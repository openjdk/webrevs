{"files":[{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3654,2 +3653,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3663,0 +3663,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3694,2 +3712,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3731,2 +3750,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3740,0 +3760,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3771,2 +3809,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3808,2 +3847,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3817,0 +3857,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3848,2 +3906,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3885,2 +3944,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3894,0 +3954,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3925,2 +4003,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3962,2 +4041,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3971,0 +4051,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4002,2 +4100,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4039,2 +4138,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4048,0 +4148,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4079,2 +4197,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4116,2 +4235,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4125,0 +4245,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4156,2 +4294,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4193,2 +4332,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4202,0 +4342,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4233,2 +4391,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4270,2 +4429,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4279,0 +4439,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4310,2 +4488,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4347,2 +4526,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4356,0 +4536,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4387,2 +4585,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4472,2 +4671,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4481,0 +4681,18 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4511,2 +4729,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6470,87 +6689,0 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            byte x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((byte)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((byte)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Byte.MIN_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Byte.MAX_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((byte)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((byte)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((byte) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((byte)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        VectorMask<Byte> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3654,2 +3653,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3663,0 +3663,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3694,2 +3712,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3731,2 +3750,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3740,0 +3760,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3771,2 +3809,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3808,2 +3847,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3817,0 +3857,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3848,2 +3906,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3885,2 +3944,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3894,0 +3954,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3925,2 +4003,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3962,2 +4041,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3971,0 +4051,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4002,2 +4100,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4039,2 +4138,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4048,0 +4148,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4079,2 +4197,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4116,2 +4235,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4125,0 +4245,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4156,2 +4294,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4193,2 +4332,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4202,0 +4342,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4233,2 +4391,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4270,2 +4429,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4279,0 +4439,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4310,2 +4488,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4347,2 +4526,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4356,0 +4536,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4387,2 +4585,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4472,2 +4671,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4481,0 +4681,18 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4511,2 +4729,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6470,87 +6689,0 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            byte x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((byte)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((byte)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Byte.MIN_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Byte.MAX_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((byte)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((byte)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((byte) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((byte)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        VectorMask<Byte> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3654,2 +3653,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3663,0 +3663,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3694,2 +3712,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3731,2 +3750,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3740,0 +3760,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3771,2 +3809,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3808,2 +3847,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3817,0 +3857,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3848,2 +3906,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3885,2 +3944,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3894,0 +3954,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3925,2 +4003,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3962,2 +4041,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3971,0 +4051,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4002,2 +4100,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4039,2 +4138,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4048,0 +4148,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4079,2 +4197,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4116,2 +4235,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4125,0 +4245,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4156,2 +4294,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4193,2 +4332,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4202,0 +4342,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4233,2 +4391,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4270,2 +4429,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4279,0 +4439,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4310,2 +4488,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4347,2 +4526,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4356,0 +4536,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4387,2 +4585,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4472,2 +4671,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4481,0 +4681,18 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4511,2 +4729,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6470,87 +6689,0 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            byte x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((byte)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((byte)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Byte.MIN_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Byte.MAX_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((byte)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((byte)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((byte) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((byte)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        VectorMask<Byte> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3654,2 +3653,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3663,0 +3663,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3694,2 +3712,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3731,2 +3750,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3740,0 +3760,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3771,2 +3809,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3808,2 +3847,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3817,0 +3857,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3848,2 +3906,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3885,2 +3944,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3894,0 +3954,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3925,2 +4003,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3962,2 +4041,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3971,0 +4051,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4002,2 +4100,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4039,2 +4138,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4048,0 +4148,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4079,2 +4197,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4116,2 +4235,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4125,0 +4245,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4156,2 +4294,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4193,2 +4332,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4202,0 +4342,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4233,2 +4391,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4270,2 +4429,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4279,0 +4439,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4310,2 +4488,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4347,2 +4526,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4356,0 +4536,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4387,2 +4585,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4472,2 +4671,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4481,0 +4681,18 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4511,2 +4729,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6470,87 +6689,0 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            byte x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((byte)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((byte)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Byte.MIN_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Byte.MAX_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((byte)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((byte)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((byte) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((byte)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        VectorMask<Byte> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -3659,2 +3659,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3668,0 +3669,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3699,2 +3718,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3736,2 +3756,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3745,0 +3766,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3776,2 +3815,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3813,2 +3853,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3822,0 +3863,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3853,2 +3912,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3890,2 +3950,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3899,0 +3960,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3930,2 +4009,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3967,2 +4047,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3976,0 +4057,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4007,2 +4106,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4044,2 +4144,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4053,0 +4154,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4084,2 +4203,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (byte) Math.min(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4121,2 +4241,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4130,0 +4251,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4161,2 +4300,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (byte) Math.max(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4198,2 +4338,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4207,0 +4348,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4238,2 +4397,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (byte) VectorMath.minUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4275,2 +4435,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4284,0 +4445,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4315,2 +4494,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (byte) VectorMath.maxUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4352,2 +4532,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4361,0 +4542,18 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4392,2 +4591,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4477,2 +4677,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4486,0 +4687,18 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            byte x = a[i];\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4516,2 +4735,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6475,87 +6695,0 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            byte x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((byte)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((byte)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Byte.MIN_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Byte.MAX_VALUE, x) == x\n-            Assert.assertEquals((byte) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((byte)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((byte)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((byte) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((byte) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((byte)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<byte[]> fa) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        VectorMask<Byte> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":264,"deletions":131,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-\n-\n@@ -73,0 +71,1 @@\n+\n@@ -2421,2 +2420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2430,0 +2430,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2461,2 +2479,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2498,2 +2517,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2507,0 +2527,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2538,2 +2576,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2575,2 +2614,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2584,0 +2624,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2615,2 +2673,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2652,2 +2711,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2661,0 +2721,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2692,2 +2770,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2729,2 +2808,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2738,0 +2818,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2769,2 +2867,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4952,51 +5051,0 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            double x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((double)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Double.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Double.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((double)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-        VectorMask<Double> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":121,"deletions":73,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-\n-\n@@ -73,0 +71,1 @@\n+\n@@ -2421,2 +2420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2430,0 +2430,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2461,2 +2479,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2498,2 +2517,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2507,0 +2527,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2538,2 +2576,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2575,2 +2614,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2584,0 +2624,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2615,2 +2673,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2652,2 +2711,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2661,0 +2721,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2692,2 +2770,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2729,2 +2808,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2738,0 +2818,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2769,2 +2867,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4952,51 +5051,0 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            double x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((double)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Double.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Double.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((double)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-        VectorMask<Double> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":121,"deletions":73,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-\n-\n@@ -73,0 +71,1 @@\n+\n@@ -2421,2 +2420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2430,0 +2430,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2461,2 +2479,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2498,2 +2517,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2507,0 +2527,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2538,2 +2576,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2575,2 +2614,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2584,0 +2624,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2615,2 +2673,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2652,2 +2711,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2661,0 +2721,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2692,2 +2770,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2729,2 +2808,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2738,0 +2818,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2769,2 +2867,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4952,51 +5051,0 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            double x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((double)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Double.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Double.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((double)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-        VectorMask<Double> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":121,"deletions":73,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-\n-\n@@ -73,0 +71,1 @@\n+\n@@ -2421,2 +2420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2430,0 +2430,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2461,2 +2479,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2498,2 +2517,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2507,0 +2527,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2538,2 +2576,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2575,2 +2614,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2584,0 +2624,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2615,2 +2673,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2652,2 +2711,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2661,0 +2721,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2692,2 +2770,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2729,2 +2808,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2738,0 +2818,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2769,2 +2867,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4952,51 +5051,0 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            double x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((double)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Double.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Double.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((double)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-        VectorMask<Double> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":121,"deletions":73,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-\n@@ -78,0 +77,1 @@\n+\n@@ -2426,2 +2426,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2435,0 +2436,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2466,2 +2485,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2503,2 +2523,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2512,0 +2533,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2543,2 +2582,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2580,2 +2620,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2589,0 +2630,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2620,2 +2679,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (double) Math.min(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2657,2 +2717,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2666,0 +2727,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2697,2 +2776,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (double) Math.max(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2734,2 +2814,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2743,0 +2824,18 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            double x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2774,2 +2873,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4957,51 +5057,0 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            double x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((double)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Double.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Double.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((double) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((double)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<double[]> fa) {\n-        double[] a = fa.apply(SPECIES.length());\n-        VectorMask<Double> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":121,"deletions":72,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-\n-\n@@ -73,0 +71,1 @@\n+\n@@ -2432,2 +2431,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2441,0 +2441,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2472,2 +2490,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2509,2 +2528,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2518,0 +2538,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2549,2 +2587,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2586,2 +2625,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2595,0 +2635,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2626,2 +2684,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2663,2 +2722,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2672,0 +2732,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2703,2 +2781,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2740,2 +2819,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2749,0 +2829,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2780,2 +2878,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4921,51 +5020,0 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            float x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((float)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Float.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Float.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((float)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-        VectorMask<Float> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":121,"deletions":73,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-\n-\n@@ -73,0 +71,1 @@\n+\n@@ -2432,2 +2431,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2441,0 +2441,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2472,2 +2490,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2509,2 +2528,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2518,0 +2538,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2549,2 +2587,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2586,2 +2625,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2595,0 +2635,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2626,2 +2684,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2663,2 +2722,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2672,0 +2732,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2703,2 +2781,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2740,2 +2819,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2749,0 +2829,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2780,2 +2878,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4921,51 +5020,0 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            float x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((float)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Float.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Float.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((float)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-        VectorMask<Float> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":121,"deletions":73,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-\n-\n@@ -73,0 +71,1 @@\n+\n@@ -2432,2 +2431,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2441,0 +2441,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2472,2 +2490,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2509,2 +2528,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2518,0 +2538,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2549,2 +2587,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2586,2 +2625,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2595,0 +2635,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2626,2 +2684,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2663,2 +2722,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2672,0 +2732,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2703,2 +2781,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2740,2 +2819,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2749,0 +2829,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2780,2 +2878,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4921,51 +5020,0 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            float x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((float)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Float.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Float.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((float)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-        VectorMask<Float> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":121,"deletions":73,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-\n-\n@@ -73,0 +71,1 @@\n+\n@@ -2432,2 +2431,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2441,0 +2441,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2472,2 +2490,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2509,2 +2528,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2518,0 +2538,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2549,2 +2587,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2586,2 +2625,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2595,0 +2635,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2626,2 +2684,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2663,2 +2722,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2672,0 +2732,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2703,2 +2781,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2740,2 +2819,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2749,0 +2829,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2780,2 +2878,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4921,51 +5020,0 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            float x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((float)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Float.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Float.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((float)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-        VectorMask<Float> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":121,"deletions":73,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-\n@@ -78,0 +77,1 @@\n+\n@@ -2437,2 +2437,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2446,0 +2447,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2477,2 +2496,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2514,2 +2534,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2523,0 +2544,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2554,2 +2593,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2591,2 +2631,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2600,0 +2641,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2631,2 +2690,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (float) Math.min(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2668,2 +2728,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2677,0 +2738,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2708,2 +2787,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (float) Math.max(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2745,2 +2825,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2754,0 +2835,18 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            float x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2785,2 +2884,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4926,51 +5026,0 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            float x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((float)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Float.NEGATIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Float.POSITIVE_INFINITY, x) == x\n-            Assert.assertEquals((float) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((float)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<float[]> fa) {\n-        float[] a = fa.apply(SPECIES.length());\n-        VectorMask<Float> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":121,"deletions":72,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3698,2 +3697,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3707,0 +3707,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3738,2 +3756,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3775,2 +3794,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3784,0 +3804,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3815,2 +3853,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3852,2 +3891,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3861,0 +3901,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3892,2 +3950,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3929,2 +3988,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3938,0 +3998,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3969,2 +4047,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4006,2 +4085,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4015,0 +4095,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4046,2 +4144,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4083,2 +4182,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4092,0 +4192,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4123,2 +4241,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4160,2 +4279,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4169,0 +4289,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4200,2 +4338,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4237,2 +4376,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4246,0 +4386,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4277,2 +4435,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4314,2 +4473,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4323,0 +4483,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4354,2 +4532,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4391,2 +4570,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4400,0 +4580,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4431,2 +4629,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4516,2 +4715,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4525,0 +4725,18 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4555,2 +4773,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6514,87 +6733,0 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((int)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((int)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Integer.MIN_VALUE, x) == x\n-            Assert.assertEquals((int) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Integer.MAX_VALUE, x) == x\n-            Assert.assertEquals((int) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((int)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((int)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((int) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((int)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-        VectorMask<Integer> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3698,2 +3697,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3707,0 +3707,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3738,2 +3756,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3775,2 +3794,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3784,0 +3804,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3815,2 +3853,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3852,2 +3891,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3861,0 +3901,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3892,2 +3950,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3929,2 +3988,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3938,0 +3998,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3969,2 +4047,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4006,2 +4085,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4015,0 +4095,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4046,2 +4144,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4083,2 +4182,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4092,0 +4192,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4123,2 +4241,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4160,2 +4279,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4169,0 +4289,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4200,2 +4338,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4237,2 +4376,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4246,0 +4386,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4277,2 +4435,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4314,2 +4473,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4323,0 +4483,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4354,2 +4532,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4391,2 +4570,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4400,0 +4580,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4431,2 +4629,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4516,2 +4715,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4525,0 +4725,18 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4555,2 +4773,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6514,87 +6733,0 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((int)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((int)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Integer.MIN_VALUE, x) == x\n-            Assert.assertEquals((int) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Integer.MAX_VALUE, x) == x\n-            Assert.assertEquals((int) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((int)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((int)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((int) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((int)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-        VectorMask<Integer> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3698,2 +3697,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3707,0 +3707,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3738,2 +3756,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3775,2 +3794,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3784,0 +3804,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3815,2 +3853,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3852,2 +3891,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3861,0 +3901,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3892,2 +3950,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3929,2 +3988,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3938,0 +3998,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3969,2 +4047,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4006,2 +4085,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4015,0 +4095,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4046,2 +4144,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4083,2 +4182,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4092,0 +4192,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4123,2 +4241,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4160,2 +4279,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4169,0 +4289,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4200,2 +4338,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4237,2 +4376,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4246,0 +4386,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4277,2 +4435,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4314,2 +4473,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4323,0 +4483,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4354,2 +4532,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4391,2 +4570,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4400,0 +4580,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4431,2 +4629,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4516,2 +4715,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4525,0 +4725,18 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4555,2 +4773,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6514,87 +6733,0 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((int)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((int)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Integer.MIN_VALUE, x) == x\n-            Assert.assertEquals((int) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Integer.MAX_VALUE, x) == x\n-            Assert.assertEquals((int) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((int)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((int)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((int) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((int)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-        VectorMask<Integer> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3698,2 +3697,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3707,0 +3707,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3738,2 +3756,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3775,2 +3794,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3784,0 +3804,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3815,2 +3853,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3852,2 +3891,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3861,0 +3901,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3892,2 +3950,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3929,2 +3988,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3938,0 +3998,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3969,2 +4047,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4006,2 +4085,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4015,0 +4095,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4046,2 +4144,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4083,2 +4182,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4092,0 +4192,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4123,2 +4241,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4160,2 +4279,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4169,0 +4289,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4200,2 +4338,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4237,2 +4376,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4246,0 +4386,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4277,2 +4435,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4314,2 +4473,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4323,0 +4483,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4354,2 +4532,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4391,2 +4570,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4400,0 +4580,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4431,2 +4629,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4516,2 +4715,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4525,0 +4725,18 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4555,2 +4773,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6514,87 +6733,0 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((int)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((int)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Integer.MIN_VALUE, x) == x\n-            Assert.assertEquals((int) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Integer.MAX_VALUE, x) == x\n-            Assert.assertEquals((int) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((int)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((int)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((int) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((int)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-        VectorMask<Integer> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -3703,2 +3703,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3712,0 +3713,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3743,2 +3762,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3780,2 +3800,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3789,0 +3810,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3820,2 +3859,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3857,2 +3897,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3866,0 +3907,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3897,2 +3956,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3934,2 +3994,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3943,0 +4004,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3974,2 +4053,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4011,2 +4091,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4020,0 +4101,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4051,2 +4150,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4088,2 +4188,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4097,0 +4198,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4128,2 +4247,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (int) Math.min(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4165,2 +4285,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4174,0 +4295,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4205,2 +4344,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (int) Math.max(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4242,2 +4382,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4251,0 +4392,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4282,2 +4441,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (int) VectorMath.minUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4319,2 +4479,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4328,0 +4489,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4359,2 +4538,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (int) VectorMath.maxUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4396,2 +4576,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4405,0 +4586,18 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4436,2 +4635,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4521,2 +4721,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4530,0 +4731,18 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int x = a[i];\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4560,2 +4779,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6519,87 +6739,0 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((int)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((int)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Integer.MIN_VALUE, x) == x\n-            Assert.assertEquals((int) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Integer.MAX_VALUE, x) == x\n-            Assert.assertEquals((int) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((int)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((int)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((int) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((int) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((int)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<int[]> fa) {\n-        int[] a = fa.apply(SPECIES.length());\n-        VectorMask<Integer> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":264,"deletions":131,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3720,2 +3719,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3729,0 +3729,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3760,2 +3778,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3797,2 +3816,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3806,0 +3826,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3837,2 +3875,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3874,2 +3913,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3883,0 +3923,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3914,2 +3972,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3951,2 +4010,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3960,0 +4020,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3991,2 +4069,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4028,2 +4107,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4037,0 +4117,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4068,2 +4166,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4105,2 +4204,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4114,0 +4214,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4145,2 +4263,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4182,2 +4301,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4191,0 +4311,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4222,2 +4360,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4259,2 +4398,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4268,0 +4408,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4299,2 +4457,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4336,2 +4495,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4345,0 +4505,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4376,2 +4554,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4413,2 +4592,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4422,0 +4602,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4453,2 +4651,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4538,2 +4737,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4547,0 +4747,18 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4577,2 +4795,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6466,87 +6685,0 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((long)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((long)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Long.MIN_VALUE, x) == x\n-            Assert.assertEquals((long) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Long.MAX_VALUE, x) == x\n-            Assert.assertEquals((long) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((long)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((long)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((long) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((long)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-        VectorMask<Long> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3720,2 +3719,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3729,0 +3729,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3760,2 +3778,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3797,2 +3816,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3806,0 +3826,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3837,2 +3875,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3874,2 +3913,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3883,0 +3923,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3914,2 +3972,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3951,2 +4010,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3960,0 +4020,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3991,2 +4069,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4028,2 +4107,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4037,0 +4117,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4068,2 +4166,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4105,2 +4204,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4114,0 +4214,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4145,2 +4263,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4182,2 +4301,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4191,0 +4311,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4222,2 +4360,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4259,2 +4398,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4268,0 +4408,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4299,2 +4457,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4336,2 +4495,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4345,0 +4505,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4376,2 +4554,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4413,2 +4592,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4422,0 +4602,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4453,2 +4651,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4538,2 +4737,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4547,0 +4747,18 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4577,2 +4795,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6466,87 +6685,0 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((long)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((long)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Long.MIN_VALUE, x) == x\n-            Assert.assertEquals((long) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Long.MAX_VALUE, x) == x\n-            Assert.assertEquals((long) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((long)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((long)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((long) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((long)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-        VectorMask<Long> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3720,2 +3719,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3729,0 +3729,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3760,2 +3778,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3797,2 +3816,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3806,0 +3826,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3837,2 +3875,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3874,2 +3913,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3883,0 +3923,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3914,2 +3972,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3951,2 +4010,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3960,0 +4020,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3991,2 +4069,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4028,2 +4107,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4037,0 +4117,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4068,2 +4166,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4105,2 +4204,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4114,0 +4214,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4145,2 +4263,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4182,2 +4301,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4191,0 +4311,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4222,2 +4360,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4259,2 +4398,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4268,0 +4408,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4299,2 +4457,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4336,2 +4495,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4345,0 +4505,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4376,2 +4554,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4413,2 +4592,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4422,0 +4602,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4453,2 +4651,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4538,2 +4737,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4547,0 +4747,18 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4577,2 +4795,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6466,87 +6685,0 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((long)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((long)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Long.MIN_VALUE, x) == x\n-            Assert.assertEquals((long) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Long.MAX_VALUE, x) == x\n-            Assert.assertEquals((long) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((long)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((long)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((long) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((long)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-        VectorMask<Long> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3720,2 +3719,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3729,0 +3729,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3760,2 +3778,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3797,2 +3816,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3806,0 +3826,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3837,2 +3875,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3874,2 +3913,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3883,0 +3923,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3914,2 +3972,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3951,2 +4010,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3960,0 +4020,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3991,2 +4069,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4028,2 +4107,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4037,0 +4117,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4068,2 +4166,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4105,2 +4204,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4114,0 +4214,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4145,2 +4263,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4182,2 +4301,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4191,0 +4311,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4222,2 +4360,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4259,2 +4398,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4268,0 +4408,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4299,2 +4457,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4336,2 +4495,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4345,0 +4505,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4376,2 +4554,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4413,2 +4592,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4422,0 +4602,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4453,2 +4651,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4538,2 +4737,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4547,0 +4747,18 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4577,2 +4795,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6466,87 +6685,0 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((long)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((long)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Long.MIN_VALUE, x) == x\n-            Assert.assertEquals((long) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Long.MAX_VALUE, x) == x\n-            Assert.assertEquals((long) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((long)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((long)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((long) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((long)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-        VectorMask<Long> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -3725,2 +3725,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3734,0 +3735,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3765,2 +3784,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3802,2 +3822,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3811,0 +3832,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3842,2 +3881,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3879,2 +3919,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3888,0 +3929,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3919,2 +3978,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3956,2 +4016,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3965,0 +4026,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3996,2 +4075,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4033,2 +4113,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4042,0 +4123,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4073,2 +4172,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4110,2 +4210,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4119,0 +4220,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4150,2 +4269,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (long) Math.min(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4187,2 +4307,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4196,0 +4317,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4227,2 +4366,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (long) Math.max(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4264,2 +4404,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4273,0 +4414,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4304,2 +4463,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (long) VectorMath.minUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4341,2 +4501,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4350,0 +4511,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4381,2 +4560,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (long) VectorMath.maxUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4418,2 +4598,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4427,0 +4608,18 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4458,2 +4657,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4543,2 +4743,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4552,0 +4753,18 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long x = a[i];\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4582,2 +4801,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6471,87 +6691,0 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((long)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((long)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Long.MIN_VALUE, x) == x\n-            Assert.assertEquals((long) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Long.MAX_VALUE, x) == x\n-            Assert.assertEquals((long) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((long)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((long)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((long) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((long) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((long)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<long[]> fa) {\n-        long[] a = fa.apply(SPECIES.length());\n-        VectorMask<Long> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":264,"deletions":131,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3645,2 +3644,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3654,0 +3654,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3685,2 +3703,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3722,2 +3741,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3731,0 +3751,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3762,2 +3800,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3799,2 +3838,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3808,0 +3848,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3839,2 +3897,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3876,2 +3935,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3885,0 +3945,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3916,2 +3994,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3953,2 +4032,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3962,0 +4042,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3993,2 +4091,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4030,2 +4129,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4039,0 +4139,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4070,2 +4188,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4107,2 +4226,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4116,0 +4236,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4147,2 +4285,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4184,2 +4323,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4193,0 +4333,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4224,2 +4382,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4261,2 +4420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4270,0 +4430,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4301,2 +4479,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4338,2 +4517,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4347,0 +4527,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4378,2 +4576,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4463,2 +4662,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4472,0 +4672,18 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4502,2 +4720,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6461,87 +6680,0 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            short x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((short)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((short)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Short.MIN_VALUE, x) == x\n-            Assert.assertEquals((short) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Short.MAX_VALUE, x) == x\n-            Assert.assertEquals((short) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((short)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((short)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((short) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((short)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-        VectorMask<Short> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3645,2 +3644,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3654,0 +3654,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3685,2 +3703,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3722,2 +3741,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3731,0 +3751,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3762,2 +3800,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3799,2 +3838,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3808,0 +3848,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3839,2 +3897,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3876,2 +3935,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3885,0 +3945,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3916,2 +3994,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3953,2 +4032,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3962,0 +4042,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3993,2 +4091,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4030,2 +4129,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4039,0 +4139,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4070,2 +4188,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4107,2 +4226,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4116,0 +4236,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4147,2 +4285,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4184,2 +4323,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4193,0 +4333,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4224,2 +4382,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4261,2 +4420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4270,0 +4430,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4301,2 +4479,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4338,2 +4517,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4347,0 +4527,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4378,2 +4576,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4463,2 +4662,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4472,0 +4672,18 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4502,2 +4720,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6461,87 +6680,0 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            short x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((short)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((short)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Short.MIN_VALUE, x) == x\n-            Assert.assertEquals((short) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Short.MAX_VALUE, x) == x\n-            Assert.assertEquals((short) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((short)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((short)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((short) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((short)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-        VectorMask<Short> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3645,2 +3644,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3654,0 +3654,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3685,2 +3703,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3722,2 +3741,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3731,0 +3751,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3762,2 +3800,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3799,2 +3838,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3808,0 +3848,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3839,2 +3897,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3876,2 +3935,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3885,0 +3945,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3916,2 +3994,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3953,2 +4032,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3962,0 +4042,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3993,2 +4091,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4030,2 +4129,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4039,0 +4139,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4070,2 +4188,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4107,2 +4226,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4116,0 +4236,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4147,2 +4285,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4184,2 +4323,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4193,0 +4333,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4224,2 +4382,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4261,2 +4420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4270,0 +4430,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4301,2 +4479,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4338,2 +4517,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4347,0 +4527,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4378,2 +4576,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4463,2 +4662,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4472,0 +4672,18 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4502,2 +4720,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6461,87 +6680,0 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            short x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((short)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((short)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Short.MIN_VALUE, x) == x\n-            Assert.assertEquals((short) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Short.MAX_VALUE, x) == x\n-            Assert.assertEquals((short) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((short)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((short)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((short) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((short)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-        VectorMask<Short> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -3645,2 +3644,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3654,0 +3654,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3685,2 +3703,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3722,2 +3741,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3731,0 +3751,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3762,2 +3800,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3799,2 +3838,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3808,0 +3848,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3839,2 +3897,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3876,2 +3935,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3885,0 +3945,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3916,2 +3994,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3953,2 +4032,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3962,0 +4042,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3993,2 +4091,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4030,2 +4129,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4039,0 +4139,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4070,2 +4188,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4107,2 +4226,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4116,0 +4236,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4147,2 +4285,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4184,2 +4323,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4193,0 +4333,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4224,2 +4382,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4261,2 +4420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4270,0 +4430,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4301,2 +4479,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4338,2 +4517,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4347,0 +4527,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4378,2 +4576,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4463,2 +4662,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4472,0 +4672,18 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4502,2 +4720,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6461,87 +6680,0 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            short x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((short)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((short)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Short.MIN_VALUE, x) == x\n-            Assert.assertEquals((short) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Short.MAX_VALUE, x) == x\n-            Assert.assertEquals((short) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((short)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((short)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((short) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((short)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-        VectorMask<Short> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":264,"deletions":132,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -3650,2 +3650,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3659,0 +3660,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3690,2 +3709,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-                ra &= r[i];\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3727,2 +3747,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3736,0 +3757,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3767,2 +3806,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-                ra |= r[i];\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3804,2 +3844,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3813,0 +3854,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3844,2 +3903,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-                ra ^= r[i];\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3881,2 +3941,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3890,0 +3951,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3921,2 +4000,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-                ra += r[i];\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3958,2 +4038,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -3967,0 +4048,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3998,2 +4097,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-                ra *= r[i];\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4035,2 +4135,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4044,0 +4145,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4075,2 +4194,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-                ra = (short) Math.min(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4112,2 +4232,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4121,0 +4242,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4152,2 +4291,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-                ra = (short) Math.max(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4189,2 +4329,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4198,0 +4339,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4229,2 +4388,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-                ra = (short) VectorMath.minUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4266,2 +4426,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4275,0 +4436,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4306,2 +4485,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-                ra = (short) VectorMath.maxUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4343,2 +4523,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4352,0 +4533,18 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4383,2 +4582,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-                ra = firstNonZero(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4468,2 +4668,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4477,0 +4678,18 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            short x = a[i];\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4507,2 +4726,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, r[i]);\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -6466,87 +6686,0 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            short x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals((short)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals((short)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max(Short.MIN_VALUE, x) == x\n-            Assert.assertEquals((short) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min(Short.MAX_VALUE, x) == x\n-            Assert.assertEquals((short) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals((short)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals((short)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals((short) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals((short) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals((short)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<short[]> fa) {\n-        short[] a = fa.apply(SPECIES.length());\n-        VectorMask<Short> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":264,"deletions":131,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -641,3 +641,0 @@\n-# Identity value tests\n-gen_op_tmpl \"Identity-test\" \"Identity\" \"\" \"\"\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -11,2 +11,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n-                ra = [[TEST_OP]](ra, r[i]);\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+                r[i] = v;\n+                ra = [[TEST_OP]](ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-Masked-op-func.template","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -11,2 +11,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n-                ra [[TEST_OP]]= r[i];\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+                r[i] = v;\n+                ra [[TEST_OP]]= v;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-Masked-op.template","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -9,2 +9,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]]);\n-                ra = [[TEST_OP]](ra, r[i]);\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]]);\n+                r[i] = v;\n+                ra = [[TEST_OP]](ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-op-func.template","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -9,2 +9,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]]);\n-                ra [[TEST_OP]]= r[i];\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]]);\n+                r[i] = v;\n+                ra [[TEST_OP]]= v;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-op.template","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -11,2 +11,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n-                ra = [[TEST_OP]](ra, r[i]);\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+                r[i] = v;\n+                ra = [[TEST_OP]](ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingReduction-Masked-op.template","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -9,2 +9,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]]);\n-                ra = [[TEST_OP]](ra, r[i]);\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]]);\n+                r[i] = v;\n+                ra = [[TEST_OP]](ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingReduction-op.template","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\n-    @Test(dataProvider = \"$type$UnaryOpProvider\")\n-    static void testIdentityValues(IntFunction<$type$[]> fa) {\n-        $type$[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i++) {\n-            $type$ x = a[i];\n-\n-            \/\/ ADD identity: 0 + x == x\n-            Assert.assertEquals(($type$)(ADD_IDENTITY + x), x,\n-                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n-#if[BITWISE]\n-\n-            \/\/ AND identity: -1 & x == x\n-            Assert.assertEquals(($type$)(AND_IDENTITY & x), x,\n-                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n-#end[BITWISE]\n-\n-            \/\/ FIRST_NONZERO identity: firstNonZero(0, x) == x\n-            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,\n-                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MAX identity: max($Wideboxtype$.$MinValue$, x) == x\n-            Assert.assertEquals(($type$) Math.max(MAX_IDENTITY, x), x,\n-                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MIN identity: min($Wideboxtype$.$MaxValue$, x) == x\n-            Assert.assertEquals(($type$) Math.min(MIN_IDENTITY, x), x,\n-                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ MUL identity: 1 * x == x\n-            Assert.assertEquals(($type$)(MUL_IDENTITY * x), x,\n-                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n-#if[BITWISE]\n-\n-            \/\/ OR identity: 0 | x == x\n-            Assert.assertEquals(($type$)(OR_IDENTITY | x), x,\n-                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ SUADD identity: addSaturatingUnsigned(0, x) == x\n-            Assert.assertEquals(($type$) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,\n-                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMAX identity: maxUnsigned(0, x) == x\n-            Assert.assertEquals(($type$) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,\n-                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ UMIN identity: minUnsigned(-1, x) == x\n-            Assert.assertEquals(($type$) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,\n-                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n-\n-            \/\/ XOR identity: 0 ^ x == x\n-            Assert.assertEquals(($type$)(XOR_IDENTITY ^ x), x,\n-                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n-#end[BITWISE]\n-        }\n-    }\n-\n-    @Test(dataProvider = \"$type$UnaryOpProvider\")\n-    static void testMaskedReductionIdentityAllFalse(IntFunction<$type$[]> fa) {\n-        $type$[] a = fa.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> allFalseMask = SPECIES.maskAll(false);\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-\n-            \/\/ When mask is all false, reduction should return identity value\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,\n-                                \"ADD with all-false mask should return ADD_IDENTITY\");\n-#if[BITWISE]\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,\n-                                \"AND with all-false mask should return AND_IDENTITY\");\n-#end[BITWISE]\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,\n-                                \"FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,\n-                                \"MAX with all-false mask should return MAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,\n-                                \"MIN with all-false mask should return MIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,\n-                                \"MUL with all-false mask should return MUL_IDENTITY\");\n-#if[BITWISE]\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,\n-                                \"OR with all-false mask should return OR_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,\n-                                \"SUADD with all-false mask should return SUADD_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,\n-                                \"UMAX with all-false mask should return UMAX_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,\n-                                \"UMIN with all-false mask should return UMIN_IDENTITY\");\n-            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,\n-                                \"XOR with all-false mask should return XOR_IDENTITY\");\n-#end[BITWISE]\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Identity-test.template","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -8,0 +8,18 @@\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]ReduceIdentityValueTests(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ id = [[TEST_INIT]];\n+\n+        Assert.assertEquals([[TEST_OP]](id, id), id,\n+                            \"[[TEST]]([[TEST_INIT]], [[TEST_INIT]]) != [[TEST_INIT]]\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            $type$ x = a[i];\n+            Assert.assertEquals([[TEST_OP]](id, x), x,\n+                                \"[[TEST]]([[TEST_INIT]], \" + x + \") != \" + x);\n+\n+            Assert.assertEquals([[TEST_OP]](x, id), x,\n+                                \"[[TEST]](\" + x + \", [[TEST_INIT]]) != \" + x);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-op-func.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -12,0 +12,18 @@\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]ReduceIdentityValueTests(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ id = [[TEST_INIT]];\n+\n+        Assert.assertEquals(($type$) (id [[TEST_OP]] id), id,\n+                            \"[[TEST]]([[TEST_INIT]], [[TEST_INIT]]) != [[TEST_INIT]]\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            $type$ x = a[i];\n+            Assert.assertEquals(($type$) (id [[TEST_OP]] x), x,\n+                                \"[[TEST]]([[TEST_INIT]], \" + x + \") != \" + x);\n+\n+            Assert.assertEquals(($type$) (x [[TEST_OP]] id), x,\n+                                \"[[TEST]](\" + x + \", [[TEST_INIT]]) != \" + x);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-op.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -8,0 +8,18 @@\n+\n+    @Test(dataProvider = \"$type$SaturatingUnaryOpProvider\")\n+    static void [[TEST]]ReduceIdentityValueTests(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ id = [[TEST_INIT]];\n+\n+        Assert.assertEquals([[TEST_OP]](id, id), id,\n+                            \"[[TEST]]([[TEST_INIT]], [[TEST_INIT]]) != [[TEST_INIT]]\");\n+\n+        for (int i = 0; i < a.length; i++) {\n+            $type$ x = a[i];\n+            Assert.assertEquals([[TEST_OP]](id, x), x,\n+                                \"[[TEST]]([[TEST_INIT]], \" + x + \") != \" + x);\n+\n+            Assert.assertEquals([[TEST_OP]](x, id), x,\n+                                \"[[TEST]](\" + x + \", [[TEST_INIT]]) != \" + x);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingReduction-op.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-\n@@ -91,0 +90,1 @@\n+\n@@ -97,1 +97,0 @@\n-\n@@ -99,0 +98,1 @@\n+\n@@ -119,0 +119,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}