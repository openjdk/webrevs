{"files":[{"patch":"@@ -95,0 +95,2 @@\n+  bool has_lock = false;\n+  bool has_unlock = false;\n@@ -103,0 +105,6 @@\n+          if (alock->is_Unlock()) {\n+            has_unlock = true;\n+          } else {\n+            assert(alock->is_Lock(), \"only Lock node expected\");\n+            has_lock = true;\n+          }\n@@ -123,0 +131,6 @@\n+  if (has_lock != has_unlock) {\n+    \/\/ Unbalanced locking region.\n+    \/\/ Can happen when locks coarsening optimization eliminated\n+    \/\/ pair of Unlock\/Lock nodes from adjacent locking regions.\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324969\n+ * @summary C2 incorrectly marks unbalanced nested locks for elimination.\n+ * @requires vm.compMode != \"Xint\"\n+ * @run main\/othervm -XX:-BackgroundCompilation TestNestedLocksElimination\n+ *\/\n+\n+public class TestNestedLocksElimination {\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 12000; ++i) {\n+            test1(-1);\n+            test2(-1);\n+        }\n+    }\n+\n+    static synchronized int methodA(int var) {\n+        return var;\n+    }\n+\n+    static synchronized int methodB(int var) {\n+        return var;\n+    }\n+\n+    static int varA = 0;\n+    static int varB = 0;\n+\n+    static void test1(int var) {\n+        synchronized (TestNestedLocksElimination.class) {\n+            for (int i2 = 0; i2 < 3; i2++) { \/\/ Fully unrolled\n+                 varA = methodA(i2);         \/\/ Nested synchronized methods also use\n+                 varB = i2 + methodB(var);   \/\/ TestNestedLocksElimination.class for lock\n+            }\n+        }\n+        TestNestedLocksElimination t = new TestNestedLocksElimination(); \/\/ Triggers EA\n+    }\n+\n+    static boolean test2(int var) {\n+        synchronized (TestNestedLocksElimination.class) {\n+            for (int i1 = 0; i1 < 100; i1++) {\n+                switch (42) {\n+                case 42:\n+                    short[] sArr = new short[256]; \/\/ Big enough to avoid scalarization checks\n+                case 50:\n+                    for (int i2 = 2; i2 < 8; i2 += 2) { \/\/ Fully unrolled\n+                        for (int i3 = 1;;) {\n+                            int var1 = methodA(i2);\n+                            int var2 = i2 + methodB(i3);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return var > 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestNestedLocksElimination.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}