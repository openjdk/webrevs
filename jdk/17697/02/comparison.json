{"files":[{"patch":"@@ -59,0 +59,1 @@\n+#include \"opto\/locknode.hpp\"\n@@ -4951,0 +4952,28 @@\n+\/\/ Mark locking regions (identified by BoxLockNode) as coarsened\n+\/\/ if locks coarsening optimization removed lock\/unlock from them.\n+\/\/ Such regions become unbalanced and we can't execute other\n+\/\/ locks elimination optimization on them.\n+void Compile::mark_coarsened_boxes() {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    Node_List* locks_list = _coarsened_locks.at(i);\n+    uint size = locks_list->size();\n+    if (size > 0) {\n+      AbstractLockNode* alock = locks_list->at(0)->as_AbstractLock();\n+      BoxLockNode* box = alock->box_node()->as_BoxLock();\n+      if (alock->is_coarsened() && !box->is_unbalanced()) { \/\/ Not marked already\n+        assert(!box->is_eliminated(), \"regions with coarsened locks should not be marked as eliminated\");\n+        for (uint j = 1; j < size; j++) {\n+          assert(locks_list->at(j)->as_AbstractLock()->is_coarsened(), \"only coarsened locks are expected here\");\n+          BoxLockNode* this_box = locks_list->at(j)->as_AbstractLock()->box_node()->as_BoxLock();\n+          assert(!this_box->is_eliminated(), \"regions with coarsened locks should not be marked as eliminated\");\n+          if (box != this_box) {\n+            box->set_unbalanced();\n+            this_box->set_unbalanced();\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -783,0 +783,1 @@\n+  void mark_coarsened_boxes();\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"opto\/locknode.hpp\"\n@@ -2549,1 +2550,2 @@\n-        if (!alock->is_non_esc_obj()) {\n+        BoxLockNode* box = alock->box_node()->as_BoxLock();\n+        if (!box->is_unbalanced() && !alock->is_non_esc_obj()) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-                                       _slot(slot), _is_eliminated(false) {\n+                                       _slot(slot), _kind(BoxLockNode::Regular) {\n@@ -58,1 +58,1 @@\n-  return Node::hash() + _slot + (_is_eliminated ? Compile::current()->fixed_slots() : 0);\n+  return Node::hash() + _slot + (is_eliminated() ? Compile::current()->fixed_slots() : 0);\n@@ -66,1 +66,1 @@\n-  return bn._slot == _slot && bn._is_eliminated == _is_eliminated;\n+  return bn._slot == _slot && bn._kind == _kind;\n@@ -93,0 +93,3 @@\n+  if (is_unbalanced()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,6 @@\n-  bool _is_eliminated; \/\/ Associated locks were safely eliminated\n+  enum {\n+    Regular = 0,       \/\/ Normal locking region\n+    Unbalanced,        \/\/ Some lock\/unlock in region were coarsened,\n+                       \/\/ as result this region become unbalanced\n+    Eliminated         \/\/ All lock\/unlock in region were eliminated\n+  } _kind;\n@@ -60,3 +65,4 @@\n-  bool is_eliminated() const { return _is_eliminated; }\n-  \/\/ mark lock as eliminated.\n-  void set_eliminated()      { _is_eliminated = true; }\n+  bool is_eliminated() const { return _kind == Eliminated; }\n+  bool is_unbalanced() const { return _kind == Unbalanced; }\n+  void set_eliminated()      { _kind = Eliminated; }\n+  void set_unbalanced()      { _kind = Unbalanced; }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1946,0 +1946,1 @@\n+  assert(!oldbox->as_BoxLock()->is_unbalanced(), \"this should not be called for unbalanced region\");\n@@ -2036,0 +2037,3 @@\n+  if (alock->box_node()->as_BoxLock()->is_unbalanced()) {\n+    return; \/\/ Can't do any more elimination for this locking region\n+  }\n@@ -2352,0 +2356,2 @@\n+  } else {\n+    C->mark_coarsened_boxes();\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324969\n+ * @summary C2 incorrectly marks unbalanced nested locks for elimination.\n+ * @requires vm.compMode != \"Xint\"\n+ * @run main\/othervm -XX:-BackgroundCompilation TestNestedLocksElimination\n+ *\/\n+\n+public class TestNestedLocksElimination {\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 12000; ++i) {\n+            test1(-1);\n+            test2(-1);\n+        }\n+    }\n+\n+    static synchronized int methodA(int var) {\n+        return var;\n+    }\n+\n+    static synchronized int methodB(int var) {\n+        return var;\n+    }\n+\n+    static int varA = 0;\n+    static int varB = 0;\n+\n+    static void test1(int var) {\n+        synchronized (TestNestedLocksElimination.class) {\n+            for (int i2 = 0; i2 < 3; i2++) { \/\/ Fully unrolled\n+                 varA = methodA(i2);         \/\/ Nested synchronized methods also use\n+                 varB = i2 + methodB(var);   \/\/ TestNestedLocksElimination.class for lock\n+            }\n+        }\n+        TestNestedLocksElimination t = new TestNestedLocksElimination(); \/\/ Triggers EA\n+    }\n+\n+    static boolean test2(int var) {\n+        synchronized (TestNestedLocksElimination.class) {\n+            for (int i1 = 0; i1 < 100; i1++) {\n+                switch (42) {\n+                case 42:\n+                    short[] sArr = new short[256]; \/\/ Big enough to avoid scalarization checks\n+                case 50:\n+                    for (int i2 = 2; i2 < 8; i2 += 2) { \/\/ Fully unrolled\n+                        for (int i3 = 1;;) {\n+                            int var1 = methodA(i2);\n+                            int var2 = i2 + methodB(i3);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return var > 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestNestedLocksElimination.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}