{"files":[{"patch":"@@ -2005,1 +2005,1 @@\n-    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->can_eliminate_lock(this)) {\n@@ -2201,1 +2201,1 @@\n-    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->can_eliminate_lock(this)) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"opto\/locknode.hpp\"\n@@ -4870,0 +4871,4 @@\n+#ifdef ASSERT\n+    AbstractLockNode* alock = locks.at(0);\n+    BoxLockNode* box = alock->box_node()->as_BoxLock();\n+#endif\n@@ -4874,0 +4879,7 @@\n+#ifdef ASSERT\n+      BoxLockNode* this_box = lock->box_node()->as_BoxLock();\n+      if (this_box != box) {\n+        this_box->mark_unbalanced();\n+        box->mark_unbalanced();\n+      }\n+#endif\n@@ -4951,0 +4963,34 @@\n+\/\/ Mark locking regions (identified by BoxLockNode) as unbalanced if\n+\/\/ locks coarsening optimization removed Lock\/Unlock nodes from them.\n+\/\/ Such regions become unbalanced because coarsening only removes part\n+\/\/ of Lock\/Unlock nodes in region. As result we can't execute other\n+\/\/ locks elimination optimizations which assume all code paths have\n+\/\/ corresponding pair of Lock\/Unlock nodes - they are balanced.\n+void Compile::mark_unbalanced_boxes() {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    Node_List* locks_list = _coarsened_locks.at(i);\n+    uint size = locks_list->size();\n+    if (size > 0) {\n+      AbstractLockNode* alock = locks_list->at(0)->as_AbstractLock();\n+      BoxLockNode* box = alock->box_node()->as_BoxLock();\n+      if (alock->is_coarsened()) {\n+        \/\/ coarsened_locks_consistent(), which is called before this method, verifies\n+        \/\/ that the rest of Lock\/Unlock nodes on locks_list are also coarsened.\n+        assert(!box->is_eliminated(), \"regions with coarsened locks should not be marked as eliminated\");\n+        for (uint j = 1; j < size; j++) {\n+          assert(locks_list->at(j)->as_AbstractLock()->is_coarsened(), \"only coarsened locks are expected here\");\n+          BoxLockNode* this_box = locks_list->at(j)->as_AbstractLock()->box_node()->as_BoxLock();\n+          assert(!this_box->is_eliminated(), \"regions with coarsened locks should not be marked as eliminated\");\n+          if (box != this_box) {\n+            box->set_unbalanced();\n+            this_box->set_unbalanced();\n+            assert(this_box->is_marked_unbalanced(),\"inconsistency\");\n+          }\n+        }\n+        assert(box->is_unbalanced() == box->is_marked_unbalanced(),\"inconsistency\");\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -783,0 +783,1 @@\n+  void mark_unbalanced_boxes();\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"opto\/locknode.hpp\"\n@@ -2550,1 +2551,1 @@\n-          if (not_global_escape(alock->obj_node())) {\n+          if (can_eliminate_lock(alock)) {\n@@ -2883,0 +2884,7 @@\n+\/\/ Return true if locked object does not escape globally\n+\/\/ and locked code region (identified by BoxLockNode) is balanced:\n+\/\/ all compiled code paths have corresponding Lock\/Unlock pairs.\n+bool ConnectionGraph::can_eliminate_lock(AbstractLockNode* alock) {\n+  BoxLockNode* box = alock->box_node()->as_BoxLock();\n+  return !box->is_unbalanced() && not_global_escape(alock->obj_node());\n+}\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+class  AbstractLockNode;\n@@ -633,0 +634,2 @@\n+  bool can_eliminate_lock(AbstractLockNode* alock);\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-                                       _slot(slot), _is_eliminated(false) {\n+                                       _slot(slot), _kind(BoxLockNode::Regular) {\n+  DEBUG_ONLY(_marked_unbalanced = false);\n@@ -58,1 +59,1 @@\n-  return Node::hash() + _slot + (_is_eliminated ? Compile::current()->fixed_slots() : 0);\n+  return Node::hash() + _slot + (is_eliminated() ? Compile::current()->fixed_slots() : 0);\n@@ -66,1 +67,1 @@\n-  return bn._slot == _slot && bn._is_eliminated == _is_eliminated;\n+  return bn._slot == _slot && bn._kind == _kind;\n@@ -93,0 +94,3 @@\n+  if (is_unbalanced()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,9 @@\n-  bool _is_eliminated; \/\/ Associated locks were safely eliminated\n+  enum {\n+    Regular = 0,       \/\/ Normal locking region\n+    Unbalanced,        \/\/ Some lock\/unlock in region were coarsened,\n+                       \/\/ as result this region become unbalanced\n+    Eliminated         \/\/ All lock\/unlock in region were eliminated\n+  } _kind;\n+\n+  \/\/ In debug VM verify correctness of unbalanced marking\n+  DEBUG_ONLY(bool _marked_unbalanced;)\n@@ -60,3 +68,9 @@\n-  bool is_eliminated() const { return _is_eliminated; }\n-  \/\/ mark lock as eliminated.\n-  void set_eliminated()      { _is_eliminated = true; }\n+  bool is_eliminated() const { return _kind == Eliminated; }\n+  bool is_unbalanced() const { return _kind == Unbalanced; }\n+  void set_eliminated()      { _kind = Eliminated; }\n+  void set_unbalanced()      { _kind = Unbalanced; }\n+\n+#ifdef ASSERT\n+  void mark_unbalanced()            { _marked_unbalanced = true; }\n+  bool is_marked_unbalanced() const { return _marked_unbalanced; }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1946,0 +1946,1 @@\n+  assert(!oldbox->as_BoxLock()->is_unbalanced(), \"this should not be called for unbalanced region\");\n@@ -2036,0 +2037,3 @@\n+  if (alock->box_node()->as_BoxLock()->is_unbalanced()) {\n+    return; \/\/ Can't do any more elimination for this locking region\n+  }\n@@ -2352,0 +2356,5 @@\n+  } else {\n+    \/\/ After coarsened locks are eliminated locking regions\n+    \/\/ become unbalanced. We should not execute any more\n+    \/\/ locks elimination optimizations on them.\n+    C->mark_unbalanced_boxes();\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324969\n+ * @summary C2 incorrectly marks unbalanced nested locks for elimination.\n+ * @requires vm.compMode != \"Xint\"\n+ * @run main\/othervm -XX:-BackgroundCompilation TestNestedLocksElimination\n+ *\/\n+\n+public class TestNestedLocksElimination {\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 12000; ++i) {\n+            test1(-1);\n+            test2(-1);\n+        }\n+    }\n+\n+    static synchronized int methodA(int var) {\n+        return var;\n+    }\n+\n+    static synchronized int methodB(int var) {\n+        return var;\n+    }\n+\n+    static int varA = 0;\n+    static int varB = 0;\n+\n+    static void test1(int var) {\n+        synchronized (TestNestedLocksElimination.class) {\n+            for (int i2 = 0; i2 < 3; i2++) { \/\/ Fully unrolled\n+                 varA = methodA(i2);         \/\/ Nested synchronized methods also use\n+                 varB = i2 + methodB(var);   \/\/ TestNestedLocksElimination.class for lock\n+            }\n+        }\n+        TestNestedLocksElimination t = new TestNestedLocksElimination(); \/\/ Triggers EA\n+    }\n+\n+    static boolean test2(int var) {\n+        synchronized (TestNestedLocksElimination.class) {\n+            for (int i1 = 0; i1 < 100; i1++) {\n+                switch (42) {\n+                case 42:\n+                    short[] sArr = new short[256]; \/\/ Big enough to avoid scalarization checks\n+                case 50:\n+                    for (int i2 = 2; i2 < 8; i2 += 2) { \/\/ Fully unrolled\n+                        for (int i3 = 1;;) {\n+                            int var1 = methodA(i2);\n+                            int var2 = i2 + methodB(i3);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return var > 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestNestedLocksElimination.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}