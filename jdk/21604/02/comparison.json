{"files":[{"patch":"@@ -1045,1 +1045,1 @@\n-bool VectorNode::should_swap_inputs_to_help_global_value_numbering() {\n+bool VectorNode::is_commutative() {\n@@ -1101,1 +1101,1 @@\n-  if (should_swap_inputs_to_help_global_value_numbering()) {\n+  if (is_commutative()) {\n@@ -2194,0 +2194,59 @@\n+static Node* UMinMaxV_Ideal(Node* n, PhaseGVN* phase, bool can_reshape) {\n+  int vopc = n->Opcode();\n+  assert(vopc == Op_UMinV || vopc == Op_UMaxV, \"Unexpected opcode\");\n+\n+  Node* umin = nullptr;\n+  Node* umax = nullptr;\n+  int lopc = n->in(1)->Opcode();\n+  int ropc = n->in(2)->Opcode();\n+\n+  if (lopc == Op_UMinV && ropc == Op_UMaxV) {\n+    umin = n->in(1);\n+    umax = n->in(2);\n+  }\n+  else if (lopc == Op_UMaxV && ropc == Op_UMinV) {\n+    umin = n->in(2);\n+    umax = n->in(1);\n+  }\n+\n+  \/\/ UMin (UMin(a, b), UMax(a, b))  => UMin(a, b)\n+  \/\/ UMin (UMax(a, b), UMin(b, a))  => UMin(a, b)\n+  \/\/ UMax (UMin(a, b), UMax(a, b))  => UMax(a, b)\n+  \/\/ UMax (UMax(a, b), UMin(b, a))  => UMax(a, b)\n+  if (umin != nullptr && umax != nullptr) {\n+    if ((umin->in(1) == umax->in(1) && umin->in(2) == umax->in(2)) ||\n+        (umin->in(2) == umax->in(1) && umin->in(1) == umax->in(2))) {\n+      if (vopc == Op_UMinV) {\n+        return new UMinVNode(umax->in(1), umax->in(2), n->bottom_type()->is_vect());\n+      } else {\n+        return new UMaxVNode(umax->in(1), umax->in(2), n->bottom_type()->is_vect());\n+      }\n+    }\n+  }\n+\n+  return static_cast<VectorNode*>(n)->VectorNode::Ideal(phase, can_reshape);\n+}\n+\n+Node* UMinVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return UMinMaxV_Ideal(this, phase, can_reshape);\n+}\n+\n+Node* UMinVNode::Identity(PhaseGVN* phase) {\n+  \/\/ UMin (a, a) => a\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n+Node* UMaxVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return UMinMaxV_Ideal(this, phase, can_reshape);\n+}\n+\n+Node* UMaxVNode::Identity(PhaseGVN* phase) {\n+  \/\/ UMax (a, a) => a\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":61,"deletions":2,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  bool should_swap_inputs_to_help_global_value_numbering();\n+  bool is_commutative();\n@@ -619,0 +619,2 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -622,0 +624,1 @@\n+\n@@ -635,0 +638,2 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1257,0 +1257,40 @@\n+    public static final String UMIN_VB = VECTOR_PREFIX + \"UMIN_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VB, \"UMinV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMIN_VS = VECTOR_PREFIX + \"UMIN_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VS, \"UMinV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMIN_VI = VECTOR_PREFIX + \"UMIN_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VI, \"UMinV\", TYPE_INT);\n+    }\n+\n+    public static final String UMIN_VL = VECTOR_PREFIX + \"UMIN_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VL, \"UMinV\", TYPE_LONG);\n+    }\n+\n+    public static final String UMAX_VB = VECTOR_PREFIX + \"UMAX_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VB, \"UMaxV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMAX_VS = VECTOR_PREFIX + \"UMAX_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VS, \"UMaxV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMAX_VI = VECTOR_PREFIX + \"UMAX_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VI, \"UMaxV\", TYPE_INT);\n+    }\n+\n+    public static final String UMAX_VL = VECTOR_PREFIX + \"UMAX_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VL, \"UMaxV\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,472 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8342676\n+* @summary Unsigned Vector Min \/ Max transforms\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.VectorUnsignedMinMaxOperationsTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.stream.IntStream;\n+\n+public class VectorUnsignedMinMaxOperationsTest {\n+    private static final int COUNT = 2048;\n+    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n+\n+    private long[]  long_in1;\n+    private int[]   int_in1;\n+    private short[] short_in1;\n+    private byte[]  byte_in1;\n+\n+    private long[]  long_in2;\n+    private int[]   int_in2;\n+    private short[] short_in2;\n+    private byte[]  byte_in2;\n+\n+    private long[]  long_out;\n+    private int[]   int_out;\n+    private short[] short_out;\n+    private byte[]  byte_out;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+\n+    public VectorUnsignedMinMaxOperationsTest() {\n+        byte_in1  = new byte[COUNT];\n+        short_in1 = new short[COUNT];\n+        int_in1   = new int[COUNT];\n+        long_in1  = new long[COUNT];\n+\n+        byte_in2  = new byte[COUNT];\n+        short_in2 = new short[COUNT];\n+        int_in2   = new int[COUNT];\n+        long_in2  = new long[COUNT];\n+        IntStream.range(0, COUNT).forEach(\n+            i -> {\n+                if ((i & 1) == 0) {\n+                    long_in1[i] = Long.MAX_VALUE;\n+                    long_in2[i] = i;\n+                    int_in1[i]  = Integer.MAX_VALUE;\n+                    int_in2[i]  = i;\n+                    short_in1[i] = Short.MAX_VALUE;\n+                    short_in2[i] = (short)i;\n+                    byte_in1[i]  = Byte.MAX_VALUE;\n+                    byte_in2[i]  = (byte)i;\n+                } else {\n+                    long_in1[i] = Long.MIN_VALUE;\n+                    long_in2[i] = -i;\n+                    int_in1[i]  = Integer.MIN_VALUE;\n+                    int_in2[i]  = -i;\n+                    short_in1[i] = Short.MIN_VALUE;\n+                    short_in2[i] = (short)-i;\n+                    byte_in1[i]  = Byte.MIN_VALUE;\n+                    byte_in2[i]  = (byte)-i;\n+                }\n+            }\n+        );\n+        long_out  = new long[COUNT];\n+        int_out   = new int[COUNT];\n+        short_out = new short[COUNT];\n+        byte_out  = new byte[COUNT];\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VB, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                      .lanewise(VectorOperators.UMAX,\n+                                ByteVector.fromArray(bspec, byte_in2, i))\n+                      .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_byte\", when = CheckAt.COMPILED)\n+    public void umax_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VS, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                       .lanewise(VectorOperators.UMAX,\n+                                 ShortVector.fromArray(sspec, short_in2, i))\n+                       .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_short\", when = CheckAt.COMPILED)\n+    public void umax_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.maxUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_int\", when = CheckAt.COMPILED)\n+    public void umax_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                      .lanewise(VectorOperators.UMAX,\n+                                LongVector.fromArray(lspec, long_in2, i))\n+                      .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_long\", when = CheckAt.COMPILED)\n+    public void umax_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.maxUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VB, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                      .lanewise(VectorOperators.UMIN,\n+                                ByteVector.fromArray(bspec, byte_in2, i))\n+                      .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_byte\", when = CheckAt.COMPILED)\n+    public void umin_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.minUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VS, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                       .lanewise(VectorOperators.UMIN,\n+                                 ShortVector.fromArray(sspec, short_in2, i))\n+                       .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_short\", when = CheckAt.COMPILED)\n+    public void umin_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.minUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_int\", when = CheckAt.COMPILED)\n+    public void umin_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                      .lanewise(VectorOperators.UMIN,\n+                                LongVector.fromArray(lspec, long_in2, i))\n+                      .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_long\")\n+    public void umin_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.minUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+       }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1\", when = CheckAt.COMPILED)\n+    public void umin_ir_transform1_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1\", when = CheckAt.COMPILED)\n+    public void umax_ir_transform1_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \", IRNode.UMIN_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform1() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform1\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform1_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform2() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMaxV (UMinV vec2, vec1) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec2.lanewise(VectorOperators.UMIN, vec1)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform2\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform2_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in2[i], int_in1[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \", IRNode.UMIN_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform3() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMaxV (UMinV vec1, vec2) (UMinV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMIN, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform3\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform3_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.minUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform4() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMaxV vec2, vec1) (UMaxV vec1, vec2) => UMaxV vec1 vec2\n+            vec2.lanewise(VectorOperators.UMAX, vec1)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform4\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform4_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(VectorMath.maxUnsigned(int_in2[i], int_in1[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform5() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMaxV (UMinV vec1, vec2) (UMaxV vec2, vec1) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec2.lanewise(VectorOperators.UMAX, vec1))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform5\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform5_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in2[i], int_in1[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorUnsignedMinMaxOperationsTest.java","additions":472,"deletions":0,"binary":false,"changes":472,"status":"added"}]}