{"files":[{"patch":"@@ -1088,1 +1088,1 @@\n-bool VectorNode::is_commutative() {\n+bool VectorNode::should_swap_inputs_to_help_global_value_numbering() {\n@@ -1144,1 +1144,1 @@\n-  if (is_commutative()) {\n+  if (should_swap_inputs_to_help_global_value_numbering()) {\n@@ -2252,2 +2252,1 @@\n-  }\n-  else if (lopc == Op_UMaxV && ropc == Op_UMinV) {\n+  } else if (lopc == Op_UMaxV && ropc == Op_UMinV) {\n@@ -2256,0 +2255,2 @@\n+  } else {\n+    return nullptr;\n@@ -2273,1 +2274,1 @@\n-  return static_cast<VectorNode*>(n)->VectorNode::Ideal(phase, can_reshape);\n+  return nullptr;\n@@ -2277,1 +2278,4 @@\n-  return UMinMaxV_Ideal(this, phase, can_reshape);\n+  Node* progress = UMinMaxV_Ideal(this, phase, can_reshape);\n+  if (progress != nullptr) return progress;\n+\n+  return VectorNode::Ideal(phase, can_reshape);\n@@ -2289,1 +2293,4 @@\n-  return UMinMaxV_Ideal(this, phase, can_reshape);\n+  Node* progress = UMinMaxV_Ideal(this, phase, can_reshape);\n+  if (progress != nullptr) return progress;\n+\n+  return VectorNode::Ideal(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  bool is_commutative();\n+  bool should_swap_inputs_to_help_global_value_numbering();\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -576,0 +576,50 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, IRNode.VECTOR_SIZE_ANY, \" 1 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\"})\n+    public void testVectorIRSharing20(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ UMax ((UMax vec1 vec2), (UMax vec2 vec1))\n+        vec1.lanewise(VectorOperators.UMAX, vec2)\n+            .lanewise(VectorOperators.UMAX, vec2.lanewise(VectorOperators.UMAX, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing20\")\n+    public void testVectorIRSharingDriver20() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing20(i);\n+        }\n+        checkVectorIRSharing20();\n+    }\n+\n+    public void checkVectorIRSharing20() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], VectorMath.maxUnsigned(ia[i], ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, IRNode.VECTOR_SIZE_ANY, \" 1 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\"})\n+    public void testVectorIRSharing21(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ UMIN ((UMIN vec1 vec2), (UMIN vec2 vec1))\n+        vec1.lanewise(VectorOperators.UMIN, vec2)\n+            .lanewise(VectorOperators.UMIN, vec2.lanewise(VectorOperators.UMIN, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing21\")\n+    public void testVectorIRSharingDriver21() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing21(i);\n+        }\n+        checkVectorIRSharing21();\n+    }\n+\n+    public void checkVectorIRSharing21() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], VectorMath.minUnsigned(ia[i], ib[i]));\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCommutativeOperSharingTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"}]}