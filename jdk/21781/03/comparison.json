{"files":[{"patch":"@@ -273,1 +273,14 @@\n-    return 0;\n+    using spin_wait_func_ptr_t = void (*)();\n+    spin_wait_func_ptr_t func = CAST_TO_FN_PTR(spin_wait_func_ptr_t, StubRoutines::aarch64::spin_wait());\n+    assert(func != nullptr, \"StubRoutines::aarch64::spin_wait must not be null.\");\n+    (*func)();\n+    \/\/ If StubRoutines::aarch64::spin_wait consists of only a RET,\n+    \/\/ SpinPause can be considered as implemented. There will be a sequence\n+    \/\/ of instructions for:\n+    \/\/ - call of SpinPause\n+    \/\/ - load of StubRoutines::aarch64::spin_wait stub pointer\n+    \/\/ - indirect call of the stub\n+    \/\/ - return from the stub\n+    \/\/ - return from SpinPause\n+    \/\/ So '1' always is returned.\n+    return 1;\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -424,1 +424,5 @@\n-   return 0 ;\n+   \/\/ pause == rep:nop\n+   \/\/ On systems that don't support pause a rep:nop\n+   \/\/ is executed as a nop.  The rep: prefix is ignored.\n+   YieldProcessor();\n+   return 1 ;\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}