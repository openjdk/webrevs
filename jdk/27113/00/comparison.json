{"files":[{"patch":"@@ -2505,1 +2505,1 @@\n-      idx          == nullptr || !idx->is_con()) {\n+      idx          == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1420,0 +1420,5 @@\n+    public static final String VECTOR_MASK_LANE_IS_SET = PREFIX + \"VECTOR_MASK_LANE_IS_SET\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_LANE_IS_SET, \"ExtractUB\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @bug 8366588\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary VectorAPI: Re-intrinsify VectorMask.laneIsSet where the input index is a variable\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorMaskLaneIsSetTest\n+ *\/\n+\n+public class VectorMaskLaneIsSetTest {\n+    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+    static final int LENGTH = 512;\n+    static boolean[] ma;\n+    static VectorMask<Byte> mask_b;\n+    static VectorMask<Short> mask_s;\n+    static VectorMask<Integer> mask_i;\n+    static VectorMask<Long> mask_l;\n+    static VectorMask<Float> mask_f;\n+    static VectorMask<Double> mask_d;\n+\n+    static {\n+        ma = new boolean[LENGTH];\n+        for (int i = 0; i < LENGTH; i++) {\n+            ma[i] = i % 2 == 0;\n+        }\n+        mask_b = VectorMask.fromArray(B_SPECIES, ma, 0);\n+        mask_s = VectorMask.fromArray(S_SPECIES, ma, 0);\n+        mask_i = VectorMask.fromArray(I_SPECIES, ma, 0);\n+        mask_l = VectorMask.fromArray(L_SPECIES, ma, 0);\n+        mask_f = VectorMask.fromArray(F_SPECIES, ma, 0);\n+        mask_d = VectorMask.fromArray(D_SPECIES, ma, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_LANE_IS_SET, \"= 6\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_MASK_TO_LONG, \"= 6\" }, applyIfCPUFeature = { \"avx2\", \"true\" })\n+    public static void testVectorMaskLaneIsSetByte_const() {\n+        Asserts.assertEquals(ma[0], mask_b.laneIsSet(0));\n+        Asserts.assertEquals(ma[0], mask_s.laneIsSet(0));\n+        Asserts.assertEquals(ma[0], mask_i.laneIsSet(0));\n+        Asserts.assertEquals(ma[0], mask_l.laneIsSet(0));\n+        Asserts.assertEquals(ma[0], mask_f.laneIsSet(0));\n+        Asserts.assertEquals(ma[0], mask_d.laneIsSet(0));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_LANE_IS_SET, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_MASK_TO_LONG, \"= 1\" }, applyIfCPUFeature = { \"avx\", \"true\" })\n+    public static boolean testVectorMaskLaneIsSet_Byte_variable(int i) {\n+        return mask_b.laneIsSet(i);\n+    }\n+\n+    @Run(test = \"testVectorMaskLaneIsSet_Byte_variable\")\n+    public static void testVectorMaskLaneIsSet_Byte_variable_runner() {\n+        Asserts.assertEquals(ma[0], testVectorMaskLaneIsSet_Byte_variable(0));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_LANE_IS_SET, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_MASK_TO_LONG, \"= 1\" }, applyIfCPUFeature = { \"avx\", \"true\" })\n+    public static boolean testVectorMaskLaneIsSet_Short_variable(int i) {\n+        return mask_s.laneIsSet(i);\n+    }\n+\n+    @Run(test = \"testVectorMaskLaneIsSet_Short_variable\")\n+    public static void testVectorMaskLaneIsSet_Short_variable_runner() {\n+        Asserts.assertEquals(ma[0], testVectorMaskLaneIsSet_Short_variable(0));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_LANE_IS_SET, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_MASK_TO_LONG, \"= 1\" }, applyIfCPUFeature = { \"avx\", \"true\" })\n+    public static boolean testVectorMaskLaneIsSet_Int_variable(int i) {\n+        return mask_i.laneIsSet(i);\n+    }\n+\n+    @Run(test = \"testVectorMaskLaneIsSet_Int_variable\")\n+    public static void testVectorMaskLaneIsSet_Int_variable_runner() {\n+        Asserts.assertEquals(ma[0], testVectorMaskLaneIsSet_Int_variable(0));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_LANE_IS_SET, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_MASK_TO_LONG, \"= 1\" }, applyIfCPUFeature = { \"avx2\", \"true\" })\n+    public static boolean testVectorMaskLaneIsSet_Long_variable(int i) {\n+        return mask_l.laneIsSet(i);\n+    }\n+\n+    @Run(test = \"testVectorMaskLaneIsSet_Long_variable\")\n+    public static void testVectorMaskLaneIsSet_Long_variable_runner() {\n+        Asserts.assertEquals(ma[0], testVectorMaskLaneIsSet_Long_variable(0));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_LANE_IS_SET, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_MASK_TO_LONG, \"= 1\" }, applyIfCPUFeature = { \"avx\", \"true\" })\n+    public static boolean testVectorMaskLaneIsSet_Float_variable(int i) {\n+        return mask_f.laneIsSet(i);\n+    }\n+\n+    @Run(test = \"testVectorMaskLaneIsSet_Float_variable\")\n+    public static void testVectorMaskLaneIsSet_Float_variable_runner() {\n+        Asserts.assertEquals(ma[0], testVectorMaskLaneIsSet_Float_variable(0));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_LANE_IS_SET, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_MASK_TO_LONG, \"= 1\" }, applyIfCPUFeature = { \"avx2\", \"true\" })\n+    public static boolean testVectorMaskLaneIsSet_Double_variable(int i) {\n+        return mask_d.laneIsSet(i);\n+    }\n+\n+    @Run(test = \"testVectorMaskLaneIsSet_Double_variable\")\n+    public static void testVectorMaskLaneIsSet_Double_variable_runner() {\n+        Asserts.assertEquals(ma[0], testVectorMaskLaneIsSet_Double_variable(0));\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskLaneIsSetTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n@@ -31,1 +32,3 @@\n-@Fork(jvmArgs = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgs = {\"--add-modules=jdk.incubator.vector\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorExtractBenchmark.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}