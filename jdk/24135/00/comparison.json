{"files":[{"patch":"@@ -2035,0 +2035,1 @@\n+ public:\n@@ -2040,1 +2041,0 @@\n- public:\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,4 +188,6 @@\n-  \/\/ Load stub address using toc (fixed instruction size, unlike load_const_optimized)\n-  __ calculate_address_from_global_toc(tmp, StubRoutines::method_entry_barrier(),\n-                                       true, true, false); \/\/ 2 instructions\n-  __ mtctr(tmp);\n+  if (!TrapBasedNMethodEntryBarriers) {\n+    \/\/ Load stub address using toc (fixed instruction size, unlike load_const_optimized)\n+    __ calculate_address_from_global_toc(tmp, StubRoutines::method_entry_barrier(),\n+                                         true, true, false); \/\/ 2 instructions\n+    __ mtctr(tmp);\n+  }\n@@ -199,1 +201,0 @@\n-  __ cmpw(CR0, R0, tmp);\n@@ -201,1 +202,6 @@\n-  __ bnectrl(CR0);\n+  if (TrapBasedNMethodEntryBarriers) {\n+    __ tw(Assembler::traptoLessThanUnsigned | Assembler::traptoGreaterThanUnsigned, R0, tmp);\n+  } else {\n+    __ cmpw(CR0, R0, tmp);\n+    __ bnectrl(CR0);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-    return reinterpret_cast<NativeMovRegMem*>(get_barrier_start_address() + 3 * 4);\n+    return reinterpret_cast<NativeMovRegMem*>(get_barrier_start_address() +\n+            (TrapBasedNMethodEntryBarriers ? 0 : 3) * BytesPerInstWord);\n@@ -69,3 +70,4 @@\n-    \/\/ calculate_address_from_global_toc (compound instruction)\n-    verify_op_code_manually(current_instruction, MacroAssembler::is_addis(*current_instruction));\n-    verify_op_code_manually(current_instruction, MacroAssembler::is_addi(*current_instruction));\n+    if (!TrapBasedNMethodEntryBarriers) {\n+      \/\/ calculate_address_from_global_toc (compound instruction)\n+      verify_op_code_manually(current_instruction, MacroAssembler::is_addis(*current_instruction));\n+      verify_op_code_manually(current_instruction, MacroAssembler::is_addi(*current_instruction));\n@@ -73,1 +75,2 @@\n-    verify_op_code_manually(current_instruction, MacroAssembler::is_mtctr(*current_instruction));\n+      verify_op_code_manually(current_instruction, MacroAssembler::is_mtctr(*current_instruction));\n+    }\n@@ -80,2 +83,5 @@\n-    \/\/ cmpw (mnemonic)\n-    verify_op_code(current_instruction, Assembler::CMP_OPCODE);\n+    if (TrapBasedNMethodEntryBarriers) {\n+      verify_op_code(current_instruction, Assembler::TW_OPCODE);\n+    } else {\n+      \/\/ cmpw (mnemonic)\n+      verify_op_code(current_instruction, Assembler::CMP_OPCODE);\n@@ -83,2 +89,3 @@\n-    \/\/ bnectrl (mnemonic) (weak check; not checking the exact type)\n-    verify_op_code(current_instruction, Assembler::BCCTR_OPCODE);\n+      \/\/ bnectrl (mnemonic) (weak check; not checking the exact type)\n+      verify_op_code(current_instruction, Assembler::BCCTR_OPCODE);\n+    }\n@@ -105,1 +112,2 @@\n-  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + (-8 * 4);\n+  address barrier_address = nm->code_begin() + nm->frame_complete_offset() -\n+                            (TrapBasedNMethodEntryBarriers ? 4 : 8) * BytesPerInstWord;\n@@ -107,1 +115,1 @@\n-    barrier_address -= 4; \/\/ isync (see nmethod_entry_barrier)\n+    barrier_address -= BytesPerInstWord; \/\/ isync (see nmethod_entry_barrier)\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetNMethod_ppc.cpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -148,0 +148,2 @@\n+  product(bool, TrapBasedNMethodEntryBarriers, true, DIAGNOSTIC,            \\\n+          \"Raise and handle SIGTRAP if nmethod entry barrier armed.\")       \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,6 @@\n+  bool is_sigtrap_nmethod_entry_barrier() {\n+    assert(UseSIGTRAP && TrapBasedNMethodEntryBarriers, \"precondition\");\n+    return Assembler::is_tw(long_at(0), Assembler::traptoLessThanUnsigned | Assembler::traptoGreaterThanUnsigned,\n+                            0, -1);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,2 +102,4 @@\n-    FLAG_SET_ERGO(TrapBasedNullChecks,       false);\n-    FLAG_SET_ERGO(TrapBasedICMissChecks,     false);\n+    MSG(TrapBasedNMethodEntryBarriers);\n+    FLAG_SET_ERGO(TrapBasedNullChecks,           false);\n+    FLAG_SET_ERGO(TrapBasedICMissChecks,         false);\n+    FLAG_SET_ERGO(TrapBasedNMethodEntryBarriers, false);\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -301,0 +301,11 @@\n+      \/\/ SIGTRAP-based nmethod entry barriers.\n+      else if (sig == SIGTRAP && TrapBasedNMethodEntryBarriers &&\n+               nativeInstruction_at(pc)->is_sigtrap_nmethod_entry_barrier() &&\n+               CodeCache::contains((void*) pc)) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: nmethod entry barrier at \" INTPTR_FORMAT \" (SIGTRAP)\", p2i(pc));\n+        }\n+        stub = StubRoutines::method_entry_barrier();\n+        uc->uc_mcontext.jmp_context.lr = (uintptr_t)(pc + BytesPerInstWord); \/\/ emulate call by setting LR\n+      }\n+\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -329,0 +329,11 @@\n+      \/\/ SIGTRAP-based nmethod entry barriers.\n+      else if (sig == SIGTRAP && TrapBasedNMethodEntryBarriers &&\n+               nativeInstruction_at(pc)->is_sigtrap_nmethod_entry_barrier() &&\n+               CodeCache::contains((void*) pc)) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: nmethod entry barrier at \" INTPTR_FORMAT \" (SIGTRAP)\", p2i(pc));\n+        }\n+        stub = StubRoutines::method_entry_barrier();\n+        uc->uc_mcontext.regs->link = (uintptr_t)(pc + BytesPerInstWord); \/\/ emulate call by setting LR\n+      }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}