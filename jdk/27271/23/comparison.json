{"files":[{"patch":"@@ -1041,1 +1041,1 @@\n-                rb = BigInteger.valueOf(5).pow(-exponent).multiply(compactVal);\n+                rb = fiveTo(-exponent).multiply(compactVal);\n@@ -1044,1 +1044,1 @@\n-                rb = BigInteger.TWO.pow(exponent).multiply(compactVal);\n+                rb = BigInteger.valueOf(compactVal).shiftLeft(exponent);\n@@ -1790,1 +1790,2 @@\n-        int preferredScale = saturateLong((long) this.scale - divisor.scale);\n+        long scaleDiff = (long) this.scale - divisor.scale;\n+        int preferredScale = saturateLong(scaleDiff);\n@@ -1794,20 +1795,0 @@\n-        else {\n-            \/*\n-             * If the quotient this\/divisor has a terminating decimal\n-             * expansion, the expansion can have no more than\n-             * (a.precision() + ceil(10*b.precision)\/3) digits.\n-             * Therefore, create a MathContext object with this\n-             * precision and do a divide with the UNNECESSARY rounding\n-             * mode.\n-             *\/\n-            MathContext mc = new MathContext( (int)Math.min(this.precision() +\n-                                                            (long)Math.ceil(10.0*divisor.precision()\/3.0),\n-                                                            Integer.MAX_VALUE),\n-                                              RoundingMode.UNNECESSARY);\n-            BigDecimal quotient;\n-            try {\n-                quotient = this.divide(divisor, mc);\n-            } catch (ArithmeticException e) {\n-                throw new ArithmeticException(\"Non-terminating decimal expansion; \" +\n-                                              \"no exact representable decimal result.\");\n-            }\n@@ -1815,8 +1796,39 @@\n-            int quotientScale = quotient.scale();\n-\n-            \/\/ divide(BigDecimal, mc) tries to adjust the quotient to\n-            \/\/ the desired one by removing trailing zeros; since the\n-            \/\/ exact divide method does not have an explicit digit\n-            \/\/ limit, we can add zeros too.\n-            if (preferredScale > quotientScale)\n-                return quotient.setScale(preferredScale, ROUND_UNNECESSARY);\n+        \/* The technique used is the following:\n+         * take a\/b, compute b' = b\/(2^e2 5^e5), where\n+         * e2 = max{n | b ≡ 0 mod 2^n} and e5 = max{n | b ≡ 0 mod 5^n}.\n+         * If a ≢ 0 mod b', then a\/b is not a finite decimal number. Otherwise:\n+         *   - if e2 ≤ e5, then a\/b = (a\/b') ⋅ 2^(e5-e2) \/ 10^e5;\n+         *   - if e2 > e5, then a\/b = (a\/b') ⋅ 5^(e2-e5) \/ 10^e2.\n+         *\/\n+        BigInteger b = divisor.unscaledValue();\n+        int e2 = b.getLowestSetBit();\n+        b = b.shiftRight(e2); \/\/ Remove powers of 2\n+\n+        \/\/ Remove and count powers of 5\n+        int e5 = 0;\n+        BigInteger[] qr;\n+        int i;\n+        \/\/ Factor out 5^(2^i) from b, until b ≢ 0 mod 5^(2^i).\n+        for (i = 0; ; i++) {\n+            qr = b.divideAndRemainder(fiveToTwoToThe(i));\n+            if (qr[1].signum != 0) { \/\/ non-0 remainder\n+                break;\n+            } else {\n+                b = qr[0];\n+                e5 += 1 << i;\n+            }\n+        }\n+        i--;\n+\n+        \/\/ Factor out all remaining powers of 5 from b\n+        int log5b = log5Upper(b);\n+        if (log5b < 1 << i)\n+            i = BigInteger.bitLengthForInt(log5b) - 1;\n+\n+        for (; i >= 0; i--) {\n+            qr = b.divideAndRemainder(fiveToTwoToThe(i));\n+            if (qr[1].signum == 0) { \/\/ zero remainder\n+                b = qr[0];\n+                e5 += 1 << i;\n+            }\n+        }\n@@ -1824,1 +1836,22 @@\n-            return quotient;\n+        qr = this.unscaledValue().divideAndRemainder(b);\n+        if (qr[1].signum != 0)\n+            throw new ArithmeticException(\"Non-terminating decimal expansion; \" +\n+                    \"no exact representable decimal result.\");\n+\n+        BigInteger quot = qr[0];\n+        int e10 = Math.max(e2, e5);\n+\n+        \/\/ Equalize multiplicities of 2 and 5\n+        quot = e10 == e5\n+                ? quot.shiftLeft(e10 - e2)\n+                : quot.multiply(fiveTo(e10 - e5));\n+\n+        BigDecimal res;\n+        \/\/ Adjust to preferredScale, avoiding overflow\n+        \/\/ by centering the preferred scale to zero\n+        if (preferredScale == scaleDiff) {\n+            \/\/ Avoid overflow of preferredScale + e10, the result's scale\n+            res = createAndStripZerosToMatchScale(quot, e10, 0L);\n+        } else { \/\/ scaleDiff exceeds int range\n+            int offset = checkScaleNonZero((scaleDiff + e10) - preferredScale);\n+            res = new BigDecimal(quot, offset).adjustToPreferredScale(0, 0);\n@@ -1826,0 +1859,4 @@\n+        \/\/ now res == (this\/divisor) * 10^preferredScale\n+        return preferredScale != Integer.MIN_VALUE\n+                ? res.scaleByPowerOfTen(-preferredScale)\n+                : res.scaleByPowerOfTen(Integer.MAX_VALUE).scaleByPowerOfTen(1);\n@@ -5111,0 +5148,25 @@\n+    \/**\n+     * @param n a non-negative integer\n+     * @return {@code 5^n}\n+     *\/\n+    private static BigInteger fiveTo(int n) {\n+        BigInteger pow = BigInteger.ONE;\n+        for (int i = 0; n != 0 && i < FIVE_TO_2_TO.length; i++) {\n+            if ((n & 1) != 0)\n+                pow = pow.multiply(FIVE_TO_2_TO[i]);\n+\n+            n >>= 1;\n+        }\n+\n+        BigInteger factor = FIVE_TO_2_TO[FIVE_TO_2_TO.length - 1];\n+        while (n != 0) {\n+            factor = factor.multiply(factor);\n+            if ((n & 1) != 0)\n+                pow = pow.multiply(factor);\n+\n+            n >>= 1;\n+        }\n+\n+        return pow;\n+    }\n+\n@@ -5113,0 +5175,16 @@\n+    \/**\n+     * @return {@code ⌊log5(|x|)⌋} or {@code ⌊log5(|x|)⌋ + 1}.\n+     *\/\n+    private static int log5Upper(BigInteger x) {\n+        \/* Let b = x.magBitLength(), m = ⌊log5(|x|)⌋. It can be shown that\n+         * | (b-1) * LOG_5_OF_2 - (b-1) log5(2) | < 2^(-21) (fp viz. real arithmetic).\n+         * Since (b - 1) * log5(2) < m + 1,\n+         * then Math.round((b - 1) * LOG_5_OF_2) <= m + 1.\n+         *\n+         * Since b log5(2) > m, log5(2)+2^(-21) < 1\/2\n+         * and (b-1) * LOG_5_OF_2 > [b log5(2) - log5(2)] - 2^(-21),\n+         * then Math.round((b - 1) * LOG_5_OF_2) >= m follows.\n+         *\/\n+        return (int) Math.round((x.magBitLength() - 1) * LOG_5_OF_2);\n+    }\n+\n@@ -5140,6 +5218,2 @@\n-        \/\/ Let b = intVal.bitLength(). It can be shown that\n-        \/\/ | b * LOG_5_OF_2 - b log5(2) | < 2^(-21) (fp viz. real arithmetic),\n-        \/\/ which entails m <= maxPowsOf5 <= m + 1, where maxPowsOf5 is as below.\n-        \/\/ Hence, maxPowsOf5 >= k.\n-        long maxPowsOf5 = Math.round(intVal.bitLength() * LOG_5_OF_2);\n-        remainingZeros = Math.min(remainingZeros, maxPowsOf5);\n+        \/\/ Since m <= log5Upper(intVal) <= m + 1, then log5Upper(intVal) >= k.\n+        remainingZeros = Math.min(remainingZeros, log5Upper(intVal));\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":112,"deletions":38,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -2907,1 +2907,1 @@\n-    private int magBitLength() {\n+    int magBitLength() { \/* package *\/\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4851776 4907265 6177836 6876282 8066842\n+ * @bug 4851776 4907265 6177836 6876282 8066842 8367603\n@@ -411,0 +411,21 @@\n+    private static int extremeScaleTests() {\n+        int failures = 0;\n+\n+        int max = Integer.MAX_VALUE, min = Integer.MIN_VALUE;\n+        BigDecimal[][] testCases = {\n+                { BigDecimal.TEN, BigDecimal.valueOf(1L, min), BigDecimal.valueOf(1L, max) },\n+                { BigDecimal.valueOf(1L, min), BigDecimal.valueOf(1L, 1), BigDecimal.valueOf(10L, min) }\n+        };\n+\n+        for (BigDecimal tc[] : testCases) {\n+            BigDecimal quotient = tc[0].divide(tc[1]);\n+            if (!quotient.equals(tc[2])) {\n+                failures++;\n+                System.err.println(\"Unexpected quotient from \" + tc[0] + \" \/ \" + tc[1] +\n+                                   \"; expected \" + tc[2] + \" got \" + quotient);\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n@@ -420,0 +441,1 @@\n+        failures += extremeScaleTests();\n","filename":"test\/jdk\/java\/math\/BigDecimal\/DivideTests.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.BigInteger;\n+import java.math.BigDecimal;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class BigDecimalDivide {\n+\n+    private BigDecimal[][] xsArray, sArray, mArray, lArray, xlArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        xsArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is at most 64 bits\n+         * in size\n+         *\/\n+        sArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is at most 256 bits\n+         * in size\n+         *\/\n+        mArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is at most 1024 bits\n+         * in size\n+         *\/\n+        lArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is at most 4096 bits\n+         * in size\n+         *\/\n+        xlArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is at most 16384 bits\n+         * in size\n+         *\/\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            xsArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(64), r));\n+            xsArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(64), r));\n+            sArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(256), r));\n+            sArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(256), r));\n+            mArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(1024), r));\n+            mArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(1024), r));\n+            lArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(4096), r));\n+            lArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(4096), r));\n+            xlArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(16384), r));\n+            xlArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(16384), r));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 64 bits  *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideXS(Blackhole bh) {\n+        for (BigDecimal[] s : xsArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 256 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideS(Blackhole bh) {\n+        for (BigDecimal[] s : sArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 1024 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideM(Blackhole bh) {\n+        for (BigDecimal[] s : mArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 4096 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideL(Blackhole bh) {\n+        for (BigDecimal[] s : lArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 16384 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideXL(Blackhole bh) {\n+        for (BigDecimal[] s : xlArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimalDivide.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}