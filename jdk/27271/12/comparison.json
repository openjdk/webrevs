{"files":[{"patch":"@@ -1045,1 +1045,1 @@\n-                rb = BigInteger.valueOf(5).pow(-exponent).multiply(compactVal);\n+                rb = fiveTo(-exponent).multiply(compactVal);\n@@ -1048,1 +1048,1 @@\n-                rb = BigInteger.TWO.pow(exponent).multiply(compactVal);\n+                rb = BigInteger.valueOf(compactVal).shiftLeft(exponent);\n@@ -1800,18 +1800,27 @@\n-            \/*\n-             * If the quotient this\/divisor has a terminating decimal\n-             * expansion, the expansion can have no more than\n-             * (a.precision() + ceil(10*b.precision)\/3) digits.\n-             * Therefore, create a MathContext object with this\n-             * precision and do a divide with the UNNECESSARY rounding\n-             * mode.\n-             *\/\n-            MathContext mc = new MathContext( (int)Math.min(this.precision() +\n-                                                            (long)Math.ceil(10.0*divisor.precision()\/3.0),\n-                                                            Integer.MAX_VALUE),\n-                                              RoundingMode.UNNECESSARY);\n-            BigDecimal quotient;\n-            try {\n-                quotient = this.divide(divisor, mc);\n-            } catch (ArithmeticException e) {\n-                throw new ArithmeticException(\"Non-terminating decimal expansion; \" +\n-                                              \"no exact representable decimal result.\");\n+            BigInteger den = divisor.unscaledValue();\n+            int powsOf2 = den.getLowestSetBit();\n+            den = den.shiftRight(powsOf2); \/\/ Remove powers of 2\n+\n+            int powsOf5 = 0;\n+            \/\/ Remove and count powers of 5\n+            BigInteger[] qr;\n+            int i;\n+            for (i = 0; ; i++) {\n+                final int exp = 1 << i;\n+                qr = den.divideAndRemainder(fiveToTwoToThe(i));\n+                if (qr[1].signum != 0) { \/\/ non-0 remainder\n+                    break;\n+                } else {\n+                    den = qr[0];\n+                    powsOf5 += exp;\n+                }\n+            }\n+            i--;\n+\n+            for (; i >= 0; i--) {\n+                final int exp = 1 << i;\n+                qr = den.divideAndRemainder(fiveToTwoToThe(i));\n+                if (qr[1].signum == 0) { \/\/ zero remainder\n+                    den = qr[0];\n+                    powsOf5 += exp;\n+                }\n@@ -1820,1 +1829,9 @@\n-            int quotientScale = quotient.scale();\n+            qr = this.unscaledValue().divideAndRemainder(den);\n+            if (qr[1].signum != 0)\n+                throw new ArithmeticException(\"Non-terminating decimal expansion; \" +\n+                        \"no exact representable decimal result.\");\n+\n+            BigInteger quot = qr[0];\n+            int powsOf10 = Math.max(powsOf2, powsOf5);\n+            if (powsOf10 == 0)\n+                return new BigDecimal(quot, preferredScale);\n@@ -1822,6 +1839,4 @@\n-            \/\/ divide(BigDecimal, mc) tries to adjust the quotient to\n-            \/\/ the desired one by removing trailing zeros; since the\n-            \/\/ exact divide method does not have an explicit digit\n-            \/\/ limit, we can add zeros too.\n-            if (preferredScale > quotientScale)\n-                return quotient.setScale(preferredScale, ROUND_UNNECESSARY);\n+            \/\/ Equalize multiplicities of 2 and 5\n+            quot = powsOf10 == powsOf5\n+                    ? quot.shiftLeft(powsOf10 - powsOf2)\n+                    : quot.multiply(fiveTo(powsOf10 - powsOf5));\n@@ -1829,1 +1844,1 @@\n-            return quotient;\n+            return createAndStripZerosToMatchScale(quot, preferredScale + powsOf10, preferredScale);\n@@ -5117,0 +5132,25 @@\n+    \/**\n+     * @param n a non-negative integer\n+     * @return {@code 5^n}\n+     *\/\n+    private static BigInteger fiveTo(int n) {\n+        BigInteger pow = BigInteger.ONE;\n+        for (int i = 0; n != 0 && i < FIVE_TO_2_TO.length; i++) {\n+            if ((n & 1) != 0)\n+                pow = pow.multiply(FIVE_TO_2_TO[i]);\n+\n+            n >>= 1;\n+        }\n+\n+        BigInteger factor = FIVE_TO_2_TO[FIVE_TO_2_TO.length - 1];\n+        while (n != 0) {\n+            factor = factor.multiply(factor);\n+            if ((n & 1) != 0)\n+                pow = pow.multiply(factor);\n+\n+            n >>= 1;\n+        }\n+\n+        return pow;\n+    }\n+\n@@ -5119,0 +5159,9 @@\n+    private static int log5Upper(BigInteger x) {\n+        \/\/ Let b = x.magBitLength(), m = max{n : 5^n <= |x|}. It can be shown that\n+        \/\/ | (b-1) * LOG_5_OF_2 - (b-1) log5(2) | < 2^(-21) (fp viz. real arithmetic).\n+        \/\/ Since b log5(2) > m, log5(2)+2^(-21) < 1\/2\n+        \/\/ and (b-1) * LOG_5_OF_2 > [b log5(2) - log5(2)] - 2^(-21),\n+        \/\/ then m <= Math.round((b - 1) * LOG_5_OF_2) <= m + 1 follows.\n+        return (int) Math.round((x.magBitLength() - 1) * LOG_5_OF_2);\n+    }\n+\n@@ -5146,6 +5195,2 @@\n-        \/\/ Let b = intVal.bitLength(). It can be shown that\n-        \/\/ | b * LOG_5_OF_2 - b log5(2) | < 2^(-21) (fp viz. real arithmetic),\n-        \/\/ which entails m <= maxPowsOf5 <= m + 1, where maxPowsOf5 is as below.\n-        \/\/ Hence, maxPowsOf5 >= k.\n-        long maxPowsOf5 = Math.round(intVal.bitLength() * LOG_5_OF_2);\n-        remainingZeros = Math.min(remainingZeros, maxPowsOf5);\n+        \/\/ Since m <= log5Upper(intVal) <= m + 1, then log5Upper(intVal) >= k.\n+        remainingZeros = Math.min(remainingZeros, log5Upper(intVal));\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":79,"deletions":34,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2907,1 +2907,1 @@\n-    private int magBitLength() {\n+    int magBitLength() {\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.BigInteger;\n+import java.math.BigDecimal;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class BigDecimalDivide {\n+\n+    private BigDecimal[][] xsArray, sArray, mArray, lArray, xlArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        xsArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 64 bits\n+         * in size\n+         *\/\n+        sArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 256 bits\n+         * in size\n+         *\/\n+        mArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 1024 bits\n+         * in size\n+         *\/\n+        lArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 4096 bits\n+         * in size\n+         *\/\n+        xlArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 16384 bits\n+         * in size\n+         *\/\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            xsArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(64), r));\n+            xsArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(64), r));\n+            sArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(256), r));\n+            sArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(256), r));\n+            mArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(1024), r));\n+            mArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(1024), r));\n+            lArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(4096), r));\n+            lArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(4096), r));\n+            xlArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(16384), r));\n+            xlArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(16384), r));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 64 bits  *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideXS(Blackhole bh) {\n+        for (BigDecimal[] s : xsArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 256 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideS(Blackhole bh) {\n+        for (BigDecimal[] s : sArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 1024 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideM(Blackhole bh) {\n+        for (BigDecimal[] s : mArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 4096 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideL(Blackhole bh) {\n+        for (BigDecimal[] s : lArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 16384 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideXL(Blackhole bh) {\n+        for (BigDecimal[] s : xlArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimalDivide.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}