{"files":[{"patch":"@@ -1800,0 +1800,9 @@\n+            BigDecimal a = this.stripTrailingZeros(), b = divisor.stripTrailingZeros();\n+            BigInteger aInt = a.unscaledValue(), bInt = b.unscaledValue();\n+\n+            \/\/ Remove common powers of 2\n+            int m_b = bInt.getLowestSetBit();\n+            int powsOf2 = Math.min(aInt.getLowestSetBit(), m_b);\n+            aInt = aInt.shiftRight(powsOf2);\n+            bInt = bInt.shiftRight(powsOf2);\n+            m_b -= powsOf2;\n@@ -1802,2 +1811,2 @@\n-             * expansion, the expansion can have no more than\n-             * (a.precision() + ceil(10*b.precision)\/3) digits.\n+             * expansion, the expansion can have no more than prec digits,\n+             * where prec is defined as below.\n@@ -1807,0 +1816,3 @@\n+             *\n+             * A proof for the formula can be found at the following link:\n+             * https:\/\/github.com\/user-attachments\/files\/22314648\/frazioni_decimali.pdf\n@@ -1808,4 +1820,2 @@\n-            MathContext mc = new MathContext( (int)Math.min(this.precision() +\n-                                                            (long)Math.ceil(10.0*divisor.precision()\/3.0),\n-                                                            Integer.MAX_VALUE),\n-                                              RoundingMode.UNNECESSARY);\n+            int prec = (digitLengthLower(aInt) + 1) - digitLengthLower(bInt)\n+                    + Math.max(m_b, log5Upper(bInt.shiftRight(m_b))) + 1;\n@@ -1814,1 +1824,1 @@\n-                quotient = this.divide(divisor, mc);\n+                quotient = a.divide(b, new MathContext(prec, RoundingMode.UNNECESSARY));\n@@ -1819,11 +1829,1 @@\n-\n-            int quotientScale = quotient.scale();\n-\n-            \/\/ divide(BigDecimal, mc) tries to adjust the quotient to\n-            \/\/ the desired one by removing trailing zeros; since the\n-            \/\/ exact divide method does not have an explicit digit\n-            \/\/ limit, we can add zeros too.\n-            if (preferredScale > quotientScale)\n-                return quotient.setScale(preferredScale, ROUND_UNNECESSARY);\n-\n-            return quotient;\n+            return quotient.adjustToPreferredScale(preferredScale, 0);\n@@ -5119,0 +5119,9 @@\n+    private static int log5Upper(BigInteger x) {\n+        \/\/ Let b = x.bitLength(), m = max{n : 5^n <= x}. It can be shown that\n+        \/\/ | b * LOG_5_OF_2 - b log5(2) | < 2^(-21) (fp viz. real arithmetic).\n+        \/\/ Since m < b log5(2) < m + 1, log5(2)+2^(-21) < 1\/2\n+        \/\/ and (b-1) * LOG_5_OF_2 > [b log5(2) - log5(2)] - 2^(-21),\n+        \/\/ then m <= Math.round((b - 1) * LOG_5_OF_2) <= m + 1 follows.\n+        return (int) Math.round((x.bitLength() - 1) * LOG_5_OF_2);\n+    }\n+\n@@ -5146,6 +5155,2 @@\n-        \/\/ Let b = intVal.bitLength(). It can be shown that\n-        \/\/ | b * LOG_5_OF_2 - b log5(2) | < 2^(-21) (fp viz. real arithmetic),\n-        \/\/ which entails m <= maxPowsOf5 <= m + 1, where maxPowsOf5 is as below.\n-        \/\/ Hence, maxPowsOf5 >= k.\n-        long maxPowsOf5 = Math.round(intVal.bitLength() * LOG_5_OF_2);\n-        remainingZeros = Math.min(remainingZeros, maxPowsOf5);\n+        \/\/ Since m <= log5Upper(intVal) <= m + 1, then log5Upper(intVal) >= k.\n+        remainingZeros = Math.min(remainingZeros, log5Upper(intVal));\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.BigInteger;\n+import java.math.BigDecimal;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class BigDecimalDivide {\n+\n+    private BigDecimal[][] xsArray, sArray, mArray, lArray, xlArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        xsArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 64 bits\n+         * in size\n+         *\/\n+        sArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 256 bits\n+         * in size\n+         *\/\n+        mArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 1024 bits\n+         * in size\n+         *\/\n+        lArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 4096 bits\n+         * in size\n+         *\/\n+        xlArray = new BigDecimal[TESTSIZE][2]; \/*\n+         * Each array entry is atmost 16384 bits\n+         * in size\n+         *\/\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            xsArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(64), r));\n+            xsArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(64), r));\n+            sArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(256), r));\n+            sArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(256), r));\n+            mArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(1024), r));\n+            mArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(1024), r));\n+            lArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(4096), r));\n+            lArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(4096), r));\n+            xlArray[i][0] = new BigDecimal(new BigInteger(r.nextInt(16384), r));\n+            xlArray[i][1] = new BigDecimal(new BigInteger(r.nextInt(16384), r));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 64 bits  *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideXS(Blackhole bh) {\n+        for (BigDecimal[] s : xsArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 256 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideS(Blackhole bh) {\n+        for (BigDecimal[] s : sArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 1024 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideM(Blackhole bh) {\n+        for (BigDecimal[] s : mArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 4096 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideL(Blackhole bh) {\n+        for (BigDecimal[] s : lArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+\n+    \/** Test BigDecimal.divide(BigDecimal) with numbers long at most 16384 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testExactDivideXL(Blackhole bh) {\n+        for (BigDecimal[] s : xlArray) {\n+            try {\n+                bh.consume(s[0].divide(s[1]));\n+            } catch (ArithmeticException e) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimalDivide.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}