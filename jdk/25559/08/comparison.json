{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,1 +208,0 @@\n-        boolean endOfFile = false;\n@@ -210,1 +209,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -212,1 +211,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -215,1 +213,1 @@\n-                endOfFile = true;\n+                bytesRead = -1;\n@@ -220,4 +218,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -239,1 +234,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -241,1 +236,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -244,8 +238,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,1 +269,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -271,1 +271,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -275,4 +274,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -313,1 +309,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -315,1 +311,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -319,4 +314,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -370,2 +370,1 @@\n-        boolean endOfFile = false;\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -373,1 +372,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -376,1 +374,1 @@\n-                endOfFile = true;\n+                bytesRead = -1;\n@@ -381,4 +379,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -407,1 +402,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -409,1 +404,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -412,8 +406,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -585,1 +572,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -587,1 +574,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -591,4 +577,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -627,1 +610,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -629,1 +612,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -633,4 +615,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":10,"deletions":31,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-    static volatile boolean jfrTracing;\n+    static boolean jfrTracing;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Throwable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -968,4 +968,1 @@\n-            long duration = SocketReadEvent.timestamp() - start;\n-            if (SocketReadEvent.shouldCommit(duration)) {\n-                SocketReadEvent.emit(start, duration, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n-            }\n+            SocketReadEvent.offer(start, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n@@ -1084,4 +1081,1 @@\n-            long duration = SocketWriteEvent.timestamp() - start;\n-            if (SocketWriteEvent.shouldCommit(duration)) {\n-                SocketWriteEvent.emit(start, duration, len, parent.getRemoteSocketAddress());\n-            }\n+            SocketWriteEvent.offer(start, len, parent.getRemoteSocketAddress());\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,5 @@\n+    public static boolean shouldThrottleCommit(long timestamp) {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/ExceptionThrownEvent.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    public static boolean shouldCommit(long duration) {\n+    public static boolean shouldThrottleCommit(long duration, long end) {\n@@ -53,0 +53,22 @@\n+    \/**\n+     * Helper method to offer the data needed to potentially commit an event.\n+     * The duration of the operation is computed using the current\n+     * timestamp and the given start time. If the duration meets\n+     * or exceeds the configured value and is not throttled (determined by calling the\n+     * generated method {@link #shouldThrottleCommit(long, long)}), an event will be\n+     * emitted by calling {@link #commit(long, long, String, long, boolean)}\n+     *\n+     * @param start  the start time\n+     * @param path  the path\n+     * @param bytesRead  the number of bytes that were read, or -1 if the end of the file was reached\n+     *\/\n+    public static void offer(long start, String path, long bytesRead) {\n+        long end = timestamp();\n+        long duration = end - start;\n+        if (shouldThrottleCommit(duration, end)) {\n+            boolean endOfFile = bytesRead < 0;\n+            long bytes = endOfFile ? 0 : bytesRead;\n+            commit(start, duration, path, bytes, endOfFile);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/FileReadEvent.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    public static boolean shouldCommit(long duration) {\n+    public static boolean shouldThrottleCommit(long duration, long end) {\n@@ -52,0 +52,21 @@\n+    \/**\n+     * Helper method to offer the data needed to potentially commit an event.\n+     * The duration of the operation is computed using the current\n+     * timestamp and the given start time. If the duration meets\n+     * or exceeds the configured value and is not throttled (determined by calling the\n+     * generated method {@link #shouldThrottleCommit(long, long)}), an event will be\n+     * emitted by calling {@link #commit(long, long, String, long)}\n+     *\n+     * @param start  the start time\n+     * @param path  the path\n+     * @param bytesRead  the number of bytes that were written, or -1 if the end of the file was reached\n+     *\/\n+    public static void offer(long start, String path, long bytesWritten) {\n+        long end = timestamp();\n+        long duration = end - start;\n+        if (shouldThrottleCommit(duration, end)) {\n+            long bytes = bytesWritten > 0 ? bytesWritten : 0;\n+            commit(start, duration, path, bytes);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/FileWriteEvent.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+     * @param end  timestamp at the end of the operation\n@@ -79,1 +80,1 @@\n-    public static boolean shouldCommit(long duration) {\n+    public static boolean shouldThrottleCommit(long duration, long end) {\n@@ -121,2 +122,3 @@\n-        long duration = timestamp() - start;\n-        if (shouldCommit(duration)) {\n+        long end = timestamp();\n+        long duration = end - start;\n+        if (shouldThrottleCommit(duration, end)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketReadEvent.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,2 @@\n-     * @param duration  time in nanoseconds to complete the operation\n+     * @param duration  time to complete the operation\n+     * @param end  timestamp at the end of the operation\n@@ -74,1 +75,1 @@\n-    public static boolean shouldCommit(long duration) {\n+    public static boolean shouldThrottleCommit(long duration, long end) {\n@@ -107,1 +108,1 @@\n-     * {@link #shouldCommit(long)}), an event will be emitted by calling\n+     * {@link #shouldThrottleCommit(long)}), an event will be emitted by calling\n@@ -115,2 +116,3 @@\n-        long duration = timestamp() - start;\n-        if (shouldCommit(duration)) {\n+        long end = timestamp();\n+        long duration = end - start;\n+        if (shouldThrottleCommit(duration, end)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketWriteEvent.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,1 @@\n-\n-        if (ErrorThrownEvent.enabled()) {\n+        if (ErrorThrownEvent.enabled() || ExceptionThrownEvent.enabled()) {\n@@ -43,5 +42,6 @@\n-            ErrorThrownEvent.commit(timestamp, message, clazz);\n-        }\n-        if (ExceptionThrownEvent.enabled()) {\n-            long timestamp = ExceptionThrownEvent.timestamp();\n-            ExceptionThrownEvent.commit(timestamp, message, clazz);\n+            if (ErrorThrownEvent.enabled()) {\n+                ErrorThrownEvent.commit(timestamp, message, clazz);\n+            }\n+            if (ExceptionThrownEvent.shouldThrottleCommit(timestamp)) {\n+                ExceptionThrownEvent.commit(timestamp, message, clazz);\n+            }\n@@ -54,2 +54,4 @@\n-            long timestamp = ExceptionThrownEvent.timestamp();\n-            ExceptionThrownEvent.commit(timestamp, message, clazz);\n+            long timestamp = ErrorThrownEvent.timestamp();\n+            if (ExceptionThrownEvent.shouldThrottleCommit(timestamp)) {\n+                ExceptionThrownEvent.commit(timestamp, message, clazz);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/ThrowableTracer.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -267,1 +267,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -269,1 +269,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -272,8 +271,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -329,1 +321,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -331,1 +323,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -334,8 +325,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -388,1 +372,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -390,1 +374,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -393,5 +376,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -444,1 +423,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -446,1 +425,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -449,5 +427,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -1202,1 +1176,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -1204,1 +1178,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -1207,8 +1180,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -1274,1 +1240,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -1276,1 +1242,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -1279,5 +1244,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":13,"deletions":52,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Event annotation, specifies the maximum rate of events per time unit, (for\n+ * example, {@code \"100\/s\"}).\n+ * <p>\n+ * If the event class annotated with {@code Throttle} is filtered by other\n+ * settings, such as a {@link jdk.jfr.Threshold} or a user-defined setting, the\n+ * throttling will happen after those settings have been applied.\n+ *\n+ * @since 25\n+ *\/\n+@MetadataDefinition\n+@Target({ ElementType.TYPE })\n+@Inherited\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Throttle {\n+    \/**\n+     * Setting name {@code \"throttle\"} for configuring throttled events.\n+     *\/\n+    public static final String NAME = \"throttle\";\n+\n+    \/**\n+     * The throttle rate, for example {@code \"100\/s\"}.\n+     * <p>\n+     * String representation of a non-negative {@code long} value followed by a\n+     * forward slash (\"\/\") and one of the following units: <br>\n+     * <ul style=\"list-style-type:none\">\n+     * <li>{@code \"ns\"} (nanoseconds)<\/li>\n+     * <li>{@code \"us\"} (microseconds)<\/li>\n+     * <li>{@code \"ms\"} (milliseconds)<\/li>\n+     * <li>{@code \"s\"} (seconds)<\/li>\n+     * <li>{@code \"m\"} (minutes)<\/li>\n+     * <li>{@code \"h\"} (hours)<\/li>\n+     * <li>{@code \"d\"} (days)<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Example values, {@code \"6000\/m\"}, {@code \"10\/ms\"} and {@code \"200\/s\"}.\n+     * <p>\n+     * Specifying zero, for example {@code \"0\/s\"}, results in no events being\n+     * emitted.\n+     * <p>\n+     * Specifying {@code \"off\"} (case-sensitive) results in all events being emitted.\n+     *\n+     * @return the throttle value, default {@code \"off\"} not {@code null}\n+     *\/\n+    String value() default \"off\";\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Throttle.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.jfr.Throttle;\n@@ -41,0 +42,1 @@\n+@Throttle\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ExceptionThrownEvent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jfr.Throttle;\n@@ -41,0 +42,1 @@\n+@Throttle\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileReadEvent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jfr.Throttle;\n@@ -41,0 +42,1 @@\n+@Throttle\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileWriteEvent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.jfr.Throttle;\n@@ -41,0 +42,1 @@\n+@Throttle\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SocketReadEvent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jfr.Throttle;\n@@ -40,0 +41,1 @@\n+@Throttle\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SocketWriteEvent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.jfr.Throttle;\n@@ -67,0 +68,1 @@\n+    private static final ClassDesc ANNOTATION_THROTTLE = classDesc(Throttle.class);\n@@ -141,0 +143,14 @@\n+    boolean isThrottled() {\n+        String result = annotationValue(ANNOTATION_THROTTLE, String.class, \"off\");\n+        if (result != null) {\n+            return true;\n+        }\n+        if (superClass != null) {\n+            Throttle t = superClass.getAnnotation(Throttle.class);\n+            if (t != null) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ClassInspector.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.jfr.Throttle;\n@@ -58,0 +59,1 @@\n+import jdk.jfr.internal.settings.Throttler;\n@@ -98,0 +100,1 @@\n+            eventType.setThrottler(new Throttler(eventType));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,8 @@\n-final class EventInstrumentation {\n+public final class EventInstrumentation {\n+    public static final long MASK_THROTTLE               = 1 << 62;\n+    public static final long MASK_THROTTLE_CHECK         = 1 << 63;\n+    public static final long MASK_THROTTLE_BITS          = MASK_THROTTLE | MASK_THROTTLE_CHECK;\n+    public static final long MASK_THROTTLE_CHECK_SUCCESS = MASK_THROTTLE_CHECK | MASK_THROTTLE;\n+    public static final long MASK_THROTTLE_CHECK_FAIL    = MASK_THROTTLE_CHECK | 0;\n+    public static final long MASK_NON_THROTTLE_BITS      = ~MASK_THROTTLE_BITS;\n+\n@@ -74,0 +81,1 @@\n+    private static final MethodDesc METHOD_THROTTLE = MethodDesc.of(\"throttle\", \"(JJ)J\");\n@@ -76,1 +84,4 @@\n-    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = MethodDesc.of(\"shouldCommit\", \"(J)Z\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT_LONG = MethodDesc.of(\"shouldCommit\", \"(J)Z\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_THROTTLE_COMMIT_LONG_LONG = MethodDesc.of(\"shouldThrottleCommit\", \"(JJ)Z\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_THROTTLE_COMMIT_LONG = MethodDesc.of(\"shouldThrottleCommit\", \"(J)Z\");\n+\n@@ -79,0 +90,2 @@\n+    private static final MethodDesc METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG_LONG = MethodDesc.of(\"shouldThrottleCommit\", \"(JJ)Z\");\n+    private static final MethodDesc METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG = MethodDesc.of(\"shouldThrottleCommit\", \"(J)Z\");\n@@ -91,0 +104,1 @@\n+    private final boolean throttled;\n@@ -113,0 +127,5 @@\n+        if (inspector.isJDK()) {\n+            this.throttled = inspector.hasStaticMethod(METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG_LONG);\n+        } else {\n+            this.throttled = inspector.isThrottled();\n+        }\n@@ -150,0 +169,6 @@\n+            if (isMethod(method, METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG_LONG)) {\n+                return this::methodShouldCommitThrottleStaticLongLong;\n+            }\n+            if (isMethod(method, METHOD_EVENT_SHOULD_THROTTLE_COMMIT_LONG)) {\n+                return this::methodShouldCommitThrottleStaticLong;\n+            }\n@@ -191,5 +216,5 @@\n-            codeBuilder.aload(0);\n-            codeBuilder.aload(0);\n-            getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n-            invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);\n-            putfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            setDuration(codeBuilder, cb -> {\n+                codeBuilder.aload(0);\n+                getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n+                invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);\n+            });\n@@ -208,3 +233,2 @@\n-        codeBuilder.aload(0);\n-        getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n-        invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n+        getDuration(codeBuilder);\n+        invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT_LONG);\n@@ -225,0 +249,24 @@\n+        if (throttled) {\n+            \/\/ long d =  eventConfiguration.throttle(this.duration);\n+            \/\/ this.duration = d;\n+            \/\/ if (d & MASK_THROTTLE_BIT == 0) {\n+            \/\/   goto fail;\n+            \/\/ }\n+            getEventConfiguration(codeBuilder);\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            Bytecode.invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_THROTTLE);\n+            int result = codeBuilder.allocateLocal(TypeKind.LONG);\n+            codeBuilder.lstore(result);\n+            codeBuilder.aload(0);\n+            codeBuilder.lload(result);\n+            putfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            codeBuilder.lload(result);\n+            codeBuilder.ldc(MASK_THROTTLE);\n+            codeBuilder.land();\n+            codeBuilder.lconst_0();\n+            codeBuilder.lcmp();\n+            codeBuilder.ifeq(fail);\n+         }\n@@ -297,0 +345,11 @@\n+        methodShouldCommitStatic(codeBuilder, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT_LONG);\n+    }\n+\n+    private void methodShouldCommitThrottleStaticLongLong(CodeBuilder codeBuilder) {\n+        methodShouldCommitStatic(codeBuilder, METHOD_EVENT_CONFIGURATION_SHOULD_THROTTLE_COMMIT_LONG_LONG);\n+    }\n+    private void methodShouldCommitThrottleStaticLong(CodeBuilder codeBuilder) {\n+        methodShouldCommitStatic(codeBuilder, METHOD_EVENT_CONFIGURATION_SHOULD_THROTTLE_COMMIT_LONG);\n+    }\n+\n+    private void methodShouldCommitStatic(CodeBuilder codeBuilder, MethodDesc method) {\n@@ -305,2 +364,4 @@\n-        codeBuilder.lload(0);\n-        codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.name(), METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.descriptor());\n+        for (int i = 0 ; i < method.descriptor().parameterCount(); i++) {\n+            codeBuilder.lload(2 * i);\n+        }\n+        codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, method.name(), method.descriptor());\n@@ -518,0 +579,22 @@\n+    private void getDuration(CodeBuilder codeBuilder) {\n+        codeBuilder.aload(0);\n+        getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+        if (throttled) {\n+            codeBuilder.loadConstant(MASK_NON_THROTTLE_BITS);\n+            codeBuilder.land();\n+        }\n+    }\n+\n+    private void setDuration(CodeBuilder codeBuilder, Consumer<CodeBuilder> expression) {\n+        codeBuilder.aload(0);\n+        expression.accept(codeBuilder);\n+        if (throttled) {\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            codeBuilder.loadConstant(MASK_THROTTLE_BITS);\n+            codeBuilder.land();\n+            codeBuilder.lor();\n+        }\n+        putfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":95,"deletions":12,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    static long nanosToTicks(long nanos) {\n+    public static long nanosToTicks(long nanos) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.jfr.Throttle;\n@@ -52,1 +53,1 @@\n-\n+import jdk.jfr.internal.settings.ThrottleSetting;\n@@ -323,1 +324,1 @@\n-                    aes.add(new AnnotationElement(Throttle.class, Throttle.DEFAULT));\n+                    aes.add(new AnnotationElement(Throttle.class, ThrottleSetting.DEFAULT_VALUE));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataLoader.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.jfr.Throttle;\n@@ -53,0 +54,1 @@\n+import jdk.jfr.internal.settings.Throttler;\n@@ -217,0 +219,1 @@\n+        pEventType.setHasThrottle(pEventType.getAnnotation(Throttle.class) != null);\n@@ -219,1 +222,2 @@\n-        EventConfiguration configuration = new EventConfiguration(pEventType, eventType, ec, settings, eventType.getId());\n+        Throttler throttler = pEventType.getThrottler();\n+        EventConfiguration configuration = new EventConfiguration(pEventType, eventType, ec, settings, throttler, eventType.getId());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.jfr.internal.settings.Throttler;\n@@ -75,0 +76,1 @@\n+    private Throttler throttler;\n@@ -193,1 +195,1 @@\n-    public void setThrottle(long eventSampleSize, long period_ms) {\n+    public void setThrottle(long eventSampleSize, long periodInMillis) {\n@@ -195,1 +197,3 @@\n-            JVM.setThrottle(getId(), eventSampleSize, period_ms);\n+            JVM.setThrottle(getId(), eventSampleSize, periodInMillis);\n+        } else {\n+            throttler.configure(eventSampleSize, periodInMillis);\n@@ -423,0 +427,8 @@\n+\n+    public Throttler getThrottler() {\n+        return throttler;\n+    }\n+\n+    public void setThrottler(Throttler throttler) {\n+       this.throttler = throttler;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Inherited;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-import jdk.jfr.MetadataDefinition;\n-\n-\/**\n- * Event annotation, determines the event emission rate in events per time unit.\n- *\n- * This setting is only supported for JVM events.\n- *\n- * @since 16\n- *\/\n-@MetadataDefinition\n-@Target({ ElementType.TYPE })\n-@Inherited\n-@Retention(RetentionPolicy.RUNTIME)\n-public @interface Throttle {\n-    \/**\n-     * Settings name {@code \"throttle\"} for configuring an event emission rate in events per time unit.\n-     *\/\n-    public static final String NAME = \"throttle\";\n-    public static final String DEFAULT = \"off\";\n-\n-    \/**\n-     * Throttle, for example {@code \"100\/s\"}.\n-     * <p>\n-     * String representation of a non-negative {@code Long} value followed by a slash (\"\/\")\n-     * and one of the following units<br>\n-     * {@code \"ns\"} (nanoseconds)<br>\n-     * {@code \"us\"} (microseconds)<br>\n-     * {@code \"ms\"} (milliseconds)<br>\n-     * {@code \"s\"} (seconds)<br>\n-     * {@code \"m\"} (minutes)<br>\n-     * {@code \"h\"} (hours)<br>\n-     * {@code \"d\"} (days)<br>\n-     * <p>\n-     * Example values, {@code \"6000\/m\"}, {@code \"10\/ms\"} and {@code \"200\/s\"}.\n-     * When zero is specified, for example {@code \"0\/s\"}, no events are emitted.\n-     * When {@code \"off\"} is specified, all events are emitted.\n-     *\n-     * @return the throttle value, default {@code \"off\"} not {@code null}\n-     *\n-     *\/\n-    String value() default DEFAULT;\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Throttle.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.jfr.internal.EventInstrumentation;\n@@ -33,0 +34,1 @@\n+import jdk.jfr.internal.settings.Throttler;\n@@ -39,0 +41,1 @@\n+    Throttler throttler,\n@@ -46,0 +49,13 @@\n+    \/\/ Accessed by generated code in event class. Used by:\n+    \/\/ static boolean shouldThrottleCommit(long duration, long timestamp)\n+    public boolean shouldThrottleCommit(long duration, long timestamp) {\n+        return isEnabled() && duration >= platformEventType.getThresholdTicks() && throttler.sample(timestamp);\n+    }\n+\n+    \/\/ Caller must of Event::shouldThrottleCommit must check enablement.\n+    \/\/ Accessed by generated code in event class. Used by:\n+    \/\/ static boolean shouldThrottleCommit(long timestamp)\n+    public boolean shouldThrottleCommit(long timestamp) {\n+        return throttler.sample(timestamp);\n+    }\n+\n@@ -56,0 +72,13 @@\n+    public long throttle(long startTime, long rawDuration) {\n+        \/\/ We have already tried to throttle, return as is\n+        if ((rawDuration & EventInstrumentation.MASK_THROTTLE_BITS) != 0) {\n+            return rawDuration;\n+        }\n+        long endTime = startTime + rawDuration;\n+        if (throttler.sample(endTime)) {\n+            return rawDuration | EventInstrumentation.MASK_THROTTLE_CHECK_SUCCESS;\n+        } else {\n+            return rawDuration | EventInstrumentation.MASK_THROTTLE_CHECK_FAIL;\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventConfiguration.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.jfr.internal.Throttle;\n@@ -52,1 +51,1 @@\n-    public static final String DEFAULT_VALUE = Throttle.DEFAULT;\n+    public static final String DEFAULT_VALUE = \"off\";\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleSetting.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.settings;\n+\n+import java.util.Random;\n+import java.util.concurrent.locks.ReentrantLock;\n+import jdk.jfr.internal.PlatformEventType;\n+public final class Throttler {\n+    private static final ThrottlerParameters DISABLED_PARAMETERS = new ThrottlerParameters(0, 0, 0);\n+    private static final long MILLIUNITS = 1000;\n+    private static final long MINUTE = 60 * MILLIUNITS;\n+    private static final long TEN_PER_1000_MS_IN_MINUTES = 600;\n+    private static final long HOUR = 60 * MINUTE;\n+    private static final long TEN_PER_1000_MS_IN_HOURS = 36000;\n+    private static final long TEN_PER_1000_MS_IN_DAYS = 864000;\n+    private static final long EVENT_THROTTLER_OFF = -2;\n+\n+    private final ReentrantLock lock = new ReentrantLock();\n+    private final Random randomGenerator = new Random();\n+    private final ThrottlerWindow window0 = new ThrottlerWindow();\n+    private final ThrottlerWindow window1 = new ThrottlerWindow();\n+\n+    private volatile ThrottlerWindow activeWindow = window0;\n+\n+    \/\/ Guarded by lock\n+    private double averagePopulationSize;\n+    private double ewmaPopulationSize;\n+    private long accumulatedDebtCarryLimit;\n+    private long accumulatedDebtCarryCount;\n+    private ThrottlerParameters lastParameters = new ThrottlerParameters(0, 0, 0);\n+    private long sampleSize;\n+    private long periodMillis;\n+    private boolean disabled;\n+    private boolean update = true;\n+\n+    public Throttler(PlatformEventType t) {\n+    }\n+    \/\/ Not synchronized in fast path, but uses volatile reads.\n+    public boolean sample(long ticks) {\n+        if (disabled) {\n+            return true;\n+        }\n+        ThrottlerWindow current = activeWindow;\n+        if (current.isExpired(ticks)) {\n+            if (lock.tryLock()) {\n+                try {\n+                    rotateWindow(ticks);\n+                } finally {\n+                    lock.unlock();\n+                }\n+            }\n+            return activeWindow.sample();\n+        }\n+        return current.sample();\n+    }\n+\n+    public void configure(long sampleSize, long periodMillis) {\n+        lock.lock();\n+        try {\n+            this.sampleSize = sampleSize;\n+            this.periodMillis = periodMillis;\n+            this.update = true;\n+            this.activeWindow = configure(nextWindowParameters(), activeWindow);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private ThrottlerWindow configure(ThrottlerParameters parameters, ThrottlerWindow expired) {\n+        if (parameters.reconfigure) {\n+            \/\/ Store updated params once to both windows\n+            expired.parameters = parameters;\n+            nextWindow(expired).parameters = parameters;\n+            configure(parameters);\n+        }\n+        ThrottlerWindow next = setRate(parameters, expired);\n+        next.initialize(parameters);\n+        return next;\n+    }\n+\n+    private void configure(ThrottlerParameters parameters) {\n+        averagePopulationSize = 0;\n+        ewmaPopulationSize = computeEwmaAlphaCoefficient(parameters.windowLookBackCount);\n+        accumulatedDebtCarryLimit = computeAccumulatedDebtCarryLimit(parameters);\n+        accumulatedDebtCarryCount = accumulatedDebtCarryLimit;\n+        parameters.reconfigure = false;\n+    }\n+\n+    private void rotateWindow(long ticks) {\n+        ThrottlerWindow current = activeWindow;\n+        if (current.isExpired(ticks)) {\n+            activeWindow = configure(current.parameters.copy(), current);\n+        }\n+    }\n+\n+    private ThrottlerWindow setRate(ThrottlerParameters parameters, ThrottlerWindow expired) {\n+        ThrottlerWindow next = nextWindow(expired);\n+        long projectedSampleSize = parameters.samplePointsPerWindow + amortizeDebt(expired);\n+        if (projectedSampleSize == 0) {\n+            next.projectedPopulationSize = 0;\n+            return next;\n+        }\n+        next.samplingInterval = deriveSamplingInterval(projectedSampleSize, expired);\n+        next.projectedPopulationSize = projectedSampleSize * next.samplingInterval;\n+        return next;\n+    }\n+\n+    private long amortizeDebt(ThrottlerWindow expired) {\n+        long accumulatedDebt = expired.accumulatedDebt();\n+        if (accumulatedDebtCarryCount == accumulatedDebtCarryLimit) {\n+            accumulatedDebtCarryCount = 1;\n+            return 0;\n+        }\n+        accumulatedDebtCarryCount++;\n+        return -accumulatedDebt;\n+    }\n+\n+    private long deriveSamplingInterval(double sampleSize, ThrottlerWindow expired) {\n+        double populationSize = projectPopulationSize(expired);\n+        if (populationSize <= sampleSize) {\n+            return 1;\n+        }\n+        double projectProbability = sampleSize \/ populationSize;\n+        return nextGeometric(projectProbability, randomGenerator.nextDouble());\n+    }\n+\n+    private double projectPopulationSize(ThrottlerWindow expired) {\n+        averagePopulationSize = exponentiallyWeightedMovingAverage(expired.populationSize(), ewmaPopulationSize, averagePopulationSize);\n+        return averagePopulationSize;\n+    }\n+\n+    private static long nextGeometric(double p, double u) {\n+        return (long) Math.ceil(Math.log(1.0 - adjustBoundary(u)) \/ Math.log(1.0 - p));\n+    }\n+\n+    private static double adjustBoundary(double u) {\n+        if (u == 0.0) {\n+            return 0.01;\n+        }\n+        if (u == 1.0) {\n+            return 0.99;\n+        }\n+        return u;\n+    }\n+\n+    private void normalize() {\n+        if (periodMillis == MILLIUNITS) {\n+            return;\n+        }\n+        if (periodMillis == MINUTE) {\n+            if (sampleSize >= TEN_PER_1000_MS_IN_MINUTES) {\n+                sampleSize \/= 60;\n+                periodMillis \/= 60;\n+            }\n+            return;\n+        }\n+        if (periodMillis == HOUR) {\n+            if (sampleSize >= TEN_PER_1000_MS_IN_HOURS) {\n+                sampleSize \/= 3600;\n+                periodMillis \/= 3600;\n+            }\n+            return;\n+        }\n+        if (sampleSize >= TEN_PER_1000_MS_IN_DAYS) {\n+            sampleSize \/= 86400;\n+            periodMillis \/= 86400;\n+        }\n+    }\n+\n+    private ThrottlerParameters nextWindowParameters() {\n+        if (update) {\n+            return updateParameters();\n+        }\n+        return disabled ? DISABLED_PARAMETERS : lastParameters;\n+    }\n+\n+    private ThrottlerParameters updateParameters() {\n+        disabled = is_disabled(sampleSize);\n+        if (disabled) {\n+            return DISABLED_PARAMETERS;\n+        }\n+        normalize();\n+        lastParameters.setSamplePointsAndWindowDuration(sampleSize, periodMillis);\n+        lastParameters.reconfigure = true;\n+        update = false;\n+        return lastParameters;\n+    }\n+\n+    private boolean is_disabled(long eventSampleSize) {\n+        return eventSampleSize == EVENT_THROTTLER_OFF;\n+    }\n+\n+    private double exponentiallyWeightedMovingAverage(double y, double alpha, double s) {\n+        return alpha * y + (1 - alpha) * s;\n+    }\n+\n+    private double computeEwmaAlphaCoefficient(long lookBackCount) {\n+        return lookBackCount <= 1 ? 1.0 : 1.0 \/ lookBackCount;\n+    }\n+\n+    private long computeAccumulatedDebtCarryLimit(ThrottlerParameters parameters) {\n+        if (parameters.windowDurationMillis == 0 || parameters.windowDurationMillis >= 1000) {\n+            return 1;\n+        }\n+        return 1000 \/ parameters.windowDurationMillis;\n+    }\n+\n+    private ThrottlerWindow nextWindow(ThrottlerWindow expired) {\n+        return expired == window0 ? window1 : window0;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/Throttler.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.settings;\n+\n+final class ThrottlerParameters {\n+    private static final long LOW_RATE_UPPER_BOUND = 9;\n+    private static final long WINDOW_DIVISOR = 5;\n+    private static final long MILLIUNITS = 1000;\n+    private static final long MINUTE = 60 * MILLIUNITS;\n+    private static final long TEN_PER_1000_MS_IN_MINUTES = 600;\n+    private static final long HOUR = 60 * MINUTE;\n+    private static final long TEN_PER_1000_MS_IN_HOURS = 36000;\n+    private static final long DAY = 24 * HOUR;\n+    private static final long TEN_PER_1000_MS_IN_DAYS = 864000;\n+    private static final long DEFAULT_WINDOWS_LOOKBACK_COUNT = 25; \/\/ 25 windows == 5 seconds (for default window duration of 200 ms)\n+\n+    long samplePointsPerWindow;\n+    long windowDurationMillis;\n+    long windowLookBackCount;\n+    boolean reconfigure;\n+\n+    ThrottlerParameters(long samplePointsPerWindow, long windowDuration, long windowLockBackCount) {\n+        this.samplePointsPerWindow = samplePointsPerWindow;\n+        this.windowDurationMillis = windowDuration;\n+        this.windowLookBackCount = windowLockBackCount;\n+    }\n+\n+    public ThrottlerParameters copy() {\n+        return new ThrottlerParameters(samplePointsPerWindow, windowDurationMillis, windowLookBackCount);\n+    }\n+\n+    void setSamplePointsAndWindowDuration(long sampleSize, long periodMillis) {\n+        try {\n+            if (sampleSize <= LOW_RATE_UPPER_BOUND) {\n+                samplePointsPerWindow = sampleSize;\n+                windowDurationMillis = periodMillis;\n+                return;\n+            }\n+            if (periodMillis == MINUTE && sampleSize < TEN_PER_1000_MS_IN_MINUTES) {\n+                samplePointsPerWindow = sampleSize;\n+                windowDurationMillis = periodMillis;\n+                return;\n+            }\n+            if (periodMillis == HOUR && sampleSize < TEN_PER_1000_MS_IN_HOURS) {\n+                samplePointsPerWindow = sampleSize;\n+                windowDurationMillis = periodMillis;\n+                return;\n+            }\n+            if (periodMillis == DAY && sampleSize < TEN_PER_1000_MS_IN_DAYS) {\n+                samplePointsPerWindow = sampleSize;\n+                windowDurationMillis = periodMillis;\n+                return;\n+            }\n+            samplePointsPerWindow = sampleSize \/ WINDOW_DIVISOR;\n+            windowDurationMillis = periodMillis \/ WINDOW_DIVISOR;\n+        } finally {\n+            updateWindowLookback();\n+        }\n+    }\n+\n+    private void updateWindowLookback() {\n+        if (windowDurationMillis <= MILLIUNITS) {\n+            windowLookBackCount = DEFAULT_WINDOWS_LOOKBACK_COUNT; \/\/ 5 seconds\n+            return;\n+        }\n+        if (windowDurationMillis == MINUTE) {\n+            windowLookBackCount = 5; \/\/ 5 windows == 5 minutes\n+            return;\n+        }\n+        windowLookBackCount = 1; \/\/ 1 window == 1 hour or 1 day\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottlerParameters.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.settings;\n+\n+import jdk.jfr.internal.JVMSupport;\n+\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.jfr.internal.JVM;\n+\n+final class ThrottlerWindow {\n+    private final AtomicLong measuredPopulationSize = new AtomicLong();\n+    \/\/ Guarded by Throttler.lock.\n+    ThrottlerParameters parameters = new ThrottlerParameters(0, 0, 0);\n+    long samplingInterval = 1;\n+    long projectedPopulationSize;\n+\n+    private volatile long endTicks;\n+\n+    void initialize(ThrottlerParameters parameters) {\n+        if (parameters.windowDurationMillis == 0) {\n+            endTicks = 0;\n+            return;\n+        }\n+        measuredPopulationSize.set(0);\n+        endTicks = JVM.counterTime() + JVMSupport.nanosToTicks(1_000_000L * parameters.windowDurationMillis);\n+    }\n+\n+    boolean isExpired(long timestamp) {\n+        long endTicks = this.endTicks;\n+        if (timestamp == 0) {\n+            return JVM.counterTime() >= endTicks;\n+        } else {\n+            return timestamp >= endTicks;\n+        }\n+    }\n+\n+    boolean sample() {\n+        long ordinal = measuredPopulationSize.incrementAndGet();\n+        return ordinal <= projectedPopulationSize && ordinal % samplingInterval == 0;\n+    }\n+\n+    long maxSampleSize() {\n+        return samplingInterval == 0 ? 0 : projectedPopulationSize \/ samplingInterval;\n+    }\n+\n+    long sampleSize() {\n+        long size = populationSize();\n+        return size > projectedPopulationSize ? maxSampleSize() : size \/ samplingInterval;\n+    }\n+\n+    long populationSize() {\n+        return measuredPopulationSize.get();\n+    }\n+\n+    long accumulatedDebt() {\n+        if (projectedPopulationSize == 0) {\n+            return 0;\n+        }\n+        return parameters.samplePointsPerWindow - maxSampleSize() + debt();\n+    }\n+\n+    long debt() {\n+        if (projectedPopulationSize == 0) {\n+            return 0;\n+        }\n+        return sampleSize() - parameters.samplePointsPerWindow;\n+    }\n+\n+    public String toString() {\n+        StringJoiner sb = new StringJoiner(\", \");\n+        sb.add(\"measuredPopulationSize=\" + measuredPopulationSize);\n+        sb.add(\"samplingInterval=\" + samplingInterval);\n+        sb.add(\"projectedPopulationSize=\" + projectedPopulationSize);\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottlerWindow.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,0 +180,22 @@\n+ *   <th scope=\"row\">{@code throttle}<\/th>\n+ *   <td>Specifies the maximum rate of events per time unit.<\/td>\n+ *   <td>{@code \"off\"} (no throttling)<\/td>\n+ *   <td>\n+ *     \"off\", if events should not be throttled, otherwise a string representation of a positive {@code Long} value followed by forward slash (\"\/\") and one of the following units:\n+ *     <ul style=\"list-style-type:none\">\n+ *       <li>{@code \"ns\"} (nanoseconds)\n+ *       <li>{@code \"us\"} (microseconds)\n+ *       <li>{@code \"ms\"} (milliseconds)<\/li>\n+ *       <li>{@code \"s\"} (seconds)<\/li>\n+ *       <li>{@code \"m\"} (minutes)<\/li>\n+ *       <li>{@code \"h\"} (hours)<\/li>\n+ *       <li>{@code \"d\"} (days)<\/li>\n+ *     <\/ul>\n+ *   <\/td>\n+ *    <td>\n+ *     {@code \"off\"}<br>\n+ *     {@code \"100\/s\"}<br>\n+ *     {@code \"1000\/m\"}\n+ *   <\/td>\n+ * <\/tr>\n+ * <tr>\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/package-info.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -772,1 +772,1 @@\n-      <setting name=\"threshold\" control=\"file-threshold\">20 ms<\/setting>\n+      <setting name=\"threshold\">20 ms<\/setting>\n@@ -778,1 +778,2 @@\n-      <setting name=\"threshold\" control=\"file-threshold\">20 ms<\/setting>\n+      <setting name=\"threshold\">1 ms<\/setting>\n+      <setting name=\"throttle\">100\/s<\/setting>\n@@ -784,1 +785,2 @@\n-      <setting name=\"threshold\" control=\"file-threshold\">20 ms<\/setting>\n+      <setting name=\"threshold\">1 ms<\/setting>\n+      <setting name=\"throttle\">100\/s<\/setting>\n@@ -790,1 +792,2 @@\n-      <setting name=\"threshold\" control=\"socket-threshold\">20 ms<\/setting>\n+      <setting name=\"threshold\">1 ms<\/setting>\n+      <setting name=\"throttle\">100\/s<\/setting>\n@@ -796,1 +799,2 @@\n-      <setting name=\"threshold\" control=\"socket-threshold\">20 ms<\/setting>\n+      <setting name=\"threshold\">1 ms<\/setting>\n+      <setting name=\"throttle\">100\/s<\/setting>\n@@ -839,1 +843,1 @@\n-      <setting name=\"enabled\" control=\"enable-exceptions\">false<\/setting>\n+      <setting name=\"enabled\" control=\"enable-exceptions\">true<\/setting>\n@@ -841,0 +845,1 @@\n+      <setting name=\"throttle\" control=\"exceptions-throttle-rate\">100\/s<\/setting>\n@@ -1139,1 +1144,1 @@\n-      <selection name=\"exceptions\" default=\"errors\" label=\"Exceptions\">\n+      <selection name=\"exceptions\" default=\"throttled\" label=\"Exceptions\">\n@@ -1141,2 +1146,2 @@\n-        <option label=\"Errors Only\" name=\"errors\">errors<\/option>\n-        <option label=\"All Exceptions, including Errors\" name=\"all\">all<\/option>\n+        <option label=\"Errors and 100 Exceptions Per Second\" name=\"throttled\">throttled<\/option>\n+        <option label=\"Errors and All Exceptions\" name=\"all\">all<\/option>\n@@ -1147,1 +1152,1 @@\n-          <test name=\"exceptions\" operator=\"equal\" value=\"errors\"\/>\n+          <test name=\"exceptions\" operator=\"equal\" value=\"throttled\"\/>\n@@ -1153,0 +1158,7 @@\n+        <or>\n+          <test name=\"exceptions\" operator=\"equal\" value=\"throttled\"\/>\n+          <test name=\"exceptions\" operator=\"equal\" value=\"all\"\/>\n+        <\/or>\n+      <\/condition>\n+\n+      <condition name=\"exceptions-throttle-rate\" true=\"off\" false=\"100\/s\">\n@@ -1180,4 +1192,0 @@\n-      <text name=\"file-threshold\" label=\"File I\/O Threshold\" contentType=\"timespan\" minimum=\"0 s\">20 ms<\/text>\n-\n-      <text name=\"socket-threshold\" label=\"Socket I\/O Threshold\" contentType=\"timespan\" minimum=\"0 s\">20 ms<\/text>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -772,1 +772,1 @@\n-      <setting name=\"threshold\" control=\"file-threshold\">10 ms<\/setting>\n+      <setting name=\"threshold\">10 ms<\/setting>\n@@ -778,1 +778,2 @@\n-      <setting name=\"threshold\" control=\"file-threshold\">10 ms<\/setting>\n+      <setting name=\"threshold\">1 ms<\/setting>\n+      <setting name=\"throttle\">300\/s<\/setting>\n@@ -784,1 +785,2 @@\n-      <setting name=\"threshold\" control=\"file-threshold\">10 ms<\/setting>\n+      <setting name=\"threshold\">1 ms<\/setting>\n+      <setting name=\"throttle\">300\/s<\/setting>\n@@ -790,1 +792,2 @@\n-      <setting name=\"threshold\" control=\"socket-threshold\">10 ms<\/setting>\n+      <setting name=\"threshold\">1 ms<\/setting>\n+      <setting name=\"throttle\">300\/s<\/setting>\n@@ -796,1 +799,2 @@\n-      <setting name=\"threshold\" control=\"socket-threshold\">10 ms<\/setting>\n+      <setting name=\"threshold\">1 ms<\/setting>\n+      <setting name=\"throttle\">300\/s<\/setting>\n@@ -839,1 +843,1 @@\n-      <setting name=\"enabled\" control=\"enable-exceptions\">false<\/setting>\n+      <setting name=\"enabled\" control=\"enable-exceptions\">true<\/setting>\n@@ -841,0 +845,1 @@\n+      <setting name=\"throttle\" control=\"exceptions-throttle-rate\">300\/s<\/setting>\n@@ -1138,1 +1143,1 @@\n-      <selection name=\"exceptions\" default=\"errors\" label=\"Exceptions\">\n+      <selection name=\"exceptions\" default=\"throttled\" label=\"Exceptions\">\n@@ -1140,2 +1145,2 @@\n-        <option label=\"Errors Only\" name=\"errors\">errors<\/option>\n-        <option label=\"All Exceptions, including Errors\" name=\"all\">all<\/option>\n+        <option label=\"Errors and 300 Exceptions Per Second\" name=\"throttled\">throttled<\/option>\n+        <option label=\"Errors and All Exceptions\" name=\"all\">all<\/option>\n@@ -1146,1 +1151,1 @@\n-          <test name=\"exceptions\" operator=\"equal\" value=\"errors\"\/>\n+          <test name=\"exceptions\" operator=\"equal\" value=\"throttled\"\/>\n@@ -1152,1 +1157,8 @@\n-        <test name=\"exceptions\" operator=\"equal\" value=\"all\"\/>\n+        <or>\n+          <test name=\"exceptions\" operator=\"equal\" value=\"throttled\"\/>\n+          <test name=\"exceptions\" operator=\"equal\" value=\"all\"\/>\n+        <\/or>\n+      <\/condition>\n+\n+      <condition name=\"exceptions-throttle-rate\" true=\"off\" false=\"300\/s\">\n+         <test name=\"exceptions\" operator=\"equal\" value=\"all\"\/>\n@@ -1179,4 +1191,0 @@\n-      <text name=\"file-threshold\" label=\"File I\/O Threshold\" contentType=\"timespan\" minimum=\"0 s\">10 ms<\/text>\n-\n-      <text name=\"socket-threshold\" label=\"Socket I\/O Threshold\" contentType=\"timespan\" minimum=\"0 s\">10 ms<\/text>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.metadata.annotations;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Constructor;\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.jfr.AnnotationElement;\n+import jdk.jfr.Event;\n+import jdk.jfr.EventType;\n+import jdk.jfr.MetadataDefinition;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Recording;\n+import jdk.jfr.SettingDefinition;\n+import jdk.jfr.SettingDescriptor;\n+import jdk.jfr.Throttle;\n+import jdk.jfr.ValueDescriptor;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.Events;\n+import jdk.jfr.SettingControl;\n+\n+\/**\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.metadata.annotations.TestThrottle\n+ *\/\n+public class TestThrottle {\n+\n+    @Throttle(\"off\")\n+    @Enabled(false)\n+    public static class ThrottledDisabledEvent extends Event {\n+    }\n+\n+    @Throttle(\"off\")\n+    public static class ThrottledOffEvent extends Event {\n+    }\n+\n+    @Throttle(\"0\/s\")\n+    public static class ThrottledZeroRateEvent extends Event {\n+    }\n+\n+    @Throttle(\"10000000\/s\")\n+    public static class ThrottledHighRateEvent extends Event {\n+    }\n+\n+    @Throttle(\"off\")\n+    @Threshold(\"5 h\")\n+    public static class ThrottledThresholdedEvent extends Event {\n+    }\n+\n+    @Throttle(\"50\/s\")\n+    public static class ThrottledNormalRateEvent extends Event {\n+        public int index;\n+    }\n+\n+    static class TestSetting extends SettingControl {\n+        private boolean value;\n+\n+        @Override\n+        public String combine(Set<String> values) {\n+            if (values.contains(\"true\")) {\n+                return \"true\";\n+            }\n+            if (values.contains(\"false\")) {\n+                return \"false\";\n+            }\n+            return \"true\";\n+        }\n+\n+        @Override\n+        public void setValue(String text) {\n+            value = Boolean.parseBoolean(text);\n+        }\n+\n+        @Override\n+        public String getValue() {\n+            return \"\" + value;\n+        }\n+    }\n+\n+    @Throttle(\"10000000\/s\")\n+    public static class ThrottledUserdefinedEvent extends Event {\n+        @SettingDefinition\n+        public boolean test(TestSetting control) {\n+            return control.value;\n+        }\n+    }\n+\n+    @Throttle(\"50\/s\")\n+    public static class ThrottledReuseEvent extends Event {\n+        public int index;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testThrottleDisabled();\n+        testThrottledOff();\n+        testThottleZeroRate();\n+        testThrottleHighRate();\n+        testThrottleThresholded();\n+        testThrottleNormalRate();\n+        testThrottleUserdefined();\n+    }\n+\n+    private static void testThrottleDisabled() throws Exception {\n+        testEvent(ThrottledDisabledEvent.class, false);\n+    }\n+\n+    private static void testThrottledOff() throws Exception {\n+        testEvent(ThrottledOffEvent.class, true);\n+    }\n+\n+    private static void testThottleZeroRate() throws Exception {\n+        testEvent(ThrottledZeroRateEvent.class, false);\n+    }\n+\n+    private static void testThrottleHighRate() throws Exception {\n+        testEvent(ThrottledHighRateEvent.class, true);\n+    }\n+\n+    private static void testThrottleThresholded() throws Exception {\n+        testEvent(ThrottledThresholdedEvent.class, false);\n+    }\n+\n+    private static void testThrottleNormalRate() throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            AtomicInteger lastIndex = new AtomicInteger();\n+            AtomicInteger throttled = new AtomicInteger();\n+            rs.onEvent(ThrottledNormalRateEvent.class.getName(), e -> {\n+                int index = e.getInt(\"index\");\n+                if (lastIndex.get() + 1 != index) {\n+                    throttled.incrementAndGet();\n+                }\n+                lastIndex.set(index);\n+            });\n+            rs.startAsync();\n+            int index = 1;\n+            while (throttled.get() < 30) {\n+                ThrottledNormalRateEvent e = new ThrottledNormalRateEvent();\n+                e.index = index;\n+                e.commit();\n+                index++;\n+                Thread.sleep(3);\n+            }\n+        }\n+    }\n+\n+    private static void testThrottleUserdefined() throws Exception {\n+        testThrottleUserdefined(\"false\", \"1000000\/s\", false);\n+        testThrottleUserdefined(\"true\", \"10000000\/s\", true);\n+        testThrottleUserdefined(\"true\", \"0\/s\", false);\n+        testThrottleUserdefined(\"true\", \"off\", true);\n+        testThrottleUserdefined(\"false\", \"off\", false);\n+    }\n+\n+    private static void testThrottleUserdefined(String test, String throttle, boolean emit) throws Exception {\n+        String eventName = ThrottledUserdefinedEvent.class.getName();\n+        try (Recording r = new Recording()) {\n+            r.enable(eventName).with(\"test\", test).with(\"throttle\", throttle);\n+            r.start();\n+\n+            ThrottledUserdefinedEvent e1 = new ThrottledUserdefinedEvent();\n+            e1.commit();\n+\n+            ThrottledUserdefinedEvent e2 = new ThrottledUserdefinedEvent();\n+            e2.begin();\n+            e2.commit();\n+\n+            ThrottledUserdefinedEvent e3 = new ThrottledUserdefinedEvent();\n+            e3.begin();\n+            e3.end();\n+            e3.commit();\n+\n+            ThrottledUserdefinedEvent e4 = new ThrottledUserdefinedEvent();\n+            if (e4.shouldCommit()) {\n+                e4.commit();\n+            }\n+            assertShouldCommit(e4, emit);\n+\n+            ThrottledUserdefinedEvent e5 = new ThrottledUserdefinedEvent();\n+            assertShouldCommit(e5, emit);\n+            if (e5.shouldCommit()) {\n+                e5.commit();\n+            }\n+\n+            r.stop();\n+            assertEvents(r, eventName, emit ? 5 : 0);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void testEvent(Class<? extends Event> eventClass, boolean shouldCommit) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            Constructor<Event> c = (Constructor<Event>) eventClass.getConstructor();\n+            for (int i = 0; i < 17; i++) {\n+                Event e = c.newInstance();\n+                if (i % 5 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+                e.commit();\n+                if (i % 3 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+            }\n+            for (int i = 0; i < 50; i++) {\n+                Event e = c.newInstance();\n+                e.begin();\n+                if (i % 5 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+                e.end();\n+                if (i % 3 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+                e.commit();\n+                if (i % 7 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+            }\n+            for (int i = 0; i < 11; i++) {\n+                Event e = c.newInstance();\n+                e.begin();\n+                e.commit();\n+                if (i % 7 == 0) {\n+                    assertShouldCommit(e, shouldCommit);\n+                }\n+            }\n+            if (shouldCommit) {\n+                assertEvents(r, eventClass.getName(), 17 + 50 + 11);\n+            }\n+        }\n+    }\n+\n+    private static void assertEvents(Recording r, String name, int expected) throws Exception {\n+        int count = 0;\n+        for (RecordedEvent event : Events.fromRecording(r)) {\n+            if (event.getEventType().getName().equals(name)) {\n+                count++;\n+            }\n+        }\n+        if (count != expected) {\n+            throw new Exception(\"Expected \" + expected + \" \" + name + \" events, but found \" + count);\n+        }\n+    }\n+\n+    private static void assertShouldCommit(Event e, boolean expected) throws Exception {\n+        if (e.shouldCommit() != expected) {\n+            throw new Exception(\"Expected \" + e.getClass() + \"::shouldCommit() to return \" + expected);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/TestThrottle.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -69,1 +69,1 @@\n-                        throw new Exception(\"Superflous event type \" + parsedType.getName() + \" in recording\");\n+                        throw new Exception(\"Superfluous event type \" + parsedType.getName() + \" in recording\");\n@@ -78,1 +78,1 @@\n-                            throw new Exception(\"Superflous setting \" + parsedSetting.getName() + \" in \" + parsedType.getName());\n+                            throw new Exception(\"Superfluous setting \" + parsedSetting.getName() + \" in \" + parsedType.getName());\n@@ -92,2 +92,2 @@\n-        testSetting(EventNames.FileRead, \"enabled\", \"threshold\", \"stackTrace\");\n-        testSetting(EventNames.FileWrite, \"enabled\", \"threshold\",\"stackTrace\");\n+        testSetting(EventNames.FileRead, \"enabled\", \"threshold\", \"stackTrace\", \"throttle\");\n+        testSetting(EventNames.FileWrite, \"enabled\", \"threshold\", \"stackTrace\", \"throttle\");\n@@ -95,2 +95,2 @@\n-        testSetting(EventNames.SocketRead, \"enabled\", \"threshold\", \"stackTrace\");\n-        testSetting(EventNames.SocketWrite, \"enabled\", \"threshold\", \"stackTrace\");\n+        testSetting(EventNames.SocketRead, \"enabled\", \"threshold\", \"stackTrace\", \"throttle\");\n+        testSetting(EventNames.SocketWrite, \"enabled\", \"threshold\", \"stackTrace\", \"throttle\");\n@@ -99,1 +99,1 @@\n-        testSetting(EventNames.JavaExceptionThrow, \"enabled\", \"stackTrace\");\n+        testSetting(EventNames.JavaExceptionThrow, \"enabled\", \"stackTrace\", \"throttle\");\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/settings\/TestSettingsAvailability.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- *      -XX:StartFlightRecording:class-loading=true,socket-threshold=100ms\n+ *      -XX:StartFlightRecording:class-loading=true,locking-threshold=100ms\n@@ -73,1 +73,1 @@\n-            assertSetting(\"jdk.SocketRead#threshold\", \"100 ms\");\n+            assertSetting(\"jdk.JavaMonitorEnter#threshold\", \"100 ms\");\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestEventSettings.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}