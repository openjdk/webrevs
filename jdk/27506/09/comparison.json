{"files":[{"patch":"@@ -202,0 +202,2 @@\n+  constexpr static bool supports_misaligned_vector_accesses() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  constexpr static bool supports_misaligned_vector_accesses() { return true; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n@@ -28,0 +30,2 @@\n+#include \"code\/codeBlob.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -30,0 +34,1 @@\n+#include \"runtime\/stubCodeGenerator.hpp\"\n@@ -37,0 +42,52 @@\n+address VM_Version::_misaligned_vector_fault_pc1 = nullptr;\n+address VM_Version::_misaligned_vector_fault_pc2 = nullptr;\n+address VM_Version::_misaligned_vector_continuation_pc = nullptr;\n+long array[2] = { 0 };\n+\n+static BufferBlob* stub_blob;\n+static const int stub_size = 256;\n+\n+extern \"C\" {\n+  typedef int (*detect_misaligned_vector_stub_t)();\n+}\n+\n+static detect_misaligned_vector_stub_t detect_misaligned_vector_stub = nullptr;\n+\n+\n+class VM_Version_StubGenerator: public StubCodeGenerator {\n+ public:\n+\n+  VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}\n+  ~VM_Version_StubGenerator() {}\n+\n+  address generate_detect_misaligned_vector(address* fault_pc1, address* fault_pc2, address* continuation_pc, int esize) {\n+    StubCodeMark mark(this, \"VM_Version\", \"detect_misaligned_vector_stub\");\n+#   define __ _masm->\n+    address start = __ pc();\n+    Assembler::SEW sew = Assembler::elembytes_to_sew(esize);\n+\n+    __ enter();\n+    __ mv(x10, zr);\n+    __ la(t1, ExternalAddress((address) array));\n+    __ addi(t1, t1, esize - 1);   \/\/ Misaligned address\n+    __ vsetivli(x0, 1, sew);\n+    __ vmv_s_x(v2, zr);\n+\n+    __ addi(t2, zr, 1);\n+    __ vmv_s_x(v1, t2);\n+    *fault_pc1 = __ pc();\n+    __ vsex_v(v1, t1, sew);   \/\/ Misaligned vector store\n+\n+    *fault_pc2 = __ pc();\n+    __ vlex_v(v2, t1, sew);   \/\/ Misaligned vector load\n+\n+    *continuation_pc = __ pc();\n+    __ vmv_x_s(x10, v2);\n+    __ leave();\n+    __ ret();\n+\n+#   undef __\n+\n+    return start;\n+  }\n+};\n@@ -170,3 +227,19 @@\n-  if (FLAG_IS_DEFAULT(AlignVector)) {\n-    FLAG_SET_DEFAULT(AlignVector,\n-      unaligned_vector.value() != MISALIGNED_VECTOR_FAST);\n+  if (UseRVV) {\n+    \/\/ The hwprobe syscall won't be able to detect support for misaligned vector accesses on old kernels.\n+    \/\/ Resort to detect_misaligned_vector_support() to see if misaligned vector accesses may trap or not.\n+    if (!unaligned_vector.enabled()) {\n+      if (AlignVector == false && !VM_Version::detect_misaligned_vector_support()) {\n+        warning(\"Misaligned vector accesses are not supported on this CPU\");\n+        FLAG_SET_DEFAULT(AlignVector, true);\n+      }\n+    } else {\n+      if (FLAG_IS_DEFAULT(AlignVector)) {\n+        FLAG_SET_DEFAULT(AlignVector,\n+          unaligned_vector.value() != MISALIGNED_VECTOR_FAST);\n+      } else if (AlignVector == false) {\n+        if (unaligned_vector.value() != MISALIGNED_VECTOR_FAST) {\n+          warning(\"Misaligned vector accesses are not supported on this CPU\");\n+          FLAG_SET_DEFAULT(AlignVector, true);\n+        }\n+      }\n+    }\n@@ -484,0 +557,26 @@\n+\n+bool VM_Version::detect_misaligned_vector_support() {\n+  \/\/ Detect with element sizes of 2, 4, and 8 bytes\n+  return detect_misaligned_vector_support(2) &&\n+         detect_misaligned_vector_support(4) &&\n+         detect_misaligned_vector_support(8);\n+}\n+\n+bool VM_Version::detect_misaligned_vector_support(int esize) {\n+  ResourceMark rm;\n+\n+  stub_blob = BufferBlob::create(\"detect_misaligned_vector_stub\", stub_size);\n+  if (stub_blob == nullptr) {\n+    vm_exit_during_initialization(\"Unable to allocate detect_misaligned_vector_stub\");\n+  }\n+\n+  CodeBuffer c(stub_blob);\n+  VM_Version_StubGenerator g(&c);\n+  detect_misaligned_vector_stub = CAST_TO_FN_PTR(detect_misaligned_vector_stub_t,\n+                                                 g.generate_detect_misaligned_vector(\n+                                                 &VM_Version::_misaligned_vector_fault_pc1,\n+                                                 &VM_Version::_misaligned_vector_fault_pc2,\n+                                                 &VM_Version::_misaligned_vector_continuation_pc, esize));\n+\n+  return detect_misaligned_vector_stub() == 1;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":102,"deletions":3,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -505,0 +505,15 @@\n+  static bool supports_misaligned_vector_accesses() { return !AlignVector; }\n+\n+  static bool is_misaligned_vector_fault(address pc) {\n+    return pc != nullptr && (pc == _misaligned_vector_fault_pc1 || pc == _misaligned_vector_fault_pc2);\n+  }\n+\n+  static address continuation_for_misaligned_vector_fault(address pc) {\n+    assert(_misaligned_vector_continuation_pc != nullptr , \"not initialized\");\n+    return _misaligned_vector_continuation_pc;\n+  }\n+\n+  static address _misaligned_vector_fault_pc1;\n+  static address _misaligned_vector_fault_pc2;\n+  static address _misaligned_vector_continuation_pc;\n+\n@@ -517,0 +532,6 @@\n+\n+  \/\/ Detect misaligned vector support\n+  static bool detect_misaligned_vector_support();\n+\n+  \/\/ Detect misaligned vector support by sew\n+  static bool detect_misaligned_vector_support(int esize);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -428,0 +428,2 @@\n+  constexpr static bool supports_misaligned_vector_accesses() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -994,0 +994,4 @@\n+  constexpr static bool supports_misaligned_vector_accesses() {\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -290,0 +290,5 @@\n+\n+    if (sig == SIGBUS && VM_Version::is_misaligned_vector_fault(pc)) {\n+      os::Posix::ucontext_set_pc(uc, VM_Version::continuation_for_misaligned_vector_fault(pc));\n+      return true;\n+    }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-    if (FLAG_IS_DEFAULT(EnableVectorSupport)) {\n+    if (FLAG_IS_DEFAULT(EnableVectorSupport) && VM_Version::supports_misaligned_vector_accesses()) {\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,0 +200,3 @@\n+  \/\/ Does platform support misaligned vector accesses?\n+  constexpr static bool supports_misaligned_vector_accesses() { return false; }\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorAddMulReduction.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCommutativeOperSharingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorExpandTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFusedMultiplyAddSubTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCompareNotTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+* @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskFromLongTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskLaneIsSetTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+* @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskToLongTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+* @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorSaturatedOperationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+* @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorUnsignedMinMaxOperationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastRVV.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ * @requires vm.opt.EnableVectorSupport == true\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorReinterpret.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}