{"files":[{"patch":"@@ -183,0 +183,3 @@\n+  \/\/ Is recursive lightweight locking implemented for this platform?\n+  constexpr static bool supports_recursive_lightweight_locking() { return false; }\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -34,0 +35,2 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -36,0 +39,2 @@\n+#include <type_traits>\n+\n@@ -42,0 +47,5 @@\n+  \/\/ Make sure the layout of the object is compatible with the emitted code's assumptions.\n+  STATIC_ASSERT(sizeof(_bad_oop_sentinel) == oopSize);\n+  STATIC_ASSERT(sizeof(_base[0]) == oopSize);\n+  STATIC_ASSERT(std::is_standard_layout<LockStack>::value);\n+  STATIC_ASSERT(offsetof(LockStack, _bad_oop_sentinel) == offsetof(LockStack, _base) - oopSize);\n@@ -70,0 +80,10 @@\n+      if (VM_Version::supports_recursive_lightweight_locking()) {\n+        oop o = _base[i];\n+        for (; i < top - 1; i++) {\n+          \/\/ Consecutive entries may be the same\n+          if (_base[i + 1] != o) {\n+            break;\n+          }\n+        }\n+      }\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  friend class LockStackTest;\n@@ -54,0 +55,3 @@\n+  \/\/ The _bad_oop_sentinel acts as a sentinel value to elide underflow checks in generated code.\n+  \/\/ The correct layout is statically asserted in the constructor.\n+  const uintptr_t _bad_oop_sentinel = badOopVal;\n@@ -78,2 +82,2 @@\n-  \/\/ Return true if we have room to push onto this lock-stack, false otherwise.\n-  inline bool can_push() const;\n+  \/\/ Returns true if the lock-stack is full. False otherwise.\n+  inline bool is_full() const;\n@@ -84,0 +88,18 @@\n+  \/\/ Get the oldest oop from this lock-stack.\n+  \/\/ Precondition: This lock-stack must not be empty.\n+  inline oop bottom() const;\n+\n+  \/\/ Is the lock-stack empty.\n+  inline bool is_empty() const;\n+\n+  \/\/ Check if object is recursive.\n+  \/\/ Precondition: This lock-stack must contain the oop.\n+  inline bool is_recursive(oop o) const;\n+\n+  \/\/ Try recursive enter.\n+  inline bool try_recursive_enter(oop o);\n+\n+  \/\/ Try recursive exit.\n+  \/\/ Precondition: This lock-stack must contain the oop.\n+  inline bool try_recursive_exit(oop o);\n+\n@@ -85,1 +107,3 @@\n-  inline void remove(oop o);\n+  \/\/ Precondition: This lock-stack must contain the oop.\n+  \/\/ Returns the number of oops removed.\n+  inline size_t remove(oop o);\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"runtime\/lockStack.hpp\"\n+\n@@ -31,1 +33,0 @@\n-#include \"runtime\/lockStack.hpp\"\n@@ -35,0 +36,2 @@\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,0 +40,1 @@\n+  assert(is_aligned(offset, oopSize), \"Bad alignment: %u\", offset);\n@@ -45,2 +49,2 @@\n-inline bool LockStack::can_push() const {\n-  return to_index(_top) < CAPACITY;\n+inline bool LockStack::is_full() const {\n+  return to_index(_top) == CAPACITY;\n@@ -64,1 +68,1 @@\n-  assert(can_push(), \"must have room\");\n+  assert(!is_full(), \"must have room\");\n@@ -71,1 +75,62 @@\n-inline void LockStack::remove(oop o) {\n+inline oop LockStack::bottom() const {\n+  assert(to_index(_top) > 0, \"must contain an oop\");\n+  return _base[0];\n+}\n+\n+inline bool LockStack::is_empty() const {\n+  return to_index(_top) == 0;\n+}\n+\n+inline bool LockStack::is_recursive(oop o) const {\n+  if (!VM_Version::supports_recursive_lightweight_locking()) {\n+    return false;\n+  }\n+\n+  assert(contains(o), \"entries must exist\");\n+  int end = to_index(_top);\n+  for (int i = 1; i < end; i++) {\n+    if (_base[i - 1] == o && _base[i] == o) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+inline bool LockStack::try_recursive_enter(oop o) {\n+  if (!VM_Version::supports_recursive_lightweight_locking()) {\n+    return false;\n+  }\n+\n+  assert(!is_full(), \"precond\");\n+\n+  int end = to_index(_top);\n+  if (end == 0 || _base[end - 1] != o) {\n+    \/\/ Topmost oop does not match o.\n+    return false;\n+  }\n+\n+  _base[end] = o;\n+  _top += oopSize;\n+  return true;\n+}\n+\n+inline bool LockStack::try_recursive_exit(oop o) {\n+  if (!VM_Version::supports_recursive_lightweight_locking()) {\n+    return false;\n+  }\n+\n+  assert(contains(o), \"entries must exist\");\n+\n+  int end = to_index(_top);\n+  if (end <= 1 || _base[end - 1] != o ||  _base[end - 2] != o) {\n+    \/\/ The two topmost oop does not match o.\n+    return false;\n+  }\n+\n+  _top -= oopSize;\n+  DEBUG_ONLY(_base[to_index(_top)] = nullptr;)\n+  return true;\n+}\n+\n+inline size_t LockStack::remove(oop o) {\n@@ -74,0 +139,1 @@\n+\n@@ -75,0 +141,1 @@\n+  int inserted = 0;\n@@ -76,10 +143,2 @@\n-    if (_base[i] == o) {\n-      int last = end - 1;\n-      for (; i < last; i++) {\n-        _base[i] = _base[i + 1];\n-      }\n-      _top -= oopSize;\n-#ifdef ASSERT\n-      _base[to_index(_top)] = nullptr;\n-#endif\n-      break;\n+    if (_base[i] != o) {\n+      _base[inserted++] = _base[i];\n@@ -88,1 +147,10 @@\n-  assert(!contains(o), \"entries must be unique: \" PTR_FORMAT, p2i(o));\n+\n+#ifdef ASSERT\n+  for (int i = inserted; i < end; i++) {\n+    _base[i] = nullptr;\n+  }\n+#endif\n+\n+  uint32_t removed = end - inserted;\n+  _top -= removed * oopSize;\n+  assert(!contains(o), \"entry must have been removed: \" PTR_FORMAT, p2i(o));\n@@ -90,0 +158,1 @@\n+  return removed;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":85,"deletions":16,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -302,0 +302,1 @@\n+  void      set_recursions(size_t recursions);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,0 +105,6 @@\n+inline void ObjectMonitor::set_recursions(size_t recursions) {\n+  assert(_recursions == 0, \"must be\");\n+  assert(has_owner(), \"must be owned\");\n+  _recursions = checked_cast<intx>(recursions);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -63,0 +64,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -349,0 +351,13 @@\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LockStack& lock_stack = current->lock_stack();\n+    if (lock_stack.is_full()) {\n+      \/\/ Always go into runtime if the lock stack is full.\n+      return false;\n+    }\n+    if (lock_stack.try_recursive_enter(obj)) {\n+      \/\/ Recursive lock successful.\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+\n@@ -475,3 +490,12 @@\n-      if (lock_stack.can_push()) {\n-        markWord mark = obj()->mark_acquire();\n-        while (mark.is_neutral()) {\n+      if (lock_stack.is_full()) {\n+        \/\/ The emitted code always goes into the runtime in case the lock stack\n+        \/\/ is full. We unconditionally make room on the lock stack by inflating\n+        \/\/ the least recently locked object on the lock stack.\n+        ObjectMonitor* monitor = inflate(current, lock_stack.bottom(), inflate_cause_vm_internal);\n+        assert(monitor->owner() == current, \"must be owner=\" PTR_FORMAT \" current=\" PTR_FORMAT \" mark=\" PTR_FORMAT,\n+               p2i(monitor->owner()), p2i(current), monitor->object()->mark_acquire().value());\n+        assert(!lock_stack.is_full(), \"must have made room here\");\n+      }\n+\n+      markWord mark = obj()->mark_acquire();\n+      while (mark.is_neutral()) {\n@@ -490,0 +514,4 @@\n+\n+        if (mark.is_fast_locked() && lock_stack.try_recursive_enter(obj())) {\n+        \/\/ Recursive lock successful.\n+        return;\n@@ -538,7 +566,17 @@\n-      while (mark.is_fast_locked()) {\n-        \/\/ Retry until a lock state change has been observed.  cas_set_mark() may collide with non lock bits modifications.\n-        const markWord unlocked_mark = mark.set_fast_locked();\n-        const markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n-        if (old_mark == mark) {\n-          current->lock_stack().remove(object);\n-          return;\n+      LockStack& lock_stack = current->lock_stack();\n+      if (mark.is_fast_locked() && lock_stack.try_recursive_exit(object)) {\n+        \/\/ Recursively unlocked.\n+        return;\n+      } else if (mark.is_fast_locked() && lock_stack.is_recursive(object)) {\n+        \/\/ This lock is recursive but unstructured exit. Just inflate the lock.\n+      } else {\n+        while (mark.is_fast_locked()) {\n+          \/\/ Retry until a lock state change has been observed.  cas_set_mark() may collide with non lock bits modifications.\n+          const markWord unlocked_mark = mark.set_fast_locked();\n+          const markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n+          if (old_mark == mark) {\n+            size_t recursions = lock_stack.remove(object) - 1;\n+            assert(recursions == 0, \"must not be recursive here\");\n+            return;\n+          }\n+          mark = old_mark;\n@@ -546,1 +584,0 @@\n-        mark = old_mark;\n@@ -1282,1 +1319,2 @@\n-        JavaThread::cast(current)->lock_stack().remove(object);\n+        size_t removed = JavaThread::cast(current)->lock_stack().remove(object);\n+        inf->set_recursions(removed - 1);\n@@ -1328,1 +1366,2 @@\n-          JavaThread::cast(current)->lock_stack().remove(object);\n+          size_t removed = JavaThread::cast(current)->lock_stack().remove(object);\n+          monitor->set_recursions(removed - 1);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":52,"deletions":13,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,428 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class LockStackTest : public ::testing::Test {\n+public:\n+  static void push_raw(LockStack& ls, oop obj) {\n+    ls._base[ls.to_index(ls._top)] = obj;\n+    ls._top += oopSize;\n+\n+  }\n+\n+  static void pop_raw(LockStack& ls) {\n+    ls._top -= oopSize;\n+#ifdef ASSERT\n+    ls._base[ls.to_index(ls._top)] = nullptr;\n+#endif\n+  }\n+\n+  static oop at(LockStack& ls, int index) {\n+    return ls._base[index];\n+  }\n+\n+  static size_t size(LockStack& ls) {\n+    return ls.to_index(ls._top);\n+  }\n+};\n+\n+#define recursive_enter(ls, obj)             \\\n+  do {                                       \\\n+    bool ret = ls.try_recursive_enter(obj);  \\\n+    EXPECT_TRUE(ret);                        \\\n+  } while (false)\n+\n+#define recursive_exit(ls, obj)             \\\n+  do {                                      \\\n+    bool ret = ls.try_recursive_exit(obj);  \\\n+    EXPECT_TRUE(ret);                       \\\n+  } while (false)\n+\n+TEST_VM_F(LockStackTest, is_recursive) {\n+  if (LockingMode != LM_LIGHTWEIGHT || !VM_Version::supports_recursive_lightweight_locking()) {\n+    return;\n+  }\n+\n+  JavaThread* THREAD = JavaThread::current();\n+  \/\/ the thread should be in vm to use locks\n+  ThreadInVMfromNative ThreadInVMfromNative(THREAD);\n+\n+  LockStack& ls = THREAD->lock_stack();\n+\n+  EXPECT_TRUE(ls.is_empty());\n+\n+  oop obj0 = Universe::int_mirror();\n+  oop obj1 = Universe::float_mirror();\n+\n+  push_raw(ls, obj0);\n+\n+  \/\/ 0\n+  EXPECT_FALSE(ls.is_recursive(obj0));\n+\n+  push_raw(ls, obj1);\n+\n+  \/\/ 0, 1\n+  EXPECT_FALSE(ls.is_recursive(obj0));\n+  EXPECT_FALSE(ls.is_recursive(obj1));\n+\n+  push_raw(ls, obj1);\n+\n+  \/\/ 0, 1, 1\n+  EXPECT_FALSE(ls.is_recursive(obj0));\n+  EXPECT_TRUE(ls.is_recursive(obj1));\n+\n+  pop_raw(ls);\n+  pop_raw(ls);\n+  push_raw(ls, obj0);\n+\n+  \/\/ 0, 0\n+  EXPECT_TRUE(ls.is_recursive(obj0));\n+\n+  push_raw(ls, obj0);\n+\n+  \/\/ 0, 0, 0\n+  EXPECT_TRUE(ls.is_recursive(obj0));\n+\n+  pop_raw(ls);\n+  push_raw(ls, obj1);\n+\n+  \/\/ 0, 0, 1\n+  EXPECT_TRUE(ls.is_recursive(obj0));\n+  EXPECT_FALSE(ls.is_recursive(obj1));\n+\n+  push_raw(ls, obj1);\n+\n+  \/\/ 0, 0, 1, 1\n+  EXPECT_TRUE(ls.is_recursive(obj0));\n+  EXPECT_TRUE(ls.is_recursive(obj1));\n+\n+  \/\/ Clear stack\n+  pop_raw(ls);\n+  pop_raw(ls);\n+  pop_raw(ls);\n+  pop_raw(ls);\n+\n+  EXPECT_TRUE(ls.is_empty());\n+}\n+\n+TEST_VM_F(LockStackTest, try_recursive_enter) {\n+  if (LockingMode != LM_LIGHTWEIGHT || !VM_Version::supports_recursive_lightweight_locking()) {\n+    return;\n+  }\n+\n+  JavaThread* THREAD = JavaThread::current();\n+  \/\/ the thread should be in vm to use locks\n+  ThreadInVMfromNative ThreadInVMfromNative(THREAD);\n+\n+  LockStack& ls = THREAD->lock_stack();\n+\n+  EXPECT_TRUE(ls.is_empty());\n+\n+  oop obj0 = Universe::int_mirror();\n+  oop obj1 = Universe::float_mirror();\n+\n+  ls.push(obj0);\n+\n+  \/\/ 0\n+  EXPECT_FALSE(ls.is_recursive(obj0));\n+\n+  ls.push(obj1);\n+\n+  \/\/ 0, 1\n+  EXPECT_FALSE(ls.is_recursive(obj0));\n+  EXPECT_FALSE(ls.is_recursive(obj1));\n+\n+  recursive_enter(ls, obj1);\n+\n+  \/\/ 0, 1, 1\n+  EXPECT_FALSE(ls.is_recursive(obj0));\n+  EXPECT_TRUE(ls.is_recursive(obj1));\n+\n+  recursive_exit(ls, obj1);\n+  pop_raw(ls);\n+  recursive_enter(ls, obj0);\n+\n+  \/\/ 0, 0\n+  EXPECT_TRUE(ls.is_recursive(obj0));\n+\n+  recursive_enter(ls, obj0);\n+\n+  \/\/ 0, 0, 0\n+  EXPECT_TRUE(ls.is_recursive(obj0));\n+\n+  recursive_exit(ls, obj0);\n+  push_raw(ls, obj1);\n+\n+  \/\/ 0, 0, 1\n+  EXPECT_TRUE(ls.is_recursive(obj0));\n+  EXPECT_FALSE(ls.is_recursive(obj1));\n+\n+  recursive_enter(ls, obj1);\n+\n+  \/\/ 0, 0, 1, 1\n+  EXPECT_TRUE(ls.is_recursive(obj0));\n+  EXPECT_TRUE(ls.is_recursive(obj1));\n+\n+  \/\/ Clear stack\n+  pop_raw(ls);\n+  pop_raw(ls);\n+  pop_raw(ls);\n+  pop_raw(ls);\n+\n+  EXPECT_TRUE(ls.is_empty());\n+}\n+\n+TEST_VM_F(LockStackTest, contains) {\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    return;\n+  }\n+\n+  const bool test_recursive = VM_Version::supports_recursive_lightweight_locking();\n+\n+  JavaThread* THREAD = JavaThread::current();\n+  \/\/ the thread should be in vm to use locks\n+  ThreadInVMfromNative ThreadInVMfromNative(THREAD);\n+\n+  LockStack& ls = THREAD->lock_stack();\n+\n+  EXPECT_TRUE(ls.is_empty());\n+\n+  oop obj0 = Universe::int_mirror();\n+  oop obj1 = Universe::float_mirror();\n+\n+  EXPECT_FALSE(ls.contains(obj0));\n+\n+  ls.push(obj0);\n+\n+  \/\/ 0\n+  EXPECT_TRUE(ls.contains(obj0));\n+  EXPECT_FALSE(ls.contains(obj1));\n+\n+  if (test_recursive) {\n+    push_raw(ls, obj0);\n+\n+    \/\/ 0, 0\n+    EXPECT_TRUE(ls.contains(obj0));\n+    EXPECT_FALSE(ls.contains(obj1));\n+  }\n+\n+  push_raw(ls, obj1);\n+\n+  \/\/ 0, 0, 1\n+  EXPECT_TRUE(ls.contains(obj0));\n+  EXPECT_TRUE(ls.contains(obj1));\n+\n+  if (test_recursive) {\n+    push_raw(ls, obj1);\n+\n+    \/\/ 0, 0, 1, 1\n+    EXPECT_TRUE(ls.contains(obj0));\n+    EXPECT_TRUE(ls.contains(obj1));\n+  }\n+\n+  pop_raw(ls);\n+  if (test_recursive) {\n+    pop_raw(ls);\n+    pop_raw(ls);\n+  }\n+  push_raw(ls, obj1);\n+\n+  \/\/ 0, 1\n+  EXPECT_TRUE(ls.contains(obj0));\n+  EXPECT_TRUE(ls.contains(obj1));\n+\n+  \/\/ Clear stack\n+  pop_raw(ls);\n+  pop_raw(ls);\n+\n+  EXPECT_TRUE(ls.is_empty());\n+}\n+\n+TEST_VM_F(LockStackTest, remove) {\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    return;\n+  }\n+\n+  const bool test_recursive = VM_Version::supports_recursive_lightweight_locking();\n+\n+  JavaThread* THREAD = JavaThread::current();\n+  \/\/ the thread should be in vm to use locks\n+  ThreadInVMfromNative ThreadInVMfromNative(THREAD);\n+\n+  LockStack& ls = THREAD->lock_stack();\n+\n+  EXPECT_TRUE(ls.is_empty());\n+\n+  oop obj0 = Universe::int_mirror();\n+  oop obj1 = Universe::float_mirror();\n+  oop obj2 = Universe::short_mirror();\n+  oop obj3 = Universe::long_mirror();\n+\n+  push_raw(ls, obj0);\n+\n+  \/\/ 0\n+  {\n+    size_t removed = ls.remove(obj0);\n+    EXPECT_EQ(removed, 1u);\n+    EXPECT_FALSE(ls.contains(obj0));\n+  }\n+\n+  if (test_recursive) {\n+    push_raw(ls, obj0);\n+    push_raw(ls, obj0);\n+\n+    \/\/ 0, 0\n+    {\n+      size_t removed = ls.remove(obj0);\n+      EXPECT_EQ(removed, 2u);\n+      EXPECT_FALSE(ls.contains(obj0));\n+    }\n+  }\n+\n+  push_raw(ls, obj0);\n+  push_raw(ls, obj1);\n+\n+  \/\/ 0, 1\n+  {\n+    size_t removed = ls.remove(obj0);\n+    EXPECT_EQ(removed, 1u);\n+    EXPECT_FALSE(ls.contains(obj0));\n+    EXPECT_TRUE(ls.contains(obj1));\n+\n+    ls.remove(obj1);\n+    EXPECT_TRUE(ls.is_empty());\n+  }\n+\n+  push_raw(ls, obj0);\n+  push_raw(ls, obj1);\n+\n+  \/\/ 0, 1\n+  {\n+    size_t removed = ls.remove(obj1);\n+    EXPECT_EQ(removed, 1u);\n+    EXPECT_FALSE(ls.contains(obj1));\n+    EXPECT_TRUE(ls.contains(obj0));\n+\n+    ls.remove(obj0);\n+    EXPECT_TRUE(ls.is_empty());\n+  }\n+\n+  if (test_recursive) {\n+    push_raw(ls, obj0);\n+    push_raw(ls, obj0);\n+    push_raw(ls, obj1);\n+\n+    \/\/ 0, 0, 1\n+    {\n+      size_t removed = ls.remove(obj0);\n+      EXPECT_EQ(removed, 2u);\n+      EXPECT_FALSE(ls.contains(obj0));\n+      EXPECT_TRUE(ls.contains(obj1));\n+\n+      ls.remove(obj1);\n+      EXPECT_TRUE(ls.is_empty());\n+    }\n+\n+    push_raw(ls, obj0);\n+    push_raw(ls, obj1);\n+    push_raw(ls, obj1);\n+\n+    \/\/ 0, 1, 1\n+    {\n+      size_t removed = ls.remove(obj1);\n+      EXPECT_EQ(removed, 2u);\n+      EXPECT_FALSE(ls.contains(obj1));\n+      EXPECT_TRUE(ls.contains(obj0));\n+\n+      ls.remove(obj0);\n+      EXPECT_TRUE(ls.is_empty());\n+    }\n+\n+    push_raw(ls, obj0);\n+    push_raw(ls, obj1);\n+    push_raw(ls, obj1);\n+    push_raw(ls, obj2);\n+    push_raw(ls, obj2);\n+    push_raw(ls, obj2);\n+    push_raw(ls, obj2);\n+    push_raw(ls, obj3);\n+\n+    \/\/ 0, 1, 1, 2, 2, 2, 2, 3\n+    {\n+      EXPECT_EQ(size(ls), 8u);\n+\n+      size_t removed = ls.remove(obj1);\n+      EXPECT_EQ(removed, 2u);\n+\n+      EXPECT_TRUE(ls.contains(obj0));\n+      EXPECT_FALSE(ls.contains(obj1));\n+      EXPECT_TRUE(ls.contains(obj2));\n+      EXPECT_TRUE(ls.contains(obj3));\n+\n+      EXPECT_EQ(at(ls, 0), obj0);\n+      EXPECT_EQ(at(ls, 1), obj2);\n+      EXPECT_EQ(at(ls, 2), obj2);\n+      EXPECT_EQ(at(ls, 3), obj2);\n+      EXPECT_EQ(at(ls, 4), obj2);\n+      EXPECT_EQ(at(ls, 5), obj3);\n+      EXPECT_EQ(size(ls), 6u);\n+\n+      removed = ls.remove(obj2);\n+      EXPECT_EQ(removed, 4u);\n+\n+      EXPECT_TRUE(ls.contains(obj0));\n+      EXPECT_FALSE(ls.contains(obj1));\n+      EXPECT_FALSE(ls.contains(obj2));\n+      EXPECT_TRUE(ls.contains(obj3));\n+\n+      EXPECT_EQ(at(ls, 0), obj0);\n+      EXPECT_EQ(at(ls, 1), obj3);\n+      EXPECT_EQ(size(ls), 2u);\n+\n+      removed = ls.remove(obj0);\n+      EXPECT_EQ(removed, 1u);\n+\n+      EXPECT_FALSE(ls.contains(obj0));\n+      EXPECT_FALSE(ls.contains(obj1));\n+      EXPECT_FALSE(ls.contains(obj2));\n+      EXPECT_TRUE(ls.contains(obj3));\n+\n+      EXPECT_EQ(at(ls, 0), obj3);\n+      EXPECT_EQ(size(ls), 1u);\n+\n+      removed = ls.remove(obj3);\n+      EXPECT_EQ(removed, 1u);\n+\n+      EXPECT_TRUE(ls.is_empty());\n+      EXPECT_EQ(size(ls), 0u);\n+    }\n+  }\n+\n+  EXPECT_TRUE(ls.is_empty());\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_lockStack.cpp","additions":428,"deletions":0,"binary":false,"changes":428,"status":"added"},{"patch":"@@ -138,0 +138,1 @@\n+  gtest\/LockStackGtests.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* @test\n+ * @summary Run LockStack gtests with LockingMode=2\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.flagless\n+ * @run main\/native GTestWrapper --gtest_filter=LockStackTest* -XX:LockingMode=2\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/LockStackGtests.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"}]}