{"files":[{"patch":"@@ -598,1 +598,3 @@\n-    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\", &ss);\n+    \/\/ It is important that we traverse both inputs and outputs of nodes,\n+    \/\/ so that we reach all nodes that are connected to Root.\n+    root()->dump_bfs(MaxNodeLimit, nullptr, \"-+S$\", &ss);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,6 @@\n+    \/\/ Note: we used to check for ConD nodes in the IR. But that is a bit brittle:\n+    \/\/ Constant nodes can appear during IR transformations, and then lose their outputs.\n+    \/\/ During IGNV, the constants stay in the graph even if they lose the inputs. But\n+    \/\/ CCP cleans them out because they are not in the useful set. So for now, we do not\n+    \/\/ rely on any constant counting, just on counting the operation nodes.\n+\n@@ -66,2 +72,4 @@\n-    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_D, \"1\"})\n+    @IR(counts = {IRNode.MOD_D, \"2\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -74,2 +82,6 @@\n-    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_D, \"1\"})\n+    @IR(counts = {IRNode.MOD_D, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"1\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1) \/\/ Only constant fold after some loop opts\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -88,2 +100,6 @@\n-    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_D, \"1\"})\n+    @IR(counts = {IRNode.MOD_D, \"2\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"2\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1) \/\/ Only constant fold after some loop opts\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -102,2 +118,6 @@\n-    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_D, \"1\"})\n+    @IR(counts = {IRNode.MOD_D, \"2\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"2\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1) \/\/ Only constant fold after some loop opts\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -116,2 +136,4 @@\n-    @IR(counts = {\"drem\", \"1\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_D, \"1\"})\n+    @IR(counts = {IRNode.MOD_D, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"1\"},\n+        phase = CompilePhase.BEFORE_MATCHING) \/\/ no constant folding\n@@ -123,2 +145,4 @@\n-    @IR(counts = {\"drem\", \"2\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_D, \"1\"})\n+    @IR(counts = {IRNode.MOD_D, \"2\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"2\"},\n+        phase = CompilePhase.BEFORE_MATCHING) \/\/ no constant folding\n@@ -130,2 +154,6 @@\n-    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.ITER_GVN1)\n-    @IR(counts = {IRNode.MOD_D, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"0\"},\n+        phase = CompilePhase.ITER_GVN1) \/\/ IGVN removes unused nodes\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -137,2 +165,6 @@\n-    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.ITER_GVN1)\n-    @IR(counts = {IRNode.MOD_D, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"0\"},\n+        phase = CompilePhase.ITER_GVN1) \/\/ IGVN removes unused nodes\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -151,2 +183,8 @@\n-    @IR(counts = {IRNode.MOD_D, \"1\"}, phase = CompilePhase.ITER_GVN2)\n-    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+    @IR(counts = {IRNode.MOD_D, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"1\"},\n+        phase = CompilePhase.ITER_GVN2)\n+    @IR(counts = {IRNode.MOD_D, \"0\"},\n+        phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -170,2 +208,8 @@\n-    @IR(counts = {IRNode.MOD_D, \"1\"}, phase = CompilePhase.AFTER_CLOOPS)\n-    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.PHASEIDEALLOOP1)\n+    @IR(counts = {IRNode.MOD_D, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"1\"},\n+        phase = CompilePhase.AFTER_CLOOPS)\n+    @IR(counts = {IRNode.MOD_D, \"0\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1)\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -189,2 +233,8 @@\n-    @IR(counts = {IRNode.MOD_D, \"2\"}, phase = CompilePhase.AFTER_CLOOPS)\n-    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.PHASEIDEALLOOP1)\n+    @IR(counts = {IRNode.MOD_D, \"3\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_D, \"2\"},\n+        phase = CompilePhase.AFTER_CLOOPS) \/\/ drop the useless one\n+    @IR(counts = {IRNode.MOD_D, \"0\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1) \/\/ drop the rest\n+    @IR(counts = {\".*CallLeaf.*drem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModDNodeTests.java","additions":72,"deletions":22,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -65,0 +65,6 @@\n+    \/\/ Note: we used to check for ConF nodes in the IR. But that is a bit brittle:\n+    \/\/ Constant nodes can appear during IR transformations, and then lose their outputs.\n+    \/\/ During IGNV, the constants stay in the graph even if they lose the inputs. But\n+    \/\/ CCP cleans them out because they are not in the useful set. So for now, we do not\n+    \/\/ rely on any constant counting, just on counting the operation nodes.\n+\n@@ -66,2 +72,4 @@\n-    @IR(failOn = {\"frem\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_F, \"1\"})\n+    @IR(counts = {IRNode.MOD_F, \"2\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -74,2 +82,6 @@\n-    @IR(failOn = {\"frem\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_F, \"1\"})\n+    @IR(counts = {IRNode.MOD_F, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"1\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1) \/\/ Only constant fold after some loop opts\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -88,2 +100,6 @@\n-    @IR(failOn = {\"frem\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_F, \"1\"})\n+    @IR(counts = {IRNode.MOD_F, \"2\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"2\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1) \/\/ Only constant fold after some loop opts\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -102,2 +118,6 @@\n-    @IR(failOn = {\"frem\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_F, \"1\"})\n+    @IR(counts = {IRNode.MOD_F, \"2\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"2\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1) \/\/ Only constant fold after some loop opts\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -116,2 +136,4 @@\n-    @IR(counts = {\"frem\", \"1\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_F, \"1\"})\n+    @IR(counts = {IRNode.MOD_F, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"1\"},\n+        phase = CompilePhase.BEFORE_MATCHING) \/\/ no constant folding\n@@ -123,2 +145,4 @@\n-    @IR(counts = {\"frem\", \"2\"}, phase = CompilePhase.BEFORE_MATCHING)\n-    @IR(counts = {IRNode.CON_F, \"1\"})\n+    @IR(counts = {IRNode.MOD_F, \"2\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"2\"},\n+        phase = CompilePhase.BEFORE_MATCHING) \/\/ no constant folding\n@@ -130,2 +154,6 @@\n-    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.ITER_GVN1)\n-    @IR(counts = {IRNode.MOD_F, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"0\"},\n+        phase = CompilePhase.ITER_GVN1) \/\/ IGVN removes unused nodes\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -137,2 +165,6 @@\n-    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.ITER_GVN1)\n-    @IR(counts = {IRNode.MOD_F, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"0\"},\n+        phase = CompilePhase.ITER_GVN1) \/\/ IGVN removes unused nodes\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -151,2 +183,8 @@\n-    @IR(counts = {IRNode.MOD_F, \"1\"}, phase = CompilePhase.ITER_GVN2)\n-    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+    @IR(counts = {IRNode.MOD_F, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"1\"},\n+        phase = CompilePhase.ITER_GVN2)\n+    @IR(counts = {IRNode.MOD_F, \"0\"},\n+        phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -170,2 +208,8 @@\n-    @IR(counts = {IRNode.MOD_F, \"1\"}, phase = CompilePhase.AFTER_CLOOPS)\n-    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.PHASEIDEALLOOP1)\n+    @IR(counts = {IRNode.MOD_F, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"1\"},\n+        phase = CompilePhase.AFTER_CLOOPS)\n+    @IR(counts = {IRNode.MOD_F, \"0\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1)\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n@@ -189,2 +233,8 @@\n-    @IR(counts = {IRNode.MOD_F, \"2\"}, phase = CompilePhase.AFTER_CLOOPS)\n-    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.PHASEIDEALLOOP1)\n+    @IR(counts = {IRNode.MOD_F, \"3\"},\n+        phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.MOD_F, \"2\"},\n+        phase = CompilePhase.AFTER_CLOOPS) \/\/ drop the useless one\n+    @IR(counts = {IRNode.MOD_F, \"0\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1) \/\/ drop the rest\n+    @IR(counts = {\".*CallLeaf.*frem.*\", \"0\"},\n+        phase = CompilePhase.BEFORE_MATCHING)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModFNodeTests.java","additions":72,"deletions":22,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -693,10 +693,0 @@\n-    public static final String CON_D = PREFIX + \"CON_D\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(CON_D, \"ConD\");\n-    }\n-\n-    public static final String CON_F = PREFIX + \"CON_F\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(CON_F, \"ConF\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8373355\n+ * @summary Test that IR matching happens on the whole graph, not just nodes\n+ *          that can be found by traversing up from the Root.\n+ * @library \/test\/lib \/\n+ * @run main ${test.main.class}\n+ *\/\n+\n+public class TestIRFindFromAbove {\n+    public static boolean flag = false;\n+    public static int fld = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    \/\/ Simulate Xcomp with no warmup: ensure the flag branch is not an unstable if\n+    \/\/ but that we compile the infinite loop.\n+    @IR(counts = {IRNode.LOAD_I, \"1\", IRNode.STORE_I, \"1\", \".*NeverBranch.*\", \"0\"},\n+        phase = CompilePhase.ITER_GVN1)\n+    @IR(counts = {IRNode.LOAD_I, \"1\", IRNode.STORE_I, \"1\", \".*NeverBranch.*\", \"1\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1)\n+    public static void test() {\n+        if (flag) {\n+            \/\/ This loop has no exit. So it is at first not connected down to Root.\n+            while (true) {\n+                \/\/ During PHASEIDEALLOOP1, we insert a NeverBranch here, with a fake\n+                \/\/ exit, that connects the loop down to Root.\n+                fld++; \/\/ LoadI and StoreI\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRFindFromAbove.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"}]}