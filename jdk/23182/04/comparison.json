{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -861,0 +861,11 @@\n+static jint\n+getThreadState(jthread thread)\n+{\n+    jint state = 0;\n+    jvmtiError error = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadState)\n+        (gdata->jvmti, thread, &state);\n+    if (error != JVMTI_ERROR_NONE) {\n+        EXIT_ERROR(error, \"getting thread state\");\n+    }\n+    return state;\n+}\n@@ -880,2 +891,0 @@\n-        step->pending = JNI_FALSE;\n-\n@@ -888,0 +897,45 @@\n+        jvmtiError error;\n+        jboolean needsSuspending; \/\/ true if we needed to suspend this thread\n+\n+        \/\/ The thread needs suspending if it is not the current thread and is\n+        \/\/ not already suspended.\n+        if (isSameObject(getEnv(), threadControl_currentThread(), thread)) {\n+            needsSuspending = JNI_FALSE;\n+        } else {\n+            jint state = getThreadState(thread);\n+            needsSuspending = ((state & JVMTI_THREAD_STATE_SUSPENDED) == 0);\n+        }\n+\n+        if (needsSuspending) {\n+            \/\/ Don't use threadControl_suspendThread() here. It does a lot of\n+            \/\/ locking, increasing the risk of deadlock issues. None of that\n+            \/\/ locking is needed here.\n+            error = JVMTI_FUNC_PTR(gdata->jvmti,SuspendThread)\n+                (gdata->jvmti, thread);\n+            if (error != JVMTI_ERROR_NONE) {\n+                EXIT_ERROR(error, \"suspending thread\");\n+            }\n+        }\n+\n+        error = JVMTI_FUNC_PTR(gdata->jvmti,ClearAllFramePops)\n+            (gdata->jvmti, thread);\n+        if (error != JVMTI_ERROR_NONE) {\n+#ifdef DEBUG\n+            jint currentDepth = getFrameCount(thread);\n+            jint state = getThreadState(thread);\n+            tty_message(\"JVMTI ERROR(%d): ClearAllFramePops (state=0x%x fromDepth=%d currentDepth=%d)\",\n+                        error, state, step->fromStackDepth, currentDepth);\n+            printThreadInfo(thread);\n+            printStackTrace(thread);\n+            threadControl_dumpThread(thread);\n+#endif\n+            EXIT_ERROR(error, \"clearing all frame pops\");\n+        }\n+\n+        if (needsSuspending) {\n+            error = JVMTI_FUNC_PTR(gdata->jvmti,ResumeThread)\n+                (gdata->jvmti, thread);\n+            if (error != JVMTI_ERROR_NONE) {\n+                EXIT_ERROR(error, \"resuming thread\");\n+            }\n+        }\n@@ -889,0 +943,2 @@\n+\n+    step->pending = JNI_FALSE;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/stepControl.c","additions":59,"deletions":3,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/  THIS TEST IS LINE NUMBER SENSITIVE\n+\n+\/**\n+ * @test\n+ * @bug 8229012\n+ * @summary Verify that during single stepping a method is not compiled and\n+ *          after single stepping it is compiled.\n+ * @requires vm.compMode == \"Xmixed\"\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g SingleStepCompilationTest.java\n+ * @run driver SingleStepCompilationTest\n+ *\/\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+import java.lang.reflect.Method;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+class TestTarg {\n+    public final static int BKPT_LINE = 66;\n+\n+    public static void main(String[] args) {\n+        \/\/ Call buswork() and verify that is get compiled.\n+        busyWork(\"Warmup\");\n+        if (!isCompiled()) {\n+            throw new RuntimeException(\"busywork() did not get compiled after warmup\");\n+        }\n+\n+        \/\/ We need to force deopt the method now. Although we are about to force interp_only\n+        \/\/ mode by enabling single stepping, this does not result in the method being\n+        \/\/ deopt right away. It just causes the compiled method not to be used.\n+        deoptimizeMethod();\n+\n+        \/\/ Call busywork() again. This time the debugger will have single stepping\n+        \/\/ enabled. After calling, verify that busywork() is not compiled.\n+        busyWork(\"StepOver\"); \/\/ BKPT_LINE: We do a STEP_OVER here\n+        if (isCompiled()) {\n+            throw new RuntimeException(\"busywork() compiled during single stepping\");\n+        }\n+\n+        \/\/ Call busywork a 3rd time. This time the debugger will not have single stepping\n+        \/\/ enabled. After calling, verify that busywork is compiled.\n+        busyWork(\"AfterStep\");\n+        if (!isCompiled()) {\n+            throw new RuntimeException(\"busywork() not compiled after single stepping completes\");\n+        }\n+    }\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static Method busyWorkMethod;\n+    static {\n+        try {\n+            busyWorkMethod = TestTarg.class.getDeclaredMethod(\"busyWork\", String.class);\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static boolean isCompiled() {\n+        return WB.isMethodCompiled(busyWorkMethod, true) || WB.isMethodCompiled(busyWorkMethod, false);\n+    }\n+\n+    private static void deoptimizeMethod() {\n+        System.out.println(\"Decompile count before: \" + WB.getMethodDecompileCount(busyWorkMethod));\n+        WB.deoptimizeMethod(busyWorkMethod, true);\n+        WB.deoptimizeMethod(busyWorkMethod, false);\n+        System.out.println(\"Decompile count after: \" + WB.getMethodDecompileCount(busyWorkMethod));\n+    }\n+\n+    \/\/ We put the array and the result variables in static volatiles just to make sure\n+    \/\/ the compiler doesn't optimize them away.\n+    public static final int ARRAY_SIZE = 1000*1024;\n+    public static volatile int[] a = new int[ARRAY_SIZE];\n+    public static volatile long result = 0;\n+\n+    \/\/ Do something compute intensive to trigger compilation.\n+    public static void busyWork(String phase) {\n+        \/\/ Although timing is not necessary for this test, it is useful to have in the\n+        \/\/ log output for troubleshooting. The timing when step over is enabled should\n+        \/\/ be sigficantly slower than when not.\n+        long start = System.currentTimeMillis();\n+\n+        \/\/ Burn some CPU time and trigger OSR compilation.\n+        for (int j = 0; j < 500; j++) {\n+            for (int i = 0; i < ARRAY_SIZE; i++) {\n+                a[i] = j*i + i << 5 + j;\n+            }\n+        }\n+        for (int i = 0; i < ARRAY_SIZE; i++) {\n+            result += a[i];\n+        }\n+\n+        long end = System.currentTimeMillis();\n+        long totalTime = end - start;\n+        System.out.println(phase + \" time: \" + totalTime);\n+    }\n+}\n+\n+\/********** test program **********\/\n+\n+public class SingleStepCompilationTest extends TestScaffold {\n+    ClassType targetClass;\n+    ThreadReference mainThread;\n+\n+    SingleStepCompilationTest (String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/*\n+         * We need to pass some extra args to the debuggee for WhiteBox support and\n+         * for more consistent compilation behavior.\n+         *\/\n+        String[] newArgs = new String[5];\n+        if (args.length != 0) {\n+            throw new RuntimeException(\"Unexpected arguments passed to test\");\n+        }\n+\n+        \/\/ These are all needed for WhiteBoxAPI\n+        newArgs[0] = \"-Xbootclasspath\/a:.\";\n+        newArgs[1] = \"-XX:+UnlockDiagnosticVMOptions\";\n+        newArgs[2] = \"-XX:+WhiteBoxAPI\";\n+\n+        \/\/ In order to make sure the compilation is complete before we exit busyWork(),\n+        \/\/ we don't allow background compilations.\n+        newArgs[3] = \"-XX:-BackgroundCompilation\";\n+\n+        \/\/ Disabled tiered compilations so a new compilation doesn't start in the middle\n+        \/\/ of executing busyWork(). (Might not really be needed)\n+        newArgs[4] = \"-XX:-TieredCompilation\";\n+\n+        new SingleStepCompilationTest(newArgs).startTests();\n+    }\n+\n+    \/********** event handlers **********\/\n+\n+    EventRequestManager erm;\n+    BreakpointRequest bkptRequest;\n+    StepRequest stepRequest;\n+\n+    \/\/ When we get a bkpt we want to disable the request and enable single stepping.\n+    public void breakpointReached(BreakpointEvent event) {\n+        System.out.println(\"Got BreakpointEvent: \" + event);\n+        EventRequest req = event.request();\n+        req.disable();\n+        stepRequest = erm.createStepRequest(mainThread,\n+                                            StepRequest.STEP_LINE,\n+                                            StepRequest.STEP_OVER);\n+        stepRequest.enable();\n+    }\n+\n+    public void stepCompleted(StepEvent event) {\n+        System.out.println(\"Got StepEvent: \" + event);\n+        EventRequest req = event.request();\n+        req.disable();\n+    }\n+\n+    public void eventSetComplete(EventSet set) {\n+        set.resume();\n+    }\n+\n+    public void vmDisconnected(VMDisconnectEvent event) {\n+        System.out.println(\"Got VMDisconnectEvent\");\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        \/*\n+         * Get to the top of main() to determine targetClass and mainThread.\n+         *\/\n+        BreakpointEvent bpe = startToMain(\"TestTarg\");\n+        targetClass = (ClassType)bpe.location().declaringType();\n+        mainThread = bpe.thread();\n+        erm = vm().eventRequestManager();\n+\n+        \/\/ The BKPT_LINE is the line we will STEP_OVER.\n+        Location loc1 = findLocation(targetClass, TestTarg.BKPT_LINE);\n+        bkptRequest = erm.createBreakpointRequest(loc1);\n+        bkptRequest.enable();\n+\n+        try {\n+            addListener(this);\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            failure(\"failure: Could not add listener\");\n+            throw new RuntimeException(\"SingleStepCompilationTest: failed\", ex);\n+        }\n+\n+        vm().resume();\n+        waitForVMDisconnect();\n+\n+        System.out.println(\"done with loop\");\n+        removeListener(this);\n+\n+        \/*\n+         * Deal with results of test. If anything has called failure(\"foo\")\n+         * then testFailed will be true.\n+         *\/\n+        if (!testFailed) {\n+            System.out.println(\"SingleStepCompilationTest: passed\");\n+        } else {\n+            throw new Exception(\"SingleStepCompilationTest: failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/SingleStepCompilationTest.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"}]}