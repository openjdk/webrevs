{"files":[{"patch":"@@ -109,2 +109,2 @@\n-        \/\/ The class file generated he is in the lib\/ directory, which we delete\n-        \/\/ after making the JAR (just to be sure).\n+        \/\/ The class file is generated in the lib\/ directory, which we delete after\n+        \/\/ making the JAR (just to be sure).\n","filename":"test\/langtools\/tools\/javac\/NoOverwriteJarClassFilesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338675\n+ * @summary javac shouldn't silently change .jar files on the classpath\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @run junit AnnotationFilerTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import toolbox.JarTask;\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.Filer;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.FileObject;\n+import javax.tools.JavaFileObject;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.Set;\n+\n+import static javax.tools.StandardLocation.CLASS_OUTPUT;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class AnnotationFilerTest {\n+    private static final String LIB_SOURCE =\n+            \"\"\"\n+            package lib;\n+            public class LibClass {\n+                public static final String FIELD = \"\";\n+            }\n+            \"\"\";\n+\n+    \/\/ Target source references the field to force library compilation.\n+    private static final String TARGET_SOURCE =\n+            \"\"\"\n+            class TargetClass {\n+                static final String VALUE = lib.LibClass.FIELD;\n+            }\n+            \"\"\";\n+\n+    private static final String LIB_CLASS_TYPE_NAME = \"lib.LibClass\";\n+    private static final Path LIB_JAR = Path.of(\"lib.jar\");\n+\n+    private static final String LIB_SOURCE_FILE_NAME = \"lib\/LibClass.java\";\n+    private static final String LIB_CLASS_FILE_NAME = \"lib\/LibClass.class\";\n+\n+    \/\/ These differ only in the filename suffix part and represent the trailing\n+    \/\/ parts of a Path URI for source\/class files in the JAR. The source file\n+    \/\/ will exist, but the class file must not be created by annotation processing.\n+    private static final String JAR_SOURCE_URI_SUFFIX = \"lib.jar!\/\" + LIB_SOURCE_FILE_NAME;\n+    private static final String JAR_CLASS_URI_SUFFIX = \"lib.jar!\/\" + LIB_CLASS_FILE_NAME;\n+\n+    @Test\n+    public void classpathJarsCannotBeWrittenDuringProcessing() throws IOException {\n+        ToolBox tb = new ToolBox();\n+        tb.createDirectories(\"lib\");\n+        tb.writeFile(LIB_SOURCE_FILE_NAME, LIB_SOURCE);\n+        new JarTask(tb, LIB_JAR).files(LIB_SOURCE_FILE_NAME).run();\n+\n+        \/\/ These are assertions about the test environment, not the code-under-test.\n+        try (FileSystem zipFs = FileSystems.newFileSystem(LIB_JAR)) {\n+            \/\/ The bug would have only manifested with writable JAR files, so assert that here.\n+            assertFalse(zipFs.isReadOnly());\n+            \/\/ This is the JAR file URI for the *source* code. Later we attempt to create the\n+            \/\/ sibling *class* file from within the annotation processor (which MUST FAIL).\n+            \/\/ We get the source URI here to verify the naming convention of the JAR file\n+            \/\/ URIs to prevent the _negative_ test we do later being fragile.\n+            URI libUri = zipFs.getPath(LIB_SOURCE_FILE_NAME).toUri();\n+            assertEquals(\"jar\", libUri.getScheme());\n+            assertTrue(libUri.getSchemeSpecificPart().endsWith(JAR_SOURCE_URI_SUFFIX));\n+        }\n+\n+        \/\/ Code under test:\n+        \/\/ Compile the target class with library source only available in the JAR. This should\n+        \/\/ succeed, but MUST NOT be able to create files in the JAR during annotation processing.\n+        new JavacTask(tb)\n+                .processors(new TestAnnotationProcessor())\n+                .options(\"-implicit:none\", \"-g:source,lines,vars\")\n+                .sources(TARGET_SOURCE)\n+                .classpath(LIB_JAR)\n+                .run()\n+                .writeAll();\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    static class TestAnnotationProcessor extends AbstractProcessor {\n+        private ProcessingEnvironment processingEnv = null;\n+\n+        @Override\n+        public void init(ProcessingEnvironment processingEnv) {\n+            this.processingEnv = processingEnv;\n+        }\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n+            \/\/ Only run this once (during the final pass), or else we get a spurious failure\n+            \/\/ about trying to recreate the class file (not allowed during annotation\n+            \/\/ processing, but not what we are testing here).\n+            if (!env.processingOver()) {\n+                return false;\n+            }\n+\n+            TypeElement libType = processingEnv.getElementUtils().getTypeElement(LIB_CLASS_TYPE_NAME);\n+            JavaFileObject libClass;\n+            \/\/ This is the primary code-under-test. The Filer must not return a file object\n+            \/\/ that's a sibling to the source file of the given type (that's in the JAR,\n+            \/\/ which MUST NOT be modified). Before bug 8338675 was fixed, this would fail.\n+            Filer filer = processingEnv.getFiler();\n+            try {\n+                libClass = filer.createClassFile(\"LibClass\", libType);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            \/\/ Double check that this is the expected file kind.\n+            assertEquals(JavaFileObject.Kind.CLASS, libClass.getKind());\n+\n+            \/\/ Primary assertions: Check the file object's URI is not from the JAR file.\n+            URI libUri = libClass.toUri();\n+            \/\/ If this were from the JAR file, the URI scheme would be \"jar\" (as tested\n+            \/\/ for earlier during setup).\n+            assertEquals(\"file\", libUri.getScheme());\n+\n+            \/\/ Check that the URI is for the right class, but not in the JAR.\n+            assertTrue(libUri.getSchemeSpecificPart().endsWith(\"\/LibClass.class\"));\n+            \/\/ Testing a negative is fragile, but the earlier checks show this would be\n+            \/\/ the expected path if the URI was referencing an entry in the JAR.\n+            assertFalse(libUri.getSchemeSpecificPart().endsWith(JAR_CLASS_URI_SUFFIX));\n+\n+            \/\/ Additional regression testing for other file objects the Filer can create\n+            \/\/ (all specified as originating from the LibClass type in the JAR). These\n+            \/\/ should all create file objects, just not in the JAR.\n+            try {\n+                assertNonJar(\n+                        filer.createClassFile(\"FooClass\", libType),\n+                        \"\/FooClass.class\");\n+                assertNonJar(\n+                        filer.createSourceFile(\"BarClass\", libType),\n+                        \"\/BarClass.java\");\n+                assertNonJar(\n+                        filer.createResource(CLASS_OUTPUT, \"lib\", \"data.txt\", libType),\n+                        \"\/data.txt\");\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static void assertNonJar(FileObject file, String uriSuffix) {\n+        URI uri = file.toUri();\n+        assertEquals(\"file\", uri.getScheme());\n+        assertTrue(uri.getSchemeSpecificPart().endsWith(uriSuffix));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationFilerTest.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"}]}