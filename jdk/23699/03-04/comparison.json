{"files":[{"patch":"@@ -921,1 +921,1 @@\n-                \/\/ archives). See JDK-8338675.\n+                \/\/ archives).\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,200 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8338675\n- * @summary javac shouldn't silently change .jar files on the classpath\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n- * @run junit NoOverwriteJarClassFilesTest\n- *\/\n-\n-import toolbox.JavacTask;\n-import toolbox.ToolBox;\n-\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.attribute.FileTime;\n-import java.time.Instant;\n-import java.time.ZoneId;\n-import java.util.jar.JarOutputStream;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-\/**\n- * This test makes two specific assertions about javac behaviour when source\n- * files are found in the classpath.\n- *\n- * <ol>\n- *     <li>Source files found in classpath JAR files are not overwritten.\n- *     <li>Class files generated during compilation which are associated with any\n- *    sources found in JAR files are written (flat) to the current directory.\n- * <\/ol>\n- *\n- * <p>Note that this behaviour is not obviously well-defined, and should not\n- * be relied upon, but it matches previous JDK behaviour and so is tested here.\n- *\n- * <p>Specifically, the behaviour in (2) means library classes with the same base\n- * class name may be overwritten, and the resulting set of class files in the\n- * current directory may not be usable.\n- *\/\n-public class NoOverwriteJarClassFilesTest {\n-\n-    private static final String OLD_LIB_SOURCE =\n-            \"\"\"\n-            package lib;\n-            public class LibClass {\n-                public static final String OLD_FIELD = \"This will not compile with Target\";\n-            }\n-            \"\"\";\n-\n-    private static final String NEW_LIB_SOURCE =\n-            \"\"\"\n-            package lib;\n-            public class LibClass {\n-                public static final String NEW_FIELD = \"Only this will compile with Target\";\n-            }\n-            \"\"\";\n-\n-    \/\/ Target source references the field only available in the new source.\n-    private static final String TARGET_SOURCE =\n-            \"\"\"\n-            class TargetClass {\n-                static final String VALUE = lib.LibClass.NEW_FIELD;\n-            }\n-            \"\"\";\n-\n-    private static final String LIB_SOURCE_NAME = \"lib\/LibClass.java\";\n-    private static final String LIB_CLASS_NAME = \"lib\/LibClass.class\";\n-    private static final Path LIB_JAR = Path.of(\"lib.jar\");\n-\n-    @Test\n-    public void jarFileNotModified() throws IOException {\n-        ToolBox tb = new ToolBox();\n-        tb.createDirectories(\"lib\");\n-        tb.writeFile(LIB_SOURCE_NAME, OLD_LIB_SOURCE);\n-\n-        \/\/ Compile the old (broken) source and then store the class file in the JAR.\n-        \/\/ The class file is generated in the lib\/ directory, which we delete after\n-        \/\/ making the JAR (just to be sure).\n-        new JavacTask(tb)\n-                .files(LIB_SOURCE_NAME)\n-                .run()\n-                .writeAll();\n-\n-        \/\/ The new (fixed) source is never written to disk, so if compilation works\n-        \/\/ it proves it's getting it from the source file in the JAR.\n-        Instant olderTime = Instant.now();\n-        Instant newerTime = olderTime.plusSeconds(1);\n-        try (OutputStream jos = Files.newOutputStream(Path.of(\"lib.jar\"))) {\n-            JarOutputStream jar = new JarOutputStream(jos);\n-            \/\/ Important: The JAR file entry order *matters* if the timestamps are\n-            \/\/ the same (the latter entry is used for compilation, regardless of\n-            \/\/ whether it's a source file or a class file). So in this test, we\n-            \/\/ put the one we want to use *first* with a newer timestamp, to show\n-            \/\/ that it's definitely the timestamp being used to select the source.\n-            writeEntry(jar, LIB_SOURCE_NAME, NEW_LIB_SOURCE.getBytes(), newerTime);\n-            \/\/ Source is newer than the (broken) compiled class, so should compile\n-            \/\/ from the source file in the JAR. If timestamps were not set, or set\n-            \/\/ equal, the test would use this (broken) class file, and fail.\n-            writeEntry(jar, LIB_CLASS_NAME, Files.readAllBytes(Path.of(LIB_CLASS_NAME)), olderTime);\n-            jar.close();\n-        }\n-        \/\/ Check there's no output file present and delete the original library files.\n-        Path outputClassFile = Path.of(\"LibClass.class\");\n-        if (Files.exists(outputClassFile)) {\n-            throw new IllegalStateException(\"Output class file should not exist (yet).\");\n-        }\n-        Path libDir = Path.of(\"lib\");\n-        tb.cleanDirectory(libDir);\n-        tb.deleteFiles(libDir);\n-\n-        \/\/ Before running the test itself, get the CRC of the class file in the JAR.\n-        long originalLibCrc = getLibCrc();\n-        \/\/ And read the JAR file completely for comparison later.\n-        byte[] originalJarContents = Files.readAllBytes(LIB_JAR);\n-\n-        \/\/ Code under test:\n-        \/\/ Compile the target class with new library source only available in the JAR.\n-        \/\/\n-        \/\/ This compilation only succeeds if 'NEW_FIELD' exists, which is only in\n-        \/\/ the source file written to the JAR, and nowhere on disk.\n-        new JavacTask(tb)\n-                .sources(TARGET_SOURCE)\n-                .classpath(LIB_JAR)\n-                .run()\n-                .writeAll();\n-\n-        \/\/ Assertion 1: The class file in the JAR is unchanged.\n-        \/\/\n-        \/\/ Since compilation succeeded, we know it used NEW_LIB_SOURCE, and if it\n-        \/\/ wrote the class file back to the JAR (bad) then that should now have\n-        \/\/ different contents. Note that the modification time of the class file\n-        \/\/ is NOT modified, even if the JAR is updated, so we cannot test that.\n-        assertEquals(originalLibCrc, getLibCrc(), \"Class library contents were modified in the JAR file.\");\n-        assertArrayEquals(originalJarContents, Files.readAllBytes(LIB_JAR), \"Jar file was modified.\");\n-\n-        \/\/ Assertion 2: An output class file was written to the current directory.\n-        assertTrue(Files.exists(outputClassFile), \"Output class file was not written to current directory.\");\n-    }\n-\n-    \/\/ Note: JarOutputStream only writes modification time, not creation time, but\n-    \/\/ that's what Javac uses to determine \"newness\" so it's fine.\n-    private static void writeEntry(JarOutputStream jar, String name, byte[] bytes, Instant timestamp) throws IOException {\n-        ZipEntry e = new ZipEntry(name);\n-        e.setLastModifiedTime(FileTime.from(timestamp));\n-        jar.putNextEntry(e);\n-        jar.write(bytes);\n-        jar.closeEntry();\n-    }\n-\n-    private static long getLibCrc() throws IOException {\n-        try (ZipFile zipFile = new ZipFile(\"lib.jar\")) {\n-            \/\/ zipFile.stream().map(NoOverwriteJarClassFilesByDefault::format).forEach(System.err::println);\n-            return zipFile.getEntry(LIB_CLASS_NAME).getCrc();\n-        }\n-    }\n-\n-    \/\/ ---- Debug helper methods ----\n-    private static String format(ZipEntry e) {\n-        return String.format(\"name: %s, size: %s, modified: %s\\n\",\n-                e.getName(),\n-                e.getSize(),\n-                toLocalTime(e.getLastModifiedTime()));\n-    }\n-\n-    private static String toLocalTime(FileTime t) {\n-        return t != null ? t.toInstant().atZone(ZoneId.systemDefault()).toString() : \"<null>\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/NoOverwriteJarClassFilesTest.java","additions":0,"deletions":200,"binary":false,"changes":200,"status":"deleted"},{"patch":"@@ -1,191 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8338675\n- * @summary javac shouldn't silently change .jar files on the classpath\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n- * @run junit AnnotationFilerTest\n- *\/\n-\n-import org.junit.jupiter.api.Test;\n-import toolbox.JarTask;\n-import toolbox.JavacTask;\n-import toolbox.ToolBox;\n-\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Filer;\n-import javax.annotation.processing.ProcessingEnvironment;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.annotation.processing.SupportedAnnotationTypes;\n-import javax.lang.model.element.TypeElement;\n-import javax.tools.FileObject;\n-import javax.tools.JavaFileObject;\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.util.Set;\n-\n-import static javax.tools.StandardLocation.CLASS_OUTPUT;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class AnnotationFilerTest {\n-    private static final String LIB_SOURCE =\n-            \"\"\"\n-            package lib;\n-            public class LibClass {\n-                public static final String FIELD = \"\";\n-            }\n-            \"\"\";\n-\n-    \/\/ Target source references the field to force library compilation.\n-    private static final String TARGET_SOURCE =\n-            \"\"\"\n-            class TargetClass {\n-                static final String VALUE = lib.LibClass.FIELD;\n-            }\n-            \"\"\";\n-\n-    private static final String LIB_CLASS_TYPE_NAME = \"lib.LibClass\";\n-    private static final Path LIB_JAR = Path.of(\"lib.jar\");\n-\n-    private static final String LIB_SOURCE_FILE_NAME = \"lib\/LibClass.java\";\n-    private static final String LIB_CLASS_FILE_NAME = \"lib\/LibClass.class\";\n-\n-    \/\/ These differ only in the filename suffix part and represent the trailing\n-    \/\/ parts of a Path URI for source\/class files in the JAR. The source file\n-    \/\/ will exist, but the class file must not be created by annotation processing.\n-    private static final String JAR_SOURCE_URI_SUFFIX = \"lib.jar!\/\" + LIB_SOURCE_FILE_NAME;\n-    private static final String JAR_CLASS_URI_SUFFIX = \"lib.jar!\/\" + LIB_CLASS_FILE_NAME;\n-\n-    @Test\n-    public void classpathJarsCannotBeWrittenDuringProcessing() throws IOException {\n-        ToolBox tb = new ToolBox();\n-        tb.createDirectories(\"lib\");\n-        tb.writeFile(LIB_SOURCE_FILE_NAME, LIB_SOURCE);\n-        new JarTask(tb, LIB_JAR).files(LIB_SOURCE_FILE_NAME).run();\n-\n-        \/\/ These are assertions about the test environment, not the code-under-test.\n-        try (FileSystem zipFs = FileSystems.newFileSystem(LIB_JAR)) {\n-            \/\/ The bug would have only manifested with writable JAR files, so assert that here.\n-            assertFalse(zipFs.isReadOnly());\n-            \/\/ This is the JAR file URI for the *source* code. Later we attempt to create the\n-            \/\/ sibling *class* file from within the annotation processor (which MUST FAIL).\n-            \/\/ We get the source URI here to verify the naming convention of the JAR file\n-            \/\/ URIs to prevent the _negative_ test we do later being fragile.\n-            URI libUri = zipFs.getPath(LIB_SOURCE_FILE_NAME).toUri();\n-            assertEquals(\"jar\", libUri.getScheme());\n-            assertTrue(libUri.getSchemeSpecificPart().endsWith(JAR_SOURCE_URI_SUFFIX));\n-        }\n-\n-        \/\/ Code under test:\n-        \/\/ Compile the target class with library source only available in the JAR. This should\n-        \/\/ succeed, but MUST NOT be able to create files in the JAR during annotation processing.\n-        new JavacTask(tb)\n-                .processors(new TestAnnotationProcessor())\n-                .options(\"-implicit:none\", \"-g:source,lines,vars\")\n-                .sources(TARGET_SOURCE)\n-                .classpath(LIB_JAR)\n-                .run()\n-                .writeAll();\n-    }\n-\n-    @SupportedAnnotationTypes(\"*\")\n-    static class TestAnnotationProcessor extends AbstractProcessor {\n-        private ProcessingEnvironment processingEnv = null;\n-\n-        @Override\n-        public void init(ProcessingEnvironment processingEnv) {\n-            this.processingEnv = processingEnv;\n-        }\n-\n-        @Override\n-        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n-            \/\/ Only run this once (during the final pass), or else we get a spurious failure\n-            \/\/ about trying to recreate the class file (not allowed during annotation\n-            \/\/ processing, but not what we are testing here).\n-            if (!env.processingOver()) {\n-                return false;\n-            }\n-\n-            TypeElement libType = processingEnv.getElementUtils().getTypeElement(LIB_CLASS_TYPE_NAME);\n-            JavaFileObject libClass;\n-            \/\/ This is the primary code-under-test. The Filer must not return a file object\n-            \/\/ that's a sibling to the source file of the given type (that's in the JAR,\n-            \/\/ which MUST NOT be modified). Before bug 8338675 was fixed, this would fail.\n-            Filer filer = processingEnv.getFiler();\n-            try {\n-                libClass = filer.createClassFile(\"LibClass\", libType);\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-            \/\/ Double check that this is the expected file kind.\n-            assertEquals(JavaFileObject.Kind.CLASS, libClass.getKind());\n-\n-            \/\/ Primary assertions: Check the file object's URI is not from the JAR file.\n-            URI libUri = libClass.toUri();\n-            \/\/ If this were from the JAR file, the URI scheme would be \"jar\" (as tested\n-            \/\/ for earlier during setup).\n-            assertEquals(\"file\", libUri.getScheme());\n-\n-            \/\/ Check that the URI is for the right class, but not in the JAR.\n-            assertTrue(libUri.getSchemeSpecificPart().endsWith(\"\/LibClass.class\"));\n-            \/\/ Testing a negative is fragile, but the earlier checks show this would be\n-            \/\/ the expected path if the URI was referencing an entry in the JAR.\n-            assertFalse(libUri.getSchemeSpecificPart().endsWith(JAR_CLASS_URI_SUFFIX));\n-\n-            \/\/ Additional regression testing for other file objects the Filer can create\n-            \/\/ (all specified as originating from the LibClass type in the JAR). These\n-            \/\/ should all create file objects, just not in the JAR.\n-            try {\n-                assertNonJar(\n-                        filer.createClassFile(\"FooClass\", libType),\n-                        \"\/FooClass.class\");\n-                assertNonJar(\n-                        filer.createSourceFile(\"BarClass\", libType),\n-                        \"\/BarClass.java\");\n-                assertNonJar(\n-                        filer.createResource(CLASS_OUTPUT, \"lib\", \"data.txt\", libType),\n-                        \"\/data.txt\");\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-            return false;\n-        }\n-    }\n-\n-    static void assertNonJar(FileObject file, String uriSuffix) {\n-        URI uri = file.toUri();\n-        assertEquals(\"file\", uri.getScheme());\n-        assertTrue(uri.getSchemeSpecificPart().endsWith(uriSuffix));\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationFilerTest.java","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338675\n+ * @summary javac shouldn't silently change .jar files on the classpath\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @run junit TestNoOverwriteJarFiles\n+ *\/\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.parallel.Execution;\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.FileObject;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n+import java.util.Set;\n+import java.util.jar.JarOutputStream;\n+import java.util.zip.ZipEntry;\n+\n+import static javax.tools.StandardLocation.CLASS_OUTPUT;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.parallel.ExecutionMode.SAME_THREAD;\n+\n+\/**\n+ * Tests that javac cannot unexpectedly modify contents of JAR files on the\n+ * class path.\n+ * <p>\n+ * Consider the following javac behaviours:\n+ * <ol>\n+ * <li>If there is no source path, javac searches the classpath for sources,\n+ * including inside JAR files.\n+ * <li>If a Java source file was modified more recently that an existing class\n+ * file, or if no class file exists, javac will compile it from the source.\n+ * <li>If there is no output directory specified, javac will put compiled class\n+ * files next to their corresponding sources.\n+ * <\/ol>\n+ * Taken together, this suggests that a newly compiled class file should be\n+ * written back into the JAR in which its source was found, possibly overwriting\n+ * an existing class file entry. This would be very problematic.\n+ * <p>\n+ * This test ensures javac will not modify JAR files on the classpath, even if\n+ * it compiles sources contained within them. Instead, the class file will be\n+ * written into the current working directory, which mimics the JDK 8 behavior.\n+ *\n+ * <h2>Important<\/h2>\n+ *\n+ * This test creates files from Java compilation and annotation processing, and\n+ * relies on files being written to the current working directory. Since jtreg\n+ * currently offers no way to run each test case in its own directory, or clean\n+ * the test directory between test cases, we must be careful to:\n+ * <ul>\n+ *     <li>Use {@code @Execution(SAME_THREAD)} to run test cases sequentially.\n+ *     <li>Clean up the test directory ourselves between test cases (via\n+ *     {@code @BeforeEach}).\n+ * <\/ul>\n+ * The alternative approach would be to compile the test classes in a specified\n+ * working directory unique to each test case, but this is currently only\n+ * possible using a subprocess via {@code Task.Mode.EXEC} , and this has two\n+ * serious disadvantages:\n+ * <ul>\n+ *     <li>It significantly complicates compilation setup.\n+ *     <li>It prevents step-through debugging of the annotation processor.\n+ * <\/ul>\n+ *\/\n+@Execution(SAME_THREAD)\n+public class TestNoOverwriteJarFiles {\n+    private static final String LIB_SOURCE_FILE_NAME = \"lib\/LibClass.java\";\n+    private static final String LIB_CLASS_FILE_NAME = \"lib\/LibClass.class\";\n+    private static final String LIB_CLASS_TYPE_NAME = \"lib.LibClass\";\n+\n+    private static final Path TEST_LIB_JAR = Path.of(\"lib.jar\");\n+    private static final Path OUTPUT_CLASS_FILE = Path.of(\"LibClass.class\");\n+\n+    \/\/ Source which can only compile against the Java source in the test library.\n+    public static final String TARGET_SOURCE =\n+            \"\"\"\n+            class TargetClass {\n+                static final String VALUE = lib.LibClass.NEW_FIELD;\n+            }\n+            \"\"\";\n+\n+    \/\/ Not expensive to create, but conceptually a singleton.\n+    private static final ToolBox toolBox = new ToolBox();\n+\n+    @BeforeEach\n+    public void cleanUpTestDirectory() throws IOException {\n+        toolBox.cleanDirectory(Path.of(\".\"));\n+    }\n+\n+    @Test\n+    public void jarFileNotModifiedOrdinaryCompilation() throws IOException {\n+        byte[] originalJarBytes = compileTestLibJar();\n+\n+        new JavacTask(toolBox)\n+                .sources(TARGET_SOURCE)\n+                .classpath(TEST_LIB_JAR)\n+                .run()\n+                .writeAll();\n+\n+        \/\/ Assertion 1: The JAR is unchanged.\n+        assertArrayEquals(originalJarBytes, Files.readAllBytes(TEST_LIB_JAR), \"Jar file was modified.\");\n+        \/\/ Assertion 2: An output class file was written to the current directory.\n+        assertTrue(Files.exists(OUTPUT_CLASS_FILE), \"Output class file missing.\");\n+    }\n+\n+    @Test\n+    public void jarFileNotModifiedAnnotationProcessing() throws IOException {\n+        byte[] originalJarBytes = compileTestLibJar();\n+\n+        new JavacTask(toolBox)\n+                .sources(TARGET_SOURCE)\n+                .classpath(TEST_LIB_JAR)\n+                .processors(new TestAnnotationProcessor())\n+                \/\/ Use \"-implicit:none\" to avoid writing the library class file.\n+                .options(\"-implicit:none\", \"-g:source,lines,vars\")\n+                .run()\n+                .writeAll();\n+\n+        \/\/ Assertion 1: The JAR is unchanged.\n+        assertArrayEquals(originalJarBytes, Files.readAllBytes(TEST_LIB_JAR), \"Jar file was modified.\");\n+        \/\/ Assertion 2: All expected output files were written to the current directory.\n+        assertDummyFile(\"DummySource.java\");\n+        assertDummyFile(\"DummyClass.class\");\n+        assertDummyFile(\"DummyResource.txt\");\n+        \/\/ Assertion 3: The class file itself wasn't written (because we used \"-implicit:none\").\n+        assertFalse(Files.exists(OUTPUT_CLASS_FILE), \"Unexpected class file in working directory.\");\n+    }\n+\n+    static class TestAnnotationProcessor extends JavacTestingAbstractProcessor {\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n+            \/\/ Only run this once (in the final pass), or else we get spurious failures about\n+            \/\/ trying to recreate file objects (not allowed during annotation processing).\n+            if (!env.processingOver()) {\n+                return false;\n+            }\n+\n+            TypeElement libClass = elements.getTypeElement(LIB_CLASS_TYPE_NAME);\n+            try {\n+                \/\/ Note: A generated Java source file must be legal Java, but a generated class\n+                \/\/ file that's unreferenced will never be loaded, so can contain any bytes.\n+                writeFileObject(\n+                        filer.createSourceFile(\"DummySource\", libClass),\n+                        \"DummySource.java\",\n+                        \"class DummySource {}\");\n+                writeFileObject(\n+                        filer.createClassFile(\"DummyClass\", libClass),\n+                        \"DummyClass.class\",\n+                        \"<<DummyClass Bytes>>\");\n+                writeFileObject(\n+                        filer.createResource(CLASS_OUTPUT, \"\", \"DummyResource.txt\", libClass),\n+                        \"DummyResource.txt\",\n+                        \"Dummy Resource Bytes\");\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static void writeFileObject(FileObject file, String expectedName, String contents) throws IOException {\n+        URI fileUri = file.toUri();\n+        \/\/ Check that the file URI doesn't look like it is associated with a JAR.\n+        assertTrue(fileUri.getSchemeSpecificPart().endsWith(\"\/\" + expectedName));\n+        \/\/ The JAR file system would have a scheme of \"jar\", not \"file\".\n+        assertEquals(\"file\", fileUri.getScheme());\n+        \/\/ Testing a negative is fragile, but a JAR URI would be expected to contain \"jar!\".\n+        assertFalse(fileUri.getSchemeSpecificPart().contains(\"jar!\"));\n+        \/\/ Write dummy data (which should end up in the test working directory).\n+        try (OutputStream os = file.openOutputStream()) {\n+            os.write(contents.getBytes());\n+        }\n+    }\n+\n+    static void assertDummyFile(String filename) throws IOException {\n+        Path path = Path.of(filename);\n+        assertTrue(Files.exists(path), \"Output file missing: \" + filename);\n+        assertTrue(Files.readString(path).contains(\"Dummy\"), \"Unexpected file contents: \" + filename);\n+    }\n+\n+    \/\/ Compiles and writes the test library JAR (LIB_JAR) into the current directory.\n+    static byte[] compileTestLibJar() throws IOException {\n+        Path libDir = Path.of(\"lib\");\n+        toolBox.createDirectories(libDir);\n+        try {\n+            toolBox.writeFile(LIB_SOURCE_FILE_NAME,\n+                    \"\"\"\n+                    package lib;\n+                    public class LibClass {\n+                        public static final String OLD_FIELD = \"This will not compile with Target\";\n+                    }\n+                    \"\"\");\n+\n+            \/\/ Compile the old (broken) source and then store the class file in the JAR.\n+            \/\/ The class file is generated in the lib\/ directory, which we delete after\n+            \/\/ making the JAR. This ensures that when compiling the target class, it's\n+            \/\/ the source file being read from the JAR,\n+            new JavacTask(toolBox)\n+                    .files(LIB_SOURCE_FILE_NAME)\n+                    .run()\n+                    .writeAll();\n+\n+            \/\/ If timestamps are equal JAR file resolution of classes is ambiguous\n+            \/\/ (currently \"last one wins\"), so give the source we want to be used a\n+            \/\/ newer timestamp.\n+            Instant now = Instant.now();\n+            try (OutputStream jos = Files.newOutputStream(Path.of(\"lib.jar\"))) {\n+                JarOutputStream jar = new JarOutputStream(jos);\n+                writeEntry(jar,\n+                        LIB_SOURCE_FILE_NAME,\n+                        \"\"\"\n+                        package lib;\n+                        public class LibClass {\n+                            public static final String NEW_FIELD = \"This will compile with Target\";\n+                        }\n+                        \"\"\".getBytes(StandardCharsets.UTF_8),\n+                        now.plusSeconds(1));\n+                writeEntry(jar,\n+                        LIB_CLASS_FILE_NAME,\n+                        Files.readAllBytes(Path.of(LIB_CLASS_FILE_NAME)),\n+                        now);\n+                jar.close();\n+            }\n+            \/\/ Return the JAR file bytes for comparison later.\n+            return Files.readAllBytes(TEST_LIB_JAR);\n+        } finally {\n+            toolBox.cleanDirectory(libDir);\n+            toolBox.deleteFiles(libDir);\n+        }\n+    }\n+\n+    \/\/ Note: JarOutputStream only writes modification time, not creation time, but\n+    \/\/ that's what Javac uses to determine \"newness\" so it's fine.\n+    private static void writeEntry(JarOutputStream jar, String name, byte[] bytes, Instant timestamp) throws IOException {\n+        ZipEntry e = new ZipEntry(name);\n+        e.setLastModifiedTime(FileTime.from(timestamp));\n+        jar.putNextEntry(e);\n+        jar.write(bytes);\n+        jar.closeEntry();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/filer\/TestNoOverwriteJarFiles.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"}]}