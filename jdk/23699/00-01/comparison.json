{"files":[{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338675\n+ * @summary javac shouldn't silently change .jar files on the classpath\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @run main NoOverwriteJarClassFilesByDefault\n+ *\/\n+\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.jar.JarOutputStream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+\/**\n+ * This test makes two specific assertions about javac behaviour when source\n+ * files are found in the classpath.\n+ *\n+ * <ol>\n+ *     <li>Source files found in classpath JAR files are not overwritten.\n+ *     <li>Class files generated during compilation which are associated with any\n+ *    sources found in JAR files are written (flat) to the current directory.\n+ * <\/ol>\n+ *\n+ * <p>Note that this behaviour is not obviously well-defined, and should not\n+ * be relied upon, but it matches previous JDK behaviour and so is tested here.\n+ *\n+ * <p>Specifically, the behaviour in (2) means library classes with the same base\n+ * class name may be overwritten, and the resulting set of class files in the\n+ * current directory may not be usable.\n+ *\/\n+public class NoOverwriteJarClassFilesByDefault {\n+\n+    private static final String OLD_LIB_SOURCE =\n+            \"\"\"\n+            package lib;\n+            public class LibClass {\n+                public static final String OLD_FIELD = \"This will not compile with Target\";\n+            }\n+            \"\"\";\n+\n+    private static final String NEW_LIB_SOURCE =\n+            \"\"\"\n+            package lib;\n+            public class LibClass {\n+                public static final String NEW_FIELD = \"Only this will compile with Target\";\n+            }\n+            \"\"\";\n+\n+    \/\/ Target source references the field only available in the new source.\n+    private static final String TARGET_SOURCE =\n+            \"\"\"\n+            class TargetClass {\n+                static final String VALUE = lib.LibClass.NEW_FIELD;\n+            }\n+            \"\"\";\n+\n+    private static final String LIB_SOURCE_NAME = \"lib\/LibClass.java\";\n+    private static final String LIB_CLASS_NAME = \"lib\/LibClass.class\";\n+    private static final Path LIB_JAR = Path.of(\"lib.jar\");\n+\n+    public static void main(String[] args) throws IOException {\n+        ToolBox tb = new ToolBox();\n+        tb.createDirectories(\"lib\");\n+        tb.writeFile(LIB_SOURCE_NAME, OLD_LIB_SOURCE);\n+\n+        \/\/ Compile the old (broken) source and then store the class file in the JAR.\n+        \/\/ The class file generated he is in the lib\/ directory, which we delete\n+        \/\/ after making the JAR (just to be sure).\n+        new JavacTask(tb)\n+                .files(LIB_SOURCE_NAME)\n+                .run()\n+                .writeAll();\n+\n+        \/\/ The new (fixed) source is never written to disk, so if compilation works\n+        \/\/ it proves it's getting it from the source file in the JAR.\n+        Instant olderTime = Instant.now();\n+        Instant newerTime = olderTime.plusSeconds(1);\n+        try (OutputStream jos = Files.newOutputStream(Path.of(\"lib.jar\"))) {\n+            JarOutputStream jar = new JarOutputStream(jos);\n+            \/\/ Important: The JAR file entry order *matters* if the timestamps are\n+            \/\/ the same (the latter entry is used for compilation, regardless of\n+            \/\/ whether it's a source file or a class file). So in this test, we\n+            \/\/ put the one we want to use *first* with a newer timestamp, to show\n+            \/\/ that it's definitely the timestamp being used to select the source.\n+            writeEntry(jar, LIB_SOURCE_NAME, NEW_LIB_SOURCE.getBytes(), newerTime);\n+            \/\/ Source is newer than the (broken) compiled class, so should compile\n+            \/\/ from the source file in the JAR. If timestamps were not set, or set\n+            \/\/ equal, the test would use this (broken) class file, and fail.\n+            writeEntry(jar, LIB_CLASS_NAME, Files.readAllBytes(Path.of(LIB_CLASS_NAME)), olderTime);\n+            jar.close();\n+        }\n+        \/\/ Check there's no output file present and delete the original library files.\n+        Path outputClassFile = Path.of(\"LibClass.class\");\n+        if (Files.exists(outputClassFile)) {\n+            throw new IllegalStateException(\"Output class file should not exist (yet).\");\n+        }\n+        Path libDir = Path.of(\"lib\");\n+        tb.cleanDirectory(libDir);\n+        tb.deleteFiles(libDir);\n+\n+        \/\/ Before running the test itself, get the CRC of the class file in the JAR.\n+        long originalLibCrc = getLibCrc();\n+        \/\/ And read the JAR file completely for comparison later.\n+        byte[] originalJarContents = Files.readAllBytes(LIB_JAR);\n+\n+        \/\/ Code under test:\n+        \/\/ Compile the target class with new library source only available in the JAR.\n+        \/\/\n+        \/\/ This compilation only succeeds if 'NEW_FIELD' exists, which is only in\n+        \/\/ the source file written to the JAR, and nowhere on disk.\n+        new JavacTask(tb)\n+                .sources(TARGET_SOURCE)\n+                .classpath(LIB_JAR)\n+                .run()\n+                .writeAll();\n+\n+        \/\/ Assertion 1: The class file in the JAR is unchanged.\n+        \/\/\n+        \/\/ Since compilation succeeded, we know it used NEW_LIB_SOURCE, and if it\n+        \/\/ wrote the class file back to the JAR (bad) then that should now have\n+        \/\/ different contents. Note that the modification time of the class file\n+        \/\/ is NOT modified, even if the JAR is updated, so we cannot test that.\n+        if (getLibCrc() != originalLibCrc) {\n+            throw new AssertionError(\"Class library contents were modified in the JAR file.\");\n+        }\n+        if (!Arrays.equals(Files.readAllBytes(LIB_JAR), originalJarContents)) {\n+            throw new AssertionError(\"Jar file was modified.\");\n+        }\n+\n+        \/\/ Assertion 2: An output class file was written to the current directory.\n+        if (!Files.exists(outputClassFile)) {\n+            throw new AssertionError(\"Output class file was not written to the current directory.\");\n+        }\n+    }\n+\n+    \/\/ Note: JarOutputStream only writes modification time, not creation time, but\n+    \/\/ that's what Javac uses to determine \"newness\" so it's fine.\n+    private static void writeEntry(JarOutputStream jar, String name, byte[] bytes, Instant timestamp) throws IOException {\n+        ZipEntry e = new ZipEntry(name);\n+        e.setLastModifiedTime(FileTime.from(timestamp));\n+        jar.putNextEntry(e);\n+        jar.write(bytes);\n+        jar.closeEntry();\n+    }\n+\n+    private static long getLibCrc() throws IOException {\n+        try (ZipFile zipFile = new ZipFile(\"lib.jar\")) {\n+            \/\/ zipFile.stream().map(NoOverwriteJarClassFilesByDefault::format).forEach(System.err::println);\n+            return zipFile.getEntry(LIB_CLASS_NAME).getCrc();\n+        }\n+    }\n+\n+    \/\/ ---- Debug helper methods ----\n+    private static String format(ZipEntry e) {\n+        return String.format(\"name: %s, size: %s, modified: %s\\n\", e.getName(), e.getSize(), toLocalTime(e.getLastModifiedTime()));\n+    }\n+\n+    private static String toLocalTime(FileTime t) {\n+        return t != null ? t.toInstant().atZone(ZoneId.systemDefault()).toString() : \"<null>\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/NoOverwriteJarClassFilesByDefault.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -1,181 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8338675\n- * @summary javac shouldn't silently change .jar files on the classpath\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n- * @run main NoOverwriteJarClassFilesByDefault\n- *\/\n-\n-import toolbox.JavacTask;\n-import toolbox.ToolBox;\n-\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.attribute.FileTime;\n-import java.time.Instant;\n-import java.time.ZoneId;\n-import java.util.jar.JarOutputStream;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-\n-\/**\n- * This test makes two specific assertions about javac behaviour when source\n- * files are found in the classpath.\n- *\n- * <ol>\n- *     <li>Source files found in classpath JAR files are not overwritten.\n- *     <li>Class files generated during compilation which are associated with any\n- *    sources found in JAR files are written (flat) to the current directory.\n- * <\/ol>\n- *\n- * <p>Note that this behaviour is not obviously well-defined, and should not\n- * be relied upon, but it matches previous JDK behaviour and so is tested here.\n- *\n- * <p>Specifically, the behaviour in (2) means library classes with the same base\n- * class name may be overwritten, and the resulting set of class files in the\n- * current directory may not be usable.\n- *\/\n-public class NoOverwriteJarClassFilesByDefault {\n-\n-    private static final String OLD_LIB_SOURCE = \"\"\"\n-            package lib;\n-            public class LibClass {\n-                public static final String OLD_FIELD = \"This will not compile with Target\";\n-            }\n-            \"\"\";\n-\n-    private static final String NEW_LIB_SOURCE = \"\"\"\n-            package lib;\n-            public class LibClass {\n-                public static final String NEW_FIELD = \"Only this will compile with Target\";\n-            }\n-            \"\"\";\n-\n-    \/\/ Target source references the field only available in the new source.\n-    private static final String TARGET_SOURCE = \"\"\"\n-            class TargetClass {\n-                static final String VALUE = lib.LibClass.NEW_FIELD;\n-            }\n-            \"\"\";\n-\n-    private static final String LIB_SOURCE_NAME = \"lib\/LibClass.java\";\n-    private static final String LIB_CLASS_NAME = \"lib\/LibClass.class\";\n-\n-    public static void main(String[] args) throws IOException {\n-        ToolBox tb = new ToolBox();\n-        tb.createDirectories(\"lib\");\n-        tb.writeFile(LIB_SOURCE_NAME, OLD_LIB_SOURCE);\n-\n-        \/\/ Compile the old (broken) source and then store the class file in the JAR.\n-        \/\/ The class file generated he is in the lib\/ directory, which we delete\n-        \/\/ after making the JAR (just to be sure).\n-        new JavacTask(tb).files(LIB_SOURCE_NAME).run();\n-\n-        \/\/ The new (fixed) source is never written to disk, so if compilation works\n-        \/\/ it proves it's getting it from the source file in the JAR.\n-        Instant olderTime = Instant.now();\n-        Instant newerTime = olderTime.plusSeconds(1);\n-        try (OutputStream jos = Files.newOutputStream(Path.of(\"lib.jar\"))) {\n-            JarOutputStream jar = new JarOutputStream(jos);\n-            \/\/ Important: The JAR file entry order *matters* if the timestamps are\n-            \/\/ the same (the latter entry is used for compilation, regardless of\n-            \/\/ whether it's a source file or a class file). So in this test, we\n-            \/\/ put the one we want to use *first* with a newer timestamp, to show\n-            \/\/ that it's definitely the timestamp being used to select the source.\n-            writeEntry(jar, LIB_SOURCE_NAME, NEW_LIB_SOURCE.getBytes(), newerTime);\n-            \/\/ Source is newer than the (broken) compiled class, so should compile\n-            \/\/ from the source file in the JAR. If timestamps were not set, or set\n-            \/\/ equal, the test would use this (broken) class file, and fail.\n-            writeEntry(jar, LIB_CLASS_NAME, Files.readAllBytes(Path.of(LIB_CLASS_NAME)), olderTime);\n-            jar.close();\n-        }\n-        \/\/ Check there's no output file present and delete the original library files.\n-        Path outputClassFile = Path.of(\"LibClass.class\");\n-        if (Files.exists(outputClassFile)) {\n-            throw new IllegalStateException(\"Output class file should not exist (yet).\");\n-        }\n-        Path libDir = Path.of(\"lib\");\n-        tb.cleanDirectory(libDir);\n-        tb.deleteFiles(libDir);\n-\n-        \/\/ Before running the test itself, get the CRC of the class file in the JAR.\n-        long originalLibCrc = getLibCrc();\n-\n-        \/\/ Code under test:\n-        \/\/ Compile the target class with new library source only available in the JAR.\n-        \/\/\n-        \/\/ This compilation only succeeds if 'NEW_FIELD' exists, which is only in\n-        \/\/ the source file written to the JAR, and nowhere on disk.\n-        new JavacTask(tb).sources(TARGET_SOURCE).classpath(\"lib.jar\").run();\n-\n-        \/\/ Assertion 1: The class file in the JAR is unchanged.\n-        \/\/\n-        \/\/ Since compilation succeeded, we know it used NEW_LIB_SOURCE, and if it\n-        \/\/ wrote the class file back to the JAR (bad) then that should now have\n-        \/\/ different contents. Note that the modification time of the class file\n-        \/\/ is NOT modified, even if the JAR is updated, so we cannot test that.\n-        long actualLibCrc = getLibCrc();\n-        if (actualLibCrc != originalLibCrc) {\n-            throw new AssertionError(\"Class library contents were modified in the JAR file.\");\n-        }\n-\n-        \/\/ Assertion 2: An output class file was written to the current directory.\n-        if (!Files.exists(outputClassFile)) {\n-            throw new AssertionError(\"Output class file was not written to the current directory.\");\n-        }\n-    }\n-\n-    \/\/ Note: JarOutputStream only writes modification time, not creation time, but\n-    \/\/ that's what Javac uses to determine \"newness\" so it's fine.\n-    private static void writeEntry(JarOutputStream jar, String name, byte[] bytes, Instant timestamp) throws IOException {\n-        ZipEntry e = new ZipEntry(name);\n-        e.setLastModifiedTime(FileTime.from(timestamp));\n-        jar.putNextEntry(e);\n-        jar.write(bytes);\n-        jar.closeEntry();\n-    }\n-\n-    private static long getLibCrc() throws IOException {\n-        try (ZipFile zipFile = new ZipFile(\"lib.jar\")) {\n-            \/\/ zipFile.stream().map(NoOverwriteJarClassFilesByDefault::format).forEach(System.err::println);\n-            return zipFile.getEntry(LIB_CLASS_NAME).getCrc();\n-        }\n-    }\n-\n-    \/\/ ---- Debug helper methods ----\n-    private static String format(ZipEntry e) {\n-        return String.format(\"name: %s, size: %s, modified: %s\\n\", e.getName(), e.getSize(), toLocalTime(e.getLastModifiedTime()));\n-    }\n-\n-    private static String toLocalTime(FileTime t) {\n-        return t != null ? t.toInstant().atZone(ZoneId.systemDefault()).toString() : \"<null>\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/T8338675\/NoOverwriteJarClassFilesByDefault.java","additions":0,"deletions":181,"binary":false,"changes":181,"status":"deleted"}]}