{"files":[{"patch":"@@ -916,0 +916,2 @@\n+                \/\/ Sibling is the associated source of the class file (e.g. x\/y\/Foo.java).\n+                \/\/ The base name for class output is the class file name (e.g. \"Foo.class\").\n@@ -917,1 +919,4 @@\n-                if (sibling != null && sibling instanceof PathFileObject pathFileObject) {\n+                \/\/ Use the sibling to determine the output location where possible, unless\n+                \/\/ it is in a JAR\/ZIP file (we don't attempt to write class files back into\n+                \/\/ archives). See JDK-8338675.\n+                if (sibling instanceof PathFileObject pathFileObject && !pathFileObject.isJarFile()) {\n@@ -920,3 +925,6 @@\n-                    Path p = getPath(baseName);\n-                    Path real = fsInfo.getCanonicalFile(p);\n-                    return PathFileObject.forSimplePath(this, real, p);\n+                    \/\/ Without the sibling present, we just create an output path in the\n+                    \/\/ current working directory (this isn't great, but it is what older\n+                    \/\/ versions of the JDK did).\n+                    Path userPath = getPath(baseName);\n+                    Path realPath = fsInfo.getCanonicalFile(userPath);\n+                    return PathFileObject.forSimplePath(this, realPath, userPath);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -357,0 +357,7 @@\n+    \/**\n+     * Returns whether this file object represents a file in a JAR archive.\n+     *\/\n+    boolean isJarFile() {\n+        return this instanceof JarFileObject;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/PathFileObject.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338675\n+ * @summary javac shouldn't silently change .jar files on the classpath\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @run main NoOverwriteJarClassFilesByDefault\n+ *\/\n+\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.util.jar.JarOutputStream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+\/**\n+ * This test makes two specific assertions about javac behaviour when source\n+ * files are found in the classpath.\n+ *\n+ * <ol>\n+ *     <li>Source files found in classpath JAR files are not overwritten.\n+ *     <li>Class files generated during compilation which are associated with any\n+ *    sources found in JAR files are written (flat) to the current directory.\n+ * <\/ol>\n+ *\n+ * <p>Note that this behaviour is not obviously well-defined, and should not\n+ * be relied upon, but it matches previous JDK behaviour and so is tested here.\n+ *\n+ * <p>Specifically, the behaviour in (2) means library classes with the same base\n+ * class name may be overwritten, and the resulting set of class files in the\n+ * current directory may not be usable.\n+ *\/\n+public class NoOverwriteJarClassFilesByDefault {\n+\n+    private static final String OLD_LIB_SOURCE = \"\"\"\n+            package lib;\n+            public class LibClass {\n+                public static final String OLD_FIELD = \"This will not compile with Target\";\n+            }\n+            \"\"\";\n+\n+    private static final String NEW_LIB_SOURCE = \"\"\"\n+            package lib;\n+            public class LibClass {\n+                public static final String NEW_FIELD = \"Only this will compile with Target\";\n+            }\n+            \"\"\";\n+\n+    \/\/ Target source references the field only available in the new source.\n+    private static final String TARGET_SOURCE = \"\"\"\n+            class TargetClass {\n+                static final String VALUE = lib.LibClass.NEW_FIELD;\n+            }\n+            \"\"\";\n+\n+    private static final String LIB_SOURCE_NAME = \"lib\/LibClass.java\";\n+    private static final String LIB_CLASS_NAME = \"lib\/LibClass.class\";\n+\n+    public static void main(String[] args) throws IOException {\n+        ToolBox tb = new ToolBox();\n+        tb.createDirectories(\"lib\");\n+        tb.writeFile(LIB_SOURCE_NAME, OLD_LIB_SOURCE);\n+\n+        \/\/ Compile the old (broken) source and then store the class file in the JAR.\n+        \/\/ The class file generated he is in the lib\/ directory, which we delete\n+        \/\/ after making the JAR (just to be sure).\n+        new JavacTask(tb).files(LIB_SOURCE_NAME).run();\n+\n+        \/\/ The new (fixed) source is never written to disk, so if compilation works\n+        \/\/ it proves it's getting it from the source file in the JAR.\n+        Instant olderTime = Instant.now();\n+        Instant newerTime = olderTime.plusSeconds(1);\n+        try (OutputStream jos = Files.newOutputStream(Path.of(\"lib.jar\"))) {\n+            JarOutputStream jar = new JarOutputStream(jos);\n+            \/\/ Important: The JAR file entry order *matters* if the timestamps are\n+            \/\/ the same (the latter entry is used for compilation, regardless of\n+            \/\/ whether it's a source file or a class file). So in this test, we\n+            \/\/ put the one we want to use *first* with a newer timestamp, to show\n+            \/\/ that it's definitely the timestamp being used to select the source.\n+            writeEntry(jar, LIB_SOURCE_NAME, NEW_LIB_SOURCE.getBytes(), newerTime);\n+            \/\/ Source is newer than the (broken) compiled class, so should compile\n+            \/\/ from the source file in the JAR. If timestamps were not set, or set\n+            \/\/ equal, the test would use this (broken) class file, and fail.\n+            writeEntry(jar, LIB_CLASS_NAME, Files.readAllBytes(Path.of(LIB_CLASS_NAME)), olderTime);\n+            jar.close();\n+        }\n+        \/\/ Check there's no output file present and delete the original library files.\n+        Path outputClassFile = Path.of(\"LibClass.class\");\n+        if (Files.exists(outputClassFile)) {\n+            throw new IllegalStateException(\"Output class file should not exist (yet).\");\n+        }\n+        Path libDir = Path.of(\"lib\");\n+        tb.cleanDirectory(libDir);\n+        tb.deleteFiles(libDir);\n+\n+        \/\/ Before running the test itself, get the CRC of the class file in the JAR.\n+        long originalLibCrc = getLibCrc();\n+\n+        \/\/ Code under test:\n+        \/\/ Compile the target class with new library source only available in the JAR.\n+        \/\/\n+        \/\/ This compilation only succeeds if 'NEW_FIELD' exists, which is only in\n+        \/\/ the source file written to the JAR, and nowhere on disk.\n+        new JavacTask(tb).sources(TARGET_SOURCE).classpath(\"lib.jar\").run();\n+\n+        \/\/ Assertion 1: The class file in the JAR is unchanged.\n+        \/\/\n+        \/\/ Since compilation succeeded, we know it used NEW_LIB_SOURCE, and if it\n+        \/\/ wrote the class file back to the JAR (bad) then that should now have\n+        \/\/ different contents. Note that the modification time of the class file\n+        \/\/ is NOT modified, even if the JAR is updated, so we cannot test that.\n+        long actualLibCrc = getLibCrc();\n+        if (actualLibCrc != originalLibCrc) {\n+            throw new AssertionError(\"Class library contents were modified in the JAR file.\");\n+        }\n+\n+        \/\/ Assertion 2: An output class file was written to the current directory.\n+        if (!Files.exists(outputClassFile)) {\n+            throw new AssertionError(\"Output class file was not written to the current directory.\");\n+        }\n+    }\n+\n+    \/\/ Note: JarOutputStream only writes modification time, not creation time, but\n+    \/\/ that's what Javac uses to determine \"newness\" so it's fine.\n+    private static void writeEntry(JarOutputStream jar, String name, byte[] bytes, Instant timestamp) throws IOException {\n+        ZipEntry e = new ZipEntry(name);\n+        e.setLastModifiedTime(FileTime.from(timestamp));\n+        jar.putNextEntry(e);\n+        jar.write(bytes);\n+        jar.closeEntry();\n+    }\n+\n+    private static long getLibCrc() throws IOException {\n+        try (ZipFile zipFile = new ZipFile(\"lib.jar\")) {\n+            \/\/ zipFile.stream().map(NoOverwriteJarClassFilesByDefault::format).forEach(System.err::println);\n+            return zipFile.getEntry(LIB_CLASS_NAME).getCrc();\n+        }\n+    }\n+\n+    \/\/ ---- Debug helper methods ----\n+    private static String format(ZipEntry e) {\n+        return String.format(\"name: %s, size: %s, modified: %s\\n\", e.getName(), e.getSize(), toLocalTime(e.getLastModifiedTime()));\n+    }\n+\n+    private static String toLocalTime(FileTime t) {\n+        return t != null ? t.toInstant().atZone(ZoneId.systemDefault()).toString() : \"<null>\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8338675\/NoOverwriteJarClassFilesByDefault.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"}]}