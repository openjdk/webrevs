{"files":[{"patch":"@@ -916,0 +916,2 @@\n+                \/\/ Sibling is the associated source of the class file (e.g. x\/y\/Foo.java).\n+                \/\/ The base name for class output is the class file name (e.g. \"Foo.class\").\n@@ -917,1 +919,4 @@\n-                if (sibling != null && sibling instanceof PathFileObject pathFileObject) {\n+                \/\/ Use the sibling to determine the output location where possible, unless\n+                \/\/ it is in a JAR\/ZIP file (we don't attempt to write class files back into\n+                \/\/ archives).\n+                if (sibling instanceof PathFileObject pathFileObject && !pathFileObject.isJarFile()) {\n@@ -920,3 +925,6 @@\n-                    Path p = getPath(baseName);\n-                    Path real = fsInfo.getCanonicalFile(p);\n-                    return PathFileObject.forSimplePath(this, real, p);\n+                    \/\/ Without the sibling present, we just create an output path in the\n+                    \/\/ current working directory (this isn't great, but it is what older\n+                    \/\/ versions of the JDK did).\n+                    Path userPath = getPath(baseName);\n+                    Path realPath = fsInfo.getCanonicalFile(userPath);\n+                    return PathFileObject.forSimplePath(this, realPath, userPath);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -357,0 +357,7 @@\n+    \/**\n+     * Returns whether this file object represents a file in a JAR archive.\n+     *\/\n+    boolean isJarFile() {\n+        return this instanceof JarFileObject;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/PathFileObject.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338675\n+ * @summary javac shouldn't silently change .jar files on the classpath\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @run junit TestNoOverwriteJarFiles\n+ *\/\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.parallel.Execution;\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.FileObject;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n+import java.util.Set;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+\n+import static javax.tools.StandardLocation.CLASS_OUTPUT;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.parallel.ExecutionMode.SAME_THREAD;\n+\n+\/**\n+ * Tests that javac cannot unexpectedly modify contents of JAR files on the\n+ * class path.\n+ * <p>\n+ * Consider the following javac behaviours:\n+ * <ol>\n+ * <li>If there is no source path, javac searches the classpath for sources,\n+ * including inside JAR files.\n+ * <li>If a Java source file was modified more recently that an existing class\n+ * file, or if no class file exists, javac will compile it from the source.\n+ * <li>If there is no output directory specified, javac will put compiled class\n+ * files next to their corresponding sources.\n+ * <\/ol>\n+ * Taken together, this suggests that a newly compiled class file should be\n+ * written back into the JAR in which its source was found, possibly overwriting\n+ * an existing class file entry. This would be very problematic.\n+ * <p>\n+ * This test ensures javac will not modify JAR files on the classpath, even if\n+ * it compiles sources contained within them. Instead, the class file will be\n+ * written into the current working directory, which mimics the JDK 8 behavior.\n+ *\n+ * <h2>Important<\/h2>\n+ *\n+ * This test creates files from Java compilation and annotation processing, and\n+ * relies on files being written to the current working directory. Since jtreg\n+ * currently offers no way to run each test case in its own directory, or clean\n+ * the test directory between test cases, we must be careful to:\n+ * <ul>\n+ *     <li>Use {@code @Execution(SAME_THREAD)} to run test cases sequentially.\n+ *     <li>Clean up the test directory ourselves between test cases (via\n+ *     {@code @BeforeEach}).\n+ * <\/ul>\n+ * The alternative approach would be to compile the test classes in a specified\n+ * working directory unique to each test case, but this is currently only\n+ * possible using a subprocess via {@code Task.Mode.EXEC} , and this has two\n+ * serious disadvantages:\n+ * <ul>\n+ *     <li>It significantly complicates compilation setup.\n+ *     <li>It prevents step-through debugging of the annotation processor.\n+ * <\/ul>\n+ *\/\n+@Execution(SAME_THREAD)\n+public class TestNoOverwriteJarFiles {\n+    private static final String LIB_SOURCE_FILE_NAME = \"lib\/LibClass.java\";\n+    private static final String LIB_CLASS_FILE_NAME = \"lib\/LibClass.class\";\n+    private static final String LIB_CLASS_TYPE_NAME = \"lib.LibClass\";\n+\n+    private static final Path TEST_LIB_JAR = Path.of(\"lib.jar\");\n+    private static final Path OUTPUT_CLASS_FILE = Path.of(\"LibClass.class\");\n+\n+    \/\/ Source which can only compile against the Java source in the test library.\n+    public static final String TARGET_SOURCE =\n+            \"\"\"\n+            class TargetClass {\n+                static final String VALUE = lib.LibClass.NEW_FIELD;\n+            }\n+            \"\"\";\n+\n+    \/\/ Not expensive to create, but conceptually a singleton.\n+    private static final ToolBox toolBox = new ToolBox();\n+\n+    @BeforeAll\n+    public static void ensureEmptyTestDirectory() throws IOException {\n+        try (var files = Files.walk(Path.of(\".\"), 1)) {\n+            \/\/ Always includes the given path as the first returned element, so skip it.\n+            if (files.skip(1).findFirst().isPresent()) {\n+                throw new IllegalStateException(\"Test working directory must be empty.\");\n+            }\n+        }\n+    }\n+\n+    @BeforeEach\n+    public void cleanUpTestDirectory() throws IOException {\n+        toolBox.cleanDirectory(Path.of(\".\"));\n+    }\n+\n+    @Test\n+    public void jarFileNotModifiedOrdinaryCompilation() throws IOException {\n+        byte[] originalJarBytes = compileTestLibJar();\n+\n+        new JavacTask(toolBox)\n+                .sources(TARGET_SOURCE)\n+                .classpath(TEST_LIB_JAR)\n+                .run()\n+                .writeAll();\n+\n+        \/\/ Assertion 1: The JAR is unchanged.\n+        assertArrayEquals(originalJarBytes, Files.readAllBytes(TEST_LIB_JAR), \"Jar file was modified.\");\n+        \/\/ Assertion 2: An output class file was written to the current directory.\n+        assertTrue(Files.exists(OUTPUT_CLASS_FILE), \"Output class file missing.\");\n+    }\n+\n+    @Test\n+    public void jarFileNotModifiedAnnotationProcessing() throws IOException {\n+        byte[] originalJarBytes = compileTestLibJar();\n+\n+        new JavacTask(toolBox)\n+                .sources(TARGET_SOURCE)\n+                .classpath(TEST_LIB_JAR)\n+                .processors(new TestAnnotationProcessor())\n+                \/\/ Use \"-implicit:none\" to avoid writing the library class file.\n+                .options(\"-implicit:none\", \"-g:source,lines,vars\")\n+                .run()\n+                .writeAll();\n+\n+        \/\/ Assertion 1: The JAR is unchanged.\n+        assertArrayEquals(originalJarBytes, Files.readAllBytes(TEST_LIB_JAR), \"Jar file was modified.\");\n+        \/\/ Assertion 2: All expected output files were written to the current directory.\n+        assertDummyFile(\"DummySource.java\");\n+        assertDummyFile(\"DummyClass.class\");\n+        assertDummyFile(\"DummyResource.txt\");\n+        \/\/ Assertion 3: The class file itself wasn't written (because we used \"-implicit:none\").\n+        assertFalse(Files.exists(OUTPUT_CLASS_FILE), \"Unexpected class file in working directory.\");\n+    }\n+\n+    static class TestAnnotationProcessor extends JavacTestingAbstractProcessor {\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n+            \/\/ Only run this once (in the final pass), or else we get spurious failures about\n+            \/\/ trying to recreate file objects (not allowed during annotation processing).\n+            if (!env.processingOver()) {\n+                return false;\n+            }\n+\n+            TypeElement libClass = elements.getTypeElement(LIB_CLASS_TYPE_NAME);\n+            try {\n+                \/\/ Note: A generated Java source file must be legal Java, but a generated class\n+                \/\/ file that's unreferenced will never be loaded, so can contain any bytes.\n+                writeFileObject(\n+                        filer.createSourceFile(\"DummySource\", libClass),\n+                        \"DummySource.java\",\n+                        \"class DummySource {}\");\n+                writeFileObject(\n+                        filer.createClassFile(\"DummyClass\", libClass),\n+                        \"DummyClass.class\",\n+                        \"<<DummyClass Bytes>>\");\n+                writeFileObject(\n+                        filer.createResource(CLASS_OUTPUT, \"\", \"DummyResource.txt\", libClass),\n+                        \"DummyResource.txt\",\n+                        \"Dummy Resource Bytes\");\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static void writeFileObject(FileObject file, String expectedName, String contents) throws IOException {\n+        URI fileUri = file.toUri();\n+        \/\/ Check that the file URI doesn't look like it is associated with a JAR.\n+        assertTrue(fileUri.getSchemeSpecificPart().endsWith(\"\/\" + expectedName));\n+        \/\/ The JAR file system would have a scheme of \"jar\", not \"file\".\n+        assertEquals(\"file\", fileUri.getScheme());\n+        \/\/ Testing a negative is fragile, but a JAR URI would be expected to contain \"jar!\".\n+        assertFalse(fileUri.getSchemeSpecificPart().contains(\"jar!\"));\n+        \/\/ Write dummy data (which should end up in the test working directory).\n+        try (OutputStream os = file.openOutputStream()) {\n+            os.write(contents.getBytes());\n+        }\n+    }\n+\n+    static void assertDummyFile(String filename) throws IOException {\n+        Path path = Path.of(filename);\n+        assertTrue(Files.exists(path), \"Output file missing: \" + filename);\n+        assertTrue(Files.readString(path).contains(\"Dummy\"), \"Unexpected file contents: \" + filename);\n+    }\n+\n+    \/\/ Compiles and writes the test library JAR (LIB_JAR) into the current directory.\n+    static byte[] compileTestLibJar() throws IOException {\n+        Path libDir = Path.of(\"lib\");\n+        toolBox.createDirectories(libDir);\n+        try {\n+            toolBox.writeFile(LIB_SOURCE_FILE_NAME,\n+                    \"\"\"\n+                    package lib;\n+                    public class LibClass {\n+                        public static final String OLD_FIELD = \"This will not compile with Target\";\n+                    }\n+                    \"\"\");\n+\n+            \/\/ Compile the old (broken) source and then store the class file in the JAR.\n+            \/\/ The class file is generated in the lib\/ directory, which we delete after\n+            \/\/ making the JAR. This ensures that when compiling the target class, it's\n+            \/\/ the source file being read from the JAR,\n+            new JavacTask(toolBox)\n+                    .files(LIB_SOURCE_FILE_NAME)\n+                    .run()\n+                    .writeAll();\n+\n+            \/\/ If timestamps are equal JAR file resolution of classes is ambiguous\n+            \/\/ (currently \"last one wins\"), so give the source we want to be used a\n+            \/\/ newer timestamp.\n+            Instant now = Instant.now();\n+            try (OutputStream jos = Files.newOutputStream(Path.of(\"lib.jar\"))) {\n+                JarOutputStream jar = new JarOutputStream(jos);\n+                writeEntry(jar,\n+                        LIB_SOURCE_FILE_NAME,\n+                        \"\"\"\n+                        package lib;\n+                        public class LibClass {\n+                            public static final String NEW_FIELD = \"This will compile with Target\";\n+                        }\n+                        \"\"\".getBytes(StandardCharsets.UTF_8),\n+                        now.plusSeconds(1));\n+                writeEntry(jar,\n+                        LIB_CLASS_FILE_NAME,\n+                        Files.readAllBytes(Path.of(LIB_CLASS_FILE_NAME)),\n+                        now);\n+                jar.close();\n+            }\n+            \/\/ Return the JAR file bytes for comparison later.\n+            return Files.readAllBytes(TEST_LIB_JAR);\n+        } finally {\n+            toolBox.cleanDirectory(libDir);\n+            toolBox.deleteFiles(libDir);\n+        }\n+    }\n+\n+    \/\/ Note: JarOutputStream only writes modification time, not creation time, but\n+    \/\/ that's what Javac uses to determine \"newness\" so it's fine.\n+    private static void writeEntry(JarOutputStream jar, String name, byte[] bytes, Instant timestamp) throws IOException {\n+        ZipEntry e = new ZipEntry(name);\n+        e.setLastModifiedTime(FileTime.from(timestamp));\n+        jar.putNextEntry(e);\n+        jar.write(bytes);\n+        jar.closeEntry();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/filer\/TestNoOverwriteJarFiles.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"}]}