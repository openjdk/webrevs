{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -37,0 +38,5 @@\n+ * <p>\n+ * Similar to nominal descriptors from {@link java.lang.constant}, {@code\n+ * ClassSignature} can represent generic signatures that cannot be represented in\n+ * classfile.  There is no classfile representation checks for string or nominal\n+ * descriptor arguments passed to static factory methods in this class.\n@@ -107,0 +113,1 @@\n+     * The string may be unrepresentable by a {@link Utf8Entry}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -41,0 +42,5 @@\n+ * <p>\n+ * Similar to nominal descriptors from {@link java.lang.constant}, {@code\n+ * MethodSignature} can represent generic signatures that cannot be represented in\n+ * classfile.  There is no classfile representation checks for string or nominal\n+ * descriptor arguments passed to static factory methods in this class.\n@@ -150,0 +156,1 @@\n+     * The string may be unrepresentable by a {@link Utf8Entry}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -51,0 +52,5 @@\n+ * <p>\n+ * Similar to nominal descriptors from {@link java.lang.constant}, {@code\n+ * Signature} can represent type signatures that cannot be represented in\n+ * classfile.  There is no classfile representation checks for string or nominal\n+ * descriptor arguments passed to static factory methods in this class.\n@@ -65,1 +71,2 @@\n-     * Parses a Java type signature from a raw string.\n+     * Parses a Java type signature from a raw string.  The string may be\n+     * unrepresentable by a {@link Utf8Entry}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -110,0 +110,2 @@\n+     * @throws IllegalArgumentException if the raw signature string is not\n+     *         representable by a {@link Utf8Entry}\n@@ -119,0 +121,2 @@\n+     * @throws IllegalArgumentException if the raw signature string is not\n+     *         representable by a {@link Utf8Entry}\n@@ -128,0 +132,2 @@\n+     * @throws IllegalArgumentException if the raw signature string is not\n+     *         representable by a {@link Utf8Entry}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SignatureAttribute.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,3 +35,5 @@\n- * Unless otherwise specified, passing {@code null} or an array or collection containing a {@code null} element as an\n- * argument to a constructor or method of any Class-File API class or interface will cause a {@link NullPointerException}\n- * to be thrown.\n+ * Unless otherwise noted, passing null or an array or collection that contains null as an element to a constructor or\n+ * method of any Class-File API class or interface will cause a {@link NullPointerException} to be thrown; passing any\n+ * string or nominal descriptor that cannot be represented in classfile, or an array or collection that contains such a\n+ * string or nominal descriptor as an element to a constructor or method of any Class-File API class or interface will\n+ * cause an {@link IllegalArgumentException} to be thrown.\n@@ -103,0 +105,1 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/package-info.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,3 +33,5 @@\n- * Unless otherwise specified, passing {@code null} or an array or collection containing a {@code null} element as an\n- * argument to a constructor or method of any Class-File API class or interface will cause a {@link NullPointerException}\n- * to be thrown.\n+ * Unless otherwise noted, passing null or an array or collection that contains null as an element to a constructor or\n+ * method of any Class-File API class or interface will cause a {@link NullPointerException} to be thrown; passing any\n+ * string or nominal descriptor that cannot be represented in classfile, or an array or collection that contains such a\n+ * string or nominal descriptor as an element to a constructor or method of any Class-File API class or interface will\n+ * cause an {@link IllegalArgumentException} to be thrown.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/package-info.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,5 @@\n- * Unless otherwise specified, passing {@code null} or an array or collection containing a {@code null} element as an\n- * argument to a constructor or method of any Class-File API class or interface will cause a {@link NullPointerException}\n- * to be thrown.\n+ * Unless otherwise noted, passing null or an array or collection that contains null as an element to a constructor or\n+ * method of any Class-File API class or interface will cause a {@link NullPointerException} to be thrown; passing any\n+ * string or nominal descriptor that cannot be represented in classfile, or an array or collection that contains such a\n+ * string or nominal descriptor as an element to a constructor or method of any Class-File API class or interface will\n+ * cause an {@link IllegalArgumentException} to be thrown.\n@@ -70,0 +72,1 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/package-info.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -253,6 +253,0 @@\n- * <p>\n- * Unless otherwise noted, passing a {@code null} argument to a constructor\n- * or method of any Class-File API class or interface will cause a {@link\n- * NullPointerException} to be thrown. Additionally,\n- * invoking a method with an array or collection containing a {@code null} element\n- * will cause a {@code NullPointerException}, unless otherwise specified.\n@@ -284,0 +278,8 @@\n+ * Unless otherwise noted, passing null or an array or collection that contains\n+ * null as an element to a constructor or method of any Class-File API class or\n+ * interface will cause a {@link NullPointerException} to be thrown; passing any\n+ * string or nominal descriptor that cannot be represented in classfile, or an\n+ * array or collection that contains such a string or nominal descriptor as an\n+ * element to a constructor or method of any Class-File API class or interface\n+ * will cause an {@link IllegalArgumentException} to be thrown.\n+ * <p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,10 @@\n+ * <p>\n+ * Nominal descriptors may represent entities not possible at run-time due to\n+ * restrictions of the Java Virtual Machine.  For example, the {@linkplain\n+ * java.io.DataInput##modified-utf-8 Modified UTF-8} representation of a class\n+ * name must not have a length over 65535, and method arguments can use at most\n+ * 255 slots.  These restrictions do not exist for {@link ClassDesc} or {@link\n+ * MethodTypeDesc}, and their resolution through {@code resolveConstantDesc}\n+ * may result in errors.  Consumers of nominal descriptors, such as bytecode\n+ * reading and writing APIs, should define the behaviors when such descriptors\n+ * are passed.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/package-info.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.ModifiedUtf;\n@@ -157,0 +158,3 @@\n+            if (!ModifiedUtf.isValidLengthInConstantPool(s)) {\n+                throw new IllegalArgumentException(\"utf8 length out of range of u2: \" + ModifiedUtf.utfLen(s));\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -280,4 +280,2 @@\n-        if (!ExactConversionsSupport.isLongToCharExact(utflenLong)) {\n-            throw new IllegalArgumentException(\"utf8 length out of range of u2: \" + utflenLong);\n-        }\n-        int utflen = (int)utflenLong;\n+        assert ExactConversionsSupport.isLongToCharExact(utflenLong) : utflenLong;\n+        int utflen = (int) utflenLong;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,8 +31,5 @@\n-\/**\n- * Helper to JDK UTF putChar and Calculate length\n- *\n- * @since 24\n- *\/\n-public abstract class ModifiedUtf {\n-    \/\/ Maximum number of bytes allowed for a Modified UTF-8 encoded string\n-    \/\/ in a ClassFile constant pool entry (CONSTANT_Utf8_info).\n+\/\/\/ Utilities for string encoding and decoding with the\n+\/\/\/ [Modified UTF-8][java.io.DataInput##modified-utf-8] format.\n+public final class ModifiedUtf {\n+    \/\/\/ Maximum number of bytes allowed for a Modified UTF-8 encoded string\n+    \/\/\/ in a [java.lang.classfile.constantpool.Utf8Entry] or a hotspot `Symbol`.\n@@ -61,5 +58,17 @@\n-    \/**\n-     * Calculate the utf length of a string\n-     * @param str input string\n-     * @param countNonZeroAscii the number of non-zero ascii characters in the prefix calculated by JLA.countNonZeroAscii(str)\n-     *\/\n+    \/\/\/ Calculate the encoded length of an input String.\n+    \/\/\/ For many workloads that have fast paths for ASCII-only prefixes,\n+    \/\/\/ [#utfLen(String, int)] skips scanning that prefix.\n+    \/\/\/\n+    \/\/\/ @param str input string\n+    public static long utfLen(String str) {\n+        return utfLen(str, 0);\n+    }\n+\n+    \/\/\/ Calculate the encoded length of trailing parts of an input String,\n+    \/\/\/ after [jdk.internal.access.JavaLangAccess#countNonZeroAscii(String)]\n+    \/\/\/ calculates the number of contiguous single-byte characters in the\n+    \/\/\/ beginning of the string.\n+    \/\/\/\n+    \/\/\/ @param str input string\n+    \/\/\/ @param countNonZeroAscii the number of non-zero ascii characters in the\n+    \/\/\/        prefix calculated by JLA.countNonZeroAscii(str)\n@@ -77,5 +86,5 @@\n-    \/**\n-     * Checks whether the Modified UTF-8 encoded length of the given string\n-     * fits within the ClassFile constant pool limit (u2 length = 65535 bytes).\n-     * @param str the string to check\n-     *\/\n+    \/\/\/ Checks whether an input String can be encoded in a\n+    \/\/\/ [java.lang.classfile.constantpool.Utf8Entry], or represented as a\n+    \/\/\/ hotspot `Symbol` (which has the same length limit).\n+    \/\/\/\n+    \/\/\/ @param str input string\n@@ -94,1 +103,1 @@\n-        long utfLen = utfLen(str, 0);\n+        long utfLen = utfLen(str);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ModifiedUtf.java","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ *      8367585\n@@ -55,0 +56,2 @@\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n@@ -59,0 +62,1 @@\n+import java.util.stream.Stream;\n@@ -64,0 +68,1 @@\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -66,0 +71,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -450,0 +457,69 @@\n+\n+    static List<String> legalStrings() {\n+        var empty = \"\";\n+        var allAscii = \"e\".repeat(0xFFFF);\n+        \/\/ 3-byte utf8 characters\n+        var largeChars = String.valueOf((char) 0x800).repeat(0xFFFF \/ 3);\n+        return List.of(empty, allAscii, largeChars);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"legalStrings\")\n+    void testStringLengthInLimit(String st) {\n+        TemporaryConstantPool.INSTANCE.utf8Entry(st);\n+        ConstantPoolBuilder.of().utf8Entry(st);\n+    }\n+\n+    static List<String> oversizedStrings() {\n+        var allAscii = \"e\".repeat(0x10000);\n+        \/\/ 3-byte utf8 characters\n+        var largeChars = String.valueOf((char) 0x800).repeat(0xFFFF \/ 3 + 1);\n+        return List.of(allAscii, largeChars);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"oversizedStrings\")\n+    void testStringLengthOverLimit(String st) {\n+        assertThrows(IllegalArgumentException.class, () -> TemporaryConstantPool.INSTANCE.utf8Entry(st));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantPoolBuilder.of().utf8Entry(st));\n+    }\n+\n+    static Stream<ConstantPoolBuilder> pools() {\n+        return Stream.of(ConstantPoolBuilder.of(), TemporaryConstantPool.INSTANCE);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testSingleReferenceNominalDescriptorOverLimit(ConstantPoolBuilder cpb) {\n+        var fittingName = \"A\" + \"a\".repeat(65532); \/\/ fits \"enveloped\" L ;\n+        var borderName = \"B\" + \"b\".repeat(65534); \/\/ fits only \"not enveloped\"\n+        var overflowName = \"C\" + \"b\".repeat(65535); \/\/ nothing fits\n+\n+        var fittingClassDesc = ClassDesc.of(fittingName);\n+        var borderClassDesc = ClassDesc.of(borderName);\n+        var overflowClassDesc = ClassDesc.of(overflowName);\n+        cpb.classEntry(fittingClassDesc);\n+        cpb.utf8Entry(fittingClassDesc);\n+        cpb.classEntry(borderClassDesc);\n+        assertThrows(IllegalArgumentException.class, () -> cpb.utf8Entry(borderClassDesc));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.classEntry(overflowClassDesc));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.utf8Entry(overflowClassDesc));\n+\n+        cpb.packageEntry(PackageDesc.of(borderName));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.packageEntry(PackageDesc.of(overflowName)));\n+        cpb.moduleEntry(ModuleDesc.of(borderName));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.moduleEntry(ModuleDesc.of(overflowName)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testMethodTypeDescOverLimit(ConstantPoolBuilder cpb) {\n+        var borderReturnMtd = MethodTypeDesc.of(ClassDesc.of(\"R\" + \"r\".repeat(65530)));\n+        var overflowReturnMtd = MethodTypeDesc.of(ClassDesc.of(\"R\" + \"r\".repeat(65531)));\n+        var borderParamMtd = MethodTypeDesc.of(CD_void, ClassDesc.of(\"P\" + \"p\".repeat(65529)));\n+        var overflowParamMtd = MethodTypeDesc.of(CD_void, ClassDesc.of(\"P\" + \"p\".repeat(65530)));\n+        cpb.utf8Entry(borderParamMtd);\n+        cpb.utf8Entry(borderReturnMtd);\n+        assertThrows(IllegalArgumentException.class, () -> cpb.utf8Entry(overflowReturnMtd));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.utf8Entry(overflowParamMtd));\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8321540 8319463 8357955 8368050 8368331\n+ * @bug 8321540 8319463 8357955 8368050 8367585 8368331\n@@ -31,0 +31,1 @@\n+import java.lang.classfile.attribute.SignatureAttribute;\n@@ -38,0 +39,1 @@\n+import java.util.Collections;\n@@ -55,0 +57,1 @@\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -56,2 +59,0 @@\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n@@ -273,41 +274,40 @@\n-    @Test\n-    void testBadTypeSignatures() {\n-        \"\"\"\n-        LObject\n-        LObject;B\n-        LIterable<LFoo>\n-        LIterable<<\n-        TBar\n-        TBar<LFoo;>\n-        B<LFoo;>\n-        B<LFoo;>;V\n-        X\n-        [LObject\n-        [LIterable<LFoo>\n-        [LIterable<<\n-        [TBar\n-        [TBar<LFoo;>\n-        [B<LFoo;>\n-        [X\n-        LSet<+Kind<**>;>;\n-        LSet<?Kind<*>;>;\n-        ()V\n-        Ljava\/util\/Opt<Ljava\/lang\/Integer;>ional;\n-        Lcom\/example\/Outer<Ljava\/lang\/String;>.package\/Inner<[I>;\n-        LSample>;\n-        LSample:Other;\n-        LOuter<[JTT;>.[Inner;\n-        TA:J;\n-        LEmpty<>;\n-        L\n-        Lcom\n-        Lcom\/example\/\n-        Lcom\/example\/Outer<\n-        Lcom\/example\/Outer<Ljava\/\n-        Lcom\/example\/Outer<Ljava\/lang\/String\n-        Lcom\/example\/Outer<Ljava\/lang\/String;\n-        Lcom\/example\/Outer<Ljava\/lang\/String;>\n-        Lcom\/example\/Outer<Ljava\/lang\/String;>.\n-        Lcom\/example\/Outer<Ljava\/lang\/String;>.Inner<[I>\n-        [V\n-        \"\"\".lines().forEach(assertThrows(Signature::parseFrom));\n+    static Stream<String> badTypeSignatures() {\n+        return \"\"\"\n+                LObject\n+                LObject;B\n+                LIterable<LFoo>\n+                LIterable<<\n+                TBar\n+                TBar<LFoo;>\n+                B<LFoo;>\n+                B<LFoo;>;V\n+                X\n+                [LObject\n+                [LIterable<LFoo>\n+                [LIterable<<\n+                [TBar\n+                [TBar<LFoo;>\n+                [B<LFoo;>\n+                [X\n+                LSet<+Kind<**>;>;\n+                LSet<?Kind<*>;>;\n+                ()V\n+                Ljava\/util\/Opt<Ljava\/lang\/Integer;>ional;\n+                Lcom\/example\/Outer<Ljava\/lang\/String;>.package\/Inner<[I>;\n+                LSample>;\n+                LSample:Other;\n+                LOuter<[JTT;>.[Inner;\n+                TA:J;\n+                LEmpty<>;\n+                L\n+                Lcom\n+                Lcom\/example\/\n+                Lcom\/example\/Outer<\n+                Lcom\/example\/Outer<Ljava\/\n+                Lcom\/example\/Outer<Ljava\/lang\/String\n+                Lcom\/example\/Outer<Ljava\/lang\/String;\n+                Lcom\/example\/Outer<Ljava\/lang\/String;>\n+                Lcom\/example\/Outer<Ljava\/lang\/String;>.\n+                Lcom\/example\/Outer<Ljava\/lang\/String;>.Inner<[I>\n+                [V\n+                \"\"\".lines();\n@@ -316,9 +316,4 @@\n-    @Test\n-    void testGoodTypeSignatures() {\n-        \"\"\"\n-        Ljava\/util\/Optional<Ljava\/lang\/Integer;>;\n-        Lcom\/example\/Outer<Ljava\/lang\/Integer;>.Inner<[I>;\n-        LSample;\n-        LOuter<[JTT;>.Inner;\n-        LOuter.Inner;\n-        \"\"\".lines().forEach(Signature::parseFrom);\n+    @ParameterizedTest\n+    @MethodSource(\"badTypeSignatures\")\n+    void testBadTypeSignatures(String s) {\n+        assertThrows(IllegalArgumentException.class, () -> Signature.parseFrom(s));\n@@ -327,27 +322,8 @@\n-    @Test\n-    void testBadClassSignatures() {\n-        \"\"\"\n-        Ljava\/lang\/Object;Ljava\/lang\/Iterable<LFoo;>\n-        LObject\n-        LObject;B\n-        LIterable<LFoo>\n-        LIterable<<\n-        TBar\n-        TBar<LFoo;>\n-        B<LFoo;>\n-        B<LFoo;>;V\n-        X\n-        LFoo<TK;>.It;L\n-        <K+LObject;>LFoo<TK;;>;LFoo<TK;>;LBar;\n-        <K:LObject;>>LFoo<TK;>;\n-        <K:LObject;>LFoo<+>;\n-        ()V\n-        <K:Ljava\/lang\/Object;>Ljava\/lang\/Object;TK;\n-        Ljava\/lang\/Object;[Ljava\/lang\/Object;\n-        [Ljava\/util\/Optional<[I>;\n-        [I\n-        <K:Ljava\/lang\/Object;>TK;\n-        <K;Q:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n-        <:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n-        <>Ljava\/lang\/Object;\n-        \"\"\".lines().forEach(assertThrows(ClassSignature::parseFrom));\n+    static Stream<String> goodTypeSignatures() {\n+        return \"\"\"\n+                Ljava\/util\/Optional<Ljava\/lang\/Integer;>;\n+                Lcom\/example\/Outer<Ljava\/lang\/Integer;>.Inner<[I>;\n+                LSample;\n+                LOuter<[JTT;>.Inner;\n+                LOuter.Inner;\n+                \"\"\".lines();\n@@ -356,25 +332,70 @@\n-    @Test\n-    void testBadMethodSignatures() {\n-        \"\"\"\n-        LObject;\n-        B\n-        ()V^\n-        ()V^B\n-        ()V^X\n-        (LObject;)\n-        (LObject)V\n-        ()LIterable<LFoo>\n-        ()LIterable<<\n-        ()TBar\n-        ()TBar;B\n-        (TBar<LFoo;>)V\n-        (B<LFoo;>)V\n-        (X)\n-        ()X\n-        ()VB\n-        ()LSet<+Kind<**>;>;\n-        (LSet<?Kind<*>;>;)V\n-        <T::LA>()V\n-        (TT;I)VI\n-        (V)V\n-        \"\"\".lines().forEach(assertThrows(MethodSignature::parseFrom));\n+    @ParameterizedTest\n+    @MethodSource(\"goodTypeSignatures\")\n+    void testGoodTypeSignature(String s) {\n+        Signature.parseFrom(s);\n+    }\n+\n+    static Stream<String> badClassSignatures() {\n+        return \"\"\"\n+                Ljava\/lang\/Object;Ljava\/lang\/Iterable<LFoo;>\n+                LObject\n+                LObject;B\n+                LIterable<LFoo>\n+                LIterable<<\n+                TBar\n+                TBar<LFoo;>\n+                B<LFoo;>\n+                B<LFoo;>;V\n+                X\n+                LFoo<TK;>.It;L\n+                <K+LObject;>LFoo<TK;;>;LFoo<TK;>;LBar;\n+                <K:LObject;>>LFoo<TK;>;\n+                <K:LObject;>LFoo<+>;\n+                ()V\n+                <K:Ljava\/lang\/Object;>Ljava\/lang\/Object;TK;\n+                Ljava\/lang\/Object;[Ljava\/lang\/Object;\n+                [Ljava\/util\/Optional<[I>;\n+                [I\n+                <K:Ljava\/lang\/Object;>TK;\n+                <K;Q:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+                <:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+                <>Ljava\/lang\/Object;\n+                \"\"\".lines();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"badClassSignatures\")\n+    void testBadClassSignature(String s) {\n+        assertThrows(IllegalArgumentException.class, () -> ClassSignature.parseFrom(s));\n+    }\n+\n+    static Stream<String> badMethodSignatures() {\n+        return \"\"\"\n+                LObject;\n+                B\n+                ()V^\n+                ()V^B\n+                ()V^X\n+                (LObject;)\n+                (LObject)V\n+                ()LIterable\n+                ()LIterable\n+                ()TBar\n+                ()TBar;B\n+                (TBar<LFoo;\n+                (B<LFoo;>)V\n+                (X)\n+                ()X\n+                ()VB\n+                ()LSet<+Kin\n+                (LSet<?Kind\n+                <T::LA>()V\n+                (TT;I)VI\n+                (V)V\n+                \"\"\".lines();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"badMethodSignatures\")\n+    void testBadMethodSignature(String s) {\n+        assertThrows(IllegalArgumentException.class, () -> MethodSignature.parseFrom(s));\n@@ -388,1 +409,1 @@\n-            Assertions.assertThrows(IllegalArgumentException.class, () -> Signature.ArrayTypeSig.of(dim, sig));\n+            assertThrows(IllegalArgumentException.class, () -> Signature.ArrayTypeSig.of(dim, sig));\n@@ -390,1 +411,1 @@\n-            Assertions.assertThrows(IllegalArgumentException.class, () -> Signature.ArrayTypeSig.of(dim, arrSig));\n+            assertThrows(IllegalArgumentException.class, () -> Signature.ArrayTypeSig.of(dim, arrSig));\n@@ -397,2 +418,62 @@\n-    private Consumer<String> assertThrows(Function<String, ?> parser) {\n-        return s -> Assertions.assertThrows(IllegalArgumentException.class, () -> parser.apply(s), s);\n+    static Stream<Signature> longTypeSignatures() {\n+        var longAsciiName = \"A\" + \"a\".repeat(65536);\n+        var longCharName = \"§\".repeat(32768);\n+        var simpleClassSig = ClassTypeSig.of(longAsciiName);\n+        var nestedSig = ClassTypeSig.of(simpleClassSig, longCharName);\n+        var typeVarSig = TypeVarSig.of(longCharName);\n+        var parameterizedSig = ClassTypeSig.of(longCharName, TypeArg.of(nestedSig), TypeArg.unbounded());\n+        var parameterizedNestedSig = ClassTypeSig.of(nestedSig, longAsciiName, TypeArg.superOf(simpleClassSig));\n+        return Stream.of(simpleClassSig, nestedSig, typeVarSig, parameterizedSig, parameterizedNestedSig);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"longTypeSignatures\")\n+    void testLongTypeSignature(Signature sig) {\n+        var st = sig.signatureString();\n+        Signature.parseFrom(st); \/\/ Valid signature\n+        assertThrows(IllegalArgumentException.class, () -> SignatureAttribute.of(sig)); \/\/ Cannot write to class\n+    }\n+\n+    static Stream<ClassSignature> longClassSignatures() {\n+        var longAsciiName = \"A\" + \"a\".repeat(65536);\n+        var longCharName = \"§\".repeat(32768);\n+        var simpleClassSig = ClassTypeSig.of(longAsciiName);\n+        var longSuperClass = ClassSignature.of(simpleClassSig);\n+        var longNameParam = TypeParam.of(longCharName, ClassTypeSig.of(CD_String));\n+        var longBoundParam = TypeParam.of(\"T\", simpleClassSig);\n+        var longNameParamClass = ClassSignature.of(List.of(longNameParam), ClassTypeSig.of(CD_Object));\n+        var longBoundParamClass = ClassSignature.of(List.of(longBoundParam), ClassTypeSig.of(CD_Number));\n+        return Stream.of(longSuperClass, longNameParamClass, longBoundParamClass);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"longClassSignatures\")\n+    void testLongClassSignature(ClassSignature sig) {\n+        var st = sig.signatureString();\n+        ClassSignature.parseFrom(st); \/\/ Valid signature\n+        assertThrows(IllegalArgumentException.class, () -> SignatureAttribute.of(sig)); \/\/ Cannot write to class\n+    }\n+\n+    static Stream<MethodSignature> longMethodSignatures() {\n+        var longAsciiName = \"A\" + \"a\".repeat(65536);\n+        var longCharName = \"§\".repeat(32768);\n+        var simpleClassSig = ClassTypeSig.of(longAsciiName);\n+        var longNameTypeVar = TypeVarSig.of(longCharName);\n+        var longReturnMethod = MethodSignature.of(simpleClassSig);\n+        var longNameParam = TypeParam.of(longCharName, ClassTypeSig.of(CD_String));\n+        var longNameParamMethod = MethodSignature.of(List.of(longNameParam), List.of(), BaseTypeSig.of(CD_void));\n+        var longThrowMethod = MethodSignature.of(List.of(), List.of(longNameTypeVar), ClassTypeSig.of(CD_Number));\n+        var longParameterMethod = MethodSignature.of(BaseTypeSig.of(CD_int), simpleClassSig);\n+\n+        var eachParameter = ClassTypeSig.of(\"A\" + \"a\".repeat(250));\n+        var parameterArray = Collections.nCopies(300, eachParameter).toArray(Signature[]::new);\n+        var manyParameterMethod = MethodSignature.of(BaseTypeSig.of(CD_void), parameterArray);\n+        return Stream.of(longReturnMethod, longNameParamMethod, longThrowMethod, longParameterMethod, manyParameterMethod);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"longMethodSignatures\")\n+    void testLongMethodSignature(MethodSignature sig) {\n+        var st = sig.signatureString();\n+        MethodSignature.parseFrom(st); \/\/ Valid signature\n+        assertThrows(IllegalArgumentException.class, () -> SignatureAttribute.of(sig)); \/\/ Cannot write to class\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":190,"deletions":109,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -107,13 +107,0 @@\n-        BufWriterImpl bufWriter = new BufWriterImpl(ConstantPoolBuilder.of(), (ClassFileImpl) ClassFile.of());\n-        Method writeUtfEntry = bufWriter.getClass().getDeclaredMethod(\"writeUtfEntry\", String.class);\n-        writeUtfEntry.setAccessible(true);\n-        try {\n-            writeUtfEntry.invoke(bufWriter, largeString);\n-            throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n-        } catch (InvocationTargetException e) {\n-            Throwable cause = e.getCause();\n-            if (!(cause instanceof IllegalArgumentException)) {\n-                throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n-            }\n-        }\n-\n","filename":"test\/jdk\/jdk\/internal\/util\/ModifiedUtfTest.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"}]}