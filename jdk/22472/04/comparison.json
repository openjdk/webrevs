{"files":[{"patch":"@@ -100,1 +100,1 @@\n-#include \"utilities\/stringUtils.hpp\"\n+#include \"utilities\/nativeStackPrinter.hpp\"\n@@ -102,0 +102,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -4012,8 +4013,3 @@\n-      if (os::platform_print_native_stack(&stack_stream, nullptr, buf, O_BUFLEN, lastpc)) {\n-        \/\/ We have printed the native stack in platform-specific code,\n-        \/\/ so nothing else to do in this case.\n-      } else {\n-        frame f = os::current_frame();\n-        VMError::print_native_stack(&stack_stream, f, current, true \/*print_source_info *\/,\n-                                    -1 \/* max stack_stream *\/, buf, O_BUFLEN);\n-      }\n+      NativeStackPrinter nsp(current);\n+      nsp.print_stack(&stack_stream, buf, sizeof(buf), lastpc,\n+                      true \/* print_source_info *\/, -1 \/* max stack *\/);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1561,0 +1561,33 @@\n+\/**\n+ * Gets the caller frame of `fr` for thread `t`.\n+ *\n+ * @returns an invalid frame (i.e. fr.pc() === 0) if the caller cannot be obtained\n+ *\/\n+frame frame::next_frame(frame fr, Thread* t) {\n+  \/\/ Compiled code may use EBP register on x86 so it looks like\n+  \/\/ non-walkable C frame. Use frame.sender() for java frames.\n+  frame invalid;\n+  if (t != nullptr && t->is_Java_thread()) {\n+    \/\/ Catch very first native frame by using stack address.\n+    \/\/ For JavaThread stack_base and stack_size should be set.\n+    if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n+      return invalid;\n+    }\n+    if (fr.is_interpreted_frame() || (fr.cb() != nullptr && fr.cb()->frame_size() > 0)) {\n+      RegisterMap map(JavaThread::cast(t),\n+                      RegisterMap::UpdateMap::skip,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::skip); \/\/ No update\n+      return fr.sender(&map);\n+    } else {\n+      \/\/ is_first_C_frame() does only simple checks for frame pointer,\n+      \/\/ it will pass if java compiled code has a pointer in EBP.\n+      if (os::is_first_C_frame(&fr)) return invalid;\n+      return os::get_sender_for_C_frame(&fr);\n+    }\n+  } else {\n+    if (os::is_first_C_frame(&fr)) return invalid;\n+    return os::get_sender_for_C_frame(&fr);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -443,0 +443,1 @@\n+  static frame next_frame(frame fr, Thread* t); \/\/ For native stack walking\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+#include \"utilities\/nativeStackPrinter.hpp\"\n@@ -1775,0 +1776,1 @@\n+    NativeStackPrinter nsp(this);\n@@ -1776,8 +1778,2 @@\n-    if (os::platform_print_native_stack(tty, nullptr, buf, O_BUFLEN, lastpc)) {\n-      \/\/ We have printed the native stack in platform-specific code,\n-      \/\/ so nothing else to do in this case.\n-    } else {\n-      frame f = os::current_frame();\n-      VMError::print_native_stack(tty, f, this, true \/*print_source_info *\/,\n-                                  -1 \/* max stack *\/, buf, O_BUFLEN);\n-    }\n+    nsp.print_stack(tty, buf, O_BUFLEN, lastpc,\n+                    true \/*print_source_info *\/, -1 \/* max stack *\/ );\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"utilities\/nativeStackPrinter.hpp\"\n@@ -648,1 +649,0 @@\n-  Thread* t = Thread::current_or_null();\n@@ -651,1 +651,3 @@\n-  VMError::print_native_stack(tty, fr, t, false, -1, buf, sizeof(buf));\n+  NativeStackPrinter nsp(Thread::current_or_null());\n+  nsp.print_stack_from_frame(tty, fr, buf, sizeof(buf),\n+                  false \/* print_source_info *\/, -1 \/* max stack *\/);\n@@ -666,8 +668,3 @@\n-  if (os::platform_print_native_stack(tty, nullptr, buf, sizeof(buf), lastpc)) {\n-    \/\/ We have printed the native stack in platform-specific code,\n-    \/\/ so nothing else to do in this case.\n-  } else {\n-    Thread* t = Thread::current_or_null();\n-    frame fr = os::current_frame();\n-    VMError::print_native_stack(tty, fr, t, false, -1, buf, sizeof(buf));\n-  }\n+  NativeStackPrinter nsp(Thread::current_or_null());\n+  nsp.print_stack(tty, buf, sizeof(buf), lastpc,\n+                  false \/* print_source_info *\/, -1 \/* max stack *\/);\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/decoder.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nativeStackPrinter.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+bool NativeStackPrinter::print_stack(outputStream* st, char* buf, int buf_size,\n+                                     address& lastpc, bool print_source_info,\n+                                     int max_frames) {\n+  if (os::platform_print_native_stack(st, _context, buf, buf_size, lastpc)) {\n+    return true;\n+  } else {\n+    print_stack_from_frame(st, buf, buf_size, print_source_info, max_frames);\n+    return false;\n+  }\n+}\n+\n+void NativeStackPrinter::print_stack_from_frame(outputStream* st, frame fr,\n+                                                char* buf, int buf_size,\n+                                                bool print_source_info, int max_frames) {\n+  \/\/ see if it's a valid frame\n+  if (fr.pc()) {\n+    st->print_cr(\"Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n+    const int limit = max_frames == -1 ? StackPrintLimit\n+                                       : MIN2(max_frames, StackPrintLimit);\n+    int count = 0;\n+    while (count++ < limit) {\n+      fr.print_on_error(st, buf, buf_size);\n+      if (fr.pc()) { \/\/ print source file and line, if available\n+        char filename[128];\n+        int line_no;\n+        if (count == 1 && _lineno != 0) {\n+          \/\/ We have source information for the first frame for internal errors,\n+          \/\/ there is no need to parse it from the symbols.\n+          st->print(\"  (%s:%d)\", _filename, _lineno);\n+        } else if (print_source_info &&\n+                   Decoder::get_source_info(fr.pc(), filename, sizeof(filename), &line_no, count != 1)) {\n+          st->print(\"  (%s:%d)\", filename, line_no);\n+        }\n+      }\n+      st->cr();\n+      fr = frame::next_frame(fr, _current);\n+      if (fr.pc() == nullptr) {\n+        break;\n+      }\n+    }\n+\n+    if (count > limit) {\n+      st->print_cr(\"...<more frames>...\");\n+    }\n+\n+  } else {\n+    st->print_cr(\"Native frames: <unavailable>\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/utilities\/nativeStackPrinter.cpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_UTILITIES_NATIVESTACKPRINTER_HPP\n+#define SHARE_UTILITIES_NATIVESTACKPRINTER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/frame.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Forward declarations\n+class outputStream;\n+class Thread;\n+\n+\/\/ Helper class to do native stack printing from various contexts\n+\/\/ including during crash reporting.\n+\/\/ The NativeStackPrinter is created with the basic context information\n+\/\/ available from the caller. Then the print_stack function is called\n+\/\/ to do the actual printing.\n+class NativeStackPrinter : public StackObj {\n+  Thread* _current;       \/\/ Current thread if known\n+  const void* _context;   \/\/ OS crash context if known\n+  const char* _filename;  \/\/ Source file name if known\n+  int _lineno;            \/\/ Source file line number if known\n+\n+ public:\n+  \/\/ Creates a NativeStackPrinter using the given additional context\n+  \/\/ information:\n+  \/\/ - the current thread is used for frame-based stack walking\n+  \/\/ - context is the crash context from the OS and can be used to get a frame;\n+  \/\/   otherwise os::current_frame() will be used\n+  \/\/ - filename and lineno provide details from the fatal error handler so we\n+  \/\/   can skip use of the Decoder for the first line (optimization)\n+  NativeStackPrinter(Thread* current_or_null,\n+                     const void* context,\n+                     const char* filename,\n+                     int lineno) :\n+    _current(current_or_null),\n+    _context(context),\n+    _filename(filename),\n+    _lineno(lineno) {\n+    assert((_lineno == 0 && _filename == nullptr) ||\n+           (_lineno  > 0 && _filename != nullptr),\n+           \"file name and line number need to be provided together\");\n+  }\n+\n+  NativeStackPrinter(Thread* current_or_null)\n+    : NativeStackPrinter(current_or_null, nullptr, nullptr, 0) {}\n+\n+  \/\/ Prints the stack of the current thread to the given stream.\n+  \/\/ We first try to print via os::platform_print_native_stack. If that\n+  \/\/ succeeds then lastpc is set and we return true. Otherwise we do a\n+  \/\/ frame walk to print the stack, and return false.\n+  \/\/ - st: the stream to print to\n+  \/\/ - buf, buf_size: temporary buffer to use for formatting output\n+  \/\/ - print_source_info: see print_stack_from_frame\n+  \/\/ - max_frames: see print_stack_from_frame\n+  \/\/\n+  bool print_stack(outputStream* st, char* buf, int buf_size,\n+                   address& lastpc, bool print_source_info,\n+                   int max_frames);\n+\n+  \/\/ Prints the stack to st by walking the frames starting from\n+  \/\/ either the context frame, else the current frame.\n+  \/\/ - st: the stream to print to\n+  \/\/ - buf, buf_size: temporary buffer to use when printing frames\n+  \/\/ - print_source_info: if true obtains source information from the Decoder\n+  \/\/                      if available. (Useful but may slow down, timeout or\n+  \/\/                      misfunction in error situations)\n+  \/\/ - max_frames: the maximum number of frames to print. -1 means print all.\n+  \/\/               However, StackPrintLimit sets a hard limit on the maximum.\n+  void print_stack_from_frame(outputStream* st, frame fr,\n+                              char* buf, int buf_size,\n+                              bool print_source_info, int max_frames);\n+\n+  \/\/ Prints the stack to st by walking the frames starting from\n+  \/\/ either the context frame, else the current frame.\n+  void print_stack_from_frame(outputStream* st,\n+                              char* buf, int buf_size,\n+                              bool print_source_info, int max_frames) {\n+      frame fr = _context != nullptr  ? os::fetch_frame_from_context(_context)\n+                                      : os::current_frame();\n+      print_stack_from_frame(st, fr, buf, buf_size, print_source_info, max_frames);\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_NATIVESTACKPRINTER_HPP\n","filename":"src\/hotspot\/share\/utilities\/nativeStackPrinter.hpp","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -70,0 +70,1 @@\n+#include \"utilities\/nativeStackPrinter.hpp\"\n@@ -100,1 +101,1 @@\n-bool              VMError::_print_native_stack_used = false;\n+bool              VMError::_print_stack_from_frame_used = false;\n@@ -421,69 +422,0 @@\n-\/**\n- * Gets the caller frame of `fr`.\n- *\n- * @returns an invalid frame (i.e. fr.pc() === 0) if the caller cannot be obtained\n- *\/\n-static frame next_frame(frame fr, Thread* t) {\n-  \/\/ Compiled code may use EBP register on x86 so it looks like\n-  \/\/ non-walkable C frame. Use frame.sender() for java frames.\n-  frame invalid;\n-  if (t != nullptr && t->is_Java_thread()) {\n-    \/\/ Catch very first native frame by using stack address.\n-    \/\/ For JavaThread stack_base and stack_size should be set.\n-    if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n-      return invalid;\n-    }\n-    if (fr.is_interpreted_frame() || (fr.cb() != nullptr && fr.cb()->frame_size() > 0)) {\n-      RegisterMap map(JavaThread::cast(t),\n-                      RegisterMap::UpdateMap::skip,\n-                      RegisterMap::ProcessFrames::include,\n-                      RegisterMap::WalkContinuation::skip); \/\/ No update\n-      return fr.sender(&map);\n-    } else {\n-      \/\/ is_first_C_frame() does only simple checks for frame pointer,\n-      \/\/ it will pass if java compiled code has a pointer in EBP.\n-      if (os::is_first_C_frame(&fr)) return invalid;\n-      return os::get_sender_for_C_frame(&fr);\n-    }\n-  } else {\n-    if (os::is_first_C_frame(&fr)) return invalid;\n-    return os::get_sender_for_C_frame(&fr);\n-  }\n-}\n-\n-void VMError::print_native_stack(outputStream* st, frame fr, Thread* t, bool print_source_info, int max_frames, char* buf, int buf_size) {\n-\n-  \/\/ see if it's a valid frame\n-  if (fr.pc()) {\n-    st->print_cr(\"Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n-    const int limit = max_frames == -1 ? StackPrintLimit : MIN2(max_frames, StackPrintLimit);\n-    int count = 0;\n-    while (count++ < limit) {\n-      fr.print_on_error(st, buf, buf_size);\n-      if (fr.pc()) { \/\/ print source file and line, if available\n-        char filename[128];\n-        int line_no;\n-        if (count == 1 && _lineno != 0) {\n-          \/\/ We have source information of the first frame for internal errors. There is no need to parse it from the symbols.\n-          st->print(\"  (%s:%d)\", get_filename_only(), _lineno);\n-        } else if (print_source_info &&\n-                   Decoder::get_source_info(fr.pc(), filename, sizeof(filename), &line_no, count != 1)) {\n-          st->print(\"  (%s:%d)\", filename, line_no);\n-        }\n-      }\n-      st->cr();\n-      fr = next_frame(fr, t);\n-      if (fr.pc() == nullptr) {\n-        break;\n-      }\n-    }\n-\n-    if (count > limit) {\n-      st->print_cr(\"...<more frames>...\");\n-    }\n-\n-  } else {\n-    st->print_cr(\"Native frames: <unavailable>\");\n-  }\n-}\n-\n@@ -1011,1 +943,4 @@\n-    if (os::platform_print_native_stack(st, _context, buf, sizeof(buf), lastpc)) {\n+\n+    NativeStackPrinter nsp(_thread, _context, _filename != nullptr ? get_filename_only() : nullptr, _lineno);\n+    if (nsp.print_stack(st, buf, sizeof(buf), lastpc,\n+                        true \/*print_source_info *\/, -1 \/* max stack *\/)) {\n@@ -1022,5 +957,1 @@\n-      frame fr = _context ? os::fetch_frame_from_context(_context)\n-                          : os::current_frame();\n-\n-      print_native_stack(st, fr, _thread, true, -1, buf, sizeof(buf));\n-      _print_native_stack_used = true;\n+      _print_stack_from_frame_used = true; \/\/ frame-based native stack walk done\n@@ -1032,3 +963,4 @@\n-    frame fr = _context ? os::fetch_frame_from_context(_context) : os::current_frame();\n-    print_native_stack(st, fr, _thread, false, -1, buf, sizeof(buf));\n-    _print_native_stack_used = true;\n+    NativeStackPrinter nsp(_thread, _context, get_filename_only(), _lineno);\n+    nsp.print_stack_from_frame(st, buf, sizeof(buf),\n+                               false \/*print_source_info *\/, -1 \/* max stack *\/);\n+    _print_stack_from_frame_used = true;\n@@ -1144,1 +1076,1 @@\n-      if (!_print_native_stack_used) {\n+      if (!_print_stack_from_frame_used) {\n@@ -1157,1 +1089,1 @@\n-          fr = next_frame(fr, _thread);\n+          fr = frame::next_frame(fr, _thread);\n@@ -1789,1 +1721,1 @@\n-            frame fr = context ? os::fetch_frame_from_context(context) : os::current_frame();\n+            NativeStackPrinter nsp(_thread, context, _filename != nullptr ? get_filename_only() : nullptr, _lineno);\n@@ -1794,1 +1726,1 @@\n-            print_native_stack(st, fr, _thread, true, max_stack_size, tmp, sizeof(tmp));\n+            nsp.print_stack_from_frame(st, tmp, sizeof(tmp), true \/* print_source_info *\/, max_stack_size);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":15,"deletions":83,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  \/\/ records if VMError::print_native_stack was used to\n+  \/\/ records if frame-based stack walking was used to\n@@ -56,1 +56,1 @@\n-  static bool        _print_native_stack_used;\n+  static bool        _print_stack_from_frame_used;\n@@ -151,6 +151,0 @@\n-  \/\/ print_source_info: if true, we try to resolve the source information on platforms that support it\n-  \/\/  (useful but may slow down, timeout or misfunction in error situations)\n-  \/\/ max_frames: if not -1, overrides StackPrintLimit\n-  static void print_native_stack(outputStream* st, frame fr, Thread* t, bool print_source_info,\n-                                 int max_frames, char* buf, int buf_size);\n-\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"}]}