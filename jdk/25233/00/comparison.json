{"files":[{"patch":"@@ -4613,0 +4613,44 @@\n+\/\/ This method checks if a wide path is actually a symbolic link\n+static bool is_symbolic_link(const wchar_t* wide_path)\n+{\n+  WIN32_FIND_DATAW fd;\n+  HANDLE f = ::FindFirstFileW(wide_path, &fd);\n+  const bool result = fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT && fd.dwReserved0 == IO_REPARSE_TAG_SYMLINK;\n+  if (0 == ::FindClose(f)) {\n+    errno = ::GetLastError();\n+    return false;\n+  }\n+  return result;\n+}\n+\n+\/\/ This method dereferences a symbolic link\n+static WCHAR* get_path_to_target(const wchar_t* wide_path)\n+{\n+  HANDLE hFile;\n+\n+  hFile = CreateFileW(wide_path, GENERIC_READ, FILE_SHARE_READ, nullptr,\n+    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);\n+\n+  const size_t target_path_size = ::GetFinalPathNameByHandleW(hFile, nullptr, 0,\n+    FILE_NAME_NORMALIZED);\n+\n+  if (target_path_size == 0)\n+  {\n+    errno = ::GetLastError();\n+    return nullptr;\n+  }\n+\n+  WCHAR* path_to_target = NEW_C_HEAP_ARRAY(WCHAR, target_path_size + 1, mtInternal);\n+\n+  ::GetFinalPathNameByHandleW(hFile, path_to_target, static_cast<DWORD>(target_path_size + 1),\n+    FILE_NAME_NORMALIZED);\n+\n+  if (0 == ::CloseHandle(hFile)) {\n+    errno = ::GetLastError();\n+    return nullptr;\n+  }\n+\n+  path_to_target[target_path_size] = '\\0';\n+  return path_to_target;\n+}\n+\n@@ -4681,0 +4725,14 @@\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink)\n+  {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr)\n+    {\n+      \/\/ it is a symbolic link, but we failed to resolve it\n+      errno = err;\n+      return -1;\n+    }\n+  }\n+\n@@ -4682,1 +4740,1 @@\n-  BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &file_data);\n+  BOOL bret = ::GetFileAttributesExW(is_symlink && path_to_target != nullptr ? path_to_target : wide_path, GetFileExInfoStandard, &file_data);\n@@ -4684,0 +4742,1 @@\n+  os::free(path_to_target);\n@@ -4874,1 +4933,16 @@\n-  int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n+\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink)\n+  {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr)\n+    {\n+      \/\/ it is a symbolic link, but we failed to resolve it\n+      errno = err;\n+      return -1;\n+    }\n+  }\n+\n+  int fd = ::_wopen(is_symlink && path_to_target != nullptr ? path_to_target : wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n@@ -4876,0 +4950,1 @@\n+  os::free(path_to_target);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":77,"deletions":2,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary JVM should be able to handle loading class via symlink on windows\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *          jdk.jartool\/sun.tools.jar\n+ * @run driver TestSymlinkLoad\n+ *\/\n+\n+import jdk.test.lib.util.FileUtils;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class TestSymlinkLoad {\n+    public static void main(String args[]) throws Exception {\n+        Path sourceDir = Paths.get(System.getProperty(\"test.src\"), \"test-classes\");\n+        Path classDir = Paths.get(System.getProperty(\"test.classes\"));\n+        Path destDir = classDir;\n+\n+        String subPath = \"compiled\";\n+        destDir = Paths.get(System.getProperty(\"test.classes\"), subPath);\n+\n+        CompilerUtils.compile(sourceDir, destDir);\n+\n+        String bootCP = \"-Xbootclasspath\/a:\" + destDir.toString();\n+\n+        String className = \"Hello\";\n+\n+        \/\/ try to load a class itself directly, i.e. not via a symlink\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                bootCP, className);\n+\n+        \/\/ make sure it runs as expected\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"Hello World\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ create a symlink to the classfile in a subdir with a given name\n+        Path classFile = Path.of(destDir + File.separator + className + \".class\");\n+        final String subdir = \"remote\";\n+        final String pathToFolderForSymlink = destDir + File.separator + subdir + File.separator;\n+        createLinkInSeparateFolder(pathToFolderForSymlink, classFile, className);\n+\n+        \/\/ try to load class via its symlink, which is in a different directory\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                bootCP + File.separator + subdir, className);\n+        output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"Hello World\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ remove the subdir\n+        FileUtils.deleteFileTreeWithRetry(Path.of(pathToFolderForSymlink));\n+    }\n+\n+    public static void createLinkInSeparateFolder( final String pathToFolderForSymlink, final Path target, final String className) throws IOException {\n+        File theDir = new File(pathToFolderForSymlink);\n+        if (!theDir.exists()){\n+            theDir.mkdirs();\n+        }\n+        Path link = Paths.get(pathToFolderForSymlink, className + \".class\");\n+        if (Files.exists(link)) {\n+            Files.delete(link);\n+        }\n+        Files.createSymbolicLink(link, target);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/LoadClass\/TestSymlinkLoad.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"}]}