{"files":[{"patch":"@@ -4613,0 +4613,56 @@\n+\/\/ This method checks if a wide path is actually a symbolic link\n+static bool is_symbolic_link(const wchar_t* wide_path) {\n+  WIN32_FIND_DATAW fd;\n+  HANDLE f = ::FindFirstFileW(wide_path, &fd);\n+  if (f != INVALID_HANDLE_VALUE) {\n+    const bool result = fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT && fd.dwReserved0 == IO_REPARSE_TAG_SYMLINK;\n+    if (::FindClose(f) == 0) {\n+      errno = ::GetLastError();\n+      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%ld.\", errno);\n+    }\n+    return result;\n+  } else {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%ld.\", errno);\n+    return false;\n+  }\n+}\n+\n+\/\/ This method dereferences a symbolic link\n+static WCHAR* get_path_to_target(const wchar_t* wide_path) {\n+  HANDLE hFile = CreateFileW(wide_path, GENERIC_READ, FILE_SHARE_READ, nullptr,\n+                             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);\n+  if (hFile == INVALID_HANDLE_VALUE) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  const size_t target_path_size = ::GetFinalPathNameByHandleW(hFile, nullptr, 0,\n+                                                              FILE_NAME_NORMALIZED);\n+  if (target_path_size == 0) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  WCHAR* path_to_target = NEW_C_HEAP_ARRAY(WCHAR, target_path_size + 1, mtInternal);\n+\n+  const size_t res = ::GetFinalPathNameByHandleW(hFile, path_to_target, static_cast<DWORD>(target_path_size + 1),\n+                                                 FILE_NAME_NORMALIZED);\n+  if (res == 0) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  if (::CloseHandle(hFile) == 0) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  path_to_target[target_path_size] = '\\0';\n+  return path_to_target;\n+}\n+\n@@ -4681,0 +4737,14 @@\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink) {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr) {\n+      \/\/ it is a symbolic link, but we failed to resolve it,\n+      \/\/ errno has been set in the call to get_path_to_target(),\n+      \/\/ no need to overwrite it\n+      os::free(wide_path);\n+      return -1;\n+    }\n+  }\n+\n@@ -4682,2 +4752,1 @@\n-  BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &file_data);\n-  os::free(wide_path);\n+  BOOL bret = ::GetFileAttributesExW(is_symlink ? path_to_target : wide_path, GetFileExInfoStandard, &file_data);\n@@ -4685,0 +4754,1 @@\n+  \/\/ if getting attributes failed, GetLastError should be called immediately after that\n@@ -4687,0 +4757,3 @@\n+    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%ld.\", errno);\n+    os::free(wide_path);\n+    os::free(path_to_target);\n@@ -4690,0 +4763,3 @@\n+  os::free(wide_path);\n+  os::free(path_to_target);\n+\n@@ -4874,2 +4950,0 @@\n-  int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n-  os::free(wide_path);\n@@ -4877,0 +4951,17 @@\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink) {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr) {\n+      \/\/ it is a symbolic link, but we failed to resolve it,\n+      \/\/ errno has been set in the call to get_path_to_target(),\n+      \/\/ no need to overwrite it\n+      os::free(wide_path);\n+      return -1;\n+    }\n+  }\n+\n+  int fd = ::_wopen(is_symlink ? path_to_target : wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n+\n+  \/\/ if opening files failed, GetLastError should be called immediately after that\n@@ -4879,0 +4970,1 @@\n+    log_debug(os)(\"os::open() failed to _wopen: GetLastError->%ld.\", errno);\n@@ -4880,0 +4972,2 @@\n+  os::free(wide_path);\n+  os::free(path_to_target);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":98,"deletions":4,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary JVM should be able to handle loading class via symlink on windows\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *          jdk.jartool\/sun.tools.jar\n+ * @run driver TestSymlinkLoad\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+\n+public class TestSymlinkLoad {\n+    public static void main(String args[]) throws Exception {\n+        Path sourceDir = Paths.get(System.getProperty(\"test.src\"), \"test-classes\");\n+        Path classDir = Paths.get(System.getProperty(\"test.classes\"));\n+        Path destDir = classDir;\n+\n+        String subPath = \"compiled\";\n+        destDir = Paths.get(System.getProperty(\"test.classes\"), subPath);\n+\n+        CompilerUtils.compile(sourceDir, destDir);\n+\n+        String bootCP = \"-Xbootclasspath\/a:\" + destDir.toString();\n+\n+        String className = \"Hello\";\n+\n+        \/\/ try to load a class itself directly, i.e. not via a symlink\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                bootCP, className);\n+\n+        \/\/ make sure it runs as expected\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"Hello World\")\n+              .shouldHaveExitValue(0);\n+\n+        \/\/ create a symlink to the classfile in a subdir with a given name\n+        Path classFile = Path.of(destDir + File.separator + className + \".class\");\n+        final String subdir = \"remote\";\n+        final String pathToFolderForSymlink = destDir + File.separator + subdir + File.separator;\n+        createLinkInSeparateFolder(pathToFolderForSymlink, classFile, className);\n+\n+        \/\/ try to load class via its symlink, which is in a different directory\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                bootCP + File.separator + subdir, className);\n+        output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"Hello World\")\n+              .shouldHaveExitValue(0);\n+\n+        \/\/ remove the subdir\n+        FileUtils.deleteFileTreeWithRetry(Path.of(pathToFolderForSymlink));\n+    }\n+\n+    public static void createLinkInSeparateFolder(final String pathToFolderForSymlink, final Path target, final String className) throws IOException {\n+        File theDir = new File(pathToFolderForSymlink);\n+        if (!theDir.exists()) {\n+            theDir.mkdirs();\n+        }\n+        Path link = Paths.get(pathToFolderForSymlink, className + \".class\");\n+        if (Files.exists(link)) {\n+            Files.delete(link);\n+        }\n+        Files.createSymbolicLink(link, target);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/LoadClass\/TestSymlinkLoad.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}