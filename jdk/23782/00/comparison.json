{"files":[{"patch":"@@ -670,1 +670,0 @@\n-  nonstatic_field(CompilerThread,              _env,                                          ciEnv*)                                \\\n@@ -713,69 +712,0 @@\n-  \/*******************************\/                                                                                                  \\\n-  \/* Runtime1 (NOTE: incomplete) *\/                                                                                                  \\\n-  \/*******************************\/                                                                                                  \\\n-                                                                                                                                     \\\n-  unchecked_c1_static_field(Runtime1,          _blobs,                                 sizeof(Runtime1::_blobs)) \/* NOTE: no type *\/ \\\n-                                                                                                                                     \\\n-  \/**************\/                                                                                                                   \\\n-  \/* CI *\/                                                                                                                           \\\n-  \/************\/                                                                                                                     \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciEnv,                       _compiler_data,                                void*)                                 \\\n-  nonstatic_field(ciEnv,                       _factory,                                      ciObjectFactory*)                      \\\n-  nonstatic_field(ciEnv,                       _dependencies,                                 Dependencies*)                         \\\n-  nonstatic_field(ciEnv,                       _task,                                         CompileTask*)                          \\\n-  nonstatic_field(ciEnv,                       _arena,                                        Arena*)                                \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciBaseObject,                _ident,                                        uint)                                  \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciObject,                    _handle,                                       jobject)                               \\\n-  nonstatic_field(ciObject,                    _klass,                                        ciKlass*)                              \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciMetadata,                  _metadata,                                     Metadata*)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciSymbol,                    _symbol,                                       Symbol*)                               \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciType,                      _basic_type,                                   BasicType)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciKlass,                     _name,                                         ciSymbol*)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciArrayKlass,                _dimension,                                    jint)                                  \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciObjArrayKlass,             _element_klass,                                ciKlass*)                              \\\n-  nonstatic_field(ciObjArrayKlass,             _base_element_klass,                           ciKlass*)                              \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciInstanceKlass,             _init_state,                                   InstanceKlass::ClassState)             \\\n-  nonstatic_field(ciInstanceKlass,             _is_shared,                                    bool)                                  \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciMethod,                    _interpreter_invocation_count,                 int)                                   \\\n-  nonstatic_field(ciMethod,                    _interpreter_throwout_count,                   int)                                   \\\n-  nonstatic_field(ciMethod,                    _inline_instructions_size,                     int)                                   \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciMethodData,                _data_size,                                    int)                                   \\\n-  nonstatic_field(ciMethodData,                _state,                                        u_char)                                \\\n-  nonstatic_field(ciMethodData,                _extra_data_size,                              int)                                   \\\n-  nonstatic_field(ciMethodData,                _data,                                         intptr_t*)                             \\\n-  nonstatic_field(ciMethodData,                _hint_di,                                      int)                                   \\\n-  nonstatic_field(ciMethodData,                _eflags,                                       intx)                                  \\\n-  nonstatic_field(ciMethodData,                _arg_local,                                    intx)                                  \\\n-  nonstatic_field(ciMethodData,                _arg_stack,                                    intx)                                  \\\n-  nonstatic_field(ciMethodData,                _arg_returned,                                 intx)                                  \\\n-  nonstatic_field(ciMethodData,                _orig,                                         MethodData::CompilerCounters)          \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciField,                     _holder,                                       ciInstanceKlass*)                      \\\n-  nonstatic_field(ciField,                     _name,                                         ciSymbol*)                             \\\n-  nonstatic_field(ciField,                     _signature,                                    ciSymbol*)                             \\\n-  nonstatic_field(ciField,                     _offset,                                       int)                                   \\\n-  nonstatic_field(ciField,                     _is_constant,                                  bool)                                  \\\n-  nonstatic_field(ciField,                     _constant_value,                               ciConstant)                            \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciObjectFactory,             _ci_metadata,                                  GrowableArray<ciMetadata*>)            \\\n-  nonstatic_field(ciObjectFactory,             _symbols,                                      GrowableArray<ciSymbol*>)              \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciConstant,                  _type,                                         BasicType)                             \\\n-  nonstatic_field(ciConstant,                  _value._int,                                   jint)                                  \\\n-  nonstatic_field(ciConstant,                  _value._long,                                  jlong)                                 \\\n-  nonstatic_field(ciConstant,                  _value._float,                                 jfloat)                                \\\n-  nonstatic_field(ciConstant,                  _value._double,                                jdouble)                               \\\n-  nonstatic_field(ciConstant,                  _value._object,                                ciObject*)                             \\\n-                                                                                                                                     \\\n@@ -800,4 +730,0 @@\n-  \/*********************\/                                                                                                            \\\n-  \/* Matcher (C2 only) *\/                                                                                                            \\\n-  \/*********************\/                                                                                                            \\\n-                                                                                                                                     \\\n@@ -806,111 +732,0 @@\n-  c2_nonstatic_field(Node,                     _in,                                           Node**)                                \\\n-  c2_nonstatic_field(Node,                     _out,                                          Node**)                                \\\n-  c2_nonstatic_field(Node,                     _cnt,                                          node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _max,                                          node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _outcnt,                                       node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _outmax,                                       node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _idx,                                          const node_idx_t)                      \\\n-  c2_nonstatic_field(Node,                     _class_id,                                     juint)                                 \\\n-  c2_nonstatic_field(Node,                     _flags,                                        juint)                                 \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Compile,                  _root,                                         RootNode*)                             \\\n-  c2_nonstatic_field(Compile,                  _unique,                                       uint)                                  \\\n-  c2_nonstatic_field(Compile,                  _entry_bci,                                    int)                                   \\\n-  c2_nonstatic_field(Compile,                  _top,                                          Node*)                                 \\\n-  c2_nonstatic_field(Compile,                  _cfg,                                          PhaseCFG*)                             \\\n-  c2_nonstatic_field(Compile,                  _regalloc,                                     PhaseRegAlloc*)                        \\\n-  c2_nonstatic_field(Compile,                  _method,                                       ciMethod*)                             \\\n-  c2_nonstatic_field(Compile,                  _compile_id,                                   const int)                             \\\n-  c2_nonstatic_field(Compile,                  _options,                                      const Options)                         \\\n-  c2_nonstatic_field(Compile,                  _ilt,                                          InlineTree*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Options,                  _subsume_loads,                                const bool)                            \\\n-  c2_nonstatic_field(Options,                  _do_escape_analysis,                           const bool)                            \\\n-  c2_nonstatic_field(Options,                  _eliminate_boxing,                             const bool)                            \\\n-  c2_nonstatic_field(Options,                  _do_locks_coarsening,                          const bool)                            \\\n-  c2_nonstatic_field(Options,                  _install_code,                                 const bool)                            \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(InlineTree,               _caller_jvms,                                  JVMState*)                             \\\n-  c2_nonstatic_field(InlineTree,               _method,                                       ciMethod*)                             \\\n-  c2_nonstatic_field(InlineTree,               _caller_tree,                                  InlineTree*)                           \\\n-  c2_nonstatic_field(InlineTree,               _subtrees,                                     GrowableArray<InlineTree*>)            \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(OptoRegPair,              _first,                                        short)                                 \\\n-  c2_nonstatic_field(OptoRegPair,              _second,                                       short)                                 \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(JVMState,                 _caller,                                       JVMState*)                             \\\n-  c2_nonstatic_field(JVMState,                 _depth,                                        uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _locoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _stkoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _monoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _scloff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _endoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _sp,                                           uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _bci,                                          int)                                   \\\n-  c2_nonstatic_field(JVMState,                 _method,                                       ciMethod*)                             \\\n-  c2_nonstatic_field(JVMState,                 _map,                                          SafePointNode*)                        \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(SafePointNode,            _jvms,                                         JVMState* const)                       \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachSafePointNode,        _jvms,                                         JVMState*)                             \\\n-  c2_nonstatic_field(MachSafePointNode,        _jvmadj,                                       uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachIfNode,               _prob,                                         jfloat)                                \\\n-  c2_nonstatic_field(MachIfNode,               _fcnt,                                         jfloat)                                \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachJumpNode,             _probs,                                        jfloat*)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallNode,                 _entry_point,                                  address)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallJavaNode,             _method,                                       ciMethod*)                             \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallRuntimeNode,          _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallStaticJavaNode,       _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachCallJavaNode,         _method,                                       ciMethod*)                             \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachCallStaticJavaNode,   _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachCallRuntimeNode,      _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(PhaseCFG,                 _number_of_blocks,                             uint)                                  \\\n-  c2_nonstatic_field(PhaseCFG,                 _blocks,                                       Block_List)                            \\\n-  c2_nonstatic_field(PhaseCFG,                 _node_to_block_mapping,                        Block_Array)                           \\\n-  c2_nonstatic_field(PhaseCFG,                 _root_block,                                   Block*)                                \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _node_regs,                                    OptoRegPair*)                          \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _node_regs_max_index,                          uint)                                  \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _framesize,                                    uint)                                  \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _max_reg,                                      OptoReg::Name)                         \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(PhaseChaitin,             _trip_cnt,                                     int)                                   \\\n-  c2_nonstatic_field(PhaseChaitin,             _alternate,                                    int)                                   \\\n-  c2_nonstatic_field(PhaseChaitin,             _lo_degree,                                    uint)                                  \\\n-  c2_nonstatic_field(PhaseChaitin,             _lo_stk_degree,                                uint)                                  \\\n-  c2_nonstatic_field(PhaseChaitin,             _hi_degree,                                    uint)                                  \\\n-  c2_nonstatic_field(PhaseChaitin,             _simplified,                                   uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Block,                    _nodes,                                        Node_List)                             \\\n-  c2_nonstatic_field(Block,                    _succs,                                        Block_Array)                           \\\n-  c2_nonstatic_field(Block,                    _num_succs,                                    uint)                                  \\\n-  c2_nonstatic_field(Block,                    _pre_order,                                    uint)                                  \\\n-  c2_nonstatic_field(Block,                    _dom_depth,                                    uint)                                  \\\n-  c2_nonstatic_field(Block,                    _idom,                                         Block*)                                \\\n-  c2_nonstatic_field(Block,                    _freq,                                         jdouble)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CFGElement,               _freq,                                         jdouble)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Block_List,               _cnt,                                          uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Block_Array,              _size,                                         uint)                                  \\\n-  c2_nonstatic_field(Block_Array,              _blocks,                                       Block**)                               \\\n-  c2_nonstatic_field(Block_Array,              _arena,                                        Arena*)                                \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Node_List,                _cnt,                                          uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Node_Array,               _max,                                          uint)                                  \\\n-  c2_nonstatic_field(Node_Array,               _nodes,                                        Node**)                                \\\n-  c2_nonstatic_field(Node_Array,               _a,                                            Arena*)                                \\\n-                                                                                                                                     \\\n-                                                                                                                                     \\\n@@ -1272,0 +1087,1 @@\n+  declare_c2_toplevel_type(Matcher)                                       \\\n@@ -1394,433 +1210,0 @@\n-  \/* Matcher (C2 only) *\/                                                 \\\n-  \/*********************\/                                                 \\\n-                                                                          \\\n-  declare_c2_toplevel_type(Matcher)                                       \\\n-  declare_c2_toplevel_type(Compile)                                       \\\n-  declare_c2_toplevel_type(Options)                                       \\\n-  declare_c2_toplevel_type(InlineTree)                                    \\\n-  declare_c2_toplevel_type(OptoRegPair)                                   \\\n-  declare_c2_toplevel_type(JVMState)                                      \\\n-  declare_c2_toplevel_type(Phase)                                         \\\n-    declare_c2_type(PhaseCFG, Phase)                                      \\\n-    declare_c2_type(PhaseRegAlloc, Phase)                                 \\\n-    declare_c2_type(PhaseChaitin, PhaseRegAlloc)                          \\\n-  declare_c2_toplevel_type(CFGElement)                                    \\\n-    declare_c2_type(Block, CFGElement)                                    \\\n-  declare_c2_toplevel_type(Block_Array)                                   \\\n-    declare_c2_type(Block_List, Block_Array)                              \\\n-  declare_c2_toplevel_type(Node_Array)                                    \\\n-  declare_c2_type(Node_List, Node_Array)                                  \\\n-  declare_c2_type(Unique_Node_List, Node_List)                            \\\n-  declare_c2_toplevel_type(Node)                                          \\\n-  declare_c2_type(AddNode, Node)                                          \\\n-  declare_c2_type(AddINode, AddNode)                                      \\\n-  declare_c2_type(AddLNode, AddNode)                                      \\\n-  declare_c2_type(AddFNode, AddNode)                                      \\\n-  declare_c2_type(AddDNode, AddNode)                                      \\\n-  declare_c2_type(AddPNode, Node)                                         \\\n-  declare_c2_type(OrINode, AddNode)                                       \\\n-  declare_c2_type(OrLNode, AddNode)                                       \\\n-  declare_c2_type(XorINode, AddNode)                                      \\\n-  declare_c2_type(XorLNode, AddNode)                                      \\\n-  declare_c2_type(MaxNode, AddNode)                                       \\\n-  declare_c2_type(MaxINode, MaxNode)                                      \\\n-  declare_c2_type(MinINode, MaxNode)                                      \\\n-  declare_c2_type(MaxLNode, MaxNode)                                      \\\n-  declare_c2_type(MinLNode, MaxNode)                                      \\\n-  declare_c2_type(MaxFNode, MaxNode)                                      \\\n-  declare_c2_type(MinFNode, MaxNode)                                      \\\n-  declare_c2_type(MaxDNode, MaxNode)                                      \\\n-  declare_c2_type(MinDNode, MaxNode)                                      \\\n-  declare_c2_type(StartNode, MultiNode)                                   \\\n-  declare_c2_type(StartOSRNode, StartNode)                                \\\n-  declare_c2_type(ParmNode, ProjNode)                                     \\\n-  declare_c2_type(ReturnNode, Node)                                       \\\n-  declare_c2_type(RethrowNode, Node)                                      \\\n-  declare_c2_type(TailCallNode, ReturnNode)                               \\\n-  declare_c2_type(TailJumpNode, ReturnNode)                               \\\n-  declare_c2_type(ForwardExceptionNode, ReturnNode)                       \\\n-  declare_c2_type(SafePointNode, MultiNode)                               \\\n-  declare_c2_type(CallNode, SafePointNode)                                \\\n-  declare_c2_type(CallJavaNode, CallNode)                                 \\\n-  declare_c2_type(CallStaticJavaNode, CallJavaNode)                       \\\n-  declare_c2_type(CallDynamicJavaNode, CallJavaNode)                      \\\n-  declare_c2_type(CallRuntimeNode, CallNode)                              \\\n-  declare_c2_type(CallLeafNode, CallRuntimeNode)                          \\\n-  declare_c2_type(CallLeafNoFPNode, CallLeafNode)                         \\\n-  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n-  declare_c2_type(AllocateNode, CallNode)                                 \\\n-  declare_c2_type(AllocateArrayNode, AllocateNode)                        \\\n-  declare_c2_type(LockNode, AbstractLockNode)                             \\\n-  declare_c2_type(UnlockNode, AbstractLockNode)                           \\\n-  declare_c2_type(FastLockNode, CmpNode)                                  \\\n-  declare_c2_type(FastUnlockNode, CmpNode)                                \\\n-  declare_c2_type(RegionNode, Node)                                       \\\n-  declare_c2_type(JProjNode, ProjNode)                                    \\\n-  declare_c2_type(PhiNode, TypeNode)                                      \\\n-  declare_c2_type(GotoNode, Node)                                         \\\n-  declare_c2_type(CProjNode, ProjNode)                                    \\\n-  declare_c2_type(MultiBranchNode, MultiNode)                             \\\n-  declare_c2_type(IfNode, MultiBranchNode)                                \\\n-  declare_c2_type(IfTrueNode, CProjNode)                                  \\\n-  declare_c2_type(IfFalseNode, CProjNode)                                 \\\n-  declare_c2_type(PCTableNode, MultiBranchNode)                           \\\n-  declare_c2_type(JumpNode, PCTableNode)                                  \\\n-  declare_c2_type(JumpProjNode, JProjNode)                                \\\n-  declare_c2_type(CatchNode, PCTableNode)                                 \\\n-  declare_c2_type(CatchProjNode, CProjNode)                               \\\n-  declare_c2_type(CreateExNode, TypeNode)                                 \\\n-  declare_c2_type(ClearArrayNode, Node)                                   \\\n-  declare_c2_type(NeverBranchNode, MultiBranchNode)                       \\\n-  declare_c2_type(ConNode, TypeNode)                                      \\\n-  declare_c2_type(ConINode, ConNode)                                      \\\n-  declare_c2_type(ConPNode, ConNode)                                      \\\n-  declare_c2_type(ConNNode, ConNode)                                      \\\n-  declare_c2_type(ConLNode, ConNode)                                      \\\n-  declare_c2_type(ConFNode, ConNode)                                      \\\n-  declare_c2_type(ConDNode, ConNode)                                      \\\n-  declare_c2_type(BinaryNode, Node)                                       \\\n-  declare_c2_type(CMoveNode, TypeNode)                                    \\\n-  declare_c2_type(CMoveDNode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveFNode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveINode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveLNode, CMoveNode)                                  \\\n-  declare_c2_type(CMovePNode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveNNode, CMoveNode)                                  \\\n-  declare_c2_type(EncodePNode, TypeNode)                                  \\\n-  declare_c2_type(DecodeNNode, TypeNode)                                  \\\n-  declare_c2_type(EncodePKlassNode, TypeNode)                             \\\n-  declare_c2_type(DecodeNKlassNode, TypeNode)                             \\\n-  declare_c2_type(ConstraintCastNode, TypeNode)                           \\\n-  declare_c2_type(CastIINode, ConstraintCastNode)                         \\\n-  declare_c2_type(CastPPNode, ConstraintCastNode)                         \\\n-  declare_c2_type(CheckCastPPNode, TypeNode)                              \\\n-  declare_c2_type(Conv2BNode, Node)                                       \\\n-  declare_c2_type(ConvertNode, TypeNode)                                  \\\n-  declare_c2_type(ConvD2FNode, Node)                                      \\\n-  declare_c2_type(ConvD2INode, Node)                                      \\\n-  declare_c2_type(ConvD2LNode, Node)                                      \\\n-  declare_c2_type(ConvF2DNode, Node)                                      \\\n-  declare_c2_type(ConvF2INode, Node)                                      \\\n-  declare_c2_type(ConvF2LNode, Node)                                      \\\n-  declare_c2_type(ConvI2DNode, Node)                                      \\\n-  declare_c2_type(ConvI2FNode, Node)                                      \\\n-  declare_c2_type(ConvI2LNode, TypeNode)                                  \\\n-  declare_c2_type(ConvL2DNode, Node)                                      \\\n-  declare_c2_type(ConvL2FNode, Node)                                      \\\n-  declare_c2_type(ConvL2INode, Node)                                      \\\n-  declare_c2_type(CastX2PNode, Node)                                      \\\n-  declare_c2_type(CastP2XNode, Node)                                      \\\n-  declare_c2_type(MemBarNode, MultiNode)                                  \\\n-  declare_c2_type(MemBarAcquireNode, MemBarNode)                          \\\n-  declare_c2_type(MemBarReleaseNode, MemBarNode)                          \\\n-  declare_c2_type(LoadFenceNode, MemBarNode)                              \\\n-  declare_c2_type(StoreFenceNode, MemBarNode)                             \\\n-  declare_c2_type(MemBarVolatileNode, MemBarNode)                         \\\n-  declare_c2_type(MemBarCPUOrderNode, MemBarNode)                         \\\n-  declare_c2_type(OnSpinWaitNode, MemBarNode)                             \\\n-  declare_c2_type(BlackholeNode, MultiNode)                               \\\n-  declare_c2_type(InitializeNode, MemBarNode)                             \\\n-  declare_c2_type(ThreadLocalNode, Node)                                  \\\n-  declare_c2_type(Opaque1Node, Node)                                      \\\n-  declare_c2_type(PartialSubtypeCheckNode, Node)                          \\\n-  declare_c2_type(MoveI2FNode, Node)                                      \\\n-  declare_c2_type(MoveL2DNode, Node)                                      \\\n-  declare_c2_type(MoveF2INode, Node)                                      \\\n-  declare_c2_type(MoveD2LNode, Node)                                      \\\n-  declare_c2_type(DivINode, Node)                                         \\\n-  declare_c2_type(DivLNode, Node)                                         \\\n-  declare_c2_type(DivFNode, Node)                                         \\\n-  declare_c2_type(DivDNode, Node)                                         \\\n-  declare_c2_type(UDivINode, Node)                                        \\\n-  declare_c2_type(UDivLNode, Node)                                        \\\n-  declare_c2_type(ModINode, Node)                                         \\\n-  declare_c2_type(ModLNode, Node)                                         \\\n-  declare_c2_type(ModFNode, Node)                                         \\\n-  declare_c2_type(ModDNode, Node)                                         \\\n-  declare_c2_type(UModINode, Node)                                        \\\n-  declare_c2_type(UModLNode, Node)                                        \\\n-  declare_c2_type(DivModNode, MultiNode)                                  \\\n-  declare_c2_type(DivModINode, DivModNode)                                \\\n-  declare_c2_type(DivModLNode, DivModNode)                                \\\n-  declare_c2_type(UDivModINode, DivModNode)                               \\\n-  declare_c2_type(UDivModLNode, DivModNode)                               \\\n-  declare_c2_type(BoxLockNode, Node)                                      \\\n-  declare_c2_type(LoopNode, RegionNode)                                   \\\n-  declare_c2_type(CountedLoopNode, LoopNode)                              \\\n-  declare_c2_type(CountedLoopEndNode, IfNode)                             \\\n-  declare_c2_type(MachNode, Node)                                         \\\n-  declare_c2_type(MachIdealNode, MachNode)                                \\\n-  declare_c2_type(MachTypeNode, MachNode)                                 \\\n-  declare_c2_type(MachBreakpointNode, MachIdealNode)                      \\\n-  declare_c2_type(MachUEPNode, MachIdealNode)                             \\\n-  declare_c2_type(MachPrologNode, MachIdealNode)                          \\\n-  declare_c2_type(MachEpilogNode, MachIdealNode)                          \\\n-  declare_c2_type(MachNopNode, MachIdealNode)                             \\\n-  declare_c2_type(MachSpillCopyNode, MachIdealNode)                       \\\n-  declare_c2_type(MachNullCheckNode, MachIdealNode)                       \\\n-  declare_c2_type(MachProjNode, ProjNode)                                 \\\n-  declare_c2_type(MachIfNode, MachNode)                                   \\\n-  declare_c2_type(MachJumpNode, MachNode)                                 \\\n-  declare_c2_type(MachFastLockNode, MachNode)                             \\\n-  declare_c2_type(MachReturnNode, MachNode)                               \\\n-  declare_c2_type(MachSafePointNode, MachReturnNode)                      \\\n-  declare_c2_type(MachCallNode, MachSafePointNode)                        \\\n-  declare_c2_type(MachCallJavaNode, MachCallNode)                         \\\n-  declare_c2_type(MachCallStaticJavaNode, MachCallJavaNode)               \\\n-  declare_c2_type(MachCallDynamicJavaNode, MachCallJavaNode)              \\\n-  declare_c2_type(MachCallRuntimeNode, MachCallNode)                      \\\n-  declare_c2_type(MachHaltNode, MachReturnNode)                           \\\n-  declare_c2_type(MachTempNode, MachNode)                                 \\\n-  declare_c2_type(MemNode, Node)                                          \\\n-  declare_c2_type(MergeMemNode, Node)                                     \\\n-  declare_c2_type(LoadNode, MemNode)                                      \\\n-  declare_c2_type(LoadBNode, LoadNode)                                    \\\n-  declare_c2_type(LoadUSNode, LoadNode)                                   \\\n-  declare_c2_type(LoadINode, LoadNode)                                    \\\n-  declare_c2_type(LoadRangeNode, LoadINode)                               \\\n-  declare_c2_type(LoadLNode, LoadNode)                                    \\\n-  declare_c2_type(LoadL_unalignedNode, LoadLNode)                         \\\n-  declare_c2_type(LoadFNode, LoadNode)                                    \\\n-  declare_c2_type(LoadDNode, LoadNode)                                    \\\n-  declare_c2_type(LoadD_unalignedNode, LoadDNode)                         \\\n-  declare_c2_type(LoadPNode, LoadNode)                                    \\\n-  declare_c2_type(LoadNNode, LoadNode)                                    \\\n-  declare_c2_type(LoadKlassNode, LoadPNode)                               \\\n-  declare_c2_type(LoadNKlassNode, LoadNNode)                              \\\n-  declare_c2_type(LoadSNode, LoadNode)                                    \\\n-  declare_c2_type(StoreNode, MemNode)                                     \\\n-  declare_c2_type(StoreBNode, StoreNode)                                  \\\n-  declare_c2_type(StoreCNode, StoreNode)                                  \\\n-  declare_c2_type(StoreINode, StoreNode)                                  \\\n-  declare_c2_type(StoreLNode, StoreNode)                                  \\\n-  declare_c2_type(StoreFNode, StoreNode)                                  \\\n-  declare_c2_type(StoreDNode, StoreNode)                                  \\\n-  declare_c2_type(StorePNode, StoreNode)                                  \\\n-  declare_c2_type(StoreNNode, StoreNode)                                  \\\n-  declare_c2_type(StoreNKlassNode, StoreNode)                             \\\n-  declare_c2_type(SCMemProjNode, ProjNode)                                \\\n-  declare_c2_type(LoadStoreNode, Node)                                    \\\n-  declare_c2_type(CompareAndSwapNode, LoadStoreConditionalNode)           \\\n-  declare_c2_type(CompareAndSwapBNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapSNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapLNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapINode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapPNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapNNode, CompareAndSwapNode)                \\\n-  declare_c2_type(WeakCompareAndSwapBNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapSNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapLNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapINode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapPNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapNNode, CompareAndSwapNode)            \\\n-  declare_c2_type(CompareAndExchangeNode, LoadStoreNode)                  \\\n-  declare_c2_type(CompareAndExchangeBNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeSNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeLNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeINode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangePNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeNNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(MulNode, Node)                                          \\\n-  declare_c2_type(MulINode, MulNode)                                      \\\n-  declare_c2_type(MulLNode, MulNode)                                      \\\n-  declare_c2_type(MulFNode, MulNode)                                      \\\n-  declare_c2_type(MulDNode, MulNode)                                      \\\n-  declare_c2_type(MulHiLNode, Node)                                       \\\n-  declare_c2_type(UMulHiLNode, Node)                                      \\\n-  declare_c2_type(AndINode, MulINode)                                     \\\n-  declare_c2_type(AndLNode, MulLNode)                                     \\\n-  declare_c2_type(LShiftINode, Node)                                      \\\n-  declare_c2_type(LShiftLNode, Node)                                      \\\n-  declare_c2_type(RShiftINode, Node)                                      \\\n-  declare_c2_type(RShiftLNode, Node)                                      \\\n-  declare_c2_type(URShiftINode, Node)                                     \\\n-  declare_c2_type(URShiftLNode, Node)                                     \\\n-  declare_c2_type(MultiNode, Node)                                        \\\n-  declare_c2_type(ProjNode, Node)                                         \\\n-  declare_c2_type(TypeNode, Node)                                         \\\n-  declare_c2_type(RootNode, LoopNode)                                     \\\n-  declare_c2_type(HaltNode, Node)                                         \\\n-  declare_c2_type(SubNode, Node)                                          \\\n-  declare_c2_type(SubINode, SubNode)                                      \\\n-  declare_c2_type(SubLNode, SubNode)                                      \\\n-  declare_c2_type(SubFPNode, SubNode)                                     \\\n-  declare_c2_type(SubFNode, SubFPNode)                                    \\\n-  declare_c2_type(SubDNode, SubFPNode)                                    \\\n-  declare_c2_type(CmpNode, SubNode)                                       \\\n-  declare_c2_type(CmpINode, CmpNode)                                      \\\n-  declare_c2_type(CmpUNode, CmpNode)                                      \\\n-  declare_c2_type(CmpU3Node, CmpUNode)                                    \\\n-  declare_c2_type(CmpPNode, CmpNode)                                      \\\n-  declare_c2_type(CmpNNode, CmpNode)                                      \\\n-  declare_c2_type(CmpLNode, CmpNode)                                      \\\n-  declare_c2_type(CmpULNode, CmpNode)                                     \\\n-  declare_c2_type(CmpL3Node, CmpLNode)                                    \\\n-  declare_c2_type(CmpUL3Node, CmpULNode)                                  \\\n-  declare_c2_type(CmpFNode, CmpNode)                                      \\\n-  declare_c2_type(CmpF3Node, CmpFNode)                                    \\\n-  declare_c2_type(CmpDNode, CmpNode)                                      \\\n-  declare_c2_type(CmpD3Node, CmpDNode)                                    \\\n-  declare_c2_type(BoolNode, Node)                                         \\\n-  declare_c2_type(AbsNode, Node)                                          \\\n-  declare_c2_type(AbsINode, AbsNode)                                      \\\n-  declare_c2_type(AbsFNode, AbsNode)                                      \\\n-  declare_c2_type(AbsDNode, AbsNode)                                      \\\n-  declare_c2_type(CmpLTMaskNode, Node)                                    \\\n-  declare_c2_type(NegNode, Node)                                          \\\n-  declare_c2_type(NegINode, NegNode)                                      \\\n-  declare_c2_type(NegLNode, NegNode)                                      \\\n-  declare_c2_type(NegFNode, NegNode)                                      \\\n-  declare_c2_type(NegDNode, NegNode)                                      \\\n-  declare_c2_type(AtanDNode, Node)                                        \\\n-  declare_c2_type(SqrtFNode, Node)                                        \\\n-  declare_c2_type(SqrtDNode, Node)                                        \\\n-  declare_c2_type(ReverseBytesINode, Node)                                \\\n-  declare_c2_type(ReverseBytesLNode, Node)                                \\\n-  declare_c2_type(ReductionNode, Node)                                    \\\n-  declare_c2_type(VectorNode, Node)                                       \\\n-  declare_c2_type(AbsVFNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVDNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVBNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVSNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVINode, VectorNode)                                  \\\n-  declare_c2_type(AbsVLNode, VectorNode)                                  \\\n-  declare_c2_type(AddVBNode, VectorNode)                                  \\\n-  declare_c2_type(AddVSNode, VectorNode)                                  \\\n-  declare_c2_type(AddVINode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVINode, ReductionNode)                      \\\n-  declare_c2_type(AddVLNode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVLNode, ReductionNode)                      \\\n-  declare_c2_type(AddVFNode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVFNode, ReductionNode)                      \\\n-  declare_c2_type(AddVDNode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVDNode, ReductionNode)                      \\\n-  declare_c2_type(SubVBNode, VectorNode)                                  \\\n-  declare_c2_type(SubVSNode, VectorNode)                                  \\\n-  declare_c2_type(SubVINode, VectorNode)                                  \\\n-  declare_c2_type(SubVLNode, VectorNode)                                  \\\n-  declare_c2_type(SubVFNode, VectorNode)                                  \\\n-  declare_c2_type(SubVDNode, VectorNode)                                  \\\n-  declare_c2_type(MulVBNode, VectorNode)                                  \\\n-  declare_c2_type(MulVSNode, VectorNode)                                  \\\n-  declare_c2_type(MulVLNode, VectorNode)                                  \\\n-  declare_c2_type(MulReductionVLNode, ReductionNode)                      \\\n-  declare_c2_type(MulVINode, VectorNode)                                  \\\n-  declare_c2_type(MulReductionVINode, ReductionNode)                      \\\n-  declare_c2_type(MulVFNode, VectorNode)                                  \\\n-  declare_c2_type(MulReductionVFNode, ReductionNode)                      \\\n-  declare_c2_type(MulVDNode, VectorNode)                                  \\\n-  declare_c2_type(NegVNode, VectorNode)                                   \\\n-  declare_c2_type(NegVINode, NegVNode)                                    \\\n-  declare_c2_type(NegVLNode, NegVNode)                                    \\\n-  declare_c2_type(NegVFNode, NegVNode)                                    \\\n-  declare_c2_type(NegVDNode, NegVNode)                                    \\\n-  declare_c2_type(FmaVDNode, VectorNode)                                  \\\n-  declare_c2_type(FmaVFNode, VectorNode)                                  \\\n-  declare_c2_type(CompressVNode, VectorNode)                              \\\n-  declare_c2_type(CompressMNode, VectorNode)                              \\\n-  declare_c2_type(ExpandVNode, VectorNode)                                \\\n-  declare_c2_type(CompressBitsVNode, VectorNode)                          \\\n-  declare_c2_type(ExpandBitsVNode, VectorNode)                            \\\n-  declare_c2_type(MulReductionVDNode, ReductionNode)                      \\\n-  declare_c2_type(DivVFNode, VectorNode)                                  \\\n-  declare_c2_type(DivVDNode, VectorNode)                                  \\\n-  declare_c2_type(PopCountVINode, VectorNode)                             \\\n-  declare_c2_type(PopCountVLNode, VectorNode)                             \\\n-  declare_c2_type(LShiftVBNode, VectorNode)                               \\\n-  declare_c2_type(LShiftVSNode, VectorNode)                               \\\n-  declare_c2_type(LShiftVINode, VectorNode)                               \\\n-  declare_c2_type(LShiftVLNode, VectorNode)                               \\\n-  declare_c2_type(RShiftVBNode, VectorNode)                               \\\n-  declare_c2_type(RShiftVSNode, VectorNode)                               \\\n-  declare_c2_type(RShiftVINode, VectorNode)                               \\\n-  declare_c2_type(RShiftVLNode, VectorNode)                               \\\n-  declare_c2_type(URShiftVBNode, VectorNode)                              \\\n-  declare_c2_type(URShiftVSNode, VectorNode)                              \\\n-  declare_c2_type(URShiftVINode, VectorNode)                              \\\n-  declare_c2_type(URShiftVLNode, VectorNode)                              \\\n-  declare_c2_type(MinReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(MaxReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(AndVNode, VectorNode)                                   \\\n-  declare_c2_type(AndReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(OrVNode, VectorNode)                                    \\\n-  declare_c2_type(OrReductionVNode, ReductionNode)                        \\\n-  declare_c2_type(XorVNode, VectorNode)                                   \\\n-  declare_c2_type(XorReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(MaxVNode, VectorNode)                                   \\\n-  declare_c2_type(MinVNode, VectorNode)                                   \\\n-  declare_c2_type(LoadVectorNode, LoadNode)                               \\\n-  declare_c2_type(StoreVectorNode, StoreNode)                             \\\n-  declare_c2_type(ReplicateNode, VectorNode)                              \\\n-  declare_c2_type(PopulateIndexNode, VectorNode)                          \\\n-  declare_c2_type(PackNode, VectorNode)                                   \\\n-  declare_c2_type(PackBNode, PackNode)                                    \\\n-  declare_c2_type(PackSNode, PackNode)                                    \\\n-  declare_c2_type(PackINode, PackNode)                                    \\\n-  declare_c2_type(PackLNode, PackNode)                                    \\\n-  declare_c2_type(PackFNode, PackNode)                                    \\\n-  declare_c2_type(PackDNode, PackNode)                                    \\\n-  declare_c2_type(Pack2LNode, PackNode)                                   \\\n-  declare_c2_type(Pack2DNode, PackNode)                                   \\\n-  declare_c2_type(ExtractNode, Node)                                      \\\n-  declare_c2_type(ExtractBNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractUBNode, ExtractNode)                             \\\n-  declare_c2_type(ExtractCNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractSNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractINode, ExtractNode)                              \\\n-  declare_c2_type(ExtractLNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractFNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractDNode, ExtractNode)                              \\\n-  declare_c2_type(OverflowNode, CmpNode)                                  \\\n-  declare_c2_type(OverflowINode, OverflowNode)                            \\\n-  declare_c2_type(OverflowAddINode, OverflowINode)                        \\\n-  declare_c2_type(OverflowSubINode, OverflowINode)                        \\\n-  declare_c2_type(OverflowMulINode, OverflowINode)                        \\\n-  declare_c2_type(OverflowLNode, OverflowNode)                            \\\n-  declare_c2_type(OverflowAddLNode, OverflowLNode)                        \\\n-  declare_c2_type(OverflowSubLNode, OverflowLNode)                        \\\n-  declare_c2_type(OverflowMulLNode, OverflowLNode)                        \\\n-  declare_c2_type(FmaDNode, Node)                                         \\\n-  declare_c2_type(FmaFNode, Node)                                         \\\n-  declare_c2_type(CopySignDNode, Node)                                    \\\n-  declare_c2_type(CopySignFNode, Node)                                    \\\n-  declare_c2_type(SignumDNode, Node)                                      \\\n-  declare_c2_type(SignumFNode, Node)                                      \\\n-  declare_c2_type(IsInfiniteFNode, Node)                                  \\\n-  declare_c2_type(IsInfiniteDNode, Node)                                  \\\n-  declare_c2_type(IsFiniteFNode, Node)                                    \\\n-  declare_c2_type(IsFiniteDNode, Node)                                    \\\n-  declare_c2_type(LoadVectorGatherNode, LoadVectorNode)                   \\\n-  declare_c2_type(StoreVectorScatterNode, StoreVectorNode)                \\\n-  declare_c2_type(VectorLoadMaskNode, VectorNode)                         \\\n-  declare_c2_type(VectorLoadShuffleNode, VectorNode)                      \\\n-  declare_c2_type(VectorStoreMaskNode, VectorNode)                        \\\n-  declare_c2_type(VectorBlendNode, VectorNode)                            \\\n-  declare_c2_type(VectorRearrangeNode, VectorNode)                        \\\n-  declare_c2_type(VectorMaskWrapperNode, VectorNode)                      \\\n-  declare_c2_type(VectorMaskCmpNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastB2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastS2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastI2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastL2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastF2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastD2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorUCastB2XNode, VectorNode)                         \\\n-  declare_c2_type(VectorUCastS2XNode, VectorNode)                         \\\n-  declare_c2_type(VectorUCastI2XNode, VectorNode)                         \\\n-  declare_c2_type(VectorInsertNode, VectorNode)                           \\\n-  declare_c2_type(VectorUnboxNode, VectorNode)                            \\\n-  declare_c2_type(VectorReinterpretNode, VectorNode)                      \\\n-  declare_c2_type(VectorMaskCastNode, VectorNode)                         \\\n-  declare_c2_type(CountLeadingZerosVNode, VectorNode)                     \\\n-  declare_c2_type(CountTrailingZerosVNode, VectorNode)                    \\\n-  declare_c2_type(ReverseBytesVNode, VectorNode)                          \\\n-  declare_c2_type(ReverseVNode, VectorNode)                               \\\n-  declare_c2_type(MaskAllNode, VectorNode)                                \\\n-  declare_c2_type(AndVMaskNode, VectorNode)                               \\\n-  declare_c2_type(OrVMaskNode, VectorNode)                                \\\n-  declare_c2_type(XorVMaskNode, VectorNode)                               \\\n-  declare_c2_type(VectorBoxNode, Node)                                    \\\n-  declare_c2_type(VectorBoxAllocateNode, CallStaticJavaNode)              \\\n-  declare_c2_type(VectorTestNode, CmpNode)                                \\\n-                                                                          \\\n-  \/*********************\/                                                 \\\n@@ -1832,21 +1215,0 @@\n-  \/*********************\/                                                 \\\n-  \/* CI *\/                                                                \\\n-  \/*********************\/                                                 \\\n-  declare_toplevel_type(ciEnv)                                            \\\n-  declare_toplevel_type(ciObjectFactory)                                  \\\n-  declare_toplevel_type(ciConstant)                                       \\\n-  declare_toplevel_type(ciField)                                          \\\n-  declare_toplevel_type(ciSymbol)                                         \\\n-  declare_toplevel_type(ciBaseObject)                                     \\\n-  declare_type(ciObject, ciBaseObject)                                    \\\n-  declare_type(ciInstance, ciObject)                                      \\\n-  declare_type(ciMetadata, ciBaseObject)                                  \\\n-  declare_type(ciMethod, ciMetadata)                                      \\\n-  declare_type(ciMethodData, ciMetadata)                                  \\\n-  declare_type(ciType, ciMetadata)                                        \\\n-  declare_type(ciKlass, ciType)                                           \\\n-  declare_type(ciInstanceKlass, ciKlass)                                  \\\n-  declare_type(ciArrayKlass, ciKlass)                                     \\\n-  declare_type(ciTypeArrayKlass, ciArrayKlass)                            \\\n-  declare_type(ciObjArrayKlass, ciArrayKlass)                             \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":639,"binary":false,"changes":640,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-<html>\n-<head>\n-<title>\n-Replay\n-<\/title>\n-<\/head>\n-<body>\n-\n-<h1>Compiler replay<\/h1>\n-<p>\n-The compiler replay is a function to repeat the compiling process from a crashed java process in compiled method<br>\n-This function only exists in debug version of VM\n-<\/p>\n-<h2>Usage<\/h2>\n-<pre>\n-First, use SA to attach to the core file, if succeeded, do\n-       hsdb&gt; dumpreplaydata &lt;address&gt; | -a | &lt;thread_id&gt; [&gt; replay.txt]\n-       create file replay.txt, address is address of Method, or nmethod(CodeBlob)\n-       hsdb&gt; buildreplayjars [all | boot | app]\n-       create files:\n-         all:\n-           app.jar, boot.jar\n-         boot:\n-           boot.jar\n-         app:\n-           app.jar\n-       exit SA now.\n-Second, use the obtained replay text file, replay.txt and jar files, app.jar and boot.jar, using debug version of java\n-       java -Xbootclasspath\/p:boot.jar -cp app.jar -XX:ReplayDataFile=&lt;datafile&gt; -XX:+ReplayCompiles ....\n-       This will replay the compiling process.\n-\n-       With ReplayCompiles, the replay will recompile all the methods in app.jar, and in boot.jar to emulate the process in java app.\n-\n-notes:\n-       1) Most time, we don't need the boot.jar which is the classes loaded from JDK. It will be only modified when an agent(JVMDI) is running and modifies the classes.\n-       2) If encounter error as \"&lt;flag&gt;\" not found, that means the SA is using a VMStructs which is different from the one with corefile. In this case, SA has a utility tool vmstructsdump which is located at agent\/src\/os\/&lt;os&gt;\/proc\/&lt;os_platform&gt;\n-\n-       Use this tool to dump VM type library:\n-       vmstructsdump libjvm.so &gt; &lt;type_name&gt;.db\n-\n-       set env SA_TYPEDB=&lt;type_name&gt;.db (refer different shell for set envs)\n","filename":"src\/jdk.hotspot.agent\/doc\/cireplay.html","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -43,6 +43,0 @@\n-<h3>Compilation Replay<\/h3>\n-<p>\n-When a java process crashes in a compiled method, usually a core file is saved.\n-The compiler replay function can reproduce the compiling process in the core.\n-See <a href=\"cireplay.html\">cireplay.html<\/a>\n-\n","filename":"src\/jdk.hotspot.agent\/doc\/index.html","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import sun.jvm.hotspot.ci.ciEnv;\n@@ -69,2 +68,0 @@\n-import sun.jvm.hotspot.opto.Compile;\n-import sun.jvm.hotspot.opto.InlineTree;\n@@ -565,51 +562,0 @@\n-        new Command(\"dumpreplaydata\", \"dumpreplaydata { <address > | -a | <thread_id> }\", false) {\n-            \/\/ This is used to dump replay data from ciInstanceKlass, ciMethodData etc\n-            \/\/ default file name is replay.txt, also if java crashes in compiler\n-            \/\/ thread, this file will be dumped in error processing.\n-            public void doit(Tokens t) {\n-                if (t.countTokens() != 1) {\n-                    usage();\n-                    return;\n-                }\n-                String name = t.nextToken();\n-                Address a = null;\n-                try {\n-                    a = VM.getVM().getDebugger().parseAddress(name);\n-                } catch (NumberFormatException e) { }\n-                if (a != null) {\n-                    \/\/ only nmethod, Method, MethodData and InstanceKlass needed to\n-                    \/\/ dump replay data\n-\n-                    CodeBlob cb = VM.getVM().getCodeCache().findBlob(a);\n-                    if (cb instanceof NMethod nMethod) {\n-                        nMethod.dumpReplayData(out);\n-                        return;\n-                    }\n-                    \/\/ assume it is Metadata\n-                    Metadata meta = Metadata.instantiateWrapperFor(a);\n-                    if (meta != null) {\n-                        meta.dumpReplayData(out);\n-                    } else {\n-                        usage();\n-                        return;\n-                    }\n-                }\n-                \/\/ Not an address\n-                boolean all = name.equals(\"-a\");\n-                Threads threads = VM.getVM().getThreads();\n-                for (int i = 0; i < threads.getNumberOfThreads(); i++) {\n-                    JavaThread thread = threads.getJavaThreadAt(i);\n-                    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-                    thread.printThreadIDOn(new PrintStream(bos));\n-                    if (all || bos.toString().equals(name)) {\n-                        if (thread instanceof CompilerThread) {\n-                            CompilerThread ct = (CompilerThread)thread;\n-                            ciEnv env = ct.env();\n-                            if (env != null) {\n-                               env.dumpReplayData(out);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        },\n@@ -976,88 +922,0 @@\n-        new Command(\"dumpideal\", \"dumpideal { -a | id }\", false) {\n-            \/\/ Do a full dump of the nodes reachable from root in each compiler thread.\n-            public void doit(Tokens t) {\n-                if (t.countTokens() != 1) {\n-                    usage();\n-                } else {\n-                    String name = t.nextToken();\n-                    boolean all = name.equals(\"-a\");\n-                    Threads threads = VM.getVM().getThreads();\n-                    for (int i = 0; i < threads.getNumberOfThreads(); i++) {\n-                        JavaThread thread = threads.getJavaThreadAt(i);\n-                        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-                        thread.printThreadIDOn(new PrintStream(bos));\n-                        if (all || bos.toString().equals(name)) {\n-                          if (thread instanceof CompilerThread) {\n-                            CompilerThread ct = (CompilerThread)thread;\n-                            out.println(ct);\n-                            ciEnv env = ct.env();\n-                            if (env != null) {\n-                              Compile c = env.compilerData();\n-                              c.root().dump(9999, out);\n-                            } else {\n-                              out.println(\"  not compiling\");\n-                            }\n-                          }\n-                        }\n-                    }\n-                }\n-            }\n-        },\n-        new Command(\"dumpcfg\", \"dumpcfg { -a | id }\", false) {\n-            \/\/ Dump the PhaseCFG for every compiler thread that has one live.\n-            public void doit(Tokens t) {\n-                if (t.countTokens() != 1) {\n-                    usage();\n-                } else {\n-                    String name = t.nextToken();\n-                    boolean all = name.equals(\"-a\");\n-                    Threads threads = VM.getVM().getThreads();\n-                    for (int i = 0; i < threads.getNumberOfThreads(); i++) {\n-                        JavaThread thread = threads.getJavaThreadAt(i);\n-                        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-                        thread.printThreadIDOn(new PrintStream(bos));\n-                        if (all || bos.toString().equals(name)) {\n-                          if (thread instanceof CompilerThread) {\n-                            CompilerThread ct = (CompilerThread)thread;\n-                            out.println(ct);\n-                            ciEnv env = ct.env();\n-                            if (env != null) {\n-                              Compile c = env.compilerData();\n-                              c.cfg().dump(out);\n-                            }\n-                          }\n-                        }\n-                    }\n-                }\n-            }\n-        },\n-        new Command(\"dumpilt\", \"dumpilt { -a | id }\", false) {\n-            \/\/ dumps the InlineTree of a C2 compile\n-            public void doit(Tokens t) {\n-                if (t.countTokens() != 1) {\n-                    usage();\n-                } else {\n-                    String name = t.nextToken();\n-                    boolean all = name.equals(\"-a\");\n-                    Threads threads = VM.getVM().getThreads();\n-                    for (int i = 0; i < threads.getNumberOfThreads(); i++) {\n-                        JavaThread thread = threads.getJavaThreadAt(i);\n-                        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-                        thread.printThreadIDOn(new PrintStream(bos));\n-                        if (all || bos.toString().equals(name)) {\n-                            if (thread instanceof CompilerThread) {\n-                                CompilerThread ct = (CompilerThread)thread;\n-                                ciEnv env = ct.env();\n-                                if (env != null) {\n-                                    Compile c = env.compilerData();\n-                                    InlineTree ilt = c.ilt();\n-                                    if (ilt != null) {\n-                                        ilt.print(out);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        },\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":1,"deletions":143,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.c1;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.code.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-\/** Currently a minimal port to get C1 frame traversal working *\/\n-\n-public class Runtime1 {\n-  private static Field         blobsField;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"Runtime1\");\n-\n-    blobsField = type.getField(\"_blobs\");\n-  }\n-\n-  public Runtime1() {\n-  }\n-\n-  \/** FIXME: consider making argument \"type-safe\" in Java port *\/\n-  public Address entryFor(int id) {\n-    return blobFor(id).codeBegin();\n-  }\n-\n-  \/** FIXME: consider making argument \"type-safe\" in Java port *\/\n-  public CodeBlob blobFor(int id) {\n-    Address blobAddr = blobsField.getStaticFieldAddress().getAddressAt(id * VM.getVM().getAddressSize());\n-    return VM.getVM().getCodeCache().createCodeBlobWrapper(blobAddr, blobAddr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/c1\/Runtime1.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciArrayKlass extends ciKlass {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciArrayKlass\");\n-    dimensionField = new IntField(type.getJIntField(\"_dimension\"), 0);\n-  }\n-\n-  private static IntField dimensionField;\n-\n-  public ciArrayKlass(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciArrayKlass.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciBaseObject extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciBaseObject\");\n-    identField = new CIntField(type.getCIntegerField(\"_ident\"), 0);\n-  }\n-\n-  private static CIntField identField;\n-\n-  public ciBaseObject(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpReplayData(PrintStream out) {\n-    out.println(\"# Unknown ci type \" + getAddress().getAddressAt(0));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciBaseObject.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciConstant extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciConstant\");\n-    valueObjectField = type.getAddressField(\"_value._object\");\n-    valueDoubleField = type.getJDoubleField(\"_value._double\");\n-    valueFloatField = type.getJFloatField(\"_value._float\");\n-    valueLongField = type.getJLongField(\"_value._long\");\n-    valueIntField = type.getJIntField(\"_value._int\");\n-    typeField = new CIntField(type.getCIntegerField(\"_type\"), 0);\n-  }\n-\n-  private static AddressField valueObjectField;\n-  private static JDoubleField valueDoubleField;\n-  private static JFloatField valueFloatField;\n-  private static JLongField valueLongField;\n-  private static JIntField valueIntField;\n-  private static CIntField typeField;\n-\n-  public ciConstant(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpReplayData(PrintStream out) {\n-    \/\/ Nothing to be done\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciConstant.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.opto.*;\n-import sun.jvm.hotspot.compiler.CompileTask;\n-import sun.jvm.hotspot.prims.JvmtiExport;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.GrowableArray;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciEnv extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciEnv\");\n-    dependenciesField = type.getAddressField(\"_dependencies\");\n-    factoryField = type.getAddressField(\"_factory\");\n-    compilerDataField = type.getAddressField(\"_compiler_data\");\n-    taskField = type.getAddressField(\"_task\");\n-  }\n-\n-  private static AddressField dependenciesField;\n-  private static AddressField factoryField;\n-  private static AddressField compilerDataField;\n-  private static AddressField taskField;\n-\n-  public ciEnv(Address addr) {\n-    super(addr);\n-  }\n-\n-  public Compile compilerData() {\n-    Address addr = compilerDataField.getValue(this.getAddress());\n-    if (addr == null) {\n-      return null;\n-    }\n-    return new Compile(addr);\n-  }\n-\n-  public ciObjectFactory factory() {\n-    return new ciObjectFactory(factoryField.getValue(this.getAddress()));\n-  }\n-\n-  public CompileTask task() {\n-    return new CompileTask(taskField.getValue(this.getAddress()));\n-  }\n-\n-  public void dumpReplayData(PrintStream out) {\n-    out.println(\"JvmtiExport can_access_local_variables \" +\n-                (JvmtiExport.canAccessLocalVariables() ? '1' : '0'));\n-    out.println(\"JvmtiExport can_hotswap_or_post_breakpoint \" +\n-                (JvmtiExport.canHotswapOrPostBreakpoint() ? '1' : '0'));\n-    out.println(\"JvmtiExport can_post_on_exceptions \" +\n-                (JvmtiExport.canPostOnExceptions() ? '1' : '0'));\n-\n-    GrowableArray<ciMetadata> objects = factory().objects();\n-    out.println(\"# \" + objects.length() + \" ciObject found\");\n-    for (int i = 0; i < objects.length(); i++) {\n-      ciMetadata o = objects.at(i);\n-      out.println(\"# ciMetadata\" + i + \" @ \" + o);\n-      o.dumpReplayData(out);\n-    }\n-    CompileTask task = task();\n-    Method method = task.method();\n-    int entryBci = task.osrBci();\n-    int compLevel = task.compLevel();\n-    out.print(\"compile \" + method.nameAsAscii() + \" \" +\n-              entryBci + \" \" + compLevel);\n-    Compile compiler = compilerData();\n-    if (compiler != null) {\n-      \/\/ Dump inlining data.\n-      compiler.dumpInlineData(out);\n-    }\n-    out.println();\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciEnv.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciField extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciField\");\n-    constantValueField = type.getAddressField(\"_constant_value\");\n-    isConstantField = type.getAddressField(\"_is_constant\");\n-    offsetField = new CIntField(type.getCIntegerField(\"_offset\"), 0);\n-    signatureField = type.getAddressField(\"_signature\");\n-    nameField = type.getAddressField(\"_name\");\n-    holderField = type.getAddressField(\"_holder\");\n-  }\n-\n-  private static AddressField constantValueField;\n-  private static AddressField isConstantField;\n-  private static CIntField offsetField;\n-  private static AddressField signatureField;\n-  private static AddressField nameField;\n-  private static AddressField holderField;\n-\n-  public ciField(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciField.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciInstance extends ciObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciInstance\");\n-  }\n-\n-\n-  public ciInstance(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciInstance.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.memory.SystemDictionary;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.Type;\n-import sun.jvm.hotspot.types.TypeDataBase;\n-import sun.jvm.hotspot.types.WrongTypeException;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciInstanceKlass extends ciKlass {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciInstanceKlass\");\n-    initStateField = new CIntField(type.getCIntegerField(\"_init_state\"), 0);\n-    isSharedField = new CIntField(type.getCIntegerField(\"_is_shared\"), 0);\n-    CLASS_STATE_LINKED = db.lookupIntConstant(\"InstanceKlass::linked\").intValue();\n-    CLASS_STATE_FULLY_INITIALIZED = db.lookupIntConstant(\"InstanceKlass::fully_initialized\").intValue();\n-  }\n-\n-  private static CIntField initStateField;\n-  private static CIntField isSharedField;\n-  private static int CLASS_STATE_LINKED;\n-  private static int CLASS_STATE_FULLY_INITIALIZED;\n-\n-  public ciInstanceKlass(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int initState() {\n-    int initState = (int)initStateField.getValue(getAddress());\n-    if (isShared() && initState < CLASS_STATE_LINKED) {\n-      InstanceKlass ik = (InstanceKlass)getMetadata();\n-      initState = ik.getInitStateAsInt();\n-    }\n-    return initState;\n-  }\n-\n-  public boolean isShared() {\n-    return isSharedField.getValue(getAddress()) != 0;\n-  }\n-\n-  public boolean isLinked() {\n-    return initState() >= CLASS_STATE_LINKED;\n-  }\n-\n-  public boolean isInitialized() {\n-    return initState() == CLASS_STATE_FULLY_INITIALIZED;\n-  }\n-\n-  public void dumpReplayData(PrintStream out) {\n-    InstanceKlass ik = (InstanceKlass)getMetadata();\n-    ConstantPool cp = ik.getConstants();\n-\n-    \/\/ Try to record related loaded classes\n-    Klass sub = ik.getSubklassKlass();\n-    while (sub != null) {\n-      if (sub instanceof InstanceKlass) {\n-        out.println(\"instanceKlass \" + sub.getName().asString());\n-      }\n-      sub = sub.getNextSiblingKlass();\n-    }\n-\n-    final int length = cp.getLength();\n-    out.print(\"ciInstanceKlass \" + name() + \" \" + (isLinked() ? 1 : 0) + \" \" + (isInitialized() ? 1 : 0) + \" \" + length);\n-    for (int index = 1; index < length; index++) {\n-      out.print(\" \" + cp.getTags().at(index));\n-    }\n-    out.println();\n-    if (isInitialized()) {\n-      Field[] staticFields = ik.getStaticFields();\n-      for (int i = 0; i < staticFields.length; i++) {\n-        Field f = staticFields[i];\n-        Oop mirror = ik.getJavaMirror();\n-        if (f.isFinal() && !f.hasInitialValue()) {\n-          out.print(\"staticfield \" + name() + \" \" +\n-                    OopUtilities.escapeString(f.getID().getName()) + \" \" +\n-                    f.getFieldType().getSignature().asString() + \" \");\n-          if (f instanceof ByteField) {\n-            ByteField bf = (ByteField)f;\n-            out.println(bf.getValue(mirror));\n-          } else if (f instanceof BooleanField) {\n-            BooleanField bf = (BooleanField)f;\n-            out.println(bf.getValue(mirror) ? 1 : 0);\n-          } else if (f instanceof ShortField) {\n-            ShortField bf = (ShortField)f;\n-            out.println(bf.getValue(mirror));\n-          } else if (f instanceof CharField) {\n-            CharField bf = (CharField)f;\n-            out.println(bf.getValue(mirror) & 0xffff);\n-          } else if (f instanceof IntField) {\n-            IntField bf = (IntField)f;\n-            out.println(bf.getValue(mirror));\n-          } else  if (f instanceof LongField) {\n-            LongField bf = (LongField)f;\n-            out.println(bf.getValue(mirror));\n-          } else if (f instanceof FloatField) {\n-            FloatField bf = (FloatField)f;\n-            out.println(Float.floatToRawIntBits(bf.getValue(mirror)));\n-          } else if (f instanceof DoubleField) {\n-            DoubleField bf = (DoubleField)f;\n-            out.println(Double.doubleToRawLongBits(bf.getValue(mirror)));\n-          } else if (f instanceof OopField) {\n-            OopField bf = (OopField)f;\n-            Oop value = bf.getValue(mirror);\n-            if (value == null) {\n-              out.println(\"null\");\n-            } else if (value.isInstance()) {\n-              Instance inst = (Instance)value;\n-              if (inst.isA(SystemDictionary.getStringKlass())) {\n-                out.println(\"\\\"\" + OopUtilities.stringOopToEscapedString(inst) + \"\\\"\");\n-              } else {\n-                out.println(inst.getKlass().getName().asString());\n-              }\n-            } else if (value.isObjArray()) {\n-              ObjArray oa = (ObjArray)value;\n-              Klass ek = (ObjArrayKlass)oa.getKlass();\n-              out.println(oa.getLength() + \" \" + ek.getName().asString());\n-            } else if (value.isTypeArray()) {\n-              TypeArray ta = (TypeArray)value;\n-              out.println(ta.getLength());\n-            } else {\n-              out.println(value);\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciInstanceKlass.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciKlass extends ciType {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciKlass\");\n-    nameField = type.getAddressField(\"_name\");\n-  }\n-\n-  private static AddressField nameField;\n-\n-  public String name() {\n-    ciSymbol sym = new ciSymbol(nameField.getValue(getAddress()));\n-    return sym.asUtf88();\n-  }\n-\n-  public ciKlass(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void printValueOn(PrintStream tty) {\n-    Klass k = (Klass)getMetadata();\n-    k.printValueOn(tty);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciKlass.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciMetadata extends ciBaseObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciMetadata\");\n-    metadataField = new MetadataField(type.getAddressField(\"_metadata\"), 0);\n-  }\n-\n-  private static MetadataField metadataField;\n-\n-  public Metadata getMetadata() {\n-    return metadataField.getValue(getAddress());\n-  }\n-\n-  public ciMetadata(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void printOn(PrintStream out) {\n-    getMetadata().printValueOn(out);\n-  }\n-\n-  public String toString() {\n-    return getMetadata().toString();\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciMetadata.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.code.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciMethod extends ciMetadata {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciMethod\");\n-    interpreterThrowoutCountField = new CIntField(type.getCIntegerField(\"_interpreter_throwout_count\"), 0);\n-    interpreterInvocationCountField = new CIntField(type.getCIntegerField(\"_interpreter_invocation_count\"), 0);\n-    try {\n-        \/\/ XXX\n-        instructionsSizeField = new CIntField(type.getCIntegerField(\"_instructions_size\"), 0);\n-    } catch (Exception e) {\n-    }\n-  }\n-\n-  private static CIntField interpreterThrowoutCountField;\n-  private static CIntField interpreterInvocationCountField;\n-  private static CIntField instructionsSizeField;\n-\n-  public ciMethod(Address addr) {\n-    super(addr);\n-  }\n-\n-  public Method method() {\n-    return (Method)getMetadata();\n-  }\n-\n-  public int interpreterThrowoutCount() {\n-    return (int) interpreterThrowoutCountField.getValue(getAddress());\n-  }\n-\n-  public int interpreterInvocationCount() {\n-    return (int) interpreterInvocationCountField.getValue(getAddress());\n-  }\n-\n-  public int instructionsSize() {\n-    if (instructionsSizeField == null) {\n-      \/\/ XXX\n-      Method method = method();\n-      NMethod nm = method.getNativeMethod();\n-      if (nm != null) return (int)nm.codeEnd().minus(nm.getVerifiedEntryPoint());\n-      return 0;\n-    }\n-    return (int) instructionsSizeField.getValue(getAddress());\n-  }\n-\n-  public void printShortName(PrintStream st) {\n-    Method method = method();\n-    st.printf(\" %s::%s\", method.getMethodHolder().getName().asString().replace('\/', '.'),\n-              method.getName().asString());\n-  }\n-\n-  public void dumpReplayData(PrintStream out) {\n-    Method method = (Method)getMetadata();\n-    NMethod nm = method.getNativeMethod();\n-    out.println(\"ciMethod \" +\n-                nameAsAscii() + \" \" +\n-                method.getInvocationCount() + \" \" +\n-                method.getBackedgeCount() + \" \" +\n-                interpreterInvocationCount() + \" \" +\n-                interpreterThrowoutCount() + \" \" +\n-                instructionsSize());\n-  }\n-\n-  public void printValueOn(PrintStream tty) {\n-    tty.print(\"ciMethod \" + method().getName().asString() + method().getSignature().asString() + \"@\" + getAddress());\n-  }\n-\n-  public String nameAsAscii() {\n-    Method method = (Method)getMetadata();\n-    return method.nameAsAscii();\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciMethod.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,361 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.types.Field;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciMethodData extends ciMetadata implements MethodDataInterface<ciKlass,ciMethod> {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciMethodData\");\n-    origField = type.getField(\"_orig\");\n-    argReturnedField = new CIntField(type.getCIntegerField(\"_arg_returned\"), 0);\n-    argStackField = new CIntField(type.getCIntegerField(\"_arg_stack\"), 0);\n-    argLocalField = new CIntField(type.getCIntegerField(\"_arg_local\"), 0);\n-    eflagsField = new CIntField(type.getCIntegerField(\"_eflags\"), 0);\n-    hintDiField = new CIntField(type.getCIntegerField(\"_hint_di\"), 0);\n-    dataField = type.getAddressField(\"_data\");\n-    extraDataSizeField = new CIntField(type.getCIntegerField(\"_extra_data_size\"), 0);\n-    dataSizeField = new CIntField(type.getCIntegerField(\"_data_size\"), 0);\n-    stateField = new CIntField(type.getCIntegerField(\"_state\"), 0);\n-    Type typeMethodData = db.lookupType(\"MethodData\");\n-    sizeofMethodDataOopDesc = (int)typeMethodData.getSize();\n-    parametersTypeDataDi = new CIntField(typeMethodData.getCIntegerField(\"_parameters_type_data_di\"), 0);\n-  }\n-\n-  private static Field origField;\n-  private static CIntField argReturnedField;\n-  private static CIntField argStackField;\n-  private static CIntField argLocalField;\n-  private static CIntField eflagsField;\n-  private static CIntField hintDiField;\n-  private static AddressField dataField;\n-  private static CIntField extraDataSizeField;\n-  private static CIntField dataSizeField;\n-  private static CIntField stateField;\n-  private static int sizeofMethodDataOopDesc;\n-  private static CIntField parametersTypeDataDi;\n-\n-  public ciMethodData(Address addr) {\n-    super(addr);\n-  }\n-\n-  public ciKlass getKlassAtAddress(Address addr) {\n-    return (ciKlass)ciObjectFactory.getMetadata(addr);\n-  }\n-\n-  public ciMethod getMethodAtAddress(Address addr) {\n-    return (ciMethod)ciObjectFactory.getMetadata(addr);\n-  }\n-\n-  public void printKlassValueOn(ciKlass klass, PrintStream st) {\n-    klass.printValueOn(st);\n-  }\n-\n-  public void printMethodValueOn(ciMethod method, PrintStream st) {\n-    method.printValueOn(st);\n-  }\n-\n-  private byte[] fetchDataAt(Address base, long size) {\n-    byte[] result = new byte[(int)size];\n-    for (int i = 0; i < size; i++) {\n-      result[i] = base.getJByteAt(i);\n-    }\n-    return result;\n-  }\n-\n-  public byte[] orig() {\n-    \/\/ fetch the orig MethodData data between header and dataSize\n-    Address base = getAddress().addOffsetTo(origField.getOffset());\n-    byte[] result = new byte[(int)origField.getType().getSize()];\n-    for (int i = 0; i < result.length; i++) {\n-      result[i] = base.getJByteAt(i);\n-    }\n-    return result;\n-  }\n-\n-  public  long[] data() {\n-    \/\/ Read the data as an array of intptr_t elements\n-    Address base = dataField.getValue(getAddress());\n-    int elements = (dataSize() + extraDataSize()) \/ MethodData.cellSize;\n-    long[] result = new long[elements];\n-    for (int i = 0; i < elements; i++) {\n-      Address value = base.getAddressAt(i * MethodData.cellSize);\n-      if (value != null) {\n-        result[i] = value.minus(null);\n-      }\n-    }\n-    return result;\n-  }\n-\n-  int dataSize() {\n-    return (int)dataSizeField.getValue(getAddress());\n-  }\n-\n-  int extraDataSize() {\n-    return (int)extraDataSizeField.getValue(getAddress());\n-  }\n-\n-  int state() {\n-    return (int)stateField.getValue(getAddress());\n-  }\n-\n-  int currentMileage() {\n-    return 0;\n-  }\n-\n-  boolean outOfBounds(int dataIndex) {\n-    return dataIndex >= dataSize();\n-  }\n-\n-  ParametersTypeData<ciKlass,ciMethod> parametersTypeData() {\n-    int di = (int)parametersTypeDataDi.getValue(getMetadata().getAddress());\n-    if (di == -1 || di == -2) {\n-      return null;\n-    }\n-    DataLayout dataLayout = new DataLayout(dataField.getValue(getAddress()), di);\n-    return new ParametersTypeData<ciKlass,ciMethod>(this, dataLayout);\n-  }\n-\n-  ProfileData dataAt(int dataIndex) {\n-    if (outOfBounds(dataIndex)) {\n-      return null;\n-    }\n-    DataLayout dataLayout = new DataLayout(dataField.getValue(getAddress()), dataIndex);\n-\n-    switch (dataLayout.tag()) {\n-    case DataLayout.noTag:\n-    default:\n-      throw new InternalError();\n-    case DataLayout.bitDataTag:\n-      return new BitData(dataLayout);\n-    case DataLayout.counterDataTag:\n-      return new CounterData(dataLayout);\n-    case DataLayout.jumpDataTag:\n-      return new JumpData(dataLayout);\n-    case DataLayout.receiverTypeDataTag:\n-      return new ReceiverTypeData<ciKlass,ciMethod>(this, dataLayout);\n-    case DataLayout.virtualCallDataTag:\n-      return new VirtualCallData<ciKlass,ciMethod>(this, dataLayout);\n-    case DataLayout.retDataTag:\n-      return new RetData(dataLayout);\n-    case DataLayout.branchDataTag:\n-      return new BranchData(dataLayout);\n-    case DataLayout.multiBranchDataTag:\n-      return new MultiBranchData(dataLayout);\n-    case DataLayout.callTypeDataTag:\n-      return new CallTypeData<ciKlass,ciMethod>(this, dataLayout);\n-    case DataLayout.virtualCallTypeDataTag:\n-      return new VirtualCallTypeData<ciKlass,ciMethod>(this, dataLayout);\n-    case DataLayout.parametersTypeDataTag:\n-      return new ParametersTypeData<ciKlass,ciMethod>(this, dataLayout);\n-    }\n-  }\n-\n-  int dpToDi(int dp) {\n-    return dp;\n-  }\n-\n-  int firstDi() { return 0; }\n-  ProfileData firstData() { return dataAt(firstDi()); }\n-  ProfileData nextData(ProfileData current) {\n-    int currentIndex = dpToDi(current.dp());\n-    int nextIndex = currentIndex + current.sizeInBytes();\n-    return dataAt(nextIndex);\n-  }\n-  boolean isValid(ProfileData current) { return current != null; }\n-\n-  DataLayout limitDataPosition() {\n-    return new DataLayout(dataField.getValue(getAddress()), dataSize());\n-  }\n-  DataLayout extraDataBase() {\n-    return limitDataPosition();\n-  }\n-  DataLayout extraDataLimit() {\n-    return new DataLayout(dataField.getValue(getAddress()), dataSize() + extraDataSize());\n-  }\n-  DataLayout nextExtra(DataLayout dataLayout) {\n-    return new DataLayout(dataField.getValue(getAddress()), dataLayout.dp() + DataLayout.computeSizeInBytes(MethodData.extraNbCells(dataLayout)));\n-  }\n-\n-  public void printDataOn(PrintStream st) {\n-    if (parametersTypeData() != null) {\n-      parametersTypeData().printDataOn(st);\n-    }\n-    ProfileData data = firstData();\n-    for ( ; isValid(data); data = nextData(data)) {\n-      st.print(dpToDi(data.dp()));\n-      st.print(\" \");\n-      \/\/ st->fillTo(6);\n-      data.printDataOn(st);\n-    }\n-    st.println(\"--- Extra data:\");\n-    DataLayout dp    = extraDataBase();\n-    DataLayout end   = extraDataLimit();\n-    for (;; dp = nextExtra(dp)) {\n-      switch(dp.tag()) {\n-      case DataLayout.noTag:\n-        continue;\n-      case DataLayout.bitDataTag:\n-        data = new BitData(dp);\n-        break;\n-      case DataLayout.speculativeTrapDataTag:\n-        data = new SpeculativeTrapData<ciKlass,ciMethod>(this, dp);\n-        break;\n-      case DataLayout.argInfoDataTag:\n-        data = new ArgInfoData(dp);\n-        dp = end; \/\/ ArgInfoData is at the end of extra data section.\n-        break;\n-      default:\n-        throw new InternalError(\"unexpected tag \" +  dp.tag());\n-      }\n-      st.print(dpToDi(data.dp()));\n-      st.print(\" \");\n-      data.printDataOn(st);\n-      if (dp == end) return;\n-    }\n-  }\n-\n-  int dumpReplayDataTypeHelper(PrintStream out, int round, int count, int index, ProfileData pdata, ciKlass k) {\n-    if (k != null) {\n-      if (round == 0) count++;\n-      else out.print(\" \" + ((pdata.dp() + pdata.cellOffset(index)) \/ MethodData.cellSize) + \" \" + k.name());\n-    }\n-    return count;\n-  }\n-\n-  int dumpReplayDataReceiverTypeHelper(PrintStream out, int round, int count, ReceiverTypeData<ciKlass,ciMethod> vdata) {\n-    for (int i = 0; i < vdata.rowLimit(); i++) {\n-      ciKlass k = vdata.receiver(i);\n-      count = dumpReplayDataTypeHelper(out, round, count, vdata.receiverCellIndex(i), vdata, k);\n-    }\n-    return count;\n-  }\n-\n-  int dumpReplayDataCallTypeHelper(PrintStream out, int round, int count, CallTypeDataInterface<ciKlass> callTypeData) {\n-    if (callTypeData.hasArguments()) {\n-      for (int i = 0; i < callTypeData.numberOfArguments(); i++) {\n-        count = dumpReplayDataTypeHelper(out, round, count, callTypeData.argumentTypeIndex(i), (ProfileData)callTypeData, callTypeData.argumentType(i));\n-      }\n-    }\n-    if (callTypeData.hasReturn()) {\n-      count = dumpReplayDataTypeHelper(out, round, count, callTypeData.returnTypeIndex(), (ProfileData)callTypeData, callTypeData.returnType());\n-    }\n-    return count;\n-  }\n-\n-  int dumpReplayDataExtraDataHelper(PrintStream out, int round, int count) {\n-    DataLayout dp    = extraDataBase();\n-    DataLayout end   = extraDataLimit();\n-\n-    for (;dp != end; dp = nextExtra(dp)) {\n-      switch(dp.tag()) {\n-      case DataLayout.noTag:\n-      case DataLayout.argInfoDataTag:\n-        return count;\n-      case DataLayout.bitDataTag:\n-        break;\n-      case DataLayout.speculativeTrapDataTag: {\n-        SpeculativeTrapData<ciKlass,ciMethod> data = new SpeculativeTrapData<ciKlass,ciMethod>(this, dp);\n-        ciMethod m = data.method();\n-        if (m != null) {\n-          if (round == 0) {\n-            count++;\n-          } else {\n-            out.print(\" \" +  (dpToDi(data.dp() + data.cellOffset(SpeculativeTrapData.methodIndex())) \/ MethodData.cellSize) + \" \" +  m.nameAsAscii());\n-          }\n-        }\n-        break;\n-      }\n-      default:\n-        throw new InternalError(\"bad tag \"  + dp.tag());\n-      }\n-    }\n-    return count;\n-  }\n-\n-  public void dumpReplayData(PrintStream out) {\n-    MethodData mdo = (MethodData)getMetadata();\n-    Method method = mdo.getMethod();\n-    out.print(\"ciMethodData \" +\n-              method.nameAsAscii() + \" \" +\n-              state() + \" \" + currentMileage());\n-    byte[] orig = orig();\n-    out.print(\" orig \" + orig.length);\n-    for (int i = 0; i < orig.length; i++) {\n-      out.print(\" \" + (orig[i] & 0xff));\n-    }\n-\n-    long[] data = data();\n-    out.print(\" data \" +  data.length);\n-    for (int i = 0; i < data.length; i++) {\n-      out.print(\" 0x\" + Long.toHexString(data[i]));\n-    }\n-    int count = 0;\n-    ParametersTypeData<ciKlass,ciMethod> parameters = parametersTypeData();\n-    for (int round = 0; round < 2; round++) {\n-      if (round == 1) out.print(\" oops \" + count);\n-      ProfileData pdata = firstData();\n-      for ( ; isValid(pdata); pdata = nextData(pdata)) {\n-        if (pdata instanceof ReceiverTypeData) {\n-          @SuppressWarnings(\"unchecked\")\n-          ReceiverTypeData<ciKlass,ciMethod> receiverTypeData = (ReceiverTypeData<ciKlass,ciMethod>)pdata;\n-          count = dumpReplayDataReceiverTypeHelper(out, round, count, receiverTypeData);\n-        }\n-        if (pdata instanceof CallTypeDataInterface) {\n-          @SuppressWarnings(\"unchecked\")\n-          CallTypeDataInterface<ciKlass> callTypeData = (CallTypeDataInterface<ciKlass>)pdata;\n-          count = dumpReplayDataCallTypeHelper(out, round, count, callTypeData);\n-        }\n-      }\n-      if (parameters != null) {\n-        for (int i = 0; i < parameters.numberOfParameters(); i++) {\n-          count = dumpReplayDataTypeHelper(out, round, count, ParametersTypeData.typeIndex(i), parameters, parameters.type(i));\n-        }\n-      }\n-    }\n-    count = 0;\n-    for (int round = 0; round < 2; round++) {\n-      if (round == 1) out.print(\" methods \" + count);\n-      count = dumpReplayDataExtraDataHelper(out, round, count);\n-    }\n-    out.println();\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciMethodData.java","additions":0,"deletions":361,"binary":false,"changes":361,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciObjArrayKlass extends ciArrayKlass {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciObjArrayKlass\");\n-    elementKlassField = type.getAddressField(\"_element_klass\");\n-    baseElementKlassField = type.getAddressField(\"_base_element_klass\");\n-  }\n-\n-  private static AddressField elementKlassField;\n-  private static AddressField baseElementKlassField;\n-\n-  public ciObjArrayKlass(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciObjArrayKlass.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciObject extends ciBaseObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciObject\");\n-    klassField = type.getAddressField(\"_klass\");\n-    handleField = type.getAddressField(\"_handle\");\n-  }\n-\n-  private static AddressField klassField;\n-  private static AddressField handleField;\n-\n-  public Oop getOop() {\n-    OopHandle oh =  handleField.getValue(getAddress()).getOopHandleAt(0);\n-    return VM.getVM().getObjectHeap().newOop(oh);\n-  }\n-\n-  public ciObject(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void printOn(PrintStream out) {\n-    getOop().printValueOn(out);\n-    out.println();\n-  }\n-\n-  public String toString() {\n-    return getOop().toString();\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciObject.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.lang.reflect.Constructor;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciObjectFactory extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciObjectFactory\");\n-    ciMetadataField = type.getAddressField(\"_ci_metadata\");\n-    symbolsField = type.getAddressField(\"_symbols\");\n-\n-    ciObjectConstructor = new VirtualBaseConstructor<ciObject>(db, db.lookupType(\"ciObject\"), \"sun.jvm.hotspot.ci\", ciObject.class);\n-    ciMetadataConstructor = new VirtualBaseConstructor<ciMetadata>(db, db.lookupType(\"ciMetadata\"), \"sun.jvm.hotspot.ci\", ciMetadata.class);\n-    ciSymbolConstructor = new VirtualBaseConstructor<ciSymbol>(db, db.lookupType(\"ciSymbol\"), \"sun.jvm.hotspot.ci\", ciSymbol.class);\n-  }\n-\n-  private static AddressField ciMetadataField;\n-  private static AddressField symbolsField;\n-\n-  private static VirtualBaseConstructor<ciObject> ciObjectConstructor;\n-  private static VirtualBaseConstructor<ciMetadata> ciMetadataConstructor;\n-  private static VirtualBaseConstructor<ciSymbol> ciSymbolConstructor;\n-\n-  public static ciObject get(Address addr) {\n-    if (addr == null) return null;\n-\n-    return ciObjectConstructor.instantiateWrapperFor(addr);\n-  }\n-\n-  public static ciMetadata getMetadata(Address addr) {\n-    if (addr == null) return null;\n-\n-    return ciMetadataConstructor.instantiateWrapperFor(addr);\n-  }\n-\n-  public GrowableArray<ciMetadata> objects() {\n-    Address addr = getAddress().addOffsetTo(ciMetadataField.getOffset());\n-    return GrowableArray.create(addr, ciMetadataConstructor);\n-  }\n-\n-  public GrowableArray<ciSymbol> symbols() {\n-    Address addr = getAddress().addOffsetTo(symbolsField.getOffset());\n-    return GrowableArray.create(addr, ciSymbolConstructor);\n-  }\n-\n-  public ciObjectFactory(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciObjectFactory.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciSymbol extends ciMetadata {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type = db.lookupType(\"ciSymbol\");\n-    symbolField = type.getAddressField(\"_symbol\");\n-  }\n-\n-  private static AddressField symbolField;\n-\n-  public String asUtf88() {\n-    Symbol sym = Symbol.create(symbolField.getValue(getAddress()));\n-    return sym.asString();\n-  }\n-\n-  public ciSymbol(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciSymbol.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciType extends ciMetadata {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciType\");\n-    basicTypeField = new CIntField(type.getCIntegerField(\"_basic_type\"), 0);\n-  }\n-\n-  private static CIntField basicTypeField;\n-\n-  public ciType(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciType.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.ci;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ciTypeArrayKlass extends ciArrayKlass {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ciTypeArrayKlass\");\n-  }\n-\n-  public ciTypeArrayKlass(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ci\/ciTypeArrayKlass.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -492,36 +492,0 @@\n-  public void dumpReplayData(PrintStream out) {\n-    HashMap<Metadata, Metadata> h = new HashMap<>();\n-    for (int i = 1; i < getMetadataLength(); i++) {\n-      Metadata meta = Metadata.instantiateWrapperFor(getMetadataAt(i));\n-      System.err.println(meta);\n-      if (h.get(meta) != null) continue;\n-      h.put(meta, meta);\n-      if (meta instanceof InstanceKlass) {\n-        meta.dumpReplayData(out);\n-      } else if (meta instanceof Method) {\n-        meta.dumpReplayData(out);\n-        MethodData mdo = ((Method)meta).getMethodData();\n-        if (mdo != null) {\n-          mdo.dumpReplayData(out);\n-        }\n-      }\n-    }\n-    Method method = getMethod();\n-    if (h.get(method) == null) {\n-      method.dumpReplayData(out);\n-      MethodData mdo = method.getMethodData();\n-      if (mdo != null) {\n-        mdo.dumpReplayData(out);\n-      }\n-    }\n-    if (h.get(method.getMethodHolder()) == null) {\n-      method.getMethodHolder().dumpReplayData(out);\n-    }\n-    Klass holder = method.getMethodHolder();\n-    out.println(\"compile \" + holder.getName().asString() + \" \" +\n-                OopUtilities.escapeString(method.getName().asString()) + \" \" +\n-                method.getSignature().asString() + \" \" +\n-                getEntryBCI() + \" \" + getCompLevel());\n-\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import sun.jvm.hotspot.opto.*;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/compiler\/CompileTask.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -968,80 +968,0 @@\n-\n-  public void dumpReplayData(PrintStream out) {\n-    ConstantPool cp = getConstants();\n-\n-    \/\/ Try to record related loaded classes\n-    Klass sub = getSubklassKlass();\n-    while (sub != null) {\n-        if (sub instanceof InstanceKlass) {\n-            out.println(\"instanceKlass \" + sub.getName().asString());\n-        }\n-        sub = sub.getNextSiblingKlass();\n-    }\n-\n-    final int length = cp.getLength();\n-    out.print(\"ciInstanceKlass \" + getName().asString() + \" \" + (isLinked() ? 1 : 0) + \" \" + (isInitialized() ? 1 : 0) + \" \" + length);\n-    for (int index = 1; index < length; index++) {\n-      out.print(\" \" + cp.getTags().at(index));\n-    }\n-    out.println();\n-    if (isInitialized()) {\n-      Field[] staticFields = getStaticFields();\n-      for (int i = 0; i < staticFields.length; i++) {\n-        Field f = staticFields[i];\n-        Oop mirror = getJavaMirror();\n-        if (f.isFinal() && !f.hasInitialValue()) {\n-          out.print(\"staticfield \" + getName().asString() + \" \" +\n-                    OopUtilities.escapeString(f.getID().getName()) + \" \" +\n-                    f.getFieldType().getSignature().asString() + \" \");\n-          if (f instanceof ByteField) {\n-            ByteField bf = (ByteField)f;\n-            out.println(bf.getValue(mirror));\n-          } else if (f instanceof BooleanField) {\n-            BooleanField bf = (BooleanField)f;\n-            out.println(bf.getValue(mirror) ? 1 : 0);\n-          } else if (f instanceof ShortField) {\n-            ShortField bf = (ShortField)f;\n-            out.println(bf.getValue(mirror));\n-          } else if (f instanceof CharField) {\n-            CharField bf = (CharField)f;\n-            out.println(bf.getValue(mirror) & 0xffff);\n-          } else if (f instanceof IntField) {\n-            IntField bf = (IntField)f;\n-            out.println(bf.getValue(mirror));\n-          } else  if (f instanceof LongField) {\n-            LongField bf = (LongField)f;\n-            out.println(bf.getValue(mirror));\n-          } else if (f instanceof FloatField) {\n-            FloatField bf = (FloatField)f;\n-            out.println(Float.floatToRawIntBits(bf.getValue(mirror)));\n-          } else if (f instanceof DoubleField) {\n-            DoubleField bf = (DoubleField)f;\n-            out.println(Double.doubleToRawLongBits(bf.getValue(mirror)));\n-          } else if (f instanceof OopField) {\n-            OopField bf = (OopField)f;\n-\n-            Oop value = bf.getValue(mirror);\n-            if (value == null) {\n-              out.println(\"null\");\n-            } else if (value.isInstance()) {\n-              Instance inst = (Instance)value;\n-              if (inst.isA(SystemDictionary.getStringKlass())) {\n-                out.println(\"\\\"\" + OopUtilities.stringOopToEscapedString(inst) + \"\\\"\");\n-              } else {\n-                out.println(inst.getKlass().getName().asString());\n-              }\n-            } else if (value.isObjArray()) {\n-              ObjArray oa = (ObjArray)value;\n-              Klass ek = (ObjArrayKlass)oa.getKlass();\n-              out.println(oa.getLength() + \" \" + ek.getName().asString());\n-            } else if (value.isTypeArray()) {\n-              TypeArray ta = (TypeArray)value;\n-              out.println(ta.getLength());\n-            } else {\n-              out.println(value);\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":1,"deletions":81,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,3 +92,0 @@\n-  public void dumpReplayData(PrintStream out) {\n-      out.println(\"# Unknown Metadata\");\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Metadata.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,16 +351,0 @@\n-  public void dumpReplayData(PrintStream out) {\n-      NMethod nm = getNativeMethod();\n-      int code_size = 0;\n-      if (nm != null) {\n-        code_size = (int)nm.codeEnd().minus(nm.getVerifiedEntryPoint());\n-      }\n-      Klass holder = getMethodHolder();\n-      out.println(\"ciMethod \" +\n-                  nameAsAscii() + \" \" +\n-                  getInvocationCount() + \" \" +\n-                  getBackedgeCount() + \" \" +\n-                  interpreterInvocationCount() + \" \" +\n-                  interpreterThrowoutCount() + \" \" +\n-                  code_size);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -442,107 +442,0 @@\n-  int dumpReplayDataTypeHelper(PrintStream out, int round, int count, int index, ProfileData pdata, Klass k) {\n-    if (k != null) {\n-      if (round == 0) count++;\n-      else out.print(\" \" +\n-                     (dpToDi(pdata.dp() +\n-                             pdata.cellOffset(index)) \/ cellSize) + \" \" +\n-                     k.getName().asString());\n-    }\n-    return count;\n-  }\n-\n-  int dumpReplayDataReceiverTypeHelper(PrintStream out, int round, int count, ReceiverTypeData<Klass,Method> vdata) {\n-    for (int i = 0; i < vdata.rowLimit(); i++) {\n-      Klass k = vdata.receiver(i);\n-      count = dumpReplayDataTypeHelper(out, round, count, vdata.receiverCellIndex(i), vdata, k);\n-    }\n-    return count;\n-  }\n-\n-  int dumpReplayDataCallTypeHelper(PrintStream out, int round, int count, CallTypeDataInterface<Klass> callTypeData) {\n-    if (callTypeData.hasArguments()) {\n-      for (int i = 0; i < callTypeData.numberOfArguments(); i++) {\n-        count = dumpReplayDataTypeHelper(out, round, count, callTypeData.argumentTypeIndex(i), (ProfileData)callTypeData, callTypeData.argumentType(i));\n-      }\n-    }\n-    if (callTypeData.hasReturn()) {\n-      count = dumpReplayDataTypeHelper(out, round, count, callTypeData.returnTypeIndex(), (ProfileData)callTypeData, callTypeData.returnType());\n-    }\n-    return count;\n-  }\n-\n-  int dumpReplayDataExtraDataHelper(PrintStream out, int round, int count) {\n-    DataLayout dp    = extraDataBase();\n-    DataLayout end   = extraDataLimit();\n-\n-    for (;dp != end; dp = nextExtra(dp)) {\n-      switch(dp.tag()) {\n-      case DataLayout.noTag:\n-      case DataLayout.argInfoDataTag:\n-        return count;\n-      case DataLayout.bitDataTag:\n-        break;\n-      case DataLayout.speculativeTrapDataTag: {\n-        SpeculativeTrapData<Klass,Method> data = new SpeculativeTrapData<Klass,Method>(this, dp);\n-        Method m = data.method();\n-        if (m != null) {\n-          if (round == 0) {\n-            count++;\n-          } else {\n-            out.print(\" \" +  (dpToDi(data.dp() + data.cellOffset(SpeculativeTrapData.methodIndex())) \/ cellSize) + \" \" +  m.nameAsAscii());\n-          }\n-        }\n-        break;\n-      }\n-      default:\n-        throw new InternalError(\"bad tag \"  + dp.tag());\n-      }\n-    }\n-    return count;\n-  }\n-\n-  public void dumpReplayData(PrintStream out) {\n-    Method method = getMethod();\n-    out.print(\"ciMethodData \" + method.nameAsAscii()\n-              + \" \" + \"2\" + \" \" +\n-              currentMileage());\n-    byte[] orig = orig();\n-    out.print(\" orig \" + orig.length);\n-    for (int i = 0; i < orig.length; i++) {\n-      out.print(\" \" + (orig[i] & 0xff));\n-    }\n-\n-    long[] data = data();\n-    out.print(\" data \" +  data.length);\n-    for (int i = 0; i < data.length; i++) {\n-      out.print(\" 0x\" + Long.toHexString(data[i]));\n-    }\n-    int count = 0;\n-    ParametersTypeData<Klass,Method> parameters = parametersTypeData();\n-    for (int round = 0; round < 2; round++) {\n-      if (round == 1) out.print(\" oops \" + count);\n-      ProfileData pdata = firstData();\n-      for ( ; isValid(pdata); pdata = nextData(pdata)) {\n-        if (pdata instanceof ReceiverTypeData) {\n-          @SuppressWarnings(\"unchecked\")\n-          ReceiverTypeData<Klass,Method> receiverTypeData = (ReceiverTypeData<Klass,Method>)pdata;\n-          count = dumpReplayDataReceiverTypeHelper(out, round, count, receiverTypeData);\n-        }\n-        if (pdata instanceof CallTypeDataInterface) {\n-          @SuppressWarnings(\"unchecked\")\n-          CallTypeDataInterface<Klass> callTypeData = (CallTypeDataInterface<Klass>)pdata;\n-          count = dumpReplayDataCallTypeHelper(out, round, count, callTypeData);\n-        }\n-      }\n-      if (parameters != null) {\n-        for (int i = 0; i < parameters.numberOfParameters(); i++) {\n-          count = dumpReplayDataTypeHelper(out, round, count, ParametersTypeData.typeIndex(i), parameters, parameters.type(i));\n-        }\n-      }\n-    }\n-    count = 0;\n-    for (int round = 0; round < 2; round++) {\n-      if (round == 1) out.print(\" methods \" + count);\n-      count = dumpReplayDataExtraDataHelper(out, round, count);\n-    }\n-    out.println();\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/MethodData.java","additions":1,"deletions":108,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Block extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"Block\");\n-    nodesField = type.getAddressField(\"_nodes\");\n-    succsField = type.getAddressField(\"_succs\");\n-    numSuccsField = new CIntField(type.getCIntegerField(\"_num_succs\"), 0);\n-    preOrderField = new CIntField(type.getCIntegerField(\"_pre_order\"), 0);\n-    domDepthField = new CIntField(type.getCIntegerField(\"_dom_depth\"), 0);\n-    idomField = type.getAddressField(\"_idom\");\n-    freqField = type.getJDoubleField(\"_freq\");\n-  }\n-\n-  private static AddressField nodesField;\n-  private static AddressField succsField;\n-  private static CIntField numSuccsField;\n-  private static CIntField preOrderField;\n-  private static CIntField domDepthField;\n-  private static AddressField idomField;\n-  private static JDoubleField freqField;\n-\n-  public Block(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int preOrder() {\n-    return (int)preOrderField.getValue(getAddress());\n-  }\n-\n-  public double freq() {\n-    return freqField.getValue(getAddress());\n-  }\n-\n-  public Node_List nodes() {\n-    return new Node_List(getAddress().addOffsetTo(nodesField.getOffset()));\n-  }\n-\n-  public void dump(PrintStream out) {\n-    out.print(\"B\" + preOrder());\n-    out.print(\" Freq: \" + freq());\n-    out.println();\n-    Node_List nl = nodes();\n-    int cnt = nl.size();\n-    for( int i=0; i<cnt; i++ )\n-      nl.at(i).dump(out);\n-    out.print(\"\\n\");\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/Block.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Block_Array extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"Block_Array\");\n-    sizeField = new CIntField(type.getCIntegerField(\"_size\"), 0);\n-    blocksField = type.getAddressField(\"_blocks\");\n-    arenaField = type.getAddressField(\"_arena\");\n-  }\n-\n-  private static CIntField sizeField;\n-  private static AddressField blocksField;\n-  private static AddressField arenaField;\n-\n-  public Block_Array(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int Max() {\n-    return (int) sizeField.getValue(getAddress());\n-  }\n-\n-  public Block at(int i) {\n-    return new Block(blocksField.getValue(getAddress()).getAddressAt(i * (int)VM.getVM().getAddressSize()));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/Block_Array.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Block_List extends Block_Array {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"Block_List\");\n-    cntField = new CIntField(type.getCIntegerField(\"_cnt\"), 0);\n-  }\n-\n-  private static CIntField cntField;\n-\n-  public Block_List(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int size() {\n-    return (int) cntField.getValue(getAddress());\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/Block_List.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class CallDynamicJavaNode extends CallJavaNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"CallDynamicJavaNode\");\n-  }\n-\n-\n-  public CallDynamicJavaNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/CallDynamicJavaNode.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.*;\n-import sun.jvm.hotspot.code.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.ci.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class CallJavaNode extends CallNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"CallJavaNode\");\n-    methodField = type.getAddressField(\"_method\");\n-  }\n-\n-  private static AddressField methodField;\n-\n-  public CallJavaNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public ciMethod method() {\n-    return (ciMethod) ciObjectFactory.getMetadata(methodField.getValue(getAddress()));\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-    if (method() !=  null) {\n-      out.print(\" \" + method().method().externalNameAndSignature());\n-    }\n-    super.dumpSpec(out);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/CallJavaNode.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class CallNode extends SafePointNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"CallNode\");\n-    entryPointField = type.getAddressField(\"_entry_point\");\n-  }\n-\n-  private static AddressField entryPointField;\n-\n-  public Address entryPoint() {\n-    return entryPointField.getValue(getAddress());\n-  }\n-\n-  public CallNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-    out.print(\" \");\n-    \/\/ tf()->dumpOn(st);\n-    \/\/ if (_cnt != countUnknown)  st->print(\" C=%f\",_cnt);\n-    JVMState jvms = jvms();\n-    if (jvms != null)  jvms.dumpSpec(out);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/CallNode.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.utilities.CStringUtilities;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class CallRuntimeNode extends CallNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"CallRuntimeNode\");\n-    nameField    = type.getAddressField(\"_name\");\n-  }\n-\n-  private static AddressField nameField;\n-\n-  public String name() {\n-    return CStringUtilities.getString(nameField.getValue(getAddress()));\n-  }\n-\n-  public CallRuntimeNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-    out.print(\" #\");\n-    out.print(name());\n-    super.dumpSpec(out);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/CallRuntimeNode.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.utilities.CStringUtilities;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class CallStaticJavaNode extends CallJavaNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"CallStaticJavaNode\");\n-    nameField    = type.getAddressField(\"_name\");\n-  }\n-\n-  private static AddressField nameField;\n-\n-  public String name() {\n-    return CStringUtilities.getString(nameField.getValue(getAddress()));\n-  }\n-\n-  public CallStaticJavaNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-    out.print(\" Static \");\n-    String name = name();\n-    if (name != null) {\n-      out.print(name);\n-      \/\/ int trapReq = uncommonTrapRequest();\n-      \/\/ if (trapReq != 0) {\n-      \/\/   char buf[100];\n-      \/\/   st->print(\"(%s)\",\n-      \/\/             Deoptimization::formatTrapRequest(buf, sizeof(buf),\n-      \/\/                                                 trapReq));\n-      \/\/ }\n-      out.print(\" \");\n-    }\n-    super.dumpSpec(out);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/CallStaticJavaNode.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.ci.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Compile extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"Compile\");\n-    rootField = type.getAddressField(\"_root\");\n-    uniqueField = new CIntField(type.getCIntegerField(\"_unique\"), 0);\n-    entryBciField = new CIntField(type.getCIntegerField(\"_entry_bci\"), 0);\n-    topField = type.getAddressField(\"_top\");\n-    cfgField = type.getAddressField(\"_cfg\");\n-    regallocField = type.getAddressField(\"_regalloc\");\n-    methodField = type.getAddressField(\"_method\");\n-    iltField = type.getAddressField(\"_ilt\");\n-  }\n-\n-  private static AddressField rootField;\n-  private static CIntField uniqueField;\n-  private static CIntField entryBciField;\n-  private static AddressField topField;\n-  private static AddressField cfgField;\n-  private static AddressField regallocField;\n-  private static AddressField methodField;\n-  private static AddressField iltField;\n-\n-  public Compile(Address addr) {\n-    super(addr);\n-  }\n-\n-  public Node root() {\n-    return new RootNode(rootField.getValue(this.getAddress()));\n-  }\n-\n-  public int entryBci() {\n-    return (int)entryBciField.getValue(getAddress());\n-  }\n-\n-  public ciMethod method() {\n-    return (ciMethod) ciObjectFactory.getMetadata(methodField.getValue(getAddress()));\n-  }\n-\n-  public PhaseCFG cfg() {\n-    Address a = cfgField.getValue(this.getAddress());\n-    if (a != null) {\n-      return new PhaseCFG(a);\n-    }\n-    return null;\n-  }\n-\n-  public InlineTree ilt() {\n-    Address a = iltField.getValue(this.getAddress());\n-    if (a != null) {\n-      return new InlineTree(a);\n-    }\n-    return null;\n-  }\n-\n-  public void dumpInlineData(PrintStream out) {\n-    InlineTree inlTree = ilt();\n-    if (inlTree != null) {\n-      out.print(\" inline \" + inlTree.count());\n-      inlTree.dumpReplayData(out);\n-    }\n-  }\n-\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/Compile.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-\/\/These definitions should be kept in sync with the definitions in the HotSpot code.\n-\n-public enum CompilerPhaseType {\n-  PHASE_BEFORE_STRINGOPTS (\"Before StringOpts\"),\n-  PHASE_AFTER_STRINGOPTS (\"After StringOpts\"),\n-  PHASE_BEFORE_REMOVEUSELESS (\"Before RemoveUseless\"),\n-  PHASE_AFTER_PARSING (\"After Parsing\"),\n-  PHASE_ITER_GVN1 (\"Iter GVN 1\"),\n-  PHASE_PHASEIDEAL_BEFORE_EA (\"PhaseIdealLoop before EA\"),\n-  PHASE_ITER_GVN_AFTER_EA (\"Iter GVN after EA\"),\n-  PHASE_ITER_GVN_AFTER_ELIMINATION (\"Iter GVN after eliminating allocations and locks\"),\n-  PHASE_PHASEIDEALLOOP1 (\"PhaseIdealLoop 1\"),\n-  PHASE_PHASEIDEALLOOP2 (\"PhaseIdealLoop 2\"),\n-  PHASE_PHASEIDEALLOOP3 (\"PhaseIdealLoop 3\"),\n-  PHASE_CCP1 (\"PhaseCCP 1\"),\n-  PHASE_ITER_GVN2 (\"Iter GVN 2\"),\n-  PHASE_PHASEIDEALLOOP_ITERATIONS (\"PhaseIdealLoop iterations\"),\n-  PHASE_OPTIMIZE_FINISHED (\"Optimize finished\"),\n-  PHASE_GLOBAL_CODE_MOTION (\"Global code motion\"),\n-  PHASE_FINAL_CODE (\"Final Code\"),\n-  PHASE_AFTER_EA (\"After Escape Analysis\"),\n-  PHASE_BEFORE_CLOOPS (\"Before CountedLoop\"),\n-  PHASE_AFTER_CLOOPS (\"After CountedLoop\"),\n-  PHASE_BEFORE_BEAUTIFY_LOOPS (\"Before beautify loops\"),\n-  PHASE_AFTER_BEAUTIFY_LOOPS (\"After beautify loops\"),\n-  PHASE_BEFORE_MATCHING (\"Before Matching\"),\n-  PHASE_INCREMENTAL_INLINE (\"Incremental Inline\"),\n-  PHASE_INCREMENTAL_BOXING_INLINE (\"Incremental Boxing Inline\"),\n-  PHASE_END (\"End\"),\n-  PHASE_FAILURE (\"Failure\"),\n-  PHASE_NUM_TYPES (\"Number of Phase Types\");\n-\n-  private final String value;\n-\n-  CompilerPhaseType(String val) {\n-    this.value = val;\n-  }\n-  public String value() {\n-    return value;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/CompilerPhaseType.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class HaltNode extends Node {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"HaltNode\");\n-  }\n-\n-\n-  public HaltNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/HaltNode.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.ci.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.utilities.GrowableArray;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class InlineTree extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"InlineTree\");\n-    callerJvmsField = type.getAddressField(\"_caller_jvms\");\n-    methodField = type.getAddressField(\"_method\");\n-    callerTreeField = type.getAddressField(\"_caller_tree\");\n-    subtreesField = type.getAddressField(\"_subtrees\");\n-  }\n-\n-  private static AddressField callerJvmsField;\n-  private static AddressField methodField;\n-  private static AddressField callerTreeField;\n-  private static AddressField subtreesField;\n-\n-  private static StaticBaseConstructor<InlineTree> inlineTreeConstructor = new StaticBaseConstructor<>(InlineTree.class);\n-\n-  public InlineTree(Address addr) {\n-    super(addr);\n-  }\n-\n-  public InlineTree callerTree() {\n-    Address addr = callerTreeField.getValue(getAddress());\n-    if (addr == null) return null;\n-\n-    return new InlineTree(addr);\n-  }\n-\n-  public ciMethod method() {\n-    return (ciMethod) ciObjectFactory.getMetadata(methodField.getValue(getAddress()));\n-  }\n-\n-  public JVMState callerJvms() {\n-    return JVMState.create(callerJvmsField.getValue(getAddress()));\n-  }\n-\n-  public int callerBci() {\n-    JVMState jvms = callerJvms();\n-    return (jvms != null) ? jvms.bci() : -1;\n-  }\n-\n-  public GrowableArray<InlineTree> subtrees() {\n-    Address addr = getAddress().addOffsetTo(subtreesField.getOffset());\n-\n-    return GrowableArray.create(addr, inlineTreeConstructor);\n-  }\n-\n-  public int inlineLevel() {\n-    JVMState jvms = callerJvms();\n-    return (jvms != null) ? jvms.depth() : 0;\n-  }\n-\n-  public void printImpl(PrintStream st, int indent) {\n-    for (int i = 0; i < indent; i++) st.print(\" \");\n-    st.printf(\" @ %d \", callerBci());\n-    method().printShortName(st);\n-    st.println();\n-\n-    GrowableArray<InlineTree> subt = subtrees();\n-    for (int i = 0 ; i < subt.length(); i++) {\n-      subt.at(i).printImpl(st, indent + 2);\n-    }\n-  }\n-  public void print(PrintStream st) {\n-    printImpl(st, 2);\n-  }\n-\n-  \/\/ Count number of nodes in this subtree\n-  public int count() {\n-    int result = 1;\n-    GrowableArray<InlineTree> subt = subtrees();\n-    for (int i = 0 ; i < subt.length(); i++) {\n-      result += subt.at(i).count();\n-    }\n-    return result;\n-  }\n-\n-  public void dumpReplayData(PrintStream out) {\n-    out.printf(\" %d %d \", inlineLevel(), callerBci());\n-    Method method = (Method)method().getMetadata();\n-    Klass holder = method.getMethodHolder();\n-    out.print(holder.getName().asString() + \" \" +\n-              OopUtilities.escapeString(method.getName().asString()) + \" \" +\n-              method.getSignature().asString());\n-\n-    GrowableArray<InlineTree> subt = subtrees();\n-    for (int i = 0 ; i < subt.length(); i++) {\n-      subt.at(i).dumpReplayData(out);\n-    }\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/InlineTree.java","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.ci.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class JVMState extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"JVMState\");\n-    mapField = type.getAddressField(\"_map\");\n-    methodField = type.getAddressField(\"_method\");\n-    bciField = new CIntField(type.getCIntegerField(\"_bci\"), 0);\n-    spField = new CIntField(type.getCIntegerField(\"_sp\"), 0);\n-    endoffField = new CIntField(type.getCIntegerField(\"_endoff\"), 0);\n-    try {\n-        scloffField = new CIntField(type.getCIntegerField(\"_scloff\"), 0);\n-    } catch (Exception e) {\n-    }\n-    monoffField = new CIntField(type.getCIntegerField(\"_monoff\"), 0);\n-    stkoffField = new CIntField(type.getCIntegerField(\"_stkoff\"), 0);\n-    locoffField = new CIntField(type.getCIntegerField(\"_locoff\"), 0);\n-    depthField = new CIntField(type.getCIntegerField(\"_depth\"), 0);\n-    callerField = type.getAddressField(\"_caller\");\n-  }\n-\n-  private static AddressField mapField;\n-  private static AddressField methodField;\n-  private static CIntField bciField;\n-  private static CIntField spField;\n-  private static CIntField endoffField;\n-  private static CIntField scloffField;\n-  private static CIntField monoffField;\n-  private static CIntField stkoffField;\n-  private static CIntField locoffField;\n-  private static CIntField depthField;\n-  private static AddressField callerField;\n-\n-  public static JVMState create(Address addr) {\n-    if (addr == null) return null;\n-    return new JVMState(addr);\n-  }\n-\n-  public JVMState(Address addr) {\n-    super(addr);\n-  }\n-\n-  public ciMethod method() {\n-    return (ciMethod) ciObjectFactory.getMetadata(methodField.getValue(getAddress()));\n-  }\n-\n-  public int bci() {\n-    return (int)bciField.getValue(getAddress());\n-  }\n-\n-  public int depth() {\n-    return (int)depthField.getValue(getAddress());\n-  }\n-\n-  public JVMState caller() {\n-    return create(callerField.getValue(getAddress()));\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-    ciMethod m = method();\n-    if (m != null) {\n-      Method meth = m.method();\n-      out.print(\" \" + meth.getMethodHolder().getName().asString().replace('\/', '.') + \"::\" +\n-                meth.getName().asString() + \" @ bci:\" + bci());\n-    } else {\n-      out.print(\" runtime stub\");\n-    }\n-    if (caller() != null)  caller().dumpSpec(out);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/JVMState.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class LoopNode extends RegionNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"LoopNode\");\n-  }\n-\n-\n-  public LoopNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/LoopNode.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.ci.ciMethod;\n-import sun.jvm.hotspot.ci.ciObjectFactory;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class MachCallJavaNode extends MachCallNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"MachCallJavaNode\");\n-    methodField = type.getAddressField(\"_method\");\n-    bciField = new CIntField(type.getCIntegerField(\"_bci\"), 0);\n-  }\n-\n-  private static AddressField methodField;\n-  private static CIntField bciField;\n-\n-  public ciMethod method() {\n-    return (ciMethod) ciObjectFactory.getMetadata(methodField.getValue(getAddress()));\n-  }\n-\n-  public MachCallJavaNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpSpec(PrintStream st) {\n-    ciMethod m = method();\n-    if (m != null) {\n-      m.printShortName(st);\n-      st.print(\" \");\n-    }\n-    super.dumpSpec(st);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/MachCallJavaNode.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class MachCallNode extends MachSafePointNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"MachCallNode\");\n-  }\n-\n-  public MachCallNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpSpec(PrintStream st) {\n-      st.print(\"# \");\n-      \/\/ tf()->dump_on(st);\n-      \/\/ if (_cnt != COUNT_UNKNOWN)  st->print(\" C=%f\",_cnt);\n-      if (jvms() != null)  jvms().dumpSpec(st);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/MachCallNode.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.CStringUtilities;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class MachCallRuntimeNode extends MachCallJavaNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"MachCallRuntimeNode\");\n-    nameField    = type.getAddressField(\"_name\");\n-  }\n-\n-  private static AddressField nameField;\n-\n-  public String name() {\n-    return CStringUtilities.getString(nameField.getValue(getAddress()));\n-  }\n-\n-  public MachCallRuntimeNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-    out.printf(\"%s \", name());\n-    super.dumpSpec(out);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/MachCallRuntimeNode.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.CStringUtilities;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class MachCallStaticJavaNode extends MachCallJavaNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"MachCallStaticJavaNode\");\n-    nameField    = type.getAddressField(\"_name\");\n-  }\n-\n-  private static AddressField nameField;\n-\n-  public String name() {\n-    return CStringUtilities.getString(nameField.getValue(getAddress()));\n-  }\n-\n-  public MachCallStaticJavaNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpSpec(PrintStream st) {\n-    st.print(\"Static \");\n-    String n = name();\n-    if (n != null) {\n-      st.printf(\"wrapper for: %s\", n);\n-      \/\/ dump_trap_args(st);\n-      st.print(\" \");\n-    }\n-    super.dumpSpec(st);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/MachCallStaticJavaNode.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class MachIfNode extends MachNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"MachIfNode\");\n-    probField = type.getJFloatField(\"_prob\");\n-    fcntField = type.getJFloatField(\"_fcnt\");\n-  }\n-\n-  private static JFloatField probField;\n-  private static JFloatField fcntField;\n-\n-  float prob() {\n-    return probField.getValue(getAddress());\n-  }\n-\n-  float cnt() {\n-    return fcntField.getValue(getAddress());\n-  }\n-\n-  public MachIfNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-    out.print(\"P=\" + prob() + \", C=\" + cnt());\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/MachIfNode.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class MachNode extends Node {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"MachNode\");\n-  }\n-\n-  public MachNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/MachNode.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class MachReturnNode extends MachNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"MachReturnNode\");\n-  }\n-\n-  public MachReturnNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/MachReturnNode.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class MachSafePointNode extends MachReturnNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"MachSafePointNode\");\n-    jvmsField = type.getAddressField(\"_jvms\");\n-    jvmadjField = new CIntField(type.getCIntegerField(\"_jvmadj\"), 0);\n-  }\n-\n-  private static AddressField jvmsField;\n-  private static CIntField jvmadjField;\n-\n-  public MachSafePointNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public JVMState jvms() {\n-    return JVMState.create(jvmsField.getValue(getAddress()));\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-    try {\n-      JVMState jvms = jvms();\n-      if (jvms != null) out.print(\" !\");\n-      if (jvms == null) out.print(\"empty jvms\");\n-      while (jvms != null) {\n-        Method m = jvms.method().method();\n-        int bci = jvms.bci();\n-        out.print(\" \" + m.getMethodHolder().getName().asString().replace('\/', '.') + \"::\" + m.getName().asString() + \" @ bci:\" + bci);\n-        jvms = jvms.caller();\n-      }\n-    } catch (Exception e) {\n-      out.print(e);\n-    }\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/MachSafePointNode.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class MultiNode extends Node {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"MultiNode\");\n-  }\n-\n-\n-  public MultiNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/MultiNode.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,271 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.io.*;\n-import java.lang.reflect.Constructor;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Node extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"Node\");\n-    outmaxField = new CIntField(type.getCIntegerField(\"_outmax\"), 0);\n-    outcntField = new CIntField(type.getCIntegerField(\"_outcnt\"), 0);\n-    maxField = new CIntField(type.getCIntegerField(\"_max\"), 0);\n-    cntField = new CIntField(type.getCIntegerField(\"_cnt\"), 0);\n-    idxField = new CIntField(type.getCIntegerField(\"_idx\"), 0);\n-    outField = type.getAddressField(\"_out\");\n-    inField = type.getAddressField(\"_in\");\n-\n-    nodeType = db.lookupType(\"Node\");\n-\n-    virtualConstructor = new VirtualBaseConstructor<>(db, nodeType, \"sun.jvm.hotspot.opto\", Node.class);\n-  }\n-\n-  private static CIntField outmaxField;\n-  private static CIntField outcntField;\n-  private static CIntField maxField;\n-  private static CIntField cntField;\n-  private static CIntField idxField;\n-  private static AddressField outField;\n-  private static AddressField inField;\n-\n-  private static VirtualBaseConstructor<Node> virtualConstructor;\n-\n-  private static Type nodeType;\n-\n-  static HashMap<Address, Node> nodes = new HashMap<>();\n-\n-  static HashMap constructors = new HashMap();\n-\n-  abstract static class Instantiator {\n-    abstract Node create(Address addr);\n-  }\n-\n-  public static Node create(Address addr) {\n-    if (addr == null) return null;\n-    Node result = nodes.get(addr);\n-    if (result == null) {\n-      result = virtualConstructor.instantiateWrapperFor(addr);\n-      nodes.put(addr, result);\n-    }\n-    return result;\n-  }\n-\n-  public Node(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int outcnt() {\n-    return (int)outcntField.getValue(this.getAddress());\n-  }\n-\n-  public int req() {\n-    return (int)cntField.getValue(this.getAddress());\n-  }\n-\n-  public int len() {\n-    return (int)maxField.getValue(this.getAddress());\n-  }\n-\n-  public int idx() {\n-    return (int)idxField.getValue(this.getAddress());\n-  }\n-\n-  private Node[] _out;\n-  private Node[] _in;\n-\n-  public Node rawOut(int i) {\n-    if (_out == null) {\n-      int addressSize = (int)VM.getVM().getAddressSize();\n-      _out = new Node[outcnt()];\n-      Address ptr = outField.getValue(this.getAddress());\n-      for (int j = 0; j < outcnt(); j++) {\n-        _out[j] = Node.create(ptr.getAddressAt(j * addressSize));\n-      }\n-    }\n-    return _out[i];\n-  }\n-\n-  public Node in(int i) {\n-    if (_in == null) {\n-      int addressSize = (int)VM.getVM().getAddressSize();\n-      _in = new Node[len()];\n-      Address ptr = inField.getValue(this.getAddress());\n-      for (int j = 0; j < len(); j++) {\n-        _in[j] = Node.create(ptr.getAddressAt(j * addressSize));\n-      }\n-    }\n-    return _in[i];\n-  }\n-\n-  public ArrayList<Node> collect(int d, boolean onlyCtrl) {\n-    int depth = Math.abs(d);\n-    ArrayList<Node> nstack = new ArrayList<>();\n-    BitSet set = new BitSet();\n-\n-    nstack.add(this);\n-    set.set(idx());\n-    int begin = 0;\n-    int end = 0;\n-    for (int i = 0; i < depth; i++) {\n-      end = nstack.size();\n-      for(int j = begin; j < end; j++) {\n-        Node tp  = nstack.get(j);\n-        int limit = d > 0 ? tp.len() : tp.outcnt();\n-        for(int k = 0; k < limit; k++) {\n-          Node n = d > 0 ? tp.in(k) : tp.rawOut(k);\n-\n-          \/\/ if (not_a_node(n))  continue;\n-          if (n == null) continue;\n-          \/\/ do not recurse through top or the root (would reach unrelated stuff)\n-          \/\/ if (n.isRoot() || n.isTop())  continue;\n-          \/\/ if (onlyCtrl && !n.isCfg()) continue;\n-\n-          if (!set.get(n.idx())) {\n-            nstack.add(n);\n-            set.set(n.idx());\n-          }\n-        }\n-      }\n-      begin = end;\n-    }\n-    return nstack;\n-  }\n-\n-  protected void dumpNodes(Node s, int d, boolean onlyCtrl, PrintStream out) {\n-    if (s == null) return;\n-\n-    ArrayList nstack = s.collect(d, onlyCtrl);\n-    int end = nstack.size();\n-    if (d > 0) {\n-      for(int j = end-1; j >= 0; j--) {\n-        ((Node)nstack.get(j)).dump(out);\n-      }\n-    } else {\n-      for(int j = 0; j < end; j++) {\n-        ((Node)nstack.get(j)).dump(out);\n-      }\n-    }\n-  }\n-\n-  public void dump(int depth, PrintStream out) {\n-    dumpNodes(this, depth, false, out);\n-  }\n-\n-  public String Name() {\n-    Type t = VM.getVM().getTypeDataBase().findDynamicTypeForAddress(getAddress(), nodeType);\n-    String name = null;\n-    if (t != null) {\n-        name = t.toString();\n-    } else {\n-        Class c = getClass();\n-        if (c == Node.class) {\n-            \/\/ couldn't identify class type\n-            return \"UnknownNode<\" + getAddress().getAddressAt(0) + \">\";\n-        }\n-        name = getClass().getName();\n-        if (name.startsWith(\"sun.jvm.hotspot.opto.\")) {\n-            name = name.substring(\"sun.jvm.hotspot.opto.\".length());\n-        }\n-    }\n-    if (name.endsWith(\"Node\")) {\n-        return name.substring(0, name.length() - 4);\n-    }\n-    return name;\n-  }\n-\n-  public void dump(PrintStream out) {\n-    out.print(\" \");\n-    out.print(idx());\n-    out.print(\"\\t\");\n-    out.print(Name());\n-    out.print(\"\\t=== \");\n-    int i = 0;\n-    for (i = 0; i < req(); i++) {\n-      Node n = in(i);\n-      if (n != null) {\n-        out.print(' ');\n-        out.print(in(i).idx());\n-      } else {\n-        out.print(\"_\");\n-      }\n-      out.print(\" \");\n-    }\n-    if (len() != req()) {\n-      int prec = 0;\n-      for (; i < len(); i++) {\n-        Node n = in(i);\n-        if (n != null) {\n-          if (prec++ == 0) {\n-            out.print(\"| \");\n-          }\n-          out.print(in(i).idx());\n-        }\n-        out.print(\" \");\n-      }\n-    }\n-    dumpOut(out);\n-    dumpSpec(out);\n-    out.println();\n-  }\n-\n-  void dumpOut(PrintStream out) {\n-    \/\/ Delimit the output edges\n-    out.print(\" [[\");\n-    \/\/ Dump the output edges\n-    for (int i = 0; i < outcnt(); i++) {    \/\/ For all outputs\n-      Node u = rawOut(i);\n-      if (u == null) {\n-        out.print(\"_ \");\n-      \/\/ } else if (not_a_node(u)) {\n-      \/\/   out.print(\"not_a_node \");\n-      } else {\n-        \/\/ out.print(\"%c%d \", Compile::current()->nodeArena()->contains(u) ? ' ' : 'o', u->_idx);\n-        out.print(' ');\n-        out.print(u.idx());\n-        out.print(' ');\n-      }\n-    }\n-    out.print(\"]] \");\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/Node.java","additions":0,"deletions":271,"binary":false,"changes":271,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Node_Array extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"Node_Array\");\n-    maxField = new CIntField(type.getCIntegerField(\"_max\"), 0);\n-    nodesField = type.getAddressField(\"_nodes\");\n-    aField = type.getAddressField(\"_a\");\n-  }\n-\n-  private static CIntField maxField;\n-  private static AddressField nodesField;\n-  private static AddressField aField;\n-\n-  public Node_Array(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int Size() {\n-    return (int) maxField.getValue(getAddress());\n-  }\n-\n-  public Node at(int i) {\n-    return Node.create(nodesField.getValue(getAddress()).getAddressAt(i * (int)VM.getVM().getAddressSize()));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/Node_Array.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Node_List extends Node_Array {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"Node_List\");\n-    cntField = new CIntField(type.getCIntegerField(\"_cnt\"), 0);\n-  }\n-\n-  private static CIntField cntField;\n-\n-  public Node_List(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int size() {\n-    return (int) cntField.getValue(getAddress());\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/Node_List.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Phase extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"Phase\");\n-  }\n-\n-\n-  public Phase(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/Phase.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import java.io.PrintStream;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class PhaseCFG extends Phase {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"PhaseCFG\");\n-    numBlocksField = new CIntField(type.getCIntegerField(\"_number_of_blocks\"), 0);\n-    blocksField = type.getAddressField(\"_blocks\");\n-    bbsField = type.getAddressField(\"_node_to_block_mapping\");\n-    brootField = type.getAddressField(\"_root_block\");\n-  }\n-\n-  private static CIntField numBlocksField;\n-  private static AddressField blocksField;\n-  private static AddressField bbsField;\n-  private static AddressField brootField;\n-\n-  public PhaseCFG(Address addr) {\n-    super(addr);\n-  }\n-\n-  public void dump(PrintStream out) {\n-    int addressSize = (int)VM.getVM().getAddressSize();\n-    int numBlocks = (int)numBlocksField.getValue(getAddress());\n-    Block_List blocks = new Block_List(getAddress().addOffsetTo(blocksField.getOffset()));\n-    int offset = 0;\n-    for (int i  = 0; i < numBlocks; i++) {\n-      blocks.at(i).dump(out);\n-    }\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/PhaseCFG.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class PhaseRegAlloc extends Phase {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"PhaseRegAlloc\");\n-    nodeRegsField = type.getAddressField(\"_node_regs\");\n-    nodeRegsMaxIndexField = new CIntField(type.getCIntegerField(\"_node_regs_max_index\"), 0);\n-    framesizeField = new CIntField(type.getCIntegerField(\"_framesize\"), 0);\n-    maxRegField = new CIntField(type.getCIntegerField(\"_max_reg\"), 0);\n-  }\n-\n-  private static AddressField nodeRegsField;\n-  private static CIntField nodeRegsMaxIndexField;\n-  private static CIntField framesizeField;\n-  private static CIntField maxRegField;\n-\n-  public PhaseRegAlloc(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/PhaseRegAlloc.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class PhiNode extends TypeNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"PhiNode\");\n-  }\n-\n-\n-  public PhiNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/PhiNode.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class ProjNode extends Node {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"ProjNode\");\n-  }\n-\n-\n-  public ProjNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/ProjNode.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class RegionNode extends Node {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"RegionNode\");\n-  }\n-\n-\n-  public RegionNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/RegionNode.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class RootNode extends LoopNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"RootNode\");\n-  }\n-\n-\n-  public RootNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/RootNode.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class SafePointNode extends MultiNode {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"SafePointNode\");\n-    jvmsField = type.getAddressField(\"_jvms\");\n-  }\n-\n-  private static AddressField jvmsField;\n-\n-  public SafePointNode(Address addr) {\n-    super(addr);\n-  }\n-\n-  public JVMState jvms() {\n-    return JVMState.create(jvmsField.getValue(getAddress()));\n-  }\n-\n-  public void dumpSpec(PrintStream out) {\n-    JVMState jvms = jvms();\n-    if (jvms != null) out.print(\" !\");\n-    while (jvms != null) {\n-      Method m = jvms.method().method();\n-      int bci = jvms.bci();\n-      out.print(\" \" + m.getMethodHolder().getName().asString().replace('\/', '.') + \"::\" + m.getName().asString() + \" @ bci:\" + bci);\n-      jvms = jvms.caller();\n-    }\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/SafePointNode.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.opto;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class TypeNode extends Node {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"TypeNode\");\n-  }\n-\n-\n-  public TypeNode(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/TypeNode.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n-import sun.jvm.hotspot.ci.*;\n@@ -48,14 +47,0 @@\n-\n-    envField = type.getAddressField(\"_env\");\n-  }\n-\n-  private ciEnv _env;\n-\n-  public synchronized ciEnv env() {\n-    if (_env == null) {\n-      Address v = envField.getValue(this.getAddress());\n-      if (v != null) {\n-        _env = new ciEnv(v);\n-      }\n-    }\n-    return _env;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/CompilerThread.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import sun.jvm.hotspot.c1.*;\n@@ -123,2 +122,0 @@\n-  \/** This is only present in a C1 build *\/\n-  private Runtime1     runtime1;\n@@ -868,11 +865,0 @@\n-\n-  \/** Should only be called for C1 builds *\/\n-  public Runtime1 getRuntime1() {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(isClientCompiler(), \"C1 builds only\");\n-    }\n-    if (runtime1 == null) {\n-      runtime1 = new Runtime1();\n-    }\n-    return runtime1;\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-compiler\/ciReplay\/TestSAServer.java 8029528 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.ciReplay;\n-\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.OutputStream;\n-import java.util.Arrays;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class SABase extends CiReplayBase {\n-    private static final String REPLAY_FILE_COPY = \"replay_vm.txt\";\n-\n-    public static void main(String args[]) throws Exception {\n-        checkSetLimits();\n-        SABase base = new SABase(args);\n-        boolean c2 = base.runServer.orElseThrow(() -> new Error(\"runServer must be set\"));\n-        String[] extra = {};\n-        if (Platform.isTieredSupported()) {\n-            if (c2) {\n-                \/\/ Replay produced on first compilation. We want that\n-                \/\/ compilation delayed so profile data is produced.\n-                extra = new String[] {\"-XX:-TieredCompilation\"};\n-            } else {\n-                extra = new String[] {\"-XX:TieredStopAtLevel=1\"};\n-            }\n-        }\n-        base.runTest(\/* needCoreDump = *\/ true, extra);\n-    }\n-\n-    public SABase(String[] args) {\n-        super(args);\n-    }\n-\n-    @Override\n-    public void testAction() {\n-        try {\n-            Files.move(Paths.get(REPLAY_FILE_NAME), Paths.get(REPLAY_FILE_COPY));\n-        } catch (IOException ioe) {\n-            throw new Error(\"Can't move files: \" + ioe, ioe);\n-        }\n-        ProcessBuilder pb;\n-        try {\n-            pb = ProcessTools.createTestJavaProcessBuilder(\"--add-modules\", \"jdk.hotspot.agent\",\n-                   \"--add-exports=jdk.hotspot.agent\/sun.jvm.hotspot=ALL-UNNAMED\",\n-                    \"sun.jvm.hotspot.CLHSDB\", JDKToolFinder.getTestJDKTool(\"java\"),\n-                    TEST_CORE_FILE_NAME);\n-        } catch (Exception e) {\n-            throw new Error(\"Can't create process builder: \" + e, e);\n-        }\n-        Process p;\n-        try {\n-            p = pb.start();\n-        } catch (IOException ioe) {\n-            throw new Error(\"Can't start child process: \" + ioe, ioe);\n-        }\n-        OutputStream input = p.getOutputStream();\n-        String str = \"dumpreplaydata -a > \" + REPLAY_FILE_NAME + \"\\nquit\\n\";\n-        try {\n-            input.write(str.getBytes());\n-            input.flush();\n-        } catch (IOException ioe) {\n-            throw new Error(\"Problem writing process input: \" + str, ioe);\n-        }\n-        try {\n-            p.waitFor();\n-        } catch (InterruptedException ie) {\n-            throw new Error(\"Problem waitinig child process: \" + ie, ie);\n-        }\n-        int exitValue = p.exitValue();\n-        if (exitValue != 0) {\n-            String output;\n-            try {\n-                output = new OutputAnalyzer(p).getOutput();\n-            } catch (IOException ioe) {\n-                throw new Error(\"Can't get failed CLHSDB process output: \" + ioe, ioe);\n-            }\n-            throw new AssertionError(\"CLHSDB wasn't run successfully: \" + output);\n-        }\n-        File replay = new File(REPLAY_FILE_NAME);\n-        Asserts.assertTrue(replay.exists() && replay.isFile() && replay.length() > 0,\n-                \"Replay data wasn't generated by SA\");\n-        \/\/ other than comment lines, content of 2 files should be identical\n-        try {\n-            BufferedReader rep = new BufferedReader(new FileReader(replay));\n-            BufferedReader repCopy = new BufferedReader(new FileReader(REPLAY_FILE_COPY));\n-            boolean failure = false;\n-            while (true) {\n-                String l1;\n-                while ((l1 = rep.readLine()) != null) {\n-                    if (!l1.startsWith(\"#\")) {\n-                        break;\n-                    }\n-                }\n-                String l2;\n-                while ((l2 = repCopy.readLine()) != null) {\n-                    if (!l2.startsWith(\"#\")) {\n-                        break;\n-                    }\n-                }\n-                if (l1 == null || l2 == null) {\n-                    if (l1 != null || l2 != null) {\n-                        System.out.println(\"Warning: replay files are not equal\");\n-                        System.out.println(\"1: \" + l1);\n-                        System.out.println(\"2: \" + l2);\n-                        failure = true;\n-                    }\n-                    break;\n-                }\n-                if (!l1.equals(l2)) {\n-                    System.out.println(\"Warning: replay files are not equal\");\n-                    System.out.println(\"1: \" + l1);\n-                    System.out.println(\"2: \" + l2);\n-                    failure = true;\n-                }\n-            }\n-            if (failure) {\n-                throw new RuntimeException(\"Warning: replay files are not equal\");\n-            }\n-        } catch (IOException ioe) {\n-            throw new Error(\"Can't read replay files: \" + ioe, ioe);\n-        }\n-        commonTests();\n-        runVmTests();\n-    }\n-\n-    public static void checkSetLimits() {\n-        if (!Platform.isWindows()) {\n-            OutputAnalyzer oa;\n-            try {\n-                \/\/ first check if setting limit is possible\n-                oa = ProcessTools.executeProcess(\"sh\", \"-c\", RUN_SHELL_NO_LIMIT + \"ulimit -c\");\n-            } catch (Throwable t) {\n-                throw new Error(\"Can't set limits: \" + t, t);\n-            }\n-            oa.shouldHaveExitValue(0);\n-\n-            String out = oa.getOutput().trim(); \/\/ cut win\/*nix newlines\n-            if (!out.equals(\"unlimited\") && !out.equals(\"-1\")) {\n-                throw new Error(\"Unable to set limits\");\n-            }\n-        }\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/SABase.java","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8011675\n- * @library \/ \/test\/lib\n- * @summary testing of ciReplay with using generated by SA replay.txt\n- * @requires vm.hasSA & vm.flightRecorder != true & vm.compMode != \"Xint\" & vm.debug == true & vm.flavor == \"client\"\n- * @modules java.base\/jdk.internal.misc\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      compiler.ciReplay.SABase client\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestSAClient.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8011675\n- * @library \/ \/test\/lib\n- * @summary testing of ciReplay with using generated by SA replay.txt\n- * @requires vm.hasSA & vm.flightRecorder != true & vm.compMode != \"Xint\" & vm.debug == true & vm.flavor == \"server\"\n- * @modules java.base\/jdk.internal.misc\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      compiler.ciReplay.SABase server\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestSAServer.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"}]}