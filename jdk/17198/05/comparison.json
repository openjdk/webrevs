{"files":[{"patch":"@@ -76,1 +76,1 @@\n-    virtual char *subsystem_path() = 0;\n+    virtual char *subsystem_path(size_t ix) = 0;\n@@ -88,0 +88,1 @@\n+                                              size_t dir_ix,\n@@ -96,1 +97,1 @@\n-  if (c->subsystem_path() == nullptr) {\n+  if (c->subsystem_path(0) == nullptr) {\n@@ -102,1 +103,5 @@\n-  file_path.print_raw(c->subsystem_path());\n+  const char *dir = c->subsystem_path(dir_ix);\n+  if (dir == nullptr) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  file_path.print_raw(dir);\n@@ -170,0 +175,1 @@\n+                                     0 \/* dir_ix *\/,                      \\\n@@ -182,1 +188,1 @@\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n+#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, dir_ix, filename, \\\n@@ -188,0 +194,1 @@\n+                                     dir_ix,                              \\\n@@ -204,4 +211,5 @@\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n+                                     0 \/* dir_ix *\/,                      \\\n+                                     filename,                            \\\n+                                     matchline,                           \\\n+                                     scan_fmt,                            \\\n+                                     &variable);                          \\\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -92,0 +92,12 @@\n+  CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+  if (mem_controller->is_hierarchical()) {\n+    GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n+                           \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n+    \/\/ Backward compatibility:\n+    log_trace(os, container)(\"Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n+    if (hier_memlimit >= os::Linux::physical_memory()) {\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n+      return (jlong)-1;\n+    }\n+    return (jlong)hier_memlimit;\n+  }\n@@ -94,1 +106,0 @@\n-\n@@ -97,10 +108,0 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n@@ -109,3 +110,1 @@\n-  else {\n-    return (jlong)memlimit;\n-  }\n+  return (jlong)memlimit;\n@@ -261,1 +260,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, 0, \"\/cpuset.cpus\",\n@@ -267,1 +266,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, 0, \"\/cpuset.mems\",\n@@ -315,1 +314,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _pids, 0, \"\/pids.max\",\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    char *subsystem_path() { return _path; }\n+    char *subsystem_path(size_t ix) { return ix == 0 ? _path : nullptr; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, 0, \"\/cpuset.cpus\",\n@@ -99,1 +99,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, 0, \"\/cpu.max\",\n@@ -105,1 +105,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, 0, \"\/cpuset.mems\",\n@@ -155,1 +155,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, 0, \"\/memory.low\",\n@@ -160,0 +160,21 @@\n+jlong CgroupV2Subsystem::dir_iterate(char *(CgroupV2Subsystem::*method_ptr)(size_t dir_ix), char *first_val) {\n+  jlong total_limit = -1;\n+  for (size_t dir_ix = 0;; ++dir_ix) {\n+    char *limit_str = dir_ix == 0 && first_val ? first_val : (this->*method_ptr)(dir_ix);\n+    if (limit_str == nullptr && dir_ix) {\n+      break;\n+    }\n+    jlong limit = limit_from_str(limit_str);\n+    if (limit != -1 && (total_limit == -1 || limit < total_limit)) {\n+      total_limit = limit;\n+    }\n+  }\n+  return total_limit;\n+}\n+\n+jlong CgroupV2Subsystem::read_hierarchical_memsw_limit() const {\n+  GET_CONTAINER_INFO_LINE(julong, _unified, \"\/memory.stat\", \"hierarchical_memsw_limit\",\n+                         \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n+  return hier_memswlimit;\n+}\n+\n@@ -166,6 +187,7 @@\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  if (mem_swp_limit_str == nullptr) {\n-    \/\/ Some container tests rely on this trace logging to happen.\n-    log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n-    \/\/ swap disabled at kernel level, treat it as no swap\n-    return read_memory_limit_in_bytes();\n+  jlong swap_limit = OSCONTAINER_ERROR;\n+  static bool hierarchical_failed = false;\n+  if (!hierarchical_failed) {\n+    swap_limit = read_hierarchical_memsw_limit();\n+    if (swap_limit == OSCONTAINER_ERROR) {\n+      hierarchical_failed = true;\n+    }\n@@ -173,5 +195,15 @@\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n-  if (swap_limit >= 0) {\n-    jlong memory_limit = read_memory_limit_in_bytes();\n-    assert(memory_limit >= 0, \"swap limit without memory limit?\");\n-    return memory_limit + swap_limit;\n+  if (swap_limit == OSCONTAINER_ERROR) {\n+    \/\/ Older kernels did not support \"hierarchical_memsw_limit\" for cgroup2.\n+    char *first_val = mem_swp_limit_val(0);\n+    if (first_val == nullptr) {\n+      \/\/ Some container tests rely on this trace logging to happen.\n+      log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n+      \/\/ swap disabled at kernel level, treat it as no swap\n+      return read_memory_limit_in_bytes();\n+    }\n+    swap_limit = dir_iterate(&CgroupV2Subsystem::mem_swp_limit_val, first_val);\n+    if (swap_limit >= 0) {\n+      jlong memory_limit = read_memory_limit_in_bytes();\n+      assert(memory_limit >= 0, \"swap limit without memory limit?\");\n+      return memory_limit + swap_limit;\n+    }\n@@ -183,2 +215,2 @@\n-char* CgroupV2Subsystem::mem_swp_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n+char* CgroupV2Subsystem::mem_swp_limit_val(size_t dir_ix) {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, dir_ix, \"\/memory.swap.max\",\n@@ -191,1 +223,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.current\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, 0, \"\/memory.swap.current\",\n@@ -196,0 +228,6 @@\n+jlong CgroupV2Subsystem::read_hierarchical_memory_limit() const {\n+  GET_CONTAINER_INFO_LINE(julong, _unified, \"\/memory.stat\", \"hierarchical_memory_limit\",\n+                         \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n+  return hier_memlimit;\n+}\n+\n@@ -205,2 +243,12 @@\n-  char * mem_limit_str = mem_limit_val();\n-  jlong limit = limit_from_str(mem_limit_str);\n+  jlong total_limit = OSCONTAINER_ERROR;\n+  static bool hierarchical_failed = false;\n+  if (!hierarchical_failed) {\n+    total_limit = read_hierarchical_memory_limit();\n+    if (total_limit == OSCONTAINER_ERROR) {\n+      hierarchical_failed = true;\n+    }\n+  }\n+  if (total_limit == OSCONTAINER_ERROR) {\n+    \/\/ Older kernels did not support \"hierarchical_memory_limit\" for cgroup2.\n+    total_limit = dir_iterate(&CgroupV2Subsystem::mem_limit_val);\n+  }\n@@ -208,1 +256,1 @@\n-    if (limit == -1) {\n+    if (total_limit == -1) {\n@@ -211,1 +259,1 @@\n-      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, total_limit);\n@@ -214,1 +262,1 @@\n-  return limit;\n+  return total_limit;\n@@ -217,2 +265,2 @@\n-char* CgroupV2Subsystem::mem_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n+char* CgroupV2Subsystem::mem_limit_val(size_t dir_ix) {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, dir_ix, \"\/memory.max\",\n@@ -227,2 +275,1 @@\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  jlong swap_limit = dir_iterate(&CgroupV2Subsystem::mem_swp_limit_val);\n@@ -244,1 +291,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, 0, \"\/pids.max\",\n@@ -276,0 +323,21 @@\n+\n+\/* CgroupV2Controller\n+ *\n+ * Constructor, cgroup_path is enumerated for each directory and the basename\n+ *\/\n+CgroupV2Controller::CgroupV2Controller(char *mount_path, char *cgroup_path) {\n+  _mount_path = mount_path;\n+  _cgroup_path = os::strdup(cgroup_path);\n+  _paths_size = 0;\n+  for (const char *cs = _cgroup_path; (cs = strchr(cs, '\/')); ++cs)\n+    ++_paths_size;\n+  _paths = (char **)os::malloc(_paths_size * sizeof(*_paths), mtInternal);\n+  assert(_cgroup_path[0] == '\/', \"_cgroup_path should start with a slash ('\/')\");\n+  size_t ix = 0;\n+  for (char *s; (s = strrchr(_cgroup_path, '\/'));) {\n+    _paths[ix++] = construct_path(mount_path, _cgroup_path);\n+    *s = 0;\n+  }\n+  assert(ix == _paths_size, \"parsing of cgroup_path failed\");\n+  strcpy(_cgroup_path, cgroup_path);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":96,"deletions":28,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-    char *_path;\n+    size_t _paths_size;\n+    char **_paths;\n@@ -42,5 +43,1 @@\n-    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n-      _mount_path = mount_path;\n-      _cgroup_path = os::strdup(cgroup_path);\n-      _path = construct_path(mount_path, cgroup_path);\n-    }\n+    CgroupV2Controller(char * mount_path, char *cgroup_path);\n@@ -48,1 +45,1 @@\n-    char *subsystem_path() { return _path; }\n+    char *subsystem_path(size_t ix) { return ix < _paths_size ? _paths[ix] : nullptr; }\n@@ -59,2 +56,2 @@\n-    char *mem_limit_val();\n-    char *mem_swp_limit_val();\n+    char *mem_limit_val(size_t dir_ix);\n+    char *mem_swp_limit_val(size_t dir_ix);\n@@ -66,0 +63,4 @@\n+    jlong dir_iterate(char *(CgroupV2Subsystem::*method_ptr)(size_t dir_ix), char *first_val = nullptr);\n+    jlong read_hierarchical_memsw_limit() const;\n+    jlong read_hierarchical_memory_limit() const;\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    public String path();\n+    public String path(int dir_ix);\n@@ -61,1 +61,1 @@\n-    public static String getStringValue(CgroupSubsystemController controller, String param) {\n+    public static String getStringValue(CgroupSubsystemController controller, int dir_ix, String param) {\n@@ -65,1 +65,1 @@\n-            return CgroupUtil.readStringValue(controller, param);\n+            return CgroupUtil.readStringValue(controller, dir_ix, param);\n@@ -73,0 +73,4 @@\n+    public static String getStringValue(CgroupSubsystemController controller, String param) {\n+        return getStringValue(controller, 0 \/* dir_ix *\/, param);\n+    }\n+\n@@ -95,1 +99,1 @@\n-            Path filePath = Paths.get(controller.path(), param);\n+            Path filePath = Paths.get(controller.path(0), param);\n@@ -164,1 +168,1 @@\n-        try (Stream<String> lines = CgroupUtil.readFilePrivileged(Paths.get(controller.path(), param))) {\n+        try (Stream<String> lines = CgroupUtil.readFilePrivileged(Paths.get(controller.path(0), param))) {\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,1 +65,5 @@\n-    static String readStringValue(CgroupSubsystemController controller, String param) throws IOException {\n+    static String readStringValue(CgroupSubsystemController controller, int dir_ix, String param) throws IOException {\n+        String controller_path = controller.path(dir_ix);\n+        if (controller_path == null) {\n+            return null;\n+        }\n@@ -67,1 +71,1 @@\n-                Files.newBufferedReader(Paths.get(controller.path(), param));\n+                Files.newBufferedReader(Paths.get(controller_path, param));\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -310,10 +310,10 @@\n-        long retval = getLongValue(memory, \"memory.limit_in_bytes\");\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n+        long retval;\n+        if (memory.isHierarchical()) {\n+            \/\/ memory.limit_in_bytes returned unlimited, attempt\n+            \/\/ hierarchical memory limit\n+            String match = \"hierarchical_memory_limit\";\n+            retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                        \"memory.stat\",\n+                                                        match);\n+        } else {\n+            retval = getLongValue(memory, \"memory.limit_in_bytes\");\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    public String path() {\n-        return path;\n+    public String path(int dir_ix) {\n+        return dir_ix == 0 ? path : null;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,0 +243,19 @@\n+    private long dirIterate(String param, String firstVal) {\n+        long totalLimit = -1;\n+        for (int dir_ix = 0;; ++dir_ix) {\n+            String strLimit = dir_ix == 0 && firstVal != null ? firstVal : CgroupSubsystemController.getStringValue(unified, dir_ix, param);\n+            if (strLimit == null && dir_ix > 0) {\n+                break;\n+            }\n+            long limit = CgroupSubsystem.limitFromString(strLimit);\n+            if (limit != -1 && (totalLimit == -1 || limit < totalLimit)) {\n+                totalLimit = limit;\n+            }\n+        }\n+        return totalLimit;\n+    }\n+\n+    private long dirIterate(String param) {\n+        return dirIterate(param, null);\n+    }\n+\n@@ -245,2 +264,1 @@\n-        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.max\");\n-        return CgroupSubsystem.limitFromString(strVal);\n+        return dirIterate(\"memory.max\");\n@@ -268,1 +286,1 @@\n-        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.swap.max\");\n+        String firstVal = CgroupSubsystemController.getStringValue(unified, 0, \"memory.swap.max\");\n@@ -271,1 +289,1 @@\n-        if (strVal == null) {\n+        if (firstVal == null) {\n@@ -274,1 +292,1 @@\n-        long swapLimit = CgroupSubsystem.limitFromString(strVal);\n+        long swapLimit = dirIterate(\"memory.swap.max\", firstVal);\n@@ -332,1 +350,1 @@\n-            return CgroupUtil.readFilePrivileged(Paths.get(unified.path(), \"io.stat\"))\n+            return CgroupUtil.readFilePrivileged(Paths.get(unified.path(0), \"io.stat\"))\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private final String path;\n+    private final String[] paths;\n@@ -38,1 +38,8 @@\n-        this.path = Paths.get(mountPath, cgroupPath).toString();\n+        \/\/ size is the number of slashes\n+        paths = new String[cgroupPath.length() - cgroupPath.replace(\"\/\", \"\").length()];\n+        int paths_ix = 0;\n+        for (int pos; (pos = cgroupPath.lastIndexOf('\/')) != -1;) {\n+          paths[paths_ix++] = Paths.get(mountPath, cgroupPath).toString();\n+          cgroupPath = cgroupPath.substring(0, pos);\n+        }\n+        assert paths_ix == paths.length;\n@@ -42,2 +49,2 @@\n-    public String path() {\n-        return path;\n+    public String path(int dir_ix) {\n+        return dir_ix < paths.length ? paths[dir_ix] : null;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  char* subsystem_path() override {\n+  char* subsystem_path(size_t ix) override {\n@@ -65,1 +65,1 @@\n-    return (char*)\"\/\";\n+    return ix == 0 ? (char*)\"\/\" : nullptr;\n@@ -87,0 +87,1 @@\n+  static const size_t dir_ix = 0;\n@@ -90,1 +91,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, \"foo\", \"%s\", &s);\n@@ -95,1 +96,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, \"foo\", \"%s\", &s);\n@@ -100,1 +101,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, \"foo\", \"%s\", &s);\n@@ -110,0 +111,1 @@\n+  static const size_t dir_ix = 0;\n@@ -113,1 +115,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, \"foo\", \"%s\", &s);\n@@ -119,1 +121,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, \"foo\", \"%s\", &s);\n@@ -125,1 +127,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, \"foo\", \"%s\", &s);\n@@ -131,1 +133,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, \"foo\", \"%s\", &s);\n@@ -137,1 +139,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, \"foo\", \"%s\", &s);\n@@ -143,1 +145,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s %*d\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, nullptr, \"%s %*d\", &s);\n@@ -149,1 +151,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%*s %d\", &x);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, nullptr, \"%*s %d\", &x);\n@@ -160,0 +162,1 @@\n+  static const size_t dir_ix = 0;\n@@ -162,1 +165,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, nullptr, \"%s\", &s);\n@@ -167,1 +170,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, nullptr, \"%d\", &x);\n@@ -173,1 +176,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, nullptr, \"%s\", &s);\n@@ -179,1 +182,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, nullptr, \"%d\", &x);\n@@ -185,1 +188,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JLONG_FORMAT, &y);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, nullptr, JLONG_FORMAT, &y);\n@@ -190,1 +193,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JULONG_FORMAT, &z);\n+  err = subsystem_file_line_contents(&my_controller, dir_ix, test_file, nullptr, JULONG_FORMAT, &z);\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  const char* expected_path;\n+  const char** expected_path;\n@@ -39,0 +39,12 @@\n+static void test_expected_path(const TestCase *testCase, CgroupController* ctrl) {\n+  for (size_t dir_ix = 0;; ++dir_ix) {\n+    const char *expected_path = testCase->expected_path[dir_ix];\n+    const char *subsystem_path = ctrl->subsystem_path(dir_ix);\n+    if (expected_path == nullptr || subsystem_path == nullptr) {\n+      ASSERT_EQ(expected_path, subsystem_path);\n+      break;\n+    }\n+    ASSERT_STREQ(expected_path, subsystem_path);\n+  }\n+}\n+\n@@ -40,0 +52,4 @@\n+  static const char* host_expected_path[] = {\n+    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\",\n+    nullptr\n+  };\n@@ -44,1 +60,5 @@\n-    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n+    host_expected_path                                                   \/\/ expected_path\n+  };\n+  static const char* container_engine_expected_path[] = {\n+    \"\/sys\/fs\/cgroup\/mem\",\n+    nullptr\n@@ -50,1 +70,1 @@\n-    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n+    container_engine_expected_path                   \/\/ expected_path\n@@ -59,1 +79,1 @@\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+    test_expected_path(testCases[i], ctrl);\n@@ -64,0 +84,4 @@\n+  static const char* at_mount_root_expected_path[] = {\n+    \"\/sys\/fs\/cgroup\",\n+    nullptr\n+  };\n@@ -65,4 +89,8 @@\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/\",                    \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n+    \"\/sys\/fs\/cgroup\",           \/\/ mount_path\n+    nullptr,                       \/\/ root_path, ignored\n+    \"\/\",                        \/\/ cgroup_path\n+    at_mount_root_expected_path \/\/ expected_path\n+  };\n+  static const char* sub_path_expected_path[] = {\n+    \"\/sys\/fs\/cgroup\/foobar\",\n+    nullptr\n@@ -74,1 +102,1 @@\n-    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n+    sub_path_expected_path  \/\/ expected_path\n@@ -76,1 +104,24 @@\n-  int length = 2;\n+  static const char* nested_path_expected_path[] = {\n+    \"\/sys\/fs\/cgroup\/outer\/inner\",\n+    \"\/sys\/fs\/cgroup\/outer\",\n+    nullptr\n+  };\n+  TestCase nested_path = {\n+    \"\/sys\/fs\/cgroup\",         \/\/ mount_path\n+    nullptr,                     \/\/ root_path, ignored\n+    \"\/outer\/inner\",           \/\/ cgroup_path\n+    nested_path_expected_path \/\/ expected_path\n+  };\n+  static const char* nested_path_doubleslash_expected_path[] = {\n+    \"\/sys\/fs\/cgroup\/outer\/\/inner\",\n+    \"\/sys\/fs\/cgroup\/outer\/\",\n+    \"\/sys\/fs\/cgroup\/outer\",\n+    nullptr\n+  };\n+  TestCase nested_path_doubleslash = {\n+    \"\/sys\/fs\/cgroup\",                     \/\/ mount_path\n+    nullptr,                                 \/\/ root_path, ignored\n+    \"\/outer\/\/inner\",                      \/\/ cgroup_path\n+    nested_path_doubleslash_expected_path \/\/ expected_path\n+  };\n+  int length = 4;\n@@ -78,1 +129,3 @@\n-                            &sub_path };\n+                            &sub_path,\n+                            &nested_path,\n+                            &nested_path_doubleslash };\n@@ -82,1 +135,1 @@\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+    test_expected_path(testCases[i], ctrl);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":65,"deletions":12,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test NestedCgroup\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/testlibrary \/test\/lib\n+ * @run main\/othervm NestedCgroup\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Asserts;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.nio.file.Files;\n+import jtreg.SkippedException;\n+import java.nio.file.Path;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import java.nio.file.NoSuchFileException;\n+import java.io.IOException;\n+\n+public class NestedCgroup {\n+    public static final String CGROUP_OUTER = \"jdktest\" + ProcessHandle.current().pid();\n+    public static final String CGROUP_INNER = \"inner\";\n+    public static final String CONTROLLERS_PATH_OUTER = \"memory:\" + CGROUP_OUTER;\n+    public static final String CONTROLLERS_PATH_INNER = CONTROLLERS_PATH_OUTER + \"\/\" + CGROUP_INNER;\n+    public static final String LINE_DELIM = \"-\".repeat(80);\n+    public static final String MOUNTINFO = \"\/proc\/self\/mountinfo\";\n+\n+    \/\/ A real usage on x86_64 fits in 39 MiB.\n+    public static final int MEMORY_MAX_OUTER = 500 * 1024 * 1024;\n+    public static final int MEMORY_MAX_INNER = MEMORY_MAX_OUTER * 2;\n+    public static final String MEMORY_LIMIT_MB = \"500.00M\";\n+\n+    public static void lineDelim(String str, String label) {\n+        System.err.print(LINE_DELIM + \" \" + label + \"\\n\" + str);\n+        if (!str.isEmpty() && !str.endsWith(\"\\n\")) {\n+            System.err.println();\n+        }\n+    }\n+\n+    public static OutputAnalyzer pSystem(List<String> args, String failStderr, String failExplanation, String ignoreStderr) throws Exception {\n+        System.err.println(LINE_DELIM + \" command: \" + String.join(\" \",args));\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process process = pb.start();\n+        OutputAnalyzer output = new OutputAnalyzer(process);\n+        int exitValue = process.waitFor();\n+        lineDelim(output.getStdout(), \"stdout\");\n+        lineDelim(output.getStderr(), \"stderr\");\n+        System.err.println(LINE_DELIM);\n+        if (!failStderr.isEmpty() && output.getStderr().equals(failStderr + \"\\n\")) {\n+            throw new SkippedException(failExplanation + \": \" + failStderr);\n+        }\n+        if (!ignoreStderr.isEmpty() && output.getStderr().equals(ignoreStderr + \"\\n\")) {\n+            return output;\n+        }\n+        Asserts.assertEQ(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+        return output;\n+    }\n+\n+    public static OutputAnalyzer pSystem(List<String> args) throws Exception {\n+        return pSystem(args, \"\", \"\", \"\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        List<String> cgdelete = new ArrayList<>();\n+        cgdelete.add(\"cgdelete\");\n+        cgdelete.add(\"-r\");\n+        cgdelete.add(\"-g\");\n+        cgdelete.add(CONTROLLERS_PATH_OUTER);\n+        try {\n+            pSystem(cgdelete,\n+                \"cgdelete: libcgroup initialization failed: Cgroup is not mounted\", \"cgroup\/cgroup2 is not mounted\",\n+                \"cgdelete: cannot remove group '\" + CGROUP_OUTER + \"': No such file or directory\");\n+        } catch (IOException e) {\n+            if (e.toString().equals(\"java.io.IOException: Cannot run program \\\"cgdelete\\\": error=2, No such file or directory\")) {\n+                throw new SkippedException(\"libcgroup-tools is not installed\");\n+            }\n+            throw e;\n+        }\n+\n+        List<String> cgcreate = new ArrayList<>();\n+        cgcreate.add(\"cgcreate\");\n+        cgcreate.add(\"-g\");\n+        cgcreate.add(CONTROLLERS_PATH_INNER);\n+        pSystem(cgcreate, \"cgcreate: can't create cgroup \" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \": Cgroup, operation not allowed\", \"Missing root permission\", \"\");\n+\n+        String mountInfo;\n+        try {\n+            mountInfo = Files.readString(Path.of(MOUNTINFO));\n+        } catch (NoSuchFileException e) {\n+            throw new SkippedException(\"Cannot open \" + MOUNTINFO);\n+        }\n+\n+        Matcher matcher = Pattern.compile(\"^(?:\\\\S+\\\\s+){4}(\\\\S+)\\\\s.*\\\\scgroup(?:(2)(?:\\\\s+\\\\S+){2}|\\\\s+\\\\S+\\\\s+(?:\\\\S*,)?memory(?:,\\\\S*)?)$\", Pattern.MULTILINE).matcher(mountInfo);\n+        if (!matcher.find()) {\n+            System.err.println(mountInfo);\n+            throw new SkippedException(\"cgroup\/cgroup2 filesystem mount point not found\");\n+        }\n+        String sysFsCgroup = matcher.group(1);\n+        boolean isCgroup2 = matcher.group(2) != null;\n+        System.err.println(LINE_DELIM + \" \" + (isCgroup2 ? \"cgroup2\" : \"cgroup1\") + \" mount point: \" + sysFsCgroup);\n+        String memory_max_filename = isCgroup2 ? \"memory.max\" : \"memory.limit_in_bytes\";\n+        Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_OUTER);\n+        \/\/ CgroupV1Subsystem::read_memory_limit_in_bytes considered hierarchical_memory_limit only when inner memory.limit_in_bytes is unlimited.\n+        Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_INNER);\n+\n+        \/\/ Here starts a copy of ProcessTools.createJavaProcessBuilder.\n+        List<String> cgexec = new ArrayList<>();\n+        cgexec.add(\"cgexec\");\n+        cgexec.add(\"-g\");\n+        cgexec.add(CONTROLLERS_PATH_INNER);\n+        cgexec.add(JDKToolFinder.getJDKTool(\"java\"));\n+        cgexec.add(\"-cp\");\n+        cgexec.add(System.getProperty(\"java.class.path\"));\n+        cgexec.add(\"-XshowSettings:system\");\n+        cgexec.add(\"-Xlog:os+container=trace\");\n+        cgexec.add(\"-version\");\n+        OutputAnalyzer output = pSystem(cgexec);\n+        output.shouldMatch(\"^ *Memory Limit: \" + MEMORY_LIMIT_MB + \"$\");\n+        output.shouldMatch(\"\\\\[trace\\\\]\\\\[os,container\\\\] \" + (isCgroup2 ? \"\" : \"Hierarchical \") + \"Memory Limit is: \" + MEMORY_MAX_OUTER + \"$\");\n+\n+        pSystem(cgdelete);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/NestedCgroup.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-        assertEquals(mountPoint, ctrl.path());\n+        assertEquals(mountPoint, ctrl.path(0));\n@@ -64,1 +64,1 @@\n-        assertEquals(expectedPath, ctrl.path());\n+        assertEquals(expectedPath, ctrl.path(0));\n@@ -75,1 +75,1 @@\n-        assertEquals(expectedPath, ctrl.path());\n+        assertEquals(expectedPath, ctrl.path(0));\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupV1SubsystemControllerTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        assertEquals(mountPoint, ctrl.path());\n+        assertEquals(mountPoint, ctrl.path(0));\n@@ -61,1 +61,1 @@\n-        assertEquals(expectedPath, ctrl.path());\n+        assertEquals(expectedPath, ctrl.path(0));\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupV2SubsystemControllerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-        public String path() {\n+        public String path(int dir_ix) {\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemController.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}