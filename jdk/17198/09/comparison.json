{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -44,1 +45,1 @@\n-  CgroupV1Controller* cpu = nullptr;\n+  CgroupV1CpuController* cpu = nullptr;\n@@ -66,1 +67,3 @@\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    CgroupV2MemoryController* memory = new CgroupV2MemoryController(cg_infos[MEMORY_IDX]._root_mount_path, cg_infos[MEMORY_IDX]._mount_path);\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(cg_infos[CPU_IDX]._root_mount_path, cg_infos[CPU_IDX]._mount_path);\n+    memory->set_subsystem_path(cg_infos[MEMORY_IDX]._cgroup_path);\n@@ -69,1 +72,1 @@\n-    return new CgroupV2Subsystem(unified);\n+    return new CgroupV2Subsystem(memory, cpu);\n@@ -109,1 +112,1 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu = new CgroupV1CpuController(info._root_mount_path, info._mount_path);\n@@ -478,1 +481,1 @@\n-  int cpu_count, limit_count;\n+  int cpu_count;\n@@ -484,1 +487,1 @@\n-  CachingCgroupController* contrl = cpu_controller();\n+  CachingCgroupController<CgroupCpuController*>* contrl = cpu_controller();\n@@ -492,17 +495,2 @@\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n+  cpu_count = os::Linux::active_processor_count();\n+  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n@@ -525,1 +513,1 @@\n-  CachingCgroupController* contrl = memory_controller();\n+  CachingCgroupController<CgroupMemoryController*>* contrl = memory_controller();\n@@ -532,22 +520,1 @@\n-  jlong mem_limit = read_memory_limit_in_bytes();\n-\n-  if (mem_limit <= 0 || mem_limit >= phys_mem) {\n-    jlong read_mem_limit = mem_limit;\n-    const char *reason;\n-    if (mem_limit >= phys_mem) {\n-      \/\/ Exceeding physical memory is treated as unlimited. Cg v1's implementation\n-      \/\/ of read_memory_limit_in_bytes() caps this at phys_mem since Cg v1 has no\n-      \/\/ value to represent 'max'. Cg v2 may return a value >= phys_mem if e.g. the\n-      \/\/ container engine was started with a memory flag exceeding it.\n-      reason = \"ignored\";\n-      mem_limit = -1;\n-    } else if (OSCONTAINER_ERROR == mem_limit) {\n-      reason = \"failed\";\n-    } else {\n-      assert(mem_limit == -1, \"Expected unlimited\");\n-      reason = \"unlimited\";\n-    }\n-    log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                             reason, read_mem_limit, phys_mem);\n-  }\n-\n+  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n@@ -559,3 +526,62 @@\n-jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n-  if (limit_str == nullptr) {\n-    return OSCONTAINER_ERROR;\n+\/\/ CgroupSubsystem implementations\n+\n+jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(phys_mem);\n+}\n+\n+jlong CgroupSubsystem::memory_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::rss_usage_in_bytes() {\n+  return memory_controller()->controller()->rss_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::cache_usage_in_bytes() {\n+  return memory_controller()->controller()->cache_usage_in_bytes();\n+}\n+\n+int CgroupSubsystem::cpu_quota() {\n+  return cpu_controller()->controller()->cpu_quota();\n+}\n+\n+int CgroupSubsystem::cpu_period() {\n+  return cpu_controller()->controller()->cpu_period();\n+}\n+\n+int CgroupSubsystem::cpu_shares() {\n+  return cpu_controller()->controller()->cpu_shares();\n+}\n+\n+\/*\n+ * Set directory to subsystem specific files based\n+ * on the contents of the mountinfo and cgroup files.\n+ *\/\n+void CgroupController::set_subsystem_path(const char *cgroup_path) {\n+  os::free(_cgroup_path);\n+  _cgroup_path = os::strdup(cgroup_path);\n+  trim_path(0);\n+}\n+\n+void CgroupController::set_path(const char *cgroup_path) {\n+  __attribute__((unused)) bool _cgroup_path; \/\/ Do not use the member variable.\n+  stringStream ss;\n+  if (_root == nullptr || cgroup_path == nullptr) {\n+    return;\n@@ -563,5 +589,46 @@\n-  \/\/ Unlimited memory in cgroups is the literal string 'max' for\n-  \/\/ some controllers, for example the pids controller.\n-  if (strcmp(\"max\", limit_str) == 0) {\n-    os::free(limit_str);\n-    return (jlong)-1;\n+  if (strcmp(_root, \"\/\") == 0) {\n+    ss.print_raw(_mount_point);\n+    if (strcmp(cgroup_path, \"\/\") != 0) {\n+      ss.print_raw(cgroup_path);\n+    }\n+    os::free(_path);\n+    _path = os::strdup(ss.base());\n+    return;\n+  }\n+  if (strcmp(_root, cgroup_path) == 0) {\n+    os::free(_path);\n+    _path = os::strdup(_mount_point);\n+    return;\n+  }\n+  if (strlen(cgroup_path) == strlen(_root)) {\n+    return;\n+  }\n+  if (strncmp(cgroup_path, _root, strlen(_root)) != 0 || cgroup_path[strlen(_root)] != '\/') {\n+    return;\n+  }\n+  ss.print_raw(_mount_point);\n+  const char* cg_path_sub = cgroup_path + strlen(_root);\n+  ss.print_raw(cg_path_sub);\n+  os::free(_path);\n+  _path = os::strdup(ss.base());\n+}\n+\n+\/* trim_path\n+ *\n+ * Remove specific dir_count number of trailing _cgroup_path directories\n+ *\n+ * return:\n+ *    whether dir_count was < number of _cgroup_path directories\n+ *    false is returned if the result would be cgroup root directory\n+ *\/\n+bool CgroupController::trim_path(size_t dir_count) {\n+  char *cgroup_path = os::strdup(_cgroup_path);\n+  assert(cgroup_path[0] == '\/', \"_cgroup_path should start with a slash ('\/')\");\n+  while (dir_count--) {\n+    char *s = strrchr(cgroup_path, '\/');\n+    assert(s, \"function should have already returned\");\n+    *s = 0;\n+    if (s == cgroup_path) {\n+      os::free(cgroup_path);\n+      return false;\n+    }\n@@ -569,4 +636,21 @@\n-  julong limit;\n-  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n-    os::free(limit_str);\n-    return OSCONTAINER_ERROR;\n+  set_path(cgroup_path);\n+  os::free(cgroup_path);\n+  return true;\n+}\n+\n+void CgroupSubsystem::initialize_hierarchy() {\n+  CgroupMemoryController *memory = memory_controller()->controller();\n+\n+  jlong phys_mem = os::Linux::physical_memory();\n+\n+  \/\/ Here it ignores any possible lower limit in parent directories.\n+  \/\/ Linux kernel will correctly consider both that but this code does not.\n+  for (size_t dir_count = 0; memory->trim_path(dir_count); ++dir_count) {\n+    jlong memory_limit = memory->read_memory_limit_in_bytes(phys_mem);\n+    jlong memory_swap_limit = memory_and_swap_limit_in_bytes();\n+    if ((memory_limit != -1 && memory_limit != OSCONTAINER_ERROR)\n+        || (memory_swap_limit != -1 && memory_swap_limit != OSCONTAINER_ERROR)) {\n+      log_trace(os, container)(\"Final Memory Limit is: \" JLONG_FORMAT, memory_limit);\n+      log_trace(os, container)(\"Final Memory and Swap Limit is: \" JLONG_FORMAT, memory_swap_limit);\n+      return;\n+    }\n@@ -574,2 +658,2 @@\n-  os::free(limit_str);\n-  return (jlong)limit;\n+\n+  memory->trim_path(0);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":144,"deletions":60,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -72,2 +72,0 @@\n-typedef char * cptr;\n-\n@@ -75,0 +73,11 @@\n+  protected:\n+    void set_path(const char *cgroup_path);\n+\n+    \/* mountinfo contents *\/\n+    char *_root;\n+    char *_mount_point;\n+    char *_cgroup_path = nullptr;\n+\n+    \/* Constructed subsystem directory *\/\n+    char *_path = nullptr;\n+\n@@ -76,1 +85,12 @@\n-    virtual char *subsystem_path() = 0;\n+    CgroupController(const char *root, const char *mountpoint) : _root(os::strdup(root)), _mount_point(os::strdup(mountpoint)) {}\n+    ~CgroupController() {\n+      os::free(_root);\n+      os::free(_mount_point);\n+      os::free(_cgroup_path);\n+      os::free(_path);\n+    }\n+\n+    bool trim_path(size_t dir_count);\n+    virtual const char *subsystem_path() { return _path; }\n+\n+    virtual void set_subsystem_path(const char *cgroup_path);\n@@ -81,11 +101,35 @@\n-\/\/ Parses a subsystem's file, looking for a matching line.\n-\/\/ If key is null, then the first line will be matched with scan_fmt.\n-\/\/ If key isn't null, then each line will be matched, looking for something that matches \"$key $scan_fmt\".\n-\/\/ The matching value will be assigned to returnval.\n-\/\/ scan_fmt uses scanf() syntax.\n-\/\/ Return value: 0 on match, OSCONTAINER_ERROR on error.\n-template <typename T> int subsystem_file_line_contents(CgroupController* c,\n-                                              const char *filename,\n-                                              const char *key,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n+template <typename T> int __cg_file_contents_impl(const char *absolute_path,\n+                                                  const char *scan_fmt,\n+                                                  T returnval) {\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return OSCONTAINER_ERROR;\n+  }\n+\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    fclose(fp);\n+    return OSCONTAINER_ERROR;\n+  }\n+  fclose(fp);\n+\n+  int matched = sscanf(line, scan_fmt, returnval);\n+  if (matched == 1) {\n+    return 0;\n+  } else {\n+    log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, absolute_path);\n+  }\n+  return OSCONTAINER_ERROR;\n+}\n+PRAGMA_DIAG_POP\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int cg_file_contents_ctrl(CgroupController* c,\n+                                                const char *filename,\n+                                                const char *scan_fmt,\n+                                                T returnval) {\n@@ -93,1 +137,1 @@\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is null\");\n+    log_debug(os, container)(\"cg_file_contents_ctrl: CgroupController* is null\");\n@@ -97,1 +141,5 @@\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is null\");\n+    log_debug(os, container)(\"cg_file_contents_ctrl: subsystem path is null\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (scan_fmt == nullptr || returnval == nullptr) {\n+    log_debug(os, container)(\"cg_file_contents_ctrl: scan_fmt or return pointer is null\");\n@@ -105,1 +153,1 @@\n-  if (file_path.size() > (MAXPATHLEN-1)) {\n+  if (file_path.size() > MAXPATHLEN) {\n@@ -111,0 +159,3 @@\n+  return __cg_file_contents_impl<T>(absolute_path, scan_fmt, returnval);\n+}\n+PRAGMA_DIAG_POP\n@@ -112,0 +163,6 @@\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int __cg_file_multi_line_impl(const char *absolute_path,\n+                                                    const char *key,\n+                                                    const char *scan_fmt,\n+                                                    T returnval) {\n@@ -128,12 +185,7 @@\n-  if (key == nullptr) {\n-    \/\/ File consists of a single line according to caller, with only a value\n-    int matched = sscanf(line, scan_fmt, returnval);\n-    found_match = matched == 1;\n-  } else {\n-    \/\/ File consists of multiple lines in a \"key value\"\n-    \/\/ fashion, we have to find the key.\n-    const int key_len = (int)strlen(key);\n-    for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n-      char* key_substr = strstr(line, key);\n-      char after_key = line[key_len];\n-      if (key_substr == line\n+  \/\/ File consists of multiple lines in a \"key value\"\n+  \/\/ fashion, we have to find the key.\n+  const int key_len = (int)strlen(key);\n+  for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n+    char* key_substr = strstr(line, key);\n+    char after_key = line[key_len];\n+    if (key_substr == line\n@@ -142,7 +194,6 @@\n-        \/\/ Skip key, skip space\n-        const char* value_substr = line + key_len + 1;\n-        int matched = sscanf(value_substr, scan_fmt, returnval);\n-        found_match = matched == 1;\n-        if (found_match) {\n-          break;\n-        }\n+      \/\/ Skip key, skip space\n+      const char* value_substr = line + key_len + 1;\n+      int matched = sscanf(value_substr, scan_fmt, returnval);\n+      found_match = matched == 1;\n+      if (found_match) {\n+        break;\n@@ -157,1 +208,1 @@\n-                           (key == nullptr ? \"null\" : key), absolute_path);\n+                           key, absolute_path);\n@@ -162,19 +213,19 @@\n-\/\/ log_fmt can be different than scan_fmt. For example\n-\/\/ cpu_period() for cgv2 uses log_fmt='%d' and scan_fmt='%*s %d'\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, log_fmt, scan_fmt, variable)        \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0) {                                                         \\\n-    log_trace(os, container)(logstring \"%d\", OSCONTAINER_ERROR);          \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-  }                                                                       \\\n-                                                                          \\\n-  log_trace(os, container)(logstring log_fmt, variable);                  \\\n-}\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int cg_file_multi_line_ctrl(CgroupController* c,\n+                                                  const char *filename,\n+                                                  const char *key,\n+                                                  const char *scan_fmt,\n+                                                  T returnval) {\n+  if (c == nullptr) {\n+    log_debug(os, container)(\"cg_file_multi_line_ctrl: CgroupController* is null\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (c->subsystem_path() == nullptr) {\n+    log_debug(os, container)(\"cg_file_multi_line_ctrl: subsystem path is null\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (key == nullptr || scan_fmt == nullptr || returnval == nullptr) {\n+    log_debug(os, container)(\"cg_file_multi_line_ctrl: key, scan_fmt or return pointer is null\");\n+    return OSCONTAINER_ERROR;\n+  }\n@@ -182,15 +233,3 @@\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) nullptr;                                         \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n+  stringStream file_path;\n+  file_path.print_raw(c->subsystem_path());\n+  file_path.print_raw(filename);\n@@ -198,14 +237,7 @@\n-#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(controller,                          \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return OSCONTAINER_ERROR;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+  return __cg_file_multi_line_impl<T>(absolute_path, key, scan_fmt, returnval);\n@@ -213,1 +245,1 @@\n-\n+PRAGMA_DIAG_POP\n@@ -239,0 +271,1 @@\n+template <class T>\n@@ -241,1 +274,1 @@\n-    CgroupController* _controller;\n+    T _controller;\n@@ -245,1 +278,1 @@\n-    CachingCgroupController(CgroupController* cont) {\n+    CachingCgroupController(T cont) {\n@@ -251,1 +284,1 @@\n-    CgroupController* controller() { return _controller; }\n+    T controller() { return _controller; }\n@@ -254,1 +287,1 @@\n-class CgroupSubsystem: public CHeapObj<mtInternal> {\n+class CgroupCpuController {\n@@ -256,4 +289,0 @@\n-    jlong memory_limit_in_bytes();\n-    int active_processor_count();\n-    jlong limit_from_str(char* limit_str);\n-\n@@ -263,2 +292,6 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+    virtual const char *subsystem_path() = 0;\n+};\n+\n+class CgroupMemoryController : virtual public CgroupController {\n+  public:\n+    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n@@ -266,3 +299,3 @@\n-    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes() = 0;\n-    virtual jlong memory_soft_limit_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n@@ -272,0 +305,13 @@\n+    virtual const char *subsystem_path() = 0;\n+};\n+\n+\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  protected:\n+    void initialize_hierarchy();\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual jlong pids_max() = 0;\n+    virtual jlong pids_current() = 0;\n@@ -273,0 +319,3 @@\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n@@ -275,1 +324,0 @@\n-    virtual jlong read_memory_limit_in_bytes() = 0;\n@@ -277,2 +325,2 @@\n-    virtual CachingCgroupController* memory_controller() = 0;\n-    virtual CachingCgroupController* cpu_controller() = 0;\n+    virtual CachingCgroupController<CgroupMemoryController*>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController*>* cpu_controller() = 0;\n@@ -280,0 +328,7 @@\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_and_swap_usage_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":157,"deletions":102,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupUtil_linux.hpp\"\n+\n+int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n+  assert(host_cpus > 0, \"physical host cpus must be positive\");\n+  int limit_count = host_cpus;\n+  int quota  = cpu_ctrl->cpu_quota();\n+  int period = cpu_ctrl->cpu_period();\n+  int quota_count = 0;\n+  int result = 0;\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+\n+  \/\/ Use quotas\n+  if (quota_count != 0) {\n+    limit_count = quota_count;\n+  }\n+\n+  result = MIN2(host_cpus, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  return result;\n+}\n+\n+jlong CgroupUtil::limit_from_str(char* limit_str) {\n+  if (limit_str == nullptr) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in cgroups is the literal string 'max' for\n+  \/\/ some controllers, for example the pids controller.\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_UTIL_LINUX_HPP\n+#define CGROUP_UTIL_LINUX_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupUtil: AllStatic {\n+\n+  public:\n+    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+    static jlong limit_from_str(char* limit_str);\n+};\n+\n+#endif \/\/ CGROUP_UTIL_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -36,3 +37,3 @@\n-\/*\n- * Set directory to subsystem specific files based\n- * on the contents of the mountinfo and cgroup files.\n+\/* check_mem_hierarchy\n+ *\n+ * Warn if unsupported non-hierarchical cgroup accounting is being done.\n@@ -40,25 +41,4 @@\n-void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n-  stringStream ss;\n-  if (_root != nullptr && cgroup_path != nullptr) {\n-    if (strcmp(_root, \"\/\") == 0) {\n-      ss.print_raw(_mount_point);\n-      if (strcmp(cgroup_path,\"\/\") != 0) {\n-        ss.print_raw(cgroup_path);\n-      }\n-      _path = os::strdup(ss.base());\n-    } else {\n-      if (strcmp(_root, cgroup_path) == 0) {\n-        ss.print_raw(_mount_point);\n-        _path = os::strdup(ss.base());\n-      } else {\n-        char *p = strstr(cgroup_path, _root);\n-        if (p != nullptr && p == _root) {\n-          if (strlen(cgroup_path) > strlen(_root)) {\n-            ss.print_raw(_mount_point);\n-            const char* cg_path_sub = cgroup_path + strlen(_root);\n-            ss.print_raw(cg_path_sub);\n-            _path = os::strdup(ss.base());\n-          }\n-        }\n-      }\n-    }\n+void CgroupV1MemoryController::check_mem_hierarchy() {\n+  static volatile int once = 1;\n+  if (Atomic::xchg(&once, 0) == 0) {\n+    return;\n@@ -66,1 +46,0 @@\n-}\n@@ -68,13 +47,10 @@\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n-jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n-  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \", JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n+  jlong use_hierarchy;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.use_hierarchy\", JLONG_FORMAT, &use_hierarchy);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Use Hierarchy is: %d\", OSCONTAINER_ERROR);\n+    return;\n+  }\n+  log_trace(os, container)(\"Use Hierarchy is: \" JLONG_FORMAT, use_hierarchy);\n+  if (!use_hierarchy) {\n+    warning(\"Non-hierarchical mode (in cgroup v1) is not supported, check \\\"memory.use_hierarchy\\\".\");\n+  }\n@@ -83,1 +59,1 @@\n-void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n+void CgroupV1MemoryController::set_subsystem_path(const char *cgroup_path) {\n@@ -85,4 +61,1 @@\n-  jlong hierarchy = uses_mem_hierarchy();\n-  if (hierarchy > 0) {\n-    set_hierarchical(true);\n-  }\n+  check_mem_hierarchy();\n@@ -91,12 +64,10 @@\n-jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memlimit);\n-\n-  if (memlimit >= os::Linux::physical_memory()) {\n-    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n+static inline\n+void do_trace_log(julong read_mem_limit, julong host_mem) {\n+  if (log_is_enabled(Debug, os, container)) {\n+    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n+    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n+      const char *reason;\n+      if (mem_limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else if (mem_limit == -1) {\n+        reason = \"unlimited\";\n@@ -104,1 +75,4 @@\n-        return (jlong)hier_memlimit;\n+        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n+        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+        reason = \"ignored\";\n@@ -106,0 +80,2 @@\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, mem_limit, host_mem);\n@@ -107,1 +83,0 @@\n-    return (jlong)-1;\n@@ -109,1 +84,32 @@\n-  else {\n+}\n+\n+jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  julong memlimit;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.limit_in_bytes\", JULONG_FORMAT, &memlimit);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory Limit is: %d\", OSCONTAINER_ERROR);\n+    do_trace_log(OSCONTAINER_ERROR, phys_mem);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory Limit is: \" JULONG_FORMAT, memlimit);\n+\n+  if (memlimit >= phys_mem) {\n+    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n+    julong hier_memlimit;\n+    err = cg_file_multi_line_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.stat\",\n+                                  \"hierarchical_memory_limit\", JULONG_FORMAT, &hier_memlimit);\n+    if (err != 0) {\n+      do_trace_log(OSCONTAINER_ERROR, phys_mem);\n+      return OSCONTAINER_ERROR;\n+    }\n+    log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n+    if (hier_memlimit >= phys_mem) {\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n+      do_trace_log(memlimit, phys_mem);\n+      return (jlong)-1;\n+    } else {\n+      do_trace_log(hier_memlimit, phys_mem);\n+      return (jlong)hier_memlimit;\n+    }\n+  } else {\n+    do_trace_log(memlimit, phys_mem);\n@@ -126,5 +132,9 @@\n-jlong CgroupV1Subsystem::read_mem_swap() {\n-  julong host_total_memsw;\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n-  host_total_memsw = os::Linux::host_swap() + os::Linux::physical_memory();\n+jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n+  julong hier_memswlimit;\n+  julong memswlimit;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.memsw.limit_in_bytes\", JULONG_FORMAT, &memswlimit);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory and Swap Limit is: \" JULONG_FORMAT, memswlimit);\n@@ -133,10 +143,11 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n-      if (hier_memswlimit >= host_total_memsw) {\n-        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memswlimit;\n-      }\n+    const char* matchline = \"hierarchical_memsw_limit\";\n+    err = cg_file_multi_line_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.stat\", matchline, JULONG_FORMAT, &hier_memswlimit);\n+    if (err != 0) {\n+      return OSCONTAINER_ERROR;\n+    }\n+    log_trace(os, container)(\"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, hier_memswlimit);\n+    if (hier_memswlimit >= host_total_memsw) {\n+      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n+      return (jlong)-1;\n+    } else {\n+      return (jlong)hier_memswlimit;\n@@ -144,1 +155,0 @@\n-    return (jlong)-1;\n@@ -150,2 +160,2 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n-  jlong memory_swap = read_mem_swap();\n+jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n@@ -160,1 +170,1 @@\n-    jlong memlimit = read_memory_limit_in_bytes();\n+    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n@@ -171,3 +181,15 @@\n-jlong CgroupV1Subsystem::memory_and_swap_usage_in_bytes() {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes();\n-  jlong memory_limit = CgroupSubsystem::memory_limit_in_bytes();\n+static inline\n+jlong memory_swap_usage_impl(CgroupController* ctrl) {\n+  julong memory_swap_usage;\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.memsw.usage_in_bytes\", JULONG_FORMAT, &memory_swap_usage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"mem swap usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"mem swap usage is: \" JULONG_FORMAT, memory_swap_usage);\n+  return (jlong)memory_swap_usage;\n+}\n+\n+jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong phys_mem, julong host_swap) {\n+  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -177,3 +199,1 @@\n-      GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.usage_in_bytes\",\n-                         \"mem swap usage is: \", JULONG_FORMAT, JULONG_FORMAT, memory_swap_usage);\n-      return (jlong)memory_swap_usage;\n+      return memory_swap_usage_impl(static_cast<CgroupV1Controller*>(this));\n@@ -185,4 +205,10 @@\n-jlong CgroupV1Subsystem::read_mem_swappiness() {\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.swappiness\",\n-                     \"Swappiness is: \", JULONG_FORMAT, JULONG_FORMAT, swappiness);\n-  return swappiness;\n+jlong CgroupV1MemoryController::read_mem_swappiness() {\n+  julong swappiness;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.swappiness\",\n+                                  JULONG_FORMAT, &swappiness);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Swappiness is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Swappiness is: \" JULONG_FORMAT, swappiness);\n+  return (jlong)swappiness;\n@@ -191,4 +217,10 @@\n-jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n-  if (memsoftlimit >= os::Linux::physical_memory()) {\n+jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong upper_bound) {\n+  julong memsoftlimit;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.soft_limit_in_bytes\",\n+                                  JULONG_FORMAT, &memsoftlimit);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory Soft Limit is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory Soft Limit is: \" JULONG_FORMAT, memsoftlimit);\n+  if (memsoftlimit >= upper_bound) {\n@@ -211,3 +243,9 @@\n-jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n+jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n+  jlong memusage;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.usage_in_bytes\",\n+                                  JLONG_FORMAT, &memusage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory Usage is: \" JLONG_FORMAT, memusage);\n@@ -225,3 +263,9 @@\n-jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n+jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n+  jlong memmaxusage;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.max_usage_in_bytes\",\n+                                  JLONG_FORMAT, &memmaxusage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Maximum Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Maximum Memory Usage is: \" JLONG_FORMAT, memmaxusage);\n@@ -231,3 +275,7 @@\n-jlong CgroupV1Subsystem::rss_usage_in_bytes() {\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"rss\", JULONG_FORMAT, JULONG_FORMAT, rss);\n+jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n+  julong rss;\n+  int err = cg_file_multi_line_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.stat\", \"rss\", JULONG_FORMAT, &rss);\n+  if (err != 0) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n@@ -237,3 +285,7 @@\n-jlong CgroupV1Subsystem::cache_usage_in_bytes() {\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"cache\", JULONG_FORMAT, JULONG_FORMAT, cache);\n+jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n+  julong cache;\n+  int err = cg_file_multi_line_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.stat\", \"cache\", JULONG_FORMAT, &cache);\n+  if (err != 0) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n@@ -243,3 +295,9 @@\n-jlong CgroupV1Subsystem::kernel_memory_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.usage_in_bytes\",\n-                     \"Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_usage);\n+jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n+  jlong kmem_usage;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.kmem.usage_in_bytes\",\n+                                  JLONG_FORMAT, &kmem_usage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Kernel Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Kernel Memory Usage is: \" JLONG_FORMAT, kmem_usage);\n@@ -249,4 +307,10 @@\n-jlong CgroupV1Subsystem::kernel_memory_limit_in_bytes() {\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.kmem.limit_in_bytes\",\n-                     \"Kernel Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, kmem_limit);\n-  if (kmem_limit >= os::Linux::physical_memory()) {\n+jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n+  julong kmem_limit;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.kmem.limit_in_bytes\",\n+                                  JULONG_FORMAT, &kmem_limit);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Kernel Memory Limit is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Kernel Memory Limit is: \" JULONG_FORMAT, kmem_limit);\n+  if (kmem_limit >= phys_mem) {\n@@ -258,3 +322,9 @@\n-jlong CgroupV1Subsystem::kernel_memory_max_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.max_usage_in_bytes\",\n-                     \"Maximum Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_max_usage);\n+jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n+  jlong kmem_max_usage;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.kmem.max_usage_in_bytes\",\n+                                  JLONG_FORMAT, &kmem_max_usage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Maximum Kernel Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Maximum Kernel Memory Usage is: \" JLONG_FORMAT, kmem_max_usage);\n@@ -265,3 +335,5 @@\n-  jlong kmem_usage = kernel_memory_usage_in_bytes();\n-  jlong kmem_limit = kernel_memory_limit_in_bytes();\n-  jlong kmem_max_usage = kernel_memory_max_usage_in_bytes();\n+  julong phys_mem = os::Linux::physical_memory();\n+  CgroupV1MemoryController* ctrl = reinterpret_cast<CgroupV1MemoryController*>(memory_controller()->controller());\n+  jlong kmem_usage = ctrl->kernel_memory_usage_in_bytes();\n+  jlong kmem_limit = ctrl->kernel_memory_limit_in_bytes(phys_mem);\n+  jlong kmem_max_usage = ctrl->kernel_memory_max_usage_in_bytes();\n@@ -275,2 +347,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  char cpus[1024];\n+  int err = cg_file_contents_ctrl(_cpuset, \"\/cpuset.cpus\", \"%1023s\", cpus);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"cpuset.cpus is: %s\", cpus);\n@@ -281,2 +357,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  char mems[1024];\n+  int err = cg_file_contents_ctrl(_cpuset, \"\/cpuset.mems\", \"%1023s\", mems);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"cpuset.mems is: %s\", mems);\n@@ -296,3 +376,8 @@\n-int CgroupV1Subsystem::cpu_quota() {\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: \", \"%d\", \"%d\", quota);\n+int CgroupV1CpuController::cpu_quota() {\n+  int quota;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/cpu.cfs_quota_us\", \"%d\", &quota);\n+  if (err != 0) {\n+    log_trace(os, container)(\"CPU Quota is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"CPU Quota is: %d\", quota);\n@@ -302,3 +387,8 @@\n-int CgroupV1Subsystem::cpu_period() {\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: \", \"%d\", \"%d\", period);\n+int CgroupV1CpuController::cpu_period() {\n+  int period;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/cpu.cfs_period_us\", \"%d\", &period);\n+  if (err != 0) {\n+    log_trace(os, container)(\"CPU Period is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"CPU Period is: %d\", period);\n@@ -318,3 +408,8 @@\n-int CgroupV1Subsystem::cpu_shares() {\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n-                     \"CPU Shares is: \", \"%d\", \"%d\", shares);\n+int CgroupV1CpuController::cpu_shares() {\n+  int shares;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/cpu.shares\", \"%d\", &shares);\n+  if (err != 0) {\n+    log_trace(os, container)(\"CPU Shares is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"CPU Shares is: %d\", shares);\n@@ -329,2 +424,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n+  char pidsmax[1024];\n+  int err = cg_file_contents_ctrl(_pids, \"\/pids.max\", \"%1023s\", pidsmax);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Maximum number of tasks is: %s\", pidsmax);\n@@ -346,1 +445,1 @@\n-  return limit_from_str(pidsmax_str);\n+  return CgroupUtil::limit_from_str(pidsmax_str);\n@@ -359,2 +458,7 @@\n-  GET_CONTAINER_INFO(jlong, _pids, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n+  jlong pids_current;\n+  int err = cg_file_contents_ctrl(_pids, \"\/pids.current\", JLONG_FORMAT, &pids_current);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Current number of tasks is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Current number of tasks is: \" JLONG_FORMAT, pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":242,"deletions":138,"binary":false,"changes":380,"status":"modified"},{"patch":"@@ -34,9 +34,1 @@\n-class CgroupV1Controller: public CgroupController {\n-  private:\n-    \/* mountinfo contents *\/\n-    char *_root;\n-    char *_mount_point;\n-\n-    \/* Constructed subsystem directory *\/\n-    char *_path;\n-\n+class CgroupV1Controller: virtual public CgroupController {\n@@ -44,8 +36,1 @@\n-    CgroupV1Controller(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = nullptr;\n-    }\n-\n-    virtual void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() { return _path; }\n+    CgroupV1Controller(const char *root, const char *mountpoint) : CgroupController(root, mountpoint) {}\n@@ -54,1 +39,1 @@\n-class CgroupV1MemoryController: public CgroupV1Controller {\n+class CgroupV1MemoryController: public CgroupV1Controller, public CgroupMemoryController {\n@@ -57,2 +42,13 @@\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_subsystem_path(char *cgroup_path);\n+    jlong read_memory_limit_in_bytes(julong upper_bound);\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap);\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap);\n+    jlong memory_soft_limit_in_bytes(julong upper_bound);\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    jlong kernel_memory_usage_in_bytes();\n+    jlong kernel_memory_limit_in_bytes(julong host_mem);\n+    jlong kernel_memory_max_usage_in_bytes();\n+    const char *subsystem_path() override { return CgroupV1Controller::subsystem_path(); }\n+    virtual void set_subsystem_path(const char *cgroup_path) override;\n@@ -61,1 +57,1 @@\n-     * hierarchy. If set to true consider also memory.stat\n+     * hierarchy. Consider also memory.stat\n@@ -63,3 +59,3 @@\n-    bool _uses_mem_hierarchy;\n-    jlong uses_mem_hierarchy();\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n+    void check_mem_hierarchy();\n+    jlong read_mem_swappiness();\n+    jlong read_mem_swap(julong host_total_memsw);\n@@ -68,3 +64,1 @@\n-    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n-    }\n+    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupController(root, mountpoint), CgroupV1Controller(root, mountpoint) {}\n@@ -74,1 +68,1 @@\n-class CgroupV1Subsystem: public CgroupSubsystem {\n+class CgroupV1CpuController: public CgroupV1Controller, public CgroupCpuController {\n@@ -77,8 +71,11 @@\n-    jlong read_memory_limit_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+\n+  public:\n+    CgroupV1CpuController(char *root, char *mountpoint) : CgroupController(root, mountpoint), CgroupV1Controller(root, mountpoint) {\n+    }\n+    const char *subsystem_path() override { return CgroupV1Controller::subsystem_path(); }\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n@@ -86,0 +83,1 @@\n+  public:\n@@ -93,5 +91,0 @@\n-    int cpu_quota();\n-    int cpu_period();\n-\n-    int cpu_shares();\n-\n@@ -106,2 +99,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController*>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController*>* cpu_controller() { return _cpu; }\n@@ -111,1 +104,1 @@\n-    CachingCgroupController* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController*>* _memory = nullptr;\n@@ -113,1 +106,1 @@\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController*>* _cpu = nullptr;\n@@ -119,3 +112,0 @@\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap();\n-\n@@ -124,1 +114,1 @@\n-                      CgroupV1Controller* cpu,\n+                      CgroupV1CpuController* cpu,\n@@ -129,1 +119,1 @@\n-      _cpu = new CachingCgroupController(cpu);\n+      _cpu = new CachingCgroupController<CgroupCpuController*>(cpu);\n@@ -132,1 +122,2 @@\n-      _memory = new CachingCgroupController(memory);\n+      _memory = new CachingCgroupController<CgroupMemoryController*>(memory);\n+      initialize_hierarchy();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":42,"deletions":51,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -37,3 +38,8 @@\n-int CgroupV2Subsystem::cpu_shares() {\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n-                     \"Raw value for CPU Shares is: \", \"%d\", \"%d\", shares);\n+int CgroupV2CpuController::cpu_shares() {\n+  int shares;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(this), \"\/cpu.weight\", \"%d\", &shares);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Raw value for CPU Shares is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Raw value for CPU Shares is: %d\", shares);\n@@ -75,0 +81,11 @@\n+static\n+char* cpu_quota_val(CgroupV2Controller* ctrl) {\n+  char quota[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/cpu.max\", \"%1023s %*d\", quota);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Raw value for CPU quota is: %s\", quota);\n+  return os::strdup(quota);\n+}\n+\n@@ -85,3 +102,3 @@\n-int CgroupV2Subsystem::cpu_quota() {\n-  char * cpu_quota_str = cpu_quota_val();\n-  int limit = (int)limit_from_str(cpu_quota_str);\n+int CgroupV2CpuController::cpu_quota() {\n+  char * cpu_quota_str = cpu_quota_val(static_cast<CgroupV2Controller*>(this));\n+  int limit = (int)CgroupUtil::limit_from_str(cpu_quota_str);\n@@ -93,2 +110,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  char cpus[1024];\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(_unified), \"\/cpuset.cpus\", \"%1023s\", cpus);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"cpuset.cpus is: %s\", cpus);\n@@ -98,6 +119,0 @@\n-char* CgroupV2Subsystem::cpu_quota_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n-                     \"Raw value for CPU quota is: %s\", \"%1023s %*d\", quota, 1024);\n-  return os::strdup(quota);\n-}\n-\n@@ -105,2 +120,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  char mems[1024];\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(_unified), \"\/cpuset.mems\", \"%1023s\", mems);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"cpuset.mems is: %s\", mems);\n@@ -110,3 +129,8 @@\n-int CgroupV2Subsystem::cpu_period() {\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n-                     \"CPU Period is: \", \"%d\", \"%*s %d\", period);\n+int CgroupV2CpuController::cpu_period() {\n+  int period;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(this), \"\/cpu.max\", \"%*s %d\", &period);\n+  if (err != 0) {\n+    log_trace(os, container)(\"CPU Period is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"CPU Period is: %d\", period);\n@@ -125,3 +149,8 @@\n-jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n+jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n+  jlong memusage;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(this), \"\/memory.current\", JLONG_FORMAT, &memusage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory Usage is: \" JLONG_FORMAT, memusage);\n@@ -131,3 +160,14 @@\n-jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n-  char* mem_soft_limit_str = mem_soft_limit_val();\n-  return limit_from_str(mem_soft_limit_str);\n+static\n+char* mem_soft_limit_val(CgroupController* ctrl) {\n+  char mem_soft_limit_str[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.low\", \"%1023s\", mem_soft_limit_str);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Memory Soft Limit is: %s\", mem_soft_limit_str);\n+  return os::strdup(mem_soft_limit_str);\n+}\n+\n+jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n+  char* mem_soft_limit_str = mem_soft_limit_val(static_cast<CgroupV2Controller*>(this));\n+  return CgroupUtil::limit_from_str(mem_soft_limit_str);\n@@ -136,1 +176,1 @@\n-jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n@@ -142,4 +182,9 @@\n-jlong CgroupV2Subsystem::rss_usage_in_bytes() {\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"anon\", JULONG_FORMAT, JULONG_FORMAT, rss);\n-  return rss;\n+jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n+  julong rss;\n+  int err = cg_file_multi_line_ctrl(static_cast<CgroupV2Controller*>(this), \"\/memory.stat\",\n+                                    \"anon\", JULONG_FORMAT, &rss);\n+  if (err != 0) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n+  return (jlong)rss;\n@@ -148,4 +193,9 @@\n-jlong CgroupV2Subsystem::cache_usage_in_bytes() {\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"file\", JULONG_FORMAT, JULONG_FORMAT, cache);\n-  return cache;\n+jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n+  julong cache;\n+  int err = cg_file_multi_line_ctrl(static_cast<CgroupV2Controller*>(this), \"\/memory.stat\",\n+                                    \"file\", JULONG_FORMAT, &cache);\n+  if (err != 0) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n+  return (jlong)cache;\n@@ -154,4 +204,11 @@\n-char* CgroupV2Subsystem::mem_soft_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n-                         \"Memory Soft Limit is: %s\", \"%1023s\", mem_soft_limit_str, 1024);\n-  return os::strdup(mem_soft_limit_str);\n+static\n+char* mem_swp_limit_val(CgroupController* ctrl) {\n+  char mem_swp_limit_str[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.swap.max\", \"%1023s\", mem_swp_limit_str);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  \/\/ FIXME: This log-line is misleading, since it reads the swap limit only, not memory *and*\n+  \/\/ swap limit.\n+  log_trace(os, container)(\"Memory and Swap Limit is: %s\", mem_swp_limit_str);\n+  return os::strdup(mem_swp_limit_str);\n@@ -165,2 +222,2 @@\n-jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n+jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem, julong host_swap) {\n+  char* mem_swp_limit_str = mem_swp_limit_val(static_cast<CgroupV2Controller*>(this));\n@@ -171,1 +228,1 @@\n-    return read_memory_limit_in_bytes();\n+    return read_memory_limit_in_bytes(phys_mem);\n@@ -173,1 +230,1 @@\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  jlong swap_limit = CgroupUtil::limit_from_str(mem_swp_limit_str);\n@@ -175,1 +232,1 @@\n-    jlong memory_limit = read_memory_limit_in_bytes();\n+    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -183,8 +240,10 @@\n-jlong CgroupV2Subsystem::memory_and_swap_usage_in_bytes() {\n-    jlong memory_usage = memory_usage_in_bytes();\n-    if (memory_usage >= 0) {\n-        char* mem_swp_current_str = mem_swp_current_val();\n-        jlong swap_current = limit_from_str(mem_swp_current_str);\n-        return memory_usage + (swap_current >= 0 ? swap_current : 0);\n-    }\n-    return memory_usage; \/\/ not supported or unlimited case\n+\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n+static\n+char* mem_swp_current_val(CgroupV2Controller* ctrl) {\n+  char mem_swp_current_str[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.swap.current\", \"%1023s\", mem_swp_current_str);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Swap currently used is: %s\", mem_swp_current_str);\n+  return os::strdup(mem_swp_current_str);\n@@ -193,4 +252,9 @@\n-char* CgroupV2Subsystem::mem_swp_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n-                         \"Memory and Swap Limit is: %s\", \"%1023s\", mem_swp_limit_str, 1024);\n-  return os::strdup(mem_swp_limit_str);\n+\n+jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_usage = memory_usage_in_bytes();\n+  if (memory_usage >= 0) {\n+      char* mem_swp_current_str = mem_swp_current_val(static_cast<CgroupV2Controller*>(this));\n+      jlong swap_current = CgroupUtil::limit_from_str(mem_swp_current_str);\n+      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+  }\n+  return memory_usage; \/\/ not supported or unlimited case\n@@ -199,5 +263,9 @@\n-\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n-char* CgroupV2Subsystem::mem_swp_current_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.current\",\n-                         \"Swap currently used is: %s\", \"%1023s\", mem_swp_current_str, 1024);\n-  return os::strdup(mem_swp_current_str);\n+static\n+char* mem_limit_val(CgroupV2Controller* ctrl) {\n+  char mem_limit_str[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.max\", \"%1023s\", mem_limit_str);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Raw value for memory limit is: %s\", mem_limit_str);\n+  return os::strdup(mem_limit_str);\n@@ -206,1 +274,1 @@\n-\/* memory_limit_in_bytes\n+\/* read_memory_limit_in_bytes\n@@ -214,3 +282,3 @@\n-jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n-  char * mem_limit_str = mem_limit_val();\n-  jlong limit = limit_from_str(mem_limit_str);\n+jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  char * mem_limit_str = mem_limit_val(static_cast<CgroupV2Controller*>(this));\n+  jlong limit = CgroupUtil::limit_from_str(mem_limit_str);\n@@ -224,0 +292,16 @@\n+  if (log_is_enabled(Debug, os, container)) {\n+    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n+    if (limit < 0 || read_limit >= phys_mem) {\n+      const char* reason;\n+      if (limit == -1) {\n+        reason = \"unlimited\";\n+      } else if (limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else {\n+        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, limit, phys_mem);\n+    }\n+  }\n@@ -227,5 +311,0 @@\n-char* CgroupV2Subsystem::mem_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n-                         \"Raw value for memory limit is: %s\", \"%1023s\", mem_limit_str, 1024);\n-  return os::strdup(mem_limit_str);\n-}\n@@ -234,2 +313,2 @@\n-  char* mem_swp_current_str = mem_swp_current_val();\n-  jlong swap_current = limit_from_str(mem_swp_current_str);\n+  char* mem_swp_current_str = mem_swp_current_val(static_cast<CgroupV2Controller*>(_unified));\n+  jlong swap_current = CgroupUtil::limit_from_str(mem_swp_current_str);\n@@ -237,2 +316,2 @@\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  char* mem_swp_limit_str = mem_swp_limit_val(static_cast<CgroupV2Controller*>(_unified));\n+  jlong swap_limit = CgroupUtil::limit_from_str(mem_swp_limit_str);\n@@ -244,9 +323,0 @@\n-char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n-  stringStream ss;\n-  ss.print_raw(mount_path);\n-  if (strcmp(cgroup_path, \"\/\") != 0) {\n-    ss.print_raw(cgroup_path);\n-  }\n-  return os::strdup(ss.base());\n-}\n-\n@@ -254,2 +324,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n+  char pidsmax[1024];\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(_unified), \"\/pids.max\", \"%1023s\", pidsmax);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Maximum number of tasks is: %s\", pidsmax);\n@@ -270,1 +344,1 @@\n-  return limit_from_str(pidsmax_str);\n+  return CgroupUtil::limit_from_str(pidsmax_str);\n@@ -282,2 +356,7 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n+  jlong pids_current;\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(_unified), \"\/pids.current\", JLONG_FORMAT, &pids_current);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Current number of tasks is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Current number of tasks is: \" JLONG_FORMAT, pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":166,"deletions":87,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -30,6 +30,4 @@\n-class CgroupV2Controller: public CgroupController {\n-  private:\n-    \/* the mount path of the cgroup v2 hierarchy *\/\n-    char *_mount_path;\n-    \/* The cgroup path for the controller *\/\n-    char *_cgroup_path;\n+class CgroupV2Controller: virtual public CgroupController {\n+  public:\n+    CgroupV2Controller(const char *root, const char *mountpoint) : CgroupController(root, mountpoint) {}\n+};\n@@ -37,3 +35,9 @@\n-    \/* Constructed full path to the subsystem directory *\/\n-    char *_path;\n-    static char* construct_path(char* mount_path, char *cgroup_path);\n+class CgroupV2CpuController: public CgroupV2Controller, public CgroupCpuController {\n+  public:\n+    CgroupV2CpuController(char * mount_path, char *cgroup_path) : CgroupController(mount_path, cgroup_path), CgroupV2Controller(mount_path, cgroup_path) {\n+    }\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+    const char *subsystem_path() { return CgroupV2Controller::subsystem_path(); }\n+};\n@@ -41,0 +45,1 @@\n+class CgroupV2MemoryController: public CgroupV2Controller, public CgroupMemoryController {\n@@ -42,4 +47,1 @@\n-    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n-      _mount_path = mount_path;\n-      _cgroup_path = os::strdup(cgroup_path);\n-      _path = construct_path(mount_path, cgroup_path);\n+    CgroupV2MemoryController(char * mount_path, char *cgroup_path) : CgroupController(mount_path, cgroup_path), CgroupV2Controller(mount_path, cgroup_path) {\n@@ -48,1 +50,9 @@\n-    char *subsystem_path() { return _path; }\n+    jlong read_memory_limit_in_bytes(julong upper_bound);\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp);\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swp);\n+    jlong memory_soft_limit_in_bytes(julong upper_bound);\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    const char *subsystem_path() { return CgroupV2Controller::subsystem_path(); }\n@@ -54,1 +64,1 @@\n-    CgroupController* _unified = nullptr;\n+    CgroupV2MemoryController* _unified = nullptr;\n@@ -56,2 +66,2 @@\n-    CachingCgroupController* _memory = nullptr;\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupMemoryController*>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController*>* _cpu = nullptr;\n@@ -59,5 +69,0 @@\n-    char *mem_limit_val();\n-    char *mem_swp_limit_val();\n-    char *mem_swp_current_val();\n-    char *mem_soft_limit_val();\n-    char *cpu_quota_val();\n@@ -67,4 +72,6 @@\n-    CgroupV2Subsystem(CgroupController * unified) {\n-      _unified = unified;\n-      _memory = new CachingCgroupController(unified);\n-      _cpu = new CachingCgroupController(unified);\n+    CgroupV2Subsystem(CgroupV2MemoryController * memory,\n+                      CgroupV2CpuController* cpu) {\n+      _unified = memory; \/\/ Use memory for now, should have all separate later\n+      _memory = new CachingCgroupController<CgroupMemoryController*>(memory);\n+      _cpu = new CachingCgroupController<CgroupCpuController*>(cpu);\n+      initialize_hierarchy();\n@@ -95,2 +102,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController*>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController*>* cpu_controller() { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n@@ -153,1 +153,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    public static final long LONG_RETVAL_UNLIMITED = -1;\n+    public static final long OSCONTAINER_ERROR = -2;\n@@ -42,2 +42,5 @@\n-        if (strVal == null || MAX_VAL.equals(strVal)) {\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        if (strVal == null) {\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n+        }\n+        if (MAX_VAL.equals(strVal)) {\n+            return Long.MAX_VALUE;\n@@ -48,0 +51,15 @@\n+    public default void initializeHierarchy(CgroupSubsystemController memory) {\n+\n+        \/\/ Here it ignores any possible lower limit in parent directories.\n+        \/\/ Linux kernel will correctly consider both that but this code does not.\n+        for (int dirCount = 0; memory.trimPath(dirCount); ++dirCount) {\n+            long memoryLimit = getMemoryLimit();\n+            long memorySwapLimit = getMemoryAndSwapLimit();\n+            if ((memoryLimit != Long.MAX_VALUE && memoryLimit != CgroupSubsystem.OSCONTAINER_ERROR)\n+                || (memorySwapLimit != Long.MAX_VALUE && memorySwapLimit != CgroupSubsystem.OSCONTAINER_ERROR)) {\n+                return;\n+            }\n+        }\n+\n+        memory.trimPath(0);\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-public interface CgroupSubsystemController {\n+public abstract class CgroupSubsystemController {\n@@ -45,1 +45,17 @@\n-    public static final String EMPTY_STR = \"\";\n+    \/\/ Values returned larger than this number are unlimited.\n+    protected static final long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n+\n+    String root;\n+    String mountPoint;\n+    String cgroupPath;\n+    String path;\n+\n+    protected CgroupSubsystemController(String root, String mountPoint) {\n+        this.root = root;\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public void setSubsystemPath(String cgroupPath) {\n+        this.cgroupPath = cgroupPath;\n+        trimPath(0);\n+    }\n@@ -47,1 +63,44 @@\n-    public String path();\n+    public void setPath(String cgroupPath) {\n+        \/\/ Do not use the this.cgroupPath variable.\n+        if (root == null || cgroupPath == null) {\n+            return;\n+        }\n+        if (root.equals(\"\/\")) {\n+            if (!cgroupPath.equals(\"\/\")) {\n+                path = mountPoint + cgroupPath;\n+                return;\n+            }\n+            path = mountPoint;\n+            return;\n+        }\n+        if (root.equals(cgroupPath)) {\n+            path = mountPoint;\n+            return;\n+        }\n+        if (!cgroupPath.startsWith(root) || cgroupPath.equals(root) || cgroupPath.charAt(root.length()) != '\/') {\n+            return;\n+        }\n+        String cgroupSubstr = cgroupPath.substring(root.length());\n+        path = mountPoint + cgroupSubstr;\n+    }\n+\n+    public String path() {\n+        return path;\n+    }\n+\n+    public boolean trimPath(int dir_count) {\n+        String cgroupPath = this.cgroupPath;\n+        assert cgroupPath.charAt(0) == '\/';\n+        while (dir_count-- > 0) {\n+            int pos = cgroupPath.lastIndexOf('\/');\n+            assert pos >= 0;\n+            if (pos == 0) {\n+                return false;\n+            }\n+            cgroupPath = cgroupPath.substring(0, pos);\n+        }\n+        path = Paths.get(mountPoint, cgroupPath).toString();\n+        return true;\n+    }\n+\n+    public static final String EMPTY_STR = \"\";\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-    private boolean hierarchical;\n@@ -37,8 +36,0 @@\n-    boolean isHierarchical() {\n-        return hierarchical;\n-    }\n-\n-    void setHierarchical(boolean hierarchical) {\n-        this.hierarchical = hierarchical;\n-    }\n-\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,3 +84,1 @@\n-                    controller.setPath(info.getCgroupPath());\n-                    boolean isHierarchial = getHierarchical(controller);\n-                    controller.setHierarchical(isHierarchial);\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -97,1 +95,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -106,1 +104,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -115,1 +113,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -124,1 +122,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -133,1 +131,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -146,0 +144,1 @@\n+            subsystem.initializeHierarchy(subsystem.memory);\n@@ -159,5 +158,0 @@\n-    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n-        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n-        return hierarchical > 0;\n-    }\n-\n@@ -193,1 +187,1 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+                                                      CgroupSubsystem.OSCONTAINER_ERROR);\n@@ -248,1 +242,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n@@ -311,10 +305,0 @@\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n-        }\n@@ -368,10 +352,0 @@\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memsw_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n-        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,8 +31,1 @@\n-public class CgroupV1SubsystemController implements CgroupSubsystemController {\n-\n-    private static final double DOUBLE_RETVAL_UNLIMITED = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-    \/\/ Values returned larger than this number are unlimited.\n-    static long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n-    String root;\n-    String mountPoint;\n-    String path;\n+public class CgroupV1SubsystemController extends CgroupSubsystemController {\n@@ -41,33 +34,1 @@\n-        this.root = root;\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public void setPath(String cgroupPath) {\n-        if (root != null && cgroupPath != null) {\n-            if (root.equals(\"\/\")) {\n-                if (!cgroupPath.equals(\"\/\")) {\n-                    path = mountPoint + cgroupPath;\n-                }\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n-                }\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String path() {\n-        return path;\n+        super(root, mountPoint);\n@@ -80,1 +41,1 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                      CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n@@ -86,1 +47,1 @@\n-                                                        DOUBLE_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                        CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n@@ -92,1 +53,1 @@\n-                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                             CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n@@ -96,1 +57,1 @@\n-        return value > UNLIMITED_MIN ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : value;\n+        return value > UNLIMITED_MIN ? Long.MAX_VALUE : value;\n@@ -106,1 +67,1 @@\n-                                                                  CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+                                                                  CgroupSubsystem.OSCONTAINER_ERROR);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":7,"deletions":46,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        return getLongVal(file, CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+        return getLongVal(file, CgroupSubsystem.OSCONTAINER_ERROR);\n@@ -79,3 +79,4 @@\n-            CgroupSubsystemController unified = new CgroupV2SubsystemController(\n-                    anyController.getMountPoint(),\n-                    anyController.getCgroupPath());\n+            CgroupV2SubsystemController unified = new CgroupV2SubsystemController(\n+                    anyController.getMountRoot(),\n+                    anyController.getMountPoint());\n+            unified.setSubsystemPath(anyController.getCgroupPath());\n@@ -83,0 +84,1 @@\n+            tmpCgroupSystem.initializeHierarchy(unified);\n@@ -143,1 +145,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n@@ -148,1 +150,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n@@ -158,1 +160,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n@@ -336,1 +338,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public class CgroupV2SubsystemController implements CgroupSubsystemController {\n+public class CgroupV2SubsystemController extends CgroupSubsystemController {\n@@ -35,9 +35,2 @@\n-    private final String path;\n-\n-    public CgroupV2SubsystemController(String mountPath, String cgroupPath) {\n-        this.path = Paths.get(mountPath, cgroupPath).toString();\n-    }\n-\n-    @Override\n-    public String path() {\n-        return path;\n+    public CgroupV2SubsystemController(String root, String mountPoint) {\n+        super(root, mountPoint);\n@@ -48,2 +41,2 @@\n-                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* overflow retval *\/,\n-                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* default retval on error *\/);\n+                                                             Long.MAX_VALUE \/* overflow retval *\/,\n+                                                             CgroupSubsystem.OSCONTAINER_ERROR \/* default retval on error *\/);\n@@ -56,1 +49,1 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                      CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n@@ -35,0 +37,6 @@\n+typedef struct {\n+  const char* mount_path;\n+  const char* root_path;\n+  const char* cgroup_path;\n+  const char* expected_path;\n+} TestCase;\n@@ -62,0 +70,2 @@\n+private:\n+  const char* _path;\n@@ -63,3 +73,5 @@\n-  char* subsystem_path() override {\n-    \/\/ The real subsystem is in \/tmp\/, generated by temp_file()\n-    return (char*)\"\/\";\n+  TestController(const char *p) : CgroupController(\"\" \/*root*\/, \"\" \/*mountpoint*\/) {\n+    _path = p;\n+  }\n+  const char* subsystem_path() override {\n+    return _path;\n@@ -81,2 +93,1 @@\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesErrorCases) {\n-  TestController my_controller{};\n+TEST(cgroupTest, cg_file_multi_line_impl_failure_cases) {\n@@ -90,1 +101,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n@@ -95,1 +106,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n@@ -100,1 +111,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n@@ -107,2 +118,1 @@\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesSuccessCases) {\n-  TestController my_controller{};\n+TEST(cgroupTest, cg_file_multi_line_impl_success_cases) {\n@@ -116,1 +126,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n@@ -122,1 +132,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n@@ -128,1 +138,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n@@ -134,1 +144,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n@@ -140,1 +150,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n@@ -144,12 +154,0 @@\n-  s[0] = '\\0';\n-  fill_file(test_file, \"max 10000\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s %*d\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"max\");\n-\n-  x = -3;\n-  fill_file(test_file, \"max 10001\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%*s %d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 10001);\n-\n@@ -160,2 +158,1 @@\n-TEST(cgroupTest, SubSystemFileLineContentsSingleLine) {\n-  TestController my_controller{};\n+TEST(cgroupTest, cg_file_contents_impl) {\n@@ -168,1 +165,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n+  err = __cg_file_contents_impl(test_file, \"%s\", &s);\n@@ -172,0 +169,4 @@\n+  err = __cg_file_contents_impl(test_file, \"%d\", &x);\n+  EXPECT_NE(err, 0) << \"'foo' cannot be read as int\";\n+  EXPECT_EQ(x, 0);\n+\n@@ -173,1 +174,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n+  err = __cg_file_contents_impl(test_file, \"%d\", &x);\n@@ -179,1 +180,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n+  err = __cg_file_contents_impl(test_file, \"%s\", &s);\n@@ -185,1 +186,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n+  err = __cg_file_contents_impl(test_file, \"%d\", &x);\n@@ -191,1 +192,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JLONG_FORMAT, &y);\n+  err = __cg_file_contents_impl(test_file, JLONG_FORMAT, &y);\n@@ -196,1 +197,1 @@\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JULONG_FORMAT, &z);\n+  err = __cg_file_contents_impl(test_file, JULONG_FORMAT, &z);\n@@ -200,0 +201,12 @@\n+  s[0] = '\\0';\n+  fill_file(test_file, \"max 10000\");\n+  err = __cg_file_contents_impl(test_file, \"%s %*d\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"max\");\n+\n+  x = -3;\n+  fill_file(test_file, \"max 10001\");\n+  err = __cg_file_contents_impl(test_file, \"%*s %d\", &x);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(x, 10001);\n+\n@@ -204,0 +217,145 @@\n+TEST(cgroupTest, cg_file_contents_ctrl_null) {\n+  TestController* null_path_controller = new TestController(nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  const char* scan_fmt = \"%d\";\n+  int a = -1;\n+  \/\/ null subsystem_path() case\n+  int err = cg_file_contents_ctrl<int*>(null_path_controller, test_file_path, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n+  \/\/ null controller\n+  err = cg_file_contents_ctrl<int*>(nullptr, test_file_path, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n+  \/\/ null scan_fmt, null return pointer\n+  TestController* test_controller = new TestController(\"\/something\");\n+  err = cg_file_contents_ctrl<int*>(test_controller, test_file_path, nullptr, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null scan format should be an error\";\n+  err = cg_file_contents_ctrl<int*>(test_controller, test_file_path, scan_fmt, nullptr);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null return pointer should be an error\";\n+}\n+\n+TEST(cgroupTest, cg_file_contents_ctrl_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* scan_fmt = \"%d\";\n+  int foo = -1;\n+  int err = cg_file_contents_ctrl<int*>(too_large_path_controller, test_file_path, scan_fmt, &foo);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Too long path should be an error\";\n+  EXPECT_EQ(-1, foo) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, cg_file_contents_ctrl_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController(\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* scan_fmt = \"\/not-used\";\n+  const char* ret_val[2] = { \"\/one\", \"\/two\" };\n+  int err = cg_file_contents_ctrl<const char*>(unknown_path_ctrl, test_file_path, scan_fmt, ret_val[0]);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"File not found should be an error\";\n+  EXPECT_EQ(\"\/one\", ret_val[0]) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, cg_file_multi_line_ctrl_null) {\n+  TestController* null_path_controller = new TestController(nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  const char* scan_fmt = \"%d\";\n+  const char* key = \"something\";\n+  int a = -1;\n+  \/\/ null subsystem_path() case\n+  int err = cg_file_multi_line_ctrl<int*>(null_path_controller, test_file_path, key, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n+  \/\/ null controller\n+  err = cg_file_multi_line_ctrl<int*>(nullptr, test_file_path, key, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n+  \/\/ null key, null scan_fmt, null return pointer\n+  TestController* test_controller = new TestController(\"\/something\");\n+  err = cg_file_multi_line_ctrl<int*>(test_controller, test_file_path, nullptr, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null key should be an error\";\n+  err = cg_file_multi_line_ctrl<int*>(test_controller, test_file_path, key, nullptr, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null scan format should be an error\";\n+  err = cg_file_multi_line_ctrl<int*>(test_controller, test_file_path, key, scan_fmt, nullptr);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null return pointer should be an error\";\n+}\n+\n+TEST(cgroupTest, cg_file_multi_line_ctrl_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* scan_fmt = \"%d\";\n+  const char* key = \"something\";\n+  int foo = -1;\n+  int err = cg_file_multi_line_ctrl<int*>(too_large_path_controller, test_file_path, key, scan_fmt, &foo);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Too long path should be an error\";\n+  EXPECT_EQ(-1, foo) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, cg_file_multi_line_ctrl_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController(\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* scan_fmt = \"\/not-used\";\n+  const char* key = \"something\";\n+  const char* ret_val[2] = { \"\/one\", \"\/two\" };\n+  int err = cg_file_multi_line_ctrl<const char*>(unknown_path_ctrl, test_file_path, key, scan_fmt, ret_val[0]);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"File not found should be an error\";\n+  EXPECT_EQ(\"\/one\", ret_val[0]) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n+  TestCase host = {\n+    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n+    \"\/\",                                                                 \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n+  };\n+  TestCase container_engine = {\n+    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &host,\n+                            &container_engine };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV1Controller* ctrl = new CgroupV1Controller( testCases[i]->root_path,\n+                                                       testCases[i]->mount_path);\n+    ctrl->set_subsystem_path(testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n+  TestCase at_mount_root = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    \"\/\",                    \/\/ root_path\n+    \"\/\",                    \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n+  };\n+  TestCase sub_path = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    \"\/\",                    \/\/ root_path\n+    \"\/foobar\",              \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &at_mount_root,\n+                            &sub_path };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV2Controller* ctrl = new CgroupV2Controller( testCases[i]->root_path,\n+                                                       testCases[i]->mount_path);\n+    ctrl->set_subsystem_path(testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":193,"deletions":35,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -1,470 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"os_linux.hpp\"\n-#include \"prims\/jniCheck.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/decoder.hpp\"\n-#include \"concurrentTestRunner.inline.hpp\"\n-#include \"testutils.hpp\"\n-#include \"unittest.hpp\"\n-\n-#include <sys\/mman.h>\n-\n-static bool using_explicit_hugepages()  { return UseLargePages && !UseTransparentHugePages; }\n-\n-namespace {\n-  static void small_page_write(void* addr, size_t size) {\n-    size_t page_size = os::vm_page_size();\n-\n-    char* end = (char*)addr + size;\n-    for (char* p = (char*)addr; p < end; p += page_size) {\n-      *p = 1;\n-    }\n-  }\n-\n-  class HugeTlbfsMemory : private ::os::Linux {\n-    char* const _ptr;\n-    const size_t _size;\n-   public:\n-    static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, size_t page_size, char* req_addr, bool exec) {\n-      return os::reserve_memory_special(bytes, alignment, page_size, req_addr, exec);\n-    }\n-    HugeTlbfsMemory(char* const ptr, size_t size) : _ptr(ptr), _size(size) { }\n-    ~HugeTlbfsMemory() {\n-      if (_ptr != nullptr) {\n-        os::release_memory_special(_ptr, _size);\n-      }\n-    }\n-  };\n-\n-  \/\/ have to use these functions, as gtest's _PRED macros don't like is_aligned\n-  \/\/ nor (is_aligned<size_t, size_t>)\n-  static bool is_size_aligned(size_t size, size_t alignment) {\n-    return is_aligned(size, alignment);\n-  }\n-  static bool is_ptr_aligned(char* ptr, size_t alignment) {\n-    return is_aligned(ptr, alignment);\n-  }\n-}\n-\n-TEST_VM(os_linux, reserve_memory_special_huge_tlbfs_size_aligned) {\n-  if (!using_explicit_hugepages()) {\n-    return;\n-  }\n-  size_t lp = os::large_page_size();\n-\n-  for (size_t size = lp; size <= lp * 10; size += lp) {\n-    char* addr = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, lp, lp, nullptr, false);\n-\n-    if (addr != nullptr) {\n-      HugeTlbfsMemory mr(addr, size);\n-      small_page_write(addr, size);\n-    }\n-  }\n-}\n-\n-TEST_VM(os_linux, reserve_memory_special_huge_tlbfs_size_not_aligned_without_addr) {\n-  if (!using_explicit_hugepages()) {\n-    return;\n-  }\n-  size_t lp = os::large_page_size();\n-  size_t ag = os::vm_allocation_granularity();\n-\n-  \/\/ sizes to test\n-  const size_t sizes[] = {\n-    lp, lp + ag, lp + lp \/ 2, lp * 2,\n-    lp * 2 + ag, lp * 2 - ag, lp * 2 + lp \/ 2,\n-    lp * 10, lp * 10 + lp \/ 2\n-  };\n-  const int num_sizes = sizeof(sizes) \/ sizeof(size_t);\n-  for (int i = 0; i < num_sizes; i++) {\n-    const size_t size = sizes[i];\n-    for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n-      char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, alignment, lp, nullptr, false);\n-      if (p != nullptr) {\n-        HugeTlbfsMemory mr(p, size);\n-        EXPECT_PRED2(is_ptr_aligned, p, alignment) << \" size = \" << size;\n-        small_page_write(p, size);\n-      }\n-    }\n-  }\n-}\n-\n-TEST_VM(os_linux, reserve_memory_special_huge_tlbfs_size_not_aligned_with_good_req_addr) {\n-  if (!using_explicit_hugepages()) {\n-    return;\n-  }\n-  size_t lp = os::large_page_size();\n-  size_t ag = os::vm_allocation_granularity();\n-\n-  \/\/ sizes to test\n-  const size_t sizes[] = {\n-    lp, lp + ag, lp + lp \/ 2, lp * 2,\n-    lp * 2 + ag, lp * 2 - ag, lp * 2 + lp \/ 2,\n-    lp * 10, lp * 10 + lp \/ 2\n-  };\n-  const int num_sizes = sizeof(sizes) \/ sizeof(size_t);\n-\n-  \/\/ Pre-allocate an area as large as the largest allocation\n-  \/\/ and aligned to the largest alignment we will be testing.\n-  const size_t mapping_size = sizes[num_sizes - 1] * 2;\n-  char* const mapping = (char*) ::mmap(nullptr, mapping_size,\n-      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n-      -1, 0);\n-  ASSERT_TRUE(mapping != MAP_FAILED) << \" mmap failed, mapping_size = \" << mapping_size;\n-  \/\/ Unmap the mapping, it will serve as a value for a \"good\" req_addr\n-  ::munmap(mapping, mapping_size);\n-\n-  for (int i = 0; i < num_sizes; i++) {\n-    const size_t size = sizes[i];\n-    for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n-      \/\/ req_addr must be at least large page aligned.\n-      char* const req_addr = align_up(mapping, MAX2(alignment, lp));\n-      char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, alignment, lp, req_addr, false);\n-      if (p != nullptr) {\n-        HugeTlbfsMemory mr(p, size);\n-        ASSERT_EQ(req_addr, p) << \" size = \" << size << \", alignment = \" << alignment;\n-        small_page_write(p, size);\n-      }\n-    }\n-  }\n-}\n-\n-\n-TEST_VM(os_linux, reserve_memory_special_huge_tlbfs_size_not_aligned_with_bad_req_addr) {\n-  if (!using_explicit_hugepages()) {\n-    return;\n-  }\n-  size_t lp = os::large_page_size();\n-  size_t ag = os::vm_allocation_granularity();\n-\n-  \/\/ sizes to test\n-  const size_t sizes[] = {\n-    lp, lp + ag, lp + lp \/ 2, lp * 2,\n-    lp * 2 + ag, lp * 2 - ag, lp * 2 + lp \/ 2,\n-    lp * 10, lp * 10 + lp \/ 2\n-  };\n-  const int num_sizes = sizeof(sizes) \/ sizeof(size_t);\n-\n-  \/\/ Pre-allocate an area as large as the largest allocation\n-  \/\/ and aligned to the largest alignment we will be testing.\n-  const size_t mapping_size = sizes[num_sizes - 1] * 2;\n-  char* const mapping = (char*) ::mmap(nullptr, mapping_size,\n-      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n-      -1, 0);\n-  ASSERT_TRUE(mapping != MAP_FAILED) << \" mmap failed, mapping_size = \" << mapping_size;\n-  \/\/ Leave the mapping intact, it will server as \"bad\" req_addr\n-\n-  class MappingHolder {\n-    char* const _mapping;\n-    size_t _size;\n-   public:\n-    MappingHolder(char* mapping, size_t size) : _mapping(mapping), _size(size) { }\n-    ~MappingHolder() {\n-      ::munmap(_mapping, _size);\n-    }\n-  } holder(mapping, mapping_size);\n-\n-  for (int i = 0; i < num_sizes; i++) {\n-    const size_t size = sizes[i];\n-    for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n-      \/\/ req_addr must be at least large page aligned.\n-      char* const req_addr = align_up(mapping, MAX2(alignment, lp));\n-      char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, alignment, lp, req_addr, false);\n-      HugeTlbfsMemory mr(p, size);\n-      \/\/ as the area around req_addr contains already existing mappings, the API should always\n-      \/\/ return null (as per contract, it cannot return another address)\n-      EXPECT_TRUE(p == nullptr) << \" size = \" << size\n-                             << \", alignment = \" << alignment\n-                             << \", req_addr = \" << req_addr\n-                             << \", p = \" << p;\n-    }\n-  }\n-}\n-\n-class TestReserveMemorySpecial : AllStatic {\n- public:\n-  static void small_page_write(void* addr, size_t size) {\n-    size_t page_size = os::vm_page_size();\n-\n-    char* end = (char*)addr + size;\n-    for (char* p = (char*)addr; p < end; p += page_size) {\n-      *p = 1;\n-    }\n-  }\n-\n-  static void test_reserve_memory_special_huge_tlbfs_size_aligned(size_t size, size_t alignment, size_t page_size) {\n-    if (!using_explicit_hugepages()) {\n-      return;\n-    }\n-    char* addr = os::reserve_memory_special(size, alignment, page_size, nullptr, false);\n-    if (addr != nullptr) {\n-      small_page_write(addr, size);\n-      os::release_memory_special(addr, size);\n-    }\n-  }\n-\n-  static void test_reserve_memory_special_huge_tlbfs_size_aligned() {\n-    if (!using_explicit_hugepages()) {\n-      return;\n-    }\n-    size_t lp = os::large_page_size();\n-    for (size_t size = lp; size <= lp * 10; size += lp) {\n-      test_reserve_memory_special_huge_tlbfs_size_aligned(size, lp, lp);\n-    }\n-  }\n-\n-  static void test_reserve_memory_special_huge_tlbfs_size_not_aligned() {\n-    size_t lp = os::large_page_size();\n-    size_t ag = os::vm_allocation_granularity();\n-\n-    \/\/ sizes to test\n-    const size_t sizes[] = {\n-      lp, lp + ag, lp + lp \/ 2, lp * 2,\n-      lp * 2 + ag, lp * 2 - ag, lp * 2 + lp \/ 2,\n-      lp * 10, lp * 10 + lp \/ 2\n-    };\n-    const int num_sizes = sizeof(sizes) \/ sizeof(size_t);\n-\n-    \/\/ For each size\/alignment combination, we test three scenarios:\n-    \/\/ 1) with req_addr == nullptr\n-    \/\/ 2) with a non-null req_addr at which we expect to successfully allocate\n-    \/\/ 3) with a non-null req_addr which contains a pre-existing mapping, at which we\n-    \/\/    expect the allocation to either fail or to ignore req_addr\n-\n-    \/\/ Pre-allocate two areas; they shall be as large as the largest allocation\n-    \/\/  and aligned to the largest alignment we will be testing.\n-    const size_t mapping_size = sizes[num_sizes - 1] * 2;\n-    char* const mapping1 = (char*) ::mmap(nullptr, mapping_size,\n-      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n-      -1, 0);\n-    EXPECT_NE(mapping1, MAP_FAILED);\n-\n-    char* const mapping2 = (char*) ::mmap(nullptr, mapping_size,\n-      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n-      -1, 0);\n-    EXPECT_NE(mapping2, MAP_FAILED);\n-\n-    \/\/ Unmap the first mapping, but leave the second mapping intact: the first\n-    \/\/ mapping will serve as a value for a \"good\" req_addr (case 2). The second\n-    \/\/ mapping, still intact, as \"bad\" req_addr (case 3).\n-    ::munmap(mapping1, mapping_size);\n-\n-    \/\/ Case 1\n-    for (int i = 0; i < num_sizes; i++) {\n-      const size_t size = sizes[i];\n-      for (size_t alignment = ag; is_aligned(size, alignment); alignment *= 2) {\n-        char* p = os::reserve_memory_special(size, alignment, lp, nullptr, false);\n-        if (p != nullptr) {\n-          EXPECT_TRUE(is_aligned(p, alignment));\n-          small_page_write(p, size);\n-          os::release_memory_special(p, size);\n-        }\n-      }\n-    }\n-\n-    \/\/ Case 2\n-    for (int i = 0; i < num_sizes; i++) {\n-      const size_t size = sizes[i];\n-      for (size_t alignment = ag; is_aligned(size, alignment); alignment *= 2) {\n-        \/\/ req_addr must be at least large page aligned.\n-        char* const req_addr = align_up(mapping1, MAX2(alignment, lp));\n-        char* p = os::reserve_memory_special(size, alignment, lp, req_addr, false);\n-        if (p != nullptr) {\n-          EXPECT_EQ(p, req_addr);\n-          small_page_write(p, size);\n-          os::release_memory_special(p, size);\n-        }\n-      }\n-    }\n-\n-    \/\/ Case 3\n-    for (int i = 0; i < num_sizes; i++) {\n-      const size_t size = sizes[i];\n-      for (size_t alignment = ag; is_aligned(size, alignment); alignment *= 2) {\n-        \/\/ req_addr must be at least large page aligned.\n-        char* const req_addr = align_up(mapping2, MAX2(alignment, lp));\n-        char* p = os::reserve_memory_special(size, alignment, lp, req_addr, false);\n-        \/\/ as the area around req_addr contains already existing mappings, the API should always\n-        \/\/ return nullptr (as per contract, it cannot return another address)\n-        EXPECT_TRUE(p == nullptr);\n-      }\n-    }\n-\n-    ::munmap(mapping2, mapping_size);\n-\n-  }\n-\n-  static void test() {\n-    if (!using_explicit_hugepages()) {\n-      return;\n-    }\n-    test_reserve_memory_special_huge_tlbfs_size_aligned();\n-    test_reserve_memory_special_huge_tlbfs_size_not_aligned();\n-  }\n-};\n-\n-TEST_VM(os_linux, reserve_memory_special) {\n-  TestReserveMemorySpecial::test();\n-}\n-\n-class ReserveMemorySpecialRunnable : public TestRunnable {\n-public:\n-  void runUnitTest() const {\n-    TestReserveMemorySpecial::test();\n-  }\n-};\n-\n-TEST_VM(os_linux, reserve_memory_special_concurrent) {\n-  if (UseLargePages) {\n-    ReserveMemorySpecialRunnable runnable;\n-    ConcurrentTestRunner testRunner(&runnable, 5, 3000);\n-    testRunner.run();\n-  }\n-}\n-\n-TEST_VM(os_linux, pretouch_thp_and_use_concurrent) {\n-  \/\/ Explicitly enable thp to test cocurrent system calls.\n-  const size_t size = 1 * G;\n-  const bool useThp = UseTransparentHugePages;\n-  UseTransparentHugePages = true;\n-  char* const heap = os::reserve_memory(size, false, mtInternal);\n-  EXPECT_NE(heap, nullptr);\n-  EXPECT_TRUE(os::commit_memory(heap, size, false));\n-\n-  {\n-    auto pretouch = [heap, size](Thread*, int) {\n-      os::pretouch_memory(heap, heap + size, os::vm_page_size());\n-    };\n-    auto useMemory = [heap, size](Thread*, int) {\n-      int* iptr = reinterpret_cast<int*>(heap);\n-      for (int i = 0; i < 1000; i++) *iptr++ = i;\n-    };\n-    TestThreadGroup<decltype(pretouch)> pretouchThreads{pretouch, 4};\n-    TestThreadGroup<decltype(useMemory)> useMemoryThreads{useMemory, 4};\n-    useMemoryThreads.doit();\n-    pretouchThreads.doit();\n-    useMemoryThreads.join();\n-    pretouchThreads.join();\n-  }\n-\n-  int* iptr = reinterpret_cast<int*>(heap);\n-  for (int i = 0; i < 1000; i++)\n-    EXPECT_EQ(*iptr++, i);\n-\n-  EXPECT_TRUE(os::uncommit_memory(heap, size, false));\n-  EXPECT_TRUE(os::release_memory(heap, size));\n-  UseTransparentHugePages = useThp;\n-}\n-\n-\/\/ Check that method JNI_CreateJavaVM is found.\n-TEST(os_linux, addr_to_function_valid) {\n-  char buf[128] = \"\";\n-  int offset = -1;\n-  address valid_function_pointer = (address)JNI_CreateJavaVM;\n-  ASSERT_TRUE(os::dll_address_to_function_name(valid_function_pointer, buf, sizeof(buf), &offset, true));\n-  ASSERT_THAT(buf, testing::HasSubstr(\"JNI_CreateJavaVM\"));\n-  ASSERT_TRUE(offset >= 0);\n-}\n-\n-#if !defined(__clang_major__) || (__clang_major__ >= 5) \/\/ DWARF does not support Clang versions older than 5.0.\n-\/\/ Test valid address of method ReportJNIFatalError in jniCheck.hpp. We should get \"jniCheck.hpp\" in the buffer and a valid line number.\n-TEST_VM(os_linux, decoder_get_source_info_valid) {\n-  char buf[128] = \"\";\n-  int line = -1;\n-  address valid_function_pointer = (address)ReportJNIFatalError;\n-  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, sizeof(buf), &line));\n-  EXPECT_STREQ(buf, \"jniCheck.hpp\");\n-  ASSERT_TRUE(line > 0);\n-}\n-\n-\/\/ Test invalid addresses. Should not cause harm and output buffer and line must contain \"\" and -1, respectively.\n-TEST_VM(os_linux, decoder_get_source_info_invalid) {\n-  char buf[128] = \"\";\n-  int line = -1;\n-  address invalid_function_pointers[] = { nullptr, (address)1, (address)&line };\n-\n-  for (address addr : invalid_function_pointers) {\n-    strcpy(buf, \"somestring\");\n-    line = 12;\n-    \/\/ We should return false but do not crash or fail in any way.\n-    ASSERT_FALSE(Decoder::get_source_info(addr, buf, sizeof(buf), &line));\n-    ASSERT_TRUE(buf[0] == '\\0'); \/\/ Should contain \"\" on error\n-    ASSERT_TRUE(line == -1); \/\/ Should contain -1 on error\n-  }\n-}\n-\n-\/\/ Test with valid address but a too small buffer to store the entire filename. Should find generic <OVERFLOW> message\n-\/\/ and a valid line number.\n-TEST_VM(os_linux, decoder_get_source_info_valid_overflow) {\n-  char buf[11] = \"\";\n-  int line = -1;\n-  address valid_function_pointer = (address)ReportJNIFatalError;\n-  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, 11, &line));\n-  EXPECT_STREQ(buf, \"<OVERFLOW>\");\n-  ASSERT_TRUE(line > 0);\n-}\n-\n-\/\/ Test with valid address but a too small buffer that can neither store the entire filename nor the generic <OVERFLOW>\n-\/\/ message. We should find \"L\" as filename and a valid line number.\n-TEST_VM(os_linux, decoder_get_source_info_valid_overflow_minimal) {\n-  char buf[2] = \"\";\n-  int line = -1;\n-  address valid_function_pointer = (address)ReportJNIFatalError;\n-  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, 2, &line));\n-  EXPECT_STREQ(buf, \"L\"); \/\/ Overflow message does not fit, so we fall back to \"L:line_number\"\n-  ASSERT_TRUE(line > 0); \/\/ Line should correctly be found and returned\n-}\n-#endif \/\/ clang\n-\n-#ifdef __GLIBC__\n-TEST_VM(os_linux, glibc_mallinfo_wrapper) {\n-  \/\/ Very basic test. Call it. That proves that resolution and invocation works.\n-  os::Linux::glibc_mallinfo mi;\n-  bool did_wrap = false;\n-\n-  os::Linux::get_mallinfo(&mi, &did_wrap);\n-\n-  void* p = os::malloc(2 * K, mtTest);\n-  ASSERT_NOT_NULL(p);\n-\n-  \/\/ We should see total allocation values > 0\n-  ASSERT_GE((mi.uordblks + mi.hblkhd), 2 * K);\n-\n-  \/\/ These values also should exceed some reasonable size.\n-  ASSERT_LT(mi.fordblks, 2 * G);\n-  ASSERT_LT(mi.uordblks, 2 * G);\n-  ASSERT_LT(mi.hblkhd, 2 * G);\n-\n-  os::free(p);\n-}\n-#endif \/\/ __GLIBC__\n-\n-#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":0,"deletions":470,"binary":false,"changes":470,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"cgroupV1Subsystem_linux.hpp\"\n-#include \"cgroupV2Subsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-\n-typedef struct {\n-  const char* mount_path;\n-  const char* root_path;\n-  const char* cgroup_path;\n-  const char* expected_path;\n-} TestCase;\n-\n-TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n-  TestCase host = {\n-    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n-    \"\/\",                                                                 \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n-  };\n-  TestCase container_engine = {\n-    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &host,\n-                            &container_engine };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n-                                                       (char*)testCases[i]->mount_path);\n-    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n-  TestCase at_mount_root = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/\",                    \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n-  };\n-  TestCase sub_path = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/foobar\",              \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &at_mount_root,\n-                            &sub_path };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n-                                                       (char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test NestedCgroup\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/testlibrary \/test\/lib\n+ * @run main\/othervm NestedCgroup\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Asserts;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.nio.file.Files;\n+import jtreg.SkippedException;\n+import java.nio.file.Path;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import java.nio.file.NoSuchFileException;\n+import java.io.IOException;\n+import java.lang.IllegalArgumentException;\n+\n+public class NestedCgroup {\n+    private static abstract class Test {\n+        public static final String CGROUP_OUTER = \"jdktest\" + ProcessHandle.current().pid();\n+        public static final String CGROUP_INNER = \"inner\";\n+        public static final String CONTROLLERS_PATH_OUTER = \"memory:\" + CGROUP_OUTER;\n+        public static final String CONTROLLERS_PATH_INNER = CONTROLLERS_PATH_OUTER + \"\/\" + CGROUP_INNER;\n+        public static final String LINE_DELIM = \"-\".repeat(80);\n+        public static final String MOUNTINFO = \"\/proc\/self\/mountinfo\";\n+\n+        \/\/ A real usage on x86_64 fits in 39 MiB.\n+        public static final int MEMORY_MAX_OUTER = 500 * 1024 * 1024;\n+        public static final int MEMORY_MAX_INNER = MEMORY_MAX_OUTER * 2;\n+        public static final String MEMORY_LIMIT_MB_OUTER = \"500.00M\";\n+        public static final String MEMORY_LIMIT_MB_INNER = \"1000.00M\";\n+\n+        class Limits {\n+            String string;\n+            int integer;\n+        };\n+\n+        public static String sysFsCgroup;\n+        public String memory_max_filename;\n+        public static boolean isCgroup2;\n+\n+        public static void lineDelim(String str, String label) {\n+            System.err.print(LINE_DELIM + \" \" + label + \"\\n\" + str);\n+            if (!str.isEmpty() && !str.endsWith(\"\\n\")) {\n+                System.err.println();\n+            }\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args, String failStderr, String failExplanation, String ignoreStderr) throws Exception {\n+            System.err.println(LINE_DELIM + \" command: \" + String.join(\" \",args));\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process process = pb.start();\n+            OutputAnalyzer output = new OutputAnalyzer(process);\n+            int exitValue = process.waitFor();\n+            lineDelim(output.getStdout(), \"stdout\");\n+            lineDelim(output.getStderr(), \"stderr\");\n+            System.err.println(LINE_DELIM);\n+            if (!failStderr.isEmpty() && output.getStderr().equals(failStderr + \"\\n\")) {\n+                throw new SkippedException(failExplanation + \": \" + failStderr);\n+            }\n+            if (!ignoreStderr.isEmpty() && output.getStderr().equals(ignoreStderr + \"\\n\")) {\n+                return output;\n+            }\n+            Asserts.assertEQ(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+            return output;\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args) throws Exception {\n+            return pSystem(args, \"\", \"\", \"\");\n+        }\n+\n+        public static void args_add_cgexec(List<String> args) {\n+            args.add(\"cgexec\");\n+            args.add(\"-g\");\n+            args.add(CONTROLLERS_PATH_INNER);\n+        }\n+\n+        public static String jdkTool;\n+\n+        public static void args_add_self(List<String> args) {\n+            args.add(jdkTool);\n+            args.add(\"-cp\");\n+            args.add(System.getProperty(\"java.class.path\"));\n+        }\n+\n+        public static void args_add_self_verbose(List<String> args) {\n+            args_add_self(args);\n+            args.add(\"-XshowSettings:system\");\n+            args.add(\"-Xlog:os+container=trace\");\n+        }\n+\n+        public Test() throws Exception {\n+            List<String> cgdelete = new ArrayList<>();\n+            cgdelete.add(\"cgdelete\");\n+            cgdelete.add(\"-r\");\n+            cgdelete.add(\"-g\");\n+            cgdelete.add(CONTROLLERS_PATH_OUTER);\n+            try {\n+                pSystem(cgdelete,\n+                    \"cgdelete: libcgroup initialization failed: Cgroup is not mounted\", \"cgroup\/cgroup2 is not mounted\",\n+                    \"cgdelete: cannot remove group '\" + CGROUP_OUTER + \"': No such file or directory\");\n+            } catch (IOException e) {\n+                if (e.toString().equals(\"java.io.IOException: Cannot run program \\\"cgdelete\\\": error=2, No such file or directory\")) {\n+                    throw new SkippedException(\"libcgroup-tools is not installed\");\n+                }\n+                throw e;\n+            }\n+\n+            List<String> cgcreate = new ArrayList<>();\n+            cgcreate.add(\"cgcreate\");\n+            cgcreate.add(\"-g\");\n+            cgcreate.add(CONTROLLERS_PATH_INNER);\n+            pSystem(cgcreate, \"cgcreate: can't create cgroup \" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \": Cgroup, operation not allowed\", \"Missing root permission\", \"\");\n+\n+            String mountInfo;\n+            try {\n+                mountInfo = Files.readString(Path.of(MOUNTINFO));\n+            } catch (NoSuchFileException e) {\n+                throw new SkippedException(\"Cannot open \" + MOUNTINFO);\n+            }\n+\n+            Matcher matcher = Pattern.compile(\"^(?:\\\\S+\\\\s+){4}(\\\\S+)\\\\s.*\\\\scgroup(?:(2)(?:\\\\s+\\\\S+){2}|\\\\s+\\\\S+\\\\s+(?:\\\\S*,)?memory(?:,\\\\S*)?)$\", Pattern.MULTILINE).matcher(mountInfo);\n+            if (!matcher.find()) {\n+                System.err.println(mountInfo);\n+                throw new SkippedException(\"cgroup\/cgroup2 filesystem mount point not found\");\n+            }\n+            sysFsCgroup = matcher.group(1);\n+            isCgroup2 = matcher.group(2) != null;\n+            System.err.println(\"isCgroup2 = \" + isCgroup2);\n+\n+            System.err.println(LINE_DELIM + \" \" + (isCgroup2 ? \"cgroup2\" : \"cgroup1\") + \" mount point: \" + sysFsCgroup);\n+            memory_max_filename = isCgroup2 ? \"memory.max\" : \"memory.limit_in_bytes\";\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_OUTER);\n+\n+            \/\/ Here starts a copy of ProcessTools.createJavaProcessBuilder.\n+            List<String> cgexec = new ArrayList<>();\n+            Limits limits = hook(cgexec);\n+            OutputAnalyzer output = pSystem(cgexec);\n+            \/\/ C++ CgroupController\n+            output.shouldMatch(\"\\\\[trace\\\\]\\\\[os,container\\\\] Final Memory Limit is: \" + limits.integer + \"$\");\n+            \/\/ Java jdk.internal.platform.CgroupSubsystem\n+            output.shouldMatch(\"^ *Memory Limit: \" + limits.string + \"$\");\n+\n+            pSystem(cgdelete);\n+        }\n+\n+        public abstract Limits hook(List<String> cgexec) throws IOException;\n+    }\n+    private static class TestTwoLimits extends Test {\n+        public Limits hook(List<String> cgexec) throws IOException {\n+            \/\/ CgroupV1Subsystem::read_memory_limit_in_bytes considered hierarchical_memory_limit only when inner memory.limit_in_bytes is unlimited.\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_INNER);\n+\n+            args_add_cgexec(cgexec);\n+            args_add_self_verbose(cgexec);\n+            cgexec.add(\"-version\");\n+\n+            \/\/ KFAIL - verify the CgroupSubsystem::initialize_hierarchy() and jdk.internal.platform.CgroupSubsystem.initializeHierarchy() bug\n+            \/\/ TestTwoLimits does not see the lower MEMORY_MAX_OUTER limit.\n+            Limits limits = new Limits();\n+            limits.integer = MEMORY_MAX_INNER;\n+            limits.string = MEMORY_LIMIT_MB_INNER;\n+            return limits;\n+        }\n+        public TestTwoLimits() throws Exception {\n+        }\n+    }\n+    private static class TestNoController extends Test {\n+        public Limits hook(List<String> cgexec) throws IOException {\n+            args_add_cgexec(cgexec);\n+            args_add_self(cgexec);\n+            cgexec.add(\"NestedCgroup\");\n+            cgexec.add(\"TestNoController\");\n+            cgexec.add(Test.jdkTool);\n+            cgexec.add(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/cgroup.subtree_control\");\n+\n+            Limits limits = new Limits();\n+            limits.integer = MEMORY_MAX_OUTER;\n+            limits.string = MEMORY_LIMIT_MB_OUTER;\n+            return limits;\n+        }\n+        public TestNoController() throws Exception {\n+        }\n+        public static void child(String arg) throws Exception {\n+            Files.writeString(Path.of(arg), \"-memory\");\n+\n+            List<String> self_verbose = new ArrayList<>();\n+            args_add_self_verbose(self_verbose);\n+            self_verbose.add(\"-version\");\n+            pSystem(self_verbose);\n+        }\n+    }\n+    public static void main(String[] args) throws Exception {\n+        switch (args.length) {\n+            case 0:\n+                Test.jdkTool = JDKToolFinder.getJDKTool(\"java\");\n+                new TestTwoLimits();\n+                if (Test.isCgroup2) {\n+                    new TestNoController();\n+                }\n+                return;\n+            case 3:\n+                switch (args[0]) {\n+                    case \"TestNoController\":\n+                        Test.jdkTool = args[1];\n+                        TestNoController.child(args[2]);\n+                        return;\n+                }\n+        }\n+        throw new IllegalArgumentException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/NestedCgroup.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"}]}