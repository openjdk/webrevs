{"files":[{"patch":"@@ -67,5 +67,3 @@\n-    const CgroupInfo &cg_info_memory = cg_infos[MEMORY_IDX];\n-    CgroupV2Controller mem_other = CgroupV2Controller(cg_info_memory._root_mount_path,\n-                                                      cg_info_memory._mount_path,\n-                                                      cg_info_memory._read_only);\n-    mem_other.set_subsystem_path(cg_info_memory._cgroup_path);\n+    CgroupV2Controller mem_other = CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path,\n+                                                      cg_infos[MEMORY_IDX]._cgroup_path,\n+                                                      cg_infos[MEMORY_IDX]._read_only);\n@@ -73,5 +71,3 @@\n-    const CgroupInfo &cg_info_cpu = cg_infos[CPU_IDX];\n-    CgroupV2CpuController* cpu = new CgroupV2CpuController(CgroupV2Controller(cg_info_cpu._root_mount_path,\n-                                                                              cg_info_cpu._mount_path,\n-                                                                              cg_info_cpu._read_only));\n-    cpu->set_subsystem_path(cg_info_cpu._cgroup_path);\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(CgroupV2Controller(cg_infos[CPU_IDX]._mount_path,\n+                                                                              cg_infos[CPU_IDX]._cgroup_path,\n+                                                                              cg_infos[CPU_IDX]._read_only));\n@@ -824,97 +820,0 @@\n-\n-\/*\n- * Set directory to subsystem specific files based\n- * on the contents of the mountinfo and cgroup files.\n- *\/\n-void CgroupController::set_subsystem_path(char *cgroup_path) {\n-  os::free(_cgroup_path);\n-  _cgroup_path = os::strdup(cgroup_path);\n-  trim_path(0);\n-}\n-\n-void CgroupController::set_path(const char *cgroup_path) {\n-  __attribute__((unused)) bool _cgroup_path; \/\/ Do not use the member variable.\n-  stringStream ss;\n-  if (_root == nullptr || cgroup_path == nullptr) {\n-    return;\n-  }\n-  if (strcmp(_root, \"\/\") == 0) {\n-    ss.print_raw(_mount_point);\n-    if (strcmp(cgroup_path, \"\/\") != 0) {\n-      ss.print_raw(cgroup_path);\n-    }\n-    os::free(_path);\n-    _path = os::strdup(ss.base());\n-    return;\n-  }\n-  if (strcmp(_root, cgroup_path) == 0) {\n-    os::free(_path);\n-    _path = os::strdup(_mount_point);\n-    return;\n-  }\n-  if (strlen(cgroup_path) == strlen(_root)) {\n-    return;\n-  }\n-  if (strncmp(cgroup_path, _root, strlen(_root)) != 0 || cgroup_path[strlen(_root)] != '\/') {\n-    return;\n-  }\n-  ss.print_raw(_mount_point);\n-  const char* cg_path_sub = cgroup_path + strlen(_root);\n-  ss.print_raw(cg_path_sub);\n-  os::free(_path);\n-  _path = os::strdup(ss.base());\n-}\n-\n-\/* trim_path\n- *\n- * Remove specific dir_count number of trailing _cgroup_path directories\n- *\n- * return:\n- *    whether dir_count was < number of _cgroup_path directories\n- *    false is returned if the result would be cgroup root directory\n- *\/\n-bool CgroupController::trim_path(size_t dir_count) {\n-  char *cgroup_path = os::strdup(_cgroup_path);\n-  assert(cgroup_path[0] == '\/', \"_cgroup_path should start with a slash ('\/')\");\n-  while (dir_count--) {\n-    char *s = strrchr(cgroup_path, '\/');\n-    assert(s, \"function should have already returned\");\n-    *s = 0;\n-    if (s == cgroup_path) {\n-      os::free(cgroup_path);\n-      return false;\n-    }\n-  }\n-  set_path(cgroup_path);\n-  os::free(cgroup_path);\n-  return true;\n-}\n-\n-void CgroupSubsystem::initialize_hierarchy() {\n-  size_t best_level = 0;\n-  jlong memory_limit_min = max_jlong;\n-  jlong memory_swap_limit_min = max_jlong;\n-\n-  for (size_t dir_count = 0; memory_controller()->trim_path(dir_count); ++dir_count) {\n-    log_trace(os, container)(\"initialize_hierarchy: dir_count = %zu, best_level = %zu, subsystem_path = %s\",\n-                             dir_count, best_level, memory_controller()->subsystem_path());\n-    jlong memory_limit = memory_limit_in_bytes();\n-    if (memory_limit != -1 && memory_limit != OSCONTAINER_ERROR && memory_limit < memory_limit_min) {\n-      memory_limit_min = memory_limit;\n-      best_level = dir_count;\n-    }\n-    jlong memory_swap_limit = memory_and_swap_limit_in_bytes();\n-    if (memory_swap_limit != -1 && memory_swap_limit != OSCONTAINER_ERROR && memory_swap_limit < memory_swap_limit_min) {\n-      memory_swap_limit_min = memory_swap_limit;\n-      best_level = dir_count;\n-    }\n-    \/\/ Never use a directory without controller files (disabled by \"..\/cgroup.subtree_control\").\n-    if (memory_limit == OSCONTAINER_ERROR && memory_swap_limit == OSCONTAINER_ERROR && best_level == dir_count) {\n-      ++best_level;\n-    }\n-  }\n-\n-  memory_controller()->trim_path(best_level);\n-  log_trace(os, container)(\"initialize_hierarchy: best_level = %zu, subsystem_path = %s\",\n-                           best_level, memory_controller()->subsystem_path());\n-}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":6,"deletions":107,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -107,11 +107,1 @@\n-    void set_path(const char *cgroup_path);\n-\n-    \/* mountinfo contents *\/\n-    char *_root;\n-    char *_mount_point;\n-    bool _read_only;\n-    char *_cgroup_path = nullptr;\n-\n-    \/* Constructed subsystem directory *\/\n-    char *_path = nullptr;\n-\n+    char* _cgroup_path;\n@@ -119,3 +109,4 @@\n-    void set_subsystem_path(char *cgroup_path);\n-    char* subsystem_path() { return _path; }\n-    bool is_read_only() { return _read_only; }\n+    virtual char* subsystem_path() = 0;\n+    virtual bool is_read_only() = 0;\n+    char* cgroup_path() { return _cgroup_path; }\n+    virtual bool needs_hierarchy_adjustment() { return false; }\n@@ -168,24 +159,0 @@\n-    CgroupController(char *root,\n-                     char *mountpoint,\n-                     bool ro) : _root(os::strdup(root)),\n-                                _mount_point(os::strdup(mountpoint)),\n-                                _read_only(ro) {\n-    }\n-    CgroupController(const CgroupController& o) : _root(os::strdup(o._root)),\n-                                                  _mount_point(os::strdup(o._mount_point)),\n-                                                  _read_only(o._read_only),\n-                                                  _cgroup_path(!o._cgroup_path ? nullptr : os::strdup(o._cgroup_path)),\n-                                                  _path(!o._path ? nullptr : os::strdup(o._path)) {\n-    }\n-    CgroupController& operator=(const CgroupController& o) = delete;\n-    ~CgroupController() {\n-      \/\/ At least one subsystem controller exists with paths to malloc'd path\n-      \/\/ names\n-      os::free(_root);\n-      os::free(_mount_point);\n-      os::free(_cgroup_path);\n-      os::free(_path);\n-    }\n-\n-    bool trim_path(size_t dir_count);\n-\n@@ -234,5 +201,0 @@\n-    bool trim_path(size_t dir_count) {\n-      _metrics_cache = new CachedMetric();\n-      return controller()->trim_path(dir_count);\n-    }\n-    char* subsystem_path() { return controller()->subsystem_path(); }\n@@ -247,0 +209,2 @@\n+    virtual bool needs_hierarchy_adjustment() = 0;\n+    virtual CgroupCpuController* adjust_controller(int host_cpus) = 0;\n@@ -262,0 +226,2 @@\n+    virtual CgroupMemoryController* adjust_controller(julong phys_mem) = 0;\n+    virtual bool needs_hierarchy_adjustment() = 0;\n@@ -263,3 +229,0 @@\n-    virtual bool trim_path(size_t dir_count) = 0;\n-    virtual void set_subsystem_path(char *cgroup_path) = 0;\n-    virtual char* subsystem_path() = 0;\n@@ -269,2 +232,0 @@\n-  protected:\n-    void initialize_hierarchy();\n@@ -297,2 +258,0 @@\n-\n-    virtual bool trim_path(size_t dir_count) = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":9,"deletions":50,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"os_linux.hpp\"\n@@ -49,0 +50,16 @@\n+\n+CgroupMemoryController* CgroupUtil::adjust_controller(CgroupMemoryController* mem) {\n+  if (mem->needs_hierarchy_adjustment()) {\n+    julong phys_mem = os::Linux::physical_memory();\n+    return mem->adjust_controller(phys_mem);\n+  }\n+  return mem;\n+}\n+\n+CgroupCpuController* CgroupUtil::adjust_controller(CgroupCpuController* cpu) {\n+  if (cpu->needs_hierarchy_adjustment()) {\n+    int cpu_total = os::Linux::active_processor_count();\n+    return cpu->adjust_controller(cpu_total);\n+  }\n+  return cpu;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+    \/\/ Iterate over the memory controller hierarchy adjusting the path to the\n+    \/\/ smallest observable limit (if any)\n+    static CgroupMemoryController* adjust_controller(CgroupMemoryController* m);\n+    \/\/ Iterate over the cpu controller hierarchy adjusting the path to the\n+    \/\/ smallest observable limit (if any)\n+    static CgroupCpuController* adjust_controller(CgroupCpuController* c);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,2 +37,137 @@\n-void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n-  reader()->set_subsystem_path(cgroup_path);\n+\/*\n+ * Set directory to subsystem specific files based\n+ * on the contents of the mountinfo and cgroup files.\n+ *\/\n+void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n+  if (_cgroup_path != nullptr) {\n+    os::free(_cgroup_path);\n+  }\n+  if (_path != nullptr) {\n+    os::free(_path);\n+  }\n+  _cgroup_path = os::strdup(cgroup_path);\n+  stringStream ss;\n+  if (_root != nullptr && cgroup_path != nullptr) {\n+    if (strcmp(_root, \"\/\") == 0) {\n+      ss.print_raw(_mount_point);\n+      if (strcmp(cgroup_path,\"\/\") != 0) {\n+        ss.print_raw(cgroup_path);\n+      }\n+      _path = os::strdup(ss.base());\n+    } else {\n+      if (strcmp(_root, cgroup_path) == 0) {\n+        ss.print_raw(_mount_point);\n+        _path = os::strdup(ss.base());\n+      } else {\n+        char *p = strstr(cgroup_path, _root);\n+        if (p != nullptr && p == _root) {\n+          if (strlen(cgroup_path) > strlen(_root)) {\n+            ss.print_raw(_mount_point);\n+            const char* cg_path_sub = cgroup_path + strlen(_root);\n+            ss.print_raw(cg_path_sub);\n+            _path = os::strdup(ss.base());\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+bool CgroupV1MemoryController::needs_hierarchy_adjustment() {\n+  return reader()->needs_hierarchy_adjustment();\n+}\n+\n+bool CgroupV1CpuController::needs_hierarchy_adjustment() {\n+  return reader()->needs_hierarchy_adjustment();\n+}\n+\n+CgroupV1MemoryController* CgroupV1MemoryController::adjust_controller(julong phys_mem) {\n+  log_trace(os, container)(\"Adjusting v1 controller path for memory: %s\", reader()->subsystem_path());\n+  assert(reader()->cgroup_path() != nullptr, \"invariant\");\n+  char* orig = os::strdup(reader()->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  jlong limit = read_memory_limit_in_bytes(phys_mem);\n+  bool path_iterated = false;\n+  while (limit < 0 && (last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    reader()->set_subsystem_path(cg_path);\n+    limit = read_memory_limit_in_bytes(phys_mem);\n+    path_iterated = true;\n+    if (limit > 0) {\n+      log_trace(os, container)(\"Adjusted v1 controller path for memory to: %s\", reader()->subsystem_path());\n+      os::free(cg_path);\n+      os::free(orig);\n+      return this;\n+    }\n+  }\n+  \/\/ no lower limit found or limit at leaf\n+  os::free(cg_path);\n+  if (path_iterated) {\n+    reader()->set_subsystem_path((char*)\"\/\");\n+    limit = read_memory_limit_in_bytes(phys_mem);\n+    if (limit > 0) {\n+      \/\/ handle limit set at mount point\n+      log_trace(os, container)(\"Adjusted v1 controller path for memory to: %s\", reader()->subsystem_path());\n+      os::free(orig);\n+      return this;\n+    }\n+    log_trace(os, container)(\"No lower limit found in hierarchy %s, adjusting to original path %s\",\n+                              reader()->mount_point(), orig);\n+    reader()->set_subsystem_path(orig);\n+  } else {\n+    log_trace(os, container)(\"Lowest limit for memory at leaf: %s\",\n+                              reader()->subsystem_path());\n+  }\n+  os::free(orig);\n+  return this;\n+}\n+\n+CgroupV1CpuController* CgroupV1CpuController::adjust_controller(int host_cpus) {\n+  log_trace(os, container)(\"Adjusting v1 controller path for cpu: %s\", reader()->subsystem_path());\n+  assert(reader()->cgroup_path() != nullptr, \"invariant\");\n+  assert(host_cpus > 0, \"Negative host cpus?\");\n+  char* orig = os::strdup(reader()->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  int cpus = CgroupUtil::processor_count(this, host_cpus);\n+  bool path_iterated = false;\n+  while (cpus == host_cpus && (last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    reader()->set_subsystem_path((char*)cg_path);\n+    cpus = CgroupUtil::processor_count(this, host_cpus);\n+    path_iterated = true;\n+    if (cpus != host_cpus) {\n+      log_trace(os, container)(\"Adjusted v1 controller path for cpu to: %s\", reader()->subsystem_path());\n+      os::free(cg_path);\n+      os::free(orig);\n+      return this;\n+    }\n+  }\n+  \/\/ no lower limit found or limit at leaf\n+  os::free(cg_path);\n+  if (path_iterated) {\n+    reader()->set_subsystem_path((char*)\"\/\");\n+    cpus = CgroupUtil::processor_count(this, host_cpus);\n+    if (cpus != host_cpus) {\n+      \/\/ handle limit set at mount point\n+      log_trace(os, container)(\"Adjusted v1 controller path for cpu to: %s\", reader()->subsystem_path());\n+      os::free(orig);\n+      return this;\n+    }\n+    log_trace(os, container)(\"No lower limit found in hierarchy %s, adjusting to original path %s\",\n+                              reader()->mount_point(), orig);\n+    reader()->set_subsystem_path(orig);\n+  } else {\n+    log_trace(os, container)(\"Lowest limit for cpu at leaf: %s\",\n+                              reader()->subsystem_path());\n+  }\n+  os::free(orig);\n+  return this;\n+}\n+\n+bool CgroupV1Controller::needs_hierarchy_adjustment() {\n+  assert(_cgroup_path != nullptr, \"sanity\");\n+  return strcmp(_root, _cgroup_path) != 0;\n@@ -67,12 +202,0 @@\n-    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    julong hier_memlimit;\n-    bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n-    if (!is_ok) {\n-      return OSCONTAINER_ERROR;\n-    }\n-    log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n-    if (hier_memlimit < phys_mem) {\n-      verbose_log(hier_memlimit, phys_mem);\n-      return (jlong)hier_memlimit;\n-    }\n-    log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n@@ -100,1 +223,0 @@\n-  julong hier_memswlimit;\n@@ -104,14 +226,1 @@\n-    log_trace(os, container)(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n-    const char* matchline = \"hierarchical_memsw_limit\";\n-    bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n-                                                         matchline,\n-                                                         &hier_memswlimit);\n-    if (!is_ok) {\n-      return OSCONTAINER_ERROR;\n-    }\n-    log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n-    if (hier_memswlimit >= host_total_memsw) {\n-      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-    } else {\n-      return (jlong)hier_memswlimit;\n-    }\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":138,"deletions":29,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -35,0 +36,9 @@\n+  private:\n+    \/* mountinfo contents *\/\n+    char* _root;\n+    char* _mount_point;\n+    bool _read_only;\n+\n+    \/* Constructed subsystem directory *\/\n+    char* _path;\n+\n@@ -36,1 +46,25 @@\n-    using CgroupController::CgroupController;\n+    CgroupV1Controller(char *root,\n+                       char *mountpoint,\n+                       bool ro) : _root(os::strdup(root)),\n+                                  _mount_point(os::strdup(mountpoint)),\n+                                  _read_only(ro),\n+                                  _path(nullptr) {\n+      _cgroup_path = nullptr;\n+    }\n+    \/\/ Shallow copy constructor\n+    CgroupV1Controller(const CgroupV1Controller& o) : _root(o._root),\n+                                                      _mount_point(o._mount_point),\n+                                                      _read_only(o._read_only),\n+                                                      _path(o._path) {\n+      _cgroup_path = o._cgroup_path;\n+    }\n+    ~CgroupV1Controller() {\n+      \/\/ At least one subsystem controller exists with paths to malloc'd path\n+      \/\/ names\n+    }\n+\n+    void set_subsystem_path(char *cgroup_path);\n+    char* subsystem_path() override { return _path; }\n+    bool is_read_only() override { return _read_only; }\n+    bool needs_hierarchy_adjustment() override;\n+    char *mount_point() { return _mount_point; }\n@@ -45,1 +79,3 @@\n-    void set_subsystem_path(char *cgroup_path);\n+    void set_subsystem_path(char *cgroup_path) {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n@@ -58,0 +94,2 @@\n+    bool needs_hierarchy_adjustment() override;\n+    CgroupV1MemoryController* adjust_controller(julong phys_mem) override;\n@@ -61,2 +99,0 @@\n-    bool trim_path(size_t dir_count) override { return reader()->trim_path(dir_count); }\n-    char* subsystem_path() override { return reader()->subsystem_path(); }\n@@ -93,0 +129,2 @@\n+    bool needs_hierarchy_adjustment() override;\n+    CgroupV1CpuController* adjust_controller(int host_cpus) override;\n@@ -108,1 +146,0 @@\n-    bool trim_path(size_t dir_count) override { return _memory->controller()->trim_path(dir_count); }\n@@ -130,1 +167,2 @@\n-      _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+      _memory(new CachingCgroupController<CgroupMemoryController>(\n+                                         CgroupUtil::adjust_controller(memory))),\n@@ -132,1 +170,2 @@\n-      _cpu(new CachingCgroupController<CgroupCpuController>(cpu)),\n+      _cpu(new CachingCgroupController<CgroupCpuController>(\n+                                         CgroupUtil::adjust_controller(cpu))),\n@@ -135,1 +174,0 @@\n-      initialize_hierarchy();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":46,"deletions":8,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -267,0 +267,106 @@\n+void CgroupV2Controller::set_subsystem_path(char* cgroup_path) {\n+  if (_path != nullptr) {\n+    os::free(_path);\n+  }\n+  _path = construct_path(_mount_path, cgroup_path);\n+}\n+\n+bool CgroupV2MemoryController::needs_hierarchy_adjustment() {\n+  return reader()->needs_hierarchy_adjustment();\n+}\n+\n+bool CgroupV2CpuController::needs_hierarchy_adjustment() {\n+  return reader()->needs_hierarchy_adjustment();\n+}\n+\n+CgroupCpuController* CgroupV2CpuController::adjust_controller(int host_cpus) {\n+  log_trace(os, container)(\"Adjusting v2 controller path for cpu: %s\", reader()->subsystem_path());\n+  assert(reader()->cgroup_path() != nullptr, \"invariant\");\n+  assert(host_cpus > 0, \"Negative host cpus?\");\n+  char* orig = os::strdup(reader()->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  int cpus = CgroupUtil::processor_count(this, host_cpus);\n+  bool path_iterated = false;\n+  while (cpus == host_cpus && (last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    reader()->set_subsystem_path(cg_path);\n+    cpus = CgroupUtil::processor_count(this, host_cpus);\n+    path_iterated = true;\n+    if (cpus != host_cpus) {\n+      log_trace(os, container)(\"Adjusted v2 controller path for cpu to: %s\", reader()->subsystem_path());\n+      os::free(cg_path);\n+      os::free(orig);\n+      return this;\n+    }\n+  }\n+  os::free(cg_path);\n+  if (path_iterated) {\n+    reader()->set_subsystem_path((char*)\"\/\");\n+    cpus = CgroupUtil::processor_count(this, host_cpus);\n+    if (cpus != host_cpus) {\n+      \/\/ handle limit set at mount point\n+      log_trace(os, container)(\"Adjusted v2 controller path for cpu to: %s\", reader()->subsystem_path());\n+      os::free(orig);\n+      return this;\n+    }\n+    log_trace(os, container)(\"No lower limit found in hierarchy %s, adjusting to original path %s\",\n+                              reader()->mount_point(), orig);\n+    reader()->set_subsystem_path(orig);\n+  } else {\n+    log_trace(os, container)(\"Lowest limit for cpu at leaf: %s\",\n+                              reader()->subsystem_path());\n+  }\n+  os::free(orig);\n+  return this;\n+}\n+\n+CgroupMemoryController* CgroupV2MemoryController::adjust_controller(julong phys_mem) {\n+  log_trace(os, container)(\"Adjusting v2 controller path for memory: %s\", reader()->subsystem_path());\n+  assert(reader()->cgroup_path() != nullptr, \"invariant\");\n+  char* orig = os::strdup(reader()->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  jlong limit = read_memory_limit_in_bytes(phys_mem);\n+  bool path_iterated = false;\n+  while (limit < 0 && (last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    reader()->set_subsystem_path(cg_path);\n+    limit = read_memory_limit_in_bytes(phys_mem);\n+    path_iterated = true;\n+    if (limit > 0) {\n+      log_trace(os, container)(\"Adjusted v2 controller path for memory to: %s\", reader()->subsystem_path());\n+      os::free(cg_path);\n+      os::free(orig);\n+      return this;\n+    }\n+  }\n+  \/\/ no lower limit found or limit at leaf\n+  os::free(cg_path);\n+  if (path_iterated) {\n+    reader()->set_subsystem_path((char*)\"\/\");\n+    limit = read_memory_limit_in_bytes(phys_mem);\n+    if (limit > 0) {\n+      \/\/ handle limit set at mount point\n+      log_trace(os, container)(\"Adjusted v2 controller path for memory to: %s\", reader()->subsystem_path());\n+      os::free(orig);\n+      return this;\n+    }\n+    log_trace(os, container)(\"No lower limit found in hierarchy %s, adjusting to original path %s\",\n+                              reader()->mount_point(), orig);\n+    reader()->set_subsystem_path(orig);\n+  } else {\n+    log_trace(os, container)(\"Lowest limit for memory at leaf: %s\",\n+                              reader()->subsystem_path());\n+  }\n+  os::free(orig);\n+  return this;\n+}\n+\n+\/\/ For cgv2 we only need hierarchy walk if the cgroup path isn't '\/' (root)\n+bool CgroupV2Controller::needs_hierarchy_adjustment() {\n+  return strcmp(_cgroup_path, \"\/\") != 0;\n+}\n+\n@@ -275,0 +381,9 @@\n+char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n+  stringStream ss;\n+  ss.print_raw(mount_path);\n+  if (strcmp(cgroup_path, \"\/\") != 0) {\n+    ss.print_raw(cgroup_path);\n+  }\n+  return os::strdup(ss.base());\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -31,0 +32,9 @@\n+  private:\n+    \/* the mount path of the cgroup v2 hierarchy *\/\n+    char *_mount_path;\n+    bool _read_only;\n+\n+    \/* Constructed full path to the subsystem directory *\/\n+    char *_path;\n+    static char* construct_path(char* mount_path, char *cgroup_path);\n+\n@@ -32,1 +42,24 @@\n-    using CgroupController::CgroupController;\n+    CgroupV2Controller(char* mount_path,\n+                       char *cgroup_path,\n+                       bool ro) :  _mount_path(os::strdup(mount_path)),\n+                                   _read_only(ro),\n+                                   _path(construct_path(mount_path, cgroup_path)) {\n+      _cgroup_path = os::strdup(cgroup_path);\n+    }\n+    \/\/ Shallow copy constructor\n+    CgroupV2Controller(const CgroupV2Controller& o) :\n+                                            _mount_path(o._mount_path),\n+                                            _read_only(o._read_only),\n+                                            _path(o._path) {\n+      _cgroup_path = o._cgroup_path;\n+    }\n+    ~CgroupV2Controller() {\n+      \/\/ At least one controller exists with references to the paths\n+    }\n+\n+    char *subsystem_path() override { return _path; }\n+    bool needs_hierarchy_adjustment() override;\n+    \/\/ Allow for optional updates of the subsystem path\n+    void set_subsystem_path(char* cgroup_path);\n+    bool is_read_only() override { return _read_only; }\n+    char * mount_point() { return _mount_path; };\n@@ -48,1 +81,2 @@\n-    void set_subsystem_path(char *cgroup_path) { reader()->set_subsystem_path(cgroup_path); }\n+    bool needs_hierarchy_adjustment() override;\n+    CgroupCpuController* adjust_controller(int host_cpus) override;\n@@ -68,0 +102,2 @@\n+    bool needs_hierarchy_adjustment() override;\n+    CgroupMemoryController* adjust_controller(julong phys_mem) override;\n@@ -71,3 +107,0 @@\n-    bool trim_path(size_t dir_count) override { return reader()->trim_path(dir_count); }\n-    void set_subsystem_path(char *cgroup_path) override { reader()->set_subsystem_path(cgroup_path); }\n-    char* subsystem_path() override { return reader()->subsystem_path(); }\n@@ -85,1 +118,0 @@\n-    bool trim_path(size_t dir_count) override { return unified()->trim_path(dir_count); }\n@@ -88,1 +120,1 @@\n-    CgroupV2Subsystem(CgroupV2MemoryController* memory,\n+    CgroupV2Subsystem(CgroupV2MemoryController * memory,\n@@ -91,4 +123,5 @@\n-        _unified(unified),\n-        _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n-        _cpu(new CachingCgroupController<CgroupCpuController>(cpu)) {\n-      initialize_hierarchy();\n+                         _unified(unified),\n+                         _memory(new CachingCgroupController<CgroupMemoryController>(\n+                                         CgroupUtil::adjust_controller(memory))),\n+                         _cpu(new CachingCgroupController<CgroupCpuController>(\n+                                         CgroupUtil::adjust_controller(cpu))) {\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":44,"deletions":11,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  friend class CgroupUtil;\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-            return Long.MAX_VALUE;\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n@@ -158,1 +158,1 @@\n-            return Long.MAX_VALUE;\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    public static final long OSCONTAINER_ERROR = -2;\n+    public static final long LONG_RETVAL_UNLIMITED = -1;\n@@ -47,5 +47,2 @@\n-        if (strVal == null) {\n-            return CgroupSubsystem.OSCONTAINER_ERROR;\n-        }\n-        if (MAX_VAL.equals(strVal)) {\n-            return Long.MAX_VALUE;\n+        if (strVal == null || MAX_VAL.equals(strVal)) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n@@ -56,15 +53,0 @@\n-    public default void initializeHierarchy(CgroupSubsystemController memory) {\n-\n-        \/\/ Here it ignores any possible lower limit in parent directories.\n-        \/\/ Linux kernel will correctly consider both that but this code does not.\n-        for (int dirCount = 0; memory.trimPath(dirCount); ++dirCount) {\n-            long memoryLimit = getMemoryLimit();\n-            long memorySwapLimit = getMemoryAndSwapLimit();\n-            if ((memoryLimit != Long.MAX_VALUE && memoryLimit != CgroupSubsystem.OSCONTAINER_ERROR)\n-                || (memorySwapLimit != Long.MAX_VALUE && memorySwapLimit != CgroupSubsystem.OSCONTAINER_ERROR)) {\n-                return;\n-            }\n-        }\n-\n-        memory.trimPath(0);\n-    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -43,62 +43,1 @@\n-public abstract class CgroupSubsystemController {\n-\n-    \/\/ Values returned larger than this number are unlimited.\n-    protected static final long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n-\n-    String root;\n-    String mountPoint;\n-    String cgroupPath;\n-    String path;\n-\n-    protected CgroupSubsystemController(String root, String mountPoint) {\n-        this.root = root;\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public void setSubsystemPath(String cgroupPath) {\n-        this.cgroupPath = cgroupPath;\n-        trimPath(0);\n-    }\n-\n-    public void setPath(String cgroupPath) {\n-        \/\/ Do not use the this.cgroupPath variable.\n-        if (root == null || cgroupPath == null) {\n-            return;\n-        }\n-        if (root.equals(\"\/\")) {\n-            if (!cgroupPath.equals(\"\/\")) {\n-                path = mountPoint + cgroupPath;\n-                return;\n-            }\n-            path = mountPoint;\n-            return;\n-        }\n-        if (root.equals(cgroupPath)) {\n-            path = mountPoint;\n-            return;\n-        }\n-        if (!cgroupPath.startsWith(root) || cgroupPath.equals(root) || cgroupPath.charAt(root.length()) != '\/') {\n-            return;\n-        }\n-        String cgroupSubstr = cgroupPath.substring(root.length());\n-        path = mountPoint + cgroupSubstr;\n-    }\n-\n-    public String path() {\n-        return path;\n-    }\n-\n-    public boolean trimPath(int dir_count) {\n-        String cgroupPath = this.cgroupPath;\n-        assert cgroupPath.charAt(0) == '\/';\n-        while (dir_count-- > 0) {\n-            int pos = cgroupPath.lastIndexOf('\/');\n-            assert pos >= 0;\n-            if (pos == 0) {\n-                return false;\n-            }\n-            cgroupPath = cgroupPath.substring(0, pos);\n-        }\n-        path = Paths.get(mountPoint, cgroupPath).toString();\n-        return true;\n-    }\n+public interface CgroupSubsystemController {\n@@ -108,0 +47,2 @@\n+    public String path();\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":3,"deletions":62,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+    private boolean hierarchical;\n@@ -36,0 +37,8 @@\n+    boolean isHierarchical() {\n+        return hierarchical;\n+    }\n+\n+    void setHierarchical(boolean hierarchical) {\n+        this.hierarchical = hierarchical;\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,1 +84,3 @@\n-                    controller.setSubsystemPath(info.getCgroupPath());\n+                    controller.setPath(info.getCgroupPath());\n+                    boolean isHierarchial = getHierarchical(controller);\n+                    controller.setHierarchical(isHierarchial);\n@@ -95,1 +97,1 @@\n-                    controller.setSubsystemPath(info.getCgroupPath());\n+                    controller.setPath(info.getCgroupPath());\n@@ -104,1 +106,1 @@\n-                    controller.setSubsystemPath(info.getCgroupPath());\n+                    controller.setPath(info.getCgroupPath());\n@@ -113,1 +115,1 @@\n-                    controller.setSubsystemPath(info.getCgroupPath());\n+                    controller.setPath(info.getCgroupPath());\n@@ -122,1 +124,1 @@\n-                    controller.setSubsystemPath(info.getCgroupPath());\n+                    controller.setPath(info.getCgroupPath());\n@@ -131,1 +133,1 @@\n-                    controller.setSubsystemPath(info.getCgroupPath());\n+                    controller.setPath(info.getCgroupPath());\n@@ -144,1 +146,0 @@\n-            subsystem.initializeHierarchy(subsystem.memory);\n@@ -158,0 +159,5 @@\n+    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n+        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n+        return hierarchical > 0;\n+    }\n+\n@@ -187,1 +193,1 @@\n-                                                      CgroupSubsystem.OSCONTAINER_ERROR);\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n@@ -242,1 +248,1 @@\n-            return Long.MAX_VALUE;\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n@@ -305,0 +311,10 @@\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memory_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n@@ -352,0 +368,10 @@\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memsw_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,1 +31,8 @@\n-public class CgroupV1SubsystemController extends CgroupSubsystemController {\n+public class CgroupV1SubsystemController implements CgroupSubsystemController {\n+\n+    private static final double DOUBLE_RETVAL_UNLIMITED = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+    \/\/ Values returned larger than this number are unlimited.\n+    static long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n+    String root;\n+    String mountPoint;\n+    String path;\n@@ -34,1 +41,33 @@\n-        super(root, mountPoint);\n+        this.root = root;\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public void setPath(String cgroupPath) {\n+        if (root != null && cgroupPath != null) {\n+            if (root.equals(\"\/\")) {\n+                if (!cgroupPath.equals(\"\/\")) {\n+                    path = mountPoint + cgroupPath;\n+                }\n+                else {\n+                    path = mountPoint;\n+                }\n+            }\n+            else {\n+                if (root.equals(cgroupPath)) {\n+                    path = mountPoint;\n+                }\n+                else {\n+                    if (cgroupPath.startsWith(root)) {\n+                        if (cgroupPath.length() > root.length()) {\n+                            String cgroupSubstr = cgroupPath.substring(root.length());\n+                            path = mountPoint + cgroupSubstr;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n@@ -41,1 +80,1 @@\n-                                                      CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n@@ -47,1 +86,1 @@\n-                                                        CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n+                                                        DOUBLE_RETVAL_UNLIMITED \/* retval on error *\/);\n@@ -53,1 +92,1 @@\n-                                                             CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n@@ -57,1 +96,1 @@\n-        return value > UNLIMITED_MIN ? Long.MAX_VALUE : value;\n+        return value > UNLIMITED_MIN ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : value;\n@@ -67,1 +106,1 @@\n-                                                                  CgroupSubsystem.OSCONTAINER_ERROR);\n+                                                                  CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":46,"deletions":7,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        return getLongVal(file, CgroupSubsystem.OSCONTAINER_ERROR);\n+        return getLongVal(file, CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n@@ -79,4 +79,3 @@\n-            CgroupV2SubsystemController unified = new CgroupV2SubsystemController(\n-                    anyController.getMountRoot(),\n-                    anyController.getMountPoint());\n-            unified.setSubsystemPath(anyController.getCgroupPath());\n+            CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                    anyController.getMountPoint(),\n+                    anyController.getCgroupPath());\n@@ -84,1 +83,0 @@\n-            tmpCgroupSystem.initializeHierarchy(unified);\n@@ -145,1 +143,1 @@\n-            return CgroupSubsystem.OSCONTAINER_ERROR;\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n@@ -150,1 +148,1 @@\n-            return CgroupSubsystem.OSCONTAINER_ERROR;\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n@@ -160,1 +158,1 @@\n-            return Long.MAX_VALUE;\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n@@ -338,1 +336,1 @@\n-            return CgroupSubsystem.OSCONTAINER_ERROR;\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public class CgroupV2SubsystemController extends CgroupSubsystemController {\n+public class CgroupV2SubsystemController implements CgroupSubsystemController {\n@@ -35,2 +35,9 @@\n-    public CgroupV2SubsystemController(String root, String mountPoint) {\n-        super(root, mountPoint);\n+    private final String path;\n+\n+    public CgroupV2SubsystemController(String mountPath, String cgroupPath) {\n+        this.path = Paths.get(mountPath, cgroupPath).toString();\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n@@ -41,2 +48,2 @@\n-                                                             Long.MAX_VALUE \/* overflow retval *\/,\n-                                                             CgroupSubsystem.OSCONTAINER_ERROR \/* default retval on error *\/);\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* overflow retval *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* default retval on error *\/);\n@@ -49,1 +56,1 @@\n-                                                      CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-static char slash[] = \"\/\";\n@@ -75,0 +74,2 @@\n+private:\n+  char* _path;\n@@ -76,2 +77,6 @@\n-  TestController(char* p): CgroupController(slash, slash, true\/*ro*\/) {\n-    set_subsystem_path(p);\n+  TestController(char* p): _path(p) {}\n+  char* subsystem_path() override {\n+    return _path;\n+  };\n+  bool is_read_only() override {\n+    return true; \/\/ doesn't matter\n@@ -79,1 +84,0 @@\n-  TestController() : TestController(slash) {}\n@@ -193,1 +197,1 @@\n-  TestController* null_path_controller = new TestController();\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n@@ -204,2 +208,2 @@\n-  char larger_than_max[MAXPATHLEN + 1] = \"\/\";\n-  for (int i = 1; i < (MAXPATHLEN); i++) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n@@ -229,1 +233,1 @@\n-  TestController* null_path_controller = new TestController();\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n@@ -396,2 +400,2 @@\n-  char larger_than_max[MAXPATHLEN + 1] = \"\/\";\n-  for (int i = 1; i < (MAXPATHLEN); i++) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n@@ -448,1 +452,1 @@\n-    \"\/\",                    \/\/ root_path\n+    nullptr,                \/\/ root_path, ignored\n@@ -454,1 +458,1 @@\n-    \"\/\",                    \/\/ root_path\n+    nullptr,                \/\/ root_path, ignored\n@@ -462,2 +466,2 @@\n-    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->root_path,\n-                                                       (char*)testCases[i]->mount_path,\n+    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n+                                                       (char*)testCases[i]->cgroup_path,\n@@ -465,1 +469,0 @@\n-    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n@@ -470,0 +473,84 @@\n+TEST(cgroupTest, cgroupv2_is_hierarchy_walk_needed) {\n+  bool controller_read_only = false; \/\/ value irrelevant;\n+  CgroupV2Controller* test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                    (char*)\"\/\" \/* cgroup_path *\/,\n+                                                    controller_read_only);\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                            (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                            controller_read_only));\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                       (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                       (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                                  (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                                  controller_read_only));\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                          (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                          (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n+TEST(cgroupTest, cgroupv1_is_hierarchy_walk_needed) {\n+  bool controller_read_only = true; \/\/ shouldn't matter;\n+  CgroupV1Controller* test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                    (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                    controller_read_only);\n+  test->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                (char*)\"\/\"\/* mount_path *\/,\n+                                controller_read_only);\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                            (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                            controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                       (char*)\"\/\"\/* mount_path *\/,\n+                                                       controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                                  (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                                  controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                          (char*)\"\/\"\/* mount_path *\/,\n+                                                          controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":102,"deletions":15,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-        public static final String MEMORY_LIMIT_MB_OUTER = \"500.00M\";\n-        public static final String MEMORY_LIMIT_MB_INNER = \"1000.00M\";\n@@ -65,1 +63,0 @@\n-            String string;\n@@ -172,2 +169,0 @@\n-            \/\/ Java jdk.internal.platform.CgroupSubsystem\n-            output.shouldMatch(\"^ *Memory Limit: \" + limits.string + \"$\");\n@@ -193,1 +188,0 @@\n-            limits.string = MEMORY_LIMIT_MB_INNER;\n@@ -210,1 +204,0 @@\n-            limits.string = MEMORY_LIMIT_MB_OUTER;\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/NestedCgroup.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}