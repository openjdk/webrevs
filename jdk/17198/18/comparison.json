{"files":[{"patch":"@@ -106,0 +106,2 @@\n+  protected:\n+    char* _cgroup_path;\n@@ -109,0 +111,2 @@\n+    char* cgroup_path() { return _cgroup_path; }\n+    virtual bool needs_hierarchy_adjustment() { return false; }\n@@ -199,0 +203,11 @@\n+class CgroupControllerVirt: public CHeapObj<mtInternal> {\n+  public:\n+    virtual bool needs_hierarchy_adjustment() = 0;\n+    virtual bool is_read_only() = 0;\n+    virtual int version() = 0;\n+    virtual char* subsystem_path() = 0;\n+    virtual void set_subsystem_path(char *cgroup_path) = 0;\n+    virtual char* cgroup_path() = 0;\n+    virtual char* mount_point() = 0;\n+};\n+\n@@ -200,1 +215,1 @@\n-class CgroupCpuController: public CHeapObj<mtInternal> {\n+class CgroupCpuController: public CgroupControllerVirt {\n@@ -205,1 +220,0 @@\n-    virtual bool is_read_only() = 0;\n@@ -209,1 +223,1 @@\n-class CgroupMemoryController: public CHeapObj<mtInternal> {\n+class CgroupMemoryController: public CgroupControllerVirt {\n@@ -220,1 +234,0 @@\n-    virtual bool is_read_only() = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"os_linux.hpp\"\n@@ -49,0 +50,92 @@\n+\n+CgroupMemoryController* CgroupUtil::adjust_controller(CgroupMemoryController* mem) {\n+  if (mem->needs_hierarchy_adjustment()) {\n+    julong phys_mem = os::Linux::physical_memory();\n+    log_trace(os, container)(\"Adjusting v%d controller path for memory: %s\", mem->version(), mem->subsystem_path());\n+    assert(mem->cgroup_path() != nullptr, \"invariant\");\n+    char* orig = os::strdup(mem->cgroup_path());\n+    char* cg_path = os::strdup(orig);\n+    char* last_slash;\n+    jlong limit = mem->read_memory_limit_in_bytes(phys_mem);\n+    bool path_iterated = false;\n+    while (limit < 0 && (last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+      *last_slash = '\\0'; \/\/ strip path\n+      \/\/ update to shortened path and try again\n+      mem->set_subsystem_path(cg_path);\n+      limit = mem->read_memory_limit_in_bytes(phys_mem);\n+      path_iterated = true;\n+      if (limit > 0) {\n+        log_trace(os, container)(\"Adjusted v%d controller path for memory to: %s\", mem->version(), mem->subsystem_path());\n+        os::free(cg_path);\n+        os::free(orig);\n+        return mem;\n+      }\n+    }\n+    \/\/ no lower limit found or limit at leaf\n+    os::free(cg_path);\n+    if (path_iterated) {\n+      mem->set_subsystem_path((char*)\"\/\");\n+      limit = mem->read_memory_limit_in_bytes(phys_mem);\n+      if (limit > 0) {\n+        \/\/ handle limit set at mount point\n+        log_trace(os, container)(\"Adjusted v%d controller path for memory to: %s\", mem->version(), mem->subsystem_path());\n+        os::free(orig);\n+        return mem;\n+      }\n+      log_trace(os, container)(\"No lower limit found in hierarchy %s, adjusting to original path %s\",\n+                                mem->mount_point(), orig);\n+      mem->set_subsystem_path(orig);\n+    } else {\n+      log_trace(os, container)(\"Lowest limit for memory at leaf: %s\",\n+                                mem->subsystem_path());\n+    }\n+    os::free(orig);\n+  }\n+  return mem;\n+}\n+\n+CgroupCpuController* CgroupUtil::adjust_controller(CgroupCpuController* cpu) {\n+  if (cpu->needs_hierarchy_adjustment()) {\n+    int cpu_total = os::Linux::active_processor_count();\n+    log_trace(os, container)(\"Adjusting v%d controller path for cpu: %s\", cpu->version(), cpu->subsystem_path());\n+    assert(cpu->cgroup_path() != nullptr, \"invariant\");\n+    assert(cpu_total > 0, \"Negative host cpus?\");\n+    char* orig = os::strdup(cpu->cgroup_path());\n+    char* cg_path = os::strdup(orig);\n+    char* last_slash;\n+    int cpus = CgroupUtil::processor_count(cpu, cpu_total);\n+    bool path_iterated = false;\n+    while (cpus == cpu_total && (last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+      *last_slash = '\\0'; \/\/ strip path\n+      \/\/ update to shortened path and try again\n+      cpu->set_subsystem_path(cg_path);\n+      cpus = CgroupUtil::processor_count(cpu, cpu_total);\n+      path_iterated = true;\n+      if (cpus != cpu_total) {\n+        log_trace(os, container)(\"Adjusted v%d controller path for cpu to: %s\", cpu->version(), cpu->subsystem_path());\n+        os::free(cg_path);\n+        os::free(orig);\n+        return cpu;\n+      }\n+    }\n+    os::free(cg_path);\n+    if (path_iterated) {\n+      cpu->set_subsystem_path((char*)\"\/\");\n+      cpus = CgroupUtil::processor_count(cpu, cpu_total);\n+      if (cpus != cpu_total) {\n+        \/\/ handle limit set at mount point\n+        log_trace(os, container)(\"Adjusted v%d controller path for cpu to: %s\", cpu->version(), cpu->subsystem_path());\n+        os::free(orig);\n+        return cpu;\n+      }\n+      log_trace(os, container)(\"No lower limit found in hierarchy %s, adjusting to original path %s\",\n+                                cpu->mount_point(), orig);\n+      cpu->set_subsystem_path(orig);\n+    } else {\n+      log_trace(os, container)(\"Lowest limit for cpu at leaf: %s\",\n+                                cpu->subsystem_path());\n+    }\n+    os::free(orig);\n+  }\n+  return cpu;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+    \/\/ Iterate over the memory controller hierarchy adjusting the path to the\n+    \/\/ smallest observable limit (if any)\n+    static CgroupMemoryController* adjust_controller(CgroupMemoryController* m);\n+    \/\/ Iterate over the cpu controller hierarchy adjusting the path to the\n+    \/\/ smallest observable limit (if any)\n+    static CgroupCpuController* adjust_controller(CgroupCpuController* c);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,7 @@\n+  if (_cgroup_path != nullptr) {\n+    os::free(_cgroup_path);\n+  }\n+  if (_path != nullptr) {\n+    os::free(_path);\n+  }\n+  _cgroup_path = os::strdup(cgroup_path);\n@@ -69,13 +76,2 @@\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n-jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n-  julong use_hierarchy;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n-  return (jlong)use_hierarchy;\n+bool CgroupV1MemoryController::needs_hierarchy_adjustment() {\n+  return reader()->needs_hierarchy_adjustment();\n@@ -84,6 +80,7 @@\n-void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n-  reader()->set_subsystem_path(cgroup_path);\n-  jlong hierarchy = uses_mem_hierarchy();\n-  if (hierarchy > 0) {\n-    set_hierarchical(true);\n-  }\n+bool CgroupV1CpuController::needs_hierarchy_adjustment() {\n+  return reader()->needs_hierarchy_adjustment();\n+}\n+\n+bool CgroupV1Controller::needs_hierarchy_adjustment() {\n+  assert(_cgroup_path != nullptr, \"sanity\");\n+  return strcmp(_root, _cgroup_path) != 0;\n@@ -118,14 +115,0 @@\n-    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    if (is_hierarchical()) {\n-      julong hier_memlimit;\n-      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n-      if (!is_ok) {\n-        return OSCONTAINER_ERROR;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n-      if (hier_memlimit < phys_mem) {\n-        verbose_log(hier_memlimit, phys_mem);\n-        return (jlong)hier_memlimit;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-    }\n@@ -153,1 +136,0 @@\n-  julong hier_memswlimit;\n@@ -157,16 +139,1 @@\n-    log_trace(os, container)(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n-    if (is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n-                                                           matchline,\n-                                                           &hier_memswlimit);\n-      if (!is_ok) {\n-        return OSCONTAINER_ERROR;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n-      if (hier_memswlimit >= host_total_memsw) {\n-        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memswlimit;\n-      }\n-    }\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":17,"deletions":50,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -51,0 +52,1 @@\n+      _cgroup_path = nullptr;\n@@ -57,0 +59,1 @@\n+      _cgroup_path = o._cgroup_path;\n@@ -64,2 +67,4 @@\n-    char *subsystem_path() override { return _path; }\n-    bool is_read_only() { return _read_only; }\n+    char* subsystem_path() override { return _path; }\n+    bool is_read_only() override { return _read_only; }\n+    bool needs_hierarchy_adjustment() override;\n+    char *mount_point() { return _mount_point; }\n@@ -74,2 +79,4 @@\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_subsystem_path(char *cgroup_path);\n+    char* subsystem_path() override { return reader()->subsystem_path(); }\n+    void set_subsystem_path(char *cgroup_path) override {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n@@ -88,0 +95,1 @@\n+    bool needs_hierarchy_adjustment() override;\n@@ -91,0 +99,3 @@\n+    int version() override { return 1; }\n+    char* cgroup_path() override { return reader()->cgroup_path(); }\n+    char* mount_point() override { return reader()->mount_point(); }\n@@ -92,6 +103,0 @@\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-    jlong uses_mem_hierarchy();\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n@@ -103,2 +108,1 @@\n-      : _reader(reader),\n-        _uses_mem_hierarchy(false) {\n+      : _reader(reader) {\n@@ -118,1 +122,2 @@\n-    void set_subsystem_path(char *cgroup_path) {\n+    char* subsystem_path() override { return reader()->subsystem_path(); }\n+    void set_subsystem_path(char *cgroup_path) override {\n@@ -124,0 +129,3 @@\n+    int version() override { return 1; }\n+    char* cgroup_path() override { return reader()->cgroup_path(); }\n+    char* mount_point() override { return reader()->mount_point(); }\n@@ -128,0 +136,1 @@\n+    bool needs_hierarchy_adjustment() override;\n@@ -164,1 +173,2 @@\n-      _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+      _memory(new CachingCgroupController<CgroupMemoryController>(\n+                                         CgroupUtil::adjust_controller(memory))),\n@@ -166,1 +176,2 @@\n-      _cpu(new CachingCgroupController<CgroupCpuController>(cpu)),\n+      _cpu(new CachingCgroupController<CgroupCpuController>(\n+                                         CgroupUtil::adjust_controller(cpu))),\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -267,0 +267,20 @@\n+void CgroupV2Controller::set_subsystem_path(char* cgroup_path) {\n+  if (_path != nullptr) {\n+    os::free(_path);\n+  }\n+  _path = construct_path(_mount_path, cgroup_path);\n+}\n+\n+bool CgroupV2MemoryController::needs_hierarchy_adjustment() {\n+  return reader()->needs_hierarchy_adjustment();\n+}\n+\n+bool CgroupV2CpuController::needs_hierarchy_adjustment() {\n+  return reader()->needs_hierarchy_adjustment();\n+}\n+\n+\/\/ For cgv2 we only need hierarchy walk if the cgroup path isn't '\/' (root)\n+bool CgroupV2Controller::needs_hierarchy_adjustment() {\n+  return strcmp(_cgroup_path, \"\/\") != 0;\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -34,2 +35,0 @@\n-    \/* The cgroup path for the controller *\/\n-    char *_cgroup_path;\n@@ -46,1 +45,0 @@\n-                                   _cgroup_path(os::strdup(cgroup_path)),\n@@ -49,0 +47,1 @@\n+      _cgroup_path = os::strdup(cgroup_path);\n@@ -53,1 +52,0 @@\n-                                            _cgroup_path(o._cgroup_path),\n@@ -56,0 +54,1 @@\n+      _cgroup_path = o._cgroup_path;\n@@ -62,0 +61,3 @@\n+    bool needs_hierarchy_adjustment() override;\n+    \/\/ Allow for optional updates of the subsystem path\n+    void set_subsystem_path(char* cgroup_path);\n@@ -63,0 +65,1 @@\n+    char * mount_point() { return _mount_path; };\n@@ -78,0 +81,8 @@\n+    int version() override { return 2; }\n+    char* subsystem_path() override { return reader()->subsystem_path(); }\n+    void set_subsystem_path(char* cgroup_path) override {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    char* cgroup_path() override { return reader()->cgroup_path(); }\n+    char* mount_point() override { return reader()->mount_point(); }\n+    bool needs_hierarchy_adjustment() override;\n@@ -97,0 +108,1 @@\n+    bool needs_hierarchy_adjustment() override;\n@@ -100,0 +112,7 @@\n+    int version() override { return 2; }\n+    char* subsystem_path() override { return reader()->subsystem_path(); }\n+    void set_subsystem_path(char* cgroup_path) override {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    char* cgroup_path() override { return reader()->cgroup_path(); }\n+    char* mount_point() override { return reader()->mount_point(); }\n@@ -116,3 +135,5 @@\n-        _unified(unified),\n-        _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n-        _cpu(new CachingCgroupController<CgroupCpuController>(cpu)) {\n+                         _unified(unified),\n+                         _memory(new CachingCgroupController<CgroupMemoryController>(\n+                                         CgroupUtil::adjust_controller(memory))),\n+                         _cpu(new CachingCgroupController<CgroupCpuController>(\n+                                         CgroupUtil::adjust_controller(cpu))) {\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  friend class CgroupUtil;\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -473,0 +473,84 @@\n+TEST(cgroupTest, cgroupv2_is_hierarchy_walk_needed) {\n+  bool controller_read_only = false; \/\/ value irrelevant;\n+  CgroupV2Controller* test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                    (char*)\"\/\" \/* cgroup_path *\/,\n+                                                    controller_read_only);\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                            (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                            controller_read_only));\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                       (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                       (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                                  (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                                  controller_read_only));\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                          (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                          (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n+TEST(cgroupTest, cgroupv1_is_hierarchy_walk_needed) {\n+  bool controller_read_only = true; \/\/ shouldn't matter;\n+  CgroupV1Controller* test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                    (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                    controller_read_only);\n+  test->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                (char*)\"\/\"\/* mount_path *\/,\n+                                controller_read_only);\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                            (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                            controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                       (char*)\"\/\"\/* mount_path *\/,\n+                                                       controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                                  (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                                  controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                          (char*)\"\/\"\/* mount_path *\/,\n+                                                          controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    vm.cgroup.tools \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test NestedCgroup\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @requires vm.cgroup.tools\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/testlibrary \/test\/lib\n+ * @run main\/othervm NestedCgroup\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.IllegalArgumentException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import jdk.internal.platform.Metrics;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+public class NestedCgroup {\n+    private static abstract class Test {\n+        public static final String CGROUP_OUTER = \"jdktest\" + ProcessHandle.current().pid();\n+        public static final String CGROUP_INNER = \"inner\";\n+        public static final String CONTROLLERS_PATH_OUTER = \"memory:\" + CGROUP_OUTER;\n+        public static final String CONTROLLERS_PATH_INNER = CONTROLLERS_PATH_OUTER + \"\/\" + CGROUP_INNER;\n+        public static final String LINE_DELIM = \"-\".repeat(80);\n+        public static final String MOUNTINFO = \"\/proc\/self\/mountinfo\";\n+\n+        \/\/ A real usage on x86_64 fits in 39 MiB.\n+        public static final int MEMORY_MAX_OUTER = 500 * 1024 * 1024;\n+        public static final int MEMORY_MAX_INNER = MEMORY_MAX_OUTER * 2;\n+\n+        class Limits {\n+            int integer;\n+        };\n+\n+        public static String sysFsCgroup;\n+        public String memory_max_filename;\n+        public static boolean isCgroup2;\n+\n+        public static void lineDelim(String str, String label) {\n+            System.err.print(LINE_DELIM + \" \" + label + \"\\n\" + str);\n+            if (!str.isEmpty() && !str.endsWith(\"\\n\")) {\n+                System.err.println();\n+            }\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args,\n+                String failStderr, String failExplanation,\n+                String fail2Stderr, String fail2Explanation,\n+                String ignoreStderr) throws Exception {\n+            System.err.println(LINE_DELIM + \" command: \" + String.join(\" \",args));\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process process = pb.start();\n+            OutputAnalyzer output = new OutputAnalyzer(process);\n+            int exitValue = process.waitFor();\n+            lineDelim(output.getStdout(), \"stdout\");\n+            lineDelim(output.getStderr(), \"stderr\");\n+            System.err.println(LINE_DELIM);\n+            if (!failStderr.isEmpty() && output.getStderr().equals(failStderr + \"\\n\")) {\n+                throw new SkippedException(failExplanation + \": \" + failStderr);\n+            }\n+            if (!fail2Stderr.isEmpty() && output.getStderr().equals(fail2Stderr + \"\\n\")) {\n+                throw new SkippedException(fail2Explanation + \": \" + fail2Stderr);\n+            }\n+            if (!ignoreStderr.isEmpty() && output.getStderr().equals(ignoreStderr + \"\\n\")) {\n+                return output;\n+            }\n+            Asserts.assertEQ(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+            return output;\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args) throws Exception {\n+            return pSystem(args, \"\", \"\", \"\", \"\", \"\");\n+        }\n+\n+        public static void args_add_cgexec(List<String> args) {\n+            args.add(\"cgexec\");\n+            args.add(\"-g\");\n+            args.add(CONTROLLERS_PATH_INNER);\n+        }\n+\n+        public static String jdkTool;\n+\n+        public static void args_add_self(List<String> args) {\n+            args.add(jdkTool);\n+            args.add(\"-cp\");\n+            args.add(System.getProperty(\"java.class.path\"));\n+        }\n+\n+        public static void args_add_self_verbose(List<String> args) {\n+            args_add_self(args);\n+            args.add(\"-XshowSettings:system\");\n+            args.add(\"-Xlog:os+container=trace\");\n+        }\n+\n+        public Test() throws Exception {\n+            List<String> cgdelete = new ArrayList<>();\n+            cgdelete.add(\"cgdelete\");\n+            cgdelete.add(\"-r\");\n+            cgdelete.add(\"-g\");\n+            cgdelete.add(CONTROLLERS_PATH_OUTER);\n+            try {\n+                pSystem(cgdelete,\n+                    \"cgdelete: libcgroup initialization failed: Cgroup is not mounted\", \"cgroup\/cgroup2 is not mounted\",\n+                    \"\", \"\",\n+                    \"cgdelete: cannot remove group '\" + CGROUP_OUTER + \"': No such file or directory\");\n+            } catch (IOException e) {\n+                if (e.toString().equals(\"java.io.IOException: Cannot run program \\\"cgdelete\\\": error=2, No such file or directory\")) {\n+                    throw new SkippedException(\"libcgroup-tools is not installed\");\n+                }\n+                throw e;\n+            }\n+\n+            \/\/ Alpine Linux 3.20.1 needs cgcreate1 otherwise:\n+            \/\/ cgcreate: can't create cgroup CONTROLLERS_PATH_INNER: No such file or directory\n+            List<String> cgcreate1 = new ArrayList<>();\n+            cgcreate1.add(\"cgcreate\");\n+            cgcreate1.add(\"-g\");\n+            cgcreate1.add(CONTROLLERS_PATH_OUTER);\n+            pSystem(cgcreate1,\n+                \"cgcreate: can't create cgroup \" + CGROUP_OUTER + \": Cgroup, operation not allowed\", \"Missing root permission\",\n+                \"cgcreate: can't create cgroup \" + CGROUP_OUTER + \": Cgroup, requested group parameter does not exist\", \"Missing root permission\",\n+                \"\");\n+\n+            List<String> cgcreate2 = new ArrayList<>();\n+            cgcreate2.add(\"cgcreate\");\n+            cgcreate2.add(\"-g\");\n+            cgcreate2.add(CONTROLLERS_PATH_INNER);\n+            pSystem(cgcreate2, \"\", \"\", \"\", \"\", \"\");\n+\n+            String provider = Metrics.systemMetrics().getProvider();\n+            System.err.println(\"Metrics.systemMetrics().getProvider() = \" + provider);\n+            boolean isCgroup2;\n+            if (\"cgroupv1\".equals(provider)) {\n+              isCgroup2 = false;\n+            } else if (\"cgroupv2\".equals(provider)) {\n+              isCgroup2 = true;\n+            } else {\n+              throw new IllegalArgumentException();\n+            }\n+            System.err.println(\"isCgroup2 = \" + isCgroup2);\n+\n+            String mountInfo;\n+            try {\n+                mountInfo = Files.readString(Path.of(MOUNTINFO));\n+            } catch (NoSuchFileException e) {\n+                throw new SkippedException(\"Cannot open \" + MOUNTINFO);\n+            }\n+\n+            Matcher matcher = Pattern.compile(\"^(?:\\\\S+\\\\s+){4}(\\\\S+)\\\\s.*\\\\scgroup(?:2(?:\\\\s+\\\\S+){2}|\\\\s+\\\\S+\\\\s+(?:\\\\S*,)?memory(?:,\\\\S*)?)$\", Pattern.MULTILINE).matcher(mountInfo);\n+            if (!matcher.find()) {\n+                System.err.println(mountInfo);\n+                throw new SkippedException(\"cgroup\/cgroup2 filesystem mount point not found\");\n+            }\n+            sysFsCgroup = matcher.group(1);\n+            System.err.println(\"sysFsCgroup = \" + sysFsCgroup);\n+\n+            System.err.println(LINE_DELIM + \" \" + (isCgroup2 ? \"cgroup2\" : \"cgroup1\") + \" mount point: \" + sysFsCgroup);\n+            memory_max_filename = isCgroup2 ? \"memory.max\" : \"memory.limit_in_bytes\";\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_OUTER);\n+\n+            \/\/ Here starts a copy of ProcessTools.createJavaProcessBuilder.\n+            List<String> cgexec = new ArrayList<>();\n+            Limits limits = hook(cgexec);\n+            OutputAnalyzer output = pSystem(cgexec);\n+            \/\/ C++ CgroupController\n+            output.shouldMatch(\"\\\\[trace\\\\]\\\\[os,container\\\\] Memory Limit is: \" + limits.integer + \"$\");\n+\n+            pSystem(cgdelete);\n+        }\n+\n+        public abstract Limits hook(List<String> cgexec) throws IOException;\n+    }\n+    private static class TestTwoLimits extends Test {\n+        public Limits hook(List<String> cgexec) throws IOException {\n+            \/\/ CgroupV1Subsystem::read_memory_limit_in_bytes considered hierarchical_memory_limit only when inner memory.limit_in_bytes is unlimited.\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_INNER);\n+\n+            args_add_cgexec(cgexec);\n+            args_add_self_verbose(cgexec);\n+            cgexec.add(\"-version\");\n+\n+            \/\/ KFAIL - verify the CgroupSubsystem::initialize_hierarchy() and jdk.internal.platform.CgroupSubsystem.initializeHierarchy() bug\n+            \/\/ TestTwoLimits does not see the lower MEMORY_MAX_OUTER limit.\n+            Limits limits = new Limits();\n+            limits.integer = MEMORY_MAX_INNER;\n+            return limits;\n+        }\n+        public TestTwoLimits() throws Exception {\n+        }\n+    }\n+    private static class TestNoController extends Test {\n+        public Limits hook(List<String> cgexec) throws IOException {\n+            args_add_cgexec(cgexec);\n+            args_add_self(cgexec);\n+            cgexec.add(\"NestedCgroup\");\n+            cgexec.add(\"TestNoController\");\n+            cgexec.add(Test.jdkTool);\n+            cgexec.add(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/cgroup.subtree_control\");\n+\n+            Limits limits = new Limits();\n+            limits.integer = MEMORY_MAX_OUTER;\n+            return limits;\n+        }\n+        public TestNoController() throws Exception {\n+        }\n+        public static void child(String arg) throws Exception {\n+            Files.writeString(Path.of(arg), \"-memory\");\n+\n+            List<String> self_verbose = new ArrayList<>();\n+            args_add_self_verbose(self_verbose);\n+            self_verbose.add(\"-version\");\n+            pSystem(self_verbose);\n+        }\n+    }\n+    public static void main(String[] args) throws Exception {\n+        switch (args.length) {\n+            case 0:\n+                Test.jdkTool = JDKToolFinder.getJDKTool(\"java\");\n+                new TestTwoLimits();\n+                if (Test.isCgroup2) {\n+                    new TestNoController();\n+                }\n+                return;\n+            case 3:\n+                switch (args[0]) {\n+                    case \"TestNoController\":\n+                        Test.jdkTool = args[1];\n+                        TestNoController.child(args[2]);\n+                        return;\n+                }\n+        }\n+        throw new IllegalArgumentException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/NestedCgroup.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -141,0 +141,1 @@\n+        map.put(\"vm.cgroup.tools\", this::cgroupTools);\n@@ -782,0 +783,15 @@\n+    private String cgroupTools() {\n+        ProcessBuilder pb = new ProcessBuilder(\"cgcreate\",\"-h\");\n+        pb.redirectErrorStream(true);\n+        int exitCode = -1;\n+        try {\n+            Process process = pb.start();\n+            exitCode = process.waitFor();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+        return \"\" + (exitCode == 0);\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}