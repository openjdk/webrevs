{"files":[{"patch":"@@ -66,1 +66,1 @@\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    CgroupV2Controller* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,0 +92,12 @@\n+  CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+  if (mem_controller->is_hierarchical()) {\n+    GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n+                           \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n+    \/\/ Backward compatibility:\n+    log_trace(os, container)(\"Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n+    if (hier_memlimit >= os::Linux::physical_memory()) {\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n+      return (jlong)-1;\n+    }\n+    return (jlong)hier_memlimit;\n+  }\n@@ -97,10 +109,0 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n@@ -109,3 +111,1 @@\n-  else {\n-    return (jlong)memlimit;\n-  }\n+  return (jlong)memlimit;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, _hierarchical_supported ? \"\/memory.swap.max.effective\" : \"\/memory.swap.max\",\n@@ -218,1 +218,1 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, _hierarchical_supported ? \"\/memory.max.effective\" : \"\/memory.max\",\n@@ -276,0 +276,63 @@\n+\n+\/* trim\n+ *\n+ * Remove specific dir_count number of trailing _cgroup_path directories\n+ *\n+ * return:\n+ *    whether dir_count was < number of _cgroup_path directories\n+ *    false is returned if the result would be cgroup root directory\n+ *\/\n+bool CgroupV2Controller::trim(size_t dir_count) {\n+  char *cgroup_path = os::strdup(_cgroup_path);\n+  assert(cgroup_path[0] == '\/', \"_cgroup_path should start with a slash ('\/')\");\n+  while (dir_count--) {\n+    char *s = strrchr(cgroup_path, '\/');\n+    assert(s, \"function should have already returned\");\n+    *s = 0;\n+    if (s == cgroup_path) {\n+      os::free(cgroup_path);\n+      return false;\n+    }\n+  }\n+  os::free(_path);\n+  _path = construct_path(_mount_path, cgroup_path);\n+  os::free(cgroup_path);\n+  return true;\n+}\n+\n+CgroupV2Subsystem::CgroupV2Subsystem(CgroupV2Controller * unified) {\n+  _unified = unified;\n+  _memory = new CachingCgroupController(unified);\n+  _cpu = new CachingCgroupController(unified);\n+\n+  _hierarchical_supported = true;\n+  jlong memory_limit = limit_from_str(mem_limit_val());\n+  if (memory_limit != OSCONTAINER_ERROR) {\n+    return;\n+  }\n+  \/\/ Older kernels did not support \"memory.max.effective\" (and \"memory.swap.max.effective\").\n+  _hierarchical_supported = false;\n+\n+  size_t best_level = 0;\n+  jlong memory_limit_min = max_jlong;\n+  jlong swap_limit_min = max_jlong;\n+\n+  for (size_t dir_count = 0; _unified->trim(dir_count); ++dir_count) {\n+    jlong memory_limit = limit_from_str(mem_limit_val());\n+    if (memory_limit != -1 && memory_limit != OSCONTAINER_ERROR && memory_limit < memory_limit_min) {\n+      memory_limit_min = memory_limit;\n+      best_level = dir_count;\n+    }\n+    jlong swap_limit = limit_from_str(mem_swp_limit_val());\n+    if (swap_limit != -1 && swap_limit != OSCONTAINER_ERROR && swap_limit < swap_limit_min) {\n+      swap_limit_min = swap_limit;\n+      best_level = dir_count;\n+    }\n+    \/\/ Never use a directory without controller files (disabled by \"..\/cgroup.subtree_control\").\n+    if (memory_limit == OSCONTAINER_ERROR && swap_limit == OSCONTAINER_ERROR && best_level == dir_count) {\n+      ++best_level;\n+    }\n+  }\n+\n+  _unified->trim(best_level);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":65,"deletions":2,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-      _mount_path = mount_path;\n+      _mount_path = os::strdup(mount_path);\n@@ -47,0 +47,6 @@\n+    ~CgroupV2Controller() {\n+      os::free(_mount_path);\n+      os::free(_cgroup_path);\n+      os::free(_path);\n+    }\n+    bool trim(size_t dir_count);\n@@ -54,1 +60,1 @@\n-    CgroupController* _unified = nullptr;\n+    CgroupV2Controller* _unified = nullptr;\n@@ -58,0 +64,1 @@\n+    bool _hierarchical_supported = false;\n@@ -67,5 +74,1 @@\n-    CgroupV2Subsystem(CgroupController * unified) {\n-      _unified = unified;\n-      _memory = new CachingCgroupController(unified);\n-      _cpu = new CachingCgroupController(unified);\n-    }\n+    CgroupV2Subsystem(CgroupV2Controller * unified);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -310,10 +310,9 @@\n-        long retval = getLongValue(memory, \"memory.limit_in_bytes\");\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n+        long retval;\n+        if (memory.isHierarchical()) {\n+            \/\/ Hierarchical limit is the one used by Linux kernel, prefer it.\n+            String match = \"hierarchical_memory_limit\";\n+            retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                                          \"memory.stat\",\n+                                                                          match);\n+        } else {\n+            retval = getLongValue(memory, \"memory.limit_in_bytes\");\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private final CgroupSubsystemController unified;\n+    private final CgroupV2SubsystemController unified;\n@@ -50,0 +50,1 @@\n+    private static boolean _hierarchical_supported = false;\n@@ -51,1 +52,1 @@\n-    private CgroupV2Subsystem(CgroupSubsystemController unified) {\n+    private CgroupV2Subsystem(CgroupV2SubsystemController unified) {\n@@ -53,0 +54,32 @@\n+\n+        _hierarchical_supported = true;\n+        if (getMemoryLimitStr() != null) {\n+            return ;\n+        }\n+        \/\/ Older kernels did not support \"memory.max.effective\" (and \"memory.swap.max.effective\").\n+        _hierarchical_supported = false;\n+\n+        int bestLevel = 0;\n+        long memoryLimitMin = Long.MAX_VALUE;\n+        long swapLimitMin = Long.MAX_VALUE;\n+\n+        for (int dirCount = 0; unified.trim(dirCount); ++dirCount) {\n+            String memoryLimitStr = getMemoryLimitStr();\n+            long memoryLimit = CgroupSubsystem.limitFromString(memoryLimitStr);\n+            if (memoryLimit != CgroupSubsystem.LONG_RETVAL_UNLIMITED && memoryLimit < memoryLimitMin) {\n+                memoryLimitMin = memoryLimit;\n+                bestLevel = dirCount;\n+            }\n+            String swapLimitStr = getSwapLimitStr();\n+            long swapLimit = CgroupSubsystem.limitFromString(swapLimitStr);\n+            if (swapLimit != CgroupSubsystem.LONG_RETVAL_UNLIMITED && swapLimit < swapLimitMin) {\n+                swapLimitMin = swapLimit;\n+                bestLevel = dirCount;\n+            }\n+            \/\/ Never use a directory without controller files (disabled by \"..\/cgroup.subtree_control\").\n+            if (memoryLimitStr == null && swapLimitStr == null && bestLevel == dirCount) {\n+                ++bestLevel;\n+            }\n+        }\n+\n+        unified.trim(bestLevel);\n@@ -79,1 +112,1 @@\n-            CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+            CgroupV2SubsystemController unified = new CgroupV2SubsystemController(\n@@ -243,0 +276,4 @@\n+    private String getMemoryLimitStr() {\n+        return CgroupSubsystemController.getStringValue(unified, _hierarchical_supported ? \"memory.max.effective\" : \"memory.max\");\n+    }\n+\n@@ -245,2 +282,1 @@\n-        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.max\");\n-        return CgroupSubsystem.limitFromString(strVal);\n+        return CgroupSubsystem.limitFromString(getMemoryLimitStr());\n@@ -259,0 +295,4 @@\n+    private String getSwapLimitStr() {\n+        return CgroupSubsystemController.getStringValue(unified, _hierarchical_supported ? \"memory.swap.max.effective\" : \"memory.swap.max\");\n+    }\n+\n@@ -268,1 +308,1 @@\n-        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.swap.max\");\n+        String strVal = getSwapLimitStr();\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":46,"deletions":6,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-    private final String path;\n+    private final String _mountPath, _cgroupPath;\n+    private String path;\n@@ -38,1 +39,18 @@\n-        this.path = Paths.get(mountPath, cgroupPath).toString();\n+        _mountPath = mountPath;\n+        _cgroupPath = cgroupPath;\n+        path = Paths.get(mountPath, cgroupPath).toString();\n+    }\n+\n+    public boolean trim(int dir_count) {\n+        String cgroupPath = _cgroupPath;\n+        assert cgroupPath.charAt(0) == '\/';\n+        while (dir_count-- > 0) {\n+            int pos = cgroupPath.lastIndexOf('\/');\n+            assert pos >= 0;\n+            if (pos == 0) {\n+                return false;\n+            }\n+            cgroupPath = cgroupPath.substring(0, pos);\n+        }\n+        path = Paths.get(_mountPath, cgroupPath).toString();\n+        return true;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test NestedCgroup\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/testlibrary \/test\/lib\n+ * @run main\/othervm NestedCgroup\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Asserts;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.nio.file.Files;\n+import jtreg.SkippedException;\n+import java.nio.file.Path;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import java.nio.file.NoSuchFileException;\n+import java.io.IOException;\n+import java.lang.IllegalArgumentException;\n+\n+public class NestedCgroup {\n+    private static abstract class Test {\n+        public static final String CGROUP_OUTER = \"jdktest\" + ProcessHandle.current().pid();\n+        public static final String CGROUP_INNER = \"inner\";\n+        public static final String CONTROLLERS_PATH_OUTER = \"memory:\" + CGROUP_OUTER;\n+        public static final String CONTROLLERS_PATH_INNER = CONTROLLERS_PATH_OUTER + \"\/\" + CGROUP_INNER;\n+        public static final String LINE_DELIM = \"-\".repeat(80);\n+        public static final String MOUNTINFO = \"\/proc\/self\/mountinfo\";\n+\n+        \/\/ A real usage on x86_64 fits in 39 MiB.\n+        public static final int MEMORY_MAX_OUTER = 500 * 1024 * 1024;\n+        public static final int MEMORY_MAX_INNER = MEMORY_MAX_OUTER * 2;\n+        public static final String MEMORY_LIMIT_MB = \"500.00M\";\n+\n+        public static String sysFsCgroup;\n+        public String memory_max_filename;\n+        public static boolean isCgroup2;\n+\n+        public static void lineDelim(String str, String label) {\n+            System.err.print(LINE_DELIM + \" \" + label + \"\\n\" + str);\n+            if (!str.isEmpty() && !str.endsWith(\"\\n\")) {\n+                System.err.println();\n+            }\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args, String failStderr, String failExplanation, String ignoreStderr) throws Exception {\n+            System.err.println(LINE_DELIM + \" command: \" + String.join(\" \",args));\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process process = pb.start();\n+            OutputAnalyzer output = new OutputAnalyzer(process);\n+            int exitValue = process.waitFor();\n+            lineDelim(output.getStdout(), \"stdout\");\n+            lineDelim(output.getStderr(), \"stderr\");\n+            System.err.println(LINE_DELIM);\n+            if (!failStderr.isEmpty() && output.getStderr().equals(failStderr + \"\\n\")) {\n+                throw new SkippedException(failExplanation + \": \" + failStderr);\n+            }\n+            if (!ignoreStderr.isEmpty() && output.getStderr().equals(ignoreStderr + \"\\n\")) {\n+                return output;\n+            }\n+            Asserts.assertEQ(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+            return output;\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args) throws Exception {\n+            return pSystem(args, \"\", \"\", \"\");\n+        }\n+\n+        public static void args_add_cgexec(List<String> args) {\n+            args.add(\"cgexec\");\n+            args.add(\"-g\");\n+            args.add(CONTROLLERS_PATH_INNER);\n+        }\n+\n+        public static String jdkTool;\n+\n+        public static void args_add_self(List<String> args) {\n+            args.add(jdkTool);\n+            args.add(\"-cp\");\n+            args.add(System.getProperty(\"java.class.path\"));\n+        }\n+\n+        public static void args_add_self_verbose(List<String> args) {\n+            args_add_self(args);\n+            args.add(\"-XshowSettings:system\");\n+            args.add(\"-Xlog:os+container=trace\");\n+        }\n+\n+        public Test() throws Exception {\n+            List<String> cgdelete = new ArrayList<>();\n+            cgdelete.add(\"cgdelete\");\n+            cgdelete.add(\"-r\");\n+            cgdelete.add(\"-g\");\n+            cgdelete.add(CONTROLLERS_PATH_OUTER);\n+            try {\n+                pSystem(cgdelete,\n+                    \"cgdelete: libcgroup initialization failed: Cgroup is not mounted\", \"cgroup\/cgroup2 is not mounted\",\n+                    \"cgdelete: cannot remove group '\" + CGROUP_OUTER + \"': No such file or directory\");\n+            } catch (IOException e) {\n+                if (e.toString().equals(\"java.io.IOException: Cannot run program \\\"cgdelete\\\": error=2, No such file or directory\")) {\n+                    throw new SkippedException(\"libcgroup-tools is not installed\");\n+                }\n+                throw e;\n+            }\n+\n+            List<String> cgcreate = new ArrayList<>();\n+            cgcreate.add(\"cgcreate\");\n+            cgcreate.add(\"-g\");\n+            cgcreate.add(CONTROLLERS_PATH_INNER);\n+            pSystem(cgcreate, \"cgcreate: can't create cgroup \" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \": Cgroup, operation not allowed\", \"Missing root permission\", \"\");\n+\n+            String mountInfo;\n+            try {\n+                mountInfo = Files.readString(Path.of(MOUNTINFO));\n+            } catch (NoSuchFileException e) {\n+                throw new SkippedException(\"Cannot open \" + MOUNTINFO);\n+            }\n+\n+            Matcher matcher = Pattern.compile(\"^(?:\\\\S+\\\\s+){4}(\\\\S+)\\\\s.*\\\\scgroup(?:(2)(?:\\\\s+\\\\S+){2}|\\\\s+\\\\S+\\\\s+(?:\\\\S*,)?memory(?:,\\\\S*)?)$\", Pattern.MULTILINE).matcher(mountInfo);\n+            if (!matcher.find()) {\n+                System.err.println(mountInfo);\n+                throw new SkippedException(\"cgroup\/cgroup2 filesystem mount point not found\");\n+            }\n+            sysFsCgroup = matcher.group(1);\n+            isCgroup2 = matcher.group(2) != null;\n+\n+            System.err.println(LINE_DELIM + \" \" + (isCgroup2 ? \"cgroup2\" : \"cgroup1\") + \" mount point: \" + sysFsCgroup);\n+            memory_max_filename = isCgroup2 ? \"memory.max\" : \"memory.limit_in_bytes\";\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_OUTER);\n+\n+            \/\/ Here starts a copy of ProcessTools.createJavaProcessBuilder.\n+            List<String> cgexec = new ArrayList<>();\n+            hook(cgexec);\n+            OutputAnalyzer output = pSystem(cgexec);\n+            output.shouldMatch(\"^ *Memory Limit: \" + MEMORY_LIMIT_MB + \"$\");\n+            output.shouldMatch(\"\\\\[trace\\\\]\\\\[os,container\\\\] \" + (isCgroup2 ? \"\" : \"Hierarchical \") + \"Memory Limit is: \" + MEMORY_MAX_OUTER + \"$\");\n+\n+            pSystem(cgdelete);\n+        }\n+\n+        public abstract void hook(List<String> cgexec) throws IOException;\n+    }\n+    private static class TestTwoLimits extends Test {\n+        public void hook(List<String> cgexec) throws IOException {\n+            \/\/ CgroupV1Subsystem::read_memory_limit_in_bytes considered hierarchical_memory_limit only when inner memory.limit_in_bytes is unlimited.\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_INNER);\n+\n+            args_add_cgexec(cgexec);\n+            args_add_self_verbose(cgexec);\n+            cgexec.add(\"-version\");\n+        }\n+        public TestTwoLimits() throws Exception {\n+        }\n+    }\n+    private static class TestNoController extends Test {\n+        public void hook(List<String> cgexec) throws IOException {\n+            args_add_cgexec(cgexec);\n+            args_add_self(cgexec);\n+            cgexec.add(\"NestedCgroup\");\n+            cgexec.add(\"TestNoController\");\n+            cgexec.add(Test.jdkTool);\n+            cgexec.add(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/cgroup.subtree_control\");\n+        }\n+        public TestNoController() throws Exception {\n+        }\n+        public static void child(String arg) throws Exception {\n+            Files.writeString(Path.of(arg), \"-memory\");\n+\n+            List<String> self_verbose = new ArrayList<>();\n+            args_add_self_verbose(self_verbose);\n+            self_verbose.add(\"-version\");\n+            pSystem(self_verbose);\n+        }\n+    }\n+    public static void main(String[] args) throws Exception {\n+        switch (args.length) {\n+            case 0:\n+                Test.jdkTool = JDKToolFinder.getJDKTool(\"java\");\n+                new TestTwoLimits();\n+                if (Test.isCgroup2) {\n+                    new TestNoController();\n+                }\n+                return;\n+            case 3:\n+                switch (args[0]) {\n+                    case \"TestNoController\":\n+                        Test.jdkTool = args[1];\n+                        TestNoController.child(args[2]);\n+                        return;\n+                }\n+        }\n+        throw new IllegalArgumentException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/NestedCgroup.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}