{"files":[{"patch":"@@ -67,3 +67,5 @@\n-    CgroupV2Controller mem_other = CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path,\n-                                                      cg_infos[MEMORY_IDX]._cgroup_path,\n-                                                      cg_infos[MEMORY_IDX]._read_only);\n+    const CgroupInfo &cg_info_memory = cg_infos[MEMORY_IDX];\n+    CgroupV2Controller mem_other = CgroupV2Controller(cg_info_memory._root_mount_path,\n+                                                      cg_info_memory._mount_path,\n+                                                      cg_info_memory._read_only);\n+    mem_other.set_subsystem_path(cg_info_memory._cgroup_path);\n@@ -71,3 +73,5 @@\n-    CgroupV2CpuController* cpu = new CgroupV2CpuController(CgroupV2Controller(cg_infos[CPU_IDX]._mount_path,\n-                                                                              cg_infos[CPU_IDX]._cgroup_path,\n-                                                                              cg_infos[CPU_IDX]._read_only));\n+    const CgroupInfo &cg_info_cpu = cg_infos[CPU_IDX];\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(CgroupV2Controller(cg_info_cpu._root_mount_path,\n+                                                                              cg_info_cpu._mount_path,\n+                                                                              cg_info_cpu._read_only));\n+    cpu->set_subsystem_path(cg_info_cpu._cgroup_path);\n@@ -820,0 +824,97 @@\n+\n+\/*\n+ * Set directory to subsystem specific files based\n+ * on the contents of the mountinfo and cgroup files.\n+ *\/\n+void CgroupController::set_subsystem_path(char *cgroup_path) {\n+  os::free(_cgroup_path);\n+  _cgroup_path = os::strdup(cgroup_path);\n+  trim_path(0);\n+}\n+\n+void CgroupController::set_path(const char *cgroup_path) {\n+  __attribute__((unused)) bool _cgroup_path; \/\/ Do not use the member variable.\n+  stringStream ss;\n+  if (_root == nullptr || cgroup_path == nullptr) {\n+    return;\n+  }\n+  if (strcmp(_root, \"\/\") == 0) {\n+    ss.print_raw(_mount_point);\n+    if (strcmp(cgroup_path, \"\/\") != 0) {\n+      ss.print_raw(cgroup_path);\n+    }\n+    os::free(_path);\n+    _path = os::strdup(ss.base());\n+    return;\n+  }\n+  if (strcmp(_root, cgroup_path) == 0) {\n+    os::free(_path);\n+    _path = os::strdup(_mount_point);\n+    return;\n+  }\n+  if (strlen(cgroup_path) == strlen(_root)) {\n+    return;\n+  }\n+  if (strncmp(cgroup_path, _root, strlen(_root)) != 0 || cgroup_path[strlen(_root)] != '\/') {\n+    return;\n+  }\n+  ss.print_raw(_mount_point);\n+  const char* cg_path_sub = cgroup_path + strlen(_root);\n+  ss.print_raw(cg_path_sub);\n+  os::free(_path);\n+  _path = os::strdup(ss.base());\n+}\n+\n+\/* trim_path\n+ *\n+ * Remove specific dir_count number of trailing _cgroup_path directories\n+ *\n+ * return:\n+ *    whether dir_count was < number of _cgroup_path directories\n+ *    false is returned if the result would be cgroup root directory\n+ *\/\n+bool CgroupController::trim_path(size_t dir_count) {\n+  char *cgroup_path = os::strdup(_cgroup_path);\n+  assert(cgroup_path[0] == '\/', \"_cgroup_path should start with a slash ('\/')\");\n+  while (dir_count--) {\n+    char *s = strrchr(cgroup_path, '\/');\n+    assert(s, \"function should have already returned\");\n+    *s = 0;\n+    if (s == cgroup_path) {\n+      os::free(cgroup_path);\n+      return false;\n+    }\n+  }\n+  set_path(cgroup_path);\n+  os::free(cgroup_path);\n+  return true;\n+}\n+\n+void CgroupSubsystem::initialize_hierarchy() {\n+  size_t best_level = 0;\n+  jlong memory_limit_min = max_jlong;\n+  jlong memory_swap_limit_min = max_jlong;\n+\n+  for (size_t dir_count = 0; memory_controller()->trim_path(dir_count); ++dir_count) {\n+    log_trace(os, container)(\"initialize_hierarchy: dir_count = %zu, best_level = %zu, subsystem_path = %s\",\n+                             dir_count, best_level, memory_controller()->subsystem_path());\n+    jlong memory_limit = memory_limit_in_bytes();\n+    if (memory_limit != -1 && memory_limit != OSCONTAINER_ERROR && memory_limit < memory_limit_min) {\n+      memory_limit_min = memory_limit;\n+      best_level = dir_count;\n+    }\n+    jlong memory_swap_limit = memory_and_swap_limit_in_bytes();\n+    if (memory_swap_limit != -1 && memory_swap_limit != OSCONTAINER_ERROR && memory_swap_limit < memory_swap_limit_min) {\n+      memory_swap_limit_min = memory_swap_limit;\n+      best_level = dir_count;\n+    }\n+    \/\/ Never use a directory without controller files (disabled by \"..\/cgroup.subtree_control\").\n+    if (memory_limit == OSCONTAINER_ERROR && memory_swap_limit == OSCONTAINER_ERROR && best_level == dir_count) {\n+      ++best_level;\n+    }\n+  }\n+\n+  memory_controller()->trim_path(best_level);\n+  log_trace(os, container)(\"initialize_hierarchy: best_level = %zu, subsystem_path = %s\",\n+                           best_level, memory_controller()->subsystem_path());\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":107,"deletions":6,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -106,0 +106,12 @@\n+  protected:\n+    void set_path(const char *cgroup_path);\n+\n+    \/* mountinfo contents *\/\n+    char *_root;\n+    char *_mount_point;\n+    bool _read_only;\n+    char *_cgroup_path = nullptr;\n+\n+    \/* Constructed subsystem directory *\/\n+    char *_path = nullptr;\n+\n@@ -107,2 +119,3 @@\n-    virtual char* subsystem_path() = 0;\n-    virtual bool is_read_only() = 0;\n+    void set_subsystem_path(char *cgroup_path);\n+    char* subsystem_path() { return _path; }\n+    bool is_read_only() { return _read_only; }\n@@ -155,0 +168,24 @@\n+    CgroupController(char *root,\n+                     char *mountpoint,\n+                     bool ro) : _root(os::strdup(root)),\n+                                _mount_point(os::strdup(mountpoint)),\n+                                _read_only(ro) {\n+    }\n+    CgroupController(const CgroupController& o) : _root(os::strdup(o._root)),\n+                                                  _mount_point(os::strdup(o._mount_point)),\n+                                                  _read_only(o._read_only),\n+                                                  _cgroup_path(!o._cgroup_path ? nullptr : os::strdup(o._cgroup_path)),\n+                                                  _path(!o._path ? nullptr : os::strdup(o._path)) {\n+    }\n+    CgroupController& operator=(const CgroupController& o) = delete;\n+    ~CgroupController() {\n+      \/\/ At least one subsystem controller exists with paths to malloc'd path\n+      \/\/ names\n+      os::free(_root);\n+      os::free(_mount_point);\n+      os::free(_cgroup_path);\n+      os::free(_path);\n+    }\n+\n+    bool trim_path(size_t dir_count);\n+\n@@ -197,0 +234,5 @@\n+    bool trim_path(size_t dir_count) {\n+      _metrics_cache = new CachedMetric();\n+      return controller()->trim_path(dir_count);\n+    }\n+    char* subsystem_path() { return controller()->subsystem_path(); }\n@@ -221,0 +263,3 @@\n+    virtual bool trim_path(size_t dir_count) = 0;\n+    virtual void set_subsystem_path(char *cgroup_path) = 0;\n+    virtual char* subsystem_path() = 0;\n@@ -224,0 +269,2 @@\n+  protected:\n+    void initialize_hierarchy();\n@@ -250,0 +297,2 @@\n+\n+    virtual bool trim_path(size_t dir_count) = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -37,47 +37,0 @@\n-\/*\n- * Set directory to subsystem specific files based\n- * on the contents of the mountinfo and cgroup files.\n- *\/\n-void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n-  stringStream ss;\n-  if (_root != nullptr && cgroup_path != nullptr) {\n-    if (strcmp(_root, \"\/\") == 0) {\n-      ss.print_raw(_mount_point);\n-      if (strcmp(cgroup_path,\"\/\") != 0) {\n-        ss.print_raw(cgroup_path);\n-      }\n-      _path = os::strdup(ss.base());\n-    } else {\n-      if (strcmp(_root, cgroup_path) == 0) {\n-        ss.print_raw(_mount_point);\n-        _path = os::strdup(ss.base());\n-      } else {\n-        char *p = strstr(cgroup_path, _root);\n-        if (p != nullptr && p == _root) {\n-          if (strlen(cgroup_path) > strlen(_root)) {\n-            ss.print_raw(_mount_point);\n-            const char* cg_path_sub = cgroup_path + strlen(_root);\n-            ss.print_raw(cg_path_sub);\n-            _path = os::strdup(ss.base());\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n-jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n-  julong use_hierarchy;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n-  return (jlong)use_hierarchy;\n-}\n-\n@@ -86,4 +39,0 @@\n-  jlong hierarchy = uses_mem_hierarchy();\n-  if (hierarchy > 0) {\n-    set_hierarchical(true);\n-  }\n@@ -119,12 +68,4 @@\n-    if (is_hierarchical()) {\n-      julong hier_memlimit;\n-      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n-      if (!is_ok) {\n-        return OSCONTAINER_ERROR;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n-      if (hier_memlimit < phys_mem) {\n-        verbose_log(hier_memlimit, phys_mem);\n-        return (jlong)hier_memlimit;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n+    julong hier_memlimit;\n+    bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n+    if (!is_ok) {\n+      return OSCONTAINER_ERROR;\n@@ -132,0 +73,6 @@\n+    log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n+    if (hier_memlimit < phys_mem) {\n+      verbose_log(hier_memlimit, phys_mem);\n+      return (jlong)hier_memlimit;\n+    }\n+    log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n@@ -158,14 +105,12 @@\n-    if (is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n-                                                           matchline,\n-                                                           &hier_memswlimit);\n-      if (!is_ok) {\n-        return OSCONTAINER_ERROR;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n-      if (hier_memswlimit >= host_total_memsw) {\n-        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memswlimit;\n-      }\n+    const char* matchline = \"hierarchical_memsw_limit\";\n+    bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n+                                                         matchline,\n+                                                         &hier_memswlimit);\n+    if (!is_ok) {\n+      return OSCONTAINER_ERROR;\n+    }\n+    log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n+    if (hier_memswlimit >= host_total_memsw) {\n+      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n+    } else {\n+      return (jlong)hier_memswlimit;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":22,"deletions":77,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -35,9 +35,0 @@\n-  private:\n-    \/* mountinfo contents *\/\n-    char* _root;\n-    char* _mount_point;\n-    bool _read_only;\n-\n-    \/* Constructed subsystem directory *\/\n-    char* _path;\n-\n@@ -45,21 +36,1 @@\n-    CgroupV1Controller(char *root,\n-                       char *mountpoint,\n-                       bool ro) : _root(os::strdup(root)),\n-                                  _mount_point(os::strdup(mountpoint)),\n-                                  _read_only(ro),\n-                                  _path(nullptr) {\n-    }\n-    \/\/ Shallow copy constructor\n-    CgroupV1Controller(const CgroupV1Controller& o) : _root(o._root),\n-                                                      _mount_point(o._mount_point),\n-                                                      _read_only(o._read_only),\n-                                                      _path(o._path) {\n-    }\n-    ~CgroupV1Controller() {\n-      \/\/ At least one subsystem controller exists with paths to malloc'd path\n-      \/\/ names\n-    }\n-\n-    void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() override { return _path; }\n-    bool is_read_only() { return _read_only; }\n+    using CgroupController::CgroupController;\n@@ -74,1 +45,0 @@\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n@@ -91,0 +61,2 @@\n+    bool trim_path(size_t dir_count) override { return reader()->trim_path(dir_count); }\n+    char* subsystem_path() override { return reader()->subsystem_path(); }\n@@ -92,6 +64,0 @@\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-    jlong uses_mem_hierarchy();\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n@@ -103,2 +69,1 @@\n-      : _reader(reader),\n-        _uses_mem_hierarchy(false) {\n+      : _reader(reader) {\n@@ -143,0 +108,1 @@\n+    bool trim_path(size_t dir_count) override { return _memory->controller()->trim_path(dir_count); }\n@@ -169,0 +135,1 @@\n+      initialize_hierarchy();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":6,"deletions":39,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -275,9 +275,0 @@\n-char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n-  stringStream ss;\n-  ss.print_raw(mount_path);\n-  if (strcmp(cgroup_path, \"\/\") != 0) {\n-    ss.print_raw(cgroup_path);\n-  }\n-  return os::strdup(ss.base());\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,11 +31,0 @@\n-  private:\n-    \/* the mount path of the cgroup v2 hierarchy *\/\n-    char *_mount_path;\n-    \/* The cgroup path for the controller *\/\n-    char *_cgroup_path;\n-    bool _read_only;\n-\n-    \/* Constructed full path to the subsystem directory *\/\n-    char *_path;\n-    static char* construct_path(char* mount_path, char *cgroup_path);\n-\n@@ -43,20 +32,1 @@\n-    CgroupV2Controller(char* mount_path,\n-                       char *cgroup_path,\n-                       bool ro) :  _mount_path(os::strdup(mount_path)),\n-                                   _cgroup_path(os::strdup(cgroup_path)),\n-                                   _read_only(ro),\n-                                   _path(construct_path(mount_path, cgroup_path)) {\n-    }\n-    \/\/ Shallow copy constructor\n-    CgroupV2Controller(const CgroupV2Controller& o) :\n-                                            _mount_path(o._mount_path),\n-                                            _cgroup_path(o._cgroup_path),\n-                                            _read_only(o._read_only),\n-                                            _path(o._path) {\n-    }\n-    ~CgroupV2Controller() {\n-      \/\/ At least one controller exists with references to the paths\n-    }\n-\n-    char *subsystem_path() override { return _path; }\n-    bool is_read_only() override { return _read_only; }\n+    using CgroupController::CgroupController;\n@@ -78,0 +48,1 @@\n+    void set_subsystem_path(char *cgroup_path) { reader()->set_subsystem_path(cgroup_path); }\n@@ -100,0 +71,3 @@\n+    bool trim_path(size_t dir_count) override { return reader()->trim_path(dir_count); }\n+    void set_subsystem_path(char *cgroup_path) override { reader()->set_subsystem_path(cgroup_path); }\n+    char* subsystem_path() override { return reader()->subsystem_path(); }\n@@ -111,0 +85,1 @@\n+    bool trim_path(size_t dir_count) override { return unified()->trim_path(dir_count); }\n@@ -119,0 +94,1 @@\n+      initialize_hierarchy();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":7,"deletions":31,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n@@ -158,1 +158,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    public static final long LONG_RETVAL_UNLIMITED = -1;\n+    public static final long OSCONTAINER_ERROR = -2;\n@@ -47,2 +47,5 @@\n-        if (strVal == null || MAX_VAL.equals(strVal)) {\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        if (strVal == null) {\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n+        }\n+        if (MAX_VAL.equals(strVal)) {\n+            return Long.MAX_VALUE;\n@@ -53,0 +56,15 @@\n+    public default void initializeHierarchy(CgroupSubsystemController memory) {\n+\n+        \/\/ Here it ignores any possible lower limit in parent directories.\n+        \/\/ Linux kernel will correctly consider both that but this code does not.\n+        for (int dirCount = 0; memory.trimPath(dirCount); ++dirCount) {\n+            long memoryLimit = getMemoryLimit();\n+            long memorySwapLimit = getMemoryAndSwapLimit();\n+            if ((memoryLimit != Long.MAX_VALUE && memoryLimit != CgroupSubsystem.OSCONTAINER_ERROR)\n+                || (memorySwapLimit != Long.MAX_VALUE && memorySwapLimit != CgroupSubsystem.OSCONTAINER_ERROR)) {\n+                return;\n+            }\n+        }\n+\n+        memory.trimPath(0);\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-public interface CgroupSubsystemController {\n+public abstract class CgroupSubsystemController {\n@@ -45,1 +45,17 @@\n-    public static final String EMPTY_STR = \"\";\n+    \/\/ Values returned larger than this number are unlimited.\n+    protected static final long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n+\n+    String root;\n+    String mountPoint;\n+    String cgroupPath;\n+    String path;\n+\n+    protected CgroupSubsystemController(String root, String mountPoint) {\n+        this.root = root;\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public void setSubsystemPath(String cgroupPath) {\n+        this.cgroupPath = cgroupPath;\n+        trimPath(0);\n+    }\n@@ -47,1 +63,44 @@\n-    public String path();\n+    public void setPath(String cgroupPath) {\n+        \/\/ Do not use the this.cgroupPath variable.\n+        if (root == null || cgroupPath == null) {\n+            return;\n+        }\n+        if (root.equals(\"\/\")) {\n+            if (!cgroupPath.equals(\"\/\")) {\n+                path = mountPoint + cgroupPath;\n+                return;\n+            }\n+            path = mountPoint;\n+            return;\n+        }\n+        if (root.equals(cgroupPath)) {\n+            path = mountPoint;\n+            return;\n+        }\n+        if (!cgroupPath.startsWith(root) || cgroupPath.equals(root) || cgroupPath.charAt(root.length()) != '\/') {\n+            return;\n+        }\n+        String cgroupSubstr = cgroupPath.substring(root.length());\n+        path = mountPoint + cgroupSubstr;\n+    }\n+\n+    public String path() {\n+        return path;\n+    }\n+\n+    public boolean trimPath(int dir_count) {\n+        String cgroupPath = this.cgroupPath;\n+        assert cgroupPath.charAt(0) == '\/';\n+        while (dir_count-- > 0) {\n+            int pos = cgroupPath.lastIndexOf('\/');\n+            assert pos >= 0;\n+            if (pos == 0) {\n+                return false;\n+            }\n+            cgroupPath = cgroupPath.substring(0, pos);\n+        }\n+        path = Paths.get(mountPoint, cgroupPath).toString();\n+        return true;\n+    }\n+\n+    public static final String EMPTY_STR = \"\";\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-    private boolean hierarchical;\n@@ -37,8 +36,0 @@\n-    boolean isHierarchical() {\n-        return hierarchical;\n-    }\n-\n-    void setHierarchical(boolean hierarchical) {\n-        this.hierarchical = hierarchical;\n-    }\n-\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,3 +84,1 @@\n-                    controller.setPath(info.getCgroupPath());\n-                    boolean isHierarchial = getHierarchical(controller);\n-                    controller.setHierarchical(isHierarchial);\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -97,1 +95,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -106,1 +104,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -115,1 +113,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -124,1 +122,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -133,1 +131,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -146,0 +144,1 @@\n+            subsystem.initializeHierarchy(subsystem.memory);\n@@ -159,5 +158,0 @@\n-    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n-        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n-        return hierarchical > 0;\n-    }\n-\n@@ -193,1 +187,1 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+                                                      CgroupSubsystem.OSCONTAINER_ERROR);\n@@ -248,1 +242,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n@@ -311,10 +305,0 @@\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n-        }\n@@ -368,10 +352,0 @@\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memsw_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n-        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,8 +31,1 @@\n-public class CgroupV1SubsystemController implements CgroupSubsystemController {\n-\n-    private static final double DOUBLE_RETVAL_UNLIMITED = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-    \/\/ Values returned larger than this number are unlimited.\n-    static long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n-    String root;\n-    String mountPoint;\n-    String path;\n+public class CgroupV1SubsystemController extends CgroupSubsystemController {\n@@ -41,33 +34,1 @@\n-        this.root = root;\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public void setPath(String cgroupPath) {\n-        if (root != null && cgroupPath != null) {\n-            if (root.equals(\"\/\")) {\n-                if (!cgroupPath.equals(\"\/\")) {\n-                    path = mountPoint + cgroupPath;\n-                }\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n-                }\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String path() {\n-        return path;\n+        super(root, mountPoint);\n@@ -80,1 +41,1 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                      CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n@@ -86,1 +47,1 @@\n-                                                        DOUBLE_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                        CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n@@ -92,1 +53,1 @@\n-                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                             CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n@@ -96,1 +57,1 @@\n-        return value > UNLIMITED_MIN ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : value;\n+        return value > UNLIMITED_MIN ? Long.MAX_VALUE : value;\n@@ -106,1 +67,1 @@\n-                                                                  CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+                                                                  CgroupSubsystem.OSCONTAINER_ERROR);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":7,"deletions":46,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        return getLongVal(file, CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+        return getLongVal(file, CgroupSubsystem.OSCONTAINER_ERROR);\n@@ -79,3 +79,4 @@\n-            CgroupSubsystemController unified = new CgroupV2SubsystemController(\n-                    anyController.getMountPoint(),\n-                    anyController.getCgroupPath());\n+            CgroupV2SubsystemController unified = new CgroupV2SubsystemController(\n+                    anyController.getMountRoot(),\n+                    anyController.getMountPoint());\n+            unified.setSubsystemPath(anyController.getCgroupPath());\n@@ -83,0 +84,1 @@\n+            tmpCgroupSystem.initializeHierarchy(unified);\n@@ -143,1 +145,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n@@ -148,1 +150,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n@@ -158,1 +160,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n@@ -336,1 +338,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public class CgroupV2SubsystemController implements CgroupSubsystemController {\n+public class CgroupV2SubsystemController extends CgroupSubsystemController {\n@@ -35,9 +35,2 @@\n-    private final String path;\n-\n-    public CgroupV2SubsystemController(String mountPath, String cgroupPath) {\n-        this.path = Paths.get(mountPath, cgroupPath).toString();\n-    }\n-\n-    @Override\n-    public String path() {\n-        return path;\n+    public CgroupV2SubsystemController(String root, String mountPoint) {\n+        super(root, mountPoint);\n@@ -48,2 +41,2 @@\n-                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* overflow retval *\/,\n-                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* default retval on error *\/);\n+                                                             Long.MAX_VALUE \/* overflow retval *\/,\n+                                                             CgroupSubsystem.OSCONTAINER_ERROR \/* default retval on error *\/);\n@@ -56,1 +49,1 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                      CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+static char slash[] = \"\/\";\n@@ -74,2 +75,0 @@\n-private:\n-  char* _path;\n@@ -77,6 +76,2 @@\n-  TestController(char* p): _path(p) {}\n-  char* subsystem_path() override {\n-    return _path;\n-  };\n-  bool is_read_only() override {\n-    return true; \/\/ doesn't matter\n+  TestController(char* p): CgroupController(slash, slash, true\/*ro*\/) {\n+    set_subsystem_path(p);\n@@ -84,0 +79,1 @@\n+  TestController() : TestController(slash) {}\n@@ -197,1 +193,1 @@\n-  TestController* null_path_controller = new TestController((char*)nullptr);\n+  TestController* null_path_controller = new TestController();\n@@ -208,2 +204,2 @@\n-  char larger_than_max[MAXPATHLEN + 1];\n-  for (int i = 0; i < (MAXPATHLEN); i++) {\n+  char larger_than_max[MAXPATHLEN + 1] = \"\/\";\n+  for (int i = 1; i < (MAXPATHLEN); i++) {\n@@ -233,1 +229,1 @@\n-  TestController* null_path_controller = new TestController((char*)nullptr);\n+  TestController* null_path_controller = new TestController();\n@@ -400,2 +396,2 @@\n-  char larger_than_max[MAXPATHLEN + 1];\n-  for (int i = 0; i < (MAXPATHLEN); i++) {\n+  char larger_than_max[MAXPATHLEN + 1] = \"\/\";\n+  for (int i = 1; i < (MAXPATHLEN); i++) {\n@@ -452,1 +448,1 @@\n-    nullptr,                \/\/ root_path, ignored\n+    \"\/\",                    \/\/ root_path\n@@ -458,1 +454,1 @@\n-    nullptr,                \/\/ root_path, ignored\n+    \"\/\",                    \/\/ root_path\n@@ -466,2 +462,2 @@\n-    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n-                                                       (char*)testCases[i]->cgroup_path,\n+    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->root_path,\n+                                                       (char*)testCases[i]->mount_path,\n@@ -469,0 +465,1 @@\n+    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test NestedCgroup\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/testlibrary \/test\/lib\n+ * @run main\/othervm NestedCgroup\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Asserts;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.nio.file.Files;\n+import jtreg.SkippedException;\n+import java.nio.file.Path;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import java.nio.file.NoSuchFileException;\n+import java.io.IOException;\n+import java.lang.IllegalArgumentException;\n+\n+public class NestedCgroup {\n+    private static abstract class Test {\n+        public static final String CGROUP_OUTER = \"jdktest\" + ProcessHandle.current().pid();\n+        public static final String CGROUP_INNER = \"inner\";\n+        public static final String CONTROLLERS_PATH_OUTER = \"memory:\" + CGROUP_OUTER;\n+        public static final String CONTROLLERS_PATH_INNER = CONTROLLERS_PATH_OUTER + \"\/\" + CGROUP_INNER;\n+        public static final String LINE_DELIM = \"-\".repeat(80);\n+        public static final String MOUNTINFO = \"\/proc\/self\/mountinfo\";\n+\n+        \/\/ A real usage on x86_64 fits in 39 MiB.\n+        public static final int MEMORY_MAX_OUTER = 500 * 1024 * 1024;\n+        public static final int MEMORY_MAX_INNER = MEMORY_MAX_OUTER * 2;\n+        public static final String MEMORY_LIMIT_MB_OUTER = \"500.00M\";\n+        public static final String MEMORY_LIMIT_MB_INNER = \"1000.00M\";\n+\n+        class Limits {\n+            String string;\n+            int integer;\n+        };\n+\n+        public static String sysFsCgroup;\n+        public String memory_max_filename;\n+        public static boolean isCgroup2;\n+\n+        public static void lineDelim(String str, String label) {\n+            System.err.print(LINE_DELIM + \" \" + label + \"\\n\" + str);\n+            if (!str.isEmpty() && !str.endsWith(\"\\n\")) {\n+                System.err.println();\n+            }\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args, String failStderr, String failExplanation, String ignoreStderr) throws Exception {\n+            System.err.println(LINE_DELIM + \" command: \" + String.join(\" \",args));\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process process = pb.start();\n+            OutputAnalyzer output = new OutputAnalyzer(process);\n+            int exitValue = process.waitFor();\n+            lineDelim(output.getStdout(), \"stdout\");\n+            lineDelim(output.getStderr(), \"stderr\");\n+            System.err.println(LINE_DELIM);\n+            if (!failStderr.isEmpty() && output.getStderr().equals(failStderr + \"\\n\")) {\n+                throw new SkippedException(failExplanation + \": \" + failStderr);\n+            }\n+            if (!ignoreStderr.isEmpty() && output.getStderr().equals(ignoreStderr + \"\\n\")) {\n+                return output;\n+            }\n+            Asserts.assertEQ(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+            return output;\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args) throws Exception {\n+            return pSystem(args, \"\", \"\", \"\");\n+        }\n+\n+        public static void args_add_cgexec(List<String> args) {\n+            args.add(\"cgexec\");\n+            args.add(\"-g\");\n+            args.add(CONTROLLERS_PATH_INNER);\n+        }\n+\n+        public static String jdkTool;\n+\n+        public static void args_add_self(List<String> args) {\n+            args.add(jdkTool);\n+            args.add(\"-cp\");\n+            args.add(System.getProperty(\"java.class.path\"));\n+        }\n+\n+        public static void args_add_self_verbose(List<String> args) {\n+            args_add_self(args);\n+            args.add(\"-XshowSettings:system\");\n+            args.add(\"-Xlog:os+container=trace\");\n+        }\n+\n+        public Test() throws Exception {\n+            List<String> cgdelete = new ArrayList<>();\n+            cgdelete.add(\"cgdelete\");\n+            cgdelete.add(\"-r\");\n+            cgdelete.add(\"-g\");\n+            cgdelete.add(CONTROLLERS_PATH_OUTER);\n+            try {\n+                pSystem(cgdelete,\n+                    \"cgdelete: libcgroup initialization failed: Cgroup is not mounted\", \"cgroup\/cgroup2 is not mounted\",\n+                    \"cgdelete: cannot remove group '\" + CGROUP_OUTER + \"': No such file or directory\");\n+            } catch (IOException e) {\n+                if (e.toString().equals(\"java.io.IOException: Cannot run program \\\"cgdelete\\\": error=2, No such file or directory\")) {\n+                    throw new SkippedException(\"libcgroup-tools is not installed\");\n+                }\n+                throw e;\n+            }\n+\n+            List<String> cgcreate = new ArrayList<>();\n+            cgcreate.add(\"cgcreate\");\n+            cgcreate.add(\"-g\");\n+            cgcreate.add(CONTROLLERS_PATH_INNER);\n+            pSystem(cgcreate, \"cgcreate: can't create cgroup \" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \": Cgroup, operation not allowed\", \"Missing root permission\", \"\");\n+\n+            String mountInfo;\n+            try {\n+                mountInfo = Files.readString(Path.of(MOUNTINFO));\n+            } catch (NoSuchFileException e) {\n+                throw new SkippedException(\"Cannot open \" + MOUNTINFO);\n+            }\n+\n+            Matcher matcher = Pattern.compile(\"^(?:\\\\S+\\\\s+){4}(\\\\S+)\\\\s.*\\\\scgroup(?:(2)(?:\\\\s+\\\\S+){2}|\\\\s+\\\\S+\\\\s+(?:\\\\S*,)?memory(?:,\\\\S*)?)$\", Pattern.MULTILINE).matcher(mountInfo);\n+            if (!matcher.find()) {\n+                System.err.println(mountInfo);\n+                throw new SkippedException(\"cgroup\/cgroup2 filesystem mount point not found\");\n+            }\n+            sysFsCgroup = matcher.group(1);\n+            isCgroup2 = matcher.group(2) != null;\n+            System.err.println(\"isCgroup2 = \" + isCgroup2);\n+\n+            System.err.println(LINE_DELIM + \" \" + (isCgroup2 ? \"cgroup2\" : \"cgroup1\") + \" mount point: \" + sysFsCgroup);\n+            memory_max_filename = isCgroup2 ? \"memory.max\" : \"memory.limit_in_bytes\";\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_OUTER);\n+\n+            \/\/ Here starts a copy of ProcessTools.createJavaProcessBuilder.\n+            List<String> cgexec = new ArrayList<>();\n+            Limits limits = hook(cgexec);\n+            OutputAnalyzer output = pSystem(cgexec);\n+            \/\/ C++ CgroupController\n+            output.shouldMatch(\"\\\\[trace\\\\]\\\\[os,container\\\\] Memory Limit is: \" + limits.integer + \"$\");\n+            \/\/ Java jdk.internal.platform.CgroupSubsystem\n+            output.shouldMatch(\"^ *Memory Limit: \" + limits.string + \"$\");\n+\n+            pSystem(cgdelete);\n+        }\n+\n+        public abstract Limits hook(List<String> cgexec) throws IOException;\n+    }\n+    private static class TestTwoLimits extends Test {\n+        public Limits hook(List<String> cgexec) throws IOException {\n+            \/\/ CgroupV1Subsystem::read_memory_limit_in_bytes considered hierarchical_memory_limit only when inner memory.limit_in_bytes is unlimited.\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_INNER);\n+\n+            args_add_cgexec(cgexec);\n+            args_add_self_verbose(cgexec);\n+            cgexec.add(\"-version\");\n+\n+            \/\/ KFAIL - verify the CgroupSubsystem::initialize_hierarchy() and jdk.internal.platform.CgroupSubsystem.initializeHierarchy() bug\n+            \/\/ TestTwoLimits does not see the lower MEMORY_MAX_OUTER limit.\n+            Limits limits = new Limits();\n+            limits.integer = MEMORY_MAX_INNER;\n+            limits.string = MEMORY_LIMIT_MB_INNER;\n+            return limits;\n+        }\n+        public TestTwoLimits() throws Exception {\n+        }\n+    }\n+    private static class TestNoController extends Test {\n+        public Limits hook(List<String> cgexec) throws IOException {\n+            args_add_cgexec(cgexec);\n+            args_add_self(cgexec);\n+            cgexec.add(\"NestedCgroup\");\n+            cgexec.add(\"TestNoController\");\n+            cgexec.add(Test.jdkTool);\n+            cgexec.add(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/cgroup.subtree_control\");\n+\n+            Limits limits = new Limits();\n+            limits.integer = MEMORY_MAX_OUTER;\n+            limits.string = MEMORY_LIMIT_MB_OUTER;\n+            return limits;\n+        }\n+        public TestNoController() throws Exception {\n+        }\n+        public static void child(String arg) throws Exception {\n+            Files.writeString(Path.of(arg), \"-memory\");\n+\n+            List<String> self_verbose = new ArrayList<>();\n+            args_add_self_verbose(self_verbose);\n+            self_verbose.add(\"-version\");\n+            pSystem(self_verbose);\n+        }\n+    }\n+    public static void main(String[] args) throws Exception {\n+        switch (args.length) {\n+            case 0:\n+                Test.jdkTool = JDKToolFinder.getJDKTool(\"java\");\n+                new TestTwoLimits();\n+                if (Test.isCgroup2) {\n+                    new TestNoController();\n+                }\n+                return;\n+            case 3:\n+                switch (args[0]) {\n+                    case \"TestNoController\":\n+                        Test.jdkTool = args[1];\n+                        TestNoController.child(args[2]);\n+                        return;\n+                }\n+        }\n+        throw new IllegalArgumentException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/NestedCgroup.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"}]}