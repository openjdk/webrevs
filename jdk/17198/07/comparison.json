{"files":[{"patch":"@@ -42,1 +42,1 @@\n-  CgroupV1MemoryController* memory = nullptr;\n+  CgroupV1Controller* memory = nullptr;\n@@ -66,1 +66,3 @@\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    const CgroupInfo &cg_info_memory = cg_infos[MEMORY_IDX];\n+    CgroupController* unified = new CgroupV2Controller(cg_info_memory._root_mount_path, cg_info_memory._mount_path);\n+    unified->set_subsystem_path(cg_info_memory._cgroup_path);\n@@ -103,1 +105,1 @@\n-        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+        memory = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n@@ -577,0 +579,95 @@\n+\n+\/*\n+ * Set directory to subsystem specific files based\n+ * on the contents of the mountinfo and cgroup files.\n+ *\/\n+void CgroupController::set_subsystem_path(const char *cgroup_path) {\n+  os::free(_cgroup_path);\n+  _cgroup_path = os::strdup(cgroup_path);\n+  trim_path(0);\n+}\n+\n+void CgroupController::set_path(const char *cgroup_path) {\n+  __attribute__((unused)) bool _cgroup_path; \/\/ Do not use the member variable.\n+  stringStream ss;\n+  if (_root == nullptr || cgroup_path == nullptr) {\n+    return;\n+  }\n+  if (strcmp(_root, \"\/\") == 0) {\n+    ss.print_raw(_mount_point);\n+    if (strcmp(cgroup_path, \"\/\") != 0) {\n+      ss.print_raw(cgroup_path);\n+    }\n+    os::free(_path);\n+    _path = os::strdup(ss.base());\n+    return;\n+  }\n+  if (strcmp(_root, cgroup_path) == 0) {\n+    os::free(_path);\n+    _path = os::strdup(_mount_point);\n+    return;\n+  }\n+  if (strlen(cgroup_path) == strlen(_root)) {\n+    return;\n+  }\n+  if (strncmp(cgroup_path, _root, strlen(_root)) != 0 || cgroup_path[strlen(_root)] != '\/') {\n+    return;\n+  }\n+  ss.print_raw(_mount_point);\n+  const char* cg_path_sub = cgroup_path + strlen(_root);\n+  ss.print_raw(cg_path_sub);\n+  os::free(_path);\n+  _path = os::strdup(ss.base());\n+}\n+\n+\/* trim_path\n+ *\n+ * Remove specific dir_count number of trailing _cgroup_path directories\n+ *\n+ * return:\n+ *    whether dir_count was < number of _cgroup_path directories\n+ *    false is returned if the result would be cgroup root directory\n+ *\/\n+bool CgroupController::trim_path(size_t dir_count) {\n+  char *cgroup_path = os::strdup(_cgroup_path);\n+  assert(cgroup_path[0] == '\/', \"_cgroup_path should start with a slash ('\/')\");\n+  while (dir_count--) {\n+    char *s = strrchr(cgroup_path, '\/');\n+    assert(s, \"function should have already returned\");\n+    *s = 0;\n+    if (s == cgroup_path) {\n+      os::free(cgroup_path);\n+      return false;\n+    }\n+  }\n+  set_path(cgroup_path);\n+  os::free(cgroup_path);\n+  return true;\n+}\n+\n+void CgroupSubsystem::initialize_hierarchy() {\n+  CgroupController *memory = memory_controller()->controller();\n+\n+  size_t best_level = 0;\n+  jlong memory_limit_min = max_jlong;\n+  jlong memory_swap_limit_min = max_jlong;\n+\n+  for (size_t dir_count = 0; memory->trim_path(dir_count); ++dir_count) {\n+    jlong memory_limit = read_memory_limit_in_bytes();\n+    if (memory_limit != -1 && memory_limit != OSCONTAINER_ERROR && memory_limit < memory_limit_min) {\n+      memory_limit_min = memory_limit;\n+      best_level = dir_count;\n+    }\n+    jlong memory_swap_limit = memory_and_swap_limit_in_bytes();\n+    if (memory_swap_limit != -1 && memory_swap_limit != OSCONTAINER_ERROR && memory_swap_limit < memory_swap_limit_min) {\n+      memory_swap_limit_min = memory_swap_limit;\n+      best_level = dir_count;\n+    }\n+    \/\/ Never use a directory without controller files (disabled by \"..\/cgroup.subtree_control\").\n+    if (memory_limit == OSCONTAINER_ERROR && memory_swap_limit == OSCONTAINER_ERROR && best_level == dir_count) {\n+      ++best_level;\n+    }\n+  }\n+\n+  memory->trim_path(best_level);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":100,"deletions":3,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -75,0 +75,11 @@\n+  protected:\n+    void set_path(const char *cgroup_path);\n+\n+    \/* mountinfo contents *\/\n+    char *_root;\n+    char *_mount_point;\n+    char *_cgroup_path = nullptr;\n+\n+    \/* Constructed subsystem directory *\/\n+    char *_path = nullptr;\n+\n@@ -76,1 +87,12 @@\n-    virtual char *subsystem_path() = 0;\n+    CgroupController(const char *root, const char *mountpoint) : _root(os::strdup(root)), _mount_point(os::strdup(mountpoint)) {}\n+    ~CgroupController() {\n+      os::free(_root);\n+      os::free(_mount_point);\n+      os::free(_cgroup_path);\n+      os::free(_path);\n+    }\n+\n+    bool trim_path(size_t dir_count);\n+    virtual const char *subsystem_path() { return _path; }\n+\n+    virtual void set_subsystem_path(const char *cgroup_path);\n@@ -255,0 +277,2 @@\n+  protected:\n+    void initialize_hierarchy();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,55 +36,0 @@\n-\/*\n- * Set directory to subsystem specific files based\n- * on the contents of the mountinfo and cgroup files.\n- *\/\n-void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n-  stringStream ss;\n-  if (_root != nullptr && cgroup_path != nullptr) {\n-    if (strcmp(_root, \"\/\") == 0) {\n-      ss.print_raw(_mount_point);\n-      if (strcmp(cgroup_path,\"\/\") != 0) {\n-        ss.print_raw(cgroup_path);\n-      }\n-      _path = os::strdup(ss.base());\n-    } else {\n-      if (strcmp(_root, cgroup_path) == 0) {\n-        ss.print_raw(_mount_point);\n-        _path = os::strdup(ss.base());\n-      } else {\n-        char *p = strstr(cgroup_path, _root);\n-        if (p != nullptr && p == _root) {\n-          if (strlen(cgroup_path) > strlen(_root)) {\n-            ss.print_raw(_mount_point);\n-            const char* cg_path_sub = cgroup_path + strlen(_root);\n-            ss.print_raw(cg_path_sub);\n-            _path = os::strdup(ss.base());\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n-jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n-  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \", JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n-}\n-\n-void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n-  CgroupV1Controller::set_subsystem_path(cgroup_path);\n-  jlong hierarchy = uses_mem_hierarchy();\n-  if (hierarchy > 0) {\n-    set_hierarchical(true);\n-  }\n-}\n-\n@@ -97,10 +42,2 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n+    \/\/ Backward compatibility:\n+    log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n@@ -109,3 +46,3 @@\n-  else {\n-    return (jlong)memlimit;\n-  }\n+  \/\/ Backward compatibility:\n+  log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, memlimit);\n+  return (jlong)memlimit;\n@@ -133,11 +70,2 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n-      if (hier_memswlimit >= host_total_memsw) {\n-        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memswlimit;\n-      }\n-    }\n+    \/\/ Backward compatibility:\n+    log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n@@ -146,0 +74,2 @@\n+    \/\/ Backward compatibility:\n+    log_trace(os, container)(\"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, memswlimit);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":9,"deletions":79,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -35,21 +35,0 @@\n-  private:\n-    \/* mountinfo contents *\/\n-    char *_root;\n-    char *_mount_point;\n-\n-    \/* Constructed subsystem directory *\/\n-    char *_path;\n-\n-  public:\n-    CgroupV1Controller(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = nullptr;\n-    }\n-\n-    virtual void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() { return _path; }\n-};\n-\n-class CgroupV1MemoryController: public CgroupV1Controller {\n-\n@@ -57,15 +36,1 @@\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_subsystem_path(char *cgroup_path);\n-  private:\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-    jlong uses_mem_hierarchy();\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n-\n-  public:\n-    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n-    }\n-\n+    CgroupV1Controller(const char *root, const char *mountpoint) : CgroupController(root, mountpoint) {}\n@@ -127,1 +92,1 @@\n-                      CgroupV1MemoryController* memory) {\n+                      CgroupV1Controller* memory) {\n@@ -133,0 +98,1 @@\n+      initialize_hierarchy();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":3,"deletions":37,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -244,9 +244,0 @@\n-char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n-  stringStream ss;\n-  ss.print_raw(mount_path);\n-  if (strcmp(cgroup_path, \"\/\") != 0) {\n-    ss.print_raw(cgroup_path);\n-  }\n-  return os::strdup(ss.base());\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,10 +31,0 @@\n-  private:\n-    \/* the mount path of the cgroup v2 hierarchy *\/\n-    char *_mount_path;\n-    \/* The cgroup path for the controller *\/\n-    char *_cgroup_path;\n-\n-    \/* Constructed full path to the subsystem directory *\/\n-    char *_path;\n-    static char* construct_path(char* mount_path, char *cgroup_path);\n-\n@@ -42,7 +32,1 @@\n-    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n-      _mount_path = mount_path;\n-      _cgroup_path = os::strdup(cgroup_path);\n-      _path = construct_path(mount_path, cgroup_path);\n-    }\n-\n-    char *subsystem_path() { return _path; }\n+    CgroupV2Controller(const char *root, const char *mountpoint) : CgroupController(root, mountpoint) {}\n@@ -71,0 +55,1 @@\n+      initialize_hierarchy();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n@@ -153,1 +153,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    public static final long LONG_RETVAL_UNLIMITED = -1;\n+    public static final long OSCONTAINER_ERROR = -2;\n@@ -42,2 +42,5 @@\n-        if (strVal == null || MAX_VAL.equals(strVal)) {\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        if (strVal == null) {\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n+        }\n+        if (MAX_VAL.equals(strVal)) {\n+            return Long.MAX_VALUE;\n@@ -48,0 +51,24 @@\n+    public default void initializeHierarchy(CgroupSubsystemController memory) {\n+        int bestLevel = 0;\n+        long memoryLimitMin = Long.MAX_VALUE;\n+        long memorySwapLimitMin = Long.MAX_VALUE;\n+\n+        for (int dirCount = 0; memory.trimPath(dirCount); ++dirCount) {\n+            long memoryLimit = getMemoryLimit();\n+            if (memoryLimit != Long.MAX_VALUE && memoryLimit != CgroupSubsystem.OSCONTAINER_ERROR && memoryLimit < memoryLimitMin) {\n+                memoryLimitMin = memoryLimit;\n+                bestLevel = dirCount;\n+            }\n+            long memorySwapLimit = getMemoryAndSwapLimit();\n+            if (memorySwapLimit != Long.MAX_VALUE && memorySwapLimit != CgroupSubsystem.OSCONTAINER_ERROR && memorySwapLimit < memorySwapLimitMin) {\n+                memorySwapLimitMin = memorySwapLimit;\n+                bestLevel = dirCount;\n+            }\n+            \/\/ Never use a directory without controller files (disabled by \"..\/cgroup.subtree_control\").\n+            if (memoryLimit == CgroupSubsystem.OSCONTAINER_ERROR && memorySwapLimit == CgroupSubsystem.OSCONTAINER_ERROR && bestLevel == dirCount) {\n+                ++bestLevel;\n+            }\n+        }\n+\n+        memory.trimPath(bestLevel);\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-public interface CgroupSubsystemController {\n+public abstract class CgroupSubsystemController {\n@@ -45,1 +45,17 @@\n-    public static final String EMPTY_STR = \"\";\n+    \/\/ Values returned larger than this number are unlimited.\n+    protected static final long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n+\n+    String root;\n+    String mountPoint;\n+    String cgroupPath;\n+    String path;\n+\n+    protected CgroupSubsystemController(String root, String mountPoint) {\n+        this.root = root;\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public void setSubsystemPath(String cgroupPath) {\n+        this.cgroupPath = cgroupPath;\n+        trimPath(0);\n+    }\n@@ -47,1 +63,44 @@\n-    public String path();\n+    public void setPath(String cgroupPath) {\n+        \/\/ Do not use the this.cgroupPath variable.\n+        if (root == null || cgroupPath == null) {\n+            return;\n+        }\n+        if (root.equals(\"\/\")) {\n+            if (!cgroupPath.equals(\"\/\")) {\n+                path = mountPoint + cgroupPath;\n+                return;\n+            }\n+            path = mountPoint;\n+            return;\n+        }\n+        if (root.equals(cgroupPath)) {\n+            path = mountPoint;\n+            return;\n+        }\n+        if (!cgroupPath.startsWith(root) || cgroupPath.equals(root) || cgroupPath.charAt(root.length()) != '\/') {\n+            return;\n+        }\n+        String cgroupSubstr = cgroupPath.substring(root.length());\n+        path = mountPoint + cgroupSubstr;\n+    }\n+\n+    public String path() {\n+        return path;\n+    }\n+\n+    public boolean trimPath(int dir_count) {\n+        String cgroupPath = this.cgroupPath;\n+        assert cgroupPath.charAt(0) == '\/';\n+        while (dir_count-- > 0) {\n+            int pos = cgroupPath.lastIndexOf('\/');\n+            assert pos >= 0;\n+            if (pos == 0) {\n+                return false;\n+            }\n+            cgroupPath = cgroupPath.substring(0, pos);\n+        }\n+        path = Paths.get(mountPoint, cgroupPath).toString();\n+        return true;\n+    }\n+\n+    public static final String EMPTY_STR = \"\";\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-    private boolean hierarchical;\n@@ -37,8 +36,0 @@\n-    boolean isHierarchical() {\n-        return hierarchical;\n-    }\n-\n-    void setHierarchical(boolean hierarchical) {\n-        this.hierarchical = hierarchical;\n-    }\n-\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,3 +84,1 @@\n-                    controller.setPath(info.getCgroupPath());\n-                    boolean isHierarchial = getHierarchical(controller);\n-                    controller.setHierarchical(isHierarchial);\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -97,1 +95,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -106,1 +104,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -115,1 +113,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -124,1 +122,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -133,1 +131,1 @@\n-                    controller.setPath(info.getCgroupPath());\n+                    controller.setSubsystemPath(info.getCgroupPath());\n@@ -146,0 +144,1 @@\n+            subsystem.initializeHierarchy(subsystem.memory);\n@@ -159,5 +158,0 @@\n-    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n-        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n-        return hierarchical > 0;\n-    }\n-\n@@ -193,1 +187,1 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+                                                      CgroupSubsystem.OSCONTAINER_ERROR);\n@@ -248,1 +242,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n@@ -311,10 +305,0 @@\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n-        }\n@@ -368,10 +352,0 @@\n-        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memsw_limit\";\n-                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match);\n-            }\n-        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,8 +31,1 @@\n-public class CgroupV1SubsystemController implements CgroupSubsystemController {\n-\n-    private static final double DOUBLE_RETVAL_UNLIMITED = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-    \/\/ Values returned larger than this number are unlimited.\n-    static long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n-    String root;\n-    String mountPoint;\n-    String path;\n+public class CgroupV1SubsystemController extends CgroupSubsystemController {\n@@ -41,33 +34,1 @@\n-        this.root = root;\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public void setPath(String cgroupPath) {\n-        if (root != null && cgroupPath != null) {\n-            if (root.equals(\"\/\")) {\n-                if (!cgroupPath.equals(\"\/\")) {\n-                    path = mountPoint + cgroupPath;\n-                }\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n-                }\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String path() {\n-        return path;\n+        super(root, mountPoint);\n@@ -80,1 +41,1 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                      CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n@@ -86,1 +47,1 @@\n-                                                        DOUBLE_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                        CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n@@ -92,1 +53,1 @@\n-                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                             CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n@@ -96,1 +57,1 @@\n-        return value > UNLIMITED_MIN ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : value;\n+        return value > UNLIMITED_MIN ? Long.MAX_VALUE : value;\n@@ -106,1 +67,1 @@\n-                                                                  CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+                                                                  CgroupSubsystem.OSCONTAINER_ERROR);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":7,"deletions":46,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        return getLongVal(file, CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+        return getLongVal(file, CgroupSubsystem.OSCONTAINER_ERROR);\n@@ -79,3 +79,4 @@\n-            CgroupSubsystemController unified = new CgroupV2SubsystemController(\n-                    anyController.getMountPoint(),\n-                    anyController.getCgroupPath());\n+            CgroupV2SubsystemController unified = new CgroupV2SubsystemController(\n+                    anyController.getMountRoot(),\n+                    anyController.getMountPoint());\n+            unified.setSubsystemPath(anyController.getCgroupPath());\n@@ -83,0 +84,1 @@\n+            tmpCgroupSystem.initializeHierarchy(unified);\n@@ -143,1 +145,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n@@ -148,1 +150,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n@@ -158,1 +160,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return Long.MAX_VALUE;\n@@ -336,1 +338,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return CgroupSubsystem.OSCONTAINER_ERROR;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public class CgroupV2SubsystemController implements CgroupSubsystemController {\n+public class CgroupV2SubsystemController extends CgroupSubsystemController {\n@@ -35,9 +35,2 @@\n-    private final String path;\n-\n-    public CgroupV2SubsystemController(String mountPath, String cgroupPath) {\n-        this.path = Paths.get(mountPath, cgroupPath).toString();\n-    }\n-\n-    @Override\n-    public String path() {\n-        return path;\n+    public CgroupV2SubsystemController(String root, String mountPoint) {\n+        super(root, mountPoint);\n@@ -48,2 +41,2 @@\n-                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* overflow retval *\/,\n-                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* default retval on error *\/);\n+                                                             Long.MAX_VALUE \/* overflow retval *\/,\n+                                                             CgroupSubsystem.OSCONTAINER_ERROR \/* default retval on error *\/);\n@@ -56,1 +49,1 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+                                                      CgroupSubsystem.OSCONTAINER_ERROR \/* retval on error *\/);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-  char* subsystem_path() override {\n+  TestController() : CgroupController(\"\/\", \"\/\") {}\n+  virtual const char* subsystem_path() override {\n@@ -65,1 +66,1 @@\n-    return (char*)\"\/\";\n+    return \"\/\";\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,3 +56,3 @@\n-    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n-                                                       (char*)testCases[i]->mount_path);\n-    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n+    CgroupV1Controller* ctrl = new CgroupV1Controller( testCases[i]->root_path,\n+                                                       testCases[i]->mount_path);\n+    ctrl->set_subsystem_path(testCases[i]->cgroup_path);\n@@ -66,1 +66,1 @@\n-    nullptr,                \/\/ root_path, ignored\n+    \"\/\",                    \/\/ root_path\n@@ -72,1 +72,1 @@\n-    nullptr,                \/\/ root_path, ignored\n+    \"\/\",                    \/\/ root_path\n@@ -80,2 +80,3 @@\n-    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n-                                                       (char*)testCases[i]->cgroup_path);\n+    CgroupV2Controller* ctrl = new CgroupV2Controller( testCases[i]->root_path,\n+                                                       testCases[i]->mount_path);\n+    ctrl->set_subsystem_path(testCases[i]->cgroup_path);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test NestedCgroup\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/testlibrary \/test\/lib\n+ * @run main\/othervm NestedCgroup\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Asserts;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.nio.file.Files;\n+import jtreg.SkippedException;\n+import java.nio.file.Path;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import java.nio.file.NoSuchFileException;\n+import java.io.IOException;\n+import java.lang.IllegalArgumentException;\n+\n+public class NestedCgroup {\n+    private static abstract class Test {\n+        public static final String CGROUP_OUTER = \"jdktest\" + ProcessHandle.current().pid();\n+        public static final String CGROUP_INNER = \"inner\";\n+        public static final String CONTROLLERS_PATH_OUTER = \"memory:\" + CGROUP_OUTER;\n+        public static final String CONTROLLERS_PATH_INNER = CONTROLLERS_PATH_OUTER + \"\/\" + CGROUP_INNER;\n+        public static final String LINE_DELIM = \"-\".repeat(80);\n+        public static final String MOUNTINFO = \"\/proc\/self\/mountinfo\";\n+\n+        \/\/ A real usage on x86_64 fits in 39 MiB.\n+        public static final int MEMORY_MAX_OUTER = 500 * 1024 * 1024;\n+        public static final int MEMORY_MAX_INNER = MEMORY_MAX_OUTER * 2;\n+        public static final String MEMORY_LIMIT_MB = \"500.00M\";\n+\n+        public static String sysFsCgroup;\n+        public String memory_max_filename;\n+        public static boolean isCgroup2;\n+\n+        public static void lineDelim(String str, String label) {\n+            System.err.print(LINE_DELIM + \" \" + label + \"\\n\" + str);\n+            if (!str.isEmpty() && !str.endsWith(\"\\n\")) {\n+                System.err.println();\n+            }\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args, String failStderr, String failExplanation, String ignoreStderr) throws Exception {\n+            System.err.println(LINE_DELIM + \" command: \" + String.join(\" \",args));\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process process = pb.start();\n+            OutputAnalyzer output = new OutputAnalyzer(process);\n+            int exitValue = process.waitFor();\n+            lineDelim(output.getStdout(), \"stdout\");\n+            lineDelim(output.getStderr(), \"stderr\");\n+            System.err.println(LINE_DELIM);\n+            if (!failStderr.isEmpty() && output.getStderr().equals(failStderr + \"\\n\")) {\n+                throw new SkippedException(failExplanation + \": \" + failStderr);\n+            }\n+            if (!ignoreStderr.isEmpty() && output.getStderr().equals(ignoreStderr + \"\\n\")) {\n+                return output;\n+            }\n+            Asserts.assertEQ(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+            return output;\n+        }\n+\n+        public static OutputAnalyzer pSystem(List<String> args) throws Exception {\n+            return pSystem(args, \"\", \"\", \"\");\n+        }\n+\n+        public static void args_add_cgexec(List<String> args) {\n+            args.add(\"cgexec\");\n+            args.add(\"-g\");\n+            args.add(CONTROLLERS_PATH_INNER);\n+        }\n+\n+        public static String jdkTool;\n+\n+        public static void args_add_self(List<String> args) {\n+            args.add(jdkTool);\n+            args.add(\"-cp\");\n+            args.add(System.getProperty(\"java.class.path\"));\n+        }\n+\n+        public static void args_add_self_verbose(List<String> args) {\n+            args_add_self(args);\n+            args.add(\"-XshowSettings:system\");\n+            args.add(\"-Xlog:os+container=trace\");\n+        }\n+\n+        public Test() throws Exception {\n+            List<String> cgdelete = new ArrayList<>();\n+            cgdelete.add(\"cgdelete\");\n+            cgdelete.add(\"-r\");\n+            cgdelete.add(\"-g\");\n+            cgdelete.add(CONTROLLERS_PATH_OUTER);\n+            try {\n+                pSystem(cgdelete,\n+                    \"cgdelete: libcgroup initialization failed: Cgroup is not mounted\", \"cgroup\/cgroup2 is not mounted\",\n+                    \"cgdelete: cannot remove group '\" + CGROUP_OUTER + \"': No such file or directory\");\n+            } catch (IOException e) {\n+                if (e.toString().equals(\"java.io.IOException: Cannot run program \\\"cgdelete\\\": error=2, No such file or directory\")) {\n+                    throw new SkippedException(\"libcgroup-tools is not installed\");\n+                }\n+                throw e;\n+            }\n+\n+            List<String> cgcreate = new ArrayList<>();\n+            cgcreate.add(\"cgcreate\");\n+            cgcreate.add(\"-g\");\n+            cgcreate.add(CONTROLLERS_PATH_INNER);\n+            pSystem(cgcreate, \"cgcreate: can't create cgroup \" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \": Cgroup, operation not allowed\", \"Missing root permission\", \"\");\n+\n+            String mountInfo;\n+            try {\n+                mountInfo = Files.readString(Path.of(MOUNTINFO));\n+            } catch (NoSuchFileException e) {\n+                throw new SkippedException(\"Cannot open \" + MOUNTINFO);\n+            }\n+\n+            Matcher matcher = Pattern.compile(\"^(?:\\\\S+\\\\s+){4}(\\\\S+)\\\\s.*\\\\scgroup(?:(2)(?:\\\\s+\\\\S+){2}|\\\\s+\\\\S+\\\\s+(?:\\\\S*,)?memory(?:,\\\\S*)?)$\", Pattern.MULTILINE).matcher(mountInfo);\n+            if (!matcher.find()) {\n+                System.err.println(mountInfo);\n+                throw new SkippedException(\"cgroup\/cgroup2 filesystem mount point not found\");\n+            }\n+            sysFsCgroup = matcher.group(1);\n+            isCgroup2 = matcher.group(2) != null;\n+\n+            System.err.println(LINE_DELIM + \" \" + (isCgroup2 ? \"cgroup2\" : \"cgroup1\") + \" mount point: \" + sysFsCgroup);\n+            memory_max_filename = isCgroup2 ? \"memory.max\" : \"memory.limit_in_bytes\";\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_OUTER);\n+\n+            \/\/ Here starts a copy of ProcessTools.createJavaProcessBuilder.\n+            List<String> cgexec = new ArrayList<>();\n+            hook(cgexec);\n+            OutputAnalyzer output = pSystem(cgexec);\n+            output.shouldMatch(\"^ *Memory Limit: \" + MEMORY_LIMIT_MB + \"$\");\n+            output.shouldMatch(\"\\\\[trace\\\\]\\\\[os,container\\\\] \" + (isCgroup2 ? \"\" : \"Hierarchical \") + \"Memory Limit is: \" + MEMORY_MAX_OUTER + \"$\");\n+\n+            pSystem(cgdelete);\n+        }\n+\n+        public abstract void hook(List<String> cgexec) throws IOException;\n+    }\n+    private static class TestTwoLimits extends Test {\n+        public void hook(List<String> cgexec) throws IOException {\n+            \/\/ CgroupV1Subsystem::read_memory_limit_in_bytes considered hierarchical_memory_limit only when inner memory.limit_in_bytes is unlimited.\n+            Files.writeString(Path.of(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/\" + CGROUP_INNER + \"\/\" + memory_max_filename), \"\" + MEMORY_MAX_INNER);\n+\n+            args_add_cgexec(cgexec);\n+            args_add_self_verbose(cgexec);\n+            cgexec.add(\"-version\");\n+        }\n+        public TestTwoLimits() throws Exception {\n+        }\n+    }\n+    private static class TestNoController extends Test {\n+        public void hook(List<String> cgexec) throws IOException {\n+            args_add_cgexec(cgexec);\n+            args_add_self(cgexec);\n+            cgexec.add(\"NestedCgroup\");\n+            cgexec.add(\"TestNoController\");\n+            cgexec.add(Test.jdkTool);\n+            cgexec.add(sysFsCgroup + \"\/\" + CGROUP_OUTER + \"\/cgroup.subtree_control\");\n+        }\n+        public TestNoController() throws Exception {\n+        }\n+        public static void child(String arg) throws Exception {\n+            Files.writeString(Path.of(arg), \"-memory\");\n+\n+            List<String> self_verbose = new ArrayList<>();\n+            args_add_self_verbose(self_verbose);\n+            self_verbose.add(\"-version\");\n+            pSystem(self_verbose);\n+        }\n+    }\n+    public static void main(String[] args) throws Exception {\n+        switch (args.length) {\n+            case 0:\n+                Test.jdkTool = JDKToolFinder.getJDKTool(\"java\");\n+                new TestTwoLimits();\n+                if (Test.isCgroup2) {\n+                    new TestNoController();\n+                }\n+                return;\n+            case 3:\n+                switch (args[0]) {\n+                    case \"TestNoController\":\n+                        Test.jdkTool = args[1];\n+                        TestNoController.child(args[2]);\n+                        return;\n+                }\n+        }\n+        throw new IllegalArgumentException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/NestedCgroup.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}