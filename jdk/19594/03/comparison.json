{"files":[{"patch":"@@ -581,27 +581,0 @@\n-\/\/ The last collection bailed out, we are running out of heap space,\n-\/\/ so we try to allocate the from-space, too.\n-HeapWord* DefNewGeneration::allocate_from_space(size_t size) {\n-  bool should_try_alloc = should_allocate_from_space() || GCLocker::is_active_and_needs_gc();\n-\n-  \/\/ If the Heap_lock is not locked by this thread, this will be called\n-  \/\/ again later with the Heap_lock held.\n-  bool do_alloc = should_try_alloc && (Heap_lock->owned_by_self() || (SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread()));\n-\n-  HeapWord* result = nullptr;\n-  if (do_alloc) {\n-    result = from()->allocate(size);\n-  }\n-\n-  log_trace(gc, alloc)(\"DefNewGeneration::allocate_from_space(\" SIZE_FORMAT \"):  will_fail: %s  heap_lock: %s  free: \" SIZE_FORMAT \"%s%s returns %s\",\n-                        size,\n-                        SerialHeap::heap()->incremental_collection_will_fail(false \/* don't consult_young *\/) ?\n-                          \"true\" : \"false\",\n-                        Heap_lock->is_locked() ? \"locked\" : \"unlocked\",\n-                        from()->free(),\n-                        should_try_alloc ? \"\" : \"  should_allocate_from_space: NOT\",\n-                        do_alloc ? \"  Heap_lock is not owned by self\" : \"\",\n-                        result == nullptr ? \"null\" : \"object\");\n-\n-  return result;\n-}\n-\n@@ -710,2 +683,0 @@\n-\n-    assert(!heap->incremental_collection_failed(), \"Should be clear\");\n@@ -718,7 +689,0 @@\n-    \/\/ Add to-space to the list of space to compact\n-    \/\/ when a promotion failure has occurred.  In that\n-    \/\/ case there can be live objects in to-space\n-    \/\/ as a result of a partial evacuation of eden\n-    \/\/ and from-space.\n-    swap_spaces();   \/\/ For uniformity wrt ParNewGeneration.\n-    heap->set_incremental_collection_failed();\n@@ -886,2 +850,0 @@\n-  DEBUG_ONLY(static bool seen_incremental_collection_failed = false;)\n-\n@@ -889,39 +851,0 @@\n-  \/\/ Check if the heap is approaching full after a collection has\n-  \/\/ been done.  Generally the young generation is empty at\n-  \/\/ a minimum at the end of a collection.  If it is not, then\n-  \/\/ the heap is approaching full.\n-  SerialHeap* gch = SerialHeap::heap();\n-  if (full) {\n-    DEBUG_ONLY(seen_incremental_collection_failed = false;)\n-    if (!collection_attempt_is_safe() && !_eden_space->is_empty()) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), full, not safe, set_failed, set_alloc_from, clear_seen\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      gch->set_incremental_collection_failed(); \/\/ Slight lie: a full gc left us in that state\n-      set_should_allocate_from_space(); \/\/ we seem to be running out of space\n-    } else {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), full, safe, clear_failed, clear_alloc_from, clear_seen\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      gch->clear_incremental_collection_failed(); \/\/ We just did a full collection\n-      clear_should_allocate_from_space(); \/\/ if set\n-    }\n-  } else {\n-#ifdef ASSERT\n-    \/\/ It is possible that incremental_collection_failed() == true\n-    \/\/ here, because an attempted scavenge did not succeed. The policy\n-    \/\/ is normally expected to cause a full collection which should\n-    \/\/ clear that condition, so we should not be here twice in a row\n-    \/\/ with incremental_collection_failed() == true without having done\n-    \/\/ a full collection in between.\n-    if (!seen_incremental_collection_failed &&\n-        gch->incremental_collection_failed()) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), not full, not_seen_failed, failed, set_seen_failed\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      seen_incremental_collection_failed = true;\n-    } else if (seen_incremental_collection_failed) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), not full, seen_failed, will_clear_seen_failed\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      seen_incremental_collection_failed = false;\n-    }\n-#endif \/\/ ASSERT\n-  }\n-\n@@ -930,1 +853,1 @@\n-  gch->counters()->update_counters();\n+  SerialHeap::heap()->counters()->update_counters();\n@@ -970,7 +893,0 @@\n-  if (result == nullptr) {\n-    \/\/ If the eden is full and the last collection bailed out, we are running\n-    \/\/ out of heap space, and we try to allocate the from-space, too.\n-    \/\/ allocate_from_space can't be inlined because that would introduce a\n-    \/\/ circular dependency at compile time.\n-    result = allocate_from_space(word_size);\n-  }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":85,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  HeapWord* allocate_from_space(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-    _incremental_collection_failed(false),\n@@ -290,2 +289,1 @@\n-         || GCLocker::is_active_and_needs_gc()\n-         || incremental_collection_failed();\n+         || GCLocker::is_active_and_needs_gc();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,5 +94,0 @@\n-  \/\/ Indicates that the most recent previous incremental collection failed.\n-  \/\/ The flag is cleared when an action is taken that might clear the\n-  \/\/ condition that caused that incremental collection to fail.\n-  bool _incremental_collection_failed;\n-\n@@ -258,23 +253,0 @@\n-  \/\/ Returns true if an incremental collection is likely to fail.\n-  \/\/ We optionally consult the young gen, if asked to do so;\n-  \/\/ otherwise we base our answer on whether the previous incremental\n-  \/\/ collection attempt failed with no corrective action as of yet.\n-  bool incremental_collection_will_fail(bool consult_young) {\n-    \/\/ The first disjunct remembers if an incremental collection failed, even\n-    \/\/ when we thought (second disjunct) that it would not.\n-    return incremental_collection_failed() ||\n-           (consult_young && !_young_gen->collection_attempt_is_safe());\n-  }\n-\n-  \/\/ If a generation bails out of an incremental collection,\n-  \/\/ it sets this flag.\n-  bool incremental_collection_failed() const {\n-    return _incremental_collection_failed;\n-  }\n-  void set_incremental_collection_failed() {\n-    _incremental_collection_failed = true;\n-  }\n-  void clear_incremental_collection_failed() {\n-    _incremental_collection_failed = false;\n-  }\n-\n@@ -292,1 +264,0 @@\n-private:\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"}]}