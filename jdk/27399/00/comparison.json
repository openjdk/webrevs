{"files":[{"patch":"@@ -252,0 +252,1 @@\n+sun\/java2d\/OpenGL\/OpaqueDest.java#id1 8367574 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6248561 6264014\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that bitmask image copies work properly with the\n+ * OGL pipeline when a SrcOver composite with extra alpha is involved.\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 DrawBitmaskImage\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 DrawBitmaskImage\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6248561 6264014\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that bitmask image copies work properly with the\n+ * OGL pipeline when a SrcOver composite with extra alpha is involved.\n+ * @run main\/othervm -Dsun.java2d.opengl=True DrawBitmaskImage\n+ * @run main\/othervm DrawBitmaskImage\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Transparency;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class DrawBitmaskImage extends Panel {\n+\n+    static final int TESTW = 200, TESTH = 200;\n+    private static volatile DrawBitmaskImage test;\n+    private static volatile Frame frame;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+        g2d.setComposite(AlphaComposite.SrcOver.derive(0.50f));\n+\n+        BufferedImage img = getGraphicsConfiguration().createCompatibleImage(50, 50,\n+                                                        Transparency.BITMASK);\n+        Graphics2D gimg = img.createGraphics();\n+        gimg.setComposite(AlphaComposite.Src);\n+        gimg.setColor(new Color(0, 0, 0, 0));\n+        gimg.fillRect(0, 0, 50, 50);\n+        gimg.setColor(Color.red);\n+        gimg.fillRect(10, 10, 30, 30);\n+        gimg.dispose();\n+\n+\n+        g2d.drawImage(img, 10, 10, null);\n+\n+        \/\/ draw a second time to ensure that the cached copy is used\n+        g2d.drawImage(img, 80, 10, null);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+         return new Dimension(TESTW, TESTH);\n+    }\n+\n+    static void createUI() {\n+        test = new DrawBitmaskImage();\n+        frame = new Frame(\"OpenGL DrawBitmaskImage Test\");\n+        Panel p = new Panel();\n+        p.add(test);\n+        frame.add(p);\n+        frame.setSize(TESTW+100, TESTH+100);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(DrawBitmaskImage::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        BufferedImage capture = null;\n+        try {\n+            GraphicsConfiguration gc = frame.getGraphicsConfiguration();\n+            if (gc.getColorModel() instanceof IndexColorModel) {\n+                System.out.println(\"IndexColorModel detected: \" +\n+                                   \"test considered PASSED\");\n+                return;\n+            }\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, TESTW, TESTH);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test background color\n+        int pixel = capture.getRGB(5, 10);\n+        if (pixel != 0xff000000) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"background (actual=\" +\n+                                       Integer.toHexString(pixel) + \")\");\n+        }\n+\n+        \/\/ Test pixels (allow for small error in the actual red value)\n+        pixel = capture.getRGB(25, 25);\n+        System.out.println(\"pixel1 is \" + Integer.toHexString(pixel));\n+\n+        if ((pixel < 0xff7e0000) || (pixel > 0xff900000)) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"first pixel (actual=\" +\n+                                       Integer.toHexString(pixel) + \")\");\n+        }\n+\n+        pixel = capture.getRGB(95, 25);\n+        System.out.println(\"pixel2 is \" + Integer.toHexString(pixel));\n+        if ((pixel < 0xff7e0000) || (pixel > 0xff900000)) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"second pixel (actual=\" +\n+                                       Integer.toHexString(pixel) + \")\");\n+        }\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/DrawBitmaskImage.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,514 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6514990\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that calling\n+ * Graphics2D.drawImage(BufferedImage, BufferedImageOp, x, y) to an\n+ * OpenGL-accelerated destination produces the same results when performed\n+ * in software via BufferedImageOp.filter().\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 DrawBufImgOp -ignore\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6514990\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that calling\n+ * Graphics2D.drawImage(BufferedImage, BufferedImageOp, x, y) to an\n+ * OpenGL-accelerated destination produces the same results when performed\n+ * in software via BufferedImageOp.filter().\n+ * @run main\/othervm -Dsun.java2d.opengl=True DrawBufImgOp -ignore\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ByteLookupTable;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ConvolveOp;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.Kernel;\n+import java.awt.image.LookupOp;\n+import java.awt.image.RescaleOp;\n+import java.awt.image.ShortLookupTable;\n+import java.awt.image.VolatileImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+\/**\n+ * REMIND: This testcase was originally intended to automatically compare\n+ * the results of the software BufferedImageOp implementations against\n+ * the OGL-accelerated codepaths.  However, there are just too many open\n+ * bugs in the mediaLib-based codepaths (see below), which means that\n+ * creating the reference image may cause crashes or exceptions,\n+ * and even if we work around those cases using the \"-ignore\" flag,\n+ * the visual results of the reference image are often buggy as well\n+ * (so the comparison will fail even though the OGL results are correct).\n+ * Therefore, for now we will run the testcase with the \"-ignore\" flag\n+ * but without the \"-compare\" flag, so at least it will be checking for\n+ * any exceptions\/crashes in the OGL code.  When we fix all of the\n+ * outstanding bugs with the software codepaths, we can remove the\n+ * \"-ignore\" flag and maybe even restore the \"-compare\" flag.  In the\n+ * meantime, it also functions well as a manual testcase (with either\n+ * the \"-show\" or \"-dump\" options).\n+ *\/\n+public class DrawBufImgOp extends Canvas {\n+\n+    private static final int TESTW = 600;\n+    private static final int TESTH = 500;\n+\n+    private static volatile DrawBufImgOp test;\n+    private static volatile Frame frame;\n+\n+    \/*\n+     * If true, skips tests that are known to trigger bugs (which in\n+     * turn may cause crashes, exceptions, or other artifacts).\n+     *\/\n+    private static boolean ignore;\n+\n+    \/\/ Test both pow2 and non-pow2 sized images\n+    private static final int[] srcSizes = { 32, 17 };\n+    private static final int[] srcTypes = {\n+        BufferedImage.TYPE_INT_RGB,\n+        BufferedImage.TYPE_INT_ARGB,\n+        BufferedImage.TYPE_INT_ARGB_PRE,\n+        BufferedImage.TYPE_INT_BGR,\n+        BufferedImage.TYPE_3BYTE_BGR,\n+        BufferedImage.TYPE_4BYTE_ABGR,\n+        BufferedImage.TYPE_USHORT_565_RGB,\n+        BufferedImage.TYPE_BYTE_GRAY,\n+        BufferedImage.TYPE_USHORT_GRAY,\n+    };\n+\n+    private static final RescaleOp\n+        rescale1band, rescale3band, rescale4band;\n+    private static final LookupOp\n+        lookup1bandbyte, lookup3bandbyte, lookup4bandbyte;\n+    private static final LookupOp\n+        lookup1bandshort, lookup3bandshort, lookup4bandshort;\n+    private static final ConvolveOp\n+        convolve3x3zero, convolve5x5zero, convolve7x7zero;\n+    private static final ConvolveOp\n+        convolve3x3noop, convolve5x5noop, convolve7x7noop;\n+\n+    static {\n+        rescale1band = new RescaleOp(0.5f, 10.0f, null);\n+        rescale3band = new RescaleOp(\n+            new float[] {  0.6f,  0.4f, 0.6f },\n+            new float[] { 10.0f, -3.0f, 5.0f },\n+            null);\n+        rescale4band = new RescaleOp(\n+            new float[] {  0.6f, 0.4f, 0.6f, 0.9f },\n+            new float[] { -1.0f, 5.0f, 3.0f, 1.0f },\n+            null);\n+\n+        \/\/ REMIND: we should probably test non-zero offsets, but that\n+        \/\/ would require massaging the source image data to avoid going\n+        \/\/ outside the lookup table array bounds\n+        int offset = 0;\n+        {\n+            byte invert[] = new byte[256];\n+            byte halved[] = new byte[256];\n+            for (int j = 0; j < 256 ; j++) {\n+                invert[j] = (byte) (255-j);\n+                halved[j] = (byte) (j \/ 2);\n+            }\n+            ByteLookupTable lut1 = new ByteLookupTable(offset, invert);\n+            lookup1bandbyte = new LookupOp(lut1, null);\n+            ByteLookupTable lut3 =\n+                new ByteLookupTable(offset,\n+                                    new byte[][] {invert, halved, invert});\n+            lookup3bandbyte = new LookupOp(lut3, null);\n+            ByteLookupTable lut4 =\n+                new ByteLookupTable(offset,\n+                               new byte[][] {invert, halved, invert, halved});\n+            lookup4bandbyte = new LookupOp(lut4, null);\n+        }\n+\n+        {\n+            short invert[] = new short[256];\n+            short halved[] = new short[256];\n+            for (int j = 0; j < 256 ; j++) {\n+                invert[j] = (short) ((255-j) * 255);\n+                halved[j] = (short) ((j \/ 2) * 255);\n+            }\n+            ShortLookupTable lut1 = new ShortLookupTable(offset, invert);\n+            lookup1bandshort = new LookupOp(lut1, null);\n+            ShortLookupTable lut3 =\n+                new ShortLookupTable(offset,\n+                                     new short[][] {invert, halved, invert});\n+            lookup3bandshort = new LookupOp(lut3, null);\n+            ShortLookupTable lut4 =\n+                new ShortLookupTable(offset,\n+                              new short[][] {invert, halved, invert, halved});\n+            lookup4bandshort = new LookupOp(lut4, null);\n+        }\n+\n+        \/\/ 3x3 blur\n+        float[] data3 = {\n+            0.1f, 0.1f, 0.1f,\n+            0.1f, 0.2f, 0.1f,\n+            0.1f, 0.1f, 0.1f,\n+        };\n+        Kernel k3 = new Kernel(3, 3, data3);\n+\n+        \/\/ 5x5 edge\n+        float[] data5 = {\n+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n+            -1.0f, -1.0f, 24.0f, -1.0f, -1.0f,\n+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n+        };\n+        Kernel k5 = new Kernel(5, 5, data5);\n+\n+        \/\/ 7x7 blur\n+        float[] data7 = {\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+        };\n+        Kernel k7 = new Kernel(7, 7, data7);\n+\n+        convolve3x3zero = new ConvolveOp(k3, ConvolveOp.EDGE_ZERO_FILL, null);\n+        convolve5x5zero = new ConvolveOp(k5, ConvolveOp.EDGE_ZERO_FILL, null);\n+        convolve7x7zero = new ConvolveOp(k7, ConvolveOp.EDGE_ZERO_FILL, null);\n+\n+        convolve3x3noop = new ConvolveOp(k3, ConvolveOp.EDGE_NO_OP, null);\n+        convolve5x5noop = new ConvolveOp(k5, ConvolveOp.EDGE_NO_OP, null);\n+        convolve7x7noop = new ConvolveOp(k7, ConvolveOp.EDGE_NO_OP, null);\n+    }\n+\n+    public void paint(Graphics g) {\n+\n+        VolatileImage vimg = createVolatileImage(TESTW, TESTH);\n+        vimg.validate(getGraphicsConfiguration());\n+\n+        Graphics2D g2d = vimg.createGraphics();\n+        renderTest(g2d);\n+        g2d.dispose();\n+\n+        g.drawImage(vimg, 0, 0, null);\n+    }\n+\n+    \/*\n+     * foreach source image size (once with pow2, once with non-pow2)\n+     *\n+     *   foreach BufferedImage type\n+     *\n+     *     RescaleOp (1 band)\n+     *     RescaleOp (3 bands, if src has 3 bands)\n+     *     RescaleOp (4 bands, if src has 4 bands)\n+     *\n+     *     foreach LookupTable type (once with ByteLUT, once with ShortLUT)\n+     *       LookupOp (1 band)\n+     *       LookupOp (3 bands, if src has 3 bands)\n+     *       LookupOp (4 bands, if src has 4 bands)\n+     *\n+     *     foreach edge condition (once with ZERO_FILL, once with EDGE_NO_OP)\n+     *       ConvolveOp (3x3)\n+     *       ConvolveOp (5x5)\n+     *       ConvolveOp (7x7)\n+     *\/\n+    private void renderTest(Graphics2D g2d) {\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, TESTW, TESTH);\n+\n+        int yorig = 2;\n+        int xinc = 34;\n+        int yinc = srcSizes[0] + srcSizes[1] + 2 + 2;\n+\n+        for (int srcType : srcTypes) {\n+            int y = yorig;\n+\n+            for (int srcSize : srcSizes) {\n+                int x = 2;\n+                System.out.printf(\"type=%d size=%d\\n\", srcType, srcSize);\n+\n+                BufferedImage srcImg = makeSourceImage(srcSize, srcType);\n+                ColorModel srcCM = srcImg.getColorModel();\n+\n+                \/\/ RescaleOp\n+                g2d.drawImage(srcImg, rescale1band, x, y);\n+                x += xinc;\n+                \/\/ REMIND: 3-band RescaleOp.filter() throws IAE for images\n+                \/\/         that contain an alpha channel (bug to be filed)\n+                if (srcCM.getNumColorComponents() == 3 &&\n+                    !(ignore && srcCM.hasAlpha()))\n+                {\n+                    g2d.drawImage(srcImg, rescale3band, x, y);\n+                }\n+                x += xinc;\n+                if (srcCM.getNumComponents() == 4) {\n+                    g2d.drawImage(srcImg, rescale4band, x, y);\n+                }\n+                x += xinc;\n+\n+                \/\/ LookupOp\n+                \/\/ REMIND: Our LUTs are only 256 elements long, so won't\n+                \/\/         currently work with USHORT_GRAY data\n+                if (srcType != BufferedImage.TYPE_USHORT_GRAY) {\n+                    g2d.drawImage(srcImg, lookup1bandbyte, x, y);\n+                    x += xinc;\n+                    if (srcCM.getNumColorComponents() == 3) {\n+                        g2d.drawImage(srcImg, lookup3bandbyte, x, y);\n+                    }\n+                    x += xinc;\n+                    if (srcCM.getNumComponents() == 4) {\n+                        g2d.drawImage(srcImg, lookup4bandbyte, x, y);\n+                    }\n+                    x += xinc;\n+\n+                    \/\/ REMIND: LookupOp.createCompatibleDestImage() throws\n+                    \/\/         IAE for 3BYTE_BGR\/4BYTE_ABGR (bug to be filed)\n+                    if (!(ignore &&\n+                          (srcType == BufferedImage.TYPE_3BYTE_BGR ||\n+                           srcType == BufferedImage.TYPE_4BYTE_ABGR)))\n+                    {\n+                        g2d.drawImage(srcImg, lookup1bandshort, x, y);\n+                        x += xinc;\n+                        \/\/ REMIND: 3-band LookupOp.filter() throws IAE for\n+                        \/\/         images that contain an alpha channel\n+                        \/\/         (bug to be filed)\n+                        if (srcCM.getNumColorComponents() == 3 &&\n+                            !(ignore && srcCM.hasAlpha()))\n+                        {\n+                            g2d.drawImage(srcImg, lookup3bandshort, x, y);\n+                        }\n+                        x += xinc;\n+                        if (srcCM.getNumComponents() == 4) {\n+                            g2d.drawImage(srcImg, lookup4bandshort, x, y);\n+                        }\n+                        x += xinc;\n+                    } else {\n+                        x += 3*xinc;\n+                    }\n+                } else {\n+                    x += 6*xinc;\n+                }\n+\n+                \/\/ ConvolveOp\n+                \/\/ REMIND: ConvolveOp.filter() throws ImagingOpException\n+                \/\/         for 3BYTE_BGR (see 4957775)\n+                if (srcType != BufferedImage.TYPE_3BYTE_BGR) {\n+                    g2d.drawImage(srcImg, convolve3x3zero, x, y);\n+                    x += xinc;\n+                    g2d.drawImage(srcImg, convolve5x5zero, x, y);\n+                    x += xinc;\n+                    g2d.drawImage(srcImg, convolve7x7zero, x, y);\n+                    x += xinc;\n+\n+                    g2d.drawImage(srcImg, convolve3x3noop, x, y);\n+                    x += xinc;\n+                    g2d.drawImage(srcImg, convolve5x5noop, x, y);\n+                    x += xinc;\n+                    g2d.drawImage(srcImg, convolve7x7noop, x, y);\n+                    x += xinc;\n+                } else {\n+                    x += 6*xinc;\n+                }\n+\n+                y += srcSize + 2;\n+            }\n+\n+            yorig += yinc;\n+        }\n+    }\n+\n+    private BufferedImage makeSourceImage(int size, int type) {\n+        int s2 = size\/2;\n+        BufferedImage img = new BufferedImage(size, size, type);\n+        Graphics2D g2d = img.createGraphics();\n+        g2d.setComposite(AlphaComposite.Src);\n+        g2d.setColor(Color.orange);\n+        g2d.fillRect(0, 0, size, size);\n+        g2d.setColor(Color.red);\n+        g2d.fillRect(0, 0, s2, s2);\n+        g2d.setColor(Color.green);\n+        g2d.fillRect(s2, 0, s2, s2);\n+        g2d.setColor(Color.blue);\n+        g2d.fillRect(0, s2, s2, s2);\n+        g2d.setColor(new Color(255, 255, 0, 128));\n+        g2d.fillRect(s2, s2, s2, s2);\n+        g2d.setColor(Color.pink);\n+        g2d.fillOval(s2-3, s2-3, 6, 6);\n+        g2d.dispose();\n+        return img;\n+    }\n+\n+    public BufferedImage makeReferenceImage() {\n+        BufferedImage img = new BufferedImage(TESTW, TESTH,\n+                                              BufferedImage.TYPE_INT_RGB);\n+        Graphics2D g2d = img.createGraphics();\n+        renderTest(g2d);\n+        g2d.dispose();\n+        return img;\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(TESTW, TESTH);\n+    }\n+\n+    private static void compareImages(BufferedImage refImg,\n+                                      BufferedImage testImg,\n+                                      int tolerance)\n+    {\n+        int x1 = 0;\n+        int y1 = 0;\n+        int x2 = refImg.getWidth();\n+        int y2 = refImg.getHeight();\n+\n+        for (int y = y1; y < y2; y++) {\n+            for (int x = x1; x < x2; x++) {\n+                Color expected = new Color(refImg.getRGB(x, y));\n+                Color actual   = new Color(testImg.getRGB(x, y));\n+                if (!isSameColor(expected, actual, tolerance)) {\n+                    saveImage(\"referenceimage\", refImg);\n+                    saveImage(\"testimage\", testImg);\n+                    throw new RuntimeException(\"Test failed at x=\"+x+\" y=\"+y+\n+                                               \" (expected=\"+expected+\n+                                               \" actual=\"+actual+\n+                                               \")\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean isSameColor(Color c1, Color c2, int e) {\n+        int r1 = c1.getRed();\n+        int g1 = c1.getGreen();\n+        int b1 = c1.getBlue();\n+        int r2 = c2.getRed();\n+        int g2 = c2.getGreen();\n+        int b2 = c2.getBlue();\n+        int rmin = Math.max(r2-e, 0);\n+        int gmin = Math.max(g2-e, 0);\n+        int bmin = Math.max(b2-e, 0);\n+        int rmax = Math.min(r2+e, 255);\n+        int gmax = Math.min(g2+e, 255);\n+        int bmax = Math.min(b2+e, 255);\n+        if (r1 >= rmin && r1 <= rmax &&\n+            g1 >= gmin && g1 <= gmax &&\n+            b1 >= bmin && b1 <= bmax)\n+        {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+\n+    static void createUI() {\n+        test = new DrawBufImgOp();\n+        Panel panel = new Panel();\n+        panel.add(test);\n+        frame = new Frame(\"OpenGL DrawBufImgOp Test\");\n+        frame.add(panel);\n+        frame.setSize(TESTW+100, TESTH+100);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        boolean show = false;\n+        boolean dump = false;\n+        boolean compare = false;\n+\n+        for (String arg : args) {\n+            if (arg.equals(\"-show\")) {\n+                show = true;\n+            } else if (arg.equals(\"-dump\")) {\n+                dump = true;\n+            } else if (arg.equals(\"-compare\")) {\n+                compare = true;\n+            } else if (arg.equals(\"-ignore\")) {\n+                ignore = true;\n+            }\n+        }\n+\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(DrawBufImgOp::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        BufferedImage capture = null;\n+        try {\n+            GraphicsConfiguration gc = frame.getGraphicsConfiguration();\n+            if (gc.getColorModel() instanceof IndexColorModel) {\n+                System.out.println(\"IndexColorModel detected: \" +\n+                                   \"test considered PASSED\");\n+                return;\n+            }\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, TESTW, TESTH);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Compare the images (allow for +\/- 1 bit differences in color comps)\n+        if (dump || compare) {\n+            BufferedImage ref = test.makeReferenceImage();\n+            if (dump) {\n+                saveImage(\"DrawBufImgOp_ref\", ref);\n+                saveImage(\"DrawBufImgOp_cap\", capture);\n+            }\n+            if (compare) {\n+                test.compareImages(ref, capture, 1);\n+            }\n+        }\n+    }\n+\n+    static void saveImage(String name, BufferedImage img) {\n+        try {\n+            File file = new File(name + \".png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/DrawBufImgOp.java","additions":514,"deletions":0,"binary":false,"changes":514,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4993274\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that managed image copies and transforms work properly\n+ * with the OGL pipeline when a background color is specified.\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 DrawImageBg\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 DrawImageBg\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4993274\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that managed image copies and transforms work properly\n+ * with the OGL pipeline when a background color is specified.\n+ * @run main\/othervm -Dsun.java2d.opengl=True DrawImageBg\n+ * @run main\/othervm DrawImageBg\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Transparency;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class DrawImageBg extends Panel {\n+\n+    static volatile Frame frame;\n+    static volatile DrawImageBg test;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        BufferedImage img = getGraphicsConfiguration().createCompatibleImage(50, 50,\n+                                                   Transparency.BITMASK);\n+        Graphics2D gimg = img.createGraphics();\n+        gimg.setComposite(AlphaComposite.Src);\n+        gimg.setColor(new Color(0, 0, 0, 0));\n+        gimg.fillRect(0, 0, 50, 50);\n+        gimg.setColor(Color.red);\n+        gimg.fillRect(10, 10, 30, 30);\n+        gimg.dispose();\n+\n+        g2d.drawImage(img, 10, 10, Color.blue, null);\n+\n+        \/\/ draw a second time to ensure that the cached copy is used\n+        g2d.drawImage(img, 80, 10, Color.blue, null);\n+    }\n+\n+    static void createUI() {\n+        frame = new Frame(\"OpenGL DrawImageBg Test\");\n+        test = new DrawImageBg();\n+        frame.add(test);\n+        frame.setSize(300, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        BufferedImage capture = null;\n+        Robot robot = new Robot();\n+        try {\n+            EventQueue.invokeAndWait(DrawImageBg::createUI);\n+            robot.waitForIdle();\n+            robot.delay(3000);\n+\n+            \/\/ Grab the screen region\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x+80, pt1.y, 80, 80);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        if (capture == null) {\n+            throw new RuntimeException(\"Screen capture is null\");\n+        }\n+\n+        \/\/ Test inner and outer pixels\n+        int pixel1 = capture.getRGB(5, 10);\n+        if (pixel1 != 0xff0000ff) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"outer\", pixel1));\n+        }\n+        int pixel2 = capture.getRGB(25, 25);\n+        if (pixel2 != 0xffff0000) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"inner\", pixel2));\n+        }\n+    }\n+\n+    static String getMsg(String r, int p1) {\n+         return \"Failed: Incorrect color for \" + r + \" pixel: got \" + Integer.toHexString(p1);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/DrawImageBg.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6219284 6358147 6274813 6578452\n+ * @key headful\n+ * @summary Verifies that OGLRenderer.drawPoly(),\n+ * OGLTextRenderer.drawGlyphList(), and OGLMaskFill work properly when the\n+ * operation parameters exceed the capacity of the render queue.  With the\n+ * single-threaded OpenGL pipeline, there are some operations that require\n+ * a separate buffer to be spawned if the parameters cannot fit entirely on\n+ * the standard buffer.  This test exercises this special case.\n+ * @run main\/othervm  -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 -Dsun.java2d.opengl.lcdshader=true LargeOps\n+ *\/\n+\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Robot;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class LargeOps extends Canvas {\n+\n+    private static final int NUM_POINTS = 8000;\n+    private int[] xPoints, yPoints;\n+    private String str;\n+\n+    public LargeOps() {\n+        xPoints = new int[NUM_POINTS];\n+        yPoints = new int[NUM_POINTS];\n+        for (int i = 0; i < NUM_POINTS; i++) {\n+            xPoints[i] = (i % 2 == 0) ? 10 : 400;\n+            yPoints[i] = (i % 2 == 1) ? i+3 : i;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < NUM_POINTS; i+=11) {\n+            sb.append(\"ThisIsATest\");\n+        }\n+        str = sb.toString();\n+    }\n+\n+    public void paint(Graphics g) {\n+        Graphics2D g2d = (Graphics2D)g;\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        \/\/ draw large polyline\n+        g2d.setColor(Color.green);\n+        g2d.drawPolyline(xPoints, yPoints, NUM_POINTS);\n+\n+        \/\/ draw long string\n+        g2d.setColor(Color.blue);\n+        g2d.drawString(str, 10, 100);\n+\n+        \/\/ draw long string with larger pt size\n+        Font font = g2d.getFont();\n+        g2d.setFont(font.deriveFont(40.0f));\n+        g2d.drawString(str, 10, 150);\n+\n+        \/\/ do the same with LCD hints enabled\n+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                             RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);\n+        g2d.setFont(font);\n+        g2d.drawString(str, 10, 200);\n+        g2d.setFont(font.deriveFont(43.0f));\n+        g2d.drawString(str, 10, 250);\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                             RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HBGR);\n+        g2d.setFont(font);\n+        g2d.drawString(str, 10, 300);\n+        g2d.setFont(font.deriveFont(37.0f));\n+        g2d.drawString(str, 10, 350);\n+    }\n+\n+    static volatile Frame frame;\n+    static volatile LargeOps test;\n+\n+    static void createUI() {\n+        frame = new Frame(\"OpenGL LargeOps Test\");\n+        frame.addWindowListener(new WindowAdapter() {\n+                public void windowClosing(WindowEvent e) {\n+                    frame.dispose();\n+                }\n+            });\n+        test = new LargeOps();\n+        frame.add(test);\n+        frame.setSize(600, 600);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+             Robot robot = new Robot();\n+             EventQueue.invokeAndWait(LargeOps::createUI);\n+             robot.waitForIdle();\n+             robot.delay(6000);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/LargeOps.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6277977 6319663\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that blending operations do not inadvertantly leave\n+ * non-opaque alpha values in the framebuffer.  Note that this test is\n+ * intended to run on GraphicsConfigs that support a stored alpha channel\n+ * (to verify the bug at hand), but it is also a useful for testing the\n+ * compositing results on any configuration.\n+ * @run main\/othervm  -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 OpaqueDest\n+ * @run main\/othervm  -Dsun.java2d.uiScale=1 OpaqueDest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6277977 6319663\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that blending operations do not inadvertantly leave\n+ * non-opaque alpha values in the framebuffer.  Note that this test is\n+ * intended to run on GraphicsConfigs that support a stored alpha channel\n+ * (to verify the bug at hand), but it is also a useful for testing the\n+ * compositing results on any configuration.\n+ * @run main\/othervm -Dsun.java2d.opengl=True OpaqueDest\n+ * @run main\/othervm  OpaqueDest\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class OpaqueDest extends Canvas {\n+\n+    private static volatile Frame frame;\n+    private static volatile OpaqueDest test;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        g2d.setColor(Color.red);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        \/\/ This will clear the rectangle to black\n+        g2d.setComposite(AlphaComposite.Clear);\n+        g2d.fillRect(10, 10, 80, 80);\n+\n+        \/\/ If everything is working properly, then this will fill the\n+        \/\/ rectangle with red again.  Before this bug was fixed, the previous\n+        \/\/ Clear operation would leave zero values in the destination's\n+        \/\/ alpha channel (if present), and therefore a SrcIn operation\n+        \/\/ would result in all-black.\n+        g2d.setComposite(AlphaComposite.SrcIn);\n+        g2d.fillRect(10, 10, 80, 80);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(100, 100);\n+    }\n+\n+    static void createUI() {\n+        test = new OpaqueDest();\n+        frame = new Frame(\"OpenGL OpaqueDest Test\");\n+        Panel p = new Panel();\n+        p.add(test);\n+        frame.add(p);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(OpaqueDest::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        BufferedImage capture = null;\n+        try {\n+            GraphicsConfiguration gc = frame.getGraphicsConfiguration();\n+            if (gc.getColorModel() instanceof IndexColorModel) {\n+                System.out.println(\"IndexColorModel detected: \" +\n+                                   \"test considered PASSED\");\n+                return;\n+            }\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 100, 100);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+\n+        \/\/ Test all pixels (every one should be red)\n+        for (int y = 0; y < 100; y++) {\n+            for (int x = 0; x < 100; x++) {\n+                int actual = capture.getRGB(x, y);\n+                    int expected = 0xffff0000;\n+                if (!similar(actual, expected)) {\n+                    saveImage(capture);\n+                    throw new RuntimeException(\"Test failed at x=\"+x+\" y=\"+y+\n+                                               \" (expected=\"+\n+                                               Integer.toHexString(expected) +\n+                                               \" actual=\"+\n+                                               Integer.toHexString(actual) +\n+                                               \")\");\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean similar(int p1, int p2) {\n+        int a1 = (p1 >> 24) & 0xff;\n+        int r1 = (p1 >> 16) & 0xff;\n+        int g1 = (p1 >> 8) & 0xff;\n+        int b1 = p1 & 0xff;\n+        int a2 = (p2 >> 24) & 0xff;\n+        int r2 = (p2 >> 16) & 0xff;\n+        int g2 = (p2 >> 8) & 0xff;\n+        int b2 = p2 & 0xff;\n+\n+        int allowedDiff = 0x01; \/\/ tiny rounding error allowed.\n+        return\n+            (Math.abs(a1 - a2) <= allowedDiff) &&\n+            (Math.abs(r1 - r2) <= allowedDiff) &&\n+            (Math.abs(g1 - g2) <= allowedDiff) &&\n+            (Math.abs(b1 - b2) <= allowedDiff);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/OpaqueDest.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5104584 8237244\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that scaling an image works properly when the\n+ * source parameters are outside the source bounds.\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 ScaleParamsOOB\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 ScaleParamsOOB\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5104584 8237244\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that scaling an image works properly when the\n+ * source parameters are outside the source bounds.\n+ * @run main\/othervm -Dsun.java2d.opengl=True ScaleParamsOOB\n+ * @run main\/othervm ScaleParamsOOB\n+ *\/\n+\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class ScaleParamsOOB extends Panel {\n+\n+    private static final int TOLERANCE = 12;\n+\n+    private static volatile ScaleParamsOOB test;\n+    private static volatile Frame frame;\n+\n+    private BufferedImage img;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        BufferedImage img = getGraphicsConfiguration().createCompatibleImage(40, 40);\n+        Graphics2D gimg = img.createGraphics();\n+        gimg.setColor(Color.red);\n+        gimg.fillRect(0, 0, 40, 40);\n+        gimg.dispose();\n+\n+        \/\/ first time will be a sw->surface blit\n+        g2d.drawImage(img,\n+                      10, 10, 90, 90,\n+                      -60, -60, 100, 100,\n+                      null);\n+\n+        \/\/ second time will be a texture->surface blit\n+        g2d.drawImage(img,\n+                      110, 10, 190, 90,\n+                      -60, -60, 100, 100,\n+                      null);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(300, 200);\n+    }\n+\n+    private static void testRegion(BufferedImage bi,\n+                                   Rectangle wholeRegion,\n+                                   Rectangle affectedRegion)\n+    {\n+        int x1 = wholeRegion.x;\n+        int y1 = wholeRegion.y;\n+        int x2 = x1 + wholeRegion.width;\n+        int y2 = y1 + wholeRegion.height;\n+\n+        for (int y = y1; y < y2; y++) {\n+            for (int x = x1; x < x2; x++) {\n+                int actual = bi.getRGB(x, y);\n+                int expected = 0;\n+                if (affectedRegion.contains(x, y)) {\n+                    expected = Color.red.getRGB();\n+                } else {\n+                    expected = Color.black.getRGB();\n+                }\n+                int alpha = (actual >> 24) & 0xFF;\n+                int red = (actual >> 16) & 0xFF;\n+                int green = (actual >> 8) & 0xFF;\n+                int blue = (actual) & 0xFF;\n+\n+                int standardAlpha = (expected >> 24) & 0xFF;\n+                int standardRed = (expected >> 16) & 0xFF;\n+                int standardGreen = (expected >> 8) & 0xFF;\n+                int standardBlue = (expected) & 0xFF;\n+\n+                if ((Math.abs(alpha - standardAlpha) > TOLERANCE) ||\n+                    (Math.abs(red - standardRed) > TOLERANCE) ||\n+                    (Math.abs(green - standardGreen) > TOLERANCE) ||\n+                    (Math.abs(blue - standardBlue) > TOLERANCE)) {\n+                    saveImage(bi);\n+                    throw new RuntimeException(\"Test failed at x=\"+x+\" y=\"+y+\n+                                               \" (expected=\"+\n+                                               Integer.toHexString(expected) +\n+                                               \" actual=\"+\n+                                               Integer.toHexString(actual) +\n+                                               \")\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void createAndShowGUI() {\n+        test = new ScaleParamsOOB();\n+        frame = new Frame(\"OpenGL ScaleParamsOOB Test\");\n+        frame.setAlwaysOnTop(true);\n+        frame.add(test);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(() -> createAndShowGUI());\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        \/\/ Grab the screen region\n+        BufferedImage capture = null;\n+        try {\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 200, 200);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test background color\n+        int pixel = capture.getRGB(5, 5);\n+        if (pixel != 0xff000000) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"background: \" + Integer.toHexString(pixel));\n+        }\n+\n+        \/\/ Test pixels\n+        testRegion(capture,\n+                   new Rectangle(5, 5, 90, 90),\n+                   new Rectangle(40, 40, 20, 20));\n+        testRegion(capture,\n+                   new Rectangle(105, 5, 90, 90),\n+                   new Rectangle(140, 40, 20, 20));\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/ScaleParamsOOB.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5002133\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that the OpenGL pipeline does not affect the color\n+ * buffer when setting up a complex (shape) clip region.  The test fails if\n+ * the circular clip region is filled with a green color (the green region\n+ * should not be visible at all).\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 ShapeClip\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 ShapeClip\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5002133\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that the OpenGL pipeline does not affect the color\n+ * buffer when setting up a complex (shape) clip region.  The test fails if\n+ * the circular clip region is filled with a green color (the green region\n+ * should not be visible at all).\n+ * @run main\/othervm -Dsun.java2d.opengl=True ShapeClip\n+ * @run main\/othervm ShapeClip\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class ShapeClip extends Panel {\n+\n+    private static volatile Frame frame;\n+    private static volatile ShapeClip test;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        int width = getWidth();\n+        int height = getHeight();\n+\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, width, height);\n+\n+        g2d.setColor(Color.green);\n+        g2d.fillRect(0, 0, 1, 1);\n+        g2d.setClip(new Ellipse2D.Double(10, 10, 100, 100));\n+        g2d.setColor(Color.blue);\n+        g2d.fillRect(30, 30, 20, 20);\n+    }\n+\n+    static void createUI() {\n+        test = new ShapeClip();\n+        frame = new Frame(\"OpenGL ShapeClip Test\");\n+        frame.add(test);\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(ShapeClip::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        \/\/ Grab the screen region\n+        BufferedImage capture = null;\n+        try {\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 80, 80);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test blue rectangle\n+        int pixel1 = capture.getRGB(40, 40);\n+        if (pixel1 != 0xff0000ff) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"rectangle \" + Integer.toHexString(pixel1));\n+        }\n+\n+        \/\/ Test clip region (should be same color as background)\n+        int pixel2 = capture.getRGB(60, 40);\n+        if (pixel2 != 0xff000000) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"clip region \" + Integer.toHexString(pixel2));\n+        }\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/ShapeClip.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4942939 4970674\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that OGLMaskFill, OGLMaskBlit, and OGLTextRenderer\n+ * operations work properly for non-SrcOver composites.\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 SrcMaskOps\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 SrcMaskOps\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4942939 4970674\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that OGLMaskFill, OGLMaskBlit, and OGLTextRenderer\n+ * operations work properly for non-SrcOver composites.\n+ * @run main\/othervm -Dsun.java2d.opengl=True SrcMaskOps\n+ * @run main\/othervm SrcMaskOps\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class SrcMaskOps extends Panel {\n+\n+    static volatile Frame frame;\n+    static volatile SrcMaskOps test;\n+\n+    static final int SRX = 50;\n+    static final int SRY = 50;\n+    static final int GPX = 90;\n+    static final int GPY = 50;\n+    static final int DTX = 120;\n+    static final int DTY = 70;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                             RenderingHints.VALUE_ANTIALIAS_ON);\n+        g2d.setComposite(AlphaComposite.Src);\n+\n+        g2d.setColor(Color.blue);\n+        g2d.drawRect(SRX, SRY, 20, 20);\n+\n+        g2d.setPaint(new GradientPaint(0.0f, 0.0f, Color.red,\n+                                       100.0f, 100.f, Color.red, true));\n+        g2d.drawRect(GPX, GPY, 20, 20);\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                             RenderingHints.VALUE_ANTIALIAS_OFF);\n+\n+        g2d.setColor(Color.red);\n+        Font font = new Font(Font.DIALOG, Font.PLAIN, 20);\n+        g2d.setFont(font);\n+        g2d.drawString(\"HELLO\", DTX, DTY);\n+    }\n+\n+    static void createUI() {\n+        frame = new Frame(\"OpenGL SrcMaskOps Test\");\n+        test = new SrcMaskOps();\n+        frame.add(test);\n+        frame.setSize(300, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Robot robot = new Robot();\n+        BufferedImage capture = null;\n+        try {\n+            EventQueue.invokeAndWait(SrcMaskOps::createUI);\n+            robot.waitForIdle();\n+            robot.delay(3000);\n+\n+            \/\/ Grab the screen region\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 300, 300);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test solid rectangle\n+        int pixel1, pixel2;\n+        pixel1 = capture.getRGB(SRX, SRY);\n+        pixel2 = capture.getRGB(SRX+2, SRY+2);\n+        if (!similar(pixel1, 0xff0000ff) || !similar(pixel2, 0xffffffff)) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"solid rectangle\", pixel1, pixel2));\n+        }\n+\n+        \/\/ Test GradientPaint rectangle\n+        pixel1 = capture.getRGB(GPX, GPY);\n+        pixel2 = capture.getRGB(GPX+2, GPY+2);\n+        if (!similar(pixel1, 0xffff0000) || !similar(pixel2, 0xffffffff)) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"GradientPaint rectangle\", pixel1, pixel2));\n+        }\n+\n+        \/\/ Test solid text\n+        pixel1 = capture.getRGB(DTX+2, DTY-5);\n+        pixel2 = capture.getRGB(DTX+5, DTY-5);\n+        if (!similar(pixel1, 0xffff0000) || !similar(pixel2, 0xffffffff)) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"solid text\", pixel1, pixel2));\n+        }\n+\n+    }\n+\n+    static boolean similar(int p1, int p2) {\n+        int a1 = (p1 >> 24) & 0xff;\n+        int r1 = (p1 >> 16) & 0xff;\n+        int g1 = (p1 >> 8) & 0xff;\n+        int b1 = p1 & 0xff;\n+        int a2 = (p2 >> 24) & 0xff;\n+        int r2 = (p2 >> 16) & 0xff;\n+        int g2 = (p2 >> 8) & 0xff;\n+        int b2 = p2 & 0xff;\n+\n+        int allowedDiff = 0x10;\n+        return\n+            (Math.abs(a1 - a2) <= allowedDiff) &&\n+            (Math.abs(r1 - r2) <= allowedDiff) &&\n+            (Math.abs(g1 - g2) <= allowedDiff) &&\n+            (Math.abs(b1 - b2) <= allowedDiff);\n+    }\n+\n+    static String getMsg(String r, int p1, int p2) {\n+         return \"Failed: Incorrect color[s] for \" + r + \" got \" +\n+                Integer.toHexString(p1) + \" and \" + Integer.toHexString(p2);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/SrcMaskOps.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6244071\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that copying a subregion from a VolatileImage works\n+ * properly with the OGL pipeline.\n+ * @run main\/othervm -Dsun.java2d.uiScale=1  VolatileSubRegion\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 -Dsun.java2d.opengl.fbobject=true VolatileSubRegion\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 -Dsun.java2d.opengl.fbobject=false VolatileSubRegion\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6244071\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that copying a subregion from a VolatileImage works\n+ * properly with the OGL pipeline.\n+ * @run main\/othervm VolatileSubRegion\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=true VolatileSubRegion\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=false VolatileSubRegion\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.VolatileImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class VolatileSubRegion extends Panel {\n+\n+    private VolatileImage img;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        if (img == null) {\n+            img = createVolatileImage(200, 200);\n+            Graphics2D goff = img.createGraphics();\n+            goff.setColor(Color.green);\n+            goff.fillRect(50, 0, 100, 50);\n+            goff.setColor(Color.blue);\n+            goff.fillRect(0, 0, 200, 200);\n+            goff.setColor(Color.red);\n+            goff.fillRect(50, 50, 100, 100);\n+            goff.setColor(Color.yellow);\n+            goff.fillRect(50, 150, 100, 50);\n+            goff.dispose();\n+        }\n+\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        g2d.drawImage(img,\n+                      50, 50, 200, 200,\n+                      50, 50, 200, 200,\n+                      null);\n+\n+    }\n+\n+\n+    private static volatile VolatileSubRegion test;\n+    private static volatile Frame frame;\n+\n+    static void createUI() {\n+        test = new VolatileSubRegion();\n+        frame = new Frame(\"OpenGL VolatileSubRegion Test\");\n+        frame.add(test);\n+        frame.setSize(300, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(VolatileSubRegion::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        BufferedImage capture = null;\n+        try {\n+            GraphicsConfiguration gc = frame.getGraphicsConfiguration();\n+            if (gc.getColorModel() instanceof IndexColorModel) {\n+                System.out.println(\"IndexColorModel detected: \" +\n+                                   \"test considered PASSED\");\n+                return;\n+            }\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 200, 200);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test pixels\n+        int pixel1 = capture.getRGB(49, 50);\n+        if (pixel1 != 0xffffffff) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"background pixel\", pixel1));\n+        }\n+        int pixel2 = capture.getRGB(50, 50);\n+        if (pixel2 != 0xffff0000) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"red region\", pixel2));\n+        }\n+        int pixel3 = capture.getRGB(50, 150);\n+        if (pixel3 != 0xffffff00) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"yellow region\", pixel3));\n+        }\n+    }\n+\n+    static String getMsg(String r, int p1) {\n+         return \"Failed: Incorrect color for \" + r + \" : got \" + Integer.toHexString(p1);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/VolatileSubRegion.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4970836\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that transformed VolatileImage copies work properly with\n+ * the OGL pipeline.\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 XformVolatile\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 -Dsun.java2d.opengl.fbobject=true XformVolatile\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 -Dsun.java2d.opengl.fbobject=false XformVolatile\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4970836\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that transformed VolatileImage copies work properly with\n+ * the OGL pipeline.\n+ * @run main\/othervm XformVolatile\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=true XformVolatile\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=false XformVolatile\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.VolatileImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class XformVolatile extends Panel {\n+\n+    private static volatile Frame frame;\n+    private static volatile XformVolatile test;\n+    private volatile VolatileImage img;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        if (img == null) {\n+            img = createVolatileImage(200, 200);\n+            Graphics2D goff = img.createGraphics();\n+            goff.setColor(Color.blue);\n+            goff.fillRect(0, 0, 200, 200);\n+            goff.setColor(Color.red);\n+            goff.fillPolygon(new int[] {10, 100, 190},\n+                             new int[] {190, 10, 190}, 3);\n+            goff.dispose();\n+        }\n+\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        g2d.rotate(Math.toRadians(3.0));\n+        g2d.drawImage(img, 0, 0, null);\n+    }\n+\n+    static void createUI() {\n+        test = new XformVolatile();\n+        frame = new Frame(\"OpenGL XformVolatile Test\");\n+        frame.add(test);\n+        frame.setSize(300, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(XformVolatile::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        \/\/ Grab the screen region\n+        BufferedImage capture = null;\n+        try {\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 200, 200);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+             if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+             }\n+        }\n+\n+        \/\/ Test inner and outer pixels\n+        int pixel1 = capture.getRGB(5, 175);\n+        if (pixel1 != 0xff0000ff) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"inner\", pixel1));\n+        }\n+        int pixel2 = capture.getRGB(5, 188);\n+        if (pixel2 != 0xffff0000) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"inner\", pixel2));\n+        }\n+    }\n+\n+    static String getMsg(String r, int p1) {\n+         return \"Failed: Incorrect color for \" + r + \" pixel: got \" + Integer.toHexString(p1);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/XformVolatile.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}