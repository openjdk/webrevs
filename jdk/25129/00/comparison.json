{"files":[{"patch":"@@ -26,0 +26,7 @@\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.test.AdditionalLauncher.forEachAdditionalLauncher;\n+\n@@ -30,0 +37,1 @@\n+import java.nio.file.InvalidPathException;\n@@ -49,1 +57,0 @@\n-import static jdk.jpackage.test.AdditionalLauncher.forEachAdditionalLauncher;\n@@ -81,0 +88,1 @@\n+        readOnlyPathAsserts = cmd.readOnlyPathAsserts;\n@@ -846,4 +854,7 @@\n-        Executor.Result result = new JPackageCommand(this)\n-                .adjustArgumentsBeforeExecution()\n-                .createExecutor()\n-                .execute(expectedExitCode);\n+        final var copy = new JPackageCommand(this).adjustArgumentsBeforeExecution();\n+\n+        final var directoriesAssert = new ReadOnlyPathsAssert(copy);\n+\n+        Executor.Result result = copy.createExecutor().execute(expectedExitCode);\n+\n+        directoriesAssert.updateAndAssert();\n@@ -906,0 +917,130 @@\n+    private static final class ReadOnlyPathsAssert {\n+        ReadOnlyPathsAssert(JPackageCommand cmd) {\n+            this.asserts = cmd.readOnlyPathAsserts.stream().map(a -> {\n+                return a.getPaths(cmd).stream().map(dir -> {\n+                    return Map.entry(a, dir);\n+                });\n+            }).flatMap(x -> x).collect(groupingBy(Map.Entry::getKey, mapping(Map.Entry::getValue, toList())));\n+            snapshots = createSnapshots();\n+        }\n+\n+        void updateAndAssert() {\n+            final var newSnapshots = createSnapshots();\n+            for (final var a : asserts.keySet().stream().sorted().toList()) {\n+                final var snapshopGroup = snapshots.get(a);\n+                final var newSnapshopGroup = newSnapshots.get(a);\n+                for (int i = 0; i < snapshopGroup.size(); i++) {\n+                    TKit.PathSnapshot.assertEquals(snapshopGroup.get(i), newSnapshopGroup.get(i),\n+                            String.format(\"Check jpackage didn't modify ${%s}=[%s]\", a, asserts.get(a).get(i)));\n+                }\n+            }\n+        }\n+\n+        private Map<ReadOnlyPathAssert, List<TKit.PathSnapshot>> createSnapshots() {\n+            return asserts.entrySet().stream()\n+                    .map(e -> {\n+                        return Map.entry(e.getKey(), e.getValue().stream().map(TKit.PathSnapshot::new).toList());\n+                    }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+        }\n+\n+        private final Map<ReadOnlyPathAssert, List<Path>> asserts;\n+        private final Map<ReadOnlyPathAssert, List<TKit.PathSnapshot>> snapshots;\n+    }\n+\n+    public static enum ReadOnlyPathAssert{\n+        APP_IMAGE(new Builder(\"--app-image\").enable(cmd -> {\n+            \/\/ External app image should be R\/O unless it is an app image signing on macOS.\n+            return !(TKit.isOSX() && MacHelper.signPredefinedAppImage(cmd));\n+        }).create()),\n+        APP_CONTENT(new Builder(\"--app-content\").multiple().create()),\n+        RESOURCE_DIR(new Builder(\"--resource-dir\").create()),\n+        MAC_DMG_CONTENT(new Builder(\"--mac-dmg-content\").multiple().create()),\n+        RUNTIME_IMAGE(new Builder(\"--runtime-image\").create());\n+\n+        ReadOnlyPathAssert(Function<JPackageCommand, List<Path>> getPaths) {\n+            this.getPaths = getPaths;\n+        }\n+\n+        List<Path> getPaths(JPackageCommand cmd) {\n+            return getPaths.apply(cmd).stream().toList();\n+        }\n+\n+        private final static class Builder {\n+\n+            Builder(String argName) {\n+                this.argName = Objects.requireNonNull(argName);\n+            }\n+\n+            Builder multiple() {\n+                multiple = true;\n+                return this;\n+            }\n+\n+            Builder enable(Predicate<JPackageCommand> v) {\n+                enable = v;\n+                return this;\n+            }\n+\n+            Function<JPackageCommand, List<Path>> create() {\n+                return cmd -> {\n+                    if (enable != null && !enable.test(cmd)) {\n+                        return List.of();\n+                    } else {\n+                        final List<Optional<Path>> dirs;\n+                        if (multiple) {\n+                            dirs = Stream.of(cmd.getAllArgumentValues(argName))\n+                                    .map(Builder::tokenizeValue)\n+                                    .flatMap(x -> x)\n+                                    .map(Builder::toExistingFile).toList();\n+                        } else {\n+                            dirs = Optional.ofNullable(cmd.getArgumentValue(argName))\n+                                    .map(Builder::toExistingFile).map(List::of).orElseGet(List::of);\n+                        }\n+\n+                        final var mutablePaths = Stream.of(\"--temp\", \"--dest\")\n+                                .map(cmd::getArgumentValue)\n+                                .filter(Objects::nonNull)\n+                                .map(Builder::toExistingFile)\n+                                .filter(Optional::isPresent).map(Optional::orElseThrow)\n+                                .collect(toSet());\n+\n+                        return dirs.stream()\n+                                .filter(Optional::isPresent).map(Optional::orElseThrow)\n+                                .filter(Predicate.not(mutablePaths::contains))\n+                                .toList();\n+                    }\n+                };\n+            }\n+\n+            private static Optional<Path> toExistingFile(String path) {\n+                Objects.requireNonNull(path);\n+                try {\n+                    return Optional.of(Path.of(path)).filter(Files::exists).map(Path::toAbsolutePath);\n+                } catch (InvalidPathException ex) {\n+                    return Optional.empty();\n+                }\n+            }\n+\n+            private static Stream<String> tokenizeValue(String str) {\n+                return Stream.of(str.split(\",\"));\n+            }\n+\n+            private Predicate<JPackageCommand> enable;\n+            private final String argName;\n+            private boolean multiple;\n+        }\n+\n+        private final Function<JPackageCommand, List<Path>> getPaths;\n+    }\n+\n+    public JPackageCommand setReadOnlyPathAsserts(ReadOnlyPathAssert... asserts) {\n+        readOnlyPathAsserts = Set.of(asserts);\n+        return this;\n+    }\n+\n+    public JPackageCommand excludeReadOnlyPathAssert(ReadOnlyPathAssert... asserts) {\n+        var asSet = Set.of(asserts);\n+        return setReadOnlyPathAsserts(readOnlyPathAsserts.stream().filter(Predicate.not(\n+                asSet::contains)).toArray(ReadOnlyPathAssert[]::new));\n+    }\n+\n@@ -1321,0 +1462,1 @@\n+    private Set<ReadOnlyPathAssert> readOnlyPathAsserts = Set.of(ReadOnlyPathAssert.values());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":147,"deletions":5,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.file.LinkOption;\n@@ -1133,0 +1134,41 @@\n+    public record PathSnapshot(List<String> contentHashes) {\n+        public PathSnapshot {\n+            contentHashes.forEach(Objects::requireNonNull);\n+        }\n+\n+        public PathSnapshot(Path path) {\n+            this(hashRecursive(path));\n+        }\n+\n+        public static void assertEquals(PathSnapshot a, PathSnapshot b, String msg) {\n+            assertStringListEquals(a.contentHashes(), b.contentHashes(), msg);\n+        }\n+\n+        private static List<String> hashRecursive(Path path) {\n+            try {\n+                try (final var walk = Files.walk(path)) {\n+                    return walk.sorted().map(p -> {\n+                        final String hash;\n+                        if (Files.isDirectory(p, LinkOption.NOFOLLOW_LINKS)) {\n+                            hash = \"\";\n+                        } else {\n+                            hash = hashFile(p);\n+                        }\n+                        return String.format(\"%s#%s\", path.relativize(p), hash);\n+                    }).toList();\n+                }\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static String hashFile(Path path) {\n+            try {\n+                final var time = Files.getLastModifiedTime(path, LinkOption.NOFOLLOW_LINKS);\n+                return time.toString();\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"}]}