{"files":[{"patch":"@@ -1000,0 +1000,1 @@\n+                                     \"Z\"                                                                                                       \\\n@@ -1014,0 +1015,1 @@\n+                                            \"Z\"                                                                                                \\\n@@ -1029,0 +1031,1 @@\n+                                      \"Z\"                                                                                                      \\\n@@ -1043,0 +1046,1 @@\n+                                             \"Z\"                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -931,1 +931,1 @@\n-static bool elem_consistent_with_arr(BasicType elem_bt, const TypeAryPtr* arr_type) {\n+static bool elem_consistent_with_arr(BasicType elem_bt, const TypeAryPtr* arr_type, bool mismatched_ms) {\n@@ -943,1 +943,1 @@\n-    return false;\n+    return mismatched_ms;\n@@ -947,19 +947,20 @@\n-\/\/ public static\n-\/\/ <C,\n-\/\/  VM,\n-\/\/  E,\n-\/\/  S extends VectorSpecies<E>>\n-\/\/ VM load(Class<? extends VM> vmClass, Class<E> elementType, int length,\n-\/\/         Object base, long offset,    \/\/ Unsafe addressing\n-\/\/         C container, long index, S s,     \/\/ Arguments for default implementation\n-\/\/         LoadOperation<C, VM, E, S> defaultImpl)\n-\/\/\n-\/\/ public static\n-\/\/ <C,\n-\/\/  V extends Vector<?>>\n-\/\/ void store(Class<?> vectorClass, Class<?> elementType, int length,\n-\/\/            Object base, long offset,    \/\/ Unsafe addressing\n-\/\/            V v,\n-\/\/            C container, long index,      \/\/ Arguments for default implementation\n-\/\/            StoreVectorOperation<C, V> defaultImpl)\n-\n+\/\/  public static\n+\/\/  <C,\n+\/\/   VM extends VectorPayload,\n+\/\/   E,\n+\/\/   S extends VectorSpecies<E>>\n+\/\/  VM load(Class<? extends VM> vmClass, Class<E> eClass,\n+\/\/          int length,\n+\/\/          Object base, long offset,            \/\/ Unsafe addressing\n+\/\/          boolean fromSegment,\n+\/\/          C container, long index, S s,        \/\/ Arguments for default implementation\n+\/\/          LoadOperation<C, VM, S> defaultImpl) {\n+\/\/  public static\n+\/\/  <C,\n+\/\/   V extends VectorPayload>\n+\/\/  void store(Class<?> vClass, Class<?> eClass,\n+\/\/             int length,\n+\/\/             Object base, long offset,        \/\/ Unsafe addressing\n+\/\/             boolean fromSegment,\n+\/\/             V v, C container, long index,    \/\/ Arguments for default implementation\n+\/\/             StoreVectorOperation<C, V> defaultImpl) {\n@@ -970,0 +971,1 @@\n+  const TypeInt*     from_ms      = gvn().type(argument(6))->isa_int();\n@@ -971,1 +973,1 @@\n-  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n+  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || !from_ms->is_con() ||\n@@ -974,1 +976,1 @@\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s from_ms=%s\",\n@@ -977,1 +979,2 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(6)->Opcode()]);\n@@ -1036,5 +1039,4 @@\n-  \/\/ Now handle special case where load\/store happens from\/to byte array but element type is not byte.\n-  bool using_byte_array = arr_type != nullptr && arr_type->elem()->array_element_basic_type() == T_BYTE && elem_bt != T_BYTE;\n-  \/\/ Handle loading masks.\n-  \/\/ If there is no consistency between array and vector element types, it must be special byte array case or loading masks\n-  if (arr_type != nullptr && !using_byte_array && !is_mask && !elem_consistent_with_arr(elem_bt, arr_type)) {\n+  bool mismatched_ms = from_ms->get_con() && !is_mask && arr_type != nullptr && arr_type->elem()->array_element_basic_type() != elem_bt;\n+  BasicType mem_elem_bt = mismatched_ms ? arr_type->elem()->array_element_basic_type() : elem_bt;\n+  int mem_num_elem = mismatched_ms ? (num_elem * type2aelembytes(elem_bt)) \/ type2aelembytes(mem_elem_bt) : num_elem;\n+  if (arr_type != nullptr && !is_mask && !elem_consistent_with_arr(elem_bt, arr_type, mismatched_ms)) {\n@@ -1050,9 +1052,26 @@\n-  \/\/ Since we are using byte array, we need to double check that the byte operations are supported by backend.\n-  if (using_byte_array) {\n-    int byte_num_elem = num_elem * type2aelembytes(elem_bt);\n-    if (!arch_supports_vector(is_store ? Op_StoreVector : Op_LoadVector, byte_num_elem, T_BYTE, VecMaskNotUsed)\n-        || !arch_supports_vector(Op_VectorReinterpret, byte_num_elem, T_BYTE, VecMaskNotUsed)) {\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n-                      is_store, is_store ? \"store\" : \"load\",\n-                      byte_num_elem, type2name(elem_bt));\n+\n+  \/\/ In case of mismatched memory segment accesses, we need to double check that the source type memory operations are supported by backend.\n+  if (mismatched_ms) {\n+    if (is_store) {\n+      if (!arch_supports_vector(Op_StoreVector, num_elem, elem_bt, VecMaskNotUsed)\n+          || !arch_supports_vector(Op_VectorReinterpret, mem_num_elem, mem_elem_bt, VecMaskNotUsed)) {\n+        if (C->print_intrinsics()) {\n+          tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n+                        is_store, \"store\",\n+                        num_elem, type2name(elem_bt));\n+        }\n+        set_map(old_map);\n+        set_sp(old_sp);\n+        return false; \/\/ not supported\n+      }\n+    } else {\n+      if (!arch_supports_vector(Op_LoadVector, mem_num_elem, mem_elem_bt, VecMaskNotUsed)\n+          || !arch_supports_vector(Op_VectorReinterpret, num_elem, elem_bt, VecMaskNotUsed)) {\n+        if (C->print_intrinsics()) {\n+          tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n+                        is_store, \"load\",\n+                        mem_num_elem, type2name(mem_elem_bt));\n+        }\n+        set_map(old_map);\n+        set_sp(old_sp);\n+        return false; \/\/ not supported\n@@ -1060,3 +1079,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n-      return false; \/\/ not supported\n@@ -1088,1 +1104,1 @@\n-    Node* val = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -1098,3 +1114,3 @@\n-    if (using_byte_array) {\n-      store_num_elem = num_elem * type2aelembytes(elem_bt);\n-      const TypeVect* to_vect_type = TypeVect::make(T_BYTE, store_num_elem);\n+    if (mismatched_ms) {\n+      store_num_elem = mem_num_elem;\n+      const TypeVect* to_vect_type = TypeVect::make(mem_elem_bt, store_num_elem);\n@@ -1111,3 +1127,2 @@\n-    if (using_byte_array) {\n-      int load_num_elem = num_elem * type2aelembytes(elem_bt);\n-      vload = gvn().transform(LoadVectorNode::make(0, control(), memory(addr), addr, addr_type, load_num_elem, T_BYTE));\n+    if (mismatched_ms) {\n+      vload = gvn().transform(LoadVectorNode::make(0, control(), memory(addr), addr, addr_type, mem_num_elem, mem_elem_bt));\n@@ -1139,22 +1154,24 @@\n-\/\/ public static\n-\/\/ <C,\n-\/\/  V extends Vector<?>,\n-\/\/  E,\n-\/\/  S extends VectorSpecies<E>,\n-\/\/  M extends VectorMask<E>>\n-\/\/ V loadMasked(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,\n-\/\/              int length, Object base, long offset, M m, int offsetInRange,\n-\/\/              C container, long index, S s,  \/\/ Arguments for default implementation\n-\/\/              LoadVectorMaskedOperation<C, V, S, M> defaultImpl) {\n-\/\/\n-\/\/ public static\n-\/\/ <C,\n-\/\/  V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ void storeMasked(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,\n-\/\/                  int length, Object base, long offset,\n-\/\/                  V v, M m,\n-\/\/                  C container, long index,  \/\/ Arguments for default implementation\n-\/\/                  StoreVectorMaskedOperation<C, V, M, E> defaultImpl) {\n-\/\/\n+\/\/  public static\n+\/\/  <C,\n+\/\/   V extends Vector<?>,\n+\/\/   E,\n+\/\/   S extends VectorSpecies<E>,\n+\/\/   M extends VectorMask<E>>\n+\/\/  V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+\/\/               int length, Object base, long offset,          \/\/ Unsafe addressing\n+\/\/               boolean fromSegment,\n+\/\/               M m, int offsetInRange,\n+\/\/               C container, long index, S s,                  \/\/ Arguments for default implementation\n+\/\/               LoadVectorMaskedOperation<C, V, S, M> defaultImpl) {\n+\/\/  public static\n+\/\/  <C,\n+\/\/   V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+\/\/                   int length,\n+\/\/                   Object base, long offset,                  \/\/ Unsafe addressing\n+\/\/                   boolean fromSegment,\n+\/\/                   V v, M m, C container, long index,         \/\/ Arguments for default implementation\n+\/\/                   StoreVectorMaskedOperation<C, V, M> defaultImpl) {\n+\n@@ -1166,0 +1183,1 @@\n+  const TypeInt*     from_ms      = gvn().type(argument(7))->isa_int();\n@@ -1168,2 +1186,2 @@\n-      vector_klass->const_oop() == nullptr || mask_klass->const_oop() == nullptr ||\n-      elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n+      vector_klass->const_oop() == nullptr || mask_klass->const_oop() == nullptr || from_ms == nullptr ||\n+      elem_klass->const_oop() == nullptr || !vlen->is_con() || !from_ms->is_con()) {\n@@ -1171,1 +1189,1 @@\n-      tty->print_cr(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s\",\n+      tty->print_cr(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s from_ms=%s\",\n@@ -1175,1 +1193,2 @@\n-                    NodeClassNames[argument(3)->Opcode()]);\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(7)->Opcode()]);\n@@ -1215,2 +1234,4 @@\n-  \/\/ Now handle special case where load\/store happens from\/to byte array but element type is not byte.\n-  bool using_byte_array = arr_type != nullptr && arr_type->elem()->array_element_basic_type() == T_BYTE && elem_bt != T_BYTE;\n+  bool mismatched_ms = from_ms->get_con() && arr_type != nullptr && arr_type->elem()->array_element_basic_type() != elem_bt;\n+  if (mismatched_ms BIG_ENDIAN_ONLY(&& true)) {\n+    return false;\n+  }\n@@ -1218,1 +1239,1 @@\n-  if (arr_type != nullptr && !using_byte_array && !elem_consistent_with_arr(elem_bt, arr_type)) {\n+  if (arr_type != nullptr && !elem_consistent_with_arr(elem_bt, arr_type, mismatched_ms)) {\n@@ -1229,2 +1250,2 @@\n-  int mem_num_elem = using_byte_array ? num_elem * type2aelembytes(elem_bt) : num_elem;\n-  BasicType mem_elem_bt = using_byte_array ? T_BYTE : elem_bt;\n+  int mem_num_elem = mismatched_ms ? num_elem * type2aelembytes(elem_bt) : num_elem;\n+  BasicType mem_elem_bt = mismatched_ms ? T_BYTE : elem_bt;\n@@ -1243,1 +1264,1 @@\n-      const TypeInt* offset_in_range = gvn().type(argument(8))->isa_int();\n+      const TypeInt* offset_in_range = gvn().type(argument(9))->isa_int();\n@@ -1258,1 +1279,1 @@\n-        tty->print_cr(\"  ** not supported: op=%s vlen=%d etype=%s using_byte_array=%d\",\n+        tty->print_cr(\"  ** not supported: op=%s vlen=%d etype=%s mismatched_ms=%d\",\n@@ -1260,1 +1281,1 @@\n-                      num_elem, type2name(elem_bt), using_byte_array ? 1 : 0);\n+                      num_elem, type2name(elem_bt), mismatched_ms ? 1 : 0);\n@@ -1273,2 +1294,2 @@\n-      tty->print_cr(\"  ** not supported: op=loadMasked vlen=%d etype=%s using_byte_array=%d\",\n-                    num_elem, type2name(elem_bt), using_byte_array ? 1 : 0);\n+      tty->print_cr(\"  ** not supported: op=loadMasked vlen=%d etype=%s mismatched_ms=%d\",\n+                    num_elem, type2name(elem_bt), mismatched_ms ? 1 : 0);\n@@ -1283,1 +1304,1 @@\n-  if (using_byte_array) {\n+  if (mismatched_ms) {\n@@ -1286,1 +1307,1 @@\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s using_byte_array=1\",\n+        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s mismatched_ms=1\",\n@@ -1321,1 +1342,1 @@\n-  Node* mask = unbox_vector(is_store ? argument(8) : argument(7), mbox_type, elem_bt, num_elem);\n+  Node* mask = unbox_vector(is_store ? argument(9) : argument(8), mbox_type, elem_bt, num_elem);\n@@ -1325,2 +1346,2 @@\n-                    is_store ? NodeClassNames[argument(8)->Opcode()]\n-                             : NodeClassNames[argument(7)->Opcode()]);\n+                    is_store ? NodeClassNames[argument(9)->Opcode()]\n+                             : NodeClassNames[argument(8)->Opcode()]);\n@@ -1334,1 +1355,1 @@\n-    Node* val = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);\n@@ -1338,1 +1359,1 @@\n-                      NodeClassNames[argument(7)->Opcode()]);\n+                      NodeClassNames[argument(8)->Opcode()]);\n@@ -1346,1 +1367,1 @@\n-    if (using_byte_array) {\n+    if (mismatched_ms) {\n@@ -1360,1 +1381,1 @@\n-    if (using_byte_array) {\n+    if (mismatched_ms) {\n@@ -1379,1 +1400,1 @@\n-    if (using_byte_array) {\n+    if (mismatched_ms) {\n@@ -1528,1 +1549,1 @@\n-  if (arr_type == nullptr || (arr_type != nullptr && !elem_consistent_with_arr(elem_bt, arr_type))) {\n+  if (arr_type == nullptr || (arr_type != nullptr && !elem_consistent_with_arr(elem_bt, arr_type, false))) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":116,"deletions":95,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true,\n@@ -400,1 +400,1 @@\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, m, offsetInRange,\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true, m, offsetInRange,\n@@ -441,1 +441,1 @@\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true,\n@@ -483,1 +483,1 @@\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, true,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -424,1 +424,1 @@\n-            Object base, long offset,\n+            Object base, long offset, boolean fromSegment,\n@@ -448,1 +448,1 @@\n-                 int length, Object base, long offset,\n+                 int length, Object base, long offset, boolean fromSegment,\n@@ -497,1 +497,1 @@\n-               Object base, long offset,\n+               Object base, long offset, boolean fromSegment,\n@@ -518,1 +518,1 @@\n-                     Object base, long offset,\n+                     Object base, long offset, boolean fromSegment,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-            bits, (long) i + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET,\n+            bits, (long) i + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3376,1 +3376,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3529,1 +3529,1 @@\n-            a, booleanArrayAddress(a, offset),\n+            a, booleanArrayAddress(a, offset), false,\n@@ -3740,1 +3740,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3757,1 +3757,1 @@\n-            a, arrayAddress(a, offset), m, offsetInRange,\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n@@ -3774,1 +3774,1 @@\n-            a, booleanArrayAddress(a, offset),\n+            a, booleanArrayAddress(a, offset), false,\n@@ -3791,1 +3791,1 @@\n-            a, booleanArrayAddress(a, offset), m, offsetInRange,\n+            a, booleanArrayAddress(a, offset), false, m, offsetInRange,\n@@ -3839,1 +3839,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3856,1 +3856,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3875,1 +3875,1 @@\n-            a, booleanArrayAddress(a, offset),\n+            a, booleanArrayAddress(a, offset), false,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3064,1 +3064,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3297,1 +3297,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3314,1 +3314,1 @@\n-            a, arrayAddress(a, offset), m, offsetInRange,\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n@@ -3416,1 +3416,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3433,1 +3433,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3070,1 +3070,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3284,1 +3284,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3301,1 +3301,1 @@\n-            a, arrayAddress(a, offset), m, offsetInRange,\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n@@ -3385,1 +3385,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3402,1 +3402,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3226,1 +3226,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3440,1 +3440,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3457,1 +3457,1 @@\n-            a, arrayAddress(a, offset), m, offsetInRange,\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n@@ -3541,1 +3541,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3558,1 +3558,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3105,1 +3105,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3338,1 +3338,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3355,1 +3355,1 @@\n-            a, arrayAddress(a, offset), m, offsetInRange,\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n@@ -3457,1 +3457,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3474,1 +3474,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3375,1 +3375,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3523,1 +3523,1 @@\n-            a, charArrayAddress(a, offset),\n+            a, charArrayAddress(a, offset), false,\n@@ -3726,1 +3726,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3743,1 +3743,1 @@\n-            a, arrayAddress(a, offset), m, offsetInRange,\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n@@ -3759,1 +3759,1 @@\n-            a, charArrayAddress(a, offset),\n+            a, charArrayAddress(a, offset), false,\n@@ -3776,1 +3776,1 @@\n-                a, charArrayAddress(a, offset), m, offsetInRange,\n+                a, charArrayAddress(a, offset), false, m, offsetInRange,\n@@ -3825,1 +3825,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3842,1 +3842,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -3892,1 +3892,1 @@\n-            a, charArrayAddress(a, offset),\n+            a, charArrayAddress(a, offset), false,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-                bits, (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET,\n+                bits, (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4181,1 +4181,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -4400,1 +4400,1 @@\n-            a, charArrayAddress(a, offset),\n+            a, charArrayAddress(a, offset), false,\n@@ -4561,1 +4561,1 @@\n-            a, booleanArrayAddress(a, offset),\n+            a, booleanArrayAddress(a, offset), false,\n@@ -4773,1 +4773,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -4790,1 +4790,1 @@\n-            a, arrayAddress(a, offset), m, offsetInRange,\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n@@ -4867,1 +4867,1 @@\n-            a, charArrayAddress(a, offset),\n+            a, charArrayAddress(a, offset), false,\n@@ -4884,1 +4884,1 @@\n-                a, charArrayAddress(a, offset), m, offsetInRange,\n+                a, charArrayAddress(a, offset), false, m, offsetInRange,\n@@ -4901,1 +4901,1 @@\n-            a, booleanArrayAddress(a, offset),\n+            a, booleanArrayAddress(a, offset), false,\n@@ -4918,1 +4918,1 @@\n-            a, booleanArrayAddress(a, offset), m, offsetInRange,\n+            a, booleanArrayAddress(a, offset), false, m, offsetInRange,\n@@ -4967,1 +4967,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -4984,1 +4984,1 @@\n-            a, arrayAddress(a, offset),\n+            a, arrayAddress(a, offset), false,\n@@ -5065,1 +5065,1 @@\n-            a, booleanArrayAddress(a, offset),\n+            a, booleanArrayAddress(a, offset), false,\n@@ -5115,1 +5115,1 @@\n-            a, charArrayAddress(a, offset),\n+            a, charArrayAddress(a, offset), false,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+    private static final VectorMask<Integer> INTEGER_MASK = VectorMask.fromLong(INTEGER_SPECIES, (1 << (INTEGER_SPECIES.length() \/ 2)) - 1);\n+    private static final VectorMask<Double> DOUBLE_MASK = VectorMask.fromLong(DOUBLE_SPECIES, (1 << (DOUBLE_SPECIES.length() \/ 2)) - 1);\n+\n@@ -256,0 +259,23 @@\n+    @Benchmark\n+    public void intVectorFromIntBackedSegmentMasked(Blackhole bh) {\n+        for (int i = 0; i < INTEGER_SPECIES.loopBound(intSrcArray.length); i += INTEGER_SPECIES.vectorByteSize()) {\n+            var v = IntVector.fromMemorySegment(INTEGER_SPECIES, doubleSegment, i, ByteOrder.nativeOrder(), INTEGER_MASK);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intVectorFromDoubleBackedSegmentMasked(Blackhole bh) {\n+        for (int i = 0; i < INTEGER_SPECIES.loopBound(intSrcArray.length); i += INTEGER_SPECIES.vectorByteSize()) {\n+            var v = IntVector.fromMemorySegment(INTEGER_SPECIES, doubleSegment, i, ByteOrder.nativeOrder(), INTEGER_MASK);\n+            bh.consume(v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleVectorFromIntBackedSegmentMasked(Blackhole bh) {\n+        for (int i = 0; i < DOUBLE_SPECIES.loopBound(doubleSrcArray.length); i += DOUBLE_SPECIES.vectorByteSize()) {\n+            var v = DoubleVector.fromMemorySegment(DOUBLE_SPECIES, intSegment, i, ByteOrder.nativeOrder(), DOUBLE_MASK);\n+            bh.consume(v);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadSegmentVarious.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}