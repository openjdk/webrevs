{"files":[{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2388,0 +2388,14 @@\n+\/\/ Vector ideal reg size corresponding to the specified len in bytes\n+uint Matcher::vector_ideal_reg_size(int len) {\n+  assert(MaxVectorSize >= len, \"\");\n+  uint ideal_reg = vector_ideal_reg(len);\n+  switch (ideal_reg) {\n+    case Op_VecD: return 8;\n+    case Op_VecX: return 16;\n+    case Op_VecA: return MaxVectorSize;\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n@@ -2634,6 +2648,7 @@\n-  \/\/ Loads and stores with indirect memory input (e.g., volatile loads and\n-  \/\/ stores) do not subsume the input into complex addressing expressions. If\n-  \/\/ the addressing expression is input to at least one such load or store, do\n-  \/\/ not clone the addressing expression. Query needs_acquiring_load and\n-  \/\/ needs_releasing_store as a proxy for indirect memory input, as it is not\n-  \/\/ possible to directly query for indirect memory input at this stage.\n+  \/\/ Loads and stores with indirect memory input (e.g., volatile loads\/stores,\n+  \/\/ and vector gather_loads\/scatter_stores) do not subsume the input into\n+  \/\/ complex addressing expressions. If the addressing expression is input\n+  \/\/ to at least one such load or store, do not clone the addressing expression.\n+  \/\/ Query needs_acquiring_load and needs_releasing_store as a proxy for\n+  \/\/ indirect memory input, as it is not possible to directly query for indirect\n+  \/\/ memory input at this stage.\n@@ -2648,0 +2663,7 @@\n+\n+    if (n->is_LoadVectorGather() ||\n+        n->is_StoreVectorScatter() ||\n+        n->is_LoadVectorGatherMasked() ||\n+        n->is_StoreVectorScatterMasked()) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -171,0 +171,2 @@\n+      case Op_LoadVectorGather:\n+      case Op_LoadVectorGatherMasked:\n@@ -177,0 +179,3 @@\n+      \/\/ Temporarily disable vector mask widen support for NEON,\n+      \/\/ as we do not have the use case now.\n+      case Op_VectorMaskWiden:\n@@ -181,6 +186,0 @@\n-      case Op_LoadVectorGather:\n-      case Op_LoadVectorGatherMasked:\n-        if (UseSVE == 0 || is_subword_type(bt)) {\n-          return false;\n-        }\n-        break;\n@@ -328,0 +327,5 @@\n+  \/\/ SVE always needs the vector index for gather\/scatter.\n+  bool Matcher::gather_scatter_needs_vector_index(BasicType elem_bt, int vlen) {\n+    return true;\n+  }\n+\n@@ -5078,0 +5082,29 @@\n+\/\/ ---------------------------- Vector Slice ------------------------\n+\n+instruct vslice_neon(vReg dst, vReg src1, vReg src2, immI index) %{\n+   predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+   match(Set dst (VectorSlice (Binary src1 src2) index));\n+   format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n+   ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n+    __ ext($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src1$$FloatRegister, $src2$$FloatRegister,\n+           ((uint)$index$$constant * scale));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vslice_sve(vReg dst_src1, vReg src2, immI index) %{\n+   predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+   match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n+   format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n+   ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n+    __ sve_ext($dst_src1$$FloatRegister, $src2$$FloatRegister,\n+               ((uint)$index$$constant * scale));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5741,0 +5774,26 @@\n+\/\/ Vector mask widen to twice size\n+\/\/\n+\/\/ Unpack elements from the lowest or highest half of the source\n+\/\/ predicate and place in elements of twice their size within the\n+\/\/ destination predicate.\n+\n+instruct vmaskwiden_lo_sve(pReg dst, pReg src) %{\n+  predicate(UseSVE > 0 && n->as_VectorMaskWiden()->is_lo());\n+  match(Set dst (VectorMaskWiden src));\n+  format %{ \"vmaskwiden_lo_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_punpklo($dst$$PRegister, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskwiden_hi_sve(pReg dst, pReg src) %{\n+  predicate(UseSVE > 0 && !n->as_VectorMaskWiden()->is_lo());\n+  match(Set dst (VectorMaskWiden src));\n+  format %{ \"vmaskwiden_hi_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_punpkhi($dst$$PRegister, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -6474,0 +6533,49 @@\n+instruct gather_load_subword_le128(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) <= 16);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load_subword_le128 $dst, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_subword_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) > 16);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"gather_load_subword_gt128 $dst, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -6484,1 +6592,1 @@\n- %}\n+  %}\n@@ -6504,0 +6612,49 @@\n+instruct gather_load_subword_masked_le128(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) <= 16);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load_subword_masked_le128 $dst, $pg, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_subword_masked_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) > 16);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"gather_load_subword_masked_gt128 $dst, $pg, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":164,"deletions":7,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -161,0 +161,2 @@\n+      case Op_LoadVectorGather:\n+      case Op_LoadVectorGatherMasked:\n@@ -167,0 +169,3 @@\n+      \/\/ Temporarily disable vector mask widen support for NEON,\n+      \/\/ as we do not have the use case now.\n+      case Op_VectorMaskWiden:\n@@ -171,6 +176,0 @@\n-      case Op_LoadVectorGather:\n-      case Op_LoadVectorGatherMasked:\n-        if (UseSVE == 0 || is_subword_type(bt)) {\n-          return false;\n-        }\n-        break;\n@@ -318,0 +317,5 @@\n+  \/\/ SVE always needs the vector index for gather\/scatter.\n+  bool Matcher::gather_scatter_needs_vector_index(BasicType elem_bt, int vlen) {\n+    return true;\n+  }\n+\n@@ -3316,0 +3320,29 @@\n+\/\/ ---------------------------- Vector Slice ------------------------\n+\n+instruct vslice_neon(vReg dst, vReg src1, vReg src2, immI index) %{\n+   predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+   match(Set dst (VectorSlice (Binary src1 src2) index));\n+   format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n+   ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n+    __ ext($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src1$$FloatRegister, $src2$$FloatRegister,\n+           ((uint)$index$$constant * scale));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vslice_sve(vReg dst_src1, vReg src2, immI index) %{\n+   predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+   match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n+   format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n+   ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n+    __ sve_ext($dst_src1$$FloatRegister, $src2$$FloatRegister,\n+               ((uint)$index$$constant * scale));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3888,0 +3921,26 @@\n+\/\/ Vector mask widen to twice size\n+\/\/\n+\/\/ Unpack elements from the lowest or highest half of the source\n+\/\/ predicate and place in elements of twice their size within the\n+\/\/ destination predicate.\n+\n+instruct vmaskwiden_lo_sve(pReg dst, pReg src) %{\n+  predicate(UseSVE > 0 && n->as_VectorMaskWiden()->is_lo());\n+  match(Set dst (VectorMaskWiden src));\n+  format %{ \"vmaskwiden_lo_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_punpklo($dst$$PRegister, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskwiden_hi_sve(pReg dst, pReg src) %{\n+  predicate(UseSVE > 0 && !n->as_VectorMaskWiden()->is_lo());\n+  match(Set dst (VectorMaskWiden src));\n+  format %{ \"vmaskwiden_hi_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_punpkhi($dst$$PRegister, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -4577,0 +4636,49 @@\n+instruct gather_load_subword_le128(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) <= 16);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load_subword_le128 $dst, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_subword_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) > 16);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"gather_load_subword_gt128 $dst, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -4587,1 +4695,1 @@\n- %}\n+  %}\n@@ -4607,0 +4715,49 @@\n+instruct gather_load_subword_masked_le128(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) <= 16);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load_subword_masked_le128 $dst, $pg, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_subword_masked_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) > 16);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"gather_load_subword_masked_gt128 $dst, $pg, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":164,"deletions":7,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -3619,0 +3619,4 @@\n+  \/\/ SVE 8-bit gather load bytes (scalar plus 32-bit unscaled offsets)\n+  INSN(sve_ld1b_gather,  0b1000010, 0b00, 0b00, 0b010);\n+  \/\/ SVE 16-bit gather load halfwords (scalar plus 32-bit scaled offsets)\n+  INSN(sve_ld1h_gather,  0b1000010, 0b01, 0b01, 0b010);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+bool Matcher::gather_scatter_needs_vector_index(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n@@ -1040,0 +1044,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified size in bytes\n+uint Matcher::vector_ideal_reg_size(int size) {\n+  assert(MaxVectorSize >= size, \"\");\n+  return size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2165,0 +2165,4 @@\n+bool Matcher::gather_scatter_needs_vector_index(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n@@ -2201,0 +2205,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified size in bytes\n+uint Matcher::vector_ideal_reg_size(int size) {\n+  assert(MaxVectorSize == size, \"\");\n+  return size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2032,0 +2032,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified len in bytes\n+uint Matcher::vector_ideal_reg_size(int len) {\n+  assert(MaxVectorSize >= len, \"\");\n+  return MaxVectorSize;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -141,0 +141,4 @@\n+\n+  bool Matcher::gather_scatter_needs_vector_index(BasicType elem_bt, int vlen) {\n+    return !is_subword_type(elem_bt);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1812,0 +1812,4 @@\n+bool Matcher::gather_scatter_needs_vector_index(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n@@ -1850,0 +1854,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified size in bytes\n+uint Matcher::vector_ideal_reg_size(int size) {\n+  assert(MaxVectorSize == size, \"\");\n+  return size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1481,6 +1481,4 @@\n-void C2_MacroAssembler::vgather8b_masked_offset(BasicType elem_bt,\n-                                                XMMRegister dst, Register base,\n-                                                Register idx_base,\n-                                                Register offset, Register mask,\n-                                                Register mask_idx, Register rtmp,\n-                                                int vlen_enc) {\n+void C2_MacroAssembler::vgather8b_masked(BasicType elem_bt, XMMRegister dst,\n+                                         Register base, Register idx_base,\n+                                         Register mask, Register mask_idx,\n+                                         Register rtmp, int vlen_enc) {\n@@ -1490,1 +1488,1 @@\n-      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      \/\/ dst[i] = mask[i] ? src[idx_base[i]] : 0\n@@ -1495,3 +1493,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1505,1 +1500,1 @@\n-      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      \/\/ dst[i] = mask[i] ? src[idx_base[i]] : 0\n@@ -1510,3 +1505,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1520,4 +1512,3 @@\n-void C2_MacroAssembler::vgather8b_offset(BasicType elem_bt, XMMRegister dst,\n-                                         Register base, Register idx_base,\n-                                         Register offset, Register rtmp,\n-                                         int vlen_enc) {\n+void C2_MacroAssembler::vgather8b(BasicType elem_bt, XMMRegister dst,\n+                                  Register base, Register idx_base,\n+                                  Register rtmp, int vlen_enc) {\n@@ -1527,1 +1518,1 @@\n-      \/\/ dst[i] = src[offset + idx_base[i]]\n+      \/\/ dst[i] = src[idx_base[i]]\n@@ -1529,3 +1520,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1537,1 +1525,1 @@\n-      \/\/ dst[i] = src[offset + idx_base[i]]\n+      \/\/ dst[i] = src[idx_base[i]]\n@@ -1539,3 +1527,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1570,5 +1555,4 @@\n-                                        Register offset, Register mask,\n-                                        XMMRegister xtmp1, XMMRegister xtmp2,\n-                                        XMMRegister temp_dst, Register rtmp,\n-                                        Register mask_idx, Register length,\n-                                        int vector_len, int vlen_enc) {\n+                                        Register mask, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister temp_dst,\n+                                        Register rtmp, Register mask_idx,\n+                                        Register length, int vector_len, int vlen_enc) {\n@@ -1588,1 +1572,1 @@\n-      vgather8b_offset(elem_ty, temp_dst, base, idx_base, offset, rtmp, vlen_enc);\n+      vgather8b(elem_ty, temp_dst, base, idx_base, rtmp, vlen_enc);\n@@ -1590,1 +1574,1 @@\n-      vgather8b_masked_offset(elem_ty, temp_dst, base, idx_base, offset, mask, mask_idx, rtmp, vlen_enc);\n+      vgather8b_masked(elem_ty, temp_dst, base, idx_base, mask, mask_idx, rtmp, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -492,2 +492,2 @@\n-  void vgather_subword(BasicType elem_ty, XMMRegister dst,  Register base, Register idx_base, Register offset,\n-                       Register mask, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n+  void vgather_subword(BasicType elem_ty, XMMRegister dst,  Register base, Register idx_base, Register mask,\n+                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n@@ -496,5 +496,4 @@\n-  void vgather8b_masked_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n-                               Register offset, Register mask, Register midx, Register rtmp, int vlen_enc);\n-\n-  void vgather8b_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n-                              Register offset, Register rtmp, int vlen_enc);\n+  void vgather8b_masked(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                        Register mask, Register midx, Register rtmp, int vlen_enc);\n+  void vgather8b(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                 Register rtmp, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2103,0 +2103,5 @@\n+\/\/ Return true if gather\/scatter needs vector index as input.\n+bool Matcher::gather_scatter_needs_vector_index(BasicType elem_bt, int vlen) {\n+  return !is_subword_type(elem_bt);\n+}\n+\n@@ -2250,0 +2255,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified len in bytes\n+uint Matcher::vector_ideal_reg_size(int size) {\n+  assert(MaxVectorSize >= size, \"\");\n+  return size;\n+}\n+\n@@ -4026,1 +4037,1 @@\n-instruct vgather_subwordLE8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegI rtmp) %{\n+instruct vgather_subwordLE8B(vec dst, memory mem, rRegP idx_base, rRegP tmp, rRegI rtmp) %{\n@@ -4028,1 +4039,1 @@\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  match(Set dst (LoadVectorGather mem idx_base));\n@@ -4035,1 +4046,1 @@\n-    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp$$Register, vlen_enc);\n+    __ vgather8b(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp$$Register, vlen_enc);\n@@ -4040,1 +4051,1 @@\n-instruct vgather_subwordGT8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_subwordGT8B(vec dst, memory mem, rRegP idx_base, rRegP tmp, rRegP idx_base_temp,\n@@ -4043,1 +4054,1 @@\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  match(Set dst (LoadVectorGather mem idx_base));\n@@ -4052,1 +4063,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, noreg, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $xtmp1$$XMMRegister,\n@@ -4058,35 +4069,1 @@\n-instruct vgather_subwordLE8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegI rtmp, rFlagsReg cr) %{\n-  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n-  effect(TEMP tmp, TEMP rtmp, KILL cr);\n-  format %{ \"vector_gatherLE8_off $dst, $mem, $idx_base, $offset\\t! using $tmp and $rtmp as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vgather_subwordGT8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegP idx_base_temp,\n-                                 vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI length, rFlagsReg cr) %{\n-  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_off $dst, $mem, $idx_base, $offset\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, noreg, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, noreg, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vgather_masked_subwordLE8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n+instruct vgather_masked_subwordLE8B_avx3(vec dst, memory mem, rRegP idx_base, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n@@ -4094,1 +4071,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4103,1 +4080,1 @@\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+    __ vgather8b_masked(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n@@ -4108,1 +4085,1 @@\n-instruct vgather_masked_subwordGT8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_masked_subwordGT8B_avx3(vec dst, memory mem, rRegP idx_base, kReg mask, rRegP tmp, rRegP idx_base_temp,\n@@ -4111,1 +4088,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4122,1 +4099,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n@@ -4128,38 +4105,1 @@\n-instruct vgather_masked_subwordLE8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n-  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n-                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordGT8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n-                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegL rtmp2, rRegL mask_idx, rRegI length, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordLE8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n+instruct vgather_masked_subwordLE8B_avx2(vec dst, memory mem, rRegP idx_base, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n@@ -4167,1 +4107,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4180,1 +4120,1 @@\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+    __ vgather8b_masked(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n@@ -4185,1 +4125,1 @@\n-instruct vgather_masked_subwordGT8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_masked_subwordGT8B_avx2(vec dst, memory mem, rRegP idx_base, vec mask, rRegP tmp, rRegP idx_base_temp,\n@@ -4188,1 +4128,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4203,47 +4143,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordLE8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n-  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n-    if (elem_bt == T_SHORT) {\n-      __ movl($mask_idx$$Register, 0x55555555);\n-      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n-    }\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n-                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordGT8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n-                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI rtmp2, rRegI mask_idx, rRegI length, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n-    if (elem_bt == T_SHORT) {\n-      __ movl($mask_idx$$Register, 0x55555555);\n-      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n-    }\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":29,"deletions":135,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -4363,1 +4363,1 @@\n-    \"VectorRearrange\", \"VectorLoadShuffle\", \"VectorLoadConst\",\n+    \"VectorRearrange\", \"VectorLoadShuffle\", \"VectorLoadConst\", \"VectorSlice\",\n@@ -4371,1 +4371,1 @@\n-    \"MaskAll\", \"AndVMask\", \"OrVMask\", \"XorVMask\", \"VectorMaskCast\",\n+    \"MaskAll\", \"AndVMask\", \"OrVMask\", \"XorVMask\", \"VectorMaskCast\", \"VectorMaskWiden\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1226,0 +1226,1 @@\n+                                     \"I\"                                                                                                       \\\n@@ -1229,0 +1230,3 @@\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n@@ -1243,0 +1247,1 @@\n+                                      \"I\"                                                                                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -516,0 +516,1 @@\n+macro(VectorMaskWiden)\n@@ -538,0 +539,1 @@\n+macro(VectorSlice)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -725,1 +725,1 @@\n-    return inline_vector_gather_scatter(\/*is_scatter*\/ false);\n+    return inline_vector_gather_scatter(\/*is_scatter=*\/ false);\n@@ -727,1 +727,1 @@\n-    return inline_vector_gather_scatter(\/*is_scatter*\/ true);\n+    return inline_vector_gather_scatter(\/*is_scatter=*\/ true);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,0 +386,2 @@\n+  Node* gen_gather_load_subword(Node* addr, Node* indexes, Node* indexes1, Node* indexes2, Node* indexes3, const TypeVect* vector_type);\n+  Node* gen_gather_load_masked_subword(Node* addr, Node* indexes, Node* indexes1, Node* indexes2, Node* indexes3, Node* mask, const TypeVect* vector_type);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2443,0 +2443,1 @@\n+    case Op_VectorSlice:\n@@ -2520,16 +2521,1 @@\n-    case Op_LoadVectorGather:\n-      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n-        Node* pair = new BinaryNode(n->in(MemNode::ValueIn), n->in(MemNode::ValueIn+1));\n-        n->set_req(MemNode::ValueIn, pair);\n-        n->del_req(MemNode::ValueIn+1);\n-      }\n-      break;\n-    case Op_LoadVectorGatherMasked:\n-      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n-        Node* pair2 = new BinaryNode(n->in(MemNode::ValueIn + 1), n->in(MemNode::ValueIn + 2));\n-        Node* pair1 = new BinaryNode(n->in(MemNode::ValueIn), pair2);\n-        n->set_req(MemNode::ValueIn, pair1);\n-        n->del_req(MemNode::ValueIn+2);\n-        n->del_req(MemNode::ValueIn+1);\n-        break;\n-      } \/\/ fall-through\n+    case Op_LoadVectorGatherMasked: \/\/ fall-through\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -346,0 +346,3 @@\n+  \/\/ Return true if gather\/scatter needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType elem_bt, int vlen);\n+\n@@ -368,0 +371,2 @@\n+  \/\/ Vector ideal reg size\n+  static uint vector_ideal_reg_size(int len);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+class VectorMaskWidenNode;\n@@ -751,0 +752,1 @@\n+        DEFINE_CLASS_ID(VectorMaskWiden, Vector, 11)\n@@ -1012,0 +1014,1 @@\n+  DEFINE_CLASS_QUERY(VectorMaskWiden)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1127,12 +1127,138 @@\n-\/\/ <C,\n-\/\/  V extends Vector<?>,\n-\/\/  W extends Vector<Integer>,\n-\/\/  S extends VectorSpecies<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V loadWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int length,\n-\/\/               Class<? extends Vector<Integer>> vectorIndexClass,\n-\/\/               Object base, long offset, \/\/ Unsafe addressing\n-\/\/               W index_vector, M m,\n-\/\/               C container, int index, int[] indexMap, int indexM, S s, \/\/ Arguments for default implementation\n-\/\/               LoadVectorOperationWithMap<C, V, E, S, M> defaultImpl)\n+Node* LibraryCallKit::gen_gather_load_subword(Node* addr, Node* indexes, Node* indexes1, Node* indexes2,\n+                                              Node* indexes3, const TypeVect* vector_type) {\n+  BasicType elem_bt = vector_type->element_basic_type();\n+  uint elem_num = vector_type->length();\n+  const TypeVect* index_vect_type = indexes->bottom_type()->isa_vect();\n+  const TypePtr* addr_type = gvn().type(addr)->isa_ptr();\n+  Node* addr_mem = memory(addr);\n+\n+  \/\/ The first gather.\n+  Node* vgather = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vector_type, indexes));\n+\n+  uint index_elem_num = index_vect_type != nullptr ? index_vect_type->length() : 0;\n+  uint vector_reg_size = Matcher::vector_ideal_reg_size(vector_type->length_in_bytes());\n+  uint max_elem_num = vector_reg_size \/ type2aelembytes(elem_bt);\n+  \/\/ The second gather.\n+  if (indexes1 != nullptr) {\n+    assert(index_vect_type != nullptr, \"indexes must be a vector\");\n+    assert(Type::equals(indexes1->bottom_type(), index_vect_type), \"invalid vector type\");\n+    Node* vgather1 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vector_type, indexes1));\n+    \/\/ Merge the second gather with the first gather result.\n+    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - index_elem_num));\n+    Node* vslice = gvn().transform(new VectorSliceNode(vgather1, vgather1, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, vslice, vector_type));\n+  }\n+\n+  \/\/ The third and fourth gathers for byte type.\n+  if (indexes2 != nullptr) {\n+    assert(elem_bt == T_BYTE, \"only byte vector needs more than 2 times of gather load\");\n+    assert(indexes3 != nullptr, \"indexes3 must be non-null\");\n+    assert(Type::equals(indexes2->bottom_type(), index_vect_type), \"invalid vector type\");\n+    assert(Type::equals(indexes3->bottom_type(), index_vect_type), \"invalid vector type\");\n+    Node* vgather2 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vector_type, indexes2));\n+    \/\/ Merge the third gather with previous results.\n+    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - 2 * index_elem_num));\n+    Node* vslice = gvn().transform(new VectorSliceNode(vgather2, vgather2, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, vslice, vector_type));\n+\n+    Node* vgather3 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vector_type, indexes3));\n+    \/\/ Merge the fourth gather with previous results.\n+    idx = gvn().makecon(TypeInt::make(max_elem_num - 3 * index_elem_num));\n+    vslice = gvn().transform(new VectorSliceNode(vgather3, vgather3, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, vslice, vector_type));\n+  }\n+  return vgather;\n+}\n+\n+Node* LibraryCallKit::gen_gather_load_masked_subword(Node* addr, Node* indexes, Node* indexes1,\n+                                                     Node* indexes2, Node* indexes3, Node* mask,\n+                                                     const TypeVect* vector_type) {\n+  BasicType elem_bt = vector_type->element_basic_type();\n+  const TypeVect* index_vect_type = indexes->bottom_type()->isa_vect();\n+  const TypePtr* addr_type = gvn().type(addr)->isa_ptr();\n+  Node* addr_mem = memory(addr);\n+\n+  \/\/ Case for architectures that do not support subword vector gather with vector index.\n+  \/\/ The mask needs to be kept as it is.\n+  if (index_vect_type == nullptr) {\n+    return gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vector_type, indexes, mask));\n+  }\n+\n+  \/\/ The mask input with subword type needs to be widened to int type. And the element\n+  \/\/ number of the new mask is the same as the index vector.\n+  uint index_elem_num = index_vect_type->length();\n+  const TypeVect* mask_vt = TypeVect::makemask(T_INT, index_elem_num);\n+  Node* vmask_temp = mask;\n+  Node* vmask = nullptr;\n+\n+  \/\/ The first masked vector gather with vector index. Generate a new vector mask by widening\n+  \/\/ the lower half of the mask to int type. For byte vector, it maybe the lowest 1\/4 part of\n+  \/\/ the mask.\n+  if (elem_bt == T_BYTE) {\n+    const TypeVect* mask_vt_s = TypeVect::makemask(T_SHORT, MaxVectorSize \/ type2aelembytes(T_SHORT));\n+    vmask_temp = gvn().transform(new VectorMaskWidenNode(mask, mask_vt_s, \/* is_lo *\/true));\n+    vmask = gvn().transform(new VectorMaskWidenNode(vmask_temp, mask_vt, \/* is_lo *\/true));\n+  } else {\n+    vmask = gvn().transform(new VectorMaskWidenNode(mask, mask_vt, \/* is_lo *\/true));\n+  }\n+  Node* vgather = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vector_type, indexes, vmask));\n+\n+  \/\/ The second masked vector gather with vector index.\n+  uint vector_reg_size = Matcher::vector_ideal_reg_size(vector_type->length_in_bytes());\n+  uint max_elem_num = vector_reg_size \/ type2aelembytes(elem_bt);\n+  if (indexes1 != nullptr) {\n+    assert(index_vect_type != nullptr, \"indexes must be a vector\");\n+    assert(Type::equals(indexes1->bottom_type(), index_vect_type), \"invalid vector type\");\n+\n+    \/\/ Generate a new vector mask by widening the higher half of the mask to int type. For byte vector,\n+    \/\/ it maybe the 2\/4 part of the mask starting from the lowest bit.\n+    vmask = gvn().transform(new VectorMaskWidenNode(vmask_temp, mask_vt, \/* is_lo *\/false));\n+    Node* vgather1 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vector_type, indexes1, vmask));\n+    \/\/ Merge the second gather with the first gather result.\n+    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - index_elem_num));\n+    Node* slice = gvn().transform(new VectorSliceNode(vgather1, vgather1, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, slice, vector_type));\n+  }\n+\n+  \/\/ The third and fourth masked vector gathers for byte vector.\n+  if (indexes2 != nullptr) {\n+    assert(elem_bt == T_BYTE, \"only byte vector needs more than 2 times of gather load\");\n+    assert(indexes3 != nullptr, \"indexes3 must be non-null\");\n+    assert(Type::equals(indexes2->bottom_type(), index_vect_type), \"invalid vector type\");\n+    assert(Type::equals(indexes3->bottom_type(), index_vect_type), \"invalid vector type\");\n+\n+    \/\/ The third masked vector gather with vector index. The new vector mask is widened from the 3\/4\n+    \/\/ part of the input mask.\n+    const TypeVect* mask_vt_s = TypeVect::makemask(T_SHORT, MaxVectorSize \/ type2aelembytes(T_SHORT));\n+    vmask_temp = gvn().transform(new VectorMaskWidenNode(mask, mask_vt_s, \/* is_lo *\/false));\n+    vmask = gvn().transform(new VectorMaskWidenNode(vmask_temp, mask_vt, \/* is_lo *\/true));\n+    Node* vgather2 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vector_type, indexes2, vmask));\n+    \/\/ Merge the third gather with previous results.\n+    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - 2 * index_elem_num));\n+    Node* slice = gvn().transform(new VectorSliceNode(vgather2, vgather2, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, slice, vector_type));\n+\n+    \/\/ The fourth masked vector gather with vector index. The new vector mask is widened from the 4\/4\n+    \/\/ part of the input mask.\n+    vmask = gvn().transform(new VectorMaskWidenNode(vmask_temp, mask_vt, \/* is_lo *\/false));\n+    Node* vgather3 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vector_type, indexes3, vmask));\n+    \/\/ Merge the fourth gather with previous results.\n+    idx = gvn().makecon(TypeInt::make(max_elem_num - 3 * index_elem_num));\n+    slice = gvn().transform(new VectorSliceNode(vgather3, vgather3, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, slice, vector_type));\n+  }\n+  return vgather;\n+}\n+\n+\/\/\n+\/\/  <C,\n+\/\/   V extends Vector<E>,\n+\/\/   W extends Vector<Integer>,\n+\/\/   M extends VectorMask<E>,_\n+\/\/   E>\n+\/\/   V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n+\/\/                 Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n+\/\/                 Object base, long offset,\n+\/\/                 W indexVector1, W index_vector2, W index_vector3, W index_vector4,\n+\/\/                 M m, C container, int index, int[] indexMap, int indexM, S s,\n+\/\/                 LoadVectorOperationWithMap<C, V, S, M> defaultImpl)\n@@ -1146,1 +1272,2 @@\n-\/\/                    int length, Class<? extends Vector<Integer>> vectorIndexClass, Object base, long offset,    \/\/ Unsafe addressing\n+\/\/                    int length, Class<? extends Vector<Integer>> vectorIndexClass,\n+\/\/                    int indexLength, Object base, long offset, \/\/ Unsafe addressing\n@@ -1157,0 +1284,1 @@\n+  const TypeInt*     idx_vlen         = gvn().type(argument(5))->isa_int();\n@@ -1159,2 +1287,3 @@\n-      vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || vector_idx_klass->const_oop() == nullptr || !vlen->is_con()) {\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s\",\n+      idx_vlen == nullptr || vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr ||\n+      vector_idx_klass->const_oop() == nullptr || !vlen->is_con() || !idx_vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s idx_vlen=%s\",\n@@ -1164,1 +1293,2 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1181,0 +1311,1 @@\n+  int idx_num_elem = idx_vlen->get_con();\n@@ -1182,1 +1313,2 @@\n-  const Type* vmask_type = gvn().type(is_scatter ? argument(10) : argument(9));\n+  Node* m = is_scatter ? argument(11) : argument(13);\n+  const Type* vmask_type = gvn().type(m);\n@@ -1218,3 +1350,4 @@\n-  \/\/ Check that the vector holding indices is supported by architecture\n-  \/\/ For sub-word gathers expander receive index array.\n-  if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, num_elem, T_INT, VecMaskNotUsed)) {\n+  bool needs_vector_index = Matcher::gather_scatter_needs_vector_index(elem_bt, num_elem);\n+  if (needs_vector_index) {\n+    \/\/ Check that the vector holding indices is supported by architecture\n+    if (!arch_supports_vector(Op_LoadVector, idx_num_elem, T_INT, VecMaskNotUsed)) {\n@@ -1222,2 +1355,2 @@\n-                      is_scatter, is_scatter ? \"scatter\" : \"gather\",\n-                      num_elem, is_masked_op ? 1 : 0);\n+                    is_scatter, is_scatter ? \"scatter\" : \"gather\",\n+                    idx_num_elem, is_masked_op ? 1 : 0);\n@@ -1225,0 +1358,16 @@\n+    }\n+\n+    \/\/ Check more ops that are necessary to finish the whole subword gather with vector indexes.\n+    if (!is_scatter && gvn().type(argument(10)) != TypePtr::NULL_PTR) {\n+      if (!arch_supports_vector(Op_VectorSlice, num_elem, elem_bt, VecMaskNotUsed) ||\n+          !arch_supports_vector(Op_OrV, num_elem, elem_bt, VecMaskNotUsed)) {\n+        log_if_needed(\"  ** not supported: op=gather\/merge vlen=%d etype=%s is_masked_op=%d\",\n+                      num_elem, type2name(elem_bt), is_masked_op ? 1 : 0);\n+        return false; \/\/ not supported\n+      }\n+      if (is_masked_op && !arch_supports_vector(Op_VectorMaskWiden, idx_num_elem, T_INT, VecMaskNotUsed)) {\n+        log_if_needed(\"  ** not supported: op=gather\/maskwiden vlen=%d etype=%s is_masked_op=1\",\n+                      idx_num_elem, type2name(elem_bt));\n+        return false; \/\/ not supported\n+      }\n+    }\n@@ -1227,2 +1376,2 @@\n-  Node* base = argument(5);\n-  Node* offset = ConvL2X(argument(6));\n+  Node* base = argument(6);\n+  Node* offset = ConvL2X(argument(7));\n@@ -1234,1 +1383,9 @@\n-  Node* addr = make_unsafe_address(base, offset, elem_bt, true);\n+  Node* addr = nullptr;\n+  if (needs_vector_index) {\n+    addr = make_unsafe_address(base, offset, elem_bt, true);\n+  } else {\n+    assert(is_subword_type(elem_bt), \"Only subword gather operation supports non-vector indexes\");\n+    assert(!is_scatter, \"Only supports gather operation for subword types now\");\n+    Node* index = argument(15);\n+    addr = array_element_address(base, index, elem_bt);\n+  }\n@@ -1236,1 +1393,1 @@\n-  const TypePtr *addr_type = gvn().type(addr)->isa_ptr();\n+  const TypePtr* addr_type = gvn().type(addr)->isa_ptr();\n@@ -1258,1 +1415,2 @@\n-  Node* index_vect = nullptr;\n+  \/\/ Get the indexes for gather\/scatter.\n+  Node* indexes = nullptr;\n@@ -1260,3 +1418,8 @@\n-  if (!is_subword_type(elem_bt)) {\n-    index_vect = unbox_vector(argument(8), vbox_idx_type, T_INT, num_elem);\n-    if (index_vect == nullptr) {\n+  if (!needs_vector_index) {\n+    Node* indexMap = argument(16);\n+    Node* indexM   = argument(17);\n+    indexes = array_element_address(indexMap, indexM, T_INT);\n+  } else {\n+    \/\/ Get the first index vector.\n+    indexes = unbox_vector(argument(9), vbox_idx_type, T_INT, idx_num_elem);\n+    if (indexes == nullptr) {\n@@ -1269,0 +1432,36 @@\n+  \/\/ Get other index vectors if they are not nullptr for subword gather operation.\n+  Node* indexes1 = nullptr;\n+  Node* indexes2 = nullptr;\n+  Node* indexes3 = nullptr;\n+  if (!is_scatter && needs_vector_index) {\n+    \/\/ Get the second index vector if they are not nullptr.\n+    if (gvn().type(argument(10)) != TypePtr::NULL_PTR) {\n+      assert(is_subword_type(elem_bt), \"Only subword gather needs more index vectors\");\n+      indexes1 = unbox_vector(argument(10), vbox_idx_type, T_INT, idx_num_elem);\n+      if (indexes1 == nullptr) {\n+        set_map(old_map);\n+        set_sp(old_sp);\n+        return false;\n+      }\n+    }\n+\n+    \/\/ Get the third and fourth index vectors if they are not nullptr.\n+    if (gvn().type(argument(11)) != TypePtr::NULL_PTR) {\n+      assert(elem_bt == T_BYTE, \"Only byte gather needs more than 2 index vectors\");\n+      if (gvn().type(argument(12)) == TypePtr::NULL_PTR) {\n+        set_map(old_map);\n+        set_sp(old_sp);\n+        return false;\n+      }\n+\n+      indexes2 = unbox_vector(argument(11), vbox_idx_type, T_INT, idx_num_elem);\n+      indexes3 = unbox_vector(argument(12), vbox_idx_type, T_INT, idx_num_elem);\n+      if (indexes2 == nullptr || indexes3 == nullptr) {\n+        set_map(old_map);\n+        set_sp(old_sp);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  \/\/ Get the vector mask value.\n@@ -1273,1 +1472,1 @@\n-    mask = unbox_vector(is_scatter ? argument(10) : argument(9), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(m, mbox_type, elem_bt, num_elem);\n@@ -1275,3 +1474,1 @@\n-      log_if_needed(\"  ** unbox failed mask=%s\",\n-                    is_scatter ? NodeClassNames[argument(10)->Opcode()]\n-                               : NodeClassNames[argument(9)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[m->Opcode()]);\n@@ -1286,1 +1483,1 @@\n-    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);\n@@ -1296,1 +1493,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterMaskedNode(control(), memory(addr), addr, addr_type, val, index_vect, mask));\n+      vstore = gvn().transform(new StoreVectorScatterMaskedNode(control(), memory(addr), addr, addr_type, val, indexes, mask));\n@@ -1298,1 +1495,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterNode(control(), memory(addr), addr, addr_type, val, index_vect));\n+      vstore = gvn().transform(new StoreVectorScatterNode(control(), memory(addr), addr, addr_type, val, indexes));\n@@ -1303,3 +1500,0 @@\n-    Node* index    = argument(11);\n-    Node* indexMap = argument(12);\n-    Node* indexM   = argument(13);\n@@ -1308,2 +1502,1 @@\n-        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n-        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, mask, index));\n+        vload = gen_gather_load_masked_subword(addr, indexes, indexes1, indexes2, indexes3, mask, vector_type);\n@@ -1311,1 +1504,1 @@\n-        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_vect, mask));\n+        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, indexes, mask));\n@@ -1315,2 +1508,1 @@\n-        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n-        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, index));\n+        vload = gen_gather_load_subword(addr, indexes, indexes1, indexes2, indexes3, vector_type);\n@@ -1318,1 +1510,1 @@\n-        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_vect));\n+        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, indexes));\n@@ -1326,1 +1518,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":238,"deletions":47,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -1044,0 +1044,12 @@\n+  BasicType mask_bt = bt;\n+  uint mask_vlen = vlen;\n+  if (vopc == Op_LoadVectorGather && is_subword_type(bt)) {\n+    \/\/ It uses the index vector's type as the mask type for subword gather load.\n+    const TypeVect* index_vt = node->in(MemNode::ValueIn)->bottom_type()->isa_vect();\n+    if (index_vt == nullptr) {\n+      return nullptr;\n+    }\n+    mask_bt = index_vt->element_basic_type();\n+    mask_vlen = index_vt->length();\n+  }\n+\n@@ -1047,1 +1059,1 @@\n-      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, vlen, bt)) {\n+      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, mask_vlen, mask_bt)) {\n@@ -1054,1 +1066,1 @@\n-  if (vt->length_in_bytes() < (uint)MaxVectorSize) {\n+  if (mask_vlen * type2aelembytes(mask_bt) < (uint)MaxVectorSize) {\n@@ -1056,1 +1068,1 @@\n-    mask = gvn->transform(VectorMaskGenNode::make(length, bt, vlen));\n+    mask = gvn->transform(VectorMaskGenNode::make(length, mask_bt, mask_vlen));\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1115,1 +1115,1 @@\n-  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* offset = nullptr)\n+  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices)\n@@ -1121,1 +1121,0 @@\n-    assert(is_subword || !offset, \"\");\n@@ -1123,3 +1122,0 @@\n-    if (offset) {\n-      add_req(offset);\n-    }\n@@ -1130,4 +1126,1 @@\n-     return idx == MemNode::Address ||\n-            idx == MemNode::ValueIn ||\n-            ((is_subword_type(vect_type()->element_basic_type())) &&\n-              idx == MemNode::ValueIn + 1);\n+     return idx == MemNode::Address || idx == MemNode::ValueIn;\n@@ -1252,1 +1245,1 @@\n-  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask, Node* offset = nullptr)\n+  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask)\n@@ -1258,3 +1251,1 @@\n-    if (is_subword_type(vt->element_basic_type())) {\n-      add_req(offset);\n-    }\n+    assert(is_subword_type(vt->element_basic_type()) || indices->bottom_type()->is_vect(), \"indices must be in vector\");\n@@ -1266,3 +1257,1 @@\n-                                                   idx == MemNode::ValueIn + 1 ||\n-                                                   (is_subword_type(vect_type()->is_vect()->element_basic_type()) &&\n-                                                   idx == MemNode::ValueIn + 2); }\n+                                                   idx == MemNode::ValueIn + 1; }\n@@ -1748,0 +1737,18 @@\n+\/\/ Generate a vector by slicing the two source vectors based on an index.\n+\/\/\n+\/\/ Copy the indexed byte up to the last byte of the first source vector\n+\/\/ to the bottom of the result vector, then fill the remainder of the\n+\/\/ result starting from the first byte of the second source vector.\n+\/\/\n+\/\/ E.g. src1 = [hgfedcba] src2 = [ponmlkji] index = 3\n+\/\/      dst = [kjihgfed]\n+class VectorSliceNode : public VectorNode {\n+ public:\n+  VectorSliceNode(Node* vec1, Node* vec2, Node* index)\n+    : VectorNode(vec1, vec2, index, vec1->bottom_type()->is_vect()) {\n+    assert(index->bottom_type()->isa_int(), \"index must be an integral value\");\n+    assert(index->is_Con(), \"index must be a constant\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n@@ -1807,0 +1814,22 @@\n+\/\/ Unpack the elements to twice size.\n+class VectorMaskWidenNode : public VectorNode {\n+ private:\n+  \/\/ \"_is_lo\" is used to denote whether the lower half or\n+  \/\/ the upper half of the elements are widened.\n+  \/\/ E.g. src = [1111 0101]\n+  \/\/      _is_lo = true, dst = [0001 0001]\n+  \/\/      _is_lo = false, dst = [0101 0101]\n+  bool _is_lo;\n+\n+ public:\n+  VectorMaskWidenNode(Node* in, const TypeVect* vt, bool is_lo) : VectorNode(in, vt), _is_lo(is_lo) {\n+    init_class_id(Class_VectorMaskWiden);\n+    const TypeVect* in_vt = in->bottom_type()->is_vect();\n+    assert(type2aelembytes(in_vt->element_basic_type()) == type2aelembytes(vt->element_basic_type()) \/ 2, \"must be half size\");\n+  }\n+\n+  bool is_lo() const { return _is_lo; }\n+  virtual int Opcode() const;\n+  virtual uint size_of() const { return sizeof(*this); }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -454,2 +454,2 @@\n-                  Object base, long offset,\n-                  W index_vector,\n+                  int indexLength, Object base, long offset,\n+                  W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n@@ -521,1 +521,1 @@\n-                      Object base, long offset,\n+                      int indexLength, Object base, long offset,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3120,5 +3120,18 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3129,2 +3142,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,\n@@ -3882,5 +3895,18 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3891,2 +3917,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":40,"deletions":14,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2913,2 +2913,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3204,1 +3204,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3399,2 +3399,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3515,1 +3515,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2919,2 +2919,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3191,1 +3191,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3368,2 +3368,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3465,1 +3465,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3097,2 +3097,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3369,1 +3369,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3546,2 +3546,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3643,1 +3643,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2976,2 +2976,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3267,1 +3267,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3462,2 +3462,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3578,1 +3578,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3121,5 +3121,9 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n@@ -3130,2 +3134,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n@@ -3868,5 +3872,9 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n@@ -3877,2 +3885,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3727,5 +3727,19 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+#if[byte]\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3736,2 +3750,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,\n@@ -3741,0 +3755,9 @@\n+#else[byte]\n+        return VectorSupport.loadWithMap(\n+            vectorType, null, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(n -> c[idx + iMap[idy+n]]));\n+#end[byte]\n@@ -3788,2 +3811,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -4414,1 +4437,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -4935,5 +4958,19 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+#if[byte]\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -4944,2 +4981,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,\n@@ -4949,0 +4986,9 @@\n+#else[byte]\n+        return VectorSupport.loadWithMap(\n+            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+#end[byte]\n@@ -4998,2 +5044,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -5189,1 +5235,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":66,"deletions":20,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2066,0 +2066,2 @@\n+                        [\"ld1b\",     \"__ sve_ld1b_gather(z15, p0, r5, z16);\",              \"ld1b\\t{z15.s}, p0\/z, [x5, z16.s, uxtw]\"],\n+                        [\"ld1h\",     \"__ sve_ld1h_gather(z15, p0, r5, z16);\",              \"ld1h\\t{z15.s}, p0\/z, [x5, z16.s, uxtw #1]\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1052,0 +1052,2 @@\n+    __ sve_ld1b_gather(z15, p0, r5, z16);              \/\/       ld1b    {z15.s}, p0\/z, [x5, z16.s, uxtw]\n+    __ sve_ld1h_gather(z15, p0, r5, z16);              \/\/       ld1h    {z15.s}, p0\/z, [x5, z16.s, uxtw #1]\n@@ -1390,7 +1392,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400047d,     0x94000000,\n-    0x97ffffd4,     0x9400047a,     0x3400000a,     0x34fffa2a,\n-    0x34008eea,     0x35000008,     0x35fff9c8,     0x35008e88,\n-    0xb400000b,     0xb4fff96b,     0xb4008e2b,     0xb500001d,\n-    0xb5fff91d,     0xb5008ddd,     0x10000013,     0x10fff8b3,\n-    0x10008d73,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36308cf6,     0x3758000c,     0x375ff7cc,     0x37588c8c,\n+    0x14000000,     0x17ffffd7,     0x1400047f,     0x94000000,\n+    0x97ffffd4,     0x9400047c,     0x3400000a,     0x34fffa2a,\n+    0x34008f2a,     0x35000008,     0x35fff9c8,     0x35008ec8,\n+    0xb400000b,     0xb4fff96b,     0xb4008e6b,     0xb500001d,\n+    0xb5fff91d,     0xb5008e1d,     0x10000013,     0x10fff8b3,\n+    0x10008db3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36308d36,     0x3758000c,     0x375ff7cc,     0x37588ccc,\n@@ -1401,13 +1403,13 @@\n-    0x54008a60,     0x54000001,     0x54fff541,     0x54008a01,\n-    0x54000002,     0x54fff4e2,     0x540089a2,     0x54000002,\n-    0x54fff482,     0x54008942,     0x54000003,     0x54fff423,\n-    0x540088e3,     0x54000003,     0x54fff3c3,     0x54008883,\n-    0x54000004,     0x54fff364,     0x54008824,     0x54000005,\n-    0x54fff305,     0x540087c5,     0x54000006,     0x54fff2a6,\n-    0x54008766,     0x54000007,     0x54fff247,     0x54008707,\n-    0x54000008,     0x54fff1e8,     0x540086a8,     0x54000009,\n-    0x54fff189,     0x54008649,     0x5400000a,     0x54fff12a,\n-    0x540085ea,     0x5400000b,     0x54fff0cb,     0x5400858b,\n-    0x5400000c,     0x54fff06c,     0x5400852c,     0x5400000d,\n-    0x54fff00d,     0x540084cd,     0x5400000e,     0x54ffefae,\n-    0x5400846e,     0x5400000f,     0x54ffef4f,     0x5400840f,\n+    0x54008aa0,     0x54000001,     0x54fff541,     0x54008a41,\n+    0x54000002,     0x54fff4e2,     0x540089e2,     0x54000002,\n+    0x54fff482,     0x54008982,     0x54000003,     0x54fff423,\n+    0x54008923,     0x54000003,     0x54fff3c3,     0x540088c3,\n+    0x54000004,     0x54fff364,     0x54008864,     0x54000005,\n+    0x54fff305,     0x54008805,     0x54000006,     0x54fff2a6,\n+    0x540087a6,     0x54000007,     0x54fff247,     0x54008747,\n+    0x54000008,     0x54fff1e8,     0x540086e8,     0x54000009,\n+    0x54fff189,     0x54008689,     0x5400000a,     0x54fff12a,\n+    0x5400862a,     0x5400000b,     0x54fff0cb,     0x540085cb,\n+    0x5400000c,     0x54fff06c,     0x5400856c,     0x5400000d,\n+    0x54fff00d,     0x5400850d,     0x5400000e,     0x54ffefae,\n+    0x540084ae,     0x5400000f,     0x54ffef4f,     0x5400844f,\n@@ -1607,71 +1609,72 @@\n-    0x04e544a7,     0x0568aca7,     0x05b23230,     0x853040af,\n-    0xc5b040af,     0xe57080af,     0xe5b080af,     0x25034440,\n-    0x254054c4,     0x25034640,     0x25415a05,     0x25834440,\n-    0x25c54489,     0x250b5d3a,     0x2550dc20,     0x2518e3e1,\n-    0x2518e021,     0x2518e0a1,     0x2518e121,     0x2518e1a1,\n-    0x2558e3e2,     0x2558e042,     0x2558e0c2,     0x2558e142,\n-    0x2598e3e3,     0x2598e063,     0x2598e0e3,     0x2598e163,\n-    0x25d8e3e4,     0x25d8e084,     0x25d8e104,     0x25d8e184,\n-    0x2518e407,     0x05214800,     0x05614800,     0x05a14800,\n-    0x05e14800,     0x05214c00,     0x05614c00,     0x05a14c00,\n-    0x05e14c00,     0x05304001,     0x05314001,     0x05a18610,\n-    0x05e18610,     0x05271e11,     0x6545e891,     0x6585e891,\n-    0x65c5e891,     0x6545c891,     0x6585c891,     0x65c5c891,\n-    0x45b0c210,     0x45f1c231,     0x1e601000,     0x1e603000,\n-    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n-    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n-    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n-    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n-    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n-    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n-    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n-    0x1e7e1000,     0x1e7e3000,     0xf82081f1,     0xf824011a,\n-    0xf83c1376,     0xf83b22f9,     0xf82030c4,     0xf8305080,\n-    0xf82f4141,     0xf8277145,     0xf83c6287,     0xf8b780d5,\n-    0xf8ab0228,     0xf8bf1226,     0xf8a223cc,     0xf8bd3363,\n-    0xf8b651dd,     0xf8ad423c,     0xf8b87045,     0xf8ae620a,\n-    0xf8eb82fb,     0xf8ec02c4,     0xf8f11024,     0xf8f321f0,\n-    0xf8ed318e,     0xf8e25071,     0xf8f540b7,     0xf8e67267,\n-    0xf8ed623c,     0xf8708046,     0xf87d0083,     0xf8661290,\n-    0xf86d228c,     0xf8683299,     0xf8735160,     0xf8784286,\n-    0xf87f720e,     0xf86660e0,     0xb82f8353,     0xb82902ea,\n-    0xb8351396,     0xb82221e3,     0xb83330f4,     0xb82450fd,\n-    0xb8204209,     0xb8347097,     0xb83062ea,     0xb8ab80d9,\n-    0xb8bf01b0,     0xb8b7102c,     0xb8ae22a9,     0xb8b031fa,\n-    0xb8a451e4,     0xb8a843c6,     0xb8a4723d,     0xb8bd613a,\n-    0xb8ef8162,     0xb8fd00e3,     0xb8e112bb,     0xb8f0210e,\n-    0xb8f03336,     0xb8e552b4,     0xb8f04217,     0xb8fe7294,\n-    0xb8e06264,     0xb8788284,     0xb8640358,     0xb8731102,\n-    0xb868230e,     0xb87032df,     0xb864503f,     0xb86a4194,\n-    0xb86070e9,     0xb8786090,     0xce2a6cdb,     0xce107db8,\n-    0xce748ed6,     0xce8973bf,     0xce7480f4,     0xce6b853c,\n-    0xcec0818e,     0xce788834,     0x25a0cd89,     0x25a1d093,\n-    0x05803685,     0x05400c08,     0x050074c4,     0x2560d6a0,\n-    0x2521c0fb,     0x05805089,     0x05403e98,     0x05025238,\n-    0x25e0cd0b,     0x25e1d1d2,     0x05800e4e,     0x05402676,\n-    0x05001e63,     0x25a0d1c9,     0x2521c495,     0x0583abe2,\n-    0x054011ab,     0x05007cbe,     0x2560c3b7,     0x25e1c358,\n-    0x05806593,     0x054064b5,     0x05000e5a,     0x2520c3f1,\n-    0x25a1cc29,     0x05801468,     0x05401d71,     0x05035bb2,\n-    0x04bb01f0,     0x046806dc,     0x659c0385,     0x65d909e0,\n-    0x65c30415,     0x04fa10ba,     0x04611a33,     0x042e17ce,\n-    0x04bf1c52,     0x0456b7d7,     0x04400008,     0x049a1417,\n-    0x04509b1a,     0x041b1456,     0x0499b58b,     0x04dab938,\n-    0x04991691,     0x04d395a4,     0x04d19ff6,     0x045011f2,\n-    0x0417be8d,     0x041eadc1,     0x04980987,     0x052799e4,\n-    0x05a49c23,     0x04c817e5,     0x044a0d2d,     0x04c901fe,\n-    0x044b0343,     0x04c10839,     0x04dcac2a,     0x65c087ba,\n-    0x658d8791,     0x65869d61,     0x65c78021,     0x65828c5b,\n-    0x049db33e,     0x65c2b862,     0x65c0ac7d,     0x65c1b38e,\n-    0x65cdab64,     0x65c19022,     0x65fc97e7,     0x65bd162a,\n-    0x65b82596,     0x65a0a969,     0x65a4d697,     0x65feec8f,\n-    0x65ba46bb,     0x65a4633f,     0x04c742a6,     0x049f7f18,\n-    0x042c3141,     0x04b9310d,     0x047733e1,     0x04f53014,\n-    0x05bb6bbf,     0x05ba6fa8,     0x65c88645,     0x4555b34d,\n-    0x45cab660,     0x043138c7,     0x44589b94,     0x445a8e71,\n-    0x44198b1a,     0x449b8f8b,     0x049a3797,     0x04183f14,\n-    0x045926fb,     0x04c825ac,     0x040a369a,     0x65873fa2,\n-    0x6586347d,     0x65982b85,     0x04412dd1,     0x0e2c116a,\n-    0x4e2a1128,     0x0e6b1149,     0x4e751293,     0x0ea21020,\n-    0x4ebf13dd,     0x2e321230,     0x6e321230,     0x2e6f11cd,\n-    0x6e791317,     0x2eba1338,     0x6eb91317,\n+    0x04e544a7,     0x0568aca7,     0x05b23230,     0x841040af,\n+    0x84b040af,     0x853040af,     0xc5b040af,     0xe57080af,\n+    0xe5b080af,     0x25034440,     0x254054c4,     0x25034640,\n+    0x25415a05,     0x25834440,     0x25c54489,     0x250b5d3a,\n+    0x2550dc20,     0x2518e3e1,     0x2518e021,     0x2518e0a1,\n+    0x2518e121,     0x2518e1a1,     0x2558e3e2,     0x2558e042,\n+    0x2558e0c2,     0x2558e142,     0x2598e3e3,     0x2598e063,\n+    0x2598e0e3,     0x2598e163,     0x25d8e3e4,     0x25d8e084,\n+    0x25d8e104,     0x25d8e184,     0x2518e407,     0x05214800,\n+    0x05614800,     0x05a14800,     0x05e14800,     0x05214c00,\n+    0x05614c00,     0x05a14c00,     0x05e14c00,     0x05304001,\n+    0x05314001,     0x05a18610,     0x05e18610,     0x05271e11,\n+    0x6545e891,     0x6585e891,     0x65c5e891,     0x6545c891,\n+    0x6585c891,     0x65c5c891,     0x45b0c210,     0x45f1c231,\n+    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n+    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n+    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n+    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n+    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n+    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n+    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n+    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n+    0xf82081f1,     0xf824011a,     0xf83c1376,     0xf83b22f9,\n+    0xf82030c4,     0xf8305080,     0xf82f4141,     0xf8277145,\n+    0xf83c6287,     0xf8b780d5,     0xf8ab0228,     0xf8bf1226,\n+    0xf8a223cc,     0xf8bd3363,     0xf8b651dd,     0xf8ad423c,\n+    0xf8b87045,     0xf8ae620a,     0xf8eb82fb,     0xf8ec02c4,\n+    0xf8f11024,     0xf8f321f0,     0xf8ed318e,     0xf8e25071,\n+    0xf8f540b7,     0xf8e67267,     0xf8ed623c,     0xf8708046,\n+    0xf87d0083,     0xf8661290,     0xf86d228c,     0xf8683299,\n+    0xf8735160,     0xf8784286,     0xf87f720e,     0xf86660e0,\n+    0xb82f8353,     0xb82902ea,     0xb8351396,     0xb82221e3,\n+    0xb83330f4,     0xb82450fd,     0xb8204209,     0xb8347097,\n+    0xb83062ea,     0xb8ab80d9,     0xb8bf01b0,     0xb8b7102c,\n+    0xb8ae22a9,     0xb8b031fa,     0xb8a451e4,     0xb8a843c6,\n+    0xb8a4723d,     0xb8bd613a,     0xb8ef8162,     0xb8fd00e3,\n+    0xb8e112bb,     0xb8f0210e,     0xb8f03336,     0xb8e552b4,\n+    0xb8f04217,     0xb8fe7294,     0xb8e06264,     0xb8788284,\n+    0xb8640358,     0xb8731102,     0xb868230e,     0xb87032df,\n+    0xb864503f,     0xb86a4194,     0xb86070e9,     0xb8786090,\n+    0xce2a6cdb,     0xce107db8,     0xce748ed6,     0xce8973bf,\n+    0xce7480f4,     0xce6b853c,     0xcec0818e,     0xce788834,\n+    0x25a0cd89,     0x25a1d093,     0x05803685,     0x05400c08,\n+    0x050074c4,     0x2560d6a0,     0x2521c0fb,     0x05805089,\n+    0x05403e98,     0x05025238,     0x25e0cd0b,     0x25e1d1d2,\n+    0x05800e4e,     0x05402676,     0x05001e63,     0x25a0d1c9,\n+    0x2521c495,     0x0583abe2,     0x054011ab,     0x05007cbe,\n+    0x2560c3b7,     0x25e1c358,     0x05806593,     0x054064b5,\n+    0x05000e5a,     0x2520c3f1,     0x25a1cc29,     0x05801468,\n+    0x05401d71,     0x05035bb2,     0x04bb01f0,     0x046806dc,\n+    0x659c0385,     0x65d909e0,     0x65c30415,     0x04fa10ba,\n+    0x04611a33,     0x042e17ce,     0x04bf1c52,     0x0456b7d7,\n+    0x04400008,     0x049a1417,     0x04509b1a,     0x041b1456,\n+    0x0499b58b,     0x04dab938,     0x04991691,     0x04d395a4,\n+    0x04d19ff6,     0x045011f2,     0x0417be8d,     0x041eadc1,\n+    0x04980987,     0x052799e4,     0x05a49c23,     0x04c817e5,\n+    0x044a0d2d,     0x04c901fe,     0x044b0343,     0x04c10839,\n+    0x04dcac2a,     0x65c087ba,     0x658d8791,     0x65869d61,\n+    0x65c78021,     0x65828c5b,     0x049db33e,     0x65c2b862,\n+    0x65c0ac7d,     0x65c1b38e,     0x65cdab64,     0x65c19022,\n+    0x65fc97e7,     0x65bd162a,     0x65b82596,     0x65a0a969,\n+    0x65a4d697,     0x65feec8f,     0x65ba46bb,     0x65a4633f,\n+    0x04c742a6,     0x049f7f18,     0x042c3141,     0x04b9310d,\n+    0x047733e1,     0x04f53014,     0x05bb6bbf,     0x05ba6fa8,\n+    0x65c88645,     0x4555b34d,     0x45cab660,     0x043138c7,\n+    0x44589b94,     0x445a8e71,     0x44198b1a,     0x449b8f8b,\n+    0x049a3797,     0x04183f14,     0x045926fb,     0x04c825ac,\n+    0x040a369a,     0x65873fa2,     0x6586347d,     0x65982b85,\n+    0x04412dd1,     0x0e2c116a,     0x4e2a1128,     0x0e6b1149,\n+    0x4e751293,     0x0ea21020,     0x4ebf13dd,     0x2e321230,\n+    0x6e321230,     0x2e6f11cd,     0x6e791317,     0x2eba1338,\n+    0x6eb91317,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":94,"deletions":91,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @bug 8351623\n+ * @summary VectorAPI: Refactor subword gather load and add SVE implementation\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorGatherSubwordTest\n+ *\/\n+public class VectorGatherSubwordTest {\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+\n+    private static int LENGTH = 128;\n+    private static final Generators random = Generators.G;\n+\n+    private static byte[] ba;\n+    private static byte[] br;\n+    private static short[] sa;\n+    private static short[] sr;\n+    private static boolean[] m;\n+    private static int[][] indexes;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        br = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sr = new short[LENGTH];\n+        m = new boolean[LENGTH];\n+        indexes = new int[2][];\n+\n+        Generator<Integer> byteGen = random.uniformInts(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+        Generator<Integer> shortGen = random.uniformInts(Short.MIN_VALUE, Short.MAX_VALUE);\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = byteGen.next().byteValue();\n+            sa[i] = shortGen.next().shortValue();\n+            m[i] = i % 2 == 0;\n+        }\n+\n+        int[] nums = {B_SPECIES.length(), S_SPECIES.length()};\n+        for (int i = 0; i < 2; i++) {\n+            indexes[i] = new int[nums[i]];\n+            random.fill(random.uniformInts(0, nums[i] - 1), indexes[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void testLoadGatherByte() {\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector.fromArray(B_SPECIES, ba, i, indexes[0], 0)\n+                      .intoArray(br, i);\n+        }\n+    }\n+\n+    @Check(test = \"testLoadGatherByte\")\n+    public void verifyLoadGatherByte() {\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            for (int j = 0; j < B_SPECIES.length(); j++) {\n+                Asserts.assertEquals(ba[i + indexes[0][j]], br[i + j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void testLoadGatherShort() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector.fromArray(S_SPECIES, sa, i, indexes[1], 0)\n+                       .intoArray(sr, i);\n+        }\n+    }\n+\n+    @Check(test = \"testLoadGatherShort\")\n+    public void verifyLoadGatherShort() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            for (int j = 0; j < S_SPECIES.length(); j++) {\n+                Asserts.assertEquals(sa[i + indexes[1][j]], sr[i + j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void testLoadGatherMaskedByte() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector.fromArray(B_SPECIES, ba, i, indexes[0], 0, mask)\n+                      .intoArray(br, i);\n+        }\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedByte\")\n+    public void verifyLoadGatherMaskedByte() {\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            for (int j = 0; j < B_SPECIES.length(); j++) {\n+                Asserts.assertEquals(m[j] ? ba[i + indexes[0][j]] : 0, br[i + j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void testLoadGatherMaskedShort() {\n+        VectorMask<Short> mask = VectorMask.fromArray(S_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector.fromArray(S_SPECIES, sa, i, indexes[1], 0, mask)\n+                       .intoArray(sr, i);\n+        }\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedShort\")\n+    public void verifyLoadGatherMaskedShort() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            for (int j = 0; j < S_SPECIES.length(); j++) {\n+                Asserts.assertEquals(m[j] ? sa[i + indexes[1][j]] : 0, sr[i + j]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherSubwordTest.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}