{"files":[{"patch":"@@ -24,1 +24,17 @@\n-\/**\n+import java.io.BufferedOutputStream;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.jar.JarOutputStream;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\/*\n@@ -27,4 +43,0 @@\n- * @library \/test\/lib\n- * @build jdk.test.lib.Platform\n- *        jdk.test.lib.util.FileUtils\n- * @run main ReadLongZipFileName\n@@ -32,0 +44,1 @@\n+ * @run junit ReadLongZipFileName\n@@ -33,6 +46,0 @@\n-\n-import java.io.*;\n-import java.util.jar.*;\n-import java.util.Stack;\n-import jdk.test.lib.util.FileUtils;\n-\n@@ -40,10 +47,3 @@\n-    private static String entryName = \"testFile.txt\";;\n-\n-    public static void realMain(String[] args) {\n-        String longDirName = \"abcdefghijklmnopqrstuvwx\"; \/\/ 24 chars.\n-        String jarFileName = \"areallylargejarfilename.jar\";    \/\/ 27 chars.\n-        File file = null;\n-        File myJarFile = null;\n-        int currentFileLength = 0;\n-        int minRequiredLength = 600; \/\/ long enough to definitely fail.\n-        Stack<File> directories = new Stack<File>();\n+    private static final String ENTRY_NAME = \"testFile.txt\";\n+    private static final String LONG_DIR_NAME = \"abcdefghijklmnopqrstuvwx\"; \/\/ 24 chars\n+    private static final String JAR_FILE_NAME = \"areallylargejarfilename.jar\"; \/\/ 27 chars\n@@ -51,11 +51,19 @@\n-        String filename = \".\" + File.separator;\n-        try {\n-            \/\/ Create a directory structure long enough that the filename will\n-            \/\/ put us over the minRequiredLength.\n-            do {\n-                filename = filename + longDirName + File.separator;\n-                file = new File(filename);\n-                file.mkdir();\n-                currentFileLength = file.getCanonicalPath().length();\n-                directories.push(file);\n-            } while (currentFileLength < (minRequiredLength - jarFileName.length()));\n+    \/*\n+     * Creates a jar file at a path whose path name length and jar file name length\n+     * combined is large. Then use the java.util.jar.JarFile APIs to open and read the jar file\n+     * to verify the APIs work against those jar\/zip files.\n+     *\/\n+    @Test\n+    public void testOpenAndReadJarFile() throws Exception {\n+        int minRequiredPathLength = 600; \/\/ long enough to definitely fail.\n+        Path tmpDir = Files.createTempDirectory(Path.of(\".\"), \"ReadLongZipFileName-test\")\n+                .normalize().toAbsolutePath();\n+        \/\/ Create a directory structure long enough that the filename will\n+        \/\/ put us over the minRequiredLength.\n+        int currentPathLength = 0;\n+        Path jarFileDir = tmpDir;\n+        do {\n+            jarFileDir = jarFileDir.resolve(LONG_DIR_NAME);\n+            Files.createDirectories(jarFileDir);\n+            currentPathLength = jarFileDir.toFile().getCanonicalPath().length();\n+        } while (currentPathLength < (minRequiredPathLength - JAR_FILE_NAME.length()));\n@@ -63,15 +71,8 @@\n-            \/\/ Create a new Jar file: use jar instead of zip to make sure long\n-            \/\/ names work for both zip and jar subclass.\n-            filename = filename + jarFileName;\n-            try (JarOutputStream out = new JarOutputStream(\n-                    new BufferedOutputStream(new FileOutputStream(filename)))) {\n-                out.putNextEntry(new JarEntry(entryName));\n-                out.write(1);\n-            }\n-            myJarFile = new File(filename);\n-            currentFileLength = myJarFile.getCanonicalPath().length();\n-            if (!myJarFile.exists()) {\n-                fail(\"Jar file does not exist.\");\n-            }\n-        } catch (IOException e) {\n-            unexpected(e, \"Problem creating the Jar file.\");\n+        \/\/ Create a new Jar file: use jar instead of zip to make sure long\n+        \/\/ names work for both zip and jar subclass.\n+        Path jarFilePath = jarFileDir.resolve(JAR_FILE_NAME);\n+        System.out.println(\"creating a jar file at \" + jarFilePath);\n+        try (JarOutputStream out = new JarOutputStream(\n+                new BufferedOutputStream(Files.newOutputStream(jarFilePath)))) {\n+            out.putNextEntry(new JarEntry(ENTRY_NAME));\n+            out.write(1);\n@@ -79,0 +80,2 @@\n+        assertTrue(Files.isRegularFile(jarFilePath),\n+                \"jar file \" + jarFilePath + \" does not exist or is not a file\");\n@@ -80,27 +83,6 @@\n-        try {\n-            try (JarFile readJarFile = new JarFile(myJarFile)) {\n-                JarEntry je = readJarFile.getJarEntry(entryName);\n-                check(je != null);\n-                DataInputStream dis = new DataInputStream(\n-                        readJarFile.getInputStream(je));\n-                byte val = dis.readByte();\n-                check(val == 1);\n-                try {\n-                    dis.readByte();\n-                    fail(\"Read past expected EOF\");\n-                } catch (IOException e) {\n-                    pass();\n-                }\n-            }\n-            pass(\"Opened Jar file for reading with a name \" + currentFileLength\n-                 + \" characters long\");\n-        } catch (IOException e) {\n-            unexpected(e, \"Test failed - problem reading the Jar file back in.\");\n-        }\n-\n-        if (myJarFile != null) {\n-            check(myJarFile.delete());\n-        }\n-\n-        while (! directories.empty()) {\n-            File f = directories.pop();\n+        try (JarFile readJarFile = new JarFile(jarFilePath.toFile())) {\n+            JarEntry je = readJarFile.getJarEntry(ENTRY_NAME);\n+            assertNotNull(je, \"missing jar entry: \" + ENTRY_NAME + \" in jar file \" + jarFilePath);\n+            DataInputStream dis = new DataInputStream(readJarFile.getInputStream(je));\n+            byte val = dis.readByte();\n+            assertEquals(1, val, \"unexpected byte \" + val + \" read from entry \" + ENTRY_NAME);\n@@ -108,1 +90,2 @@\n-                FileUtils.deleteFileWithRetry(f.toPath());\n+                dis.readByte();\n+                Assertions.fail(\"Read past expected EOF\");\n@@ -110,2 +93,2 @@\n-                unexpected(e, \"Fail to clean up directory, \" + f);\n-                break;\n+                \/\/ expected\n+                System.out.println(\"received the expected exception: \" + e);\n@@ -114,17 +97,2 @@\n-    }\n-\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() {passed++;}\n-    static void pass(String msg) {System.out.println(msg); passed++;}\n-    static void fail() {failed++; Thread.dumpStack();}\n-    static void fail(String msg) {System.out.println(msg); fail();}\n-    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    static void unexpected(Throwable t, String msg) {\n-        System.out.println(msg); failed++; t.printStackTrace();}\n-    static void check(boolean cond) {if (cond) pass(); else fail();}\n-\n-    public static void main(String[] args) throws Throwable {\n-        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.println(\"\\nPassed = \" + passed + \" failed = \" + failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");\n+        System.out.println(\"Successfully opened and read contents from a jar file with a name \"\n+                + jarFilePath.toFile().getCanonicalPath().length() + \" characters long\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadLongZipFileName.java","additions":62,"deletions":94,"binary":false,"changes":156,"status":"modified"}]}