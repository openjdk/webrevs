{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLGraphicsConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/opengl\/CGLGraphicsConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.swing;\n+\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.AbstractMultiResolutionImage;\n+import java.awt.image.ImageObserver;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+class BackingStoreMultiResolutionImage\n+        extends AbstractMultiResolutionImage {\n+\n+    private final int width;\n+    private final int height;\n+    private final int scaledWidth;\n+    private final int scaledHeight;\n+    private final Image rvImage;\n+\n+    BackingStoreMultiResolutionImage(int width, int height,\n+                                     int scaledWidth, int scaledHeight,\n+                                     Image rvImage) {\n+        this.width = width;\n+        this.height = height;\n+        this.scaledWidth = scaledWidth;\n+        this.scaledHeight = scaledHeight;\n+        this.rvImage = rvImage;\n+    }\n+\n+    int getScaledWidth() {\n+        return scaledWidth;\n+    }\n+\n+    int getScaledHeight() {\n+        return scaledHeight;\n+    }\n+\n+    @Override\n+    public int getWidth(ImageObserver observer) {\n+        return width;\n+    }\n+\n+    @Override\n+    public int getHeight(ImageObserver observer) {\n+        return height;\n+    }\n+\n+    @Override\n+    protected Image getBaseImage() {\n+        return rvImage;\n+    }\n+\n+    @Override\n+    public Graphics getGraphics() {\n+        Graphics graphics = rvImage.getGraphics();\n+        if (graphics instanceof Graphics2D) {\n+            double sx = (double) scaledWidth \/ width;\n+            double sy = (double) scaledHeight \/ height;\n+            ((Graphics2D) graphics).scale(sx, sy);\n+        }\n+        return graphics;\n+    }\n+\n+    @Override\n+    public Image getResolutionVariant(double w, double h) {\n+        return rvImage;\n+    }\n+\n+    @Override\n+    public java.util.List<Image> getResolutionVariants() {\n+        return Collections.unmodifiableList(Arrays.asList(rvImage));\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/BackingStoreMultiResolutionImage.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -777,2 +777,3 @@\n-                    recreateBackingStoreImage = (mrImage.scaledWidth != scaledWidth\n-                            || mrImage.scaledHeight != scaledHeight);\n+                    recreateBackingStoreImage =\n+                            (mrImage.getScaledWidth() != scaledWidth ||\n+                            mrImage.getScaledHeight() != scaledHeight);\n@@ -876,56 +877,0 @@\n-    static class BackingStoreMultiResolutionImage\n-            extends AbstractMultiResolutionImage {\n-\n-        private final int width;\n-        private final int height;\n-        private final int scaledWidth;\n-        private final int scaledHeight;\n-        private final Image rvImage;\n-\n-        public BackingStoreMultiResolutionImage(int width, int height,\n-                int scaledWidth, int scaledHeight, Image rvImage) {\n-            this.width = width;\n-            this.height = height;\n-            this.scaledWidth = scaledWidth;\n-            this.scaledHeight = scaledHeight;\n-            this.rvImage = rvImage;\n-        }\n-\n-        @Override\n-        public int getWidth(ImageObserver observer) {\n-            return width;\n-        }\n-\n-        @Override\n-        public int getHeight(ImageObserver observer) {\n-            return height;\n-        }\n-\n-        @Override\n-        protected Image getBaseImage() {\n-            return rvImage;\n-        }\n-\n-        @Override\n-        public Graphics getGraphics() {\n-            Graphics graphics = rvImage.getGraphics();\n-            if (graphics instanceof Graphics2D) {\n-                double sx = (double) scaledWidth \/ width;\n-                double sy = (double) scaledHeight \/ height;\n-                ((Graphics2D) graphics).scale(sx, sy);\n-            }\n-            return graphics;\n-        }\n-\n-        @Override\n-        public Image getResolutionVariant(double w, double h) {\n-            return rvImage;\n-        }\n-\n-        @Override\n-        public java.util.List<Image> getResolutionVariants() {\n-            return Collections.unmodifiableList(Arrays.asList(rvImage));\n-        }\n-    }\n-\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JViewport.java","additions":4,"deletions":59,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.awt.image.BaseMultiResolutionImage;\n+import java.awt.image.BufferedImage;\n@@ -1068,1 +1070,1 @@\n-            result = c.createImage(width , height);\n+            result = createImage(c, width, height);\n@@ -1082,0 +1084,36 @@\n+    \/**\n+     * Return a BackingStoreMultiResolutionImage that can be used to paint a\n+     * Component.\n+     * <p>\n+     * For example: if a Component is 100x100 pixels on a high-resolution\n+     * (200%) monitor, then this return a MultiResolutionImage that is\n+     * backed by a 200x200 pixel BufferedImage.\n+     * <\/p>\n+     *\/\n+    private BackingStoreMultiResolutionImage createImage(\n+            Component c, int virtualWidth, int virtualHeight) {\n+        GraphicsConfiguration gc = c.getGraphicsConfiguration();\n+        int scaledWidth, scaledHeight;\n+        AffineTransform at = gc == null ? new AffineTransform() : gc.getDefaultTransform();\n+        if ( (at.getType() == AffineTransform.TYPE_GENERAL_SCALE ||\n+                at.getType() == AffineTransform.TYPE_UNIFORM_SCALE ||\n+                at.getType() == AffineTransform.TYPE_IDENTITY) &&\n+                at.getScaleX() > 0 && at.getScaleY() > 0) {\n+            scaledWidth = Math.round((float) at.getScaleX() * virtualWidth);\n+            scaledHeight = Math.round((float) at.getScaleY() * virtualHeight);\n+\n+            \/\/ this is extremely unlikely, but since these dimensions are used\n+            \/\/ to construct a BufferedImage: they cannot be zero or else an\n+            \/\/ exception is thrown.\n+            scaledWidth = Math.max(1, scaledWidth);\n+            scaledHeight = Math.max(1, scaledHeight);\n+        } else {\n+            \/\/ this is unexpected. Let's fail gracefully by acting like\n+            \/\/ we're on a 100% resolution monitor.\n+            scaledWidth = virtualWidth;\n+            scaledHeight = virtualHeight;\n+        }\n+        Image img = c.createImage(scaledWidth, scaledHeight);\n+        return new BackingStoreMultiResolutionImage(virtualWidth, virtualHeight, scaledWidth, scaledHeight, img);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.awt.Window;\n@@ -407,4 +406,1 @@\n-        int transparency = Transparency.OPAQUE;\n-        if (target instanceof Window window && !window.isOpaque())\n-            transparency = Transparency.TRANSLUCENT;\n-        ColorModel model = getColorModel(transparency);\n+        ColorModel model = getColorModel(Transparency.OPAQUE);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsConfig.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.awt.Window;\n@@ -249,4 +248,1 @@\n-        int transparency = Transparency.OPAQUE;\n-        if (target instanceof Window window && !window.isOpaque())\n-            transparency = Transparency.TRANSLUCENT;\n-        ColorModel model = getColorModel(transparency);\n+        ColorModel model = getColorModel(Transparency.OPAQUE);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/opengl\/GLXGraphicsConfig.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.awt.Window;\n@@ -263,4 +262,1 @@\n-        int transparency = Transparency.OPAQUE;\n-        if (target instanceof Window window && !window.isOpaque())\n-            transparency = Transparency.TRANSLUCENT;\n-        ColorModel model = getColorModel(transparency);\n+        ColorModel model = getColorModel(Transparency.OPAQUE);\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32GraphicsConfig.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8303904\n+   @summary when \"swing.volatileImageBufferEnabled\" is \"false\" windows repaint\n+            as opaque and as if on a 100% resolution monitor\n+*\/\n+\n+import javax.swing.JFrame;\n+import javax.swing.RepaintManager;\n+import javax.swing.SwingUtilities;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Image;\n+import java.awt.Transparency;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class TestVolatileBufferOpacityAndTransform {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"swing.volatileImageBufferEnabled\", \"false\");\n+        TestVolatileBufferOpacityAndTransform test =\n+                new TestVolatileBufferOpacityAndTransform();\n+        test.run();\n+    }\n+\n+    int testFailureCtr = 0;\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    public TestVolatileBufferOpacityAndTransform() {\n+        SwingUtilities.invokeLater(() -> {\n+            try {\n+                GraphicsDevice[] allDevices = GraphicsEnvironment.\n+                        getLocalGraphicsEnvironment().getScreenDevices();\n+                for (GraphicsDevice gd : allDevices) {\n+                    String id = gd.getIDstring() + \"; \" +\n+                            gd.getDefaultConfiguration().getDefaultTransform();\n+                    System.out.println(\"Testing GraphicsDevice = \" + id);\n+                    for (boolean transparentBackground :\n+                            new boolean[] {true, false}) {\n+                        System.out.println(\"\\tTesting transparentBackground = \"\n+                                + transparentBackground);\n+                        JFrame f = new JFrame(gd.getDefaultConfiguration());\n+                        f.setUndecorated(true);\n+                        if (transparentBackground) {\n+                            f.setBackground(new Color(0, 0, 0, 0));\n+                        }\n+                        f.pack();\n+                        f.setLocationRelativeTo(null);\n+                        f.setVisible(true);\n+\n+                        testOpacity(f, transparentBackground ?\n+                                Transparency.TRANSLUCENT :\n+                                Transparency.OPAQUE);\n+                        testTransform(f);\n+                    }\n+                }\n+            } finally {\n+                latch.countDown();\n+            }\n+        });\n+    }\n+\n+    public void run() throws Exception {\n+        latch.await();\n+        if (testFailureCtr > 0)\n+            throw new Error(\"Test failed\");\n+        System.out.println(\"Test passed\");\n+    }\n+\n+    \/**\n+     * Make sure Component.createImage() returns an image that can be\n+     * Transparency.OPAQUE or Transparency.TRANSLUCENT\n+     *\/\n+    private void testOpacity(Component c, int expectedTransparencyValue) {\n+        BufferedImage image = (BufferedImage) c.createImage(1, 1);\n+        assertEquals( image.getTransparency(), expectedTransparencyValue);\n+    }\n+\n+    private void assertEquals(int expectedValue, int actualValue) {\n+        if (expectedValue != actualValue) {\n+            testFailureCtr++;\n+            System.err.println(\"failed assertion; expected = \" +\n+                    expectedValue + \", actual = \" + actualValue);\n+            Thread.dumpStack();\n+        }\n+    }\n+\n+    private void assertEquals(double expectedValue, double actualValue) {\n+        if (expectedValue != actualValue) {\n+            testFailureCtr++;\n+            System.err.println(\"failed assertion; expected = \" +\n+                    expectedValue + \", actual = \" + actualValue);\n+            Thread.dumpStack();\n+        }\n+    }\n+\n+    \/**\n+     * Inspector the image we use to repaint a Component. Make sure its\n+     * AffineTransform resembles the GraphicsConfiguration's transform.\n+     * (That is: on a 200% resolution monitor we should be painting\n+     * at 200%.)\n+     *\/\n+    private void testTransform(Component c) {\n+        \/\/ we put the MultiResolutionImage logic in RepaintManager:\n+        Image i = RepaintManager.currentManager(c).\n+                getOffscreenBuffer(c, 10, 10);\n+\n+        \/\/ we considered putting the MultiResolutionImage logic in\n+        \/\/ Component.createImage(), so this could resemble:\n+\/\/        i = dialog.createImage(10, 10);\n+\n+        Graphics2D g = (Graphics2D) i.getGraphics();\n+        AffineTransform tx1 = g.getTransform();\n+        AffineTransform tx2 = c.getGraphicsConfiguration().\n+                getDefaultTransform();\n+        assertEquals(tx2.getScaleX(), tx1.getScaleX());\n+        assertEquals(tx2.getScaleY(), tx1.getScaleY());\n+        assertEquals(tx2.getShearX(), tx1.getShearX());\n+        assertEquals(tx2.getShearY(), tx1.getShearY());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303904\/TestVolatileBufferOpacityAndTransform.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8303904\n+   @summary this tests TestVolatileBufferOpacityAndTransform with the OpenGL\n+            pipeline\n+*\/\n+\n+public class TestVolatileBufferOpacityAndTransform_OGL {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ a capital \"T\" in \"True\" should add \"OpenGL pipeline enabled [..]\"\n+        \/\/ log output\n+        System.setProperty(\"sun.java2d.opengl\", \"True\");\n+        TestVolatileBufferOpacityAndTransform.main(args);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303904\/TestVolatileBufferOpacityAndTransform_OGL.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 8303904\n-   @summary when \"swing.volatileImageBufferEnabled\" is \"false\" translucent windows repaint as opaque\n-*\/\n-\n-import javax.swing.*;\n-import javax.swing.border.EmptyBorder;\n-import javax.swing.plaf.PanelUI;\n-import java.awt.*;\n-import java.awt.geom.RoundRectangle2D;\n-import java.awt.image.*;\n-import java.util.List;\n-import java.util.Arrays;\n-import java.util.Hashtable;\n-import java.util.Objects;\n-\n-public class bug8303904 extends JDialog {\n-    static bug8303904 dialog;\n-    static boolean testCompleted = false;\n-    static boolean TEST_FAILED = false;\n-\n-    public static void main(String[] args) {\n-        System.setProperty(\"swing.volatileImageBufferEnabled\", \"false\");\n-\n-        SwingUtilities.invokeLater(() -> {\n-            JFrame whiteBackgroundFrame = new JFrame();\n-            whiteBackgroundFrame.setUndecorated(true);\n-            whiteBackgroundFrame.getContentPane().setBackground(Color.white);\n-\n-            dialog = new bug8303904();\n-            dialog.pack();\n-            dialog.setLocationRelativeTo(null);\n-\n-            whiteBackgroundFrame.setBounds(dialog.getBounds());\n-            whiteBackgroundFrame.setVisible(true);\n-\n-            dialog.setVisible(true);\n-            dialog.toFront();\n-        });\n-\n-        while (dialog == null || !dialog.isShowing()) {\n-            try {\n-                Thread.sleep(5);\n-            } catch (InterruptedException e) {}\n-        }\n-\n-        SwingUtilities.invokeLater(new Runnable() {\n-            int ctr = 0;\n-            @Override\n-            public void run() {\n-                if (ctr++ < 10_000) {\n-                    SwingUtilities.invokeLater(this);\n-                    return;\n-                }\n-\n-                try {\n-                    \/\/ these methods test the same thing in different ways. The second one (testPixelColor)\n-                    \/\/ is the more important integration-type test. If the first test passes\n-                    \/\/ and the second test fails: that may indicate we're not waiting long enough\n-                    \/\/ during setup and the pixels just aren't ready for the Robot to grab yet.\n-\n-                    testImageTransparency();\n-                    testPixelColor();\n-                } finally {\n-                    testCompleted = true;\n-                }\n-            }\n-\n-            \/**\n-             * This tests the transparency of {@link Component#createImage(int, int)}\n-             *\/\n-            private void testImageTransparency() {\n-                System.out.println(\"dialog.getGraphicsConfiguration() = \" + dialog.getGraphicsConfiguration());\n-                System.out.println(\"dialog.getBackground().getAlpha() = \" + dialog.getBackground().getAlpha());\n-                System.out.println(\"dialog.isOpaque = \" + dialog.isOpaque());\n-                BufferedImage img = (BufferedImage) dialog.createImage(300, 300);\n-                System.out.println(\"dialog.createImage produced \" + img);\n-                if (img.getTransparency() != Transparency.TRANSLUCENT) {\n-                    System.err.println(\"dialog.createImage(..) should return a translucent image\");\n-                    TEST_FAILED = true;\n-                }\n-            }\n-\n-            \/**\n-             * This uses a Robot to grab the actual pixel color.\n-             *\/\n-            private void testPixelColor() {\n-                Robot robot = null;\n-                try {\n-                    robot = new Robot();\n-                    Point p = dialog.getContentPane().getLocationOnScreen();\n-                    Color c = robot.getPixelColor(p.x + 7, p.y + 7);\n-                    if (c.getRed() < 200 || c.getGreen() < 200 || c.getBlue() < 200) {\n-                        System.err.println(\"The top-left corner of the dialog should be near white, but it was \" + c);\n-                        TEST_FAILED = true;\n-                    }\n-                } catch (AWTException e) {\n-                    e.printStackTrace();\n-                    TEST_FAILED = true;\n-                }\n-            }\n-        });\n-\n-\n-        while (!testCompleted) {\n-            try {\n-                Thread.sleep(50);\n-            } catch (InterruptedException e) {}\n-        }\n-\n-        if (TEST_FAILED)\n-            throw new RuntimeException(\"This test failed; see System.err for details.\");\n-    }\n-\n-    JTextPane instructions = new JTextPane();\n-\n-    public bug8303904() {\n-        instructions.setText(\"Instructions\\n\\nLook at this window. This test passes if the window does NOT have a black border.\");\n-        instructions.setBorder(new EmptyBorder(10,10,10,10));\n-        instructions.setOpaque(false);\n-        instructions.setEditable(false);\n-\n-        setUndecorated(true);\n-        JPanel p = new JPanel();\n-        p.setOpaque(false);\n-        p.setBorder(new EmptyBorder(10,10,10,10));\n-        p.setUI(new PanelUI() {\n-            @Override\n-            public void paint(Graphics g, JComponent c) {\n-                Graphics2D g2 = (Graphics2D) g;\n-                g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n-                g2.setColor(new Color(220, 180, 0, 200));\n-                g2.fill(new RoundRectangle2D.Double(5, 5,c.getWidth()-10,c.getHeight()-10,20,20));\n-            }\n-        });\n-        p.setLayout(new BorderLayout());\n-        p.add(instructions, BorderLayout.NORTH);\n-        getContentPane().add(p);\n-        setBackground(new Color(0,0,0,0));\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303904\/bug8303904.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 8303904\n-   @summary this tests bug8303904 with the OpenGL pipeline\n-*\/\n-\n-public class bug8303904_OGL {\n-\n-    public static void main(String[] args) {\n-        \/\/ a capital \"T\" in \"True\" should add \"OpenGL pipeline enabled [..]\" log output\n-        System.setProperty(\"sun.java2d.opengl\", \"True\");\n-        bug8303904.main(args);\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303904\/bug8303904_OGL.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"}]}