{"files":[{"patch":"@@ -2522,0 +2522,106 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register temp_itbl_klass,\n+                                                  Register scan_temp,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  \/\/ 'method_result' is only used as output register at the very end of this method.\n+  \/\/ Until then we can reuse it as 'holder_offset'.\n+  Register holder_offset = method_result;\n+  assert_different_registers(resolved_klass, recv_klass, holder_klass, temp_itbl_klass, scan_temp, holder_offset);\n+\n+  int vtable_start_offset_bytes = in_bytes(Klass::vtable_start_offset());\n+  int scan_step = itableOffsetEntry::size() * wordSize;\n+  int ioffset_bytes = in_bytes(itableOffsetEntry::interface_offset());\n+  int ooffset_bytes = in_bytes(itableOffsetEntry::offset_offset());\n+  int itmentry_off_bytes = in_bytes(itableMethodEntry::method_offset());\n+  int vte_size_bytes = vtableEntry::size_in_bytes();\n+  const int vte_scale = 3;\n+\n+  Label L_loop_search_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  lwu(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  add(recv_klass, recv_klass, vtable_start_offset_bytes + ioffset_bytes);\n+  \/\/ itableOffsetEntry[] itable = recv_klass + Klass::vtable_start_offset()\n+  \/\/                            + sizeof(vtableEntry) * (recv_klass->_vtable_len);\n+  \/\/ temp_itbl_klass = itable[0]._interface;\n+  assert(vte_size_bytes == wordSize, \"else adjust vte_scale\");\n+  shadd(scan_temp, scan_temp, recv_klass, scan_temp, vte_scale);\n+  ld(temp_itbl_klass, Address(scan_temp));\n+  mv(holder_offset, zr);\n+  \/\/ scan_temp = &(itable[0]._interface)\n+  la(scan_temp, Address(scan_temp));\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  bne(resolved_klass, holder_klass, L_loop_search_resolved_entry);\n+  beq(holder_klass, temp_itbl_klass, L_holder_found);\n+  beqz(temp_itbl_klass, L_no_such_interface);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     temp_itbl_klass = *(scan_temp += scan_step);\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/       goto L_holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (temp_itbl_klass != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  Label L_search_holder;\n+  bind(L_search_holder);\n+    add(scan_temp, scan_temp, scan_step);\n+    ld(temp_itbl_klass, Address(scan_temp));\n+    beq(holder_klass, temp_itbl_klass, L_holder_found);\n+    bnez(temp_itbl_klass, L_search_holder);\n+\n+  j(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   while (true) {\n+  \/\/     temp_itbl_klass = *(scan_temp += scan_step);\n+  \/\/     if (temp_itbl_klass == 0) {\n+  \/\/       goto L_no_such_interface;\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/        holder_offset = scan_temp;\n+  \/\/     }\n+  \/\/   }\n+  \/\/\n+  Label L_loop_search_resolved;\n+  bind(L_loop_search_resolved);\n+    add(scan_temp, scan_temp, scan_step);\n+    ld(temp_itbl_klass, Address(scan_temp));\n+  bind(L_loop_search_resolved_entry);\n+    beqz(temp_itbl_klass, L_no_such_interface);\n+    beq(resolved_klass, temp_itbl_klass, L_resolved_found);\n+    bne(holder_klass, temp_itbl_klass, L_loop_search_resolved);\n+    mv(holder_offset, scan_temp);\n+    j(L_loop_search_resolved);\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  beqz(holder_offset, L_search_holder);\n+  mv(scan_temp, holder_offset);\n+\n+  \/\/ Finally, scan_temp contains holder_klass vtable offset\n+  bind(L_holder_found);\n+  lwu(method_result, Address(scan_temp, ooffset_bytes - ioffset_bytes));\n+  add(recv_klass, recv_klass, itable_index * wordSize + itmentry_off_bytes\n+                              - vtable_start_offset_bytes - ioffset_bytes); \/\/ substract offsets to restore the original value of recv_klass\n+  add(method_result, recv_klass, method_result);\n+  ld(method_result, Address(method_result));\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -257,0 +257,9 @@\n+  void lookup_interface_method_stub(Register recv_klass,\n+                                    Register holder_klass,\n+                                    Register resolved_klass,\n+                                    Register method_result,\n+                                    Register temp_reg,\n+                                    Register temp_reg2,\n+                                    int itable_index,\n+                                    Label& L_no_such_interface);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  const Register resolved_klass_reg = xmethod; \/\/ resolved interface klass (REFC)\n+  const Register resolved_klass_reg = x30; \/\/ resolved interface klass (REFC)\n@@ -198,10 +198,0 @@\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             temp_reg2, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n@@ -209,7 +199,2 @@\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             xmethod, temp_reg,\n-                             L_no_such_interface);\n-\n-  const ptrdiff_t lookupSize = __ pc() - start_pc;\n+  __ lookup_interface_method_stub(recv_klass_reg, holder_klass_reg, resolved_klass_reg, xmethod,\n+                                  temp_reg, temp_reg2, itable_index, L_no_such_interface);\n@@ -219,1 +204,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize;\n+  const ptrdiff_t codesize = __ pc() - start_pc;\n","filename":"src\/hotspot\/cpu\/riscv\/vtableStubs_riscv.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"}]}