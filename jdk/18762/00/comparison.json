{"files":[{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -57,35 +56,0 @@\n-\/\/ On macos\/aarch64 we need to ensure WXExec mode when running generated\n-\/\/ FastGetXXXField, as these functions can be called from WXWrite context\n-\/\/ (8262896).  So each FastGetXXXField is wrapped into a C++ statically\n-\/\/ compiled template function that optionally switches to WXExec if necessary.\n-\n-#ifdef __APPLE__\n-\n-static address generated_fast_get_field[T_LONG + 1 - T_BOOLEAN];\n-\n-template<int BType> struct BasicTypeToJni {};\n-template<> struct BasicTypeToJni<T_BOOLEAN> { static const jboolean jni_type; };\n-template<> struct BasicTypeToJni<T_BYTE>    { static const jbyte    jni_type; };\n-template<> struct BasicTypeToJni<T_CHAR>    { static const jchar    jni_type; };\n-template<> struct BasicTypeToJni<T_SHORT>   { static const jshort   jni_type; };\n-template<> struct BasicTypeToJni<T_INT>     { static const jint     jni_type; };\n-template<> struct BasicTypeToJni<T_LONG>    { static const jlong    jni_type; };\n-template<> struct BasicTypeToJni<T_FLOAT>   { static const jfloat   jni_type; };\n-template<> struct BasicTypeToJni<T_DOUBLE>  { static const jdouble  jni_type; };\n-\n-template<int BType, typename JniType = decltype(BasicTypeToJni<BType>::jni_type)>\n-JniType static_fast_get_field_wrapper(JNIEnv *env, jobject obj, jfieldID fieldID) {\n-  JavaThread* thread = JavaThread::thread_from_jni_environment(env);\n-  ThreadWXEnable wx(WXExec, thread);\n-  address get_field_addr = generated_fast_get_field[BType - T_BOOLEAN];\n-  return ((JniType(*)(JNIEnv *env, jobject obj, jfieldID fieldID))get_field_addr)(env, obj, fieldID);\n-}\n-\n-template<int BType>\n-address JNI_FastGetField::generate_fast_get_int_field1() {\n-  generated_fast_get_field[BType - T_BOOLEAN] = generate_fast_get_int_field0((BasicType)BType);\n-  return (address)static_fast_get_field_wrapper<BType>;\n-}\n-\n-#else \/\/ __APPLE__\n-\n@@ -97,2 +61,0 @@\n-#endif \/\/ __APPLE__\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -36,5 +36,1 @@\n-                         constraint)                                    \\\n-                                                                        \\\n-  AARCH64_ONLY(develop(bool, AssertWXAtThreadSync, false,                \\\n-          \"Conservatively check W^X thread state at possible safepoint\" \\\n-          \"or handshake\"))\n+                         constraint)\n","filename":"src\/hotspot\/os\/bsd\/globals_bsd.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -617,1 +617,0 @@\n-        MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, t);) \/\/ can call PcDescCache::add_pc_desc\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -197,4 +197,0 @@\n-  \/\/ Enable WXWrite: this function is called by the signal handler at arbitrary\n-  \/\/ point of execution.\n-  ThreadWXEnable wx(WXWrite, thread);\n-\n@@ -206,0 +202,14 @@\n+  #if defined(__APPLE__) && defined(AARCH64)\n+  if (nullptr != uc && nullptr != info && CodeCache::contains(info->si_addr) && sig == SIGBUS){\n+    \/\/ we can get here from non-java thread\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if (pc == info->si_addr){\n+      os::current_thread_enable_wx(WXExec);\n+    }\n+    else{\n+      os::current_thread_enable_wx(WXWrite);\n+    }\n+    return true;\n+  }\n+  #endif\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1320,4 +1320,0 @@\n-  \/\/ Enable WXWrite: the function is called by c1 stub as a runtime function\n-  \/\/ (see another implementation above).\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -406,1 +405,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n@@ -2723,5 +2721,1 @@\n-    if (!Thread::current_in_asgct()) {\n-      \/\/ we don't want to modify the cache if we're in ASGCT\n-      \/\/ which is typically called in a signal handler\n-      _pc_desc_cache.add_pc_desc(upper);\n-    }\n+    _pc_desc_cache.add_pc_desc(upper);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -169,4 +168,0 @@\n-  \/\/ Enable WXWrite: the function is called directly from nmethod_entry_barrier\n-  \/\/ stub.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current()));\n-\n@@ -174,1 +169,0 @@\n-  AARCH64_PORT_ONLY(return_address = pauth_strip_pointer(return_address));\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -49,2 +48,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetNMethod.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -44,2 +43,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current()));\n-\n","filename":"src\/hotspot\/share\/gc\/x\/xBarrierSetNMethod.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -52,2 +51,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current()));\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1001,3 +1001,0 @@\n-  \/\/ Enable WXWrite: the function is called directly by interpreter.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -159,2 +159,0 @@\n-  \/\/ WXWrite is needed before entering the vm below and in callee methods.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, THREAD));\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrJvmtiAgent.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -703,1 +703,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -294,1 +294,0 @@\n-        MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorage.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));       \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -842,0 +842,3 @@\n+      if (executable){\n+        MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+      }\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -610,3 +610,0 @@\n-  \/\/ signify to other code in the VM that we're in ASGCT\n-  ThreadInAsgct tia(thread);\n-\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3627,1 +3627,0 @@\n-    MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n@@ -3729,3 +3728,0 @@\n-  \/\/ We are going to VM, change W^X state to the expected one.\n-  MACOS_AARCH64_ONLY(WXMode oldmode = thread->enable_wx(WXWrite));\n-\n@@ -3787,1 +3783,0 @@\n-  MACOS_AARCH64_ONLY(thread->init_wx());\n@@ -3858,1 +3853,0 @@\n-  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n@@ -3912,3 +3906,0 @@\n-  \/\/ We are going to VM, change W^X state to the expected one.\n-  MACOS_AARCH64_ONLY(thread->enable_wx(WXWrite));\n-\n@@ -3931,4 +3922,0 @@\n-  \/\/ Go to the execute mode, the initial state of the thread on creation.\n-  \/\/ Use os interface as the thread is not a JavaThread anymore.\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n-\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thr));               \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -440,1 +440,0 @@\n-    <xsl:text>MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));<\/xsl:text>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -200,1 +200,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));\n@@ -3518,2 +3517,0 @@\n-    \/\/ 8266889: raw_enter changes Java thread state, needs WXWrite\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));\n@@ -3552,2 +3549,0 @@\n-  \/\/ 8266889: raw_wait changes Java thread state, needs WXWrite\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -384,2 +384,0 @@\n-    \/\/ transition code: native to VM\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -411,1 +411,0 @@\n-      MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));\n@@ -443,1 +442,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));\n@@ -450,1 +448,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,4 +91,0 @@\n-  \/\/ The call to transition_from_native below contains a safepoint check\n-  \/\/ which needs the code cache to be writable.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n-\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-  ClearPendingJniExcCheck _clearCheck(env); \\\n-  MACOS_AARCH64_ONLY(ThreadWXEnable _wx(WXWrite, thread));\n+  ClearPendingJniExcCheck _clearCheck(env);\n","filename":"src\/hotspot\/share\/prims\/whitebox.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -251,2 +251,0 @@\n-  \/\/ we might modify the code cache via BarrierSetNMethod::nmethod_entry_barrier\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -2602,3 +2601,0 @@\n-  \/\/ Enable WXWrite: current function is called from methods compiled by C2 directly\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -253,8 +252,0 @@\n-\/\/ On macos\/aarch64 we need to maintain the W^X state of the thread.  So we\n-\/\/ take WXWrite on the enter to VM from the \"outside\" world, so the rest of JVM\n-\/\/ code can assume writing (but not executing) codecache is always possible\n-\/\/ without preliminary actions.\n-\/\/ JavaThread state should be changed only after taking WXWrite. The state\n-\/\/ change may trigger a safepoint, that would need WXWrite to do bookkeeping\n-\/\/ in the codecache.\n-\n@@ -286,1 +277,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current));       \\\n@@ -314,1 +304,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current));       \\\n@@ -324,1 +313,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current));       \\\n@@ -361,1 +349,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -386,1 +373,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -396,1 +382,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -98,1 +98,0 @@\n-  MACOS_AARCH64_ONLY(_thread->enable_wx(WXExec));\n@@ -105,2 +104,0 @@\n-  MACOS_AARCH64_ONLY(_thread->enable_wx(WXWrite));\n-\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -380,8 +379,0 @@\n-  \/\/ Macos\/aarch64 should be in the right state for safepoint (e.g.\n-  \/\/ deoptimization needs WXWrite).  Crashes caused by the wrong state rarely\n-  \/\/ happens in practice, making such issues hard to find and reproduce.\n-#if defined(__APPLE__) && defined(AARCH64)\n-  if (AssertWXAtThreadSync) {\n-    assert_wx_state(WXWrite);\n-  }\n-#endif\n@@ -1267,3 +1258,0 @@\n-  \/\/ Enable WXWrite: called directly from interpreter native wrapper.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n-\n@@ -1464,1 +1452,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -696,3 +695,0 @@\n-  \/\/ Enable WXWrite: the function is called implicitly from java code.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -483,3 +483,0 @@\n-  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n-\n@@ -1774,3 +1771,0 @@\n-  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, JavaThread::current()));\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -457,1 +456,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current());) \/\/ About to call into code cache\n@@ -463,1 +461,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current());) \/\/ About to call into code cache\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -140,2 +140,0 @@\n-\n-  MACOS_AARCH64_ONLY(DEBUG_ONLY(_wx_init = false));\n@@ -204,2 +202,0 @@\n-  MACOS_AARCH64_ONLY(this->init_wx());\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -630,23 +630,0 @@\n-#if defined(__APPLE__) && defined(AARCH64)\n- private:\n-  DEBUG_ONLY(bool _wx_init);\n-  WXMode _wx_state;\n- public:\n-  void init_wx();\n-  WXMode enable_wx(WXMode new_state);\n-\n-  void assert_wx_state(WXMode expected) {\n-    assert(_wx_state == expected, \"wrong state\");\n-  }\n-#endif \/\/ __APPLE__ && AARCH64\n-\n- private:\n-  bool _in_asgct = false;\n- public:\n-  bool in_asgct() const { return _in_asgct; }\n-  void set_in_asgct(bool value) { _in_asgct = value; }\n-  static bool current_in_asgct() {\n-    Thread *cur = Thread::current_or_null_safe();\n-    return cur != nullptr && cur->in_asgct();\n-  }\n-\n@@ -657,17 +634,0 @@\n-class ThreadInAsgct {\n- private:\n-  Thread* _thread;\n-  bool _saved_in_asgct;\n- public:\n-  ThreadInAsgct(Thread* thread) : _thread(thread) {\n-    assert(thread != nullptr, \"invariant\");\n-    \/\/ Allow AsyncGetCallTrace to be reentrant - save the previous state.\n-    _saved_in_asgct = thread->in_asgct();\n-    thread->set_in_asgct(true);\n-  }\n-  ~ThreadInAsgct() {\n-    assert(_thread->in_asgct(), \"invariant\");\n-    _thread->set_in_asgct(_saved_in_asgct);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -34,4 +34,0 @@\n-#if defined(__APPLE__) && defined(AARCH64)\n-#include \"runtime\/os.hpp\"\n-#endif\n-\n@@ -73,21 +69,0 @@\n-#if defined(__APPLE__) && defined(AARCH64)\n-inline void Thread::init_wx() {\n-  assert(this == Thread::current(), \"should only be called for current thread\");\n-  assert(!_wx_init, \"second init\");\n-  _wx_state = WXWrite;\n-  os::current_thread_enable_wx(_wx_state);\n-  DEBUG_ONLY(_wx_init = true);\n-}\n-\n-inline WXMode Thread::enable_wx(WXMode new_state) {\n-  assert(this == Thread::current(), \"should only be called for current thread\");\n-  assert(_wx_init, \"should be inited\");\n-  WXMode old = _wx_state;\n-  if (_wx_state != new_state) {\n-    _wx_state = new_state;\n-    os::current_thread_enable_wx(new_state);\n-  }\n-  return old;\n-}\n-#endif \/\/ __APPLE__ && AARCH64\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_THREADWXSETTERS_INLINE_HPP\n-#define SHARE_RUNTIME_THREADWXSETTERS_INLINE_HPP\n-\n-\/\/ No threadWXSetters.hpp\n-\n-#if defined(__APPLE__) && defined(AARCH64)\n-\n-#include \"runtime\/thread.inline.hpp\"\n-\n-class ThreadWXEnable  {\n-  Thread* _thread;\n-  WXMode _old_mode;\n-public:\n-  ThreadWXEnable(WXMode new_mode, Thread* thread) :\n-    _thread(thread),\n-    _old_mode(_thread ? _thread->enable_wx(new_mode) : WXWrite)\n-  { }\n-  ~ThreadWXEnable() {\n-    if (_thread) {\n-      _thread->enable_wx(_old_mode);\n-    }\n-  }\n-};\n-#endif \/\/ __APPLE__ && AARCH64\n-\n-#endif \/\/ SHARE_RUNTIME_THREADWXSETTERS_INLINE_HPP\n-\n","filename":"src\/hotspot\/share\/runtime\/threadWXSetters.inline.hpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -434,2 +434,0 @@\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n-\n@@ -534,1 +532,0 @@\n-  MACOS_AARCH64_ONLY(main_thread->init_wx());\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -96,6 +96,0 @@\n-  if (ret == JNI_OK) {\n-    \/\/ CreateJavaVM leaves WXExec context, while gtests\n-    \/\/ calls internal functions assuming running in WXWwrite.\n-    \/\/ Switch to WXWrite once for all test cases.\n-    MACOS_AARCH64_ONLY(Thread::current()->enable_wx(WXWrite));\n-  }\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n@@ -81,1 +80,0 @@\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n@@ -85,1 +83,0 @@\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n@@ -106,1 +103,0 @@\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n@@ -110,1 +106,0 @@\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n@@ -152,1 +147,0 @@\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n","filename":"test\/hotspot\/gtest\/runtime\/test_stubRoutines.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,1 +183,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n","filename":"test\/hotspot\/gtest\/runtime\/test_threads.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}