{"files":[{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.ffi.generated;\n+\n+import jdk.internal.ffi.generated.errno.errno_h;\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.charset.StandardCharsets;\n+\n+\/\/ Errno utility for macosx platform\n+public final class ErrnoUtils {\n+    private ErrnoUtils() {\n+    }\n+\n+    private static final long ERRNO_STRING_HOLDER_ARRAY_SIZE = 256L;\n+\n+    public static IOException IOExceptionWithErrnoString(int errno, String message) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment buf = arena.allocate(ERRNO_STRING_HOLDER_ARRAY_SIZE);\n+            if (errno_h.strerror_r(errno, buf, ERRNO_STRING_HOLDER_ARRAY_SIZE) == 0) {\n+                String errnoMsg = buf.getString(0, StandardCharsets.UTF_8);\n+                return new IOException(message + \" \" + errnoMsg);\n+            } else {\n+                \/\/ failed to convert errno to string - output errno value\n+                return new IOException(message + \" Errno: \" + errno);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/ErrnoUtils.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.errno;\n+\n+import jdk.internal.ffi.util.FFMUtils;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+\n+@SuppressWarnings(\"restricted\")\n+public class errno_h {\n+\n+    errno_h() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final int EINTR = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EINTR 4\n+     * }\n+     *\/\n+    public static int EINTR() {\n+        return EINTR;\n+    }\n+\n+    private static class strerror_r {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                FFMUtils.C_INT,\n+                FFMUtils.C_INT,\n+                FFMUtils.C_POINTER,\n+                FFMUtils.C_LONG\n+        );\n+\n+        public static final MemorySegment ADDR = FFMUtils.findOrThrow(\"strerror_r\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)\n+     * }\n+     *\/\n+    public static FunctionDescriptor strerror_r$descriptor() {\n+        return strerror_r.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)\n+     * }\n+     *\/\n+    public static MethodHandle strerror_r$handle() {\n+        return strerror_r.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)\n+     * }\n+     *\/\n+    public static MemorySegment strerror_r$address() {\n+        return strerror_r.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)\n+     * }\n+     *\/\n+    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {\n+        var mh$ = strerror_r.HANDLE;\n+        try {\n+            if (FFMUtils.TRACE_DOWNCALLS) {\n+                FFMUtils.traceDowncall(\"strerror_r\", __errnum, __strerrbuf, __buflen);\n+            }\n+            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/errno\/errno_h.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Defines native structures for errno APIs.\n+ * Generated with the following jextract command:\n+ * {@snippet lang = \"Shell Script\":\n+ *\n+ * HEADER_NAME=errno.h\n+ * echo \"#include <errno.h>\" > $HEADER_NAME\n+ * echo \"#include <string.h>\" >> $HEADER_NAME\n+ *\n+ * jextract --target-package jdk.internal.ffi.generated.errno \\\n+ *    --include-constant EINTR \\\n+ *    --include-function strerror_r \\\n+ *    $HEADER_NAME\n+ * }\n+ *\n+ * After generation of native bindings, the layouts for the C builtin layouts and other\n+ * variables\/methods not specific to a component area are moved to the {@code BindingUtils} class\n+ * for future reusability.\n+ *\n+ *\/\n+\n+package jdk.internal.ffi.generated.errno;\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/errno\/package-info.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,387 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.kqueue;\n+\n+import jdk.internal.ffi.util.FFMUtils;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.Arena;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.ValueLayout.OfLong;\n+import static java.lang.foreign.ValueLayout.OfShort;\n+import static java.lang.foreign.ValueLayout.OfInt;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct kevent {\n+ *     uintptr_t ident;\n+ *     int16_t filter;\n+ *     uint16_t flags;\n+ *     uint32_t fflags;\n+ *     intptr_t data;\n+ *     void *udata;\n+ * }\n+ * }\n+ *\/\n+@SuppressWarnings(\"restricted\")\n+public class kevent {\n+\n+    kevent() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+            FFMUtils.align(FFMUtils.C_LONG, 4).withName(\"ident\"),\n+            FFMUtils.C_SHORT.withName(\"filter\"),\n+            FFMUtils.C_SHORT.withName(\"flags\"),\n+            FFMUtils.C_INT.withName(\"fflags\"),\n+            FFMUtils.align(FFMUtils.C_LONG, 4).withName(\"data\"),\n+            FFMUtils.align(FFMUtils.C_POINTER, 4).withName(\"udata\")\n+    ).withName(\"kevent\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfLong ident$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"ident\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * uintptr_t ident\n+     * }\n+     *\/\n+    public static final OfLong ident$layout() {\n+        return ident$LAYOUT;\n+    }\n+\n+    private static final long ident$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * uintptr_t ident\n+     * }\n+     *\/\n+    public static final long ident$offset() {\n+        return ident$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uintptr_t ident\n+     * }\n+     *\/\n+    public static long ident(MemorySegment struct) {\n+        return struct.get(ident$LAYOUT, ident$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * uintptr_t ident\n+     * }\n+     *\/\n+    public static void ident(MemorySegment struct, long fieldValue) {\n+        struct.set(ident$LAYOUT, ident$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfShort filter$LAYOUT = (OfShort)$LAYOUT.select(groupElement(\"filter\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int16_t filter\n+     * }\n+     *\/\n+    public static final OfShort filter$layout() {\n+        return filter$LAYOUT;\n+    }\n+\n+    private static final long filter$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int16_t filter\n+     * }\n+     *\/\n+    public static final long filter$offset() {\n+        return filter$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int16_t filter\n+     * }\n+     *\/\n+    public static short filter(MemorySegment struct) {\n+        return struct.get(filter$LAYOUT, filter$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int16_t filter\n+     * }\n+     *\/\n+    public static void filter(MemorySegment struct, short fieldValue) {\n+        struct.set(filter$LAYOUT, filter$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfShort flags$LAYOUT = (OfShort)$LAYOUT.select(groupElement(\"flags\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * uint16_t flags\n+     * }\n+     *\/\n+    public static final OfShort flags$layout() {\n+        return flags$LAYOUT;\n+    }\n+\n+    private static final long flags$OFFSET = 10;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * uint16_t flags\n+     * }\n+     *\/\n+    public static final long flags$offset() {\n+        return flags$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uint16_t flags\n+     * }\n+     *\/\n+    public static short flags(MemorySegment struct) {\n+        return struct.get(flags$LAYOUT, flags$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * uint16_t flags\n+     * }\n+     *\/\n+    public static void flags(MemorySegment struct, short fieldValue) {\n+        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt fflags$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"fflags\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * uint32_t fflags\n+     * }\n+     *\/\n+    public static final OfInt fflags$layout() {\n+        return fflags$LAYOUT;\n+    }\n+\n+    private static final long fflags$OFFSET = 12;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * uint32_t fflags\n+     * }\n+     *\/\n+    public static final long fflags$offset() {\n+        return fflags$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uint32_t fflags\n+     * }\n+     *\/\n+    public static int fflags(MemorySegment struct) {\n+        return struct.get(fflags$LAYOUT, fflags$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * uint32_t fflags\n+     * }\n+     *\/\n+    public static void fflags(MemorySegment struct, int fieldValue) {\n+        struct.set(fflags$LAYOUT, fflags$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfLong data$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"data\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * intptr_t data\n+     * }\n+     *\/\n+    public static final OfLong data$layout() {\n+        return data$LAYOUT;\n+    }\n+\n+    private static final long data$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * intptr_t data\n+     * }\n+     *\/\n+    public static final long data$offset() {\n+        return data$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * intptr_t data\n+     * }\n+     *\/\n+    public static long data(MemorySegment struct) {\n+        return struct.get(data$LAYOUT, data$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * intptr_t data\n+     * }\n+     *\/\n+    public static void data(MemorySegment struct, long fieldValue) {\n+        struct.set(data$LAYOUT, data$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout udata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"udata\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *udata\n+     * }\n+     *\/\n+    public static final AddressLayout udata$layout() {\n+        return udata$LAYOUT;\n+    }\n+\n+    private static final long udata$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *udata\n+     * }\n+     *\/\n+    public static final long udata$offset() {\n+        return udata$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *udata\n+     * }\n+     *\/\n+    public static MemorySegment udata(MemorySegment struct) {\n+        return struct.get(udata$LAYOUT, udata$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *udata\n+     * }\n+     *\/\n+    public static void udata(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(udata$LAYOUT, udata$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/kevent.java","additions":387,"deletions":0,"binary":false,"changes":387,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.kqueue;\n+\n+import jdk.internal.ffi.util.FFMUtils;\n+import jdk.internal.foreign.*;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+\n+@SuppressWarnings(\"restricted\")\n+public class kqueue_h {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    kqueue_h() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(Linker.nativeLinker().defaultLookup());\n+\n+    private static final int EV_ADD = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EV_ADD 1\n+     * }\n+     *\/\n+    public static int EV_ADD() {\n+        return EV_ADD;\n+    }\n+    private static final int EV_DELETE = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EV_DELETE 2\n+     * }\n+     *\/\n+    public static int EV_DELETE() {\n+        return EV_DELETE;\n+    }\n+    private static final int EV_ONESHOT = (int)16L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EV_ONESHOT 16\n+     * }\n+     *\/\n+    public static int EV_ONESHOT() {\n+        return EV_ONESHOT;\n+    }\n+\n+    private static final int EV_CLEAR = (int)32L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EV_CLEAR 32\n+     * }\n+     *\/\n+    public static int EV_CLEAR() {\n+        return EV_CLEAR;\n+    }\n+\n+    private static class kqueue {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                FFMUtils.C_INT    );\n+\n+        public static final MemorySegment ADDR = FFMUtils.findOrThrow(\"kqueue\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC,\n+                Linker.Option.captureCallState(ERRNO_NAME));\n+\n+        public static final MethodHandle ADAPTED = CaptureStateUtil.adaptSystemCall(HANDLE, ERRNO_NAME);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int kqueue()\n+     * }\n+     *\/\n+    public static FunctionDescriptor kqueue$descriptor() {\n+        return kqueue.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int kqueue()\n+     * }\n+     *\/\n+    public static MethodHandle kqueue$handle() {\n+        return kqueue.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * int kqueue()\n+     * }\n+     *\/\n+    public static MemorySegment kqueue$address() {\n+        return kqueue.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int kqueue()\n+     * }\n+     *\/\n+    public static int kqueue() {\n+        try {\n+            return (int) kqueue.ADAPTED.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class kevent {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+                FFMUtils.C_INT,\n+                FFMUtils.C_INT,\n+                FFMUtils.C_POINTER,\n+                FFMUtils.C_INT,\n+                FFMUtils.C_POINTER,\n+                FFMUtils.C_INT,\n+                FFMUtils.C_POINTER\n+        );\n+\n+        public static final MemorySegment ADDR = FFMUtils.findOrThrow(\"kevent\");\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC,\n+                Linker.Option.captureCallState(ERRNO_NAME));\n+        public static final MethodHandle ADAPTED =  CaptureStateUtil.adaptSystemCall(HANDLE, ERRNO_NAME);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)\n+     * }\n+     *\/\n+    public static FunctionDescriptor kevent$descriptor() {\n+        return kevent.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)\n+     * }\n+     *\/\n+    public static MethodHandle kevent$handle() {\n+        return kevent.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)\n+     * }\n+     *\/\n+    public static MemorySegment kevent$address() {\n+        return kevent.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)\n+     * }\n+     *\/\n+    public static int kevent(int kq, MemorySegment changelist, int nchanges, MemorySegment eventlist, int nevents, MemorySegment timeout) {\n+        try {\n+            if (FFMUtils.TRACE_DOWNCALLS) {\n+                FFMUtils.traceDowncall(\"kevent\", kq, changelist, nchanges, eventlist, nevents, timeout);\n+            }\n+             return (int) kevent.ADAPTED.invokeExact(kq, changelist, nchanges, eventlist, nevents, timeout);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static final int EVFILT_READ = (int)-1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EVFILT_READ -1\n+     * }\n+     *\/\n+    public static int EVFILT_READ() {\n+        return EVFILT_READ;\n+    }\n+    private static final int EVFILT_WRITE = (int)-2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define EVFILT_WRITE -2\n+     * }\n+     *\/\n+    public static int EVFILT_WRITE() {\n+        return EVFILT_WRITE;\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/kqueue_h.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Defines native structures for Kqueue socket APIs.\n+ * Generated with the following jextract command:\n+ * {@snippet lang = \"Shell Script\":\n+ *\n+ *  HEADER_NAME=kqueue.h\n+ *   echo \"#include <sys\/types.h> \" > $HEADER_NAME\n+ *   echo \"#include <sys\/event.h>\" >> $HEADER_NAME\n+ *\n+ *\n+ * $JEXTRACT --target-package jdk.internal.natives.net.kqueue \\\n+ *    --include-constant EV_CLEAR \\\n+ *    --include-constant EV_ONESHOT \\\n+ *    --include-constant EV_DELETE \\\n+ *    --include-constant EV_ADD \\\n+ *    --include-constant EVFILT_WRITE \\\n+ *    --include-constant EVFILT_READ \\\n+ *    --include-function kevent \\\n+ *    --include-function kqueue \\\n+ *    --include-struct kevent \\\n+ *    --include-struct klist \\\n+ *    $HEADER_NAME\n+ * }\n+ *\n+ * After generation of native bindings, the layouts for the C builtin layouts and other\n+ * variables\/methods not specific to a component area are moved to the {@code BindingUtils} class\n+ * for future reusability.\n+ *\n+ *\/\n+\n+package jdk.internal.ffi.generated.kqueue;\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/package-info.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Defines native structures for timespec APIs.\n+ * Generated with the following jextract command:\n+ * {@snippet lang = \"Shell Script\":\n+ *\n+ * HEADER_NAME=timespec.h\n+ * echo \"#include <time.h>\" > $HEADER_NAME\n+ *\n+ * jextract --target-package jdk.internal.ffi.generated.timespec \\\n+ *    --include-struct timespec \\\n+ *    $HEADER_NAME\n+ * }\n+ *\n+ * After generation of native bindings, the layouts for the C builtin layouts and other\n+ * variables\/methods not specific to a component area are moved to the {@code BindingUtils} class\n+ * for future reusability.\n+ *\n+ *\/\n+\n+package jdk.internal.ffi.generated.timespec;\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/package-info.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.ffi.generated.timespec;\n+\n+import jdk.internal.ffi.util.*;\n+\n+import java.lang.foreign.*;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.ValueLayout.OfLong;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct timespec {\n+ *     __darwin_time_t tv_sec;\n+ *     long tv_nsec;\n+ * }\n+ * }\n+ *\/\n+@SuppressWarnings(\"restricted\")\n+public class timespec {\n+\n+    timespec() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+            FFMUtils.C_LONG.withName(\"tv_sec\"),\n+            FFMUtils.C_LONG.withName(\"tv_nsec\")\n+    ).withName(\"timespec\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfLong tv_sec$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"tv_sec\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * __darwin_time_t tv_sec\n+     * }\n+     *\/\n+    public static final OfLong tv_sec$layout() {\n+        return tv_sec$LAYOUT;\n+    }\n+\n+    private static final long tv_sec$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * __darwin_time_t tv_sec\n+     * }\n+     *\/\n+    public static final long tv_sec$offset() {\n+        return tv_sec$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * __darwin_time_t tv_sec\n+     * }\n+     *\/\n+    public static long tv_sec(MemorySegment struct) {\n+        return struct.get(tv_sec$LAYOUT, tv_sec$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * __darwin_time_t tv_sec\n+     * }\n+     *\/\n+    public static void tv_sec(MemorySegment struct, long fieldValue) {\n+        struct.set(tv_sec$LAYOUT, tv_sec$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfLong tv_nsec$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"tv_nsec\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * long tv_nsec\n+     * }\n+     *\/\n+    public static final OfLong tv_nsec$layout() {\n+        return tv_nsec$LAYOUT;\n+    }\n+\n+    private static final long tv_nsec$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * long tv_nsec\n+     * }\n+     *\/\n+    public static final long tv_nsec$offset() {\n+        return tv_nsec$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * long tv_nsec\n+     * }\n+     *\/\n+    public static long tv_nsec(MemorySegment struct) {\n+        return struct.get(tv_nsec$LAYOUT, tv_nsec$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * long tv_nsec\n+     * }\n+     *\/\n+    public static void tv_nsec(MemorySegment struct, long fieldValue) {\n+        struct.set(tv_nsec$LAYOUT, tv_nsec$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/timespec.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.ffi.util;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+@SuppressWarnings(\"restricted\")\n+public final class FFMUtils {\n+\n+    public static final ValueLayout.OfBoolean C_BOOL =\n+            (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+\n+    public static final ValueLayout.OfByte C_CHAR =\n+            (ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+\n+    public static final ValueLayout.OfShort C_SHORT =\n+            (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+\n+    public static final ValueLayout.OfInt C_INT =\n+            (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+\n+    public static final ValueLayout.OfLong C_LONG_LONG =\n+            (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+\n+    public static final ValueLayout.OfFloat C_FLOAT =\n+            (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+\n+    public static final ValueLayout.OfDouble C_DOUBLE =\n+            (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+\n+    public static final AddressLayout C_POINTER =\n+            ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n+\n+    public static final ValueLayout.OfLong C_LONG =\n+            (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n+\n+    private FFMUtils() {\n+    }\n+\n+    \/**\n+     * Returns a {@code MemorySegment} set to the size of byteSize\n+     *\n+     * @param byteSize the size in bytes to be allocated\n+     * @param byteAlignment the size in bytes for the memory alignment\n+     *\n+     * @throws IllegalArgumentException if the maxByteAlignment of the created\n+     * MemorySegment is less than the provided byteAlignment\n+     *\n+     * @return the newly created {@code MemorySegment}\n+     *\/\n+    public static MemorySegment malloc(long byteSize, long byteAlignment) {\n+        long allocatedMemory = UNSAFE.allocateMemory(byteSize);\n+        MemorySegment result = MemorySegment.ofAddress(allocatedMemory).reinterpret(byteSize);\n+        if (result.maxByteAlignment() < byteAlignment) {\n+            throw new IllegalArgumentException();\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Takes a {@code MemorySegment} and deallocates the memory at that address\n+     * @param memorySegment the {@code MemorySegment} that will be deallocated\n+     *\/\n+    public static void free(MemorySegment memorySegment) {\n+        UNSAFE.freeMemory(memorySegment.address());\n+    }\n+\n+    \/\/ SegmentAllocator that delegates to Unsafe for memory allocation\n+    public static final SegmentAllocator SEGMENT_ALLOCATOR = new SegmentAllocator() {\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return malloc(byteSize, byteAlignment);\n+        }\n+    };\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Variables and methods below are extracted from jextract generated\n+    \/\/ code and used by native bindings on all platforms\n+    public static final boolean TRACE_DOWNCALLS = false;\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(Linker.nativeLinker().defaultLookup());\n+\n+    public static void traceDowncall(String name, Object... args) {\n+        String traceArgs = Arrays.stream(args)\n+                .map(Object::toString)\n+                .collect(Collectors.joining(\", \"));\n+        System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    public static MemorySegment findOrThrow(String symbol) {\n+        return SYMBOL_LOOKUP.findOrThrow(symbol);\n+    }\n+\n+    public static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    public static MemoryLayout align(MemoryLayout layout, long align) {\n+        return switch (layout) {\n+            case PaddingLayout p -> p;\n+            case ValueLayout v -> v.withByteAlignment(align);\n+            case GroupLayout g -> {\n+                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                yield g instanceof StructLayout ?\n+                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+            }\n+            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+        };\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/util\/FFMUtils.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+import jdk.internal.ffi.generated.kqueue.kevent;\n+import jdk.internal.ffi.generated.kqueue.kqueue_h;\n+import jdk.internal.ffi.generated.timespec.timespec;\n+import jdk.internal.ffi.generated.ErrnoUtils;\n+import jdk.internal.ffi.util.FFMUtils;\n+import jdk.internal.foreign.BufferStack;\n+\n@@ -29,1 +36,5 @@\n-import jdk.internal.misc.Unsafe;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import static java.lang.foreign.MemorySegment.NULL;\n+import static jdk.internal.ffi.generated.errno.errno_h.EINTR;\n@@ -35,2 +46,1 @@\n-class KQueue {\n-    private KQueue() { }\n+final class KQueue {\n@@ -38,1 +48,3 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+    private static final BufferStack POOL = BufferStack.of(timespec.layout());\n+\n+    private KQueue() { }\n@@ -50,7 +62,0 @@\n-    static {\n-        IOUtil.load();\n-    }\n-    private static final int SIZEOF_KQUEUEEVENT    = keventSize();\n-    private static final int OFFSET_IDENT          = identOffset();\n-    private static final int OFFSET_FILTER         = filterOffset();\n-    private static final int OFFSET_FLAGS          = flagsOffset();\n@@ -59,2 +64,2 @@\n-    static final int EVFILT_READ  = -1;\n-    static final int EVFILT_WRITE = -2;\n+    static final int EVFILT_READ  = kqueue_h.EVFILT_READ();\n+    static final int EVFILT_WRITE = kqueue_h.EVFILT_WRITE();\n@@ -63,4 +68,4 @@\n-    static final int EV_ADD     = 0x0001;\n-    static final int EV_DELETE  = 0x0002;\n-    static final int EV_ONESHOT = 0x0010;\n-    static final int EV_CLEAR   = 0x0020;\n+    static final int EV_ADD     = kqueue_h.EV_ADD();\n+    static final int EV_DELETE  = kqueue_h.EV_DELETE();\n+    static final int EV_ONESHOT = kqueue_h.EV_ONESHOT();\n+    static final int EV_CLEAR   = kqueue_h.EV_CLEAR();\n@@ -71,2 +76,2 @@\n-    static long allocatePollArray(int count) {\n-        return unsafe.allocateMemory(count * SIZEOF_KQUEUEEVENT);\n+    static MemorySegment allocatePollArray(int count) {\n+        return kevent.allocateArray(count, FFMUtils.SEGMENT_ALLOCATOR);\n@@ -78,2 +83,2 @@\n-    static void freePollArray(long address) {\n-        unsafe.freeMemory(address);\n+    static void freePollArray(MemorySegment memorySegment){\n+        FFMUtils.free(memorySegment);\n@@ -85,2 +90,2 @@\n-    static long getEvent(long address, int i) {\n-        return address + (SIZEOF_KQUEUEEVENT*i);\n+    static MemorySegment getEvent(MemorySegment memoryHandle, int i) {\n+        return kevent.asSlice(memoryHandle, i);\n@@ -92,2 +97,2 @@\n-    static int getDescriptor(long address) {\n-        return unsafe.getInt(address + OFFSET_IDENT);\n+    static long getDescriptor(MemorySegment memoryHandle) {\n+        return kevent.ident(memoryHandle);\n@@ -96,2 +101,2 @@\n-    static short getFilter(long address) {\n-        return unsafe.getShort(address + OFFSET_FILTER);\n+    static short getFilter(MemorySegment memoryHandle) {\n+        return kevent.filter(memoryHandle);\n@@ -100,2 +105,2 @@\n-    static short getFlags(long address) {\n-        return unsafe.getShort(address + OFFSET_FLAGS);\n+    static short getFlags(MemorySegment memoryHandle) {\n+        return kevent.flags(memoryHandle);\n@@ -106,9 +111,20 @@\n-    private static native int keventSize();\n-\n-    private static native int identOffset();\n-\n-    private static native int filterOffset();\n-\n-    private static native int flagsOffset();\n-\n-    static native int create() throws IOException;\n+    static public int register(int kqfd, int fd, int filter, int flags) {\n+        int result;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment keventMS = arena.allocate(kevent.layout());\n+            kevent.ident(keventMS, fd);\n+            kevent.filter(keventMS, (short) filter);\n+            kevent.flags(keventMS, (short) flags);\n+            \/\/ rest default to zero\n+\n+            \/\/ this do-while replaces restartable\n+            do {\n+                result = kqueue_h.kevent(\n+                        kqfd, keventMS, 1, NULL,\n+                        0, NULL);\n+            } while (result == -EINTR());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+        return result;\n+    }\n@@ -116,1 +132,30 @@\n-    static native int register(int kqfd, int fd, int filter, int flags);\n+    static public int poll(int kqfd, MemorySegment pollAddress, int nevents, long timeout) {\n+        int result;\n+        try (Arena arena = POOL.pushFrame(timespec.layout())) {\n+            MemorySegment tsMS = arena.allocate(timespec.layout());\n+            MemorySegment tsp;\n+\n+            if (timeout >= 0) {\n+                timespec.tv_sec(tsMS, timeout \/ 1000);\n+                timespec.tv_nsec(tsMS, (timeout % 1000) * 1000000);\n+                tsp = tsMS;\n+            } else {\n+                tsp = NULL;\n+            }\n+\n+            result = kqueue_h.kevent(\n+                    kqfd, NULL, 0, pollAddress,\n+                    nevents, tsp);\n+            if (result < 0) {\n+                if (result == -EINTR()) {\n+                    return IOStatus.INTERRUPTED;\n+                } else {\n+                    throw ErrnoUtils.IOExceptionWithErrnoString(-result,\n+                            \"kqueue failed.\");\n+                }\n+            }\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+        return result;\n+    }\n@@ -118,2 +163,7 @@\n-    static native int poll(int kqfd, long pollAddress, int nevents, long timeout)\n-        throws IOException;\n+    static int create() throws IOException {\n+        int res = kqueue_h.kqueue();\n+        if (res < 0) {\n+            throw ErrnoUtils.IOExceptionWithErrnoString(-res, \"kqueue failed\");\n+        }\n+        return res;\n+    }\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueue.java","additions":92,"deletions":42,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import jdk.internal.ffi.generated.*;\n+import jdk.internal.ffi.generated.kqueue.kqueue_h;\n+\n@@ -28,0 +31,2 @@\n+import java.lang.foreign.MemorySegment;\n+\n@@ -37,1 +42,1 @@\n-    private final long address;\n+    private final MemorySegment pollArray;\n@@ -43,1 +48,1 @@\n-        this.address = KQueue.allocatePollArray(maxEvents);\n+        this.pollArray = KQueue.allocatePollArray(maxEvents);\n@@ -68,1 +73,1 @@\n-        int n = KQueue.poll(kqfd, address, maxEvents, timeout);\n+        int n = KQueue.poll(kqfd, pollArray, maxEvents, timeout);\n@@ -71,2 +76,2 @@\n-            long keventAddress = KQueue.getEvent(address, i);\n-            int fdVal = KQueue.getDescriptor(keventAddress);\n+            MemorySegment eventMS = KQueue.getEvent(pollArray, i);\n+            int fdVal = (int) KQueue.getDescriptor(eventMS);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueuePoller.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import java.nio.channels.spi.AsynchronousChannelProvider;\n+import jdk.internal.ffi.generated.*;\n+import jdk.internal.ffi.generated.kqueue.kqueue_h;\n+\n@@ -30,0 +32,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.nio.channels.spi.AsynchronousChannelProvider;\n@@ -53,1 +57,1 @@\n-    private final long address;\n+    private final MemorySegment pollArrayRegions;\n@@ -88,1 +92,0 @@\n-\n@@ -90,1 +93,1 @@\n-        this.address = KQueue.allocatePollArray(MAX_KEVENTS_TO_POLL);\n+        this.pollArrayRegions = KQueue.allocatePollArray(MAX_KEVENTS_TO_POLL);\n@@ -97,1 +100,1 @@\n-            KQueue.freePollArray(address);\n+            KQueue.freePollArray(pollArrayRegions);\n@@ -129,1 +132,1 @@\n-        KQueue.freePollArray(address);\n+        KQueue.freePollArray(pollArrayRegions);\n@@ -200,1 +203,1 @@\n-                        n = KQueue.poll(kqfd, address, MAX_KEVENTS_TO_POLL, -1L);\n+                        n = KQueue.poll(kqfd, pollArrayRegions, MAX_KEVENTS_TO_POLL, -1L);\n@@ -212,2 +215,2 @@\n-                            long keventAddress = KQueue.getEvent(address, n);\n-                            int fd = KQueue.getDescriptor(keventAddress);\n+                            MemorySegment eventMS = KQueue.getEvent(pollArrayRegions, n);\n+                            int fd = (int) KQueue.getDescriptor(eventMS);\n@@ -238,1 +241,1 @@\n-                                int filter = KQueue.getFilter(keventAddress);\n+                                int filter = KQueue.getFilter(eventMS);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueuePort.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.ffi.generated.*;\n+import jdk.internal.ffi.generated.kqueue.kqueue_h;\n+\n@@ -29,0 +32,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -57,1 +61,1 @@\n-    private final long pollArrayAddress;\n+    private final MemorySegment pollArrayAddress;\n@@ -80,1 +84,0 @@\n-\n@@ -100,1 +103,1 @@\n-        throws IOException\n+            throws IOException\n@@ -232,1 +235,1 @@\n-        throws IOException\n+            throws IOException\n@@ -248,2 +251,2 @@\n-            long kevent = KQueue.getEvent(pollArrayAddress, i);\n-            int fd = KQueue.getDescriptor(kevent);\n+            MemorySegment eventMS = KQueue.getEvent(pollArrayAddress, i);\n+            int fd = (int) KQueue.getDescriptor(eventMS);\n@@ -256,1 +259,1 @@\n-                    short filter = KQueue.getFilter(kevent);\n+                    short filter = KQueue.getFilter(eventMS);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueueSelectorImpl.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <strings.h>\n-#include <sys\/types.h>\n-#include <sys\/event.h>\n-#include <sys\/time.h>\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jlong.h\"\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-\n-#include \"sun_nio_ch_KQueue.h\"\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_keventSize(JNIEnv* env, jclass clazz)\n-{\n-    return sizeof(struct kevent);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_identOffset(JNIEnv* env, jclass clazz)\n-{\n-    return offsetof(struct kevent, ident);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_filterOffset(JNIEnv* env, jclass clazz)\n-{\n-    return offsetof(struct kevent, filter);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_flagsOffset(JNIEnv* env, jclass clazz)\n-{\n-    return offsetof(struct kevent, flags);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_create(JNIEnv *env, jclass clazz) {\n-    int kqfd = kqueue();\n-    if (kqfd < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"kqueue failed\");\n-        return IOS_THROWN;\n-    }\n-    return kqfd;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_register(JNIEnv *env, jclass clazz, jint kqfd,\n-                                jint fd, jint filter, jint flags)\n-\n-{\n-    struct kevent changes[1];\n-    int res;\n-\n-    EV_SET(&changes[0], fd, filter, flags, 0, 0, 0);\n-    RESTARTABLE(kevent(kqfd, &changes[0], 1, NULL, 0, NULL), res);\n-    return (res == -1) ? errno : 0;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_poll(JNIEnv *env, jclass clazz, jint kqfd, jlong address,\n-                            jint nevents, jlong timeout)\n-{\n-    struct kevent *events = jlong_to_ptr(address);\n-    int res;\n-    struct timespec ts;\n-    struct timespec *tsp;\n-\n-    if (timeout >= 0) {\n-        ts.tv_sec = timeout \/ 1000;\n-        ts.tv_nsec = (timeout % 1000) * 1000000;\n-        tsp = &ts;\n-    } else {\n-        tsp = NULL;\n-    }\n-\n-    res = kevent(kqfd, NULL, 0, events, nevents, tsp);\n-    if (res < 0) {\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        } else {\n-            JNU_ThrowIOExceptionWithLastError(env, \"kqueue failed\");\n-            return IOS_THROWN;\n-        }\n-    }\n-    return res;\n-}\n","filename":"src\/java.base\/macosx\/native\/libnio\/ch\/KQueue.c","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"}]}