{"files":[{"patch":"@@ -172,4 +172,4 @@\n-  while (1) {\n-    Node *next = ctl;\n-    \/\/ Moving the node out of a loop on the projection of a If\n-    \/\/ confuses loop predication. So once we hit a Loop in a If branch\n+  while (true) {\n+    Node* next = ctl;\n+    \/\/ Moving the node out of a loop on the projection of an If\n+    \/\/ confuses Loop Predication. So, once we hit a loop in an If branch\n@@ -6380,1 +6380,1 @@\n-    \/\/ following pass of loop predication doesn't hoist a predicate\n+    \/\/ following pass of Loop Predication doesn't hoist a predicate\n@@ -6382,3 +6382,4 @@\n-    Node* new_ctrl = least;\n-    for (;;) {\n-      if (!new_ctrl->is_Proj()) {\n+    PredicateEntryIterator predicate_iterator(least);\n+    while (predicate_iterator.has_next()) {\n+      Node* next_predicate_entry = predicate_iterator.next_entry();\n+      if (is_dominator(next_predicate_entry, early) && next_predicate_entry != early) {\n@@ -6387,16 +6388,1 @@\n-      CallStaticJavaNode* call = new_ctrl->as_Proj()->is_uncommon_trap_if_pattern();\n-      if (call == nullptr) {\n-        break;\n-      }\n-      int req = call->uncommon_trap_request();\n-      Deoptimization::DeoptReason trap_reason = Deoptimization::trap_request_reason(req);\n-      if (trap_reason != Deoptimization::Reason_loop_limit_check &&\n-          trap_reason != Deoptimization::Reason_predicate &&\n-          trap_reason != Deoptimization::Reason_profile_predicate) {\n-        break;\n-      }\n-      Node* c = new_ctrl->in(0)->in(0);\n-      if (is_dominator(c, early) && c != early) {\n-        break;\n-      }\n-      new_ctrl = c;\n+      least = next_predicate_entry;\n@@ -6404,1 +6390,0 @@\n-    least = new_ctrl;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  while (is_assertion_predicate_success_proj(entry)) {\n+  while (AssertionPredicateWithHalt::is_predicate(entry)) {\n@@ -41,2 +41,2 @@\n-bool AssertionPredicatesWithHalt::is_assertion_predicate_success_proj(const Node* predicate_proj) {\n-  if (predicate_proj == nullptr || !predicate_proj->is_IfProj() || !predicate_proj->in(0)->is_If()) {\n+bool AssertionPredicateWithHalt::is_predicate(const Node* maybe_success_proj) {\n+  if (maybe_success_proj == nullptr || !maybe_success_proj->is_IfProj() || !maybe_success_proj->in(0)->is_If()) {\n@@ -45,1 +45,1 @@\n-  return has_assertion_predicate_opaque(predicate_proj) && has_halt(predicate_proj);\n+  return has_assertion_predicate_opaque(maybe_success_proj) && has_halt(maybe_success_proj);\n@@ -50,1 +50,1 @@\n-bool AssertionPredicatesWithHalt::has_assertion_predicate_opaque(const Node* predicate_proj) {\n+bool AssertionPredicateWithHalt::has_assertion_predicate_opaque(const Node* predicate_proj) {\n@@ -57,1 +57,1 @@\n-bool AssertionPredicatesWithHalt::has_halt(const Node* success_proj) {\n+bool AssertionPredicateWithHalt::has_halt(const Node* success_proj) {\n@@ -75,1 +75,9 @@\n-Deoptimization::DeoptReason RuntimePredicate::uncommon_trap_reason(IfProjNode* if_proj) {\n+bool ParsePredicate::is_predicate(Node* maybe_success_proj) {\n+  if (!maybe_success_proj->is_IfProj()) {\n+    return false;\n+  }\n+  IfNode* if_node = maybe_success_proj->in(0)->as_If();\n+  return if_node->is_ParsePredicate();\n+}\n+\n+Deoptimization::DeoptReason RegularPredicateWithUCT::uncommon_trap_reason(IfProjNode* if_proj) {\n@@ -83,2 +91,14 @@\n-bool RuntimePredicate::is_success_proj(Node* node, Deoptimization::DeoptReason deopt_reason) {\n-  if (may_be_runtime_predicate_if(node)) {\n+bool RegularPredicateWithUCT::is_predicate(Node* maybe_success_proj) {\n+  if (may_be_predicate_if(maybe_success_proj)) {\n+    IfProjNode* success_proj = maybe_success_proj->as_IfProj();\n+    const Deoptimization::DeoptReason deopt_reason = uncommon_trap_reason(success_proj);\n+    return (deopt_reason == Deoptimization::Reason_loop_limit_check ||\n+            deopt_reason == Deoptimization::Reason_predicate ||\n+            deopt_reason == Deoptimization::Reason_profile_predicate);\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool RegularPredicateWithUCT::is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason) {\n+  if (may_be_predicate_if(node)) {\n@@ -92,1 +112,1 @@\n-bool RuntimePredicate::may_be_runtime_predicate_if(Node* node) {\n+bool RegularPredicateWithUCT::may_be_predicate_if(Node* node) {\n@@ -104,0 +124,4 @@\n+bool RuntimePredicate::is_success_proj(Node* node, Deoptimization::DeoptReason deopt_reason) {\n+  return RegularPredicateWithUCT::is_predicate(node, deopt_reason);\n+}\n+\n@@ -359,0 +383,15 @@\n+\n+\/\/ Is current node pointed to by iterator a predicate?\n+bool PredicateEntryIterator::has_next() const {\n+    return ParsePredicate::is_predicate(_current) ||\n+           RegularPredicateWithUCT::is_predicate(_current) ||\n+           AssertionPredicateWithHalt::is_predicate(_current);\n+}\n+\n+\/\/ Skip the current predicate pointed to by iterator by returning the input into the predicate. This could possibly be\n+\/\/ a non-predicate node.\n+Node* PredicateEntryIterator::next_entry() {\n+  assert(has_next(), \"current must be predicate\");\n+  _current = _current->in(0)->in(0);\n+  return _current;\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":49,"deletions":10,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/connode.hpp\"\n@@ -202,3 +203,0 @@\n-  static bool has_assertion_predicate_opaque(const Node* predicate_proj);\n-  static bool has_halt(const Node* success_proj);\n-  static bool is_assertion_predicate_success_proj(const Node* predicate_proj);\n@@ -216,0 +214,24 @@\n+\/\/ Class to represent a single Assertion Predicate with a HaltNode. This could either be:\n+\/\/ - A Template Assertion Predicate.\n+\/\/ - An Initialized Assertion Predicate.\n+\/\/ Note that all other Regular Predicates have an UCT node.\n+class AssertionPredicateWithHalt : public StackObj {\n+  static bool has_assertion_predicate_opaque(const Node* predicate_proj);\n+  static bool has_halt(const Node* success_proj);\n+ public:\n+  static bool is_predicate(const Node* maybe_success_proj);\n+};\n+\n+\/\/ Class to represent a single Regular Predicate with an UCT. This could either be:\n+\/\/ - A Runtime Predicate\n+\/\/ - A Template Assertion Predicate\n+\/\/ Note that all other Regular Predicates have a Halt node.\n+class RegularPredicateWithUCT : public StackObj {\n+  static Deoptimization::DeoptReason uncommon_trap_reason(IfProjNode* if_proj);\n+  static bool may_be_predicate_if(Node* node);\n+\n+ public:\n+  static bool is_predicate(Node* maybe_success_proj);\n+  static bool is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason);\n+};\n+\n@@ -222,1 +244,1 @@\n-  IfTrueNode* init_success_proj(const Node* parse_predicate_proj) const {\n+  static IfTrueNode* init_success_proj(const Node* parse_predicate_proj) {\n@@ -256,0 +278,2 @@\n+\n+  static bool is_predicate(Node* maybe_success_proj);\n@@ -260,3 +284,0 @@\n-  static Deoptimization::DeoptReason uncommon_trap_reason(IfProjNode* if_proj);\n-  static bool may_be_runtime_predicate_if(Node* node);\n-\n@@ -476,0 +497,13 @@\n+\n+\/\/ Special predicate iterator that can be used to walk through predicate entries, regardless of whether the predicate\n+\/\/ belongs to the same loop or not (i.e. leftovers from already folded nodes). The iterator returns the next entry\n+\/\/ to a predicate.\n+class PredicateEntryIterator : public StackObj {\n+  Node* _current;\n+\n+ public:\n+  explicit PredicateEntryIterator(Node* start) : _current(start) {};\n+\n+  bool has_next() const;\n+  Node* next_entry();\n+};\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":41,"deletions":7,"binary":false,"changes":48,"status":"modified"}]}