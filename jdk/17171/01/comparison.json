{"files":[{"patch":"@@ -2865,0 +2865,1 @@\n+  assert(__ last_calls_return_pc() == __ pc(), \"pcn not at return pc\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-      CodeBlob* cb = CodeCache::find_blob(pc);\n+      CodeBlob* cb = CodeCache::find_blob_fast(pc);\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-    frame sender(sender_sp, sender_pc);\n+    frame sender(sender_sp, sender_pc, nullptr \/* unextended_sp *\/, nullptr \/* fp *\/, sender_blob);\n@@ -199,1 +199,1 @@\n-    frame fr(jfa->last_Java_sp(), jfa->last_Java_pc());\n+    frame fr(jfa->last_Java_sp(), jfa->last_Java_pc(), kind::code_blob);\n@@ -204,1 +204,1 @@\n-  frame fr(jfa->last_Java_sp());\n+  frame fr(jfa->last_Java_sp(), nullptr, kind::code_blob);\n@@ -232,1 +232,1 @@\n-  frame fr(jfa->last_Java_sp(), jfa->last_Java_pc());\n+  frame fr(jfa->last_Java_sp(), jfa->last_Java_pc(), kind::code_blob);\n@@ -454,1 +454,1 @@\n-frame::frame(void* sp, void* fp, void* pc) : frame((intptr_t*)sp, (address)pc) {}\n+frame::frame(void* sp, void* fp, void* pc) : frame((intptr_t*)sp, (address)pc, kind::code_blob) {}\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -396,0 +396,9 @@\n+  enum class kind {\n+    native,           \/\/ The frame's pc is not necessarily in the CodeCache.\n+                      \/\/ CodeCache::find_blob_fast(void* pc) can yield wrong results in this case and must not be used.\n+    code_blob,        \/\/ The frame's pc is known to be in the CodeCache but it is likely not in an nmethod.\n+                      \/\/ CodeCache::find_blob_fast() will be correct but not faster in this case.\n+    nmethod           \/\/ This is likely the frame of a nmethod.\n+                      \/\/ The code cache lookup is optimized based on NativePostCallNops.\n+  };\n+\n@@ -399,1 +408,1 @@\n-  inline void setup();\n+  inline void setup(kind knd);\n@@ -405,1 +414,2 @@\n-  inline frame(intptr_t* sp, address pc, intptr_t* unextended_sp = nullptr, intptr_t* fp = nullptr, CodeBlob* cb = nullptr);\n+  inline frame(intptr_t* sp, address pc, kind knd = kind::nmethod);\n+  inline frame(intptr_t* sp, address pc, intptr_t* unextended_sp, intptr_t* fp = nullptr, CodeBlob* cb = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-inline void frame::setup() {\n+inline void frame::setup(kind knd) {\n@@ -44,2 +44,2 @@\n-  if (_cb == nullptr) {\n-    _cb = CodeCache::find_blob(_pc);\n+  if (_cb == nullptr ) {\n+    _cb = knd == kind::nmethod ? CodeCache::find_blob_fast(_pc) : CodeCache::find_blob(_pc);\n@@ -92,1 +92,1 @@\n-inline frame::frame(intptr_t* sp) : frame(sp, nullptr) {}\n+inline frame::frame(intptr_t* sp) : frame(sp, nullptr, kind::nmethod) {}\n@@ -96,0 +96,6 @@\n+inline frame::frame(intptr_t* sp, address pc, kind knd)\n+  : _sp(sp), _pc(pc), _cb(nullptr), _oop_map(nullptr),\n+    _on_heap(false), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(sp), _fp(nullptr) {\n+  setup(knd);\n+}\n+\n@@ -99,1 +105,1 @@\n-  setup();\n+  setup(kind::nmethod);\n@@ -106,1 +112,1 @@\n-  setup();\n+  setup(kind::nmethod);\n@@ -116,1 +122,1 @@\n-    setup();\n+    setup(kind::nmethod);\n@@ -303,1 +309,1 @@\n-  return frame(sender_sp(), sender_pc());\n+  return frame(sender_sp(), sender_pc(), kind::code_blob);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1190,0 +1190,3 @@\n+  \/\/ We use CMPI\/CMPLI instructions to encode post call nops.\n+  \/\/ We set bit 9 to distinguish post call nops from real CMPI\/CMPI instructions\n+  relocate(post_call_nop_Relocation::spec());\n@@ -1191,1 +1194,2 @@\n-  nop();\n+  Assembler::emit_int32(Assembler::CMPLI_OPCODE | Assembler::opp_u_field(1, 9, 9));\n+  assert(is_post_call_nop(*(int*)(pc() - 4)), \"post call not not found\");\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -420,0 +420,6 @@\n+  static bool is_post_call_nop(int instr_bits) {\n+    const uint32_t nineth_bit = opp_u_field(1, 9, 9);\n+    const uint32_t opcode_mask = 0b111110 << OPCODE_SHIFT;\n+    const uint32_t pcn_mask = opcode_mask | nineth_bit;\n+    return (instr_bits & pcn_mask) == (Assembler::CMPLI_OPCODE | nineth_bit);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -432,0 +432,25 @@\n+bool NativePostCallNop::patch(int32_t oopmap_slot, int32_t cb_offset) {\n+  int32_t i2, i1;\n+  assert(is_aligned(cb_offset, 4), \"cb offset alignment does not match instruction alignment\");\n+  assert(!decode(i1, i2), \"already patched\");\n+\n+  cb_offset = cb_offset >> 2;\n+  if (((oopmap_slot & ppc_oopmap_slot_mask) != oopmap_slot) || ((cb_offset & ppc_cb_offset_mask) != cb_offset)) {\n+    return false;  \/\/ cannot encode\n+  }\n+  const uint32_t data = oopmap_slot << ppc_cb_offset_bits | cb_offset;\n+  const uint32_t lo_data = data & ppc_data_lo_mask;\n+  const uint32_t hi_data = data >> ppc_data_lo_bits;\n+  const uint32_t nineth_bit = 1 << (31 - 9);\n+  uint32_t instr = Assembler::CMPLI_OPCODE | hi_data << ppc_data_hi_shift | nineth_bit | lo_data;\n+  *(uint32_t*)addr_at(0) = instr;\n+\n+  int32_t oopmap_slot_dec, cb_offset_dec;\n+  assert(is_post_call_nop(), \"pcn not recognized\");\n+  assert(decode(oopmap_slot_dec, cb_offset_dec), \"encoding failed\");\n+  assert(oopmap_slot == oopmap_slot_dec, \"oopmap slot encoding is wrong\");\n+  assert((cb_offset << 2) == cb_offset_dec, \"cb offset encoding is wrong\");\n+\n+  return true;  \/\/ encoding succeeded\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  bool is_nop() const { return Assembler::is_nop(long_at(0)); }\n+  bool is_post_call_nop() const { return MacroAssembler::is_post_call_nop(long_at(0)); }\n@@ -509,0 +509,29 @@\n+\n+    \/\/ We use CMPI\/CMPLI to represent Post Call Nops (PCN)\n+\n+    \/\/   Bit |0         5|6    |9 |10|11     |16                          31|\n+    \/\/       +--------------------------------------------------------------+\n+    \/\/ Field |OPCODE     |BF   |\/ |L |RA     |SI                            |\n+    \/\/       +--------------------------------------------------------------+\n+    \/\/       |0 0 1 0 1|DATA HI| 1|        DATA LO                          |\n+    \/\/       |         |4 bits |  |        22 bits                          |\n+    \/\/\n+    \/\/ Bit 9 is alwys 1 for PCNs to distinguish them from CMPI\/CMPLI\n+    \/\/\n+    \/\/ Using both, CMPLI (opcode 10 = 0b001010) and CMPI (opcode 11 = 0b001011) for\n+    \/\/ PCNs allows using bit 5 from the opcode to encode DATA HI.\n+\n+    enum {\n+      ppc_data_lo_bits = 31 - 9,\n+      ppc_data_lo_mask = right_n_bits(ppc_data_lo_bits),\n+      ppc_data_hi_bits = 9 - 5,\n+      ppc_data_hi_shift = ppc_data_lo_bits + 1,\n+      ppc_data_hi_mask = right_n_bits(ppc_data_hi_bits) << ppc_data_hi_shift,\n+      ppc_data_bits = ppc_data_lo_bits + ppc_data_hi_bits,\n+\n+      ppc_oopmap_slot_bits = 9,\n+      ppc_oopmap_slot_mask = right_n_bits(ppc_oopmap_slot_bits),\n+      ppc_cb_offset_bits = ppc_data_bits - ppc_oopmap_slot_bits,\n+      ppc_cb_offset_mask = right_n_bits(ppc_cb_offset_bits),\n+};\n+\n@@ -510,3 +539,14 @@\n-  bool check() const { return is_nop(); }\n-  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const { return false; }\n-  bool patch(int32_t oopmap_slot, int32_t cb_offset) { return false; }\n+  bool check() const { return is_post_call_nop(); }\n+  bool decode(int32_t& oopmap_slot, int32_t& cb_offset) const {\n+    uint32_t instr_bits = long_at(0);\n+    uint32_t data_lo = instr_bits & ppc_data_lo_mask;\n+    uint32_t data_hi = (instr_bits & ppc_data_hi_mask) >> 1;\n+    uint32_t data = data_hi | data_lo;\n+    if (data == 0) {\n+      return false; \/\/ no data found\n+    }\n+    cb_offset = (data & ppc_cb_offset_mask) << 2;\n+    oopmap_slot = data >> ppc_cb_offset_bits;\n+    return true; \/\/ decoding succeeded\n+  }\n+  bool patch(int32_t oopmap_slot, int32_t cb_offset);\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-  return frame(sp, pc);\n+  \/\/ Likely the frame of a RuntimeStub.\n+  return frame(sp, pc, frame::kind::code_blob);\n@@ -53,1 +54,1 @@\n-    *fr_addr = frame(sp, pc);\n+    *fr_addr = frame(sp, pc, frame::kind::code_blob);\n@@ -69,1 +70,2 @@\n-    frame ret_frame((intptr_t*)uc->uc_mcontext.jmp_context.gpr[1\/*REG_SP*\/], pc);\n+    \/\/ pc could refer to a native address outside the code cache even though the thread isInJava.\n+    frame ret_frame((intptr_t*)uc->uc_mcontext.jmp_context.gpr[1\/*REG_SP*\/], pc, frame::kind::native);\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/javaThread_aix_ppc.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-    frame fr(sp, epc);\n+    frame fr(sp, epc, frame::kind::native);\n@@ -140,1 +140,1 @@\n-  return frame(sp, lr);\n+  return frame(sp, lr, frame::kind::native);\n@@ -146,1 +146,1 @@\n-    return frame(nullptr, nullptr);\n+    return frame();\n@@ -148,1 +148,1 @@\n-  return frame(fr->sender_sp(), fr->sender_pc());\n+  return frame(fr->sender_sp(), fr->sender_pc(), frame::kind::native);\n@@ -154,1 +154,1 @@\n-  frame topframe(csp, CAST_FROM_FN_PTR(address, os::current_frame));\n+  frame topframe(csp, CAST_FROM_FN_PTR(address, os::current_frame), frame::kind::native);\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-  return frame(sp, pc);\n+  \/\/ Likely the frame of a RuntimeStub.\n+  return frame(sp, pc, frame::kind::code_blob);\n@@ -52,1 +53,1 @@\n-    *fr_addr = frame(sp, pc);\n+    *fr_addr = frame(sp, pc, frame::kind::code_blob);\n@@ -68,1 +69,2 @@\n-    frame ret_frame((intptr_t*)uc->uc_mcontext.regs->gpr[1\/*REG_SP*\/], pc);\n+    \/\/ pc could refer to a native address outside the code cache even though the thread isInJava.\n+    frame ret_frame((intptr_t*)uc->uc_mcontext.regs->gpr[1\/*REG_SP*\/], pc, frame::kind::native);\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/javaThread_linux_ppc.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  return frame(sp, epc);\n+  return frame(sp, epc, frame::kind::native);\n@@ -166,1 +166,1 @@\n-  return frame(sp, lr);\n+  return frame(sp, lr, frame::kind::native);\n@@ -172,1 +172,1 @@\n-    return frame(nullptr, nullptr);\n+    return frame();\n@@ -174,1 +174,1 @@\n-  return frame(fr->sender_sp(), fr->sender_pc());\n+  return frame(fr->sender_sp(), fr->sender_pc(), frame::kind::native);\n@@ -180,1 +180,1 @@\n-  frame topframe(csp, CAST_FROM_FN_PTR(address, os::current_frame));\n+  frame topframe(csp, CAST_FROM_FN_PTR(address, os::current_frame), frame::kind::native);\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}