{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -64,1 +66,2 @@\n-                                           G1EvacFailureRegions* evac_failure_regions)\n+                                           G1EvacFailureRegions* evac_failure_regions,\n+                                           PartialArrayStateAllocator* pas_allocator)\n@@ -83,2 +86,2 @@\n-    _partial_objarray_chunk_size(ParGCArrayScanChunk),\n-    _partial_array_stepper(num_workers),\n+    _partial_array_state_allocator(pas_allocator),\n+    _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n@@ -172,1 +175,1 @@\n-void G1ParScanThreadState::verify_task(PartialArrayScanTask task) const {\n+void G1ParScanThreadState::verify_task(PartialArrayState* task) const {\n@@ -174,1 +177,1 @@\n-  oop p = task.to_source_array();\n+  oop p = task->source();\n@@ -183,2 +186,2 @@\n-  } else if (task.is_partial_array_task()) {\n-    verify_task(task.to_partial_array_task());\n+  } else if (task.is_partial_array_state()) {\n+    verify_task(task.to_partial_array_state());\n@@ -226,2 +229,2 @@\n-void G1ParScanThreadState::do_partial_array(PartialArrayScanTask task) {\n-  oop from_obj = task.to_source_array();\n+void G1ParScanThreadState::do_partial_array(PartialArrayState* state) {\n+  oop to_obj = state->destination();\n@@ -229,0 +232,2 @@\n+#ifdef ASSERT\n+  oop from_obj = state->source();\n@@ -232,2 +237,0 @@\n-\n-  oop to_obj = from_obj->forwardee();\n@@ -236,0 +239,2 @@\n+#endif \/\/ ASSERT\n+\n@@ -238,6 +243,9 @@\n-  PartialArrayTaskStepper::Step step\n-    = _partial_array_stepper.next(objArrayOop(from_obj),\n-                                  to_array,\n-                                  _partial_objarray_chunk_size);\n-  for (uint i = 0; i < step._ncreate; ++i) {\n-    push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+  \/\/ Push any additional partial scan tasks needed.  Pushed before processing\n+  \/\/ the claimed chunk to allow other workers to steal while we're processing.\n+  if (step._ncreate > 0) {\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_on_queue(ScannerTask(state));\n+    }\n@@ -248,3 +256,1 @@\n-  \/\/ Process claimed task.  The length of to_array is not correct, but\n-  \/\/ fortunately the iteration ignores the length field and just relies\n-  \/\/ on start\/end.\n+  \/\/ Process claimed task.\n@@ -252,2 +258,4 @@\n-                              step._index,\n-                              step._index + _partial_objarray_chunk_size);\n+                              checked_cast<int>(step._index),\n+                              checked_cast<int>(step._index + _partial_array_stepper.chunk_size()));\n+  \/\/ Release reference to the state, now that we're done with it.\n+  _partial_array_state_allocator->release(_worker_id, state);\n@@ -263,1 +271,0 @@\n-  assert(from_obj != to_obj, \"should not be scanning self-forwarded objects\");\n@@ -268,4 +275,2 @@\n-  PartialArrayTaskStepper::Step step\n-    = _partial_array_stepper.start(objArrayOop(from_obj),\n-                                   to_array,\n-                                   _partial_objarray_chunk_size);\n+  size_t array_length = to_array->length();\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n@@ -275,2 +280,15 @@\n-  for (uint i = 0; i < step._ncreate; ++i) {\n-    push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+  if (step._ncreate > 0) {\n+    assert(step._index < array_length, \"invariant\");\n+    assert(((array_length - step._index) % _partial_array_stepper.chunk_size()) == 0,\n+           \"invariant\");\n+    PartialArrayState* state =\n+      _partial_array_state_allocator->allocate(_worker_id,\n+                                               from_obj, to_obj,\n+                                               step._index,\n+                                               array_length,\n+                                               step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_on_queue(ScannerTask(state));\n+    }\n+  } else {\n+    assert(step._index == array_length, \"invariant\");\n@@ -287,3 +305,2 @@\n-  \/\/ module. The length of to_array is not correct, but fortunately\n-  \/\/ the iteration ignores that length field and relies on start\/end.\n-  to_array->oop_iterate_range(&_scanner, 0, step._index);\n+  \/\/ module.\n+  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(step._index));\n@@ -300,1 +317,1 @@\n-    do_partial_array(task.to_partial_array_task());\n+    do_partial_array(task.to_partial_array_state());\n@@ -585,1 +602,2 @@\n-                               _evac_failure_regions);\n+                               _evac_failure_regions,\n+                               &_partial_array_state_allocator);\n@@ -718,1 +736,3 @@\n-    _evac_failure_regions(evac_failure_regions) {\n+    _evac_failure_regions(evac_failure_regions),\n+    _partial_array_state_allocator(num_workers)\n+{\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":55,"deletions":35,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -90,1 +91,2 @@\n-  int _partial_objarray_chunk_size;\n+  size_t _partial_objarray_chunk_size;\n+  PartialArrayStateAllocator* _partial_array_state_allocator;\n@@ -132,1 +134,2 @@\n-                       G1EvacFailureRegions* evac_failure_regions);\n+                       G1EvacFailureRegions* evac_failure_regions,\n+                       PartialArrayStateAllocator* partial_array_state_allocator);\n@@ -143,1 +146,1 @@\n-  void verify_task(PartialArrayScanTask task) const NOT_DEBUG_RETURN;\n+  void verify_task(PartialArrayState* task) const NOT_DEBUG_RETURN;\n@@ -172,1 +175,1 @@\n-  void do_partial_array(PartialArrayScanTask task);\n+  void do_partial_array(PartialArrayState* state);\n@@ -255,0 +258,1 @@\n+  PartialArrayStateAllocator _partial_array_state_allocator;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"nmt\/memflags.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include <new>\n+\n+PartialArrayState::PartialArrayState(oop src, oop dst,\n+                                     size_t index, size_t length,\n+                                     size_t initial_refcount)\n+  : _source(src),\n+    _destination(dst),\n+    _length(length),\n+    _index(index),\n+    _refcount(initial_refcount)\n+{\n+  assert(index <= length, \"precondition\");\n+}\n+\n+void PartialArrayState::add_references(size_t count) {\n+  size_t new_count = Atomic::add(&_refcount, count, memory_order_relaxed);\n+  assert(new_count >= count, \"reference count overflow\");\n+}\n+\n+class PartialArrayStateAllocator::Impl : public CHeapObj<mtGC> {\n+  struct FreeListEntry;\n+\n+  Arena* _arenas;\n+  FreeListEntry** _free_lists;\n+  uint _num_workers;\n+\n+public:\n+  Impl(uint num_workers);\n+  ~Impl();\n+\n+  NONCOPYABLE(Impl);\n+\n+  PartialArrayState* allocate(uint worker_id,\n+                              oop src, oop dst,\n+                              size_t index, size_t length,\n+                              size_t initial_refcount);\n+  void release(uint worker_id, PartialArrayState* state);\n+};\n+\n+struct PartialArrayStateAllocator::Impl::FreeListEntry {\n+  FreeListEntry* _next;\n+\n+  FreeListEntry(FreeListEntry* next) : _next(next) {}\n+  ~FreeListEntry() = default;\n+\n+  NONCOPYABLE(FreeListEntry);\n+};\n+\n+PartialArrayStateAllocator::Impl::Impl(uint num_workers)\n+  : _arenas(NEW_C_HEAP_ARRAY(Arena, num_workers, mtGC)),\n+    _free_lists(NEW_C_HEAP_ARRAY(FreeListEntry*, num_workers, mtGC)),\n+    _num_workers(num_workers)\n+{\n+  for (uint i = 0; i < _num_workers; ++i) {\n+    ::new (&_arenas[i]) Arena(mtGC);\n+    _free_lists[i] = nullptr;\n+  }\n+}\n+\n+PartialArrayStateAllocator::Impl::~Impl() {\n+  \/\/ We don't need to clean up the free lists.  Deallocating the entries\n+  \/\/ does nothing, since we're using arena allocation.  Instead, leave it\n+  \/\/ to the arena destructor to release the memory.\n+  FREE_C_HEAP_ARRAY(FreeListEntry*, _free_lists);\n+  for (uint i = 0; i < _num_workers; ++i) {\n+    _arenas[i].~Arena();\n+  }\n+}\n+\n+PartialArrayState* PartialArrayStateAllocator::Impl::allocate(uint worker_id,\n+                                                              oop src, oop dst,\n+                                                              size_t index,\n+                                                              size_t length,\n+                                                              size_t initial_refcount) {\n+  void* p;\n+  FreeListEntry* head = _free_lists[worker_id];\n+  if (head == nullptr) {\n+    p = NEW_ARENA_OBJ(&_arenas[worker_id], PartialArrayState);\n+  } else {\n+    _free_lists[worker_id] = head->_next;\n+    head->~FreeListEntry();\n+    p = head;\n+  }\n+  return ::new (p) PartialArrayState(src, dst, index, length, initial_refcount);\n+}\n+\n+void PartialArrayStateAllocator::Impl::release(uint worker_id, PartialArrayState* state) {\n+  size_t refcount = Atomic::sub(&state->_refcount, size_t(1), memory_order_release);\n+  if (refcount != 0) {\n+    assert(refcount + 1 != 0, \"refcount underflow\");\n+  } else {\n+    OrderAccess::acquire();\n+    state->~PartialArrayState();\n+    _free_lists[worker_id] = ::new (state) FreeListEntry(_free_lists[worker_id]);\n+  }\n+}\n+\n+PartialArrayStateAllocator::PartialArrayStateAllocator(uint num_workers)\n+  : _impl(new Impl(num_workers))\n+{}\n+\n+PartialArrayStateAllocator::~PartialArrayStateAllocator() {\n+  delete _impl;\n+}\n+\n+PartialArrayState* PartialArrayStateAllocator::allocate(uint worker_id,\n+                                                        oop src, oop dst,\n+                                                        size_t index,\n+                                                        size_t length,\n+                                                        size_t initial_refcount) {\n+  return _impl->allocate(worker_id, src, dst, index, length, initial_refcount);\n+}\n+\n+void PartialArrayStateAllocator::release(uint worker_id, PartialArrayState* state) {\n+  _impl->release(worker_id, state);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.cpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYSTATE_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYSTATE_HPP\n+\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class PartialArrayStateAllocator;\n+\n+\/\/ Instances of this class are used to represent processing progress for an\n+\/\/ array task in a taskqueue.  When a sufficiently large array needs to be\n+\/\/ processed, such that it is desirable to split up the processing into\n+\/\/ parallelizable subtasks, a state object is allocated for the array.\n+\/\/ Multiple tasks referring to the state can then be added to the taskqueue\n+\/\/ for later processing, either by the current thread or by some other thread\n+\/\/ that steals one of those tasks.\n+\/\/\n+\/\/ Processing a state involves using the state to claim a segment of the\n+\/\/ array, and processing that segment.  Claiming is done by atomically\n+\/\/ incrementing the index, thereby claiming the segment from the old to new\n+\/\/ index values.  New tasks should also be added as needed to ensure the\n+\/\/ entire array will be processed.  A PartialArrayTaskStepper can be used to\n+\/\/ help with this.\n+\/\/\n+\/\/ States are allocated and released using a PartialArrayStateAllocator.\n+\/\/ States are reference counted to aid in that management.  Each task\n+\/\/ referring to a given state that is added to a taskqueue must increase the\n+\/\/ reference count by one.  When the processing of a task referring to a state\n+\/\/ is complete, the reference count must be decreased by one.  When the\n+\/\/ reference count reaches zero the state should be released to the allocator\n+\/\/ for later reuse.\n+class PartialArrayState {\n+  oop _source;\n+  oop _destination;\n+  size_t _length;\n+  volatile size_t _index;\n+  volatile size_t _refcount;\n+\n+  friend class PartialArrayStateAllocator;\n+\n+  PartialArrayState(oop src, oop dst,\n+                    size_t index, size_t length,\n+                    size_t initial_refcount);\n+  ~PartialArrayState() = default;\n+\n+  NONCOPYABLE(PartialArrayState);\n+\n+public:\n+  \/\/ Add count references, one per referring task being added to a taskqueue.\n+  void add_references(size_t count);\n+\n+  \/\/ The source array oop.\n+  oop source() const { return _source; }\n+\n+  \/\/ The destination array oop.  In some circumstances the source and\n+  \/\/ destination may be the same.\n+  oop destination() const { return _destination; }\n+\n+  \/\/ The length of the array oop.\n+  size_t length() const { return _length; }\n+\n+  \/\/ A pointer to the start index for the next segment to process, for atomic\n+  \/\/ update.\n+  volatile size_t* index_addr() { return &_index; }\n+};\n+\n+\/\/ This class provides memory management for PartialArrayStates.\n+\/\/\n+\/\/ States are initially allocated from a set of arenas owned by the allocator.\n+\/\/ This allows the entire set of allocated states to be discarded without the\n+\/\/ need to keep track of or find them under some circumstances.  For example,\n+\/\/ if G1 concurrent marking is aborted and needs to restart because of a full\n+\/\/ marking queue, the queue doesn't need to be searched for tasks referring to\n+\/\/ states to allow releasing them.  Instead the queue contents can just be\n+\/\/ discarded, and the memory for the no longer referenced states will\n+\/\/ eventually be reclaimed when the arenas are reset.\n+\/\/\n+\/\/ A set of free-lists is placed in front of the arena allocators.  This\n+\/\/ causes the maximum number of allocated states to be based on the number of\n+\/\/ in-progress arrays, rather than the total number of arrays that need to be\n+\/\/ processed.  The use of free-list allocators is the reason for reference\n+\/\/ counting states.\n+\/\/\n+\/\/ The arena and free-list to use for an allocation operation is designated by\n+\/\/ the worker_id used in the operation.  This avoids locking and such on those\n+\/\/ data structures, at the cost of possibly doing more total arena allocation\n+\/\/ that would be needed with a single shared arena and free-list.\n+class PartialArrayStateAllocator {\n+  class Impl;\n+  Impl* _impl;\n+\n+public:\n+  PartialArrayStateAllocator(uint num_workers);\n+  ~PartialArrayStateAllocator();\n+\n+  NONCOPYABLE(PartialArrayStateAllocator);\n+\n+  \/\/ Create a new state, obtaining the memory for it from the free-list or\n+  \/\/ arena associated with worker_id.\n+  PartialArrayState* allocate(uint worker_id,\n+                              oop src, oop dst,\n+                              size_t index, size_t length,\n+                              size_t initial_refcount);\n+\n+  \/\/ Decrement the state's refcount.  If the new refcount is zero, add the\n+  \/\/ state to the free-list associated with worker_id.  The state must have\n+  \/\/ been allocated by this allocator, but that allocation doesn't need to\n+  \/\/ have been associated with worker_id.\n+  void release(uint worker_id, PartialArrayState* state);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYSTATE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -51,1 +52,2 @@\n-PartialArrayTaskStepper::PartialArrayTaskStepper(uint n_workers) :\n+PartialArrayTaskStepper::PartialArrayTaskStepper(uint n_workers, size_t chunk_size) :\n+  _chunk_size(chunk_size),\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,3 @@\n-\/\/ Helper for handling PartialArrayTasks.\n+class PartialArrayState;\n+\n+\/\/ Helper for partial array chunking tasks.\n@@ -34,11 +36,4 @@\n-\/\/ processed in parallel.  Each task (implicitly) represents such a chunk.\n-\/\/ We can enqueue multiple tasks at the same time.  We want to enqueue\n-\/\/ enough tasks to benefit from the available parallelism, while not so many\n-\/\/ as to substantially expand the task queues.\n-\/\/\n-\/\/ A task directly refers to the from-space array.  The from-space array's\n-\/\/ forwarding pointer refers to the associated to-space array, and its\n-\/\/ length is the actual length. The to-space array's length field is used to\n-\/\/ indicate processing progress.  It is the starting index of the next chunk\n-\/\/ to process, or equals the actual length when there are no more chunks to\n-\/\/ be processed.\n+\/\/ processed in parallel.  Each task (implicitly) represents such a chunk.  We\n+\/\/ can enqueue multiple tasks at the same time.  We want to enqueue enough\n+\/\/ tasks to benefit from the available parallelism, while not so many as to\n+\/\/ substantially expand the task queues.\n@@ -47,1 +42,1 @@\n-  PartialArrayTaskStepper(uint n_workers);\n+  PartialArrayTaskStepper(uint n_workers, size_t chunk_size);\n@@ -50,1 +45,1 @@\n-    int _index;                 \/\/ Array index for the step.\n+    size_t _index;              \/\/ Array index for the step.\n@@ -54,5 +49,12 @@\n-  \/\/ Set to's length to the end of the initial chunk, which is the start of\n-  \/\/ the first partial task if the array is large enough to need splitting.\n-  \/\/ Returns a Step with _index being that index and _ncreate being the\n-  \/\/ initial number of partial tasks to enqueue.\n-  inline Step start(arrayOop from, arrayOop to, int chunk_size) const;\n+  \/\/ Called with the length of the array to be processed.  Returns a Step with\n+  \/\/ _index being the end of the initial chunk, which the caller should\n+  \/\/ process.  This is also the starting index for the next chunk to process.\n+  \/\/ The _ncreate is the number of tasks to enqueue to continue processing the\n+  \/\/ array.  If _ncreate is zero then _index will be length.\n+  inline Step start(size_t length) const;\n+\n+  \/\/ Atomically increment state's index by chunk_size() to claim the next\n+  \/\/ chunk.  Returns a Step with _index being the starting index of the\n+  \/\/ claimed chunk and _ncreate being the number of additional partial tasks\n+  \/\/ to enqueue.\n+  inline Step next(PartialArrayState* state) const;\n@@ -60,5 +62,2 @@\n-  \/\/ Increment to's length by chunk_size to claim the next chunk.  Returns a\n-  \/\/ Step with _index being the starting index of the claimed chunk and\n-  \/\/ _ncreate being the number of additional partial tasks to enqueue.\n-  \/\/ precondition: chunk_size must be the same as used to start the task sequence.\n-  inline Step next(arrayOop from, arrayOop to, int chunk_size) const;\n+  \/\/ The size of chunks to claim for each task.\n+  inline size_t chunk_size() const;\n@@ -69,0 +68,2 @@\n+  \/\/ Size (number of elements) of a chunk to process.\n+  size_t _chunk_size;\n@@ -74,6 +75,2 @@\n-  \/\/ Split start\/next into public part dealing with oops and private\n-  \/\/ impl dealing with lengths and pointers to lengths, for unit testing.\n-  \/\/ length is the actual length obtained from the from-space object.\n-  \/\/ to_length_addr is the address of the to-space object's length value.\n-  inline Step start_impl(int length, int* to_length_addr, int chunk_size) const;\n-  inline Step next_impl(int length, int* to_length_addr, int chunk_size) const;\n+  \/\/ For unit tests.\n+  inline Step next_impl(size_t length, volatile size_t* index_addr) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.hpp","additions":28,"deletions":31,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -29,2 +30,0 @@\n-\n-#include \"oops\/arrayOop.hpp\"\n@@ -32,0 +31,2 @@\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/debug.hpp\"\n@@ -33,17 +34,3 @@\n-PartialArrayTaskStepper::Step\n-PartialArrayTaskStepper::start_impl(int length,\n-                                    int* to_length_addr,\n-                                    int chunk_size) const {\n-  assert(chunk_size > 0, \"precondition\");\n-\n-  int end = length % chunk_size; \/\/ End of initial chunk.\n-  \/\/ Set to's length to end of initial chunk.  Partial tasks use that length\n-  \/\/ field as the start of the next chunk to process.  Must be done before\n-  \/\/ enqueuing partial scan tasks, in case other threads steal any of those\n-  \/\/ tasks.\n-  \/\/\n-  \/\/ The value of end can be 0, either because of a 0-length array or\n-  \/\/ because length is a multiple of the chunk size.  Both of those are\n-  \/\/ relatively rare and handled in the normal course of the iteration, so\n-  \/\/ not worth doing anything special about here.\n-  *to_length_addr = end;\n+size_t PartialArrayTaskStepper::chunk_size() const {\n+  return _chunk_size;\n+}\n@@ -51,0 +38,3 @@\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::start(size_t length) const {\n+  size_t end = length % _chunk_size; \/\/ End of initial chunk.\n@@ -54,2 +44,1 @@\n-  Step result = { end, (length > end) ? 1u : 0u };\n-  return result;\n+  return Step{ end, (length > end) ? 1u : 0u };\n@@ -59,11 +48,2 @@\n-PartialArrayTaskStepper::start(arrayOop from, arrayOop to, int chunk_size) const {\n-  return start_impl(from->length(), to->length_addr(), chunk_size);\n-}\n-\n-PartialArrayTaskStepper::Step\n-PartialArrayTaskStepper::next_impl(int length,\n-                                   int* to_length_addr,\n-                                   int chunk_size) const {\n-  assert(chunk_size > 0, \"precondition\");\n-\n-  \/\/ The start of the next task is in the length field of the to-space object.\n+PartialArrayTaskStepper::next_impl(size_t length, volatile size_t* index_addr) const {\n+  \/\/ The start of the next task is in the state's index.\n@@ -74,3 +54,3 @@\n-  int start = Atomic::fetch_then_add(to_length_addr,\n-                                     chunk_size,\n-                                     memory_order_relaxed);\n+  size_t start = Atomic::fetch_then_add(index_addr,\n+                                        _chunk_size,\n+                                        memory_order_relaxed);\n@@ -78,4 +58,4 @@\n-  assert(start < length, \"invariant: start %d, length %d\", start, length);\n-  assert(((length - start) % chunk_size) == 0,\n-         \"invariant: start %d, length %d, chunk size %d\",\n-         start, length, chunk_size);\n+  assert(start < length, \"invariant: start %zu, length %zu\", start, length);\n+  assert(((length - start) % _chunk_size) == 0,\n+         \"invariant: start %zu, length %zu, chunk size %zu\",\n+         start, length, _chunk_size);\n@@ -85,1 +65,1 @@\n-  uint task_num = (start \/ chunk_size);\n+  uint task_num = checked_cast<uint>(start \/ _chunk_size);\n@@ -87,1 +67,1 @@\n-  uint remaining_tasks = (length - start) \/ chunk_size;\n+  uint remaining_tasks = checked_cast<uint>((length - start) \/ _chunk_size);\n@@ -109,2 +89,1 @@\n-  Step result = { start, ncreate };\n-  return result;\n+  return Step{ start, ncreate };\n@@ -114,2 +93,2 @@\n-PartialArrayTaskStepper::next(arrayOop from, arrayOop to, int chunk_size) const {\n-  return next_impl(from->length(), to->length_addr(), chunk_size);\n+PartialArrayTaskStepper::next(PartialArrayState* state) const {\n+  return next_impl(state->length(), state->index_addr());\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.inline.hpp","additions":25,"deletions":46,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -579,0 +579,1 @@\n+\/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n@@ -589,1 +590,3 @@\n-\/\/ Discriminated union over oop*, narrowOop*, and PartialArrayScanTask.\n+class PartialArrayState;\n+\n+\/\/ Discriminated union over oop*, narrowOop*, and PartialArrayState.\n@@ -627,0 +630,1 @@\n+  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n@@ -630,0 +634,3 @@\n+  explicit ScannerTask(PartialArrayState* state) :\n+    _p(encode(state, PartialArrayTag)) {}\n+\n@@ -642,0 +649,1 @@\n+  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n@@ -646,0 +654,4 @@\n+  bool is_partial_array_state() const {\n+    return (raw_value() & PartialArrayTag) != 0;\n+  }\n+\n@@ -654,0 +666,1 @@\n+  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n@@ -657,0 +670,4 @@\n+\n+  PartialArrayState* to_partial_array_state() const {\n+    return static_cast<PartialArrayState*>(decode(PartialArrayTag));\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,7 +35,0 @@\n-  static Step start(const Stepper* stepper,\n-                    int length,\n-                    int* to_length_addr,\n-                    uint chunk_size) {\n-    return stepper->start_impl(length, to_length_addr, chunk_size);\n-  }\n-\n@@ -43,4 +36,3 @@\n-                   int length,\n-                   int* to_length_addr,\n-                   uint chunk_size) {\n-    return stepper->next_impl(length, to_length_addr, chunk_size);\n+                   size_t length,\n+                   size_t* to_length_addr) {\n+    return stepper->next_impl(length, to_length_addr);\n@@ -52,5 +44,5 @@\n-static int simulate(const Stepper* stepper,\n-                    int length,\n-                    int* to_length_addr,\n-                    uint chunk_size) {\n-  Step init = StepperSupport::start(stepper, length, to_length_addr, chunk_size);\n+static uint simulate(const Stepper* stepper,\n+                     size_t length,\n+                     size_t* to_length_addr) {\n+  Step init = stepper->start(length);\n+  *to_length_addr = init._index;\n@@ -58,1 +50,1 @@\n-  int task = 0;\n+  uint task = 0;\n@@ -61,1 +53,1 @@\n-    Step step = StepperSupport::next(stepper, length, to_length_addr, chunk_size);\n+    Step step = StepperSupport::next(stepper, length, to_length_addr);\n@@ -67,4 +59,4 @@\n-static void run_test(int length, int chunk_size, uint n_workers) {\n-  const PartialArrayTaskStepper stepper(n_workers);\n-  int to_length;\n-  int tasks = simulate(&stepper, length, &to_length, chunk_size);\n+static void run_test(size_t length, size_t chunk_size, uint n_workers) {\n+  const PartialArrayTaskStepper stepper(n_workers, chunk_size);\n+  size_t to_length;\n+  uint tasks = simulate(&stepper, length, &to_length);\n@@ -76,1 +68,1 @@\n-  for (int chunk_size = 50; chunk_size <= 500; chunk_size += 50) {\n+  for (size_t chunk_size = 50; chunk_size <= 500; chunk_size += 50) {\n@@ -78,1 +70,1 @@\n-      for (int length = 0; length <= 1000000; length = (length * 2 + 1)) {\n+      for (size_t length = 0; length <= 1000000; length = (length * 2 + 1)) {\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_partialArrayTaskStepper.cpp","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"}]}