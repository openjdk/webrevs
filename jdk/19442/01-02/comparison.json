{"files":[{"patch":"@@ -514,0 +514,10 @@\n+\/\/ Following routine generates IR corresponding to AbstractShuffle::partiallyWrapIndex method,\n+\/\/ which partially wraps index by modulo VEC_LENGTH and generates a negative index value if original\n+\/\/ index is out of valid index range [0, VEC_LENGTH)\n+\/\/\n+\/\/   wrapped_index = (VEC_LENGTH - 1) & index\n+\/\/   if (index u> VEC_LENGTH) {\n+\/\/     wrapped_index -= VEC_LENGTH;\n+\/\/\n+\/\/ Note: Unsigned greater than comparison treat both <0 and >VEC_LENGTH indices as out-of-bound\n+\/\/ indexes.\n@@ -516,2 +526,2 @@\n-  const TypeVect * vt  = TypeVect::make(elem_bt, num_elem);\n-  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n+  const TypeVect* vt  = TypeVect::make(elem_bt, num_elem);\n+  const Type* type_bt = Type::get_const_basic_type(elem_bt);\n@@ -620,1 +630,1 @@\n-     res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n+    res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n@@ -622,1 +632,1 @@\n-     res = partially_wrap_indexes(res, num_elem, elem_bt);\n+    res = partially_wrap_indexes(res, num_elem, elem_bt);\n@@ -2308,0 +2318,2 @@\n+    log_if_needed(\"  ** not supported: arity=1 op=shuffle_index_wrap vlen2=%d etype2=%s\",\n+                    num_elem_to, type2name(elem_bt_to));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"}]}