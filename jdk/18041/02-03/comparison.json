{"files":[{"patch":"@@ -1,191 +0,0 @@\n-#\n-# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-ifeq (,$(_MAKEBASE_GMK))\n-  $(error You must include MakeBase.gmk prior to including BaseUtils.gmk)\n-endif\n-\n-################################################################################\n-#\n-# Basic utility functions available to MakeBase.gmk itself\n-#\n-################################################################################\n-\n-# String equals\n-equals = \\\n-    $(if $(strip $1)$(strip $2),$(strip \\\n-      $(and $(findstring $(strip $1),$(strip $2)),\\\n-        $(findstring $(strip $2),$(strip $1)))), \\\n-      true \\\n-    )\n-\n-# Convert the string given to upper case, without any $(shell)\n-# Inspired by http:\/\/lists.gnu.org\/archive\/html\/help-make\/2013-09\/msg00009.html\n-uppercase_table := a,A b,B c,C d,D e,E f,F g,G h,H i,I j,J k,K l,L m,M n,N o,O \\\n-    p,P q,Q r,R s,S t,T u,U v,V w,W x,X y,Y z,Z\n-\n-uppercase_internal = \\\n-  $(if $(strip $1), $$(subst $(firstword $1), $(call uppercase_internal, \\\n-      $(wordlist 2, $(words $1), $1), $2)), $2)\n-\n-# Convert a string to upper case. Works only on a-z.\n-# $1 - The string to convert\n-uppercase = \\\n-  $(strip \\\n-    $(eval uppercase_result := $(call uppercase_internal, $(uppercase_table), $1)) \\\n-    $(uppercase_result) \\\n-  )\n-\n-################################################################################\n-# Creates a sequence of increasing numbers (inclusive).\n-# Param 1 - starting number\n-# Param 2 - ending number\n-sequence = \\\n-    $(wordlist $1, $2, $(strip \\\n-        $(eval SEQUENCE_COUNT :=) \\\n-        $(call _sequence-do,$(strip $2))))\n-\n-_sequence-do = \\\n-    $(if $(word $1, $(SEQUENCE_COUNT)),, \\\n-      $(eval SEQUENCE_COUNT += .) \\\n-      $(words $(SEQUENCE_COUNT)) \\\n-      $(call _sequence-do,$1))\n-\n-################################################################################\n-# This macro translates $ into \\$ to protect the $ from expansion in the shell.\n-# To make this macro resilient against already escaped strings, first remove\n-# any present escapes before escaping so that no double escapes are added.\n-EscapeDollar = $(subst $$,\\$$,$(subst \\$$,$$,$(strip $1)))\n-\n-################################################################################\n-# This macro works just like EscapeDollar above, but for #.\n-EscapeHash = $(subst \\#,\\\\\\#,$(subst \\\\\\#,\\#,$(strip $1)))\n-\n-################################################################################\n-# This macro translates $ into $$ to protect the string from make itself.\n-DoubleDollar = $(subst $$,$$$$,$(strip $1))\n-\n-################################################################################\n-# ShellQuote\n-#\n-# Quotes a string with single quotes and replaces single quotes with '\\'' so\n-# that the contents survives being given to the shell.\n-ShellQuote = \\\n-    $(SQUOTE)$(subst $(SQUOTE),$(SQUOTE)\\$(SQUOTE)$(SQUOTE),$(strip $1))$(SQUOTE)\n-\n-################################################################################\n-# Write to and read from file\n-\n-# Param 1 - File to read\n-ReadFile = \\\n-    $(shell $(CAT) $1)\n-\n-# Param 1 - Text to write\n-# Param 2 - File to write to\n-ifeq ($(HAS_FILE_FUNCTION), true)\n-  WriteFile = \\\n-      $(file >$2,$(strip $1))\n-else\n-  # Use printf to get consistent behavior on all platforms.\n-  WriteFile = \\\n-      $(shell $(PRINTF) \"%s\\n\" $(strip $(call ShellQuote, $1)) > $2)\n-endif\n-\n-# Param 1 - Text to write\n-# Param 2 - File to write to\n-ifeq ($(HAS_FILE_FUNCTION), true)\n-  AppendFile = \\\n-      $(file >>$2,$(strip $1))\n-else\n-  # Use printf to get consistent behavior on all platforms.\n-  AppendFile = \\\n-      $(shell $(PRINTF) \"%s\\n\" $(strip $(call ShellQuote, $1)) >> $2)\n-endif\n-\n-################################################################################\n-# Make directory without forking mkdir if not needed.\n-#\n-# If a directory with an encoded space is provided, the wildcard function\n-# sometimes returns false answers (typically if the dir existed when the\n-# makefile was parsed, but was deleted by a previous rule). In that case, always\n-# call mkdir regardless of what wildcard says.\n-#\n-# 1: List of directories to create\n-MakeDir = \\\n-    $(strip \\\n-        $(eval MakeDir_dirs_to_make := $(strip $(foreach d, $1, \\\n-          $(if $(findstring ?, $d), '$(call DecodeSpace, $d)', \\\n-            $(if $(wildcard $d), , $d) \\\n-          ) \\\n-        ))) \\\n-        $(if $(MakeDir_dirs_to_make), $(shell $(MKDIR) -p $(MakeDir_dirs_to_make))) \\\n-    )\n-\n-################################################################################\n-# Check if our build or target conforms to certain restrictions. This set of\n-# functions all work in similar ways, testing the property that the name\n-# implies, so e.g. isTargetCpu test the CPU of the target system.\n-#\n-# $1 - A property, or a space separated list of properties to test for.\n-#\n-# Returns true if the actual property matches one of the properties in the list,\n-# and false otherwise.\n-#\n-# Examples: $(call isTargetOs, linux windows) will return true when executed\n-# on either linux or windows, and false otherwise.\n-# $(call isBuildCpuArch, x86) will return true iff the build CPU Arch is x86.\n-\n-isTargetOs = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_OS), $1), true, false))\n-\n-isTargetOsType = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_OS_TYPE), $1), true, false))\n-\n-isTargetCpu = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_CPU), $1), true, false))\n-\n-isTargetCpuArch = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_ARCH), $1), true, false))\n-\n-isTargetCpuBits = \\\n-  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_BITS), $1), true, false))\n-\n-isBuildOs = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_OS), $1), true, false))\n-\n-isBuildOsType = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_OS_TYPE), $1), true, false))\n-\n-isBuildOsEnv = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_OS_ENV), $1), true, false))\n-\n-isBuildCpu = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_CPU), $1), true, false))\n-\n-isBuildCpuArch = \\\n-  $(strip $(if $(filter $(OPENJDK_BUILD_CPU_ARCH), $1), true, false))\n-\n-isCompiler = \\\n-  $(strip $(if $(filter $(TOOLCHAIN_TYPE), $1), true, false))\n","filename":"make\/common\/BaseUtils.gmk","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"},{"patch":"@@ -76,3 +76,0 @@\n-# Basic functionality for MakeBase and friends. Needs the make version defines.\n-include $(TOPDIR)\/make\/common\/BaseUtils.gmk\n-\n","filename":"make\/common\/MakeBase.gmk","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,163 @@\n+################################################################################\n+#\n+# Basic utility functions available to MakeBase.gmk itself\n+#\n+################################################################################\n+\n+# String equals\n+equals = \\\n+    $(if $(strip $1)$(strip $2),$(strip \\\n+      $(and $(findstring $(strip $1),$(strip $2)),\\\n+        $(findstring $(strip $2),$(strip $1)))), \\\n+      true \\\n+    )\n+\n+# Convert the string given to upper case, without any $(shell)\n+# Inspired by http:\/\/lists.gnu.org\/archive\/html\/help-make\/2013-09\/msg00009.html\n+uppercase_table := a,A b,B c,C d,D e,E f,F g,G h,H i,I j,J k,K l,L m,M n,N o,O \\\n+    p,P q,Q r,R s,S t,T u,U v,V w,W x,X y,Y z,Z\n+\n+uppercase_internal = \\\n+  $(if $(strip $1), $$(subst $(firstword $1), $(call uppercase_internal, \\\n+      $(wordlist 2, $(words $1), $1), $2)), $2)\n+\n+# Convert a string to upper case. Works only on a-z.\n+# $1 - The string to convert\n+uppercase = \\\n+  $(strip \\\n+    $(eval uppercase_result := $(call uppercase_internal, $(uppercase_table), $1)) \\\n+    $(uppercase_result) \\\n+  )\n+\n+################################################################################\n+# Creates a sequence of increasing numbers (inclusive).\n+# Param 1 - starting number\n+# Param 2 - ending number\n+sequence = \\\n+    $(wordlist $1, $2, $(strip \\\n+        $(eval SEQUENCE_COUNT :=) \\\n+        $(call _sequence-do,$(strip $2))))\n+\n+_sequence-do = \\\n+    $(if $(word $1, $(SEQUENCE_COUNT)),, \\\n+      $(eval SEQUENCE_COUNT += .) \\\n+      $(words $(SEQUENCE_COUNT)) \\\n+      $(call _sequence-do,$1))\n+\n+################################################################################\n+# This macro translates $ into \\$ to protect the $ from expansion in the shell.\n+# To make this macro resilient against already escaped strings, first remove\n+# any present escapes before escaping so that no double escapes are added.\n+EscapeDollar = $(subst $$,\\$$,$(subst \\$$,$$,$(strip $1)))\n+\n+################################################################################\n+# This macro works just like EscapeDollar above, but for #.\n+EscapeHash = $(subst \\#,\\\\\\#,$(subst \\\\\\#,\\#,$(strip $1)))\n+\n+################################################################################\n+# This macro translates $ into $$ to protect the string from make itself.\n+DoubleDollar = $(subst $$,$$$$,$(strip $1))\n+\n+################################################################################\n+# ShellQuote\n+#\n+# Quotes a string with single quotes and replaces single quotes with '\\'' so\n+# that the contents survives being given to the shell.\n+ShellQuote = \\\n+    $(SQUOTE)$(subst $(SQUOTE),$(SQUOTE)\\$(SQUOTE)$(SQUOTE),$(strip $1))$(SQUOTE)\n+\n+################################################################################\n+# Write to and read from file\n+\n+# Param 1 - File to read\n+ReadFile = \\\n+    $(shell $(CAT) $1)\n+\n+# Param 1 - Text to write\n+# Param 2 - File to write to\n+ifeq ($(HAS_FILE_FUNCTION), true)\n+  WriteFile = \\\n+      $(file >$2,$(strip $1))\n+else\n+  # Use printf to get consistent behavior on all platforms.\n+  WriteFile = \\\n+      $(shell $(PRINTF) \"%s\\n\" $(strip $(call ShellQuote, $1)) > $2)\n+endif\n+\n+# Param 1 - Text to write\n+# Param 2 - File to write to\n+ifeq ($(HAS_FILE_FUNCTION), true)\n+  AppendFile = \\\n+      $(file >>$2,$(strip $1))\n+else\n+  # Use printf to get consistent behavior on all platforms.\n+  AppendFile = \\\n+      $(shell $(PRINTF) \"%s\\n\" $(strip $(call ShellQuote, $1)) >> $2)\n+endif\n+\n+################################################################################\n+# Make directory without forking mkdir if not needed.\n+#\n+# If a directory with an encoded space is provided, the wildcard function\n+# sometimes returns false answers (typically if the dir existed when the\n+# makefile was parsed, but was deleted by a previous rule). In that case, always\n+# call mkdir regardless of what wildcard says.\n+#\n+# 1: List of directories to create\n+MakeDir = \\\n+    $(strip \\\n+        $(eval MakeDir_dirs_to_make := $(strip $(foreach d, $1, \\\n+          $(if $(findstring ?, $d), '$(call DecodeSpace, $d)', \\\n+            $(if $(wildcard $d), , $d) \\\n+          ) \\\n+        ))) \\\n+        $(if $(MakeDir_dirs_to_make), $(shell $(MKDIR) -p $(MakeDir_dirs_to_make))) \\\n+    )\n+\n+################################################################################\n+# Check if our build or target conforms to certain restrictions. This set of\n+# functions all work in similar ways, testing the property that the name\n+# implies, so e.g. isTargetCpu test the CPU of the target system.\n+#\n+# $1 - A property, or a space separated list of properties to test for.\n+#\n+# Returns true if the actual property matches one of the properties in the list,\n+# and false otherwise.\n+#\n+# Examples: $(call isTargetOs, linux windows) will return true when executed\n+# on either linux or windows, and false otherwise.\n+# $(call isBuildCpuArch, x86) will return true iff the build CPU Arch is x86.\n+\n+isTargetOs = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_OS), $1), true, false))\n+\n+isTargetOsType = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_OS_TYPE), $1), true, false))\n+\n+isTargetCpu = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_CPU), $1), true, false))\n+\n+isTargetCpuArch = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_ARCH), $1), true, false))\n+\n+isTargetCpuBits = \\\n+  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_BITS), $1), true, false))\n+\n+isBuildOs = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_OS), $1), true, false))\n+\n+isBuildOsType = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_OS_TYPE), $1), true, false))\n+\n+isBuildOsEnv = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_OS_ENV), $1), true, false))\n+\n+isBuildCpu = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_CPU), $1), true, false))\n+\n+isBuildCpuArch = \\\n+  $(strip $(if $(filter $(OPENJDK_BUILD_CPU_ARCH), $1), true, false))\n+\n+isCompiler = \\\n+  $(strip $(if $(filter $(TOOLCHAIN_TYPE), $1), true, false))\n+\n","filename":"make\/common\/Utils.gmk","additions":163,"deletions":0,"binary":false,"changes":163,"status":"modified"}]}