{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.Annotation;\n@@ -49,0 +50,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -50,0 +52,1 @@\n+import sun.security.action.GetIntegerAction;\n@@ -53,0 +56,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -80,0 +84,2 @@\n+    private static final int SCOPE_DEDUP_DEPTH\n+            = GetIntegerAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.SCOPE_DEDUP_DEPTH\", 2);\n@@ -102,0 +108,1 @@\n+    private static final ClassDesc CD_ForceInline = referenceClassDesc(ForceInline.class);\n@@ -199,2 +206,3 @@\n-               .withMethodBody(METHOD_NAME, methodTypeDesc(callerMethodType), ACC_PUBLIC | ACC_STATIC,\n-                    cb -> new BindingSpecializer(cb, callerMethodType, callingSequence, abi, leafType).specialize());\n+               .withMethod(METHOD_NAME, methodTypeDesc(callerMethodType), ACC_PUBLIC | ACC_STATIC,\n+                    mb -> mb.with(RuntimeVisibleAnnotationsAttribute.of(Annotation.of(CD_ForceInline)))\n+                            .withCode(cb -> new BindingSpecializer(cb, callerMethodType, callingSequence, abi, leafType).specialize()));\n@@ -505,2 +513,9 @@\n-        boolean hasOtherScopes = curScopeLocalIdx != 0;\n-        for (int i = 0; i < curScopeLocalIdx; i++) {\n+        boolean hasLookup = false;\n+\n+        \/\/ Here we check if the current scope has not been already acquired.\n+        \/\/ To do that, we generate many comparisons (one per cached scope).\n+        \/\/ Note that we always skip comparisons against the very first cached scope\n+        \/\/ (as that is the function address, which typically belongs to another scope).\n+        \/\/ We also stop the comparisons at SCOPE_DEDUP_DEPTH, to keep a lid on the size\n+        \/\/ of the generated code.\n+        for (int i = 1; i < curScopeLocalIdx && i <= SCOPE_DEDUP_DEPTH; i++) {\n@@ -510,0 +525,1 @@\n+            hasLookup = true;\n@@ -519,1 +535,1 @@\n-        if (hasOtherScopes) { \/\/ avoid ASM generating a bunch of nops for the dead code\n+        if (hasLookup) { \/\/ avoid ASM generating a bunch of nops for the dead code\n@@ -521,2 +537,2 @@\n-              .labelBinding(skipAcquire)\n-              .pop(); \/\/ drop scope\n+                    .labelBinding(skipAcquire)\n+                    .pop(); \/\/ drop scope\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,247 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n+public class CallByRefHighArity {\n+\n+    static {\n+        System.loadLibrary(\"CallByRefHighArity\");\n+    }\n+\n+    @Param\n+    SegmentKind kind;\n+\n+    public enum SegmentKind {\n+        CONFINED,\n+        SHARED,\n+        GLOBAL,\n+        HEAP\n+    }\n+\n+    Supplier<MemorySegment> segmentSupplier;\n+    Arena arena;\n+\n+    @Setup\n+    public void setup() {\n+        if (kind == SegmentKind.CONFINED) {\n+            arena = Arena.ofConfined();\n+            MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_INT, 0);\n+            segmentSupplier = () -> segment;\n+        } else if (kind == SegmentKind.SHARED) {\n+            arena = Arena.ofShared();\n+            MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_INT, 0);\n+            segmentSupplier = () -> segment;\n+        } else if (kind == SegmentKind.HEAP) {\n+            byte[] array = new byte[8];\n+            MemorySegment segment = MemorySegment.ofArray(array);\n+            segmentSupplier = () -> segment;\n+        } else { \/\/ global\n+            segmentSupplier = () -> MemorySegment.ofAddress(0);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        if (arena != null) {\n+            arena.close();\n+        }\n+    }\n+\n+    \/\/ A shared library that exports the functions below\n+    private static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n+\n+    \/\/ void noop_params0() {}\n+    private static final MethodHandle MH_NOOP_PARAMS0 = Linker.nativeLinker()\n+            .downcallHandle(FunctionDescriptor.ofVoid(), Linker.Option.critical(true))\n+            .bindTo(LOOKUP.find(\"noop_params0\").orElseThrow());\n+\n+    \/\/ void noop_params1(void *param0) {}\n+    private static final MethodHandle MH_NOOP_PARAMS1 = Linker.nativeLinker()\n+            .downcallHandle(FunctionDescriptor.ofVoid(\n+                    ValueLayout.ADDRESS\n+            ), Linker.Option.critical(true))\n+            .bindTo(LOOKUP.find(\"noop_params1\").orElseThrow());\n+\n+    \/\/ void noop_params2(void *param0, void *param1) {}\n+    private static final MethodHandle MH_NOOP_PARAMS2 = Linker.nativeLinker()\n+            .downcallHandle(FunctionDescriptor.ofVoid(\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS\n+            ), Linker.Option.critical(true))\n+            .bindTo(LOOKUP.find(\"noop_params2\").orElseThrow());\n+\n+    \/\/ void noop_params3(void *param0, void *param1, void *param2) {}\n+    private static final MethodHandle MH_NOOP_PARAMS3 = Linker.nativeLinker()\n+            .downcallHandle(FunctionDescriptor.ofVoid(\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS\n+            ), Linker.Option.critical(true))\n+            .bindTo(LOOKUP.find(\"noop_params3\").orElseThrow());\n+\n+    \/\/ void noop_params4(void *param0, void *param1, void *param2, void *param3) {}\n+    private static final MethodHandle MH_NOOP_PARAMS4 = Linker.nativeLinker()\n+            .downcallHandle(FunctionDescriptor.ofVoid(\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS\n+            ), Linker.Option.critical(true))\n+            .bindTo(LOOKUP.find(\"noop_params4\").orElseThrow());\n+\n+    \/\/ void noop_params5(int param0, int param1, void *param2, void *param3, void *param4) {}\n+    private static final MethodHandle MH_NOOP_PARAMS5 = Linker.nativeLinker()\n+            .downcallHandle(FunctionDescriptor.ofVoid(\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS\n+            ), Linker.Option.critical(true))\n+            .bindTo(LOOKUP.find(\"noop_params5\").orElseThrow());\n+\n+    \/\/ void noop_params10(int param0, int param1, void *param2, void *param3, void *param4,\n+    \/\/                    int param5, int param6, void *param7, void *param8, void *param9) {}\n+    private static final MethodHandle MH_NOOP_PARAMS10 = Linker.nativeLinker()\n+            .downcallHandle(FunctionDescriptor.ofVoid(\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS,\n+                    ValueLayout.ADDRESS\n+            ), Linker.Option.critical(true))\n+            .bindTo(LOOKUP.find(\"noop_params10\").orElseThrow());\n+\n+    @Benchmark\n+    public void noop_params0() {\n+        try {\n+            MH_NOOP_PARAMS0.invokeExact();\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void noop_params1() {\n+        try {\n+            MH_NOOP_PARAMS1.invokeExact(\n+                    segmentSupplier.get()\n+            );\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void noop_params2() {\n+        try {\n+            MH_NOOP_PARAMS2.invokeExact(\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get()\n+            );\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void noop_params3() {\n+        try {\n+            MH_NOOP_PARAMS3.invokeExact(\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get()\n+            );\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void noop_params4() {\n+        try {\n+            MH_NOOP_PARAMS4.invokeExact(\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get()\n+            );\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void noop_params5() {\n+        try {\n+            MH_NOOP_PARAMS5.invokeExact(\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get()\n+            );\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void noop_params10() {\n+        try {\n+            MH_NOOP_PARAMS10.invokeExact(\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get(),\n+                    segmentSupplier.get()\n+            );\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallByRefHighArity.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+EXPORT void noop_params0() {}\n+EXPORT void noop_params1(void *param0) {}\n+EXPORT void noop_params2(void *param0, void *param1) {}\n+EXPORT void noop_params3(void *param0, void *param1, void *param2) {}\n+EXPORT void noop_params4(void *param0, void *param1, void *param2, void *param3) {}\n+EXPORT void noop_params5(int param0, int param1, void *param2, void *param3, void *param4) {}\n+EXPORT void noop_params10(int param0, int param1, void *param2, void *param3, void *param4,\n+                          int param5, int param6, void *param7, void *param8, void *param9) {}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallByRefHighArity.c","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"}]}