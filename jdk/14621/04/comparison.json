{"files":[{"patch":"@@ -27,1 +27,1 @@\n- * @summary Test standard charset name constants.\n+ * @summary Test standard charset name constants and class qualities.\n@@ -29,1 +29,1 @@\n- * @run main Standard\n+ * @run junit Standard\n@@ -34,2 +34,2 @@\n-import java.io.*;\n-import java.nio.charset.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n@@ -37,2 +37,10 @@\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -42,4 +50,5 @@\n-    private final static String standardCharsets[] = {\n-        \"US-ASCII\", \"ISO-8859-1\", \"UTF-8\",\n-        \"UTF-16BE\", \"UTF-16LE\", \"UTF-16\",\n-        \"UTF-32BE\", \"UTF-32LE\", \"UTF-32\",\n+    \/\/ These are the charsets StandardCharsets.java is expected to contain.\n+    private static final String[] expectedCharsets = {\n+            \"US-ASCII\", \"ISO-8859-1\", \"UTF-8\",\n+            \"UTF-16BE\", \"UTF-16LE\", \"UTF-16\",\n+            \"UTF-32BE\", \"UTF-32LE\", \"UTF-32\"\n@@ -48,10 +57,2 @@\n-    public static void realMain(String[] args) {\n-        check(StandardCharsets.US_ASCII instanceof Charset);\n-        check(StandardCharsets.ISO_8859_1 instanceof Charset);\n-        check(StandardCharsets.UTF_8 instanceof Charset);\n-        check(StandardCharsets.UTF_16BE instanceof Charset);\n-        check(StandardCharsets.UTF_16LE instanceof Charset);\n-        check(StandardCharsets.UTF_16 instanceof Charset);\n-        check(StandardCharsets.UTF_32BE instanceof Charset);\n-        check(StandardCharsets.UTF_32LE instanceof Charset);\n-        check(StandardCharsets.UTF_32 instanceof Charset);\n+    private static final Field[] standardCharsetFields =\n+            StandardCharsets.class.getFields();\n@@ -59,9 +60,20 @@\n-        check(\"US-ASCII\".equals(StandardCharsets.US_ASCII.name()));\n-        check(\"ISO-8859-1\".equals(StandardCharsets.ISO_8859_1.name()));\n-        check(\"UTF-8\".equals(StandardCharsets.UTF_8.name()));\n-        check(\"UTF-16BE\".equals(StandardCharsets.UTF_16BE.name()));\n-        check(\"UTF-16LE\".equals(StandardCharsets.UTF_16LE.name()));\n-        check(\"UTF-16\".equals(StandardCharsets.UTF_16.name()));\n-        check(\"UTF-32BE\".equals(StandardCharsets.UTF_32BE.name()));\n-        check(\"UTF-32LE\".equals(StandardCharsets.UTF_32LE.name()));\n-        check(\"UTF-32\".equals(StandardCharsets.UTF_32.name()));\n+    \/**\n+     * Validates that the Charset constants from the data provider\n+     * are of type Charset.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetProvider\")\n+    public void typeTest(Charset charset) {\n+        \/\/ Doubly checked, as it is validated when passed as a param\n+        assertTrue(charset instanceof Charset);\n+    }\n+\n+    \/**\n+     * Validates that calling .name() on a Charset constant is equal\n+     * to the matching String value from the data provider.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetProvider\")\n+    public void nameMethodTest(Charset charset, String charString) {\n+        assertEquals(charset.name(), charString);\n+    }\n@@ -69,9 +81,9 @@\n-        check(Charset.forName(\"US-ASCII\") == StandardCharsets.US_ASCII);\n-        check(Charset.forName(\"ISO-8859-1\") == StandardCharsets.ISO_8859_1);\n-        check(Charset.forName(\"UTF-8\") == StandardCharsets.UTF_8);\n-        check(Charset.forName(\"UTF-16BE\") == StandardCharsets.UTF_16BE);\n-        check(Charset.forName(\"UTF-16LE\") == StandardCharsets.UTF_16LE);\n-        check(Charset.forName(\"UTF-16\") == StandardCharsets.UTF_16);\n-        check(Charset.forName(\"UTF-32BE\") == StandardCharsets.UTF_32BE);\n-        check(Charset.forName(\"UTF-32LE\") == StandardCharsets.UTF_32LE);\n-        check(Charset.forName(\"UTF-32\") == StandardCharsets.UTF_32);\n+    \/**\n+     * Validates that calling Charset.forName() on a String is equal\n+     * to the matching Charset constant from the data provider.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetProvider\")\n+    public void forNameMethodTest(Charset charset, String charString) {\n+        assertEquals(Charset.forName(charString), charset);\n+    }\n@@ -79,2 +91,17 @@\n-        Set<String> charsets = new HashSet<>();\n-        Field standardCharsetFields[] = StandardCharsets.class.getFields();\n+    \/**\n+     * Validates the qualities of a StandardCharsets field are as expected:\n+     * The field is final, static, public, and one can access\n+     * the underlying value of the field.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetFields\")\n+    public void charsetModifiersTest(Field charsetField) throws IllegalAccessException {\n+        \/\/ Check modifiers\n+        assertEquals(StandardCharsets.class, charsetField.getDeclaringClass());\n+        assertTrue(Modifier.isFinal(charsetField.getModifiers()));\n+        assertTrue(Modifier.isStatic(charsetField.getModifiers()));\n+        assertTrue(Modifier.isPublic(charsetField.getModifiers()));\n+        \/\/ Check that the value can be accessed, and it is a Charset\n+        Object valueOfField = charsetField.get(null);\n+        assertTrue(valueOfField instanceof Charset);\n+    }\n@@ -82,6 +109,10 @@\n-        for(Field charsetField : standardCharsetFields) {\n-            check(StandardCharsets.class == charsetField.getDeclaringClass());\n-            check(Modifier.isFinal(charsetField.getModifiers()));\n-            check(Modifier.isStatic(charsetField.getModifiers()));\n-            check(Modifier.isPublic(charsetField.getModifiers()));\n-            Object value;\n+    \/**\n+     * Validates that the Charsets contained in StandardCharsets are equal\n+     * to the expected Charsets list defined in the test. This test should fail if\n+     * either the actual or expected (standard) Charsets are modified, and\n+     * the others are not.\n+     *\/\n+    @Test\n+    public void correctCharsetsTest() {\n+        \/\/ Grab the value from each Standard Charset field\n+        List<String> actualCharsets = charsetFields().map(field -> {\n@@ -89,4 +120,3 @@\n-                value = charsetField.get(null);\n-            } catch(IllegalAccessException failure) {\n-                unexpected(failure);\n-                continue;\n+                return ((Charset) field.get(null)).name();\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Can not test correctCharsetsTest() due to %s\", e);\n@@ -94,7 +124,2 @@\n-            check(value instanceof Charset);\n-            charsets.add(((Charset)value).name());\n-        }\n-\n-        check(charsets.containsAll(Arrays.asList(standardCharsets)));\n-        charsets.removeAll(Arrays.asList(standardCharsets));\n-        check(charsets.isEmpty());\n+        }).toList();\n+        assertEquals(actualCharsets, Arrays.asList(expectedCharsets));\n@@ -103,16 +128,16 @@\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() { passed++; }\n-    static void fail() { failed++; Thread.dumpStack(); }\n-    static void fail(String msg) { System.out.println(msg); fail(); }\n-    static void unexpected(Throwable t) { failed++; t.printStackTrace(); }\n-    static void check(boolean cond) { if (cond) pass(); else fail(); }\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else {System.out.println(x + \" not equal to \" + y); fail();}}\n-    static void equal2(Object x, Object y) {equal(x, y); equal(y, x);}\n-    public static void main(String[] args) throws Throwable {\n-        try { realMain(args); } catch (Throwable t) { unexpected(t); }\n-\n-        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n-        if (failed > 0) throw new Exception(\"Some tests failed\");\n+    \/**\n+     * Provides the constant Charset and associated String value of\n+     * the standard charsets.\n+     *\/\n+    private static Stream<Arguments> charsetProvider() {\n+        return Stream.of(\n+                Arguments.of(StandardCharsets.US_ASCII, \"US-ASCII\"),\n+                Arguments.of(StandardCharsets.ISO_8859_1, \"ISO-8859-1\"),\n+                Arguments.of(StandardCharsets.UTF_8, \"UTF-8\"),\n+                Arguments.of(StandardCharsets.UTF_16BE, \"UTF-16BE\"),\n+                Arguments.of(StandardCharsets.UTF_16LE, \"UTF-16LE\"),\n+                Arguments.of(StandardCharsets.UTF_16, \"UTF-16\"),\n+                Arguments.of(StandardCharsets.UTF_32BE, \"UTF-32BE\"),\n+                Arguments.of(StandardCharsets.UTF_32LE, \"UTF-32LE\"),\n+                Arguments.of(StandardCharsets.UTF_32, \"UTF-32\")\n+        );\n@@ -120,14 +145,0 @@\n-    static byte[] serializedForm(Object obj) {\n-        try {\n-            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            new ObjectOutputStream(baos).writeObject(obj);\n-            return baos.toByteArray();\n-        } catch (IOException e) { throw new Error(e); }}\n-    static Object readObject(byte[] bytes)\n-        throws IOException, ClassNotFoundException {\n-        InputStream is = new ByteArrayInputStream(bytes);\n-        return new ObjectInputStream(is).readObject();}\n-    @SuppressWarnings(\"unchecked\")\n-    static <T> T serialClone(T obj) {\n-        try { return (T) readObject(serializedForm(obj)); }\n-        catch (Exception e) { throw new Error(e); }}\n@@ -135,0 +146,3 @@\n+    private static Stream<Field> charsetFields() {\n+        return Arrays.stream(standardCharsetFields);\n+    }\n","filename":"test\/jdk\/java\/nio\/charset\/StandardCharsets\/Standard.java","additions":101,"deletions":87,"binary":false,"changes":188,"status":"modified"}]}