{"files":[{"patch":"@@ -215,5 +215,0 @@\n-\n-void NativeJump::check_verified_entry_alignment(address entry, address verified_entry) {\n-}\n-\n-\n@@ -362,25 +357,0 @@\n-\/\/ MT-safe inserting of a jump over a jump or a nop (used by\n-\/\/ nmethod::make_not_entrant)\n-\n-void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n-\n-  assert(dest == SharedRuntime::get_handle_wrong_method_stub(), \"expected fixed destination of patch\");\n-  assert(nativeInstruction_at(verified_entry)->is_jump_or_nop()\n-         || nativeInstruction_at(verified_entry)->is_sigill_not_entrant(),\n-         \"Aarch64 cannot replace non-jump with jump\");\n-\n-  \/\/ Patch this nmethod atomically.\n-  if (Assembler::reachable_from_branch_at(verified_entry, dest)) {\n-    ptrdiff_t disp = dest - verified_entry;\n-    guarantee(disp < 1 << 27 && disp > - (1 << 27), \"branch overflow\");\n-\n-    unsigned int insn = (0b000101 << 26) | ((disp >> 2) & 0x3ffffff);\n-    *(unsigned int*)verified_entry = insn;\n-  } else {\n-    \/\/ We use an illegal instruction for marking a method as not_entrant.\n-    NativeIllegalInstruction::insert(verified_entry);\n-  }\n-\n-  ICache::invalidate_range(verified_entry, instruction_size);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -363,3 +363,0 @@\n-  \/\/ MT-safe insertion of native jump at verified method entry\n-  static void check_verified_entry_alignment(address entry, address verified_entry);\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -285,10 +285,0 @@\n-void RawNativeJump::check_verified_entry_alignment(address entry, address verified_entry) {\n-}\n-\n-void RawNativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n-  assert(dest == SharedRuntime::get_handle_wrong_method_stub(), \"should be\");\n-  int *a = (int *)verified_entry;\n-  a[0] = not_entrant_illegal_instruction; \/\/ always illegal\n-  ICache::invalidate_range((address)&a[0], sizeof a[0]);\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,4 +64,0 @@\n-  \/\/ illegal instruction used by NativeJump::patch_verified_entry\n-  \/\/ permanently undefined (UDF): 0xe << 28 | 0b1111111 << 20 | 0b1111 << 4\n-  static const int not_entrant_illegal_instruction = 0xe7f000f0;\n-\n@@ -277,4 +273,0 @@\n-  static void check_verified_entry_alignment(address entry, address verified_entry);\n-\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n-\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  \/\/ Avoid stack bang as first instruction. It may get overwritten by patch_verified_entry.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,12 +42,0 @@\n-\/\/ We use an illtrap for marking a method as not_entrant\n-\/\/ Work around a C++ compiler bug which changes 'this'\n-bool NativeInstruction::is_sigill_not_entrant_at(address addr) {\n-  if (!Assembler::is_illtrap(addr)) return false;\n-  CodeBlob* cb = CodeCache::find_blob(addr);\n-  if (cb == nullptr || !cb->is_nmethod()) return false;\n-  nmethod *nm = (nmethod *)cb;\n-  \/\/ This method is not_entrant iff the illtrap instruction is\n-  \/\/ located at the verified entry point.\n-  return nm->verified_entry_point() == addr;\n-}\n-\n@@ -334,19 +322,0 @@\n-void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n-  ResourceMark rm;\n-  int code_size = 1 * BytesPerInstWord;\n-  CodeBuffer cb(verified_entry, code_size + 1);\n-  MacroAssembler* a = new MacroAssembler(&cb);\n-#ifdef COMPILER2\n-  assert(dest == SharedRuntime::get_handle_wrong_method_stub(), \"expected fixed destination of patch\");\n-#endif\n-  \/\/ Patch this nmethod atomically. Always use illtrap\/trap in debug build.\n-  if (DEBUG_ONLY(false &&) a->is_within_range_of_b(dest, a->pc())) {\n-    a->b(dest);\n-  } else {\n-    \/\/ The signal handler will continue at dest=OptoRuntime::handle_wrong_method_stub().\n-    \/\/ We use an illtrap for marking a method as not_entrant.\n-    a->illtrap();\n-  }\n-  ICache::ppc64_flush_icache_bytes(verified_entry, code_size);\n-}\n-\n@@ -465,3 +434,1 @@\n-  nmethod *nm = (nmethod *)cb;\n-  \/\/ see NativeInstruction::is_sigill_not_entrant_at()\n-  return nm->verified_entry_point() != code_pos;\n+  return true;\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":1,"deletions":34,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,3 +331,0 @@\n-  \/\/ MT-safe insertion of native jump at verified method entry\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n-\n@@ -335,5 +332,0 @@\n-\n-  static void check_verified_entry_alignment(address entry, address verified_entry) {\n-    \/\/ We just patch one instruction on ppc64, so the jump doesn't have to\n-    \/\/ be aligned. Nothing to do here.\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -359,12 +359,0 @@\n-\n-void NativeJump::check_verified_entry_alignment(address entry, address verified_entry) {\n-  \/\/ Patching to not_entrant can happen while activations of the method are\n-  \/\/ in use. The patching in that instance must happen only when certain\n-  \/\/ alignment restrictions are true. These guarantees check those\n-  \/\/ conditions.\n-\n-  \/\/ Must be 4 bytes aligned\n-  MacroAssembler::assert_alignment(verified_entry);\n-}\n-\n-\n@@ -439,39 +427,0 @@\n-\n-\/\/ MT-safe inserting of a jump over a jump or a nop (used by\n-\/\/ nmethod::make_not_entrant)\n-\n-void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n-\n-  assert(dest == SharedRuntime::get_handle_wrong_method_stub(), \"expected fixed destination of patch\");\n-\n-  assert(nativeInstruction_at(verified_entry)->is_jump_or_nop() ||\n-         nativeInstruction_at(verified_entry)->is_sigill_not_entrant(),\n-         \"riscv cannot replace non-jump with jump\");\n-\n-  check_verified_entry_alignment(entry, verified_entry);\n-\n-  \/\/ Patch this nmethod atomically.\n-  if (Assembler::reachable_from_branch_at(verified_entry, dest)) {\n-    ptrdiff_t offset = dest - verified_entry;\n-    guarantee(Assembler::is_simm21(offset) && ((offset % 2) == 0),\n-              \"offset is too large to be patched in one jal instruction.\"); \/\/ 1M\n-\n-    uint32_t insn = 0;\n-    address pInsn = (address)&insn;\n-    Assembler::patch(pInsn, 31, 31, (offset >> 20) & 0x1);\n-    Assembler::patch(pInsn, 30, 21, (offset >> 1) & 0x3ff);\n-    Assembler::patch(pInsn, 20, 20, (offset >> 11) & 0x1);\n-    Assembler::patch(pInsn, 19, 12, (offset >> 12) & 0xff);\n-    Assembler::patch(pInsn, 11, 7, 0); \/\/ zero, no link jump\n-    Assembler::patch(pInsn, 6, 0, 0b1101111); \/\/ j, (jal x0 offset)\n-    Assembler::sd_instr(verified_entry, insn);\n-  } else {\n-    \/\/ We use an illegal instruction for marking a method as\n-    \/\/ not_entrant.\n-    NativeIllegalInstruction::insert(verified_entry);\n-  }\n-\n-  ICache::invalidate_range(verified_entry, instruction_size);\n-}\n-\n-\/\/-------------------------------------------------------------------\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,3 +277,0 @@\n-  \/\/ MT-safe insertion of native jump at verified method entry\n-  static void check_verified_entry_alignment(address entry, address verified_entry);\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1799,1 +1799,0 @@\n-  \/\/ Verified entry point must be properly 4 bytes aligned for patching by NativeJump::patch_verified_entry().\n@@ -8194,1 +8193,1 @@\n-  \n+ \n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,21 +170,0 @@\n-\/\/ We use an illtrap for marking a method as not_entrant.\n-bool NativeInstruction::is_sigill_not_entrant() {\n-  if (!is_illegal()) return false; \/\/ Just a quick path.\n-\n-  \/\/ One-sided error of is_illegal tolerable here\n-  \/\/ (see implementation of is_illegal() for details).\n-\n-  CodeBlob* cb = CodeCache::find_blob(addr_at(0));\n-  if (cb == nullptr || !cb->is_nmethod()) {\n-    return false;\n-  }\n-\n-  nmethod *nm = (nmethod *)cb;\n-  \/\/ This method is not_entrant if the illtrap instruction\n-  \/\/ is located at the verified entry point.\n-  \/\/ BE AWARE: the current pc (this) points to the instruction after the\n-  \/\/ \"illtrap\" location.\n-  address sig_addr = ((address) this) - 2;\n-  return nm->verified_entry_point() == sig_addr;\n-}\n-\n@@ -623,13 +602,0 @@\n-\/\/ Patch atomically with an illtrap.\n-void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {\n-  ResourceMark rm;\n-  int code_size = 2;\n-  CodeBuffer cb(verified_entry, code_size + 1);\n-  MacroAssembler* a = new MacroAssembler(&cb);\n-#ifdef COMPILER2\n-  assert(dest == SharedRuntime::get_handle_wrong_method_stub(), \"expected fixed destination of patch\");\n-#endif\n-  a->z_illtrap();\n-  ICache::invalidate_range(verified_entry, code_size);\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.cpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -612,5 +612,0 @@\n-\n-  \/\/ MT-safe insertion of native jump at verified method entry.\n-  static void check_verified_entry_alignment(address entry, address verified_entry) { }\n-\n-  static void patch_verified_entry(address entry, address verified_entry, address dest);\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright 2008 Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"entry_zero.hpp\"\n-#include \"interpreter\/zero\/zeroInterpreter.hpp\"\n-#include \"nativeInst_zero.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-\/\/ This method is called by nmethod::make_not_entrant to\n-\/\/ insert a jump to SharedRuntime::get_handle_wrong_method_stub()\n-\/\/ (dest) at the start of a compiled method (verified_entry) to avoid\n-\/\/ a race where a method is invoked while being made non-entrant.\n-\n-void NativeJump::patch_verified_entry(address entry,\n-                                      address verified_entry,\n-                                      address dest) {\n-  assert(dest == SharedRuntime::get_handle_wrong_method_stub(), \"should be\");\n-\n-  ((ZeroEntry*) verified_entry)->set_entry_point(\n-    (address) ZeroInterpreter::normal_entry);\n-}\n","filename":"src\/hotspot\/cpu\/zero\/nativeInst_zero.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,8 +180,0 @@\n-\n-  static void check_verified_entry_alignment(address entry,\n-                                             address verified_entry) {\n-  }\n-\n-  static void patch_verified_entry(address entry,\n-                                   address verified_entry,\n-                                   address dest);\n","filename":"src\/hotspot\/cpu\/zero\/nativeInst_zero.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2755,13 +2755,0 @@\n-#ifdef _M_ARM64\n-    if (in_java &&\n-        (exception_code == EXCEPTION_ILLEGAL_INSTRUCTION ||\n-          exception_code == EXCEPTION_ILLEGAL_INSTRUCTION_2)) {\n-      if (nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n-        if (TraceTraps) {\n-          tty->print_cr(\"trap: not_entrant\");\n-        }\n-        return Handle_Exception(exceptionInfo, SharedRuntime::get_handle_wrong_method_stub());\n-      }\n-    }\n-#endif\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -232,10 +232,1 @@\n-      \/\/ Handle signal from NativeJump::patch_verified_entry().\n-      if (sig == SIGILL && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n-        if (TraceTraps) {\n-          tty->print_cr(\"trap: not_entrant\");\n-        }\n-        stub = SharedRuntime::get_handle_wrong_method_stub();\n-        goto run_stub;\n-      }\n-\n-      else if ((sig == (USE_POLL_BIT_ONLY ? SIGTRAP : SIGSEGV)) &&\n+      if ((sig == (USE_POLL_BIT_ONLY ? SIGTRAP : SIGSEGV)) &&\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -274,8 +274,1 @@\n-      \/\/ Handle signal from NativeJump::patch_verified_entry().\n-      if ((sig == SIGILL)\n-          && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n-        if (TraceTraps) {\n-          tty->print_cr(\"trap: not_entrant\");\n-        }\n-        stub = SharedRuntime::get_handle_wrong_method_stub();\n-      } else if ((sig == SIGSEGV || sig == SIGBUS) && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n+      if ((sig == SIGSEGV || sig == SIGBUS) && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -235,8 +235,1 @@\n-      \/\/ Handle signal from NativeJump::patch_verified_entry().\n-      if ((sig == SIGILL || sig == SIGTRAP)\n-          && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n-        if (TraceTraps) {\n-          tty->print_cr(\"trap: not_entrant (%s)\", (sig == SIGTRAP) ? \"SIGTRAP\" : \"SIGILL\");\n-        }\n-        stub = SharedRuntime::get_handle_wrong_method_stub();\n-      } else if (sig == SIGSEGV && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n+      if (sig == SIGSEGV && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -362,5 +362,0 @@\n-      } else if (sig == SIGILL &&\n-                 *(int*)pc ==\n-                     NativeInstruction::not_entrant_illegal_instruction) {\n-        \/\/ Not entrant\n-        stub = SharedRuntime::get_handle_wrong_method_stub();\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -261,9 +261,1 @@\n-      \/\/ Handle signal from NativeJump::patch_verified_entry().\n-      if (sig == SIGILL && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n-        if (TraceTraps) {\n-          tty->print_cr(\"trap: not_entrant\");\n-        }\n-        stub = SharedRuntime::get_handle_wrong_method_stub();\n-      }\n-\n-      else if ((sig == (USE_POLL_BIT_ONLY ? SIGTRAP : SIGSEGV)) &&\n+      if ((sig == (USE_POLL_BIT_ONLY ? SIGTRAP : SIGSEGV)) &&\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -226,8 +226,1 @@\n-      \/\/ Handle signal from NativeJump::patch_verified_entry().\n-      if ((sig == SIGILL || sig == SIGTRAP)\n-          && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n-        if (TraceTraps) {\n-          tty->print_cr(\"trap: not_entrant (%s)\", (sig == SIGTRAP) ? \"SIGTRAP\" : \"SIGILL\");\n-        }\n-        stub = SharedRuntime::get_handle_wrong_method_stub();\n-      } else if (sig == SIGSEGV && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n+      if (sig == SIGSEGV && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -260,9 +260,1 @@\n-      \/\/ Handle signal from NativeJump::patch_verified_entry().\n-      if (sig == SIGILL && nativeInstruction_at(pc)->is_sigill_not_entrant()) {\n-        if (TraceTraps) {\n-          tty->print_cr(\"trap: not_entrant (SIGILL)\");\n-        }\n-        stub = SharedRuntime::get_handle_wrong_method_stub();\n-      }\n-\n-      else if (sig == SIGSEGV &&\n+      if (sig == SIGSEGV &&\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -86,1 +86,4 @@\n-  set_guard_value(nm, value);\n+  if (guard_value(nm) != value) {\n+    \/\/ Patch the code only if needed.\n+    set_guard_value(nm, value);\n+  }\n@@ -246,1 +249,4 @@\n-  set_guard_value(nm, value);\n+  if (guard_value(nm) != value) {\n+    \/\/ Patch the code only if needed.\n+    set_guard_value(nm, value);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  void arm(nmethod* nm) { arm_with(nm, armed); }\n@@ -65,0 +64,1 @@\n+  void arm(nmethod* nm) { arm_with(nm, armed); }\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,4 @@\n-  set_guard_value(nm, value);\n+  if (guard_value(nm) != value) {\n+    \/\/ Patch the code only if needed.\n+    set_guard_value(nm, value);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}