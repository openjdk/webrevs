{"files":[{"patch":"@@ -62,0 +62,1 @@\n+import com.sun.tools.javac.parser.VirtualParser.VirtualScanner;\n@@ -5022,0 +5023,1 @@\n+            boolean unclosedParameterList;\n@@ -5024,0 +5026,1 @@\n+                unclosedParameterList = token.pos == endPosTable.errorEndPos;\n@@ -5029,0 +5032,2 @@\n+            } else {\n+                unclosedParameterList = false;\n@@ -5042,0 +5047,1 @@\n+                    accept(SEMI);\n@@ -5044,0 +5050,1 @@\n+                    accept(SEMI, tk -> Errors.Expected2(LBRACE, SEMI));\n@@ -5045,1 +5052,0 @@\n-                accept(SEMI);\n@@ -5048,2 +5054,5 @@\n-                    skip(false, true, false, false);\n-                    if (token.kind == LBRACE) {\n+                    \/\/ look if there is a probable missing opening brace,\n+                    \/\/ and if yes, parse as a block\n+                    boolean parseAsBlock = openingBraceMissing(unclosedParameterList);\n+\n+                    if (parseAsBlock) {\n@@ -5066,0 +5075,78 @@\n+    \/**\n+     * After seeing a method header, and not seeing an opening left brace,\n+     * attempt to estimate if acting as if the left brace was present and\n+     * parsing the upcoming code will get better results than not parsing\n+     * the code as a block.\n+     *\n+     * The estimate is as follows:\n+     * - tokens are skipped until member, statement or identifier is found,\n+     * - then, if there is a left brace, parse as a block,\n+     * - otherwise, if the head was broken, do not parse as a block,\n+     * - otherwise, look at the next token and:\n+     *   - if it definitelly starts a statement, parse as a block,\n+     *   - otherwise, if it is a closing\/right brace, count opening and closing\n+     *     braces in the rest of the file, to see if imaginarily \"adding\" an opening\n+     *     brace would lead to a balanced count - if yes, parse as a block,\n+     *   - otherwise, speculatively parse the following code as a block, and if\n+     *     it contains statements that cannot be members, parse as a block,\n+     *   - otherwise, don't parse as a block.\n+     *\n+     * @param unclosedParameterList whether there was a serious problem in the\n+     *                              parameters list\n+     * @return true if and only if the following code should be parsed as a block.\n+     *\/\n+    private boolean openingBraceMissing(boolean unclosedParameterList) {\n+        skip(false, true, !unclosedParameterList, !unclosedParameterList);\n+\n+        if (token.kind == LBRACE) {\n+            return true;\n+        } else if (unclosedParameterList) {\n+            return false;\n+        } else {\n+            return switch (token.kind) {\n+                \/\/definitelly sees a statement:\n+                case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n+                    RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n+                    CATCH, THIS, SUPER, NEW -> true;\n+                case RBRACE -> {\n+                    \/\/check if adding an opening brace would balance out\n+                    \/\/the opening and closing braces:\n+                    int braceBalance = 1;\n+                    VirtualScanner virtualScanner = new VirtualScanner(S);\n+\n+                    virtualScanner.nextToken();\n+\n+                    while (virtualScanner.token().kind != TokenKind.EOF) {\n+                        switch (virtualScanner.token().kind) {\n+                            case LBRACE -> braceBalance++;\n+                            case RBRACE -> braceBalance--;\n+                        }\n+                        virtualScanner.nextToken();\n+                    }\n+\n+                    yield braceBalance == 0;\n+                }\n+                default -> {\n+                    \/\/speculatively try to parse as a block, and check\n+                    \/\/if the result would suggest there is a block\n+                    \/\/e.g.: it contains a statement that is not\n+                    \/\/a member declaration\n+                    JavacParser speculative = new VirtualParser(this);\n+                    JCBlock speculativeResult =\n+                            speculative.block();\n+                    if (!speculativeResult.stats.isEmpty()) {\n+                        JCStatement last = speculativeResult.stats.last();\n+                        yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n+                                s.hasTag(CLASSDEF) ||\n+                                s.hasTag(BLOCK) ||\n+                                s == last) ||\n+                            !(last instanceof JCExpressionStatement exprStatement &&\n+                            exprStatement.expr.hasTag(ERRONEOUS));\n+                    } else {\n+                        yield false;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":90,"deletions":3,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859\n@@ -2486,0 +2486,531 @@\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion1() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              return true;\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             return true;\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion2() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }                       \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion2: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion3() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion3: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion4() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion4: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion5() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test(String,\n+                      }\n+                      class T {}\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:38:compiler.err.expected\",\n+                             \"4:1:compiler.err.illegal.start.of.type\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test(String <error>, (ERROR: ) <error>);\n+                     }\n+                     class T {\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion6() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          private Object testMethod(final String arg1 final String arg2) {\n+                              return null;\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:48:compiler.err.expected3\",\n+                             \"3:66:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         private Object testMethod(final String arg1);\n+                         final String arg2;\n+                         {\n+                             return null;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion7() throws IOException {\n+        \/\/after 'default' attribute value, only semicolon (';') is expected,\n+        \/\/not left brace ('{'):\n+        String code = \"\"\"\n+                      package tests;\n+                      public @interface A {\n+                          public String value() default \"\"\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:37:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public @interface A {\n+                         \\n\\\n+                         public String value() default \"\";\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion10() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion11() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          String s = \"\"; \/\/field declaration\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion12() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              final String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             final String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion13() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          final String s = \"\"; \/\/field declaration?\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         final String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion14() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              s.length();\n+                              if (true); \/\/force parse as block\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\",\n+                             \"7:5:compiler.err.illegal.start.of.expr\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             s.length();\n+                             if (true) ;\n+                             (ERROR: );\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":532,"deletions":1,"binary":false,"changes":533,"status":"modified"}]}