{"files":[{"patch":"@@ -5030,52 +5030,1 @@\n-                    skip(false, true, !unclosedParameterList, !unclosedParameterList);\n-                    boolean parseAsBlock;\n-                    if (token.kind == LBRACE) {\n-                        parseAsBlock = true;\n-                    } else if (unclosedParameterList) {\n-                        parseAsBlock = false;\n-                    } else {\n-                        parseAsBlock = switch (token.kind) {\n-                            \/\/definitelly sees a statement:\n-                            case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n-                                 RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n-                                 CATCH, THIS, SUPER, NEW -> true;\n-                            case RBRACE -> {\n-                                \/\/check if adding an opening brace would balance out\n-                                \/\/the opening and closing braces:\n-                                int braceBalance = 1;\n-                                VirtualScanner virtualScanner = new VirtualScanner(S);\n-\n-                                virtualScanner.nextToken();\n-\n-                                while (virtualScanner.token().kind != TokenKind.EOF) {\n-                                    switch (virtualScanner.token().kind) {\n-                                        case LBRACE -> braceBalance++;\n-                                        case RBRACE -> braceBalance--;\n-                                    }\n-                                    virtualScanner.nextToken();\n-                                }\n-\n-                                yield braceBalance == 0;\n-                            }\n-                            default -> {\n-                                \/\/speculatively try to parse as a block, and check\n-                                \/\/if the result would suggest there is a block\n-                                \/\/e.g.: it contains a statement that is not\n-                                \/\/a member declaration\n-                                JavacParser speculative = new VirtualParser(this);\n-                                JCBlock speculativeResult =\n-                                        speculative.block();\n-                                if (!speculativeResult.stats.isEmpty()) {\n-                                    JCStatement last = speculativeResult.stats.last();\n-                                    yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n-                                                                                          s.hasTag(CLASSDEF) ||\n-                                                                                          s.hasTag(BLOCK) ||\n-                                                                                          s == last) ||\n-                                          !(last instanceof JCExpressionStatement exprStatement &&\n-                                            exprStatement.expr.hasTag(ERRONEOUS));\n-                                } else {\n-                                    yield false;\n-                                }\n-                            }\n-                        };\n-                    }\n+                    boolean parseAsBlock = openingBraceMissing(unclosedParameterList);\n@@ -5100,0 +5049,78 @@\n+    \/**\n+     * After seeing a method header, and not seeing an opening left brace,\n+     * attempt to estimate if acting as if the left brace was present and\n+     * parsing the upcoming code will get better results than not parsing\n+     * the code as a block.\n+     *\n+     * The estimate is as follows:\n+     * - tokens are skipped until member, statement of identifier is found,\n+     * - then, if there is a left brace, parse as a block,\n+     * - otherwise, if the head was broken, do not parse as a block,\n+     * - otherwise, look at the next token and:\n+     *   - if it definitelly starts a statement, parse as a block,\n+     *   - otherwise, if it is a closing\/right brace, count opening and closing\n+     *     braces in the rest of the file, to see if imaginarily \"adding\" an opening\n+     *     brace would lead to a balanced count - if yes, parse as a block,\n+     *   - otherwise, speculatively parse the following code as a block, and if\n+     *     it contains statements that cannot be members, parse as a block,\n+     *   - otherwise, don't parse as a block.\n+     *\n+     * @param unclosedParameterList whether there was a serious problem in the\n+     *                              parameters list\n+     * @return true if and only if the following code should be parsed as a block.\n+     *\/\n+    private boolean openingBraceMissing(boolean unclosedParameterList) {\n+        skip(false, true, !unclosedParameterList, !unclosedParameterList);\n+\n+        if (token.kind == LBRACE) {\n+            return true;\n+        } else if (unclosedParameterList) {\n+            return false;\n+        } else {\n+            return switch (token.kind) {\n+                \/\/definitelly sees a statement:\n+                case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n+                    RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n+                    CATCH, THIS, SUPER, NEW -> true;\n+                case RBRACE -> {\n+                    \/\/check if adding an opening brace would balance out\n+                    \/\/the opening and closing braces:\n+                    int braceBalance = 1;\n+                    VirtualScanner virtualScanner = new VirtualScanner(S);\n+\n+                    virtualScanner.nextToken();\n+\n+                    while (virtualScanner.token().kind != TokenKind.EOF) {\n+                        switch (virtualScanner.token().kind) {\n+                            case LBRACE -> braceBalance++;\n+                            case RBRACE -> braceBalance--;\n+                        }\n+                        virtualScanner.nextToken();\n+                    }\n+\n+                    yield braceBalance == 0;\n+                }\n+                default -> {\n+                    \/\/speculatively try to parse as a block, and check\n+                    \/\/if the result would suggest there is a block\n+                    \/\/e.g.: it contains a statement that is not\n+                    \/\/a member declaration\n+                    JavacParser speculative = new VirtualParser(this);\n+                    JCBlock speculativeResult =\n+                            speculative.block();\n+                    if (!speculativeResult.stats.isEmpty()) {\n+                        JCStatement last = speculativeResult.stats.last();\n+                        yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n+                                s.hasTag(CLASSDEF) ||\n+                                s.hasTag(BLOCK) ||\n+                                s == last) ||\n+                            !(last instanceof JCExpressionStatement exprStatement &&\n+                            exprStatement.expr.hasTag(ERRONEOUS));\n+                    } else {\n+                        yield false;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":79,"deletions":52,"binary":false,"changes":131,"status":"modified"}]}