{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+    private boolean enableCertificateCompression = true;\n@@ -963,0 +964,34 @@\n+\n+    \/**\n+     * Sets whether TLS certificate compression should be enabled.\n+     * <p>\n+     * This method only applies to TLSv1.3.\n+     *\n+     * @param   enableCertificateCompression\n+     *          {@code true} indicates that TLS certificate compression\n+     *          should be enabled; {@code false} indicates that TLS certificate\n+     *          compression should be disabled\n+     *\n+     * @see     #getEnableCertificateCompression()\n+     *\n+     * @since 27\n+     *\/\n+    public void setEnableCertificateCompression(\n+            boolean enableCertificateCompression) {\n+        this.enableCertificateCompression = enableCertificateCompression;\n+    }\n+\n+    \/**\n+     * Returns whether TLS certificate compression should be enabled\n+     * <p>\n+     * This method only applies to TLSv1.3.\n+     *\n+     * @return  true, if TLS certificate compression should be enabled\n+     *\n+     * @see     #setEnableCertificateCompression(boolean)\n+     *\n+     * @since 27\n+     *\/\n+    public boolean getEnableCertificateCompression() {\n+        return this.enableCertificateCompression;\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLParameters.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,0 +284,2 @@\n+                        tc.handshakeContext.handshakeConsumers.remove(\n+                                SSLHandshake.COMPRESSED_CERTIFICATE.id);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Alert.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -920,5 +920,4 @@\n-            if (hc.sslConfig.isClientMode) {\n-                return onProduceCertificate(\n-                        (ClientHandshakeContext)context, message);\n-            } else {\n-                return onProduceCertificate(\n+            T13CertificateMessage cm = hc.sslConfig.isClientMode ?\n+                onProduceCertificate(\n+                        (ClientHandshakeContext)context, message) :\n+                onProduceCertificate(\n@@ -926,0 +925,8 @@\n+\n+            \/\/ Output the handshake message.\n+            if (hc.certDeflater == null) {\n+                cm.write(hc.handshakeOutput);\n+                hc.handshakeOutput.flush();\n+            } else {\n+                \/\/ Replace with CompressedCertificate message\n+                CompressedCertificate.handshakeProducer.produce(hc, cm);\n@@ -927,0 +934,3 @@\n+\n+            \/\/ The handshake message has been delivered.\n+            return null;\n@@ -929,1 +939,1 @@\n-        private byte[] onProduceCertificate(ServerHandshakeContext shc,\n+        private T13CertificateMessage onProduceCertificate(ServerHandshakeContext shc,\n@@ -987,6 +997,1 @@\n-            \/\/ Output the handshake message.\n-            cm.write(shc.handshakeOutput);\n-            shc.handshakeOutput.flush();\n-\n-            \/\/ The handshake message has been delivered.\n-            return null;\n+            return cm;\n@@ -1031,1 +1036,1 @@\n-        private byte[] onProduceCertificate(ClientHandshakeContext chc,\n+        private T13CertificateMessage onProduceCertificate(ClientHandshakeContext chc,\n@@ -1074,6 +1079,1 @@\n-            \/\/ Output the handshake message.\n-            cm.write(chc.handshakeOutput);\n-            chc.handshakeOutput.flush();\n-\n-            \/\/ The handshake message has been delivered.\n-            return null;\n+            return cm;\n@@ -1099,0 +1099,1 @@\n+            hc.handshakeConsumers.remove(SSLHandshake.COMPRESSED_CERTIFICATE.id);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -948,0 +948,5 @@\n+            if (shc.certInflaters != null && !shc.certInflaters.isEmpty()) {\n+                    shc.handshakeConsumers.put(\n+                        SSLHandshake.COMPRESSED_CERTIFICATE.id,\n+                        SSLHandshake.COMPRESSED_CERTIFICATE);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,317 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import javax.net.ssl.SSLProtocolException;\n+import sun.security.ssl.SSLExtension.ExtensionConsumer;\n+import sun.security.ssl.SSLExtension.SSLExtensionSpec;\n+import sun.security.ssl.SSLHandshake.HandshakeMessage;\n+\n+\/**\n+ * Pack of the \"compress_certificate\" extensions [RFC 5246].\n+ *\/\n+final class CompressCertExtension {\n+\n+    static final HandshakeProducer chNetworkProducer =\n+            new CHCompressCertificateProducer();\n+    static final ExtensionConsumer chOnLoadConsumer =\n+            new CHCompressCertificateConsumer();\n+\n+    static final HandshakeProducer crNetworkProducer =\n+            new CRCompressCertificateProducer();\n+    static final ExtensionConsumer crOnLoadConsumer =\n+            new CRCompressCertificateConsumer();\n+\n+    static final SSLStringizer ccStringizer =\n+            new CompressCertificateStringizer();\n+\n+    \/**\n+     * The \"signature_algorithms\" extension.\n+     *\/\n+    static final class CertCompressionSpec implements SSLExtensionSpec {\n+\n+        private final int[] compressionAlgorithms;  \/\/ non-null\n+\n+        CertCompressionSpec(\n+                Map<Integer, Function<byte[], byte[]>> certInflaters) {\n+            compressionAlgorithms = new int[certInflaters.size()];\n+            int i = 0;\n+            for (Integer id : certInflaters.keySet()) {\n+                compressionAlgorithms[i++] = id;\n+            }\n+        }\n+\n+        CertCompressionSpec(HandshakeContext hc,\n+                ByteBuffer buffer) throws IOException {\n+            if (buffer.remaining() < 2) {      \/\/ 2: the length of the list\n+                throw hc.conContext.fatal(Alert.DECODE_ERROR,\n+                        new SSLProtocolException(\n+                                \"Invalid compress_certificate: insufficient data\"));\n+            }\n+\n+            byte[] algs = Record.getBytes8(buffer);\n+            if (buffer.hasRemaining()) {\n+                throw hc.conContext.fatal(Alert.DECODE_ERROR,\n+                        new SSLProtocolException(\n+                                \"Invalid compress_certificate: unknown extra data\"));\n+            }\n+\n+            if (algs.length == 0 || (algs.length & 0x01) != 0) {\n+                throw hc.conContext.fatal(Alert.DECODE_ERROR,\n+                        new SSLProtocolException(\n+                                \"Invalid compress_certificate: incomplete data\"));\n+            }\n+\n+            int[] compressionAlgs = new int[algs.length \/ 2];\n+            for (int i = 0, j = 0; i < algs.length; ) {\n+                byte hash = algs[i++];\n+                byte sign = algs[i++];\n+                compressionAlgs[j++] = ((hash & 0xFF) << 8) | (sign & 0xFF);\n+            }\n+\n+            this.compressionAlgorithms = compressionAlgs;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            MessageFormat messageFormat = new MessageFormat(\n+                    \"\\\"compression algorithms\\\": '['{0}']'\", Locale.ENGLISH);\n+\n+            if (compressionAlgorithms.length == 0) {\n+                Object[] messageFields = {\n+                        \"<no supported compression algorithms specified>\"\n+                };\n+                return messageFormat.format(messageFields);\n+            } else {\n+                StringBuilder builder = new StringBuilder(512);\n+                boolean isFirst = true;\n+                for (int ca : compressionAlgorithms) {\n+                    if (isFirst) {\n+                        isFirst = false;\n+                    } else {\n+                        builder.append(\", \");\n+                    }\n+\n+                    builder.append(CompressionAlgorithm.nameOf(ca));\n+                }\n+\n+                Object[] messageFields = {\n+                        builder.toString()\n+                };\n+\n+                return messageFormat.format(messageFields);\n+            }\n+        }\n+    }\n+\n+    private static final\n+    class CompressCertificateStringizer implements SSLStringizer {\n+\n+        @Override\n+        public String toString(HandshakeContext hc, ByteBuffer buffer) {\n+            try {\n+                return (new CertCompressionSpec(hc, buffer)).toString();\n+            } catch (IOException ioe) {\n+                \/\/ For debug logging only, so please swallow exceptions.\n+                return ioe.getMessage();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Network data producer of a \"compress_certificate\" extension in\n+     * the ClientHello handshake message.\n+     *\/\n+    private static final\n+    class CHCompressCertificateProducer implements HandshakeProducer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CHCompressCertificateProducer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public byte[] produce(ConnectionContext context,\n+                HandshakeMessage message) throws IOException {\n+            \/\/ The producing happens in client side only.\n+            return produceCompCertExt(context,\n+                    SSLExtension.CH_COMPRESS_CERTIFICATE);\n+        }\n+    }\n+\n+    \/**\n+     * Network data consumer of a \"compress_certificate\" extension in\n+     * the ClientHello handshake message.\n+     *\/\n+    private static final\n+    class CHCompressCertificateConsumer implements ExtensionConsumer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CHCompressCertificateConsumer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public void consume(ConnectionContext context,\n+                HandshakeMessage message, ByteBuffer buffer)\n+                throws IOException {\n+            \/\/ The consuming happens in server side only.\n+            consumeCompCertExt(context, buffer,\n+                    SSLExtension.CH_COMPRESS_CERTIFICATE);\n+        }\n+    }\n+\n+    \/**\n+     * Network data producer of a \"compress_certificate\" extension in\n+     * the CertificateRequest handshake message.\n+     *\/\n+    private static final\n+    class CRCompressCertificateProducer implements HandshakeProducer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CRCompressCertificateProducer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public byte[] produce(ConnectionContext context,\n+                HandshakeMessage message) throws IOException {\n+            \/\/ The producing happens in server side only.\n+            return produceCompCertExt(context,\n+                    SSLExtension.CR_COMPRESS_CERTIFICATE);\n+        }\n+    }\n+\n+    \/**\n+     * Network data consumer of a \"compress_certificate\" extension in\n+     * the CertificateRequest handshake message.\n+     *\/\n+    private static final\n+    class CRCompressCertificateConsumer implements ExtensionConsumer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CRCompressCertificateConsumer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public void consume(ConnectionContext context,\n+                HandshakeMessage message, ByteBuffer buffer)\n+                throws IOException {\n+            \/\/ The consuming happens in client side only.\n+            consumeCompCertExt(context, buffer,\n+                    SSLExtension.CR_COMPRESS_CERTIFICATE);\n+        }\n+    }\n+\n+    private static byte[] produceCompCertExt(\n+            ConnectionContext context, SSLExtension extension)\n+            throws IOException {\n+\n+        HandshakeContext hc = (HandshakeContext) context;\n+        \/\/ Is it a supported and enabled extension?\n+        if (!hc.sslConfig.isAvailable(extension)) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"Ignore unavailable \" +\n+                        \"compress_certificate extension\");\n+            }\n+            return null;\n+        }\n+\n+        \/\/ Produce the extension.\n+        if (hc.certInflaters == null) {\n+            hc.certInflaters =\n+                    CompressionAlgorithm.findInflaters(hc.sslConfig);\n+        }\n+\n+        if (hc.certInflaters.isEmpty()) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"Ignore unsupported \" +\n+                        \"compress_certificate extension\");\n+            }\n+            return null;\n+        }\n+\n+        int vectorLen = CompressionAlgorithm.sizeInRecord() *\n+                hc.certInflaters.size();\n+        byte[] extData = new byte[vectorLen + 1];\n+        ByteBuffer m = ByteBuffer.wrap(extData);\n+        Record.putInt8(m, vectorLen);\n+        for (Integer algId : hc.certInflaters.keySet()) {\n+            Record.putInt16(m, algId);\n+        }\n+\n+        \/\/ Update the context.\n+        hc.handshakeExtensions.put(\n+                extension, new CertCompressionSpec(hc.certInflaters));\n+\n+        return extData;\n+    }\n+\n+    private static void consumeCompCertExt(ConnectionContext context,\n+            ByteBuffer buffer, SSLExtension extension) throws IOException {\n+\n+        HandshakeContext hc = (HandshakeContext) context;\n+        \/\/ Is it a supported and enabled extension?\n+        if (!hc.sslConfig.isAvailable(extension)) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"Ignore unavailable \" +\n+                        \"compress_certificate extension\");\n+            }\n+            return;     \/\/ ignore the extension\n+        }\n+\n+        if (hc.sslConfig.certDeflaters == null ||\n+                hc.sslConfig.certDeflaters.isEmpty()) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"Ignore unsupported \" +\n+                        \"compress_certificate extension\");\n+            }\n+            return;     \/\/ ignore the extension\n+        }\n+\n+        \/\/ Parse the extension.\n+        CertCompressionSpec spec = new CertCompressionSpec(hc, buffer);\n+\n+        \/\/ Update the context.\n+        hc.certDeflater = CompressionAlgorithm.selectDeflater(\n+                hc.sslConfig, spec.compressionAlgorithms);\n+        if (hc.certDeflater == null) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"Ignore, no supported \" +\n+                        \"certificate compression algorithms\");\n+            }\n+        }\n+        \/\/ No impact on session resumption.\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CompressCertExtension.java","additions":317,"deletions":0,"binary":false,"changes":317,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.function.Function;\n+import javax.net.ssl.SSLProtocolException;\n+import sun.security.ssl.SSLHandshake.HandshakeMessage;\n+import sun.security.util.HexDumpEncoder;\n+\n+\/**\n+ * Pack of the CompressedCertificate handshake message.\n+ *\/\n+final class CompressedCertificate {\n+\n+    static final SSLConsumer handshakeConsumer =\n+            new CompressedCertConsumer();\n+    static final HandshakeProducer handshakeProducer =\n+            new CompressedCertProducer();\n+\n+    \/**\n+     * The CompressedCertificate handshake message for TLS 1.3.\n+     *\/\n+    static final class CompressedCertMessage extends HandshakeMessage {\n+\n+        private final int algorithmId;\n+        private final int uncompressedLength;\n+        private final byte[] compressedCert;\n+\n+        CompressedCertMessage(HandshakeContext context,\n+                int algorithmId, int uncompressedLength,\n+                byte[] compressedCert) {\n+            super(context);\n+\n+            this.algorithmId = algorithmId;\n+            this.uncompressedLength = uncompressedLength;\n+            this.compressedCert = compressedCert;\n+        }\n+\n+        CompressedCertMessage(HandshakeContext handshakeContext,\n+                ByteBuffer m) throws IOException {\n+            super(handshakeContext);\n+\n+            \/\/ struct {\n+            \/\/     CertificateCompressionAlgorithm algorithm;\n+            \/\/     uint24 uncompressed_length;\n+            \/\/     opaque compressed_certificate_message<1..2^24-1>;\n+            \/\/ } CompressedCertificate;\n+            if (m.remaining() < 9) {\n+                throw new SSLProtocolException(\n+                        \"Invalid CompressedCertificate message: \" +\n+                                \"insufficient data (length=\" + m.remaining()\n+                                + \")\");\n+            }\n+            this.algorithmId = Record.getInt16(m);\n+            this.uncompressedLength = Record.getInt24(m);\n+            this.compressedCert = Record.getBytes24(m);\n+\n+            if (m.hasRemaining()) {\n+                throw handshakeContext.conContext.fatal(\n+                        Alert.HANDSHAKE_FAILURE,\n+                        \"Invalid CompressedCertificate message: \" +\n+                                \"unknown extra data\");\n+            }\n+        }\n+\n+        @Override\n+        public SSLHandshake handshakeType() {\n+            return SSLHandshake.COMPRESSED_CERTIFICATE;\n+        }\n+\n+        @Override\n+        public int messageLength() {\n+            return 8 + compressedCert.length;\n+        }\n+\n+        @Override\n+        public void send(HandshakeOutStream hos) throws IOException {\n+            hos.putInt16(algorithmId);\n+            hos.putInt24(uncompressedLength);\n+            hos.putBytes24(compressedCert);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            MessageFormat messageFormat = new MessageFormat(\n+                    \"\"\"\n+                    \"CompressedCertificate\": '{'\n+                      \"algorithm\": \"{0}\",\n+                      \"uncompressed_length\": {1}\n+                      \"compressed_certificate_message\": [\n+                    {2}\n+                      ]\n+                    '}'\"\"\",\n+                    Locale.ENGLISH);\n+\n+            HexDumpEncoder hexEncoder = new HexDumpEncoder();\n+            Object[] messageFields = {\n+                    CompressionAlgorithm.nameOf(algorithmId),\n+                    uncompressedLength,\n+                    Utilities.indent(hexEncoder.encode(compressedCert), \"    \")\n+            };\n+\n+            return messageFormat.format(messageFields);\n+        }\n+    }\n+\n+    \/**\n+     * The \"Certificate\" handshake message producer for TLS 1.3.\n+     *\/\n+    private static final\n+    class CompressedCertProducer implements HandshakeProducer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CompressedCertProducer() {\n+            \/\/ blank\n+        }\n+\n+        \/\/ Note this is a special producer, which can only be called from\n+        \/\/ the CertificateMessage producer.  The input 'message' parameter\n+        \/\/ represents the Certificate handshake message.\n+        @Override\n+        public byte[] produce(ConnectionContext context,\n+                HandshakeMessage message) throws IOException {\n+            \/\/ The producing happens in handshake context only.\n+            HandshakeContext hc = (HandshakeContext) context;\n+\n+            \/\/ Compress the Certificate message.\n+            HandshakeOutStream hos = new HandshakeOutStream(null);\n+            message.send(hos);\n+            byte[] certMsg = hos.toByteArray();\n+            byte[] compressedCertMsg =\n+                    hc.certDeflater.getValue().apply(certMsg);\n+            if (compressedCertMsg == null || compressedCertMsg.length == 0) {\n+                throw hc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No compressed Certificate data\");\n+            }\n+\n+            CompressedCertMessage ccm = new CompressedCertMessage(hc,\n+                    hc.certDeflater.getKey(), certMsg.length,\n+                    compressedCertMsg);\n+\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                        \"Produced CompressedCertificate handshake message\",\n+                        ccm);\n+            }\n+\n+            ccm.write(hc.handshakeOutput);\n+            hc.handshakeOutput.flush();\n+\n+            \/\/ The handshake message has been delivered.\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * The \"Certificate\" handshake message consumer for TLS 1.3.\n+     *\/\n+    private static final class CompressedCertConsumer implements SSLConsumer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CompressedCertConsumer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public void consume(ConnectionContext context,\n+                ByteBuffer message) throws IOException {\n+            \/\/ The consuming happens in handshake context only.\n+            HandshakeContext hc = (HandshakeContext) context;\n+\n+            \/\/ clean up this consumer\n+            hc.handshakeConsumers.remove(\n+                    SSLHandshake.COMPRESSED_CERTIFICATE.id);\n+            hc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE.id);\n+\n+            \/\/ Parse the handshake message\n+            CompressedCertMessage ccm = new CompressedCertMessage(hc, message);\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                        \"Consuming CompressedCertificate handshake message\",\n+                        ccm);\n+            }\n+\n+            \/\/ check the compression algorithm\n+            Function<byte[], byte[]> inflater =\n+                    hc.certInflaters.get(ccm.algorithmId);\n+            if (inflater == null) {\n+                throw hc.conContext.fatal(Alert.BAD_CERTIFICATE,\n+                        \"Unsupported certificate compression algorithm\");\n+            }\n+\n+            \/\/ decompress\n+            byte[] certificateMessage = inflater.apply(ccm.compressedCert);\n+\n+            \/\/ check the uncompressed length\n+            if (certificateMessage == null ||\n+                    certificateMessage.length != ccm.uncompressedLength) {\n+                throw hc.conContext.fatal(Alert.BAD_CERTIFICATE,\n+                        \"Improper certificate compression\");\n+            }\n+\n+            \/\/ Call the Certificate handshake message consumer.\n+            CertificateMessage.t13HandshakeConsumer.consume(hc,\n+                    ByteBuffer.wrap(certificateMessage));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CompressedCertificate.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.AbstractMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.zip.CRC32C;\n+import java.util.zip.Deflater;\n+import java.util.zip.Inflater;\n+\n+\/**\n+ * Enum for TLS certificate compression algorithms.\n+ *\/\n+enum CompressionAlgorithm {\n+    ZLIB(1, \"zlib\", new ConcurrentHashMap<>(2)),\n+    \/\/ Placeholders, we currently support only ZLIB.\n+    BROTLI(2, \"brotli\", null),\n+    ZSTD(3, \"zstd\", null);\n+\n+    final int id;\n+    final String name;\n+    \/\/ We compress only local certificates, so it's ok to store the\n+    \/\/ deflated certificate data in a memory cache permanently, i.e. such\n+    \/\/ cache is going to be of a manageable size.\n+    final Map<Long, byte[]> cache;          \/\/ Checksum -> deflated data.\n+\n+    CompressionAlgorithm(int id, String name, Map<Long, byte[]> cache) {\n+        this.id = id;\n+        this.name = name;\n+        this.cache = cache;\n+    }\n+\n+    static CompressionAlgorithm nameOf(String name) {\n+        for (CompressionAlgorithm cca : CompressionAlgorithm.values()) {\n+            if (cca.name.equals(name)) {\n+                return cca;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    static String nameOf(int id) {\n+        for (CompressionAlgorithm cca : CompressionAlgorithm.values()) {\n+            if (cca.id == id) {\n+                return cca.name;\n+            }\n+        }\n+\n+        return \"<UNKNOWN CONTENT TYPE: \" + id + \">\";\n+    }\n+\n+    \/\/ Return the size of a compression algorithms structure in TLS record\n+    static int sizeInRecord() {\n+        return 2;\n+    }\n+\n+    \/\/ Get local supported algorithm collection.\n+    static Map<Integer, Function<byte[], byte[]>> findInflaters(\n+            SSLConfiguration config) {\n+        if (config.certInflaters == null || config.certInflaters.isEmpty()) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.finest(\n+                        \"No supported certificate compression algorithms\");\n+            }\n+            return Map.of();\n+        }\n+\n+        Map<Integer, Function<byte[], byte[]>> inflaters =\n+                new LinkedHashMap<>(config.certInflaters.size());\n+\n+        for (Map.Entry<String, Function<byte[], byte[]>> entry :\n+                config.certInflaters.entrySet()) {\n+            CompressionAlgorithm ca =\n+                    CompressionAlgorithm.nameOf(entry.getKey());\n+            if (ca == null) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.finest(\"Ignore unsupported certificate \" +\n+                            \"compression algorithm: \" + entry.getKey());\n+                }\n+                continue;\n+            }\n+\n+            inflaters.putIfAbsent(ca.id, entry.getValue());\n+        }\n+\n+        return inflaters;\n+    }\n+\n+    static Map.Entry<Integer, Function<byte[], byte[]>> selectDeflater(\n+            SSLConfiguration config, int[] compressionAlgorithmIds) {\n+        if (config.certDeflaters == null) {\n+            return null;\n+        }\n+\n+        for (Map.Entry<String, Function<byte[], byte[]>> entry :\n+                config.certDeflaters.entrySet()) {\n+            CompressionAlgorithm ca =\n+                    CompressionAlgorithm.nameOf(entry.getKey());\n+            if (ca != null) {\n+                for (int id : compressionAlgorithmIds) {\n+                    if (ca.id == id) {\n+                        return new AbstractMap.SimpleImmutableEntry<>(\n+                                id, entry.getValue());\n+                    }\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    \/\/ Default Deflaters and Inflaters.\n+\n+    static Map<String, Function<byte[], byte[]>> getDefaultDeflaters() {\n+        return Map.of(ZLIB.name, (input) ->\n+                ZLIB.cache.computeIfAbsent(getChecksum(input), _ -> {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        SSLLogger.info(\"Deflating and caching new \" + ZLIB.name\n+                                + \" certificate data of \" + input.length\n+                                + \" bytes\");\n+                    }\n+\n+                    try (Deflater deflater = new Deflater();\n+                            ByteArrayOutputStream outputStream =\n+                                    new ByteArrayOutputStream(input.length)) {\n+\n+                        deflater.setInput(input);\n+                        deflater.finish();\n+                        byte[] buffer = new byte[1024];\n+\n+                        while (!deflater.finished()) {\n+                            int compressedSize = deflater.deflate(buffer);\n+                            outputStream.write(buffer, 0, compressedSize);\n+                        }\n+\n+                        return outputStream.toByteArray();\n+                    } catch (Exception e) {\n+                        if (SSLLogger.isOn()\n+                                && SSLLogger.isOn(\"ssl,handshake\")) {\n+                            SSLLogger.warning(\"Exception during certificate \"\n+                                    + \"compression: \", e);\n+                        }\n+                        return null;\n+                    }\n+                }));\n+    }\n+\n+    static Map<String, Function<byte[], byte[]>> getDefaultInflaters() {\n+        return Map.of(ZLIB.name, (input) -> {\n+            try (Inflater inflater = new Inflater();\n+                    ByteArrayOutputStream outputStream =\n+                            new ByteArrayOutputStream(input.length)) {\n+\n+                inflater.setInput(input);\n+                byte[] buffer = new byte[1024];\n+\n+                while (!inflater.finished()) {\n+                    int decompressedSize = inflater.inflate(buffer);\n+                    outputStream.write(buffer, 0, decompressedSize);\n+                }\n+\n+                return outputStream.toByteArray();\n+            } catch (Exception e) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\n+                            \"Exception during certificate decompression: \", e);\n+                }\n+                return null;\n+            }\n+        });\n+    }\n+\n+    \/\/ Fast checksum.\n+    private static long getChecksum(byte[] input) {\n+        CRC32C crc32c = new CRC32C();\n+        crc32c.update(input);\n+        \/\/ The upper 32 bits are not used in the long returned by CRC32C,\n+        \/\/ place input's length there to reduce the chance of collision.\n+        return crc32c.getValue() | (long) input.length << 32;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CompressionAlgorithm.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.function.Function;\n@@ -134,0 +135,4 @@\n+    \/\/ CertificateCompressionAlgorithm\n+    Map<Integer, Function<byte[], byte[]>>          certInflaters;\n+    Map.Entry<Integer, Function<byte[], byte[]>>    certDeflater;\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.function.Function;\n@@ -67,0 +68,8 @@\n+    \/\/ The configured certificate compression algorithms for\n+    \/\/ \"compress_certificate\" extensions\n+    Map<String, Function<byte[], byte[]>> certDeflaters;\n+    Map<String, Function<byte[], byte[]>> certInflaters;\n+\n+    \/\/ the maximum protocol version of enabled protocols\n+    ProtocolVersion             maximumProtocolVersion;\n+\n@@ -248,0 +257,10 @@\n+\n+        if (Utilities.getBooleanProperty(\n+                \"jdk.tls.enableCertificateCompression\", true)) {\n+            this.certDeflaters = CompressionAlgorithm.getDefaultDeflaters();\n+            this.certInflaters = CompressionAlgorithm.getDefaultInflaters();\n+        } else {\n+            this.certDeflaters = Map.of();\n+            this.certInflaters = Map.of();\n+        }\n+\n@@ -298,0 +317,2 @@\n+        params.setEnableCertificateCompression(!this.certInflaters.isEmpty()\n+                && !this.certDeflaters.isEmpty());\n@@ -366,0 +387,8 @@\n+        if (params.getEnableCertificateCompression()) {\n+            this.certDeflaters = CompressionAlgorithm.getDefaultDeflaters();\n+            this.certInflaters = CompressionAlgorithm.getDefaultInflaters();\n+        } else {\n+            this.certDeflaters = Map.of();\n+            this.certInflaters = Map.of();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -273,0 +273,21 @@\n+    \/\/ Extensions defined in RFC 8879 (TLS Certificate Compression)\n+    CH_COMPRESS_CERTIFICATE (0x001B, \"compress_certificate\",\n+                             SSLHandshake.CLIENT_HELLO,\n+                             ProtocolVersion.PROTOCOLS_OF_13,\n+                             CompressCertExtension.chNetworkProducer,\n+                             CompressCertExtension.chOnLoadConsumer,\n+                             null,\n+                             null,\n+                             null,\n+                             CompressCertExtension.ccStringizer),\n+\n+    CR_COMPRESS_CERTIFICATE (0x001B, \"compress_certificate\",\n+                             SSLHandshake.CERTIFICATE_REQUEST,\n+                             ProtocolVersion.PROTOCOLS_OF_13,\n+                             CompressCertExtension.crNetworkProducer,\n+                             CompressCertExtension.crOnLoadConsumer,\n+                             null,\n+                             null,\n+                             null,\n+                             CompressCertExtension.ccStringizer),\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLExtension.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,1 +373,16 @@\n-    COMPRESSED_CERTIFICATE      ((byte)0x19, \"compressed_certificate\"),\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    COMPRESSED_CERTIFICATE      ((byte)0x19, \"compressed_certificate\",\n+            (new Map.Entry[] {\n+                    new SimpleImmutableEntry<>(\n+                            CompressedCertificate.handshakeConsumer,\n+                            ProtocolVersion.PROTOCOLS_OF_13\n+                    )\n+            }),\n+            (new Map.Entry[] {\n+                    \/\/ Note that the producing of this message is delegated to\n+                    \/\/ CertificateMessage producer.\n+                    new SimpleImmutableEntry<>(\n+                            CertificateMessage.t13HandshakeProducer,\n+                            ProtocolVersion.PROTOCOLS_OF_13\n+                    )\n+            })),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLHandshake.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1459,0 +1459,5 @@\n+            if (chc.certInflaters != null && !chc.certInflaters.isEmpty()) {\n+                chc.handshakeConsumers.put(\n+                        SSLHandshake.COMPRESSED_CERTIFICATE.id,\n+                        SSLHandshake.COMPRESSED_CERTIFICATE);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -723,0 +723,1 @@\n+        p1.setEnableCertificateCompression(p.getEnableCertificateCompression());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.net.http.HttpResponse.BodyHandlers.ofString;\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import javax.net.ssl.SSLParameters;\n+\n+\/*\n+ * @test\n+ * @bug 8372526\n+ * @summary TLS certificate compression\n+ * @run main\/manual\/othervm HttpsCompressedCert true\n+ * @run main\/manual\/othervm HttpsCompressedCert false\n+ *\/\n+\n+public class HttpsCompressedCert {\n+\n+    public static void main(String[] args) throws Exception {\n+        SSLParameters sslParameters = new SSLParameters();\n+        sslParameters.setEnableCertificateCompression(\n+                Boolean.parseBoolean(args[0]));\n+\n+        try (HttpClient httpClient = HttpClient.newBuilder()\n+                .sslContext(SSLClientContext.createClientSSLContext())\n+                .version(HttpClient.Version.HTTP_2)\n+                .sslParameters(sslParameters)\n+                .build()) {\n+\n+            HttpRequest httpRequest = HttpRequest.newBuilder(\n+                            new URI(\"https:\/\/www.google.com\/\"))\n+                    .GET()\n+                    .build();\n+            HttpResponse<String> response = httpClient.send(\n+                    httpRequest, ofString());\n+            assertEquals(response.statusCode(), 200);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpsCompressedCert.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLSocket;\n+\n+\/*\n+ * @test\n+ * @bug 8372526\n+ * @summary TLS Certificate Compression\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm CompressedCert\n+ *\/\n+\n+public class CompressedCert extends SSLSocketTemplate {\n+\n+    private final boolean enableClientCertComp;\n+    private final boolean enableServerCertComp;\n+    private final boolean requireClientCert;\n+\n+    public CompressedCert(\n+            boolean enableClientCertComp,\n+            boolean enableServerCertComp,\n+            boolean requireClientCert) {\n+        this.enableClientCertComp = enableClientCertComp;\n+        this.enableServerCertComp = enableServerCertComp;\n+        this.requireClientCert = requireClientCert;\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        sslParameters.setEnableCertificateCompression(enableClientCertComp);\n+        sslParameters.setNeedClientAuth(requireClientCert);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        SSLParameters sslParameters = socket.getSSLParameters();\n+        sslParameters.setEnableCertificateCompression(enableServerCertComp);\n+        socket.setSSLParameters(sslParameters);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(false, false, false);\n+        runTest(false, false, true);\n+        runTest(false, true, false);\n+        runTest(true, false, true);\n+        runTest(true, true, false);\n+        runTest(true, true, true);\n+    }\n+\n+    private static void runTest(\n+            boolean enableClientCertComp,\n+            boolean enableServerCertComp,\n+            boolean requireClientCert) throws Exception {\n+        new CompressedCert(enableClientCertComp, enableServerCertComp,\n+                requireClientCert).run();\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/CompressedCert.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManagerFactory;\n+import java.io.ByteArrayInputStream;\n+import java.security.KeyStore;\n+import java.security.cert.CertificateFactory;\n+\n+public enum SSLClientContext {\n+    GTS_ROOT_R1(\"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIIFWjCCA0KgAwIBAgIQbkepxUtHDA3sM9CJuRz04TANBgkqhkiG9w0BAQwFADBH\n+            MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM\n+            QzEUMBIGA1UEAxMLR1RTIFJvb3QgUjEwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIy\n+            MDAwMDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNl\n+            cnZpY2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjEwggIiMA0GCSqGSIb3DQEB\n+            AQUAA4ICDwAwggIKAoICAQC2EQKLHuOhd5s73L+UPreVp0A8of2C+X0yBoJx9vaM\n+            f\/vo27xqLpeXo4xL+Sv2sfnOhB2x+cWX3u+58qPpvBKJXqeqUqv4IyfLpLGcY9vX\n+            mX7wCl7raKb0xlpHDU0QM+NOsROjyBhsS+z8CZDfnWQpJSMHobTSPS5g4M\/SCYe7\n+            zUjwTcLCeoiKu7rPWRnWr4+wB7CeMfGCwcDfLqZtbBkOtdh+JhpFAz2weaSUKK0P\n+            fyblqAj+lug8aJRT7oM6iCsVlgmy4HqMLnXWnOunVmSPlk9orj2XwoSPwLxAwAtc\n+            vfaHszVsrBhQf4TgTM2S0yDpM7xSma8ytSmzJSq0SPly4cpk9+aCEI3oncKKiPo4\n+            Zor8Y\/kB+Xj9e1x3+naH+uzfsQ55lVe0vSbv1gHR6xYKu44LtcXFilWr06zqkUsp\n+            zBmkMiVOKvFlRNACzqrOSbTqn3yDsEB750Orp2yjj32JgfpMpf\/VjsPOS+C12LOO\n+            Rc92wO1AK\/1TD7Cn1TsNsYqiA94xrcx36m97PtbfkSIS5r762DL8EGMUUXLeXdYW\n+            k70paDPvOmbsB4om3xPXV2V4J95eSRQAogB\/mqghtqmxlbCluQ0WEdrHbEg8QOB+\n+            DVrNVjzRlwW5y0vtOUucxD\/SVRNuJLDWcfr0wbrM7Rv1\/oFB2ACYPTrIrnqYNxgF\n+            lQIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH\/BAUwAwEB\/zAdBgNV\n+            HQ4EFgQU5K8rJnEaK0gnhS9SZizv8IkTcT4wDQYJKoZIhvcNAQEMBQADggIBADiW\n+            Cu49tJYeX++dnAsznyvgyv3SjgofQXSlfKqE1OXyHuY3UjKcC9FhHb8owbZEKTV1\n+            d5iyfNm9dKyKaOOpMQkpAWBz40d8U6iQSifvS9efk+eCNs6aaAyC58\/UEBZvXw6Z\n+            XPYfcX3v73svfuo21pdwCxXu11xWajOl40k4DLh9+42FpLFZXvRq4d2h9mREruZR\n+            gyFmxhE+885H7pwoHyXa\/6xmld01D1zvICxi\/ZG6qcz8WpyTgYMpl0p8WnK0OdC3\n+            d8t5\/Wk6kjftbjhlRn7pYL15iJdfOBL07q9bgsiG1eGZbYwE8na6SfZu6W0eX6Dv\n+            J4J2QPim01hcDyxC2kLGe4g0x8HYRZvBPsVhHdljUEn2NIVq4BjFbkerQUIpm\/Zg\n+            DdIx02OYI5NaAIFItO\/Nis3Jz5nu2Z6qNuFoS3FJFDYoOj0dzpqPJeaAcWErtXvM\n+            +SUWgeExX6GjfhaknBZqlxi9dnKlC54dNuYvoS++cJEPqOba+MSSQGwlfnuzCdyy\n+            F62ARPBopY+Udf90WuioAnwMCeKpSwughQtiue+hMZL77\/ZRBIls6Kl0obsXs7X9\n+            SQ98POyDGCBDTtWTurQ0sR8WNh8M5mQ5Fkzc4P4dyKliPUDqysU0ArSuiYgzNdws\n+            E3PYJ\/HQcu51OyLemGhmW\/HGY0dVHLqlCFF1pkgl\n+            -----END CERTIFICATE-----\"\"\"),\n+\n+    GTS_ROOT_R2(\"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIIFWjCCA0KgAwIBAgIQbkepxlqz5yDFMJo\/aFLybzANBgkqhkiG9w0BAQwFADBH\n+            MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM\n+            QzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIy\n+            MDAwMDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNl\n+            cnZpY2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwggIiMA0GCSqGSIb3DQEB\n+            AQUAA4ICDwAwggIKAoICAQDO3v2m++zsFDQ8BwZabFn3GTXd98GdVarTzTukk3Lv\n+            CvptnfbwhYBboUhSnznFt+4orO\/LdmgUud+tAWyZH8QiHZ\/+cnfgLFuv5AS\/T3Kg\n+            GjSY6Dlo7JUle3ah5mm5hRm9iYz+re026nO8\/4Piy33B0s5Ks40FnotJk9\/BW9Bu\n+            XvAuMC6C\/Pq8tBcKSOWIm8Wba96wyrQD8Nr0kLhlZPdcTK3ofmZemde4wj7I0BOd\n+            re7kRXuJVfeKH2JShBKzwkCX44ofR5GmdFrS+LFjKBC4swm4VndAoiaYecb+3yXu\n+            PuWgf9RhD1FLPD+M2uFwdNjCaKH5wQzpoeJ\/u1U8dgbuak7MkogwTZq9TwtImoS1\n+            mKPV+3PBV2HdKFZ1E66HjucMUQkQdYhMvI35ezzUIkgfKtzra7tEscszcTJGr61K\n+            8YzodDqs5xoic4DSMPclQsciOzsSrZYuxsN2B6ogtzVJV+mSSeh2FnIxZyuWfoqj\n+            x5RWIr9qS34BIbIjMt\/kmkRtWVtd9QCgHJvGeJeNkP+byKq0rxFROV7Z+2et1VsR\n+            nTKaG73VululycslaVNVJ1zgyjbLiGH7HrfQy+4W+9OmTN6SpdTi3\/UGVN4unUu0\n+            kzCqgc7dGtxRcw1PcOnlthYhGXmy5okLdWTK1au8CcEYof\/UVKGFPP0UJAOyh9Ok\n+            twIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH\/BAUwAwEB\/zAdBgNV\n+            HQ4EFgQUu\/\/KjiOfT5nK2+JopqUVJxce2Q4wDQYJKoZIhvcNAQEMBQADggIBALZp\n+            8KZ3\/p7uC4Gt4cCpx\/k1HUCCq+YEtN\/L9x0Pg\/B+E02NjO7jMyLDOfxA325BS0JT\n+            vhaI8dI4XsRomRyYUpOM52jtG2pzegVATX9lO9ZY8c6DR2Dj\/5epnGB3GFW1fgiT\n+            z9D2PGcDFWEJ+YF59exTpJ\/JjwGLc8R3dtyDovUMSRqodt6Sm2T4syzFJ9MHwAiA\n+            pJiS4wGWAqoC7o87xdFtCjMwc3i5T1QWvwsHoaRc5svJXISPD+AVdyx+Jn7axEvb\n+            pxZ3B7DNdehyQtaVhJ2Gg\/LkkM0JR9SLA3DaWsYDQvTtN6LwG1BUSw7YhN4ZKJmB\n+            R64JGz9I0cNv4rBgF\/XuIwKl2gBbbZCr7qLpGzvpx0QnRY5rn\/WkhLx3+WuXrD5R\n+            RaIRpsyF7gpo8j5QOHokYh4XIDdtak23CZvJ\/KRY9bb7nE4Yu5UC56GtmwfuNmsk\n+            0jmGwZODUNKBRqhfYlcsu2xkiAhu7xNUX90txGdj08+JN7+dIPT7eoOboB6BAFDC\n+            5AwiWVIQ7UNWhwD4FFKnHYuTjKJNRn8nxnGbJN7k2oaLDX5rIMHAnuFl2GqjpuiF\n+            izoHCBy69Y9Vmhh1fuXsgWbRIXOhNUQLgD1bnF5vKheW0YMjiGZt5obicDIvUiLn\n+            yOd\/xCxgXS\/Dr55FBcOEArf9LAhST4Ldo\/DUhgkC\n+            -----END CERTIFICATE-----\"\"\"),\n+\n+    GTS_ROOT_R3(\"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIICDDCCAZGgAwIBAgIQbkepx2ypcyRAiQ8DVd2NHTAKBggqhkjOPQQDAzBHMQsw\n+            CQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExMQzEU\n+            MBIGA1UEAxMLR1RTIFJvb3QgUjMwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIyMDAw\n+            MDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZp\n+            Y2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjMwdjAQBgcqhkjOPQIBBgUrgQQA\n+            IgNiAAQfTzOHMymKoYTey8chWEGJ6ladK0uFxh1MJ7x\/JlFyb+Kf1qPKzEUURout\n+            736GjOyxfi\/\/qXGdGIRFBEFVbivqJn+7kAHjSxm65FSWRQmx1WyRRK2EE46ajA2A\n+            DDL24CejQjBAMA4GA1UdDwEB\/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH\/MB0GA1Ud\n+            DgQWBBTB8Sa6oC2uhYHP0\/EqEr24Cmf9vDAKBggqhkjOPQQDAwNpADBmAjEAgFuk\n+            fCPAlaUs3L6JbyO5o91lAFJekazInXJ0glMLfalAvWhgxeG4VDvBNhcl2MG9AjEA\n+            njWSdIUlUfUk7GRSJFClH9voy8l27OyCbvWFGFPouOOaKaqW04MjyaR7YbPMAuhd\n+            -----END CERTIFICATE-----\"\"\"),\n+\n+    GTS_ROOT_R4(\"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIICCjCCAZGgAwIBAgIQbkepyIuUtui7OyrYorLBmTAKBggqhkjOPQQDAzBHMQsw\n+            CQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExMQzEU\n+            MBIGA1UEAxMLR1RTIFJvb3QgUjQwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIyMDAw\n+            MDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZp\n+            Y2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjQwdjAQBgcqhkjOPQIBBgUrgQQA\n+            IgNiAATzdHOnaItgrkO4NcWBMHtLSZ37wWHO5t5GvWvVYRg1rkDdc\/eJkTBa6zzu\n+            hXyiQHY7qca4R9gq55KRanPpsXI5nymfopjTX15YhmUPoYRlBtHci8nHc8iMai\/l\n+            xKvRHYqjQjBAMA4GA1UdDwEB\/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH\/MB0GA1Ud\n+            DgQWBBSATNbrdP9JNqPV2Py1PsVq8JQdjDAKBggqhkjOPQQDAwNnADBkAjBqUFJ0\n+            CMRw3J5QdCHojXohw0+WbhXRIjVhLfoIN+4Zba3bssx9BzT1YBkstTTZbyACMANx\n+            sbqjYAuG7ZoIapVon+Kz4ZNkfF6Tpt95LY2F45TPI11xzPKwTdb+mciUqXWi4w==\n+            -----END CERTIFICATE-----\"\"\");\n+\n+    final String certStr;\n+\n+    SSLClientContext(String certStr) {\n+        this.certStr = certStr;\n+    }\n+\n+    public static SSLContext createClientSSLContext() throws Exception {\n+        \/\/ Generate certificate from cert string.\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n+        \/\/ Import the trusted certs.\n+        KeyStore ts = KeyStore.getInstance(\"PKCS12\");\n+        ts.load(null, null);\n+        for (SSLClientContext clientContext : SSLClientContext.values()) {\n+            try (ByteArrayInputStream is = new ByteArrayInputStream(\n+                        clientContext.certStr.getBytes())) {\n+                ts.setCertificateEntry(\"trusted-cert-\" +\n+                        clientContext.name(), cf.generateCertificate(is));\n+            }\n+        }\n+\n+        \/\/ Create an SSLContext object.\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ts);\n+\n+        SSLContext context = SSLContext.getInstance(\"TLS\");\n+        context.init(null, tmf.getTrustManagers(), null);\n+\n+        return context;\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLClientContext.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.net.ssl.SSLParameters;\n+\n+\/*\n+ * @test\n+ * @bug 8372526\n+ * @summary Add support for ZLIB TLS Certificate Compression.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DefaultCertCompression\n+ *\/\n+\n+public class DefaultCertCompression extends SSLEngineTemplate {\n+\n+    protected static final int CLI_HELLO_MSG = 1;\n+    protected static final int COMP_CERT_EXT = 27;\n+    \/\/ zlib(1), brotli(2), zstd(3)\n+    protected static final List<Integer> DEFAULT_COMP_ALGS = List.of(1);\n+\n+    protected DefaultCertCompression() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new DefaultCertCompression().runTest(true);\n+        System.setProperty(\"jdk.tls.enableCertificateCompression\", \"false\");\n+        new DefaultCertCompression().runTest(false);\n+    }\n+\n+    protected void runTest(boolean sysPropValue) throws Exception {\n+        SSLParameters params = clientEngine.getSSLParameters();\n+        \/\/ Assert system property was set correctly in SSLParameters,\n+        \/\/ then flip it to test that SSLParameters override the system property\n+        assertEquals(sysPropValue, params.getEnableCertificateCompression());\n+        params.setEnableCertificateCompression(!sysPropValue);\n+        clientEngine.setSSLParameters(params);\n+\n+        \/\/ Produce client_hello\n+        clientEngine.wrap(clientOut, cTOs);\n+        cTOs.flip();\n+\n+        checkClientHello();\n+    }\n+\n+    protected void checkClientHello() throws Exception {\n+        List<Integer> compCertExt = getCompAlgsCliHello(\n+                extractHandshakeMsg(cTOs, CLI_HELLO_MSG, false));\n+\n+        if (clientEngine.getSSLParameters().getEnableCertificateCompression()) {\n+            assertEquals(DEFAULT_COMP_ALGS, compCertExt,\n+                    \"Unexpected compress_certificate extension algorithms: \"\n+                            + compCertExt);\n+        } else {\n+            assertEquals(compCertExt.size(), 0,\n+                    \"compress_certificate extension present in ClientHello\");\n+        }\n+    }\n+\n+    \/**\n+     * Parses the ClientHello message and extracts from it a list of\n+     * compression algorithm values. It is assumed that the provided\n+     * ByteBuffer has its position set at the first byte of the ClientHello\n+     * message body (AFTER the handshake header) and contains the entire\n+     * hello message.  Upon successful completion of this method the ByteBuffer\n+     * will have its position reset to the initial offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data The ByteBuffer containing the ClientHello bytes.\n+     * @return A List of the compression algorithm values.\n+     *\/\n+    protected List<Integer> getCompAlgsCliHello(ByteBuffer data) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Skip over the protocol version and client random\n+        data.position(data.position() + 34);\n+\n+        \/\/ Jump past the session ID (if there is one)\n+        int sessLen = Byte.toUnsignedInt(data.get());\n+        if (sessLen != 0) {\n+            data.position(data.position() + sessLen);\n+        }\n+\n+        \/\/ Jump past the cipher suites\n+        int csLen = Short.toUnsignedInt(data.getShort());\n+        if (csLen != 0) {\n+            data.position(data.position() + csLen);\n+        }\n+\n+        \/\/ ...and the compression\n+        int compLen = Byte.toUnsignedInt(data.get());\n+        if (compLen != 0) {\n+            data.position(data.position() + compLen);\n+        }\n+\n+        List<Integer> extSigAlgs = getCompAlgsFromExt(data);\n+\n+        \/\/ We should be at the end of the ClientHello\n+        data.reset();\n+        return extSigAlgs;\n+    }\n+\n+    \/**\n+     * Gets compression algorithms from the given TLS extension.\n+     * The buffer should be positioned at the start of the extension.\n+     *\/\n+    protected List<Integer> getCompAlgsFromExt(ByteBuffer data) {\n+\n+        List<Integer> extCompAlgs = new ArrayList<>();\n+        data.getShort(); \/\/ read length\n+\n+        while (data.hasRemaining()) {\n+            int extType = Short.toUnsignedInt(data.getShort());\n+            int extLen = Short.toUnsignedInt(data.getShort());\n+\n+            if (extType == COMP_CERT_EXT) {\n+                int sigSchemeLen = data.get();\n+\n+                for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+                    Integer schemeName = Short.toUnsignedInt(data.getShort());\n+                    extCompAlgs.add(schemeName);\n+                }\n+            } else {\n+                \/\/ Not the extension we're looking for.  Skip past the\n+                \/\/ extension data\n+                data.position(data.position() + extLen);\n+            }\n+        }\n+\n+        return extCompAlgs;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/CertificateCompression\/DefaultCertCompression.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"}]}