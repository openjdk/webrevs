{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -34,0 +36,1 @@\n+import java.util.zip.CRC32C;\n@@ -141,0 +144,12 @@\n+        \/\/ Only local certificates are compressed, so it makes sense to store\n+        \/\/ the deflated certificate data in a memory cache statically and avoid\n+        \/\/ compressing local certificates repeatedly for every handshake.\n+        private static final Map<Long, byte[]> CACHE =\n+                new ConcurrentHashMap<>();\n+\n+        \/\/ Limit the size of the cache in case certificate_request_context is\n+        \/\/ randomized (should only happen during post-handshake authentication\n+        \/\/ and only on the client side). Allow 4 cache mappings per algorithm.\n+        private static final int MAX_CACHE_SIZE =\n+                CompressionAlgorithm.values().length * 4;\n+\n@@ -159,2 +174,21 @@\n-            byte[] compressedCertMsg =\n-                    hc.certDeflater.getValue().apply(certMsg);\n+\n+            long key = getCacheKey(certMsg, hc.certDeflater.getKey());\n+            byte[] compressedCertMsg = CACHE.get(key);\n+\n+            if (compressedCertMsg == null) {\n+                compressedCertMsg = hc.certDeflater.getValue().apply(certMsg);\n+\n+                if (CACHE.size() < MAX_CACHE_SIZE) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        SSLLogger.fine(\"Caching CompressedCertificate message\");\n+                    }\n+\n+                    CACHE.put(key, compressedCertMsg);\n+                } else {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        SSLLogger.warning(\"Certificate message cache size limit\"\n+                                + \" of \" + MAX_CACHE_SIZE + \" reached\");\n+                    }\n+                }\n+            }\n+\n@@ -182,0 +216,10 @@\n+\n+        private static long getCacheKey(byte[] input, int algId) {\n+            CRC32C crc32c = new CRC32C();\n+            crc32c.update(input);\n+            \/\/ Upper 32 bits of the 64 bit long returned by CRC32C are not used\n+            \/\/ and set to zero, put input's length and algorithm id there.\n+            return crc32c.getValue()              \/\/ 32 bits\n+                    | (long) input.length << 32   \/\/ 16 bits\n+                    | (long) algId << 48;         \/\/ 16 bits\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CompressedCertificate.java","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -35,1 +34,0 @@\n-import java.util.zip.CRC32C;\n@@ -43,4 +41,2 @@\n-    ZLIB(1, \"zlib\", new ConcurrentHashMap<>(3)),\n-    \/\/ Placeholders, we currently support only ZLIB.\n-    BROTLI(2, \"brotli\", null),\n-    ZSTD(3, \"zstd\", null);\n+    \/\/ Currently only ZLIB is supported.\n+    ZLIB(1, \"zlib\");\n@@ -50,4 +46,0 @@\n-    \/\/ We compress only local certificates, so it's ok to store the\n-    \/\/ deflated certificate data in a memory cache permanently, i.e. such\n-    \/\/ cache is going to be of a manageable size.\n-    final Map<Long, byte[]> cache;          \/\/ Checksum -> deflated data.\n@@ -55,1 +47,1 @@\n-    CompressionAlgorithm(int id, String name, Map<Long, byte[]> cache) {\n+    CompressionAlgorithm(int id, String name) {\n@@ -58,1 +50,0 @@\n-        this.cache = cache;\n@@ -90,1 +81,1 @@\n-            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -105,1 +96,1 @@\n-                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -144,7 +135,4 @@\n-        return Map.of(ZLIB.name, (input) ->\n-                ZLIB.cache.computeIfAbsent(getChecksum(input), _ -> {\n-                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n-                        SSLLogger.info(\"Deflating and caching new \" + ZLIB.name\n-                                + \" certificate data of \" + input.length\n-                                + \" bytes\");\n-                    }\n+        return Map.of(ZLIB.name, (input) -> {\n+            try (Deflater deflater = new Deflater();\n+                    ByteArrayOutputStream outputStream =\n+                            new ByteArrayOutputStream(input.length)) {\n@@ -152,22 +140,18 @@\n-                    try (Deflater deflater = new Deflater();\n-                            ByteArrayOutputStream outputStream =\n-                                    new ByteArrayOutputStream(input.length)) {\n-\n-                        deflater.setInput(input);\n-                        deflater.finish();\n-                        byte[] buffer = new byte[1024];\n-\n-                        while (!deflater.finished()) {\n-                            int compressedSize = deflater.deflate(buffer);\n-                            outputStream.write(buffer, 0, compressedSize);\n-                        }\n-\n-                        return outputStream.toByteArray();\n-                    } catch (Exception e) {\n-                        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n-                            SSLLogger.warning(\"Exception during certificate \"\n-                                    + \"compression: \", e);\n-                        }\n-                        return null;\n-                    }\n-                }));\n+                deflater.setInput(input);\n+                deflater.finish();\n+                byte[] buffer = new byte[1024];\n+\n+                while (!deflater.finished()) {\n+                    int compressedSize = deflater.deflate(buffer);\n+                    outputStream.write(buffer, 0, compressedSize);\n+                }\n+\n+                return outputStream.toByteArray();\n+            } catch (Exception e) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\"Exception during certificate \"\n+                            + \"compression: \", e);\n+                }\n+                return null;\n+            }\n+        });\n@@ -192,1 +176,1 @@\n-                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -200,9 +184,0 @@\n-\n-    \/\/ Fast checksum.\n-    private static long getChecksum(byte[] input) {\n-        CRC32C crc32c = new CRC32C();\n-        crc32c.update(input);\n-        \/\/ The upper 32 bits are not used in the long returned by CRC32C,\n-        \/\/ place input's length there to reduce the chance of collision.\n-        return crc32c.getValue() | (long) input.length << 32;\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CompressionAlgorithm.java","additions":28,"deletions":53,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8372526\n+ * @summary Make sure the same CompressedCertificate message is cached\n+ *          only once.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm CompressedCertMsgCache\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+\n+public class CompressedCertMsgCache extends SSLSocketTemplate {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"javax.net.debug\", \"ssl\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baos);\n+        System.setErr(err);\n+\n+        \/\/ Complete 2 handshakes with the same certificate.\n+        new CompressedCertMsgCache().run();\n+        new CompressedCertMsgCache().run();\n+\n+        err.close();\n+\n+        \/\/ Make sure the same CompressedCertificate message is cached only once\n+        assertEquals(1, countSubstringOccurrences(baos.toString(),\n+                \"Caching CompressedCertificate message\"));\n+    }\n+\n+    protected static int countSubstringOccurrences(String str, String sub) {\n+        if (str == null || sub == null || sub.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int count = 0;\n+        int lastIndex = 0;\n+\n+        while ((lastIndex = str.indexOf(sub, lastIndex)) != -1) {\n+            count++;\n+            lastIndex += sub.length();\n+        }\n+\n+        return count;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/CertificateCompression\/CompressedCertMsgCache.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManagerFactory;\n+import jdk.test.lib.security.CertificateBuilder;\n+\n+\/*\n+ * @test\n+ * @bug 8372526\n+ * @summary Check CompressedCertificate message cache size limit.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm CompressedCertMsgCacheLimit\n+ *\/\n+\n+public class CompressedCertMsgCacheLimit extends CompressedCertMsgCache {\n+\n+    \/\/ Make sure every certificate has random serial number.\n+    private static final SecureRandom RANDOM = new SecureRandom();\n+\n+    private final String protocol;\n+    private final String keyAlg;\n+    private final String certSigAlg;\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate clientCert;\n+    private KeyPair serverKeys;\n+    private KeyPair clientKeys;\n+\n+    protected CompressedCertMsgCacheLimit(\n+            String protocol, String keyAlg,\n+            String certSigAlg) throws Exception {\n+        super();\n+        this.protocol = protocol;\n+        this.keyAlg = keyAlg;\n+        this.certSigAlg = certSigAlg;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"javax.net.debug\", \"ssl\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baos);\n+        System.setErr(err);\n+\n+        \/\/ Complete 6 handshakes, all with different certificates.\n+        for (int i = 0; i < 6; i++) {\n+            new CompressedCertMsgCacheLimit(\n+                    \"TLSv1.3\", \"EC\", \"SHA256withECDSA\").run();\n+        }\n+\n+        err.close();\n+\n+        \/\/ Make sure first 4 CompressedCertificate messages are cached.\n+        assertEquals(4, countSubstringOccurrences(baos.toString(),\n+                \"Caching CompressedCertificate message\"));\n+\n+        \/\/ Last 2 CompressedCertificate messages must not be cached.\n+        assertEquals(2, countSubstringOccurrences(baos.toString(),\n+                \"Certificate message cache size limit of 4 reached\"));\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate(), protocol);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate(), protocol);\n+    }\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey, String protocol)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(protocol);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return ctx;\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(keyAlg);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        this.serverKeys = kpg.generateKeyPair();\n+        this.clientKeys = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys, certSigAlg);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), certSigAlg);\n+\n+        this.clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), certSigAlg);\n+    }\n+\n+    private static X509Certificate createTrustedCert(\n+            KeyPair caKeys, String certSigAlg) throws Exception {\n+        return customCertificateBuilder(\n+                \"O=CA-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(true, true, 1)\n+                .build(null, caKeys.getPrivate(), certSigAlg);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        return new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(BigInteger.valueOf(\n+                        RANDOM.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey)\n+                .addKeyUsageExt(new boolean[]{\n+                        true, true, true, true, true, true, true});\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/CertificateCompression\/CompressedCertMsgCacheLimit.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,3 @@\n+    @Param({\"true\", \"false\"})\n+    boolean certCompression;\n+\n@@ -214,0 +217,1 @@\n+        clientParams.setEnableCertificateCompression(certCompression);\n@@ -218,0 +222,1 @@\n+        serverParams.setEnableCertificateCompression(certCompression);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}