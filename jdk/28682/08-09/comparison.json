{"files":[{"patch":"@@ -153,2 +153,1 @@\n-        private static final int MAX_CACHE_SIZE =\n-                CompressionAlgorithm.values().length * 4;\n+        private static final int CACHE_SIZE_PER_ALG = 4;\n@@ -175,1 +174,2 @@\n-            long key = getCacheKey(certMsg, hc.certDeflater.getKey());\n+            int algId = hc.certDeflater.getKey();\n+            long key = getCacheKey(certMsg, algId);\n@@ -181,1 +181,1 @@\n-                if (CACHE.size() < MAX_CACHE_SIZE) {\n+                if (isUnderCacheLimit(algId)) {\n@@ -189,2 +189,2 @@\n-                        SSLLogger.warning(\"Certificate message cache size limit\"\n-                                + \" of \" + MAX_CACHE_SIZE + \" reached\");\n+                        SSLLogger.warning(\"CompressedCertificate message cache\"\n+                                + \" size limit reached\");\n@@ -217,0 +217,1 @@\n+        \/\/ Generate cache key from the CertificateMessage and algorithm id.\n@@ -226,0 +227,8 @@\n+\n+        \/\/ Returns true if the compression algorithm didn't reach cache limit.\n+        private static boolean isUnderCacheLimit(int algId) {\n+            return CACHE.keySet()\n+                    .stream()\n+                    .filter(k -> (k >> 32 & 0xFFL) == algId)\n+                    .count() < CACHE_SIZE_PER_ALG;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CompressedCertificate.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-                \"Certificate message cache size limit of 4 reached\"));\n+                \"CompressedCertificate message cache size limit reached\"));\n","filename":"test\/jdk\/sun\/security\/ssl\/CertificateCompression\/CompressedCertMsgCacheLimit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}