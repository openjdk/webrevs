{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,4 @@\n-         * See if the event thread is a vthread that we need to start tracking.\n+         * See if the event thread is a vthread that we need to start tracking. Note\n+         * we don't track the thread if it is not going to be suspended because it\n+         * might terminate before we even register the ThreadDeathRequest below,\n+         * which will result in it never being unregistered.\n@@ -107,4 +110,7 @@\n-        if (event instanceof ClassPrepareEvent evt) {\n-            eventThread = evt.thread();\n-        } else if (event instanceof LocatableEvent evt) {\n-            eventThread = evt.thread();\n+        EventRequest req = event.request();\n+        if (req != null && req.suspendPolicy() != EventRequest.SUSPEND_NONE) {\n+            if (event instanceof ClassPrepareEvent evt) {\n+                eventThread = evt.thread();\n+            } else if (event instanceof LocatableEvent evt) {\n+                eventThread = evt.thread();\n+            }\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/EventHandler.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -992,0 +992,2 @@\n+    gdata->virtualThreadStartEventsPermanentlyEnabled = JNI_FALSE;\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1210,0 +1210,9 @@\n+ *\n+ * FIXME - This API does not take into account if there is more than one filter thread.\n+ * As a result the event will end up getting enabled on the thread, but when an event\n+ * comes in, it will (properly) fail the eventFilterRestricted_passesFilter() check,\n+ * and thus (properly) not pass the event on to the debugger. The downside of all this\n+ * is that it was not actually necessary to enable the event on the \"request\" thread.\n+ * However, if we return NULL if there is more than one filter thread, then the result\n+ * is enabling the event on all threads, and we don't want that either. This API needs\n+ * a way to communicate that there was more than one filter thread, so don't enable the event.\n@@ -1246,0 +1255,33 @@\n+\/\/ Returns true if this handler has the PlatformThreadsOnly filter enabled.\n+static jboolean\n+hasPlatformThreadsOnlyFilter(HandlerNode *node)\n+{\n+    int i;\n+    Filter *filter = FILTERS_ARRAY(node);\n+\n+    for (i = 0; i < FILTER_COUNT(node); ++i, ++filter) {\n+        switch (filter->modifier) {\n+            case JDWP_REQUEST_MODIFIER(PlatformThreadsOnly):\n+                return JNI_TRUE;\n+            default:\n+                continue;\n+        }\n+    }\n+    return JNI_FALSE;\n+}\n+\n+\/\/ Used to determine if no handler of the given type have the PlatformThreadsOnly filter.\n+static jboolean\n+matchHasNoPlatformThreadsOnlyFilter(JNIEnv *env, HandlerNode *node, void *arg)\n+{\n+    jthread goalThread = (jthread)arg;\n+    jthread reqThread = requestThread(node); \/\/ the filter thread\n+    if (hasPlatformThreadsOnlyFilter(node)) {\n+        return JNI_FALSE;\n+    } else {\n+        \/\/ If this handler does not have a PlatformThreadsOnly filter, then we\n+        \/\/ only return true if the threads also match, or are both NULL.\n+        return isSameObject(env, reqThread, goalThread);\n+    }\n+}\n+\n@@ -1254,0 +1296,1 @@\n+    int ei = NODE_EI(node);\n@@ -1255,1 +1298,1 @@\n-    switch (NODE_EI(node)) {\n+    switch (ei) {\n@@ -1264,2 +1307,0 @@\n-        case EI_THREAD_START:\n-        case EI_THREAD_END:\n@@ -1269,0 +1310,40 @@\n+            return JVMTI_ERROR_NONE;\n+\n+        case EI_THREAD_END:\n+        case EI_THREAD_START:\n+            \/* JVMTI_EVENT_THREAD_START\/END are always enabled. However, we need to\n+             * conditionally enable JVMTI_EVENT_VIRTUAL_THREAD_START\/END based on\n+             * whether or not there is any handler that does not use the\n+             * PlatformThreadsOnly filter. Note we don't have a separate JDWP\n+             * event type for virtual theads. They use THREAD_START\/END, but\n+             * JVMTI does have different event types for them.\n+             *\/\n+            if (gdata->includeVThreads) {\n+                \/\/ JVMTI_EVENT_VIRTUAL_THREAD_START\/END are already always enabled.\n+                return JVMTI_ERROR_NONE;\n+            }\n+            if (ei == EI_THREAD_START && gdata->virtualThreadStartEventsPermanentlyEnabled) {\n+                \/\/ JVMTI_EVENT_VIRTUAL_THREAD_START is already permanently enabled.\n+                return JVMTI_ERROR_NONE;\n+            }\n+            if (hasPlatformThreadsOnlyFilter(node)) {\n+                \/\/ This request has the filter so would not end up triggering\n+                \/\/ enabling the VIRTUAL events.\n+                return JVMTI_ERROR_NONE;\n+            }\n+\n+            \/\/ This request does not have the filter, so enable VIRTUAL events. It's possible\n+            \/\/ that the events are already enabled, but rather than trying to determine that\n+            \/\/ first, it's a lot easier to just blindly enable them. There's no harm if they\n+            \/\/ were already enabled.\n+            if (ei == EI_THREAD_START) {\n+                error = threadControl_setEventMode(JVMTI_ENABLE, EI_VIRTUAL_THREAD_START, NULL);\n+            } else {\n+                jthread thread = requestThread(node);\n+                error = threadControl_setEventMode(JVMTI_ENABLE, EI_VIRTUAL_THREAD_END, thread);\n+            }\n+            if (error != JVMTI_ERROR_NONE && error != JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                EXIT_ERROR(error, \"enabling VIRTUAL_THREAD_START\/END\");\n+            }\n+            return error;\n+\n@@ -1271,1 +1352,3 @@\n-            return error;\n+            \/\/ These are mapped to EI_THREAD_START\/END so we should never see a handler for them.\n+            JDI_ASSERT(JNI_FALSE);\n+            return JVMTI_ERROR_NONE;\n@@ -1294,4 +1377,2 @@\n-        if (!eventHandlerRestricted_iterator(\n-                NODE_EI(node), matchThread, thread)) {\n-            error = threadControl_setEventMode(JVMTI_ENABLE,\n-                                               NODE_EI(node), thread);\n+        if (!eventHandlerRestricted_iterator(ei, matchThread, thread)) {\n+            error = threadControl_setEventMode(JVMTI_ENABLE, ei, thread);\n@@ -1313,0 +1394,1 @@\n+    int ei = NODE_EI(node);\n@@ -1314,2 +1396,1 @@\n-\n-    switch (NODE_EI(node)) {\n+    switch (ei) {\n@@ -1324,2 +1405,0 @@\n-        case EI_THREAD_START:\n-        case EI_THREAD_END:\n@@ -1329,0 +1408,46 @@\n+            return JVMTI_ERROR_NONE;\n+\n+        case EI_THREAD_START:\n+        case EI_THREAD_END:\n+            \/\/ See comments above in enableEvents() for special handling of virtual thread events.\n+            if (gdata->includeVThreads) {\n+                \/\/ JVMTI_EVENT_VIRTUAL_THREAD_START\/END are already enabled and stay enabled.\n+                return JVMTI_ERROR_NONE;\n+            }\n+            if (ei == EI_THREAD_START && gdata->virtualThreadStartEventsPermanentlyEnabled) {\n+                \/\/ JVMTI_EVENT_VIRTUAL_THREAD_START is already permanently enabled.\n+                return JVMTI_ERROR_NONE;\n+            }\n+            if (hasPlatformThreadsOnlyFilter(node)) {\n+                \/\/ This request has the filter, so removing it would not end up\n+                \/\/ triggering disabling the virtual thread events.\n+                return JVMTI_ERROR_NONE;\n+            }\n+\n+            jthread thread = requestThread(node);\n+            \/\/ Unlike when enabling events, we can't just blindly disable them here.\n+            \/\/ If, other than this handler, there are one or more handlers that require\n+            \/\/ events to be enabled, then we need to keep them enabled, so we need to\n+            \/\/ check all the other handlers.\n+            \/\/\n+            \/\/ One thing important to note when we call eventHandlerRestricted_iterator()\n+            \/\/ below is that \"node\" has already been removed from the event handler list,\n+            \/\/ so it won't show up during the iteration.\n+            if (!eventHandlerRestricted_iterator(ei, matchHasNoPlatformThreadsOnlyFilter, thread)) {\n+                \/\/ This request doesn't have the filter, but all the other existing\n+                \/\/ requests do, so we should disable the event because none of the\n+                \/\/ remaining requests rely on it.\n+                if (ei == EI_THREAD_START) {\n+                    error = threadControl_setEventMode(JVMTI_DISABLE, EI_VIRTUAL_THREAD_START, NULL);\n+                } else {\n+                    error = threadControl_setEventMode(JVMTI_DISABLE, EI_VIRTUAL_THREAD_END, thread);\n+                }\n+                \/\/tty_message(\"DISABLE:(%d) DISABLED - all nodes have filters\", ei);\n+            } else {\n+                \/\/tty_message(\"DISABLE:(%d) NO ACTION - at least one node with the filter\", ei);\n+            }\n+            if (error != JVMTI_ERROR_NONE) {\n+                EXIT_ERROR(error, \"disabling VIRTUAL_THREAD_START\/END\");\n+            }\n+            return error;\n+\n@@ -1331,1 +1456,3 @@\n-            return error;\n+            \/\/ These are mapped to EI_THREAD_START\/END so we should never see a handler for them.\n+            JDI_ASSERT(JNI_FALSE);\n+            return JVMTI_ERROR_NONE;\n@@ -1354,3 +1481,2 @@\n-    if (!eventHandlerRestricted_iterator(NODE_EI(node), matchThread, thread)) {\n-        error2 = threadControl_setEventMode(JVMTI_DISABLE,\n-                                            NODE_EI(node), thread);\n+    if (!eventHandlerRestricted_iterator(ei, matchThread, thread)) {\n+        error2 = threadControl_setEventMode(JVMTI_DISABLE, ei, thread);\n@@ -1358,1 +1484,1 @@\n-    return error != JVMTI_ERROR_NONE? error : error2;\n+    return error != JVMTI_ERROR_NONE ? error : error2;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventFilter.c","additions":144,"deletions":18,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1643,23 +1643,0 @@\n-    debugMonitorEnter(handlerLock);\n-\n-    \/*\n-     * Enable vthread START and END events if they are not already always enabled.\n-     * They are always enabled if we are remembering vthreads when no debugger is\n-     * connected. Otherwise they are only enabled when connected because they can\n-     * be very noisy and hurt performance a lot.\n-     *\/\n-    if (gdata->vthreadsSupported && !gdata->rememberVThreadsWhenDisconnected) {\n-        jvmtiError error;\n-        error = threadControl_setEventMode(JVMTI_ENABLE,\n-                                           EI_VIRTUAL_THREAD_START, NULL);\n-        if (error != JVMTI_ERROR_NONE) {\n-            EXIT_ERROR(error,\"Can't enable vthread start events\");\n-        }\n-        error = threadControl_setEventMode(JVMTI_ENABLE,\n-                                           EI_VIRTUAL_THREAD_END, NULL);\n-        if (error != JVMTI_ERROR_NONE) {\n-            EXIT_ERROR(error,\"Can't enable vthread end events\");\n-        }\n-    }\n-\n-    debugMonitorExit(handlerLock);\n@@ -1711,0 +1688,13 @@\n+    \/* We also want to disable VIRTUAL_THREAD_START events if they were enabled due to\n+     * a deferred event request.\n+     *\/\n+    if (gdata->virtualThreadStartEventsPermanentlyEnabled) {\n+        jvmtiError error;\n+        error = threadControl_setEventMode(JVMTI_DISABLE,\n+                                           EI_VIRTUAL_THREAD_START, NULL);\n+        if (adjust_jvmti_error(error) != JVMTI_ERROR_NONE) {\n+            EXIT_ERROR(error,\"Can't disable vthread start events\");\n+        }\n+        gdata->virtualThreadStartEventsPermanentlyEnabled = JNI_FALSE;\n+    }\n+\n@@ -1934,1 +1924,3 @@\n-    tty_message(\"Handler for %s(%d)\\n\", eventIndex2EventName(node->ei), node->ei);\n+    tty_message(\"handlerID(%d) for %s(%d) suspendPolicy(%d) permanent(%d)\",\n+                node->handlerID, eventIndex2EventName(node->ei), node->ei,\n+                node->suspendPolicy, node->permanent);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -897,0 +897,7 @@\n+        jint state = getThreadState(thread);\n+        if (state & JVMTI_THREAD_STATE_TERMINATED) {\n+            \/\/ If this thread has terminated, there is no need to do any of the\n+            \/\/ below, and doing so would produce errors.\n+            return;\n+        }\n+\n@@ -905,1 +912,0 @@\n-            jint state = getThreadState(thread);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/stepControl.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+static void dumpThread(ThreadNode *node);\n+static void dumpThreadList(ThreadList *list);\n+\n@@ -160,5 +163,14 @@\n-    if ( error == JVMTI_ERROR_THREAD_NOT_ALIVE && node == NULL) {\n-        \/* Just return. This can happen when clearing the TLS. *\/\n-        return;\n-    } else if ( error != JVMTI_ERROR_NONE ) {\n-        \/* The jthread object must be valid, so this must be a fatal error *\/\n+    if (error == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+        if (node == NULL) {\n+            \/\/ Just return. This can happen when clearing the TLS.\n+            return;\n+        }\n+        if (isVThread(thread)) {\n+            \/\/ Just return. This can happen with a vthread that is running and we\n+            \/\/ had to create a ThreadNode for it. By the time we get here, it may\n+            \/\/ have already terminated.\n+            return;\n+        }\n+    }\n+    if (error != JVMTI_ERROR_NONE) {\n+        \/\/ The jthread object must be valid, so this must be a fatal error.\n@@ -254,1 +266,3 @@\n-            \/* The thread better not be on either list if the TLS lookup failed. *\/\n+            \/\/ The thread better not be on the runningThreads list if the TLS lookup failed.\n+            \/\/ It might be on the runningVThreads list because VIRTUAL_THREAD_END events\n+            \/\/ might not be enabled, so we don't check runningVThreads.\n@@ -256,1 +270,0 @@\n-            JDI_ASSERT(!nonTlsSearch(getEnv(), &runningVThreads, thread));\n@@ -323,1 +336,1 @@\n-            \/\/ in the future we won't be enabling VIRTUAL_THREAD_START events in some\n+            \/\/ we won't be enabling VIRTUAL_THREAD_START events in some\n@@ -559,0 +572,20 @@\n+    \/*\n+     * We are about to do a bunch of checks to see if the ThreadNode is holding\n+     * on to any important thread state information. If it is, then we can't\n+     * free it. However, sometimes this state information is still present even\n+     * after the thread has termintated. In this case the state information\n+     * is no longer relevant and we can still free the ThreadNode, so the first\n+     * thing we do is check if the thread is termintated, and bypass all the\n+     * other checks if it is.\n+     *\/\n+    jint vthread_state = 0;\n+    jvmtiError error = threadState(node->thread, &vthread_state);\n+    if (error != JVMTI_ERROR_NONE) {\n+        EXIT_ERROR(error, \"getting vthread state\");\n+    }\n+    if ((vthread_state & JVMTI_THREAD_STATE_TERMINATED) != 0) {\n+        removeNode(node);\n+        clearThread(env, node);\n+        return;\n+    }\n+\n@@ -660,0 +693,12 @@\n+\n+\/*\n+ * DeferredEventMode:  Deferred event mode support\n+ *\n+ * JDWP allows filtering of events by thread. This is allowed after the thread has been\n+ * created, even if it has not been started yet. However, JVMTI does not allow enabling\n+ * events for a specific thread before the thread has started. If an EventRequest is made\n+ * with thread filtering enabled, and this is done  before the thread is running, we must\n+ * defer the enabling of the JVMTI event until the THREAD_START event is received. The\n+ * code below supports this deferred event enabling.\n+ *\/\n+\n@@ -700,0 +745,26 @@\n+\n+    \/*\n+     * Deferred event mode handling relies on getting a THREAD_START event or\n+     * VIRTUAL_THREAD_START event to trigger the enabling of the event. THREAD_START\n+     * is always enabled, but VIRTUAL_THREAD_START may not be. So that means if\n+     * there is a deferred event mode request for a virtual thread, we must make\n+     * sure VIRTUAL_THREAD_START events are enabled.\n+     *\n+     * Since it is not common to enable events on a thread that has not yet been\n+     * started, we choose to just permanently enable VIRTUAL_THREAD_START events\n+     * when needed here. A more elegant solution would also disable them when\n+     * the deferred event mode is dequeued and processed, but that comes with\n+     * complications. We'd not only need to make sure that there are no other\n+     * deferred event modes queue up for virtual threads, but we'd also need to\n+     * make sure that there are no event handlers (event requests) for THREAD_START\n+     * events that do not have the PlatformThreadsFilter enabled.\n+     *\/\n+    if (!gdata->includeVThreads && !gdata->virtualThreadStartEventsPermanentlyEnabled && isVThread(thread)) {\n+        jvmtiError error = JVMTI_FUNC_PTR(gdata->jvmti,SetEventNotificationMode)\n+                (gdata->jvmti, JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+        if (error != JVMTI_ERROR_NONE) {\n+            EXIT_ERROR(error, \"cannot enable JVMTI_EVENT_VIRTUAL_THREAD_START\");\n+        }\n+        gdata->virtualThreadStartEventsPermanentlyEnabled = JNI_TRUE;\n+    }\n+\n@@ -1243,0 +1314,1 @@\n+        jthread thread = reqList[i];\n@@ -1244,1 +1316,1 @@\n-        node = findRunningThread(reqList[i]);\n+        node = findRunningThread(thread);\n@@ -1246,1 +1318,18 @@\n-            EXIT_ERROR(AGENT_ERROR_INVALID_THREAD,\"missing entry in running thread table\");\n+            node = nonTlsSearch(getEnv(), &runningVThreads, thread);\n+            if (node != NULL) {\n+                \/\/ This means the vthread has terminated already. This can only happen\n+                \/\/ with vthreads since VIRTUAL_THREAD_END events might not be enable to\n+                \/\/ trigger removal of the ThreadNode when the thread exits. Just assert\n+                \/\/ that the thread is in the TERMINATED state. The ThreadNode will\n+                \/\/ eventually be removed by freeUnusedVThreadNodes().\n+                if (gdata->assertOn) {\n+                    jint vthread_state = 0;\n+                    jvmtiError error = threadState(thread, &vthread_state);\n+                    if (error != JVMTI_ERROR_NONE) {\n+                        EXIT_ERROR(error, \"getting vthread state\");\n+                    }\n+                    JDI_ASSERT((vthread_state & JVMTI_THREAD_STATE_TERMINATED) != 0);\n+                }\n+            } else {\n+                EXIT_ERROR(AGENT_ERROR_INVALID_THREAD,\"missing entry in running thread table\");\n+            }\n@@ -1551,2 +1640,1 @@\n-            \/\/ Now is a good time to garbage collect vthread nodes. We want to do it before\n-            \/\/ any suspendAll because it will prevent the suspended nodes from being freed.\n+            \/\/ Now is a good time to garbage collect vthread nodes.\n@@ -2719,3 +2807,0 @@\n-static void dumpThreadList(ThreadList *list);\n-static void dumpThread(ThreadNode *node);\n-\n@@ -2809,0 +2894,8 @@\n+    tty_message(\"\\tcurrentStep.pending: %d\", node->currentStep.pending);\n+    tty_message(\"\\tinstructionStepMode: %d\", node->instructionStepMode);\n+    tty_message(\"\\tcurrent_ei: %d\", node->current_ei);\n+    tty_message(\"\\tcleInfo.ei: %d\", node->cleInfo.ei);\n+    tty_message(\"\\tpopFrameEvent: %d\", node->popFrameEvent);\n+    tty_message(\"\\tpopFrameProceed: %d\", node->popFrameProceed);\n+    tty_message(\"\\tpopFrameThread: %d\", node->popFrameThread);\n+    tty_message(\"\\tpendingStop: 0x%x\", node->pendingStop);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":108,"deletions":15,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    jboolean virtualThreadStartEventsPermanentlyEnabled;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}