{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,12 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.ConstantValueEntry;\n+import java.lang.classfile.constantpool.IntegerEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -91,57 +103,0 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Annotation;\n-import com.sun.tools.classfile.Annotation.Annotation_element_value;\n-import com.sun.tools.classfile.Annotation.Array_element_value;\n-import com.sun.tools.classfile.Annotation.Class_element_value;\n-import com.sun.tools.classfile.Annotation.Enum_element_value;\n-import com.sun.tools.classfile.Annotation.Primitive_element_value;\n-import com.sun.tools.classfile.Annotation.element_value;\n-import com.sun.tools.classfile.Annotation.element_value_pair;\n-import com.sun.tools.classfile.AnnotationDefault_attribute;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Double_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Float_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Integer_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Long_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Module_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Package_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_String_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ConstantPool.InvalidIndex;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.ConstantValue_attribute;\n-import com.sun.tools.classfile.Deprecated_attribute;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Exceptions_attribute;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.InnerClasses_attribute;\n-import com.sun.tools.classfile.InnerClasses_attribute.Info;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.ModulePackages_attribute;\n-import com.sun.tools.classfile.MethodParameters_attribute;\n-import com.sun.tools.classfile.ModuleMainClass_attribute;\n-import com.sun.tools.classfile.ModuleResolution_attribute;\n-import com.sun.tools.classfile.ModuleTarget_attribute;\n-import com.sun.tools.classfile.Module_attribute;\n-import com.sun.tools.classfile.Module_attribute.ExportsEntry;\n-import com.sun.tools.classfile.Module_attribute.OpensEntry;\n-import com.sun.tools.classfile.Module_attribute.ProvidesEntry;\n-import com.sun.tools.classfile.Module_attribute.RequiresEntry;\n-import com.sun.tools.classfile.NestHost_attribute;\n-import com.sun.tools.classfile.NestMembers_attribute;\n-import com.sun.tools.classfile.PermittedSubclasses_attribute;\n-import com.sun.tools.classfile.Record_attribute;\n-import com.sun.tools.classfile.Record_attribute.ComponentInfo;\n-import com.sun.tools.classfile.RuntimeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.Signature_attribute;\n@@ -157,0 +112,3 @@\n+import static java.lang.classfile.ClassFile.ACC_PROTECTED;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+\n@@ -162,2 +120,1 @@\n- *  * <jdk-N>\/bin\/java --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED \\\n- *                     --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n+ *  * <jdk-N>\/bin\/java --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n@@ -412,1 +369,1 @@\n-                            throw new IllegalStateException(\"Unknown key: \" + reader.lineKey);\n+                            throw new IllegalArgumentException(\"Unknown key: \" + reader.lineKey);\n@@ -435,1 +392,1 @@\n-                        throw new IllegalStateException(\"Unknown key: \" + reader.lineKey);\n+                        throw new IllegalArgumentException(\"Unknown key: \" + reader.lineKey);\n@@ -833,24 +790,4 @@\n-        List<CPInfo> constantPool = new ArrayList<>();\n-        constantPool.add(null);\n-        int currentClass = addClass(constantPool, \"module-info\");\n-        int superclass = 0;\n-        int[] interfaces = new int[0];\n-        AccessFlags flags = new AccessFlags(header.flags);\n-        Map<String, Attribute> attributesMap = new HashMap<>();\n-        String versionString = Character.toString(version);\n-        addAttributes(moduleDescription, header, constantPool, attributesMap,\n-                      version2ModuleVersion.apply(version));\n-        Attributes attributes = new Attributes(attributesMap);\n-        CPInfo[] cpData = constantPool.toArray(new CPInfo[constantPool.size()]);\n-        ConstantPool cp = new ConstantPool(cpData);\n-        ClassFile classFile = new ClassFile(0xCAFEBABE,\n-                Target.DEFAULT.minorVersion,\n-                Target.DEFAULT.majorVersion,\n-                cp,\n-                flags,\n-                currentClass,\n-                superclass,\n-                interfaces,\n-                new Field[0],\n-                new Method[0],\n-                attributes);\n+        var classFile = ClassFile.of().build(ClassDesc.of(\"module-info\"), clb -> {\n+            clb.withFlags(header.flags);\n+            addAttributes(moduleDescription, header, clb, version2ModuleVersion.apply(version));\n+        });\n@@ -858,0 +795,1 @@\n+        String versionString = Character.toString(version);\n@@ -866,51 +804,20 @@\n-        List<CPInfo> constantPool = new ArrayList<>();\n-        constantPool.add(null);\n-        List<Method> methods = new ArrayList<>();\n-        for (MethodDescription methDesc : classDescription.methods) {\n-            if (disjoint(methDesc.versions, version))\n-                continue;\n-            Descriptor descriptor = new Descriptor(addString(constantPool, methDesc.descriptor));\n-            \/\/TODO: LinkedHashMap to avoid param annotations vs. Signature problem in javac's ClassReader:\n-            Map<String, Attribute> attributesMap = new LinkedHashMap<>();\n-            addAttributes(methDesc, constantPool, attributesMap);\n-            Attributes attributes = new Attributes(attributesMap);\n-            AccessFlags flags = new AccessFlags(methDesc.flags);\n-            int nameString = addString(constantPool, methDesc.name);\n-            methods.add(new Method(flags, nameString, descriptor, attributes));\n-        }\n-        List<Field> fields = new ArrayList<>();\n-        for (FieldDescription fieldDesc : classDescription.fields) {\n-            if (disjoint(fieldDesc.versions, version))\n-                continue;\n-            Descriptor descriptor = new Descriptor(addString(constantPool, fieldDesc.descriptor));\n-            Map<String, Attribute> attributesMap = new HashMap<>();\n-            addAttributes(fieldDesc, constantPool, attributesMap);\n-            Attributes attributes = new Attributes(attributesMap);\n-            AccessFlags flags = new AccessFlags(fieldDesc.flags);\n-            int nameString = addString(constantPool, fieldDesc.name);\n-            fields.add(new Field(flags, nameString, descriptor, attributes));\n-        }\n-        int currentClass = addClass(constantPool, classDescription.name);\n-        int superclass = header.extendsAttr != null ? addClass(constantPool, header.extendsAttr) : 0;\n-        int[] interfaces = new int[header.implementsAttr.size()];\n-        int i = 0;\n-        for (String intf : header.implementsAttr) {\n-            interfaces[i++] = addClass(constantPool, intf);\n-        }\n-        AccessFlags flags = new AccessFlags(header.flags);\n-        Map<String, Attribute> attributesMap = new HashMap<>();\n-        addAttributes(header, constantPool, attributesMap);\n-        Attributes attributes = new Attributes(attributesMap);\n-        ConstantPool cp = new ConstantPool(constantPool.toArray(new CPInfo[constantPool.size()]));\n-        ClassFile classFile = new ClassFile(0xCAFEBABE,\n-                Target.DEFAULT.minorVersion,\n-                Target.DEFAULT.majorVersion,\n-                cp,\n-                flags,\n-                currentClass,\n-                superclass,\n-                interfaces,\n-                fields.toArray(new Field[0]),\n-                methods.toArray(new Method[0]),\n-                attributes);\n-\n+        var classFile = ClassFile.of().build(ClassDesc.ofInternalName(classDescription.name), clb -> {\n+            if (header.extendsAttr != null)\n+                clb.withSuperclass(ClassDesc.ofInternalName(header.extendsAttr));\n+            clb.withInterfaceSymbols(header.implementsAttr.stream().map(ClassDesc::ofInternalName).collect(Collectors.toList()))\n+                    .withFlags(header.flags);\n+            for (FieldDescription fieldDesc : classDescription.fields) {\n+                if (disjoint(fieldDesc.versions, version))\n+                    continue;\n+                clb.withField(fieldDesc.name, ClassDesc.ofDescriptor(fieldDesc.descriptor), fb -> {\n+                    addAttributes(fieldDesc, fb);\n+                    fb.withFlags(fieldDesc.flags);\n+                });\n+            }\n+            for (MethodDescription methDesc : classDescription.methods) {\n+                if (disjoint(methDesc.versions, version))\n+                    continue;\n+                clb.withMethod(methDesc.name, MethodTypeDesc.ofDescriptor(methDesc.descriptor), methDesc.flags, mb -> addAttributes(methDesc, mb));\n+            }\n+            addAttributes(header, clb);\n+        });\n@@ -924,1 +831,1 @@\n-                         ClassFile classFile) throws IOException {\n+                         byte[] classFile) throws IOException {\n@@ -929,8 +836,2 @@\n-        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n-            ClassWriter w = new ClassWriter();\n-\n-            w.write(classFile, out);\n-\n-            openDirectory(directory2FileData, directory)\n-                .add(new FileData(fullFileName, out.toByteArray()));\n-        }\n+        openDirectory(directory2FileData, directory)\n+                .add(new FileData(fullFileName, classFile));\n@@ -958,2 +859,1 @@\n-                               List<CPInfo> cp,\n-                               Map<String, Attribute> attributes,\n+                               ClassBuilder builder,\n@@ -961,1 +861,1 @@\n-        addGenericAttributes(header, cp, attributes);\n+        addGenericAttributes(header, builder);\n@@ -963,5 +863,1 @@\n-            int attrIdx = addString(cp, Attribute.ModuleResolution);\n-            final ModuleResolution_attribute resIdx =\n-                    new ModuleResolution_attribute(attrIdx,\n-                                                   header.moduleResolution);\n-            attributes.put(Attribute.ModuleResolution, resIdx);\n+            builder.with(ModuleResolutionAttribute.of(header.moduleResolution));\n@@ -970,4 +866,1 @@\n-            int attrIdx = addString(cp, Attribute.ModuleTarget);\n-            int targetIdx = addString(cp, header.moduleTarget);\n-            attributes.put(Attribute.ModuleTarget,\n-                           new ModuleTarget_attribute(attrIdx, targetIdx));\n+            builder.with(ModuleTargetAttribute.of(header.moduleTarget));\n@@ -976,58 +869,1 @@\n-            int attrIdx = addString(cp, Attribute.ModuleMainClass);\n-            int targetIdx = addClassName(cp, header.moduleMainClass);\n-            attributes.put(Attribute.ModuleMainClass,\n-                           new ModuleMainClass_attribute(attrIdx, targetIdx));\n-        }\n-        int versionIdx = addString(cp, moduleVersion);\n-        int attrIdx = addString(cp, Attribute.Module);\n-        attributes.put(Attribute.Module,\n-                       new Module_attribute(attrIdx,\n-                             addModuleName(cp, md.name),\n-                             0,\n-                             versionIdx,\n-                             header.requires\n-                                   .stream()\n-                                   .map(r -> createRequiresEntry(cp, r))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new RequiresEntry[0]),\n-                             header.exports\n-                                   .stream()\n-                                   .map(e -> createExportsEntry(cp, e))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new ExportsEntry[0]),\n-                             header.opens\n-                                   .stream()\n-                                   .map(e -> createOpensEntry(cp, e))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new OpensEntry[0]),\n-                             header.uses\n-                                   .stream()\n-                                   .mapToInt(u -> addClassName(cp, u))\n-                                   .toArray(),\n-                             header.provides\n-                                   .stream()\n-                                   .map(p -> createProvidesEntry(cp, p))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new ProvidesEntry[0])));\n-        addInnerClassesAttribute(header, cp, attributes);\n-    }\n-\n-    private static RequiresEntry createRequiresEntry(List<CPInfo> cp,\n-            RequiresDescription r) {\n-        final int idx = addModuleName(cp, r.moduleName);\n-        return new RequiresEntry(idx,\n-                                 r.flags,\n-                                 r.version != null\n-                                         ? addString(cp, r.version)\n-                                         : 0);\n-    }\n-\n-    private static ExportsEntry createExportsEntry(List<CPInfo> cp,\n-                                                   ExportsDescription export) {\n-        int[] to;\n-        if (export.isQualified()) {\n-            to = export.to.stream()\n-                          .mapToInt(module -> addModuleName(cp, module))\n-                          .toArray();\n-        } else {\n-            to = new int[0];\n+            builder.with(ModuleMainClassAttribute.of(ClassDesc.ofInternalName(header.moduleMainClass)));\n@@ -1035,14 +871,24 @@\n-        return new ExportsEntry(addPackageName(cp, export.packageName()), 0, to);\n-    }\n-\n-    private static OpensEntry createOpensEntry(List<CPInfo> cp, String e) {\n-        return new OpensEntry(addPackageName(cp, e), 0, new int[0]);\n-    }\n-\n-    private static ProvidesEntry createProvidesEntry(List<CPInfo> cp,\n-            ModuleHeaderDescription.ProvidesDescription p) {\n-        final int idx = addClassName(cp, p.interfaceName);\n-        return new ProvidesEntry(idx, p.implNames\n-                                       .stream()\n-                                       .mapToInt(i -> addClassName(cp, i))\n-                                       .toArray());\n+        builder.with(ModuleAttribute.of(ModuleDesc.of(md.name), mb -> {\n+            mb.moduleVersion(moduleVersion);\n+            for (var req : header.requires) {\n+                mb.requires(ModuleDesc.of(req.moduleName), req.flags, req.version); \/\/ nullable version\n+            }\n+            for (var exp : header.exports) {\n+                if (exp.isQualified()) {\n+                    mb.exports(PackageDesc.ofInternalName(exp.packageName()), 0, exp.to.stream().map(ModuleDesc::of).toArray(ModuleDesc[]::new));\n+                } else {\n+                    mb.exports(PackageDesc.ofInternalName(exp.packageName()), 0);\n+                }\n+            }\n+            for (var open : header.opens) {\n+                mb.opens(PackageDesc.ofInternalName(open), 0);\n+            }\n+            for (var use : header.uses) {\n+                mb.uses(ClassDesc.ofInternalName(use));\n+            }\n+            for (var provide : header.provides) {\n+                mb.provides(ClassDesc.ofInternalName(provide.interfaceName),\n+                        provide.implNames.stream().map(ClassDesc::ofInternalName).toArray(ClassDesc[]::new));\n+            }\n+        }));\n+        addInnerClassesAttribute(header, builder);\n@@ -1051,3 +897,2 @@\n-    private void addAttributes(ClassHeaderDescription header,\n-            List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n-        addGenericAttributes(header, constantPool, attributes);\n+    private void addAttributes(ClassHeaderDescription header, ClassBuilder builder) {\n+        addGenericAttributes(header, builder);\n@@ -1055,4 +900,1 @@\n-            int attributeString = addString(constantPool, Attribute.NestHost);\n-            int nestHost = addClass(constantPool, header.nestHost);\n-            attributes.put(Attribute.NestHost,\n-                           new NestHost_attribute(attributeString, nestHost));\n+            builder.with(NestHostAttribute.of(ClassDesc.ofInternalName(header.nestHost)));\n@@ -1061,8 +903,1 @@\n-            int attributeString = addString(constantPool, Attribute.NestMembers);\n-            int[] nestMembers = new int[header.nestMembers.size()];\n-            int i = 0;\n-            for (String intf : header.nestMembers) {\n-                nestMembers[i++] = addClass(constantPool, intf);\n-            }\n-            attributes.put(Attribute.NestMembers,\n-                           new NestMembers_attribute(attributeString, nestMembers));\n+            builder.with(NestMembersAttribute.ofSymbols(header.nestMembers.stream().map(ClassDesc::ofInternalName).collect(Collectors.toList())));\n@@ -1071,14 +906,5 @@\n-            assert header.recordComponents != null;\n-            int attributeString = addString(constantPool, Attribute.Record);\n-            ComponentInfo[] recordComponents = new ComponentInfo[header.recordComponents.size()];\n-            int i = 0;\n-            for (RecordComponentDescription rcd : header.recordComponents) {\n-                int name = addString(constantPool, rcd.name);\n-                Descriptor desc = new Descriptor(addString(constantPool, rcd.descriptor));\n-                Map<String, Attribute> nestedAttrs = new HashMap<>();\n-                addGenericAttributes(rcd, constantPool, nestedAttrs);\n-                Attributes attrs = new Attributes(nestedAttrs);\n-                recordComponents[i++] = new ComponentInfo(name, desc, attrs);\n-            }\n-            attributes.put(Attribute.Record,\n-                           new Record_attribute(attributeString, recordComponents));\n+            builder.with(RecordAttribute.of(header.recordComponents.stream().map(desc -> {\n+                List<Attribute<?>> attributes = new ArrayList<>();\n+                addGenericAttributes(desc, attributes::add, builder.constantPool());\n+                return RecordComponentInfo.of(desc.name, ClassDesc.ofDescriptor(desc.descriptor), attributes);\n+            }).collect(Collectors.toList())));\n@@ -1087,8 +913,1 @@\n-            int attributeString = addString(constantPool, Attribute.PermittedSubclasses);\n-            int[] subclasses = new int[header.permittedSubclasses.size()];\n-            int i = 0;\n-            for (String intf : header.permittedSubclasses) {\n-                subclasses[i++] = addClass(constantPool, intf);\n-            }\n-            attributes.put(Attribute.PermittedSubclasses,\n-                    new PermittedSubclasses_attribute(attributeString, subclasses));\n+            builder.with(PermittedSubclassesAttribute.ofSymbols(header.permittedSubclasses.stream().map(ClassDesc::ofInternalName).collect(Collectors.toList())));\n@@ -1096,1 +915,1 @@\n-        addInnerClassesAttribute(header, constantPool, attributes);\n+        addInnerClassesAttribute(header, builder);\n@@ -1099,2 +918,1 @@\n-    private void addInnerClassesAttribute(HeaderDescription header,\n-            List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n+    private void addInnerClassesAttribute(HeaderDescription header, ClassBuilder builder) {\n@@ -1102,12 +920,7 @@\n-            Info[] innerClasses = new Info[header.innerClasses.size()];\n-            int i = 0;\n-            for (InnerClassInfo info : header.innerClasses) {\n-                innerClasses[i++] =\n-                        new Info(info.innerClass == null ? 0 : addClass(constantPool, info.innerClass),\n-                                 info.outerClass == null ? 0 : addClass(constantPool, info.outerClass),\n-                                 info.innerClassName == null ? 0 : addString(constantPool, info.innerClassName),\n-                                 new AccessFlags(info.innerClassFlags));\n-            }\n-            int attributeString = addString(constantPool, Attribute.InnerClasses);\n-            attributes.put(Attribute.InnerClasses,\n-                           new InnerClasses_attribute(attributeString, innerClasses));\n+            builder.with(InnerClassesAttribute.of(header.innerClasses.stream()\n+                    .map(info -> java.lang.classfile.attribute.InnerClassInfo.of(\n+                            ClassDesc.ofInternalName(info.innerClass),\n+                            Optional.ofNullable(info.outerClass).map(ClassDesc::ofInternalName),\n+                            Optional.ofNullable(info.innerClassName),\n+                            info.innerClassFlags\n+                    )).collect(Collectors.toList())));\n@@ -1117,2 +930,2 @@\n-    private void addAttributes(MethodDescription desc, List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n-        addGenericAttributes(desc, constantPool, attributes);\n+    private void addAttributes(MethodDescription desc, MethodBuilder builder) {\n+        addGenericAttributes(desc, builder);\n@@ -1120,8 +933,2 @@\n-            int[] exceptions = new int[desc.thrownTypes.size()];\n-            int i = 0;\n-            for (String exc : desc.thrownTypes) {\n-                exceptions[i++] = addClass(constantPool, exc);\n-            }\n-            int attributeString = addString(constantPool, Attribute.Exceptions);\n-            attributes.put(Attribute.Exceptions,\n-                           new Exceptions_attribute(attributeString, exceptions));\n+            builder.with(ExceptionsAttribute.ofSymbols(desc.thrownTypes.stream()\n+                    .map(ClassDesc::ofInternalName).collect(Collectors.toList())));\n@@ -1130,5 +937,1 @@\n-            int attributeString = addString(constantPool, Attribute.AnnotationDefault);\n-            element_value attributeValue = createAttributeValue(constantPool,\n-                                                                desc.annotationDefaultValue);\n-            attributes.put(Attribute.AnnotationDefault,\n-                           new AnnotationDefault_attribute(attributeString, attributeValue));\n+            builder.with(AnnotationDefaultAttribute.of(createAttributeValue(desc.annotationDefaultValue)));\n@@ -1137,7 +940,1 @@\n-            int attributeString =\n-                    addString(constantPool, Attribute.RuntimeInvisibleParameterAnnotations);\n-            Annotation[][] annotations =\n-                    createParameterAnnotations(constantPool, desc.classParameterAnnotations);\n-            attributes.put(Attribute.RuntimeInvisibleParameterAnnotations,\n-                           new RuntimeInvisibleParameterAnnotations_attribute(attributeString,\n-                                   annotations));\n+            builder.with(RuntimeInvisibleParameterAnnotationsAttribute.of(createParameterAnnotations(desc.classParameterAnnotations)));\n@@ -1146,7 +943,1 @@\n-            int attributeString =\n-                    addString(constantPool, Attribute.RuntimeVisibleParameterAnnotations);\n-            Annotation[][] annotations =\n-                    createParameterAnnotations(constantPool, desc.runtimeParameterAnnotations);\n-            attributes.put(Attribute.RuntimeVisibleParameterAnnotations,\n-                           new RuntimeVisibleParameterAnnotations_attribute(attributeString,\n-                                   annotations));\n+            builder.with(RuntimeVisibleParameterAnnotationsAttribute.of(createParameterAnnotations(desc.runtimeParameterAnnotations)));\n@@ -1155,11 +946,2 @@\n-            int attributeString =\n-                    addString(constantPool, Attribute.MethodParameters);\n-            MethodParameters_attribute.Entry[] entries =\n-                    desc.methodParameters\n-                        .stream()\n-                        .map(p -> new MethodParameters_attribute.Entry(p.name == null || p.name.isEmpty() ? 0\n-                                                                                                          : addString(constantPool, p.name),\n-                                                                       p.flags))\n-                        .toArray(s -> new MethodParameters_attribute.Entry[s]);\n-            attributes.put(Attribute.MethodParameters,\n-                           new MethodParameters_attribute(attributeString, entries));\n+            builder.with(MethodParametersAttribute.of(desc.methodParameters.stream()\n+                    .map(mp -> MethodParameterInfo.ofParameter(Optional.ofNullable(mp.name), mp.flags)).collect(Collectors.toList())));\n@@ -1169,2 +951,2 @@\n-    private void addAttributes(FieldDescription desc, List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n-        addGenericAttributes(desc, constantPool, attributes);\n+    private void addAttributes(FieldDescription desc, FieldBuilder builder) {\n+        addGenericAttributes(desc, builder);\n@@ -1172,6 +954,12 @@\n-            Pair<Integer, Character> constantPoolEntry =\n-                    addConstant(constantPool, desc.constantValue, false);\n-            Assert.checkNonNull(constantPoolEntry);\n-            int constantValueString = addString(constantPool, Attribute.ConstantValue);\n-            attributes.put(Attribute.ConstantValue,\n-                           new ConstantValue_attribute(constantValueString, constantPoolEntry.fst));\n+            var cp = builder.constantPool();\n+            ConstantValueEntry entry = switch (desc.constantValue) {\n+                case Boolean v -> cp.intEntry(v ? 1 : 0);\n+                case Character v -> cp.intEntry(v);\n+                case Integer v -> cp.intEntry(v);\n+                case Long v -> cp.longEntry(v);\n+                case Float v -> cp.floatEntry(v);\n+                case Double v -> cp.doubleEntry(v);\n+                case String v -> cp.stringEntry(v);\n+                default -> throw new IllegalArgumentException(desc.constantValue.getClass().toString());\n+            };\n+            builder.with(ConstantValueAttribute.of(entry));\n@@ -1181,1 +969,8 @@\n-    private void addGenericAttributes(FeatureDescription desc, List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n+    @SuppressWarnings(\"unchecked\")\n+    private void addGenericAttributes(FeatureDescription desc, ClassFileBuilder<?, ?> builder) {\n+        addGenericAttributes(desc, (Consumer<? super Attribute<?>>) builder, builder.constantPool());\n+    }\n+\n+    private void addGenericAttributes(FeatureDescription desc, Consumer<? super Attribute<?>> sink, ConstantPoolBuilder cpb) {\n+        @SuppressWarnings(\"unchecked\")\n+        var builder = (Consumer<Attribute<?>>) sink;\n@@ -1183,3 +978,1 @@\n-            int attributeString = addString(constantPool, Attribute.Deprecated);\n-            attributes.put(Attribute.Deprecated,\n-                           new Deprecated_attribute(attributeString));\n+            builder.accept(DeprecatedAttribute.of());\n@@ -1188,4 +981,1 @@\n-            int attributeString = addString(constantPool, Attribute.Signature);\n-            int signatureString = addString(constantPool, desc.signature);\n-            attributes.put(Attribute.Signature,\n-                           new Signature_attribute(attributeString, signatureString));\n+            builder.accept(SignatureAttribute.of(cpb.utf8Entry(desc.signature)));\n@@ -1194,4 +984,1 @@\n-            int attributeString = addString(constantPool, Attribute.RuntimeInvisibleAnnotations);\n-            Annotation[] annotations = createAnnotations(constantPool, desc.classAnnotations);\n-            attributes.put(Attribute.RuntimeInvisibleAnnotations,\n-                           new RuntimeInvisibleAnnotations_attribute(attributeString, annotations));\n+            builder.accept(RuntimeInvisibleAnnotationsAttribute.of(createAnnotations(desc.classAnnotations)));\n@@ -1200,4 +987,1 @@\n-            int attributeString = addString(constantPool, Attribute.RuntimeVisibleAnnotations);\n-            Annotation[] annotations = createAnnotations(constantPool, desc.runtimeAnnotations);\n-            attributes.put(Attribute.RuntimeVisibleAnnotations,\n-                           new RuntimeVisibleAnnotations_attribute(attributeString, annotations));\n+            builder.accept(RuntimeVisibleAnnotationsAttribute.of(createAnnotations(desc.runtimeAnnotations)));\n@@ -1207,9 +991,2 @@\n-    private Annotation[] createAnnotations(List<CPInfo> constantPool, List<AnnotationDescription> desc) {\n-        Annotation[] result = new Annotation[desc.size()];\n-        int i = 0;\n-\n-        for (AnnotationDescription ad : desc) {\n-            result[i++] = createAnnotation(constantPool, ad);\n-        }\n-\n-        return result;\n+    private List<Annotation> createAnnotations(List<AnnotationDescription> desc) {\n+        return desc.stream().map(this::createAnnotation).collect(Collectors.toList());\n@@ -1218,9 +995,2 @@\n-    private Annotation[][] createParameterAnnotations(List<CPInfo> constantPool, List<List<AnnotationDescription>> desc) {\n-        Annotation[][] result = new Annotation[desc.size()][];\n-        int i = 0;\n-\n-        for (List<AnnotationDescription> paramAnnos : desc) {\n-            result[i++] = createAnnotations(constantPool, paramAnnos);\n-        }\n-\n-        return result;\n+    private List<List<Annotation>> createParameterAnnotations(List<List<AnnotationDescription>> desc) {\n+        return desc.stream().map(this::createAnnotations).collect(Collectors.toList());\n@@ -1229,1 +999,1 @@\n-    private Annotation createAnnotation(List<CPInfo> constantPool, AnnotationDescription desc) {\n+    private Annotation createAnnotation(AnnotationDescription desc) {\n@@ -1260,178 +1030,27 @@\n-        return new Annotation(null,\n-                              addString(constantPool, annotationType),\n-                              createElementPairs(constantPool, values));\n-    }\n-\n-    private element_value_pair[] createElementPairs(List<CPInfo> constantPool, Map<String, Object> annotationAttributes) {\n-        element_value_pair[] pairs = new element_value_pair[annotationAttributes.size()];\n-        int i = 0;\n-\n-        for (Entry<String, Object> e : annotationAttributes.entrySet()) {\n-            int elementNameString = addString(constantPool, e.getKey());\n-            element_value value = createAttributeValue(constantPool, e.getValue());\n-            pairs[i++] = new element_value_pair(elementNameString, value);\n-        }\n-\n-        return pairs;\n-    }\n-\n-    private element_value createAttributeValue(List<CPInfo> constantPool, Object value) {\n-        Pair<Integer, Character> constantPoolEntry = addConstant(constantPool, value, true);\n-        if (constantPoolEntry != null) {\n-            return new Primitive_element_value(constantPoolEntry.fst, constantPoolEntry.snd);\n-        } else if (value instanceof EnumConstant) {\n-            EnumConstant ec = (EnumConstant) value;\n-            return new Enum_element_value(addString(constantPool, ec.type),\n-                                          addString(constantPool, ec.constant),\n-                                          'e');\n-        } else if (value instanceof ClassConstant) {\n-            ClassConstant cc = (ClassConstant) value;\n-            return new Class_element_value(addString(constantPool, cc.type), 'c');\n-        } else if (value instanceof AnnotationDescription) {\n-            Annotation annotation = createAnnotation(constantPool, ((AnnotationDescription) value));\n-            return new Annotation_element_value(annotation, '@');\n-        } else if (value instanceof Collection) {\n-            @SuppressWarnings(\"unchecked\")\n-                    Collection<Object> array = (Collection<Object>) value;\n-            element_value[] values = new element_value[array.size()];\n-            int i = 0;\n-\n-            for (Object elem : array) {\n-                values[i++] = createAttributeValue(constantPool, elem);\n-            }\n-\n-            return new Array_element_value(values, '[');\n-        }\n-        throw new IllegalStateException(value.getClass().getName());\n-    }\n-\n-    private static Pair<Integer, Character> addConstant(List<CPInfo> constantPool, Object value, boolean annotation) {\n-        if (value instanceof Boolean) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info(((Boolean) value) ? 1 : 0)), 'Z');\n-        } else if (value instanceof Byte) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((byte) value)), 'B');\n-        } else if (value instanceof Character) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((char) value)), 'C');\n-        } else if (value instanceof Short) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((short) value)), 'S');\n-        } else if (value instanceof Integer) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((int) value)), 'I');\n-        } else if (value instanceof Long) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Long_info((long) value)), 'J');\n-        } else if (value instanceof Float) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Float_info((float) value)), 'F');\n-        } else if (value instanceof Double) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Double_info((double) value)), 'D');\n-        } else if (value instanceof String) {\n-            int stringIndex = addString(constantPool, (String) value);\n-            if (annotation) {\n-                return Pair.of(stringIndex, 's');\n-            } else {\n-                return Pair.of(addToCP(constantPool, new CONSTANT_String_info(null, stringIndex)), 's');\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    private static int addString(List<CPInfo> constantPool, String string) {\n-        Assert.checkNonNull(string);\n-\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Utf8_info) {\n-                if (((CONSTANT_Utf8_info) info).value.equals(string)) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Utf8_info(string));\n-    }\n-\n-    private static int addInt(List<CPInfo> constantPool, int value) {\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Integer_info) {\n-                if (((CONSTANT_Integer_info) info).value == value) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Integer_info(value));\n-    }\n-\n-    private static int addModuleName(List<CPInfo> constantPool, String moduleName) {\n-        int nameIdx = addString(constantPool, moduleName);\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Module_info) {\n-                if (((CONSTANT_Module_info) info).name_index == nameIdx) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Module_info(null, nameIdx));\n-    }\n-\n-    private static int addPackageName(List<CPInfo> constantPool, String packageName) {\n-        int nameIdx = addString(constantPool, packageName);\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Package_info) {\n-                if (((CONSTANT_Package_info) info).name_index == nameIdx) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Package_info(null, nameIdx));\n-    }\n-\n-    private static int addClassName(List<CPInfo> constantPool, String className) {\n-        int nameIdx = addString(constantPool, className);\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Class_info) {\n-                if (((CONSTANT_Class_info) info).name_index == nameIdx) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Class_info(null, nameIdx));\n-    }\n-\n-    private static int addToCP(List<CPInfo> constantPool, CPInfo entry) {\n-        int result = constantPool.size();\n-\n-        constantPool.add(entry);\n-\n-        if (entry.size() > 1) {\n-            constantPool.add(null);\n-        }\n-\n-        return result;\n-    }\n-\n-    private static int addClass(List<CPInfo> constantPool, String className) {\n-        int classNameIndex = addString(constantPool, className);\n-\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Class_info) {\n-                if (((CONSTANT_Class_info) info).name_index == classNameIndex) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Class_info(null, classNameIndex));\n+        return Annotation.of(ClassDesc.ofDescriptor(annotationType),\n+                createElementPairs(values));\n+    }\n+\n+    private List<AnnotationElement> createElementPairs(Map<String, Object> annotationAttributes) {\n+        return annotationAttributes.entrySet().stream()\n+                .map(e -> AnnotationElement.of(e.getKey(), createAttributeValue(e.getValue())))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private AnnotationValue createAttributeValue(Object value) {\n+        return switch (value) {\n+            case Boolean v -> AnnotationValue.ofBoolean(v);\n+            case Byte v -> AnnotationValue.ofByte(v);\n+            case Character v -> AnnotationValue.ofChar(v);\n+            case Short v -> AnnotationValue.ofShort(v);\n+            case Integer v -> AnnotationValue.ofInt(v);\n+            case Long v -> AnnotationValue.ofLong(v);\n+            case Float v -> AnnotationValue.ofFloat(v);\n+            case Double v -> AnnotationValue.ofDouble(v);\n+            case String v -> AnnotationValue.ofString(v);\n+            case EnumConstant v -> AnnotationValue.ofEnum(ClassDesc.ofDescriptor(v.type), v.constant);\n+            case ClassConstant v -> AnnotationValue.ofClass(ClassDesc.ofDescriptor(v.type));\n+            case AnnotationDescription v -> AnnotationValue.ofAnnotation(createAnnotation(v));\n+            case Collection<?> v -> AnnotationValue.ofArray(v.stream().map(this::createAttributeValue).collect(Collectors.toList()));\n+            default -> throw new IllegalArgumentException(value.getClass().getName());\n+        };\n@@ -1512,1 +1131,1 @@\n-                throw new IllegalStateException(ex);\n+                throw new IllegalArgumentException(ex);\n@@ -1528,6 +1147,2 @@\n-            try (InputStream in = new ByteArrayInputStream(classFileData)) {\n-                inspectModuleInfoClassFile(in,\n-                                           currentVersionModules, version);\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n+            inspectModuleInfoClassFile(classFileData,\n+                    currentVersionModules, version);\n@@ -1564,2 +1179,2 @@\n-                                 cf -> {\n-                                     PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n+                                 cm -> {\n+                                     var permitted = cm.findAttribute(Attributes.permittedSubclasses()).orElse(null);\n@@ -1567,2 +1182,2 @@\n-                                         try {\n-                                             String currentPack = cf.getName().substring(0, cf.getName().lastIndexOf('\/'));\n+                                         var name = cm.thisClass().asInternalName();\n+                                         String currentPack = name.substring(0, name.lastIndexOf('\/'));\n@@ -1570,4 +1185,4 @@\n-                                             for (int i = 0; i < permitted.subtypes.length; i++) {\n-                                                 String permittedClassName = cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName();\n-                                                 if (!currentEIList.accepts(permittedClassName, false)) {\n-                                                     String permittedPack = permittedClassName.substring(0, permittedClassName.lastIndexOf('\/'));\n+                                         for (var sub : permitted.permittedSubclasses()) {\n+                                             String permittedClassName = sub.asInternalName();\n+                                             if (!currentEIList.accepts(permittedClassName, false)) {\n+                                                 String permittedPack = permittedClassName.substring(0, permittedClassName.lastIndexOf('\/'));\n@@ -1575,3 +1190,2 @@\n-                                                     extraModulesPackagesToDerive.computeIfAbsent(permittedPack, x -> new HashSet<>())\n-                                                                                 .add(currentPack);\n-                                                 }\n+                                                 extraModulesPackagesToDerive.computeIfAbsent(permittedPack, x -> new HashSet<>())\n+                                                                             .add(currentPack);\n@@ -1579,2 +1193,0 @@\n-                                         } catch (ConstantPoolException ex) {\n-                                             throw new IllegalStateException(ex);\n@@ -1584,2 +1196,2 @@\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n+            } catch (IOException ex) {\n+                throw new IllegalArgumentException(ex);\n@@ -1651,4 +1263,1 @@\n-                        ModuleDescription md;\n-\n-                        try (InputStream in = Files.newInputStream(moduleInfo)) {\n-                            md = inspectModuleInfoClassFile(in,\n+                        ModuleDescription md = inspectModuleInfoClassFile(Files.readAllBytes(moduleInfo),\n@@ -1656,1 +1265,0 @@\n-                        }\n@@ -1718,2 +1326,2 @@\n-        } catch (IOException | ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n+        } catch (IOException ex) {\n+            throw new IllegalArgumentException(ex);\n@@ -1727,1 +1335,1 @@\n-                                                  List<String> todo) throws IOException, ConstantPoolException {\n+                                                  List<String> todo) throws IOException {\n@@ -2247,1 +1855,1 @@\n-    private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version) throws IOException, ConstantPoolException {\n+    private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version) throws IOException {\n@@ -2252,2 +1860,2 @@\n-                                  Consumer<ClassFile> extraTask) throws IOException, ConstantPoolException {\n-        ClassFile cf = ClassFile.read(in);\n+                                  Consumer<ClassModel> extraTask) throws IOException {\n+        ClassModel cm = ClassFile.of().parse(in.readAllBytes());\n@@ -2255,1 +1863,1 @@\n-        if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n+        if (cm.isModuleInfo()) {\n@@ -2259,1 +1867,1 @@\n-        if (!excludesIncludes.accepts(cf.getName(), true)) {\n+        if (!excludesIncludes.accepts(cm.thisClass().asInternalName(), true)) {\n@@ -2263,1 +1871,1 @@\n-        extraTask.accept(cf);\n+        extraTask.accept(cm);\n@@ -2267,1 +1875,1 @@\n-        headerDesc.flags = cf.access_flags.flags;\n+        headerDesc.flags = cm.flags().flagsMask();\n@@ -2269,6 +1877,2 @@\n-        if (cf.super_class != 0) {\n-            headerDesc.extendsAttr = cf.getSuperclassName();\n-        }\n-        List<String> interfaces = new ArrayList<>();\n-        for (int i = 0; i < cf.interfaces.length; i++) {\n-            interfaces.add(cf.getInterfaceName(i));\n+        if (cm.superclass().isPresent()) {\n+            headerDesc.extendsAttr = cm.superclass().get().asInternalName();\n@@ -2276,3 +1880,3 @@\n-        headerDesc.implementsAttr = interfaces;\n-        for (Attribute attr : cf.attributes) {\n-            if (!readAttribute(cf, headerDesc, attr))\n+        headerDesc.implementsAttr = cm.interfaces().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+        for (var attr : cm.attributes()) {\n+            if (!readAttribute(headerDesc, attr))\n@@ -2285,1 +1889,1 @@\n-            if (cd.name.equals(cf.getName())) {\n+            if (cd.name.equals(cm.thisClass().asInternalName())) {\n@@ -2293,1 +1897,1 @@\n-            clazzDesc.name = cf.getName();\n+            clazzDesc.name = cm.thisClass().asInternalName();\n@@ -2299,2 +1903,2 @@\n-        for (Method m : cf.methods) {\n-            if (!include(m.access_flags.flags))\n+        for (var m : cm.methods()) {\n+            if (!include(m.flags().flagsMask()))\n@@ -2303,5 +1907,5 @@\n-            methDesc.flags = m.access_flags.flags;\n-            methDesc.name = m.getName(cf.constant_pool);\n-            methDesc.descriptor = m.descriptor.getValue(cf.constant_pool);\n-            for (Attribute attr : m.attributes) {\n-                readAttribute(cf, methDesc, attr);\n+            methDesc.flags = m.flags().flagsMask();\n+            methDesc.name = m.methodName().stringValue();\n+            methDesc.descriptor = m.methodType().stringValue();\n+            for (var attr : m.attributes()) {\n+                readAttribute(methDesc, attr);\n@@ -2311,2 +1915,2 @@\n-        for (Field f : cf.fields) {\n-            if (!include(f.access_flags.flags))\n+        for (var f : cm.fields()) {\n+            if (!include(f.flags().flagsMask()))\n@@ -2315,5 +1919,5 @@\n-            fieldDesc.flags = f.access_flags.flags;\n-            fieldDesc.name = f.getName(cf.constant_pool);\n-            fieldDesc.descriptor = f.descriptor.getValue(cf.constant_pool);\n-            for (Attribute attr : f.attributes) {\n-                readAttribute(cf, fieldDesc, attr);\n+            fieldDesc.flags = f.flags().flagsMask();\n+            fieldDesc.name = f.fieldName().stringValue();\n+            fieldDesc.descriptor = f.fieldType().stringValue();\n+            for (var attr : f.attributes()) {\n+                readAttribute(fieldDesc, attr);\n@@ -2325,1 +1929,1 @@\n-    private ModuleDescription inspectModuleInfoClassFile(InputStream in,\n+    private ModuleDescription inspectModuleInfoClassFile(byte[] data,\n@@ -2327,2 +1931,2 @@\n-            String version) throws IOException, ConstantPoolException {\n-        ClassFile cf = ClassFile.read(in);\n+            String version) {\n+        ClassModel cm = ClassFile.of().parse(data);\n@@ -2330,1 +1934,1 @@\n-        if (!cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n+        if (!cm.flags().has(AccessFlag.MODULE)) {\n@@ -2337,1 +1941,1 @@\n-        headerDesc.flags = cf.access_flags.flags;\n+        headerDesc.flags = cm.flags().flagsMask();\n@@ -2339,2 +1943,2 @@\n-        for (Attribute attr : cf.attributes) {\n-            if (!readAttribute(cf, headerDesc, attr))\n+        for (var attr : cm.attributes()) {\n+            if (!readAttribute(headerDesc, attr))\n@@ -2364,7 +1968,1 @@\n-            try (InputStream in = new ByteArrayInputStream(classFileData)) {\n-                ClassFile cf = ClassFile.read(in);\n-\n-                additionalIncludes.addAll(otherRelevantTypesWithOwners(cf));\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n+            additionalIncludes.addAll(otherRelevantTypesWithOwners(ClassFile.of().parse(classFileData)));\n@@ -2376,1 +1974,1 @@\n-    private Set<String> otherRelevantTypesWithOwners(ClassFile cf) {\n+    private Set<String> otherRelevantTypesWithOwners(ClassModel cm) {\n@@ -2379,4 +1977,3 @@\n-        try {\n-            if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n-                return supertypes;\n-            }\n+        if (cm.flags().has(AccessFlag.MODULE)) {\n+            return supertypes;\n+        }\n@@ -2384,1 +1981,1 @@\n-            Set<String> additionalClasses = new HashSet<>();\n+        Set<String> additionalClasses = new HashSet<>();\n@@ -2386,11 +1983,10 @@\n-            if (cf.super_class != 0) {\n-                additionalClasses.add(cf.getSuperclassName());\n-            }\n-            for (int i = 0; i < cf.interfaces.length; i++) {\n-                additionalClasses.add(cf.getInterfaceName(i));\n-            }\n-            PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n-            if (permitted != null) {\n-                for (int i = 0; i < permitted.subtypes.length; i++) {\n-                    additionalClasses.add(cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName());\n-                }\n+        if (cm.superclass().isPresent()) {\n+            additionalClasses.add(cm.superclass().get().asInternalName());\n+        }\n+        for (var iface : cm.interfaces()) {\n+            additionalClasses.add(iface.asInternalName());\n+        }\n+        var permitted = cm.findAttribute(Attributes.permittedSubclasses()).orElse(null);\n+        if (permitted != null) {\n+            for (var sub : permitted.permittedSubclasses()) {\n+                additionalClasses.add(sub.asInternalName());\n@@ -2398,0 +1994,1 @@\n+        }\n@@ -2399,2 +1996,2 @@\n-            for (String additional : additionalClasses) {\n-                int dollar;\n+        for (String additional : additionalClasses) {\n+            int dollar;\n@@ -2402,1 +1999,1 @@\n-                supertypes.add(additional);\n+            supertypes.add(additional);\n@@ -2404,4 +2001,3 @@\n-                while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n-                    additional = additional.substring(0, dollar);\n-                    supertypes.add(additional);\n-                }\n+            while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n+                additional = additional.substring(0, dollar);\n+                supertypes.add(additional);\n@@ -2409,4 +2005,0 @@\n-\n-            return supertypes;\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n@@ -2414,0 +2006,2 @@\n+\n+        return supertypes;\n@@ -2438,1 +2032,1 @@\n-        return (accessFlags & (AccessFlags.ACC_PUBLIC | AccessFlags.ACC_PROTECTED)) != 0;\n+        return (accessFlags & (ACC_PUBLIC | ACC_PROTECTED)) != 0;\n@@ -2534,22 +2128,7 @@\n-    private boolean readAttribute(ClassFile cf, FeatureDescription feature, Attribute attr) throws ConstantPoolException {\n-        String attrName = attr.getName(cf.constant_pool);\n-        switch (attrName) {\n-            case Attribute.AnnotationDefault:\n-                assert feature instanceof MethodDescription;\n-                element_value defaultValue = ((AnnotationDefault_attribute) attr).default_value;\n-                ((MethodDescription) feature).annotationDefaultValue =\n-                        convertElementValue(cf.constant_pool, defaultValue);\n-                break;\n-            case \"Deprecated\":\n-                feature.deprecated = true;\n-                break;\n-            case \"Exceptions\":\n-                assert feature instanceof MethodDescription;\n-                List<String> thrownTypes = new ArrayList<>();\n-                Exceptions_attribute exceptionAttr = (Exceptions_attribute) attr;\n-                for (int i = 0; i < exceptionAttr.exception_index_table.length; i++) {\n-                    thrownTypes.add(exceptionAttr.getException(i, cf.constant_pool));\n-                }\n-                ((MethodDescription) feature).thrownTypes = thrownTypes;\n-                break;\n-            case Attribute.InnerClasses:\n+    private boolean readAttribute(FeatureDescription feature, Attribute<?> attr) {\n+        switch (attr) {\n+            case AnnotationDefaultAttribute a ->\n+                    ((MethodDescription) feature).annotationDefaultValue = convertElementValue(a.defaultValue());\n+            case DeprecatedAttribute _ -> feature.deprecated = true;\n+            case ExceptionsAttribute a -> ((MethodDescription) feature).thrownTypes = a.exceptions().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+            case InnerClassesAttribute a -> {\n@@ -2558,71 +2137,26 @@\n-                assert feature instanceof ClassHeaderDescription;\n-                List<InnerClassInfo> innerClasses = new ArrayList<>();\n-                InnerClasses_attribute innerClassesAttr = (InnerClasses_attribute) attr;\n-                for (int i = 0; i < innerClassesAttr.number_of_classes; i++) {\n-                    CONSTANT_Class_info outerClassInfo =\n-                            innerClassesAttr.classes[i].getOuterClassInfo(cf.constant_pool);\n-                    InnerClassInfo info = new InnerClassInfo();\n-                    CONSTANT_Class_info innerClassInfo =\n-                            innerClassesAttr.classes[i].getInnerClassInfo(cf.constant_pool);\n-                    info.innerClass = innerClassInfo != null ? innerClassInfo.getName() : null;\n-                    info.outerClass = outerClassInfo != null ? outerClassInfo.getName() : null;\n-                    info.innerClassName = innerClassesAttr.classes[i].getInnerName(cf.constant_pool);\n-                    info.innerClassFlags = innerClassesAttr.classes[i].inner_class_access_flags.flags;\n-                    innerClasses.add(info);\n-                }\n-                ((ClassHeaderDescription) feature).innerClasses = innerClasses;\n-                break;\n-            case \"RuntimeInvisibleAnnotations\":\n-                feature.classAnnotations = annotations2Description(cf.constant_pool, attr);\n-                break;\n-            case \"RuntimeVisibleAnnotations\":\n-                feature.runtimeAnnotations = annotations2Description(cf.constant_pool, attr);\n-                break;\n-            case \"Signature\":\n-                feature.signature = ((Signature_attribute) attr).getSignature(cf.constant_pool);\n-                break;\n-            case \"ConstantValue\":\n-                assert feature instanceof FieldDescription;\n-                Object value = convertConstantValue(cf.constant_pool.get(((ConstantValue_attribute) attr).constantvalue_index), ((FieldDescription) feature).descriptor);\n-                if (((FieldDescription) feature).descriptor.equals(\"C\")) {\n-                    value = (char) (int) value;\n-                }\n-                ((FieldDescription) feature).constantValue = value;\n-                break;\n-            case \"SourceFile\":\n-                \/\/ignore, not needed\n-                break;\n-            case \"BootstrapMethods\":\n-                \/\/ignore, not needed\n-                break;\n-            case \"Code\":\n-                \/\/ignore, not needed\n-                break;\n-            case \"EnclosingMethod\":\n-                return false;\n-            case \"Synthetic\":\n-                break;\n-            case \"RuntimeVisibleParameterAnnotations\":\n-                assert feature instanceof MethodDescription;\n-                ((MethodDescription) feature).runtimeParameterAnnotations =\n-                        parameterAnnotations2Description(cf.constant_pool, attr);\n-                break;\n-            case \"RuntimeInvisibleParameterAnnotations\":\n-                assert feature instanceof MethodDescription;\n-                ((MethodDescription) feature).classParameterAnnotations =\n-                        parameterAnnotations2Description(cf.constant_pool, attr);\n-                break;\n-            case Attribute.Module: {\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                Module_attribute mod = (Module_attribute) attr;\n-\n-                header.name = cf.constant_pool\n-                                .getModuleInfo(mod.module_name)\n-                                .getName();\n-\n-                header.exports =\n-                        Arrays.stream(mod.exports)\n-                              .map(ee -> ExportsDescription.create(cf, ee))\n-                              .collect(Collectors.toList());\n+                ((ClassHeaderDescription) feature).innerClasses = a.classes().stream().map(cfi -> {\n+                    var info = new InnerClassInfo();\n+                    info.innerClass = cfi.innerClass().asInternalName();\n+                    info.outerClass = cfi.outerClass().map(ClassEntry::asInternalName).orElse(null);\n+                    info.innerClassName = cfi.innerName().map(Utf8Entry::stringValue).orElse(null);\n+                    info.innerClassFlags = cfi.flagsMask();\n+                    return info;\n+                }).collect(Collectors.toList());\n+            }\n+            case RuntimeInvisibleAnnotationsAttribute a -> feature.classAnnotations = annotations2Description(a.annotations());\n+            case RuntimeVisibleAnnotationsAttribute a -> feature.runtimeAnnotations = annotations2Description(a.annotations());\n+            case SignatureAttribute a -> feature.signature = a.signature().stringValue();\n+            case ConstantValueAttribute a -> {\n+                var f = (FieldDescription) feature;\n+                f.constantValue = convertConstantValue(a.constant(), f.descriptor);\n+            }\n+            case SourceFileAttribute _, BootstrapMethodsAttribute _, CodeAttribute _, SyntheticAttribute _ -> {}\n+            case EnclosingMethodAttribute _ -> {\n+                return false;\n+            }\n+            case RuntimeVisibleParameterAnnotationsAttribute a -> ((MethodDescription) feature).runtimeParameterAnnotations = parameterAnnotations2Description(a.parameterAnnotations());\n+            case RuntimeInvisibleParameterAnnotationsAttribute a -> ((MethodDescription) feature).classParameterAnnotations = parameterAnnotations2Description(a.parameterAnnotations());\n+            case ModuleAttribute a -> {\n+                ModuleHeaderDescription header = (ModuleHeaderDescription) feature;\n+                header.name = a.moduleName().name().stringValue();\n+                header.exports = a.exports().stream().map(ExportsDescription::create).collect(Collectors.toList());\n@@ -2632,24 +2166,3 @@\n-                header.requires =\n-                        Arrays.stream(mod.requires)\n-                              .map(r -> RequiresDescription.create(cf, r))\n-                              .collect(Collectors.toList());\n-                header.uses = Arrays.stream(mod.uses_index)\n-                                    .mapToObj(use -> getClassName(cf, use))\n-                                    .collect(Collectors.toList());\n-                header.provides =\n-                        Arrays.stream(mod.provides)\n-                              .map(p -> ProvidesDescription.create(cf, p))\n-                              .collect(Collectors.toList());\n-                break;\n-            }\n-            case Attribute.ModuleTarget: {\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                ModuleTarget_attribute mod = (ModuleTarget_attribute) attr;\n-                if (mod.target_platform_index != 0) {\n-                    header.moduleTarget =\n-                            cf.constant_pool\n-                              .getUTF8Value(mod.target_platform_index);\n-                }\n-                break;\n+                header.requires = a.requires().stream().map(RequiresDescription::create).collect(Collectors.toList());\n+                header.uses = a.uses().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+                header.provides = a.provides().stream().map(ProvidesDescription::create).collect(Collectors.toList());\n@@ -2657,18 +2170,6 @@\n-            case Attribute.ModuleResolution: {\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                ModuleResolution_attribute mod =\n-                        (ModuleResolution_attribute) attr;\n-                header.moduleResolution = mod.resolution_flags;\n-                break;\n-            }\n-            case Attribute.ModulePackages:\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                ModulePackages_attribute mod =\n-                        (ModulePackages_attribute) attr;\n-                header.extraModulePackages = new ArrayList<>();\n-                for (int i = 0; i < mod.packages_count; i++) {\n-                    String packageName = getPackageName(cf, mod.packages_index[i]);\n+            case ModuleTargetAttribute a -> ((ModuleHeaderDescription) feature).moduleTarget = a.targetPlatform().stringValue();\n+            case ModuleResolutionAttribute a -> ((ModuleHeaderDescription) feature).moduleResolution = a.resolutionFlags();\n+            case ModulePackagesAttribute a -> {\n+                var header = (ModuleHeaderDescription) feature;\n+                header.extraModulePackages = a.packages().stream().<String>mapMulti((packageItem, sink) -> {\n+                    var packageName = packageItem.name().stringValue();\n@@ -2676,2 +2177,2 @@\n-                        header.exports.stream().noneMatch(ed -> ed.packageName().equals(packageName))) {\n-                        header.extraModulePackages.add(packageName);\n+                            header.exports.stream().noneMatch(ed -> ed.packageName().equals(packageName))) {\n+                        sink.accept(packageName);\n@@ -2679,19 +2180,1 @@\n-                }\n-                break;\n-            case Attribute.ModuleHashes:\n-                break;\n-            case Attribute.NestHost: {\n-                assert feature instanceof ClassHeaderDescription;\n-                NestHost_attribute nestHost = (NestHost_attribute) attr;\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n-                chd.nestHost = nestHost.getNestTop(cf.constant_pool).getName();\n-                break;\n-            }\n-            case Attribute.NestMembers: {\n-                assert feature instanceof ClassHeaderDescription;\n-                NestMembers_attribute nestMembers = (NestMembers_attribute) attr;\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n-                chd.nestMembers = Arrays.stream(nestMembers.members_indexes)\n-                                        .mapToObj(i -> getClassName(cf, i))\n-                                        .collect(Collectors.toList());\n-                break;\n+                }).collect(Collectors.toList());\n@@ -2699,14 +2182,5 @@\n-            case Attribute.Record: {\n-                assert feature instanceof ClassHeaderDescription;\n-                Record_attribute record = (Record_attribute) attr;\n-                List<RecordComponentDescription> components = new ArrayList<>();\n-                for (ComponentInfo info : record.component_info_arr) {\n-                    RecordComponentDescription rcd = new RecordComponentDescription();\n-                    rcd.name = info.getName(cf.constant_pool);\n-                    rcd.descriptor = info.descriptor.getValue(cf.constant_pool);\n-                    for (Attribute nestedAttr : info.attributes) {\n-                        readAttribute(cf, rcd, nestedAttr);\n-                    }\n-                    components.add(rcd);\n-                }\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n+            case ModuleHashesAttribute _ -> {}\n+            case NestHostAttribute a -> ((ClassHeaderDescription) feature).nestHost = a.nestHost().asInternalName();\n+            case NestMembersAttribute a -> ((ClassHeaderDescription) feature).nestMembers = a.nestMembers().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+            case RecordAttribute a -> {\n+                var chd = (ClassHeaderDescription) feature;\n@@ -2714,24 +2188,13 @@\n-                chd.recordComponents = components;\n-                break;\n-            }\n-            case Attribute.MethodParameters: {\n-                assert feature instanceof MethodDescription;\n-                MethodParameters_attribute params = (MethodParameters_attribute) attr;\n-                MethodDescription method = (MethodDescription) feature;\n-                method.methodParameters = new ArrayList<>();\n-                for (MethodParameters_attribute.Entry e : params.method_parameter_table) {\n-                    String name = e.name_index == 0 ? null\n-                            : cf.constant_pool.getUTF8Value(e.name_index);\n-                    MethodDescription.MethodParam param =\n-                            new MethodDescription.MethodParam(e.flags, name);\n-                    method.methodParameters.add(param);\n-                }\n-                break;\n-            }\n-            case Attribute.PermittedSubclasses: {\n-                assert feature instanceof ClassHeaderDescription;\n-                PermittedSubclasses_attribute permittedSubclasses = (PermittedSubclasses_attribute) attr;\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n-                chd.permittedSubclasses = Arrays.stream(permittedSubclasses.subtypes)\n-                        .mapToObj(i -> getClassName(cf, i))\n-                        .collect(Collectors.toList());\n+                chd.recordComponents = a.components().stream().map(rci -> {\n+                    var rcd = new RecordComponentDescription();\n+                    rcd.name = rci.name().stringValue();\n+                    rcd.descriptor = rci.descriptor().stringValue();\n+                    rci.attributes().forEach(child -> readAttribute(rcd, child));\n+                    return rcd;\n+                }).collect(Collectors.toList());\n+            }\n+            case MethodParametersAttribute a -> ((MethodDescription) feature).methodParameters = a.parameters().stream()\n+                    .map(mpi -> new MethodDescription.MethodParam(mpi.flagsMask(), mpi.name().map(Utf8Entry::stringValue).orElse(null)))\n+                    .collect(Collectors.toList());\n+            case PermittedSubclassesAttribute a -> {\n+                var chd = (ClassHeaderDescription) feature;\n@@ -2739,1 +2202,1 @@\n-                break;\n+                chd.permittedSubclasses = a.permittedSubclasses().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n@@ -2741,10 +2204,2 @@\n-            case Attribute.ModuleMainClass: {\n-                ModuleMainClass_attribute moduleMainClass = (ModuleMainClass_attribute) attr;\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription mhd = (ModuleHeaderDescription) feature;\n-                mhd.moduleMainClass = moduleMainClass.getMainClassName(cf.constant_pool);\n-                break;\n-            }\n-            default:\n-                throw new IllegalStateException(\"Unhandled attribute: \" +\n-                                                attrName);\n+            case ModuleMainClassAttribute a -> ((ModuleHeaderDescription) feature).moduleMainClass = a.mainClass().asInternalName();\n+            default -> throw new IllegalArgumentException(\"Unhandled attribute: \" + attr.attributeName()); \/\/ Do nothing\n@@ -2756,36 +2211,0 @@\n-    private static String getClassName(ClassFile cf, int idx) {\n-        try {\n-            return cf.constant_pool.getClassInfo(idx).getName();\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPool.UnexpectedEntry ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    private static String getPackageName(ClassFile cf, int idx) {\n-        try {\n-            return cf.constant_pool.getPackageInfo(idx).getName();\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPool.UnexpectedEntry ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    private static String getModuleName(ClassFile cf, int idx) {\n-        try {\n-            return cf.constant_pool.getModuleInfo(idx).getName();\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPool.UnexpectedEntry ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n@@ -2794,1 +2213,1 @@\n-    private static String getVersion(ClassFile cf, int idx) {\n+    private static String getVersion(Optional<Utf8Entry> version) {\n@@ -2798,7 +2217,1 @@\n-        if (idx == 0)\n-            return null;\n-        try {\n-            return ((CONSTANT_Utf8_info) cf.constant_pool.get(idx)).value;\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        }\n+        return version.map(Utf8Entry::stringValue).orElse(null);\n@@ -2807,16 +2220,11 @@\n-    Object convertConstantValue(CPInfo info, String descriptor) throws ConstantPoolException {\n-        if (info instanceof CONSTANT_Integer_info) {\n-            if (\"Z\".equals(descriptor))\n-                return ((CONSTANT_Integer_info) info).value == 1;\n-            else\n-                return ((CONSTANT_Integer_info) info).value;\n-        } else if (info instanceof CONSTANT_Long_info) {\n-            return ((CONSTANT_Long_info) info).value;\n-        } else if (info instanceof CONSTANT_Float_info) {\n-            return ((CONSTANT_Float_info) info).value;\n-        } else if (info instanceof CONSTANT_Double_info) {\n-            return ((CONSTANT_Double_info) info).value;\n-        } else if (info instanceof CONSTANT_String_info) {\n-            return ((CONSTANT_String_info) info).getString();\n-        }\n-        throw new IllegalStateException(info.getClass().getName());\n+    Object convertConstantValue(ConstantValueEntry info, String descriptor) {\n+        if (descriptor.length() == 1 && info instanceof IntegerEntry ie) {\n+            var i = ie.intValue();\n+            return switch (descriptor.charAt(0)) {\n+                case 'I', 'B', 'S' -> i;\n+                case 'C' -> (char) i;\n+                case 'Z' -> i == 1;\n+                default -> throw new IllegalArgumentException(descriptor);\n+            };\n+        }\n+        return info.constantValue();\n@@ -2825,39 +2233,8 @@\n-    Object convertElementValue(ConstantPool cp, element_value val) throws InvalidIndex, ConstantPoolException {\n-        switch (val.tag) {\n-            case 'Z':\n-                return ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value != 0;\n-            case 'B':\n-                return (byte) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'C':\n-                return (char) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'S':\n-                return (short) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'I':\n-                return ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'J':\n-                return ((CONSTANT_Long_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'F':\n-                return ((CONSTANT_Float_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'D':\n-                return ((CONSTANT_Double_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 's':\n-                return ((CONSTANT_Utf8_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-\n-            case 'e':\n-                return new EnumConstant(cp.getUTF8Value(((Enum_element_value) val).type_name_index),\n-                        cp.getUTF8Value(((Enum_element_value) val).const_name_index));\n-            case 'c':\n-                return new ClassConstant(cp.getUTF8Value(((Class_element_value) val).class_info_index));\n-\n-            case '@':\n-                return annotation2Description(cp, ((Annotation_element_value) val).annotation_value);\n-\n-            case '[':\n-                List<Object> values = new ArrayList<>();\n-                for (element_value elem : ((Array_element_value) val).values) {\n-                    values.add(convertElementValue(cp, elem));\n-                }\n-                return values;\n-            default:\n-                throw new IllegalStateException(\"Currently unhandled tag: \" + val.tag);\n-        }\n+    Object convertElementValue(AnnotationValue val) {\n+        return switch (val) {\n+            case AnnotationValue.OfConstant oc -> oc.resolvedValue();\n+            case AnnotationValue.OfEnum oe -> new EnumConstant(oe.className().stringValue(), oe.constantName().stringValue());\n+            case AnnotationValue.OfClass oc -> new ClassConstant(oc.className().stringValue());\n+            case AnnotationValue.OfArray oa -> oa.values().stream().map(this::convertElementValue).collect(Collectors.toList());\n+            case AnnotationValue.OfAnnotation oa -> annotation2Description(oa.annotation());\n+        };\n@@ -2866,7 +2243,2 @@\n-    private List<AnnotationDescription> annotations2Description(ConstantPool cp, Attribute attr) throws ConstantPoolException {\n-        RuntimeAnnotations_attribute annotationsAttr = (RuntimeAnnotations_attribute) attr;\n-        List<AnnotationDescription> descs = new ArrayList<>();\n-        for (Annotation a : annotationsAttr.annotations) {\n-            descs.add(annotation2Description(cp, a));\n-        }\n-        return descs;\n+    private List<AnnotationDescription> annotations2Description(List<java.lang.classfile.Annotation> annos) {\n+        return annos.stream().map(this::annotation2Description).collect(Collectors.toList());\n@@ -2875,12 +2247,2 @@\n-    private List<List<AnnotationDescription>> parameterAnnotations2Description(ConstantPool cp, Attribute attr) throws ConstantPoolException {\n-        RuntimeParameterAnnotations_attribute annotationsAttr =\n-                (RuntimeParameterAnnotations_attribute) attr;\n-        List<List<AnnotationDescription>> descs = new ArrayList<>();\n-        for (Annotation[] attrAnnos : annotationsAttr.parameter_annotations) {\n-            List<AnnotationDescription> paramDescs = new ArrayList<>();\n-            for (Annotation ann : attrAnnos) {\n-                paramDescs.add(annotation2Description(cp, ann));\n-            }\n-            descs.add(paramDescs);\n-        }\n-        return descs;\n+    private List<List<AnnotationDescription>> parameterAnnotations2Description(List<List<java.lang.classfile.Annotation>> annos) {\n+        return annos.stream().map(this::annotations2Description).collect(Collectors.toList());\n@@ -2889,2 +2251,2 @@\n-    private AnnotationDescription annotation2Description(ConstantPool cp, Annotation a) throws ConstantPoolException {\n-        String annotationType = cp.getUTF8Value(a.type_index);\n+    private AnnotationDescription annotation2Description(java.lang.classfile.Annotation a) {\n+        String annotationType = a.className().stringValue();\n@@ -2893,2 +2255,2 @@\n-        for (element_value_pair e : a.element_value_pairs) {\n-            values.put(cp.getUTF8Value(e.element_name_index), convertElementValue(cp, e.value));\n+        for (var e : a.elements()) {\n+            values.put(e.name().stringValue(), convertElementValue(e.value()));\n@@ -3184,1 +2546,1 @@\n-                        throw new IllegalStateException(reader.lineKey);\n+                        throw new IllegalArgumentException(reader.lineKey);\n@@ -3399,3 +2761,2 @@\n-            public static ExportsDescription create(ClassFile cf,\n-                                                    ExportsEntry ee) {\n-                String packageName = getPackageName(cf, ee.exports_index);\n+            public static ExportsDescription create(ModuleExportInfo ee) {\n+                String packageName = ee.exportedPackage().name().stringValue();\n@@ -3403,5 +2764,2 @@\n-                if (ee.exports_to_count > 0) {\n-                    to = new ArrayList<>();\n-                    for (int moduleIndex : ee.exports_to_index) {\n-                        to.add(getModuleName(cf, moduleIndex));\n-                    }\n+                if (!ee.exportsTo().isEmpty()) {\n+                    to = ee.exportsTo().stream().map(m -> m.name().stringValue()).collect(Collectors.toList());\n@@ -3450,4 +2808,3 @@\n-            public static RequiresDescription create(ClassFile cf,\n-                                                     RequiresEntry req) {\n-                String mod = getModuleName(cf, req.requires_index);\n-                String ver = getVersion(cf, req.requires_version_index);\n+            public static RequiresDescription create(ModuleRequireInfo req) {\n+                String mod = req.requires().name().stringValue();\n+                String ver = getVersion(req.requiresVersion());\n@@ -3455,1 +2812,1 @@\n-                                               req.requires_flags,\n+                                               req.requiresFlagsMask(),\n@@ -3518,7 +2875,3 @@\n-            public static ProvidesDescription create(ClassFile cf,\n-                                                     ProvidesEntry prov) {\n-                String api = getClassName(cf, prov.provides_index);\n-                List<String> impls =\n-                        Arrays.stream(prov.with_index)\n-                              .mapToObj(wi -> getClassName(cf, wi))\n-                              .collect(Collectors.toList());\n+            public static ProvidesDescription create(ModuleProvideInfo prov) {\n+                String api = prov.provides().asInternalName();\n+                List<String> impls = prov.providesWith().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n@@ -3679,1 +3032,1 @@\n-                        throw new IllegalStateException(reader.lineKey);\n+                        throw new IllegalArgumentException(reader.lineKey);\n@@ -4076,1 +3429,1 @@\n-        Object constantValue;\n+        Object constantValue; \/\/ Uses (unsigned) Integer for byte\/short\n@@ -4152,1 +3505,1 @@\n-                        throw new IllegalStateException(\"Unrecognized field type: \" + descriptor);\n+                        throw new IllegalArgumentException(\"Unrecognized field type: \" + descriptor);\n@@ -4419,1 +3772,1 @@\n-            throw new IllegalStateException(\"Cannot find: \" + name);\n+            throw new IllegalArgumentException(\"Cannot find: \" + name);\n@@ -4568,1 +3921,1 @@\n-                    throw new IllegalStateException(\"Unrecognized boolean structure: \" + value);\n+                    throw new IllegalArgumentException(\"Unrecognized boolean structure: \" + value);\n@@ -4596,1 +3949,1 @@\n-                throw new IllegalStateException(\"Unrecognized signature type: \" + value.charAt(valuePointer[0] - 1) + \"; value=\" + value);\n+                throw new IllegalArgumentException(\"Unrecognized signature type: \" + value.charAt(valuePointer[0] - 1) + \"; value=\" + value);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":355,"deletions":1002,"binary":false,"changes":1357,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED \\\n","filename":"make\/modules\/jdk.compiler\/Gendata.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,2 +71,1 @@\n-$1\/bin\/java --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED \\\n-            --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n+$1\/bin\/java --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n","filename":"make\/scripts\/generate-symbol-data.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- *          jdk.jdeps\/com.sun.tools.classfile:+open\n@@ -79,2 +78,1 @@\n-              .options(\"--add-exports\", \"jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\",\n-                       \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED\",\n+              .options(\"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED\",\n@@ -105,2 +103,1 @@\n-                      \"jdk.compiler\/com.sun.tools.javac.util\",\n-                      \"jdk.jdeps\/com.sun.tools.classfile\")\n+                      \"jdk.compiler\/com.sun.tools.javac.util\")\n","filename":"test\/langtools\/tools\/javac\/platform\/CanHandleClassFilesTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n@@ -110,2 +109,1 @@\n-                                              \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\",\n-                                              \"--add-exports\", \"jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\"),\n+                                              \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\"),\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}