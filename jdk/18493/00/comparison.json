{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,29 @@\n+ * <p> The above forms adhere \"strict\" decimal-only syntax.\n+ * Additionally, the following (loose) syntax is available with\n+ * {@link Inet4Address#ofPosixLiteral(String)} method that implements\n+ * <a href=\"https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/inet_addr.html\">\n+ * POSIX {@code inet_addr}<\/a> compatible parsing algorithm, allowing\n+ * octal and hexadecimal address segments. Please refer to\n+ * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc6943.html#section-3.1.1\"> <i>RFC&nbsp;\n+ * 6943: Issues in Identifier Comparison for Security Purposes<\/i><\/a>.\n+ * <p> The following (non-decimal) forms are supported\n+ * in this mode:\n+ * {@snippet :\n+ *  \/\/ Dotted-quad 'x.x.x.x' form with four part address literal\n+ *  Inet4Address.ofPosixLiteral(\"0177.0000.0000.0001\"); \/\/ ==> \/127.0.0.1\n+ *  Inet4Address.ofPosixLiteral(\"0127.0.0.1\"); \/\/ ==> \/87.0.0.1\n+ *\n+ *  \/\/ Dotted-triple 'x.x.x' form with three part address literal,\n+ *  \/\/ the last part is placed in the rightmost two bytes\n+ *  \/\/ of the constructed address\n+ *  Inet4Address.ofPosixLiteral(\"0x7F.0.0x101\"); \/\/ ==> \/127.0.1.1\n+ *\n+ *  \/\/ Dotted-double 'x.x' form with two part address literal,\n+ *  \/\/ the last part is placed in the rightmost three bytes\n+ *  \/\/ of the constructed address\n+ *  Inet4Address.ofPosixLiteral(\"0177.0200401\"); \/\/ ==> \/127.1.1.1\n+ *\n+ *  \/\/ Dotless 'x' form with one value that is stored directly in\n+ *  \/\/ the constructed address bytes without any rearrangement\n+ *  Inet4Address.ofPosixLiteral(\"017700000001\"); \/\/ ==> \/127.0.0.1\n+ * }\n@@ -115,0 +144,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc6943.html#section-3.1.1\n+ *      RFC 6943: Issues in Identifier Comparison for Security Purposes\n@@ -183,0 +214,33 @@\n+    \/**\n+     * Creates an {@code Inet4Address} based on the provided {@linkplain\n+     * Inet4Address##format textual representation} of an IPv4 address in POSIX form.\n+     * This form allows extended syntax, accepting hexadecimal and octal address\n+     * segments as specified in {@code inet_addr} POSIX API (loose syntax). Please\n+     * refer to <a href=\"https:\/\/www.ietf.org\/rfc\/rfc6943.html#section-3.1.1\">\n+     * <i>RFC&nbsp;6943: Issues in Identifier Comparison for Security Purposes<\/i><\/a>.\n+     * <p> If the provided IPv4 address literal cannot represent a {@linkplain\n+     * Inet4Address##format valid IPv4 address} an {@code IllegalArgumentException} is thrown.\n+     * <p> This method doesn't block, i.e. no hostname lookup is performed.\n+     *\n+     * @apiNote\n+     * This method produces different results compared to {@linkplain Inet4Address#ofLiteral}\n+     * when {@code posixIPAddressLiteral} parameter contains octal address segments below\n+     * {@code 0256} (decimal {@code 174}). Unlike {@linkplain Inet4Address#ofLiteral}\n+     * that ignores leading zeros, parses all numbers as decimal and produces\n+     * {@code 255} for {@code \"0255\"}, {@linkplain Inet4Address#ofPosixLiteral this}\n+     * method interprets the numbers based on their prefix (hexadecimal {@code \"0x\"},\n+     * octal {@code \"0\"}) and returns {@code 173} for {@code \"0255\"}.\n+     *\n+     * @param posixIPAddressLiteral the textual representation of an IPv4 address.\n+     * @return an {@link Inet4Address} object with no hostname set, and constructed\n+     *         from the provided IPv4 address literal.\n+     * @throws IllegalArgumentException if the {@code posixIPAddressLiteral} cannot be\n+     *         parsed as an IPv4 address literal.\n+     * @throws NullPointerException if the {@code posixIPAddressLiteral} is {@code null}.\n+     * @since 23\n+     *\/\n+    public static Inet4Address ofPosixLiteral(String posixIPAddressLiteral) {\n+        Objects.requireNonNull(posixIPAddressLiteral);\n+        return parseAddressStringPosix(posixIPAddressLiteral, true);\n+    }\n+\n@@ -215,0 +279,39 @@\n+    \/**\n+     * Parses the given string as an IPv4 address literal in POSIX form.\n+     * This form allows extended syntax, accepting hexadecimal and octal address\n+     * segments as specified in {@code inet_addr} POSIX API (loose syntax). Please\n+     * refer to <a href=\"https:\/\/www.ietf.org\/rfc\/rfc6943.html#section-3.1.1\">\n+     * <i>RFC&nbsp;6943: Issues in Identifier Comparison for Security Purposes<\/i><\/a>.\n+     *\n+     * <p> If the given {@code addressLiteral} string cannot be parsed as an IPv4 address literal\n+     * in POSIX form and {@code throwIAE} is {@code false}, {@code null} is returned.\n+     * If the given {@code addressLiteral} string cannot be parsed as an IPv4 address literal\n+     * and {@code throwIAE} is {@code true}, an {@code IllegalArgumentException}\n+     * is thrown.\n+     *\n+     * @apiNote\n+     * This method produces different results compared to {@linkplain Inet4Address#parseAddressString}\n+     * when {@code addressLiteral} string contains octal address segments below\n+     * {@code 0256} (decimal {@code 174}). Unlike {@linkplain Inet4Address#parseAddressString}\n+     * that ignores leading zeros, parses all numbers as decimal and produces\n+     * {@code 255} for {@code \"0255\"}, {@linkplain Inet4Address#parseAddressStringPosix this}\n+     * method interprets the numbers based on their prefix (hexadecimal {@code \"0x\"},\n+     * octal {@code \"0\"}) and returns {@code 173} for {@code \"0255\"}.\n+     *\n+     * @param addressLiteral IPv4 address literal to parse\n+     * @param throwIAE whether to throw {@code IllegalArgumentException} if the\n+     *                 given {@code addressLiteral} string cannot be parsed as\n+     *                 an IPv4 address literal.\n+     * @return {@code Inet4Address} object constructed from the address literal;\n+     *         or {@code null} if the literal cannot be parsed as an IPv4 address\n+     * @throws IllegalArgumentException if the given {@code addressLiteral} string\n+     * cannot be parsed as an IPv4 address literal and {@code throwIAE} is {@code true}.\n+     *\/\n+    static Inet4Address parseAddressStringPosix(String addressLiteral, boolean throwIAE) {\n+        byte [] parsedBytes = IPAddressUtil.parseBsdLiteralV4(addressLiteral);\n+        if (parsedBytes == null && throwIAE) {\n+            throw IPAddressUtil.invalidIpAddressLiteral(addressLiteral);\n+        }\n+        return (parsedBytes == null) ? null : new Inet4Address(null, parsedBytes);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4Address.java","additions":104,"deletions":1,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -669,0 +669,20 @@\n+        return parseBsdLiteralV4(input) != null;\n+    }\n+\n+    \/**\n+     * Parse String as IPv4 address literal by following\n+     * POSIX-style formatting rules.\n+     *\n+     * @param input a String representing an IPv4 address in POSIX format\n+     * @return a byte array representing the IPv4 numeric address\n+     * if input string is a parsable POSIX formatted IPv4 address literal,\n+     * {@code null} otherwise.\n+     *\/\n+    public static byte[] parseBsdLiteralV4(String input) {\n+\n+        byte[] res = new byte[]{0,0,0,0};\n+\n+        int len = input.length();\n+        if (len == 0) {\n+            return null;\n+        }\n@@ -672,1 +692,1 @@\n-            return false;\n+            return null;\n@@ -676,1 +696,1 @@\n-        char lastSymbol = input.charAt(input.length() - 1);\n+        char lastSymbol = input.charAt(len - 1);\n@@ -678,1 +698,1 @@\n-            return false;\n+            return null;\n@@ -684,0 +704,1 @@\n+        long fieldValue = -1L;\n@@ -685,1 +706,1 @@\n-            long fieldValue = -1L;\n+            fieldValue = -1L;\n@@ -690,0 +711,3 @@\n+                    if (fieldValue < 256) {\n+                        res[fieldNumber] = (byte) fieldValue;\n+                    }\n@@ -693,1 +717,1 @@\n-                    return false;\n+                    return null;\n@@ -699,1 +723,1 @@\n-                return false;\n+                return null;\n@@ -702,1 +726,14 @@\n-        return true;\n+        \/\/ The last field value must be non-negative\n+        if (fieldValue < 0) {\n+            return null;\n+        }\n+        \/\/ If the last fieldValue is greater than 255 (fieldNumer < 4),\n+        \/\/ it is written to the last (4 - (fieldNumber - 1)) octets\n+        \/\/ in the network order\n+        if (fieldNumber < 4) {\n+            for (int i = 3; i >= fieldNumber - 1; --i) {\n+                res[i] = (byte) (fieldValue & 255);\n+                fieldValue >>= 8;\n+            }\n+        }\n+        return res;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8272215\n+ * @bug 8272215 8315767\n@@ -70,0 +70,1 @@\n+            case INET4_ADDRESS_POSIX -> Inet4Address.ofPosixLiteral(addressLiteral);\n@@ -72,1 +73,0 @@\n-        InetAddress getByNameResult = InetAddress.getByName(addressLiteral);\n@@ -74,1 +74,5 @@\n-        Assert.assertEquals(getByNameResult, ofLiteralResult);\n+        \/\/ POSIX literals are not compatible with InetAddress.getByName()\n+        if (inetAddressClass != InetAddressClass.INET4_ADDRESS_POSIX) {\n+            InetAddress getByNameResult = InetAddress.getByName(addressLiteral);\n+            Assert.assertEquals(getByNameResult, ofLiteralResult);\n+        }\n@@ -104,0 +108,27 @@\n+        \/\/ 87.0.0.1 address bytes\n+        byte[] ipv4_87_0_0_1 = new byte[]{87, 0, 0, 1};\n+\n+        \/\/ 127.0.0.1 address bytes\n+        byte[] ipv4_127_0_0_1 = new byte[]{127, 0, 0, 1};\n+\n+        \/\/ 17.99.141.27 address bytes\n+        byte[] ipv4_17_99_141_27 = new byte[]{17, 99, (byte)141, 27};\n+\n+        \/\/ 127.8.0.1 address bytes\n+        byte[] ipv4_127_8_0_1 = new byte[]{127, 8, 0, 1};\n+\n+        \/\/ 0.0.0.42 address bytes\n+        byte[] ipv4_0_0_0_42 = new byte[]{0, 0, 0, 42};\n+\n+        \/\/ 0.0.0.34 address bytes\n+        byte[] ipv4_0_0_0_34 = new byte[]{0, 0, 0, 34};\n+\n+        \/\/ 127.0.1.1 address bytes\n+        byte[] ipv4_127_0_1_1 = new byte[]{127, 0, 1, 1};\n+\n+        \/\/ 127.1.1.1 address bytes\n+        byte[] ipv4_127_1_1_1 = new byte[]{127, 1, 1, 1};\n+\n+        \/\/ 255.255.255.255 address bytes\n+        byte[] ipv4_255_255_255_255 = new byte[]{(byte)255, (byte)255, (byte)255, (byte)255};\n+\n@@ -173,1 +204,57 @@\n-                        \"03735928559\", ipv4ExpBytes)\n+                        \"03735928559\", ipv4ExpBytes),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0127.0.0.1\", ipv4_87_0_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0.0.1\", ipv4_127_0_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0s treated as octal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0000.0000.0001\", ipv4_127_0_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"127.010.0.1\", ipv4_127_8_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0377.0377.0377.0377\", ipv4_255_255_255_255),\n+                \/\/      form:'x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hexadecimal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0x7F.0.0x101\", ipv4_127_0_1_1),\n+                \/\/      form:'x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0s treated as octal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0200401\", ipv4_127_1_1_1),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"017700000001\", ipv4_127_0_0_1),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"02130706433\", ipv4_17_99_141_27),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"037777777777\", ipv4_255_255_255_255),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hex prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0xFFFFFFFF\", ipv4_255_255_255_255),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without leading 0 treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"2130706433\", ipv4_127_0_0_1),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without leading 0 treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"42\", ipv4_0_0_0_42),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"042\", ipv4_0_0_0_34)\n@@ -254,1 +341,12 @@\n-                Arguments.of(InetAddressClass.INET4_ADDRESS, \"0xFFFFFFFF\")\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"0xFFFFFFFF\"),\n+\n+                \/\/ invalid IPv4 literals in POSIX\/BSD form\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"0x100.1.2.3\"), \/\/ 0x100 is too large\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"1.2.3.0x100\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"127.08.9.1\"),  \/\/ 8, 9 are invalid octals\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"127.8.09.1\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"048\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"\"),            \/\/ empty\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"0x1FFFFFFFF\"), \/\/ 2^33 - 1 is too large\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"0x100000000\"), \/\/ 2^32 is too large\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"040000000000\")\n@@ -300,0 +398,1 @@\n+            case INET4_ADDRESS_POSIX -> () -> Inet4Address.ofPosixLiteral(input);\n@@ -307,0 +406,1 @@\n+        INET4_ADDRESS_POSIX,\n","filename":"test\/jdk\/java\/net\/InetAddress\/OfLiteralTest.java","additions":106,"deletions":6,"binary":false,"changes":112,"status":"modified"}]}