{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,3 +73,3 @@\n- * <p> These forms support parts specified in decimal format only.\n- * For example, the following forms are supported by methods capable\n- * of parsing textual representations of IPv4 addresses:\n+ * <p> For example, the following (decimal) forms are supported by the methods\n+ * {@link Inet4Address#ofLiteral(String)} and {@link InetAddress#getByName(String)}\n+ * which are capable of parsing textual representations of IPv4 addresses:\n@@ -96,0 +96,8 @@\n+ * <p> The above forms adhere to \"strict\" decimal-only syntax.\n+ * Additionally, the {@link Inet4Address#ofPosixLiteral(String)}\n+ * method implements a POSIX {@code inet_addr} compatible \"loose\"\n+ * parsing algorithm, allowing octal and hexadecimal address segments.\n+ * Please refer to <a href=\"https:\/\/www.ietf.org\/rfc\/rfc6943.html#section-3.1.1\">\n+ * <i>RFC&nbsp;6943: Issues in Identifier Comparison for Security\n+ * Purposes<\/i><\/a>. Aside from {@code Inet4Address.ofPosixLiteral(String)}, all methods only\n+ * support strict decimal parsing.\n@@ -97,1 +105,1 @@\n- * value, the first form, i.e. a dotted-quad string, is used.\n+ * value, the first form, i.e. a dotted-quad string in strict decimal notation, is used.\n@@ -115,0 +123,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc6943.html#section-3.1.1\n+ *      RFC 6943: Issues in Identifier Comparison for Security Purposes\n@@ -183,0 +193,66 @@\n+    \/**\n+     * Creates an {@code Inet4Address} based on the provided {@linkplain\n+     * Inet4Address##format-posix textual representation of an IPv4 address in\n+     * POSIX {@code inet_addr} compatible form}.\n+     * <p> <a id=\"format-posix\"><\/a> The method {@code ofPosixLiteral}\n+     * implements <a href=\"https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/inet_addr.html\">\n+     * POSIX {@code inet_addr}<\/a> compatible parsing algorithm, allowing\n+     * octal and hexadecimal address segments. {@code \"0\"} is the prefix\n+     * for octal numbers, {@code \"0x\"} and {@code \"0X\"} are the prefixes\n+     * for hexadecimal numbers. Non-zero address segments that start from\n+     * non-zero digits are parsed as decimal numbers. The following\n+     * (non-decimal) forms are supported by this method:\n+     * {@snippet :\n+     *  \/\/ Dotted-quad 'x.x.x.x' form with four part address literal\n+     *  Inet4Address.ofPosixLiteral(\"0177.0.0.1\"); \/\/ ==> \/127.0.0.1\n+     *  Inet4Address.ofPosixLiteral(\"0x7F.0.0.1\"); \/\/ ==> \/127.0.0.1\n+     *\n+     *  \/\/ Dotted-triple 'x.x.x' form with three part address literal,\n+     *  \/\/ the last part is placed in the rightmost two bytes\n+     *  \/\/ of the constructed address\n+     *  Inet4Address.ofPosixLiteral(\"0177.0.0402\"); \/\/ ==> \/127.0.1.2\n+     *  Inet4Address.ofPosixLiteral(\"0x7F.0.0x102\"); \/\/ ==> \/127.0.1.2\n+     *\n+     *  \/\/ Dotted-double 'x.x' form with two part address literal,\n+     *  \/\/ the last part is placed in the rightmost three bytes\n+     *  \/\/ of the constructed address\n+     *  Inet4Address.ofPosixLiteral(\"0177.0201003\"); \/\/ ==> \/127.1.2.3\n+     *  Inet4Address.ofPosixLiteral(\"0x7F.0x10203\"); \/\/ ==> \/127.1.2.3\n+     *  Inet4Address.ofPosixLiteral(\"127.66051\"); \/\/ ==> \/127.1.2.3\n+     *\n+     *  \/\/ Dotless 'x' form with one value that is stored directly in\n+     *  \/\/ the constructed address bytes without any rearrangement\n+     *  Inet4Address.ofPosixLiteral(\"0100401404\"); \/\/ ==> \/1.2.3.4\n+     *  Inet4Address.ofPosixLiteral(\"0x1020304\"); \/\/ ==> \/1.2.3.4\n+     *  Inet4Address.ofPosixLiteral(\"16909060\"); \/\/ ==> \/1.2.3.4\n+     * }\n+     * <p> If the provided IPv4 address literal cannot represent a\n+     * valid IPv4 address in {@linkplain Inet4Address##format-posix\n+     * POSIX form} an {@code IllegalArgumentException} is thrown.\n+     * <p> This method doesn't block, i.e. no hostname lookup is performed.\n+     *\n+     * @apiNote\n+     * This method produces different results compared to {@linkplain Inet4Address#ofLiteral}\n+     * when {@code posixIPAddressLiteral} parameter contains address segments with\n+     * leading zeroes. An address segment with a leading zero is always parsed as an octal\n+     * number by this method, therefore {@code 0255} (octal) will be parsed as\n+     * {@code 173} (decimal). On the other hand, {@link Inet4Address#ofLiteral\n+     * Inet4Address.ofLiteral} ignores leading zeros, parses all numbers as decimal and produces\n+     * {@code 255}. Where this method would parse {@code 0256.0256.0256.0256} (octal) and\n+     * produce {@code 174.174.174.174} (decimal) in four dotted quad notation,\n+     * {@link Inet4Address#ofLiteral Inet4Address.ofLiteral} will throw\n+     * {@code IllegalArgumentException}.\n+     *\n+     * @param posixIPAddressLiteral a textual representation of an IPv4 address.\n+     * @return an {@link Inet4Address} object with no hostname set, and constructed\n+     *         from the provided IPv4 address literal.\n+     * @throws IllegalArgumentException if the {@code posixIPAddressLiteral} cannot be\n+     *         parsed as an IPv4 address literal.\n+     * @throws NullPointerException if the {@code posixIPAddressLiteral} is {@code null}.\n+     * @since 23\n+     *\/\n+    public static Inet4Address ofPosixLiteral(String posixIPAddressLiteral) {\n+        Objects.requireNonNull(posixIPAddressLiteral);\n+        return parseAddressStringPosix(posixIPAddressLiteral);\n+    }\n+\n@@ -215,0 +291,39 @@\n+    \/**\n+     * Parses the given string as an IPv4 address literal in\n+     * {@linkplain Inet4Address##format-posix POSIX form.}\n+     *\n+     * <p> If the given {@code addressLiteral} string cannot be parsed as an IPv4 address literal\n+     * in POSIX form and {@code throwIAE} is {@code false}, {@code null} is returned.\n+     * If the given {@code addressLiteral} string cannot be parsed as an IPv4 address literal\n+     * and {@code throwIAE} is {@code true}, an {@code IllegalArgumentException}\n+     * is thrown.\n+     *\n+     * @apiNote\n+     * This method produces different results compared to {@linkplain Inet4Address#parseAddressString}\n+     * when {@code addressLiteral} parameter contains address segments with leading\n+     * zeroes. An address segment with a leading zero is always parsed as an octal\n+     * number by this method, therefore {@code 0255} (octal) will be parsed as\n+     * {@code 173} (decimal). On the other hand, {@link Inet4Address#parseAddressString}\n+     * ignores leading zeros, parses all numbers as decimal and produces {@code 255}.\n+     * Where this method would parse {@code 0256.0256.0256.0256} (octal) and produce\n+     * {@code 174.174.174.174} (decimal) in four dotted quad notation, {@linkplain\n+     * Inet4Address#parseAddressString} will either throw {@code IllegalArgumentException}\n+     * or return {@code null}, depending on the value of {@code throwIAE}.\n+     *\n+     * @param addressLiteral IPv4 address literal to parse\n+     * @param throwIAE whether to throw {@code IllegalArgumentException} if the\n+     *                 given {@code addressLiteral} string cannot be parsed as\n+     *                 an IPv4 address literal.\n+     * @return {@code Inet4Address} object constructed from the address literal;\n+     *         or {@code null} if the literal cannot be parsed as an IPv4 address\n+     * @throws IllegalArgumentException if the given {@code addressLiteral} string\n+     * cannot be parsed as an IPv4 address literal and {@code throwIAE} is {@code true}.\n+     *\/\n+    private static Inet4Address parseAddressStringPosix(String addressLiteral) {\n+        byte [] parsedBytes = IPAddressUtil.parseBsdLiteralV4(addressLiteral);\n+        if (parsedBytes == null) {\n+            throw IPAddressUtil.invalidIpAddressLiteral(addressLiteral);\n+        }\n+        return new Inet4Address(null, parsedBytes);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4Address.java","additions":120,"deletions":5,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -669,0 +669,20 @@\n+        return parseBsdLiteralV4(input) != null;\n+    }\n+\n+    \/**\n+     * Parse String as IPv4 address literal by following\n+     * POSIX-style formatting rules.\n+     *\n+     * @param input a String representing an IPv4 address in POSIX format\n+     * @return a byte array representing the IPv4 numeric address\n+     * if input string is a parsable POSIX formatted IPv4 address literal,\n+     * {@code null} otherwise.\n+     *\/\n+    public static byte[] parseBsdLiteralV4(String input) {\n+\n+        byte[] res = new byte[]{0,0,0,0};\n+\n+        int len = input.length();\n+        if (len == 0) {\n+            return null;\n+        }\n@@ -672,1 +692,1 @@\n-            return false;\n+            return null;\n@@ -676,1 +696,1 @@\n-        char lastSymbol = input.charAt(input.length() - 1);\n+        char lastSymbol = input.charAt(len - 1);\n@@ -678,1 +698,1 @@\n-            return false;\n+            return null;\n@@ -684,0 +704,1 @@\n+        long fieldValue = -1L;\n@@ -685,1 +706,1 @@\n-            long fieldValue = -1L;\n+            fieldValue = -1L;\n@@ -690,0 +711,7 @@\n+                    if (fieldValue < 256) {\n+                        \/\/ Store the parsed field in the byte buffer.\n+                        \/\/ If the field value is greater than 255, it can only be the last field.\n+                        \/\/ If it is not the last one, parseV4FieldBsd enforces this limit\n+                        \/\/ and returns TERMINAL_PARSE_ERROR.\n+                        res[fieldNumber] = (byte) fieldValue;\n+                    }\n@@ -693,1 +721,1 @@\n-                    return false;\n+                    return null;\n@@ -699,1 +727,1 @@\n-                return false;\n+                return null;\n@@ -702,1 +730,14 @@\n-        return true;\n+        \/\/ The last field value must be non-negative\n+        if (fieldValue < 0) {\n+            return null;\n+        }\n+        \/\/ If the last fieldValue is greater than 255 (fieldNumber < 4),\n+        \/\/ it is written to the last (4 - (fieldNumber - 1)) octets\n+        \/\/ in the network order\n+        if (fieldNumber < 4) {\n+            for (int i = 3; i >= fieldNumber - 1; --i) {\n+                res[i] = (byte) (fieldValue & 255);\n+                fieldValue >>= 8;\n+            }\n+        }\n+        return res;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n- * @bug 8272215\n- * @summary Test for ofLiteral API in InetAddress classes\n+ * @bug 8272215 8315767\n+ * @summary Test for ofLiteral, ofPosixLiteral APIs in InetAddress classes\n@@ -70,0 +70,1 @@\n+            case INET4_ADDRESS_POSIX -> Inet4Address.ofPosixLiteral(addressLiteral);\n@@ -72,1 +73,0 @@\n-        InetAddress getByNameResult = InetAddress.getByName(addressLiteral);\n@@ -74,1 +74,5 @@\n-        Assert.assertEquals(getByNameResult, ofLiteralResult);\n+        \/\/ POSIX literals are not compatible with InetAddress.getByName()\n+        if (inetAddressClass != InetAddressClass.INET4_ADDRESS_POSIX) {\n+            InetAddress getByNameResult = InetAddress.getByName(addressLiteral);\n+            Assert.assertEquals(getByNameResult, ofLiteralResult);\n+        }\n@@ -104,0 +108,27 @@\n+        \/\/ 87.0.0.1 address bytes\n+        byte[] ipv4_87_0_0_1 = new byte[]{87, 0, 0, 1};\n+\n+        \/\/ 127.0.0.1 address bytes\n+        byte[] ipv4_127_0_0_1 = new byte[]{127, 0, 0, 1};\n+\n+        \/\/ 17.99.141.27 address bytes\n+        byte[] ipv4_17_99_141_27 = new byte[]{17, 99, (byte)141, 27};\n+\n+        \/\/ 127.8.0.1 address bytes\n+        byte[] ipv4_127_8_0_1 = new byte[]{127, 8, 0, 1};\n+\n+        \/\/ 0.0.0.42 address bytes\n+        byte[] ipv4_0_0_0_42 = new byte[]{0, 0, 0, 42};\n+\n+        \/\/ 0.0.0.34 address bytes\n+        byte[] ipv4_0_0_0_34 = new byte[]{0, 0, 0, 34};\n+\n+        \/\/ 127.0.1.2 address bytes\n+        byte[] ipv4_127_0_1_2 = new byte[]{127, 0, 1, 2};\n+\n+        \/\/ 127.1.2.3 address bytes\n+        byte[] ipv4_127_1_2_3 = new byte[]{127, 1, 2, 3};\n+\n+        \/\/ 255.255.255.255 address bytes\n+        byte[] ipv4_255_255_255_255 = new byte[]{(byte)255, (byte)255, (byte)255, (byte)255};\n+\n@@ -173,1 +204,81 @@\n-                        \"03735928559\", ipv4ExpBytes)\n+                        \"03735928559\", ipv4ExpBytes),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0127.0.0.1\", ipv4_87_0_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0.0.1\", ipv4_127_0_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0s treated as octal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0000.0000.0001\", ipv4_127_0_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"127.010.0.1\", ipv4_127_8_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0377.0377.0377.0377\", ipv4_255_255_255_255),\n+                \/\/      form:'x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0s treated as octal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0.0402\", ipv4_127_0_1_2),\n+                \/\/      form:'x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hexadecimal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0x7F.0.0x102\", ipv4_127_0_1_2),\n+                \/\/      form:'x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0s treated as octal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0201003\", ipv4_127_1_2_3),\n+                \/\/      form:'x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hexadecimal prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0x7F.0x10203\", ipv4_127_1_2_3),\n+                \/\/      form:'x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without prefixes treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"127.66051\", ipv4_127_1_2_3),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"017700000001\", ipv4_127_0_0_1),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"02130706433\", ipv4_17_99_141_27),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"037777777777\", ipv4_255_255_255_255),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hex prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0x1020304\", oneToFourAddressExpBytes),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hex prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0xFFFFFFFF\", ipv4_255_255_255_255),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without leading 0 treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"2130706433\", ipv4_127_0_0_1),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without leading 0 treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"42\", ipv4_0_0_0_42),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0100401404\", oneToFourAddressExpBytes),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without prefixes treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"16909060\", oneToFourAddressExpBytes),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"042\", ipv4_0_0_0_34)\n@@ -254,1 +365,12 @@\n-                Arguments.of(InetAddressClass.INET4_ADDRESS, \"0xFFFFFFFF\")\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"0xFFFFFFFF\"),\n+\n+                \/\/ invalid IPv4 literals in POSIX\/BSD form\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"0x100.1.2.3\"), \/\/ 0x100 is too large\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"1.2.3.0x100\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"127.08.9.1\"),  \/\/ 8, 9 are invalid octals\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"127.8.09.1\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"048\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"\"),            \/\/ empty\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"0x1FFFFFFFF\"), \/\/ 2^33 - 1 is too large\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"0x100000000\"), \/\/ 2^32 is too large\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"040000000000\")\n@@ -300,0 +422,1 @@\n+            case INET4_ADDRESS_POSIX -> () -> Inet4Address.ofPosixLiteral(input);\n@@ -307,0 +430,1 @@\n+        INET4_ADDRESS_POSIX,\n","filename":"test\/jdk\/java\/net\/InetAddress\/OfLiteralTest.java","additions":131,"deletions":7,"binary":false,"changes":138,"status":"modified"}]}