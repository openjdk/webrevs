{"files":[{"patch":"@@ -4,0 +4,1 @@\n+\/\/ Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1197,1 +1198,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1200,4 +1200,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_codestub_branch_size();\n-  }\n-\n@@ -1205,1 +1201,1 @@\n-    \/\/ count one adr and one far branch instruction\n+    \/\/ count one branch instruction and one far call instruction sequence\n@@ -2264,19 +2260,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ mov rscratch1 #exception_blob_entry_point\n-  \/\/ br rscratch1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -2293,0 +2270,1 @@\n+\n@@ -2294,0 +2272,3 @@\n+  Label start;\n+  __ bind(start);\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2295,2 +2276,2 @@\n-  __ adr(lr, __ pc());\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  int entry_offset = __ offset();\n+  __ b(start);\n@@ -2299,0 +2280,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -2300,1 +2283,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -452,2 +452,8 @@\n-  __ adr(lr, pc());\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ b(start);\n+\n@@ -455,0 +461,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -457,1 +465,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    _deopt_handler_size = 7 * NativeInstruction::instruction_size\n+    _deopt_handler_size = 4 * NativeInstruction::instruction_size\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,6 +397,0 @@\n-#ifdef ASSERT\n-static bool is_movk_to_zr(uint32_t insn) {\n-  return ((insn & 0xffe0001f) == 0xf280001f);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -529,0 +529,5 @@\n+private:\n+  static bool is_movk_to_zr(uint32_t insn) {\n+    return ((insn & 0xffe0001f) == 0xf280001f);\n+  }\n+\n@@ -530,0 +535,7 @@\n+  enum AArch64_specific_constants {\n+    \/\/ The two parts should be checked separately to prevent out of bounds access in case\n+    \/\/ the return address points to the deopt handler stub code entry point which could be\n+    \/\/ at the end of page.\n+    first_check_size = 4\n+  };\n+\n@@ -531,6 +543,11 @@\n-    uint64_t insns = *(uint64_t*)addr_at(0);\n-    \/\/ Check for two instructions: nop; movk zr, xx\n-    \/\/ These instructions only ever appear together in a post-call\n-    \/\/ NOP, so it's unnecessary to check that the third instruction is\n-    \/\/ a MOVK as well.\n-    return (insns & 0xffe0001fffffffff) == 0xf280001fd503201f;\n+    \/\/ Check the first instruction is NOP.\n+    if (is_nop()) {\n+      uint32_t insn = *(uint32_t*)addr_at(first_check_size);\n+      \/\/ Check next instruction is MOVK zr, xx.\n+      \/\/ These instructions only ever appear together in a post-call\n+      \/\/ NOP, so it's unnecessary to check that the third instruction is\n+      \/\/ a MOVK as well.\n+      return is_movk_to_zr(insn);\n+    }\n+\n+    return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -263,2 +263,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in aarch64.ad file)\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -111,5 +110,0 @@\n-  static uint size_exception_handler() {\n-    return ( 3 * 4 );\n-  }\n-\n-\n@@ -879,20 +873,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-\n-  \/\/ OK to trash LR, because exception blob will kill it\n-  __ jump(OptoRuntime::exception_blob()->entry_point(), relocInfo::runtime_call_type, LR_tmp);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -909,1 +883,0 @@\n-  address deopt_pc = __ pc();\n@@ -911,5 +884,3 @@\n-  __ sub(SP, SP, wordSize); \/\/ make room for saved PC\n-  __ push(LR); \/\/ save LR that may be live when we get here\n-  __ mov_relative_address(LR, deopt_pc);\n-  __ str(LR, Address(SP, wordSize)); \/\/ save deopt PC\n-  __ pop(LR); \/\/ restore LR\n+  Label start;\n+  __ bind(start);\n+\n@@ -918,0 +889,10 @@\n+  int entry_offset = __ offset();\n+  address deopt_pc = __ pc();\n+  \/\/ Preserve R0 and reserve space for the address of the entry point\n+  __ push(RegisterSet(R0) | RegisterSet(R1));\n+  \/\/ Store the entry point address\n+  __ mov_relative_address(R0, deopt_pc);\n+  __ str(R0, Address(SP, wordSize));\n+  __ pop(R0); \/\/ restore R0\n+  __ b(start);\n+\n@@ -919,0 +900,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -921,1 +904,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":16,"deletions":33,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -275,0 +275,6 @@\n+  Label start;\n+  __ bind(start);\n+\n+  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+\n+  int entry_offset = __ offset();\n@@ -277,1 +283,1 @@\n-  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+  __ b(start);\n@@ -280,0 +286,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -282,1 +290,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    _deopt_handler_size = 16\n+    _deopt_handler_size = 20\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -433,0 +433,7 @@\n+  enum arm_specific_constants {\n+    \/\/ If the check is adjusted to read beyond size of the instruction sequence at the deopt\n+    \/\/ handler stub code entry point, it has to happen in two stages - to prevent out of bounds\n+    \/\/ access in case the return address points to the entry point which could be at\n+    \/\/ the end of page.\n+    first_check_size = 4\n+  };\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -185,2 +185,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in sparc.ad file)\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -267,0 +267,3 @@\n+  Label start;\n+\n+  __ bind(start);\n@@ -268,0 +271,2 @@\n+  int entry_offset = __ offset();\n+  __ b(start);\n@@ -270,0 +275,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -272,1 +279,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  _deopt_handler_size = MacroAssembler::bl64_patchable_size\n+  _deopt_handler_size = MacroAssembler::bl64_patchable_size + BytesPerInstWord\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-  bool is_post_call_nop() const { return MacroAssembler::is_post_call_nop(long_at(0)); }\n-\n@@ -534,0 +532,8 @@\n+  enum ppc_specific_constants {\n+    \/\/ If the check is adjusted to read beyond size of the instruction at the deopt handler stub\n+    \/\/ code entry point, it has to happen in two stages - to prevent out of bounds access in case\n+    \/\/ the return address points to the entry point which could be at the end of page.\n+    first_check_size = 4\n+  };\n+\n+  bool is_post_call_nop() const { return MacroAssembler::is_post_call_nop(long_at(0)); }\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2091,1 +2091,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2094,5 +2093,0 @@\n-  static uint size_exception_handler() {\n-    \/\/ The exception_handler is a b64_patchable.\n-    return MacroAssembler::b64_patchable_size;\n-  }\n-\n@@ -2101,1 +2095,1 @@\n-    return MacroAssembler::bl64_patchable_size;\n+    return MacroAssembler::bl64_patchable_size + BytesPerInstWord;\n@@ -2117,16 +2111,0 @@\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  __ b64_patchable((address)OptoRuntime::exception_blob()->content_begin(),\n-                       relocInfo::runtime_call_type);\n-  assert(__ offset() - offset == (int)size_exception_handler(), \"must be fixed size\");\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -2143,0 +2121,4 @@\n+\n+  Label start;\n+  __ bind(start);\n+\n@@ -2145,0 +2127,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ b(start);\n+\n@@ -2146,0 +2133,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -2148,1 +2137,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-                         int return_pc_adjustment,\n@@ -265,1 +264,0 @@\n-                         int return_pc_adjustment,\n@@ -274,1 +272,0 @@\n-  \/\/ If return_pc_adjustment != 0 adjust the return pc by return_pc_adjustment.\n@@ -308,1 +305,1 @@\n-    case return_pc_is_pre_saved: assert(return_pc_adjustment == 0, \"unsupported\"); break;\n+    case return_pc_is_pre_saved: break;\n@@ -313,3 +310,0 @@\n-    if (return_pc_adjustment != 0) {\n-      __ addi(R31, R31, return_pc_adjustment);\n-    }\n@@ -2910,2 +2904,0 @@\n-  \/\/ So currently SR_LR points behind the call in the deopt handler.\n-  \/\/ We adjust it such that it points to the start of the deopt handler.\n@@ -2915,4 +2907,0 @@\n-  \/\/ We can't grab a free register here, because all registers may\n-  \/\/ contain live values, so let the RegisterSaver do the adjustment\n-  \/\/ of the return pc.\n-  const int return_pc_adjustment_no_exception = -MacroAssembler::bl64_patchable_size;\n@@ -2925,1 +2913,0 @@\n-                                                                   return_pc_adjustment_no_exception,\n@@ -2960,1 +2947,0 @@\n-                                                             \/*return_pc_adjustment_exception=*\/ 0,\n@@ -2978,1 +2964,0 @@\n-                                                             \/*return_pc_adjustment_reexecute=*\/ 0,\n@@ -3269,1 +3254,0 @@\n-                                                                   \/*return_pc_adjustment=*\/0,\n@@ -3370,1 +3354,0 @@\n-                                                                   \/*return_pc_adjustment*\/ 0,\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -380,2 +380,8 @@\n-  __ auipc(ra, 0);\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ j(start);\n+\n@@ -383,0 +389,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -385,1 +393,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    \/\/ auipc (1) + far_jump (2)\n+    \/\/ far_call (2) + j (1)\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -314,0 +314,7 @@\n+  enum RISCV_specific_constants {\n+    \/\/ The two parts should be checked separately to prevent out of bounds access in\n+    \/\/ case the return address points to the deopt handler stub code entry point\n+    \/\/ which could be at the end of page.\n+    first_check_size = 4\n+  };\n+\n@@ -319,1 +326,1 @@\n-    return is_nop() && MacroAssembler::is_lui_to_zr_at(addr_at(4));\n+    return is_nop() && MacroAssembler::is_lui_to_zr_at(addr_at(first_check_size));\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1052,1 +1052,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1055,4 +1054,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_branch_size();\n-  }\n-\n@@ -1060,1 +1055,1 @@\n-    \/\/ count auipc + far branch\n+    \/\/ count far call + j\n@@ -1833,19 +1828,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ auipc t1, #exception_blob_entry_point\n-  \/\/ jr (offset)t1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -1862,2 +1838,7 @@\n-  __ auipc(ra, 0);\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ j(start);\n@@ -1866,0 +1847,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -1867,1 +1850,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -252,2 +252,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in riscv.ad file)\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,1 +275,7 @@\n-  }  int offset = code_offset();\n+  }\n+\n+  int offset = code_offset();\n+\n+  Label start;\n+  __ bind(start);\n+\n@@ -279,0 +285,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ z_bru(start);\n+\n@@ -280,0 +291,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -282,1 +295,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -652,0 +652,7 @@\n+  enum z_specific_constants {\n+    \/\/ Once the check is implemented, this has to specify number of bytes checked on the first\n+    \/\/ read. If the check would read beyond size of the instruction at the deopt handler stub\n+    \/\/ code entry point, then it has to happen in two stages - to prevent out of bounds access\n+    \/\/ in case the return address points to the entry point which could be at the end of page.\n+    first_check_size = 0\n+  };\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in s390.ad file)\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1652,1 +1652,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1655,4 +1654,0 @@\n-  static uint size_exception_handler() {\n-    return NativeJump::max_instruction_size();\n-  }\n-\n@@ -1660,1 +1655,1 @@\n-    return NativeCall::max_instruction_size();\n+    return NativeCall::max_instruction_size() + MacroAssembler::jump_pcrelative_size();\n@@ -1675,37 +1670,0 @@\n-\/\/ This exception handler code snippet is placed after the method's\n-\/\/ code. It is the return point if an exception occurred. it jumps to\n-\/\/ the exception blob.\n-\/\/\n-\/\/ If the method gets deoptimized, the method and this code snippet\n-\/\/ get patched.\n-\/\/\n-\/\/ 1) Trampoline code gets patched into the end of this exception\n-\/\/   handler. the trampoline code jumps to the deoptimization blob.\n-\/\/\n-\/\/ 2) The return address in the method's code will get patched such\n-\/\/   that it jumps to the trampoline.\n-\/\/\n-\/\/ 3) The handler will get patched such that it does not jump to the\n-\/\/   exception blob, but to an entry in the deoptimization blob being\n-\/\/   aware of the exception.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  Register temp_reg = Z_R1;\n-\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;          \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  \/\/ Use unconditional pc-relative jump with 32-bit range here.\n-  __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()->content_begin());\n-  __ z_br(temp_reg);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -1723,0 +1681,3 @@\n+  Label start;\n+  __ bind(start);\n+\n@@ -1727,0 +1688,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ z_bru(start);\n+\n@@ -1728,0 +1694,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -1730,1 +1698,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":12,"deletions":44,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2547,2 +2547,1 @@\n-  \/\/ Z_R14 points behind the call in the deopt handler. We adjust\n-  \/\/ it such that it points to the start of the deopt handler.\n+  \/\/ Z_R14 points to the entry point of the deopt handler.\n@@ -2552,3 +2551,0 @@\n-  \/\/ The (int) cast is necessary, because -((unsigned int)14)\n-  \/\/ is an unsigned int.\n-  __ add2reg(Z_R14, -(int)NativeCall::max_instruction_size());\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -453,1 +453,0 @@\n-  InternalAddress here(__ pc());\n@@ -455,2 +454,9 @@\n-  __ pushptr(here.addr(), rscratch1);\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+\n+  __ jmp(start);\n+\n@@ -458,0 +464,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -460,1 +468,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    _deopt_handler_size = 17\n+    _deopt_handler_size = 7\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  jshort short_at(int offset) const    { return *(jshort*) addr_at(offset); }\n@@ -581,1 +582,6 @@\n-    displacement_offset = 4\n+    displacement_offset = 4,\n+\n+    \/\/ The two parts should be checked separately to prevent out of bounds access in case\n+    \/\/ the return address points to the deopt handler stub code entry point which could be\n+    \/\/ at the end of page.\n+    first_check_size = 2\n@@ -584,1 +590,1 @@\n-  bool check() const { return int_at(0) == 0x841f0f; }\n+  bool check() const { return short_at(0) == 0x1f0f && short_at(first_check_size) == 0x0084; }\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -245,2 +245,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in x86_64.ad file)\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2770,1 +2770,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2773,9 +2772,0 @@\n-  static uint size_exception_handler() {\n-    \/\/ NativeCall instruction size is the same as NativeJump.\n-    \/\/ exception handler starts out as jump and can be patched to\n-    \/\/ a call be deoptimization.  (4932387)\n-    \/\/ Note that this value is also credited (in output.cpp) to\n-    \/\/ the size of the code section.\n-    return NativeJump::instruction_size;\n-  }\n-\n@@ -2783,2 +2773,2 @@\n-    \/\/ three 5 byte instructions plus one move for unreachable address.\n-    return 15+3;\n+    \/\/ one call and one jmp.\n+    return 7;\n@@ -2876,18 +2866,0 @@\n-\/\/ Emit exception handler code.\n-\/\/ Stuff framesize into a register and call a VM stub routine.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -2906,4 +2878,4 @@\n-  address the_pc = (address) __ pc();\n-  Label next;\n-  \/\/ push a \"the_pc\" on the stack without destroying any registers\n-  \/\/ as they all may be live.\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2911,5 +2883,3 @@\n-  \/\/ push address of \"next\"\n-  __ call(next, relocInfo::none); \/\/ reloc none is fine since it is a disp32\n-  __ bind(next);\n-  \/\/ adjust it so it matches \"the_pc\"\n-  __ subptr(Address(rsp, 0), __ offset() - offset);\n+  int entry_offset = __ offset();\n+\n+  __ jmp(start);\n@@ -2917,1 +2887,0 @@\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2919,0 +2888,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -2920,1 +2891,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":41,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-        address deopt = nm->deopt_handler_begin();\n+        address deopt = nm->deopt_handler_entry();\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2798,1 +2798,1 @@\n-          address deopt = nm->deopt_handler_begin();\n+          address deopt = nm->deopt_handler_entry();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1060,1 +1060,3 @@\n-    assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n+\n+    assert(compiler->type() == compiler_c2 ||\n+           offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1305,1 +1305,1 @@\n-    _deopt_handler_offset    = 0;\n+    _deopt_handler_entry_offset    = 0;\n@@ -1445,1 +1445,1 @@\n-  _deopt_handler_offset         = nm._deopt_handler_offset;\n+  _deopt_handler_entry_offset   = nm._deopt_handler_entry_offset;\n@@ -1707,1 +1707,1 @@\n-        _deopt_handler_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n+        _deopt_handler_entry_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n@@ -1709,1 +1709,1 @@\n-        _deopt_handler_offset    = -1;\n+        _deopt_handler_entry_offset    = -1;\n@@ -1715,1 +1715,0 @@\n-      assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must be set\");\n@@ -1718,2 +1717,10 @@\n-      _exception_offset          = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n-      _deopt_handler_offset      = _stub_offset + offsets->value(CodeOffsets::Deopt);\n+      bool has_exception_handler = (offsets->value(CodeOffsets::Exceptions) != -1);\n+      assert(has_exception_handler == (compiler->type() != compiler_c2),\n+             \"C2 compiler doesn't provide exception handler stub code.\");\n+      if (has_exception_handler) {\n+        _exception_offset = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+      } else {\n+        _exception_offset = -1;\n+      }\n+\n+      _deopt_handler_entry_offset = _stub_offset + offsets->value(CodeOffsets::Deopt);\n@@ -4027,1 +4034,1 @@\n-  if (JVMCI_ONLY(_deopt_handler_offset != -1 &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n+  if (JVMCI_ONLY(_deopt_handler_entry_offset != -1 &&) pos == deopt_handler_entry()) label = \"[Deopt Handler Entry Point]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-  int _deopt_handler_offset;\n+  int _deopt_handler_entry_offset;\n@@ -620,1 +620,1 @@\n-  address deopt_handler_begin   () const { return           header_begin() + _deopt_handler_offset    ; }\n+  address deopt_handler_entry   () const { return           header_begin() + _deopt_handler_entry_offset    ; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return pc == deopt_handler_begin();\n+  return pc == deopt_handler_entry();\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1350,1 +1350,0 @@\n-  int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; \/\/ add marginal slop for handler\n@@ -1356,1 +1355,1 @@\n-    code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  \/\/ force expansion\n+    code_req = const_req = stub_req = deopt_handler_req = 0x10;  \/\/ force expansion\n@@ -1363,1 +1362,0 @@\n-          exception_handler_req +\n@@ -1792,2 +1790,0 @@\n-    \/\/ Emit the exception handler code.\n-    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(masm));\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -502,0 +502,3 @@\n+  if (exec_mode == Unpack_deopt) {\n+    assert(deoptee.is_deoptimized_frame(), \"frame is not marked for deoptimization\");\n+  }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-    return nm->deopt_handler_begin() - pc_return_offset;\n+    return nm->deopt_handler_entry() - pc_return_offset;\n@@ -358,1 +358,1 @@\n-  address deopt = nm->deopt_handler_begin();\n+  address deopt = nm->deopt_handler_entry();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n@@ -604,0 +607,5 @@\n+#ifdef COMPILER2\n+      if (nm->compiler_type() == compiler_c2) {\n+        return OptoRuntime::exception_blob()->entry_point();\n+      }\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -538,1 +538,1 @@\n-  nonstatic_field(nmethod,                     _deopt_handler_offset,                         int)                                   \\\n+  nonstatic_field(nmethod,                     _deopt_handler_entry_offset,                   int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  private static CIntegerField deoptHandlerOffsetField;\n+  private static CIntegerField deoptHandlerEntryOffsetField;\n@@ -89,1 +89,1 @@\n-    deoptHandlerOffsetField            = type.getCIntegerField(\"_deopt_handler_offset\");\n+    deoptHandlerEntryOffsetField       = type.getCIntegerField(\"_deopt_handler_entry_offset\");\n@@ -124,10 +124,10 @@\n-  public Address constantsBegin()             { return contentBegin();                                     }\n-  public Address constantsEnd()               { return codeBegin();                                        }\n-  public Address instsBegin()                 { return codeBegin();                                        }\n-  public Address instsEnd()                   { return headerBegin().addOffsetTo(getStubOffset());         }\n-  public Address exceptionBegin()             { return headerBegin().addOffsetTo(getExceptionOffset());    }\n-  public Address deoptHandlerBegin()          { return headerBegin().addOffsetTo(getDeoptHandlerOffset()); }\n-  public Address stubBegin()                  { return headerBegin().addOffsetTo(getStubOffset());         }\n-  public Address stubEnd()                    { return dataBegin();                                        }\n-  public Address oopsBegin()                  { return dataBegin();                                        }\n-  public Address oopsEnd()                    { return dataEnd();                                          }\n+  public Address constantsBegin()             { return contentBegin();                                          }\n+  public Address constantsEnd()               { return codeBegin();                                             }\n+  public Address instsBegin()                 { return codeBegin();                                             }\n+  public Address instsEnd()                   { return headerBegin().addOffsetTo(getStubOffset());              }\n+  public Address exceptionBegin()             { return headerBegin().addOffsetTo(getExceptionOffset());         }\n+  public Address deoptHandlerEntry()          { return headerBegin().addOffsetTo(getDeoptHandlerEntryOffset()); }\n+  public Address stubBegin()                  { return headerBegin().addOffsetTo(getStubOffset());              }\n+  public Address stubEnd()                    { return dataBegin();                                             }\n+  public Address oopsBegin()                  { return dataBegin();                                             }\n+  public Address oopsEnd()                    { return dataEnd();                                               }\n@@ -265,1 +265,1 @@\n-  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerBegin(); }\n+  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerEntry(); }\n@@ -493,1 +493,1 @@\n-  private int getDeoptHandlerOffset()           { return (int) deoptHandlerOffsetField          .getValue(addr); }\n+  private int getDeoptHandlerEntryOffset()      { return (int) deoptHandlerEntryOffsetField     .getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n+        if (pc.equals(nm.deoptHandlerEntry())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Frame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=vthread-deopt-c1\n+ * @summary Deoptimization test for virtual threads (C1)\n+ * @requires vm.continuations\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.opt.TieredStopAtLevel != 0\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   -XX:TieredStopAtLevel=1\n+ *                   Deoptimization\n+ *\/\n+\n+\/**\n+ * @test id=vthread-deopt-c2\n+ * @summary Deoptimization test for virtual threads (C2)\n+ * @requires vm.continuations\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   -XX:-TieredCompilation\n+ *                   Deoptimization\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.Objects;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class Deoptimization {\n+    static final WhiteBox white_box = WhiteBox.getWhiteBox();\n+\n+    static class TestTask implements Runnable {\n+        CyclicBarrier start_barrier = null;\n+        AtomicInteger completed_number = new AtomicInteger(0);\n+\n+        public void reset(int barrier_parties) {\n+            start_barrier = new CyclicBarrier(barrier_parties);\n+            completed_number.set(0);\n+        }\n+\n+        public int getNumberWaiting() {\n+            return start_barrier.getNumberWaiting();\n+        }\n+\n+        public int getNumberCompleted() {\n+            return completed_number.get();\n+        }\n+\n+        public void await() throws BrokenBarrierException, InterruptedException {\n+            start_barrier.await();\n+        }\n+\n+        public void run() {\n+            try {\n+                await();\n+            } catch(BrokenBarrierException e) {\n+                return;\n+            } catch(InterruptedException e) {\n+                return;\n+            }\n+\n+            completed_number.getAndIncrement();\n+        }\n+    }\n+\n+    static void test(TestTask task, Method method, int vthreads_num) throws Exception {\n+        task.reset(vthreads_num + 1 \/* 1 for the main thread *\/);\n+\n+        Thread[] vthreads = new Thread[vthreads_num];\n+        for (int i = 0; i < vthreads_num; i++) {\n+            vthreads[i] = Thread.startVirtualThread(task);\n+        }\n+\n+        while (task.getNumberWaiting() != vthreads_num) {\n+            Thread.onSpinWait();\n+        }\n+\n+        if (method != null) {\n+            if (!white_box.isMethodCompiled(method, false)) {\n+                throw new Error(\"Unexpectedly, it is not compiled.\");\n+            }\n+\n+            white_box.deoptimizeMethod(method);\n+\n+            if (white_box.isMethodCompiled(method, false)) {\n+                throw new Error(\"Unexpectedly, it is compiled.\");\n+            }\n+        }\n+\n+        task.await();\n+\n+        for (int i = 0; i < vthreads_num; i++) {\n+            vthreads[i].join();\n+        }\n+\n+        if (task.getNumberCompleted() != vthreads_num) {\n+            throw new Error(\"Some threads didn't reach completion\");\n+        }\n+    }\n+\n+    static int getIntegerOption(String option_name) {\n+        Object option_object = white_box.getVMFlag(option_name);\n+        String option_string = Objects.toString(option_object);\n+        return Integer.parseInt(option_string);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int tiered_stop_at_level = getIntegerOption(\"TieredStopAtLevel\");\n+\n+        Method method_run = TestTask.class.getMethod(\"run\");\n+        white_box.testSetDontInlineMethod(method_run, true);\n+\n+        Method method_await = TestTask.class.getMethod(\"await\");\n+        white_box.testSetDontInlineMethod(method_await, true);\n+\n+        TestTask task = new TestTask();\n+\n+        \/\/ Warm-up\n+        test(task, null, 2);\n+\n+        white_box.enqueueMethodForCompilation(method_run, tiered_stop_at_level);\n+\n+        \/\/ Deoptimization test\n+        test(task, method_run, 10000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/Deoptimization.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}