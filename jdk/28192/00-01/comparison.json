{"files":[{"patch":"@@ -2280,0 +2280,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -461,0 +461,2 @@\n+  guarantee(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+            \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -535,0 +535,7 @@\n+  enum AArch64_specific_constants {\n+    \/\/ The two parts should be checked separately to prevent out of bounds access in case\n+    \/\/ the return address points to the deopt handler stub code entry point which could be\n+    \/\/ at the end of page.\n+    first_check_size = 4\n+  };\n+\n@@ -538,1 +545,1 @@\n-      uint32_t insn = *(uint32_t*)addr_at(4);\n+      uint32_t insn = *(uint32_t*)addr_at(first_check_size);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -900,0 +900,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,0 +286,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -433,0 +433,7 @@\n+  enum arm_specific_constants {\n+    \/\/ If the check is adjusted to read beyond size of the instruction sequence at the deopt\n+    \/\/ handler stub code entry point, it has to happen in two stages - to prevent out of bounds\n+    \/\/ access in case the return address points to the entry point which could be at\n+    \/\/ the end of page.\n+    first_check_size = 4\n+  };\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -275,0 +275,2 @@\n+  guarantee(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+            \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-  bool is_post_call_nop() const { return MacroAssembler::is_post_call_nop(long_at(0)); }\n-\n@@ -534,0 +532,8 @@\n+  enum ppc_specific_constants {\n+    \/\/ If the check is adjusted to read beyond size of the instruction at the deopt handler stub\n+    \/\/ code entry point, it has to happen in two stages - to prevent out of bounds access in case\n+    \/\/ the return address points to the entry point which could be at the end of page.\n+    first_check_size = 4\n+  };\n+\n+  bool is_post_call_nop() const { return MacroAssembler::is_post_call_nop(long_at(0)); }\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2133,0 +2133,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -389,0 +389,2 @@\n+  guarantee(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+            \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -314,0 +314,7 @@\n+  enum RISCV_specific_constants {\n+    \/\/ The two parts should be checked separately to prevent out of bounds access in\n+    \/\/ case the return address points to the deopt handler stub code entry point\n+    \/\/ which could be at the end of page.\n+    first_check_size = 4\n+  };\n+\n@@ -319,1 +326,1 @@\n-    return is_nop() && MacroAssembler::is_lui_to_zr_at(addr_at(4));\n+    return is_nop() && MacroAssembler::is_lui_to_zr_at(addr_at(first_check_size));\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1847,0 +1847,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -291,0 +291,2 @@\n+  guarantee(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+            \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -652,0 +652,7 @@\n+  enum z_specific_constants {\n+    \/\/ Once the check is implemented, this has to specify number of bytes checked on the first\n+    \/\/ read. If the check would read beyond size of the instruction at the deopt handler stub\n+    \/\/ code entry point, then it has to happen in two stages - to prevent out of bounds access\n+    \/\/ in case the return address points to the entry point which could be at the end of page.\n+    first_check_size = 0\n+  };\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1694,0 +1694,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -464,0 +464,2 @@\n+  guarantee(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+            \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -582,1 +582,6 @@\n-    displacement_offset = 4\n+    displacement_offset = 4,\n+\n+    \/\/ The two parts should be checked separately to prevent out of bounds access in case\n+    \/\/ the return address points to the deopt handler stub code entry point which could be\n+    \/\/ at the end of page.\n+    first_check_size = 2\n@@ -585,1 +590,1 @@\n-  bool check() const { return short_at(0) == 0x1f0f && short_at(2) == 0x0084; }\n+  bool check() const { return short_at(0) == 0x1f0f && short_at(first_check_size) == 0x0084; }\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2888,0 +2888,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}