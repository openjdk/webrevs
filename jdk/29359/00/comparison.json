{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -3838,0 +3838,12 @@\n+    \/\/ When PreferSVEMergingModeCPY is enabled, optimize the SVE `cpy (immediate,\n+    \/\/ zeroing)` instruction as `movi + cpy (immediate, merging)` instructions\n+    \/\/ for better performance.\n+    if (PreferSVEMergingModeCPY && !isMerge) {\n+      \/\/ Generates a NEON instruction `movi Vd.2d, #0`.\n+      \/\/ On AArch64, Z and V registers alias in the low 128 bits, so Vd is the\n+      \/\/ low 128 bits of Zd. A write to Vd also clears all bits of Zd above 128,\n+      \/\/ so this `movi` instruction effectively zeroes the entire Zd register.\n+      \/\/ According to the Arm Software Optimization Guide, `movi` is zero cost.\n+      movi(Zd, T2D, 0);\n+      isMerge = true;\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,0 +107,2 @@\n+  product(bool, PreferSVEMergingModeCPY, false,                         \\\n+          \"Prefer SVE merging-mode CPY instruction\")                    \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,9 +224,6 @@\n-  \/\/   N1: 0xd0c\n-  \/\/   N2: 0xd49\n-  \/\/   N3: 0xd8e\n-  \/\/   V1: 0xd40\n-  \/\/   V2: 0xd4f\n-  \/\/   V3: 0xd84\n-  if (_cpu == CPU_ARM && (model_is(0xd0c) || model_is(0xd49) ||\n-                          model_is(0xd40) || model_is(0xd4f) ||\n-                          model_is(0xd8e) || model_is(0xd84))) {\n+  if (_cpu == CPU_ARM && (model_is(CPU_MODEL_NEOVERSE_N1) ||\n+                          model_is(CPU_MODEL_NEOVERSE_N2) ||\n+                          model_is(CPU_MODEL_NEOVERSE_N3) ||\n+                          model_is(CPU_MODEL_NEOVERSE_V1) ||\n+                          model_is(CPU_MODEL_NEOVERSE_V2) ||\n+                          model_is(CPU_MODEL_NEOVERSE_V3))) {\n@@ -264,4 +261,0 @@\n-  \/\/ Neoverse\n-  \/\/   V1: 0xd40\n-  \/\/   V2: 0xd4f\n-  \/\/   V3: 0xd84\n@@ -269,1 +262,3 @@\n-      (model_is(0xd40) || model_is(0xd4f) || model_is(0xd84))) {\n+      (model_is(CPU_MODEL_NEOVERSE_V1) ||\n+       model_is(CPU_MODEL_NEOVERSE_V2) ||\n+       model_is(CPU_MODEL_NEOVERSE_V3))) {\n@@ -606,0 +601,17 @@\n+  \/\/ Enable PreferSVEMergingModeCPY by default on Neoverse V1\/V2, because the\n+  \/\/ merging mode SVE CPY instruction performs better on them.\n+  if (_cpu == CPU_ARM && (model_is(CPU_MODEL_NEOVERSE_V1) ||\n+                          model_is(CPU_MODEL_NEOVERSE_V2))) {\n+    if (FLAG_IS_DEFAULT(PreferSVEMergingModeCPY)) {\n+      FLAG_SET_DEFAULT(PreferSVEMergingModeCPY, true);\n+    }\n+  }\n+\n+  \/\/ PreferSVEMergingModeCPY is only meaningful when SVE is enabled.\n+  if (UseSVE == 0 && PreferSVEMergingModeCPY) {\n+    if (!FLAG_IS_DEFAULT(PreferSVEMergingModeCPY)) {\n+      warning(\"PreferSVEMergingModeCPY specified, but SVE is disabled. Disabling PreferSVEMergingModeCPY\");\n+    }\n+    FLAG_SET_DEFAULT(PreferSVEMergingModeCPY, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-enum Ampere_CPU_Model {\n+  enum Ampere_CPU_Model {\n@@ -121,2 +121,11 @@\n-    CPU_MODEL_AMPERE_1B = 0xac5  \/* AMPERE_1B core Implements ARMv8.7 with CSSC, MTE, SM3\/SM4 extensions *\/\n-};\n+    CPU_MODEL_AMPERE_1B = 0xac5, \/* AMPERE_1B core Implements ARMv8.7 with CSSC, MTE, SM3\/SM4 extensions *\/\n+  };\n+\n+  enum Neoverse_CPU_Model {\n+    CPU_MODEL_NEOVERSE_N1 = 0xd0c,\n+    CPU_MODEL_NEOVERSE_N2 = 0xd49,\n+    CPU_MODEL_NEOVERSE_N3 = 0xd8e,\n+    CPU_MODEL_NEOVERSE_V1 = 0xd40,\n+    CPU_MODEL_NEOVERSE_V2 = 0xd4f,\n+    CPU_MODEL_NEOVERSE_V3 = 0xd84,\n+  };\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,3 @@\n+  \/\/ Disable PreferSVEMergingModeCPY to ensure consistent encoding with asmtest.out.h\n+  FlagSetting fs(PreferSVEMergingModeCPY, false);\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/test_assembler_aarch64.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2026, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8374349\n+ * @summary Test PreferSVEMergingModeCPY behavior with different flag settings\n+ *\n+ * @requires os.arch == \"aarch64\"\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller\n+ *             jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:UseSVE=0\n+ *                   compiler.arguments.TestPreferSVEMergingModeCPY\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:UseSVE=1\n+ *                   compiler.arguments.TestPreferSVEMergingModeCPY\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:UseSVE=0 -XX:+PreferSVEMergingModeCPY\n+ *                   compiler.arguments.TestPreferSVEMergingModeCPY optionSpecified\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:UseSVE=0 -XX:-PreferSVEMergingModeCPY\n+ *                   compiler.arguments.TestPreferSVEMergingModeCPY optionSpecified\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:UseSVE=1 -XX:+PreferSVEMergingModeCPY\n+ *                   compiler.arguments.TestPreferSVEMergingModeCPY optionSpecified\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:UseSVE=1 -XX:-PreferSVEMergingModeCPY\n+ *                   compiler.arguments.TestPreferSVEMergingModeCPY optionSpecified\n+ *\/\n+\n+package compiler.arguments;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n+\n+public class TestPreferSVEMergingModeCPY {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        boolean optionSpecified = Arrays.asList(args).contains(\"optionSpecified\");\n+\n+        int sveLevel = WB.getUintVMFlag(\"UseSVE\").intValue();\n+        Boolean optionValue = WB.getBooleanVMFlag(\"PreferSVEMergingModeCPY\");\n+        Asserts.assertNotNull(optionValue);\n+        boolean isDefault = WB.isDefaultVMFlag(\"PreferSVEMergingModeCPY\");\n+\n+        List<String> cpuFeatures = CPUInfo.getFeatures();\n+        boolean isNeoverseV1orV2 = !cpuFeatures.isEmpty() && isNeoverseV1orV2(cpuFeatures.get(0));\n+\n+        if (sveLevel == 0) {\n+            \/\/ UseSVE == 0\n+            if (!optionSpecified) {\n+                \/\/ Case 1: option not specified\n+                Asserts.assertFalse(optionValue.booleanValue(),\n+                        \"PreferSVEMergingModeCPY should be false when UseSVE=0 (default)\");\n+                Asserts.assertTrue(isDefault,\n+                        \"PreferSVEMergingModeCPY should remain default when not specified\");\n+            } else {\n+                \/\/ Case 3 & 4: option specified\n+                \/\/ Regardless of what user specified, VM forces it to false\n+                Asserts.assertFalse(optionValue.booleanValue(),\n+                        \"PreferSVEMergingModeCPY must be disabled when UseSVE=0\");\n+                Asserts.assertFalse(isDefault,\n+                        \"PreferSVEMergingModeCPY should not be default when explicitly set by user\");\n+            }\n+        } else {\n+            \/\/ UseSVE > 0\n+            if (!optionSpecified) {\n+                \/\/ Case 2: option not specified\n+                if (isNeoverseV1orV2) {\n+                    Asserts.assertTrue(optionValue.booleanValue(),\n+                            \"PreferSVEMergingModeCPY should be true on Neoverse V1\/V2 when UseSVE>0 (default)\");\n+                } else {\n+                    Asserts.assertFalse(optionValue.booleanValue(),\n+                            \"PreferSVEMergingModeCPY should be false on non-V1\/V2 CPUs when UseSVE>0 (default)\");\n+                }\n+                Asserts.assertTrue(isDefault,\n+                        \"PreferSVEMergingModeCPY should remain default when not specified\");\n+            } else {\n+                \/\/ Case 5 & 6: option specified\n+                \/\/ Option value should match what user specified\n+                Asserts.assertFalse(isDefault,\n+                        \"PreferSVEMergingModeCPY should not be default when explicitly set by user\");\n+            }\n+        }\n+    }\n+\n+    private static boolean isNeoverseV1orV2(String cpuModel) {\n+        \/\/ Neoverse V1: CPU implementer 0x41 (ARM), variant 0x0, part 0xd40\n+        \/\/ Neoverse V2: CPU implementer 0x41 (ARM), variant 0x0, part 0xd4f\n+        return cpuModel.contains(\"0xd40\") || cpuModel.contains(\"0xd4f\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestPreferSVEMergingModeCPY.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"}]}