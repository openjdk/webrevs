{"files":[{"patch":"@@ -230,0 +230,28 @@\n+    \/**\n+     * Get the enum constants for the given enum class symbol, if known.\n+     * They will only be found if they are defined within the same top-level\n+     * class as the class being compiled, so it's safe to assume that they\n+     * can't change at runtime due to a recompilation.\n+     *\/\n+    List<Name> enumNamesFor(ClassSymbol c) {\n+\n+        \/\/ Find the class definition and verify it is an enum class\n+        final JCClassDecl classDef = classDef(c);\n+        if (classDef == null ||\n+            (classDef.mods.flags & ENUM) == 0 ||\n+            (types.supertype(currentClass.type).tsym.flags() & ENUM) != 0) {\n+            return null;\n+        }\n+\n+        \/\/ Gather the enum identifiers\n+        ListBuffer<Name> idents = new ListBuffer<>();\n+        for (List<JCTree> defs = classDef.defs; defs.nonEmpty(); defs=defs.tail) {\n+            if (defs.head.hasTag(VARDEF) &&\n+                (((JCVariableDecl) defs.head).mods.flags & ENUM) != 0) {\n+                JCVariableDecl var = (JCVariableDecl)defs.head;\n+                idents.append(var.name);\n+            }\n+        }\n+        return idents.toList();\n+    }\n+\n@@ -430,4 +458,10 @@\n-        EnumMapping map = enumSwitchMap.get(enumClass);\n-        if (map == null)\n-            enumSwitchMap.put(enumClass, map = new EnumMapping(pos, enumClass));\n-        return map;\n+\n+        \/\/ If enum class is part of this compilation, just switch on ordinal value\n+        if (enumClass.kind == TYP) {\n+            final List<Name> idents = enumNamesFor((ClassSymbol)enumClass);\n+            if (idents != null)\n+                return new CompileTimeEnumMapping(idents);\n+        }\n+\n+        \/\/ Map identifiers to ordinal values at runtime, and then switch on that\n+        return enumSwitchMap.computeIfAbsent(enumClass, ec -> new RuntimeEnumMapping(pos, ec));\n@@ -436,2 +470,44 @@\n-    \/** This map gives a translation table to be used for enum\n-     *  switches.\n+    \/** Generates a test value and corresponding cases for a switch on an enum type.\n+     *\/\n+    interface EnumMapping {\n+\n+        \/** Given an expression for the enum value's ordinal, generate an expression for the switch statement.\n+         *\/\n+        JCExpression switchValue(JCExpression ordinalExpr);\n+\n+        \/** Generate the switch statement case value corresponding to the given enum value.\n+         *\/\n+        JCLiteral caseValue(VarSymbol v);\n+\n+        default void translate() {\n+        }\n+    }\n+\n+    \/** EnumMapping using compile-time constants. Only valid when compiling the enum class itself,\n+     *  because otherwise the ordinals we use could become obsolete if\/when the enum class is recompiled.\n+     *\/\n+    class CompileTimeEnumMapping implements EnumMapping {\n+\n+        final List<Name> enumNames;\n+\n+        CompileTimeEnumMapping(List<Name> enumNames) {\n+            Assert.check(enumNames != null);\n+            this.enumNames = enumNames;\n+        }\n+\n+        @Override\n+        public JCExpression switchValue(JCExpression ordinalExpr) {\n+            return ordinalExpr;\n+        }\n+\n+        @Override\n+        public JCLiteral caseValue(VarSymbol v) {\n+            final int ordinal = enumNames.indexOf(v.name);\n+            Assert.check(ordinal != -1);\n+            return make.Literal(ordinal);\n+        }\n+    }\n+\n+    \/** EnumMapping using run-time ordinal lookup.\n+     *\n+     *  This builds a translation table to be used for enum switches.\n@@ -469,2 +545,2 @@\n-    class EnumMapping {\n-        EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {\n+    class RuntimeEnumMapping implements EnumMapping {\n+        RuntimeEnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {\n@@ -503,1 +579,7 @@\n-        JCLiteral forConstant(VarSymbol v) {\n+        @Override\n+        public JCExpression switchValue(JCExpression ordinalExpr) {\n+            return make.Indexed(mapVar, ordinalExpr);\n+        }\n+\n+        @Override\n+        public JCLiteral caseValue(VarSymbol v) {\n@@ -511,1 +593,2 @@\n-        void translate() {\n+        @Override\n+        public void translate() {\n@@ -3763,1 +3846,1 @@\n-            newSelector = make.Indexed(map.mapVar,\n+            newSelector = map.switchValue(\n@@ -3774,1 +3857,1 @@\n-            newSelector = make.Indexed(map.mapVar,\n+            newSelector = map.switchValue(\n@@ -3786,1 +3869,1 @@\n-                    pat = map.forConstant(label);\n+                    pat = map.caseValue(label);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":96,"deletions":13,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-        \"ClassFileLoadHook$1\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/ClassFileLoadHookTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-        enum E {E1}\n@@ -72,1 +71,1 @@\n-        public int m (E e) {\n+        public int m (Thread.State e) {\n@@ -74,1 +73,1 @@\n-                case E1:\n+                case NEW:\n","filename":"test\/langtools\/tools\/javac\/T8011181\/EmptyUTF8ForInnerClassNameTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 7176515 8299760\n+ * @summary ExceptionInInitializerError for an enum with multiple switch statements\n+ *\/\n+\n+import java.math.RoundingMode;\n+\n+public class EnumLookupTableExceptionInInitializer {\n+\n+    public enum MyEnum {\n+        FIRST(RoundingMode.CEILING),\n+        SECOND(RoundingMode.HALF_DOWN),\n+        THIRD(RoundingMode.UNNECESSARY),\n+        FOURTH(RoundingMode.HALF_EVEN),\n+        FIFTH(RoundingMode.HALF_DOWN),\n+        SIXTH(RoundingMode.CEILING),\n+        SEVENTH(RoundingMode.UNNECESSARY);\n+\n+        private final RoundingMode mode;\n+\n+        private MyEnum(RoundingMode mode) {\n+            switch (mode) {\n+            case CEILING:\n+            case HALF_DOWN:\n+            case UNNECESSARY:\n+            case HALF_EVEN:\n+                break;\n+            default:\n+                throw new IllegalArgumentException();\n+            }\n+            this.mode = mode;\n+        }\n+\n+        public boolean isOdd() {\n+            switch (this) {\n+            case FIRST:\n+            case THIRD:\n+            case FIFTH:\n+            case SEVENTH:\n+                return true;\n+            default:\n+                return false;\n+            }\n+        }\n+    }\n+\n+    public enum Nested {\n+        AAA(MyEnum.FIRST),\n+        BBB(MyEnum.THIRD),\n+        CCC(MyEnum.FIFTH),\n+        DDD(MyEnum.SEVENTH),\n+        EEE(MyEnum.SECOND);\n+\n+        private Nested(MyEnum x) {\n+            switch (x) {\n+            default:\n+                break;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        boolean shouldBeOdd = true;\n+        for (MyEnum x : MyEnum.values()) {\n+            if (x.isOdd() != shouldBeOdd)\n+                throw new RuntimeException(\"failed\");\n+            shouldBeOdd = !shouldBeOdd;\n+        }\n+        Nested.class.hashCode();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/enum\/EnumLookupTableExceptionInInitializer.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}