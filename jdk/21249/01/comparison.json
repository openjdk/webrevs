{"files":[{"patch":"@@ -413,0 +413,5 @@\n+         * @apiNote\n+         * If a {@link HttpRequest} has an {@code Authorization} or {@code\n+         * Proxy-Authorization} header set then its value will override any\n+         * value derived from the given {@link Authenticator}.\n+         *\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -247,0 +247,8 @@\n+        if (req.getUserSetAuthFlag(SERVER) && status == 401) {\n+            \/\/ return the response. We don't handle it.\n+            return null;\n+        } else if (req.getUserSetAuthFlag(PROXY) && status == 407) {\n+            \/\/ same\n+            return null;\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -94,1 +96,0 @@\n-\n@@ -109,0 +110,2 @@\n+        Utils.setUserAuthFlags(request, userHeaders);\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-            return Utils.CONTEXT_RESTRICTED(client);\n+            return (k, v) -> true;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.net.Authenticator;\n@@ -50,0 +51,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -69,0 +72,2 @@\n+    private volatile boolean userSetAuthorization;\n+    private volatile boolean userSetProxyAuthorization;\n@@ -336,0 +341,24 @@\n+    \/**\n+     * These flags are set if the user set an Authorization or Proxy-Authorization header\n+     * overriding headers produced by an Authenticator that was also set\n+     *\n+     * The values are checked in the AuthenticationFilter which tells the library\n+     * to return whatever response received to the user instead of causing request\n+     * to be resent, in case of error.\n+     *\/\n+    public void setUserSetAuthFlag(Authenticator.RequestorType type, boolean value) {\n+        if (type == SERVER) {\n+            userSetAuthorization = value;\n+        } else {\n+            userSetProxyAuthorization = value;\n+        }\n+    }\n+\n+    public boolean getUserSetAuthFlag(Authenticator.RequestorType type) {\n+        if (type == SERVER) {\n+            return userSetAuthorization;\n+        } else {\n+            return userSetProxyAuthorization;\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestImpl.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+                                    System.out.println(\"CLOSING DELEGATE\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainTunnelingConnection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -781,1 +781,2 @@\n-        userh = HttpHeaders.of(userh.map(), Utils.CONTEXT_RESTRICTED(client()));\n+        userh = HttpHeaders.of(userh.map(), (k, v) -> true);\n+        Utils.setUserAuthFlags(request, userh);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -213,13 +215,0 @@\n-    \/\/ Headers that are not generally restricted, and can therefore be set by users,\n-    \/\/ but can in some contexts be overridden by the implementation.\n-    \/\/ Currently, only contains \"Authorization\" which will\n-    \/\/ be overridden, when an Authenticator is set on the HttpClient.\n-    \/\/ Needs to be BiPred<String,String> to fit with general form of predicates\n-    \/\/ used by caller.\n-\n-    public static final BiPredicate<String, String> CONTEXT_RESTRICTED(HttpClient client) {\n-        return (k, v) -> client.authenticator().isEmpty() ||\n-                (!k.equalsIgnoreCase(\"Authorization\")\n-                        && !k.equalsIgnoreCase(\"Proxy-Authorization\"));\n-    }\n-\n@@ -230,1 +219,1 @@\n-        return CONTEXT_RESTRICTED(client).and(HOST_RESTRICTED);\n+        return HOST_RESTRICTED;\n@@ -313,0 +302,13 @@\n+    \/**\n+     * Check the user headers to see if the Authorization or ProxyAuthorization\n+     * were set. We need to set special flags in the request if so. Otherwise\n+     * we can't distinguish user set from Authenticator set headers\n+     *\/\n+    public static void setUserAuthFlags(HttpRequestImpl request, HttpHeaders userHeaders) {\n+        if (userHeaders.firstValue(\"Authorization\").isPresent()) {\n+            request.setUserSetAuthFlag(SERVER, true);\n+        }\n+        if (userHeaders.firstValue(\"Proxy-Authorization\").isPresent()) {\n+            request.setUserSetAuthFlag(PROXY, true);\n+        }\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.net.httpserver.Headers;\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import java.io.*;\n-import java.net.Authenticator;\n-import java.net.InetSocketAddress;\n-import java.net.ProxySelector;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.nio.channels.*;\n-import java.nio.charset.StandardCharsets;\n-\n-import jdk.test.lib.net.IPSupport;\n-\n-\/**\n- * @test\n- * @bug 8263442\n- * @summary Potential bug in jdk.internal.net.http.common.Utils.CONTEXT_RESTRICTED\n- * @library \/test\/lib\n- * @run main\/othervm AuthFilter\n- *\/\n-\n-public class AuthFilter {\n-    static class Auth extends Authenticator {\n-    }\n-\n-    static HttpServer createServer() throws IOException {\n-        HttpServer server = HttpServer.create(new InetSocketAddress(0), 5);\n-        HttpHandler handler = (HttpExchange e) -> {\n-            InputStream is = e.getRequestBody();\n-            is.readAllBytes();\n-            is.close();\n-            Headers reqh = e.getRequestHeaders();\n-            if (reqh.containsKey(\"authorization\")) {\n-                e.sendResponseHeaders(500, -1);\n-            } else {\n-                e.sendResponseHeaders(200, -1);\n-            }\n-        };\n-        server.createContext(\"\/\", handler);\n-        return server;\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        test(false);\n-        test(true);\n-    }\n-\n-    \/**\n-     *  Fake proxy. Just looks for Proxy-Authorization header\n-     *  and returns error if seen. Returns 200 OK if not.\n-     *  Does not actually forward the request\n-     *\/\n-    static class ProxyServer extends Thread {\n-\n-        final ServerSocketChannel server;\n-        final int port;\n-        volatile SocketChannel c;\n-\n-        ProxyServer() throws IOException {\n-            server = ServerSocketChannel.open();\n-            server.bind(new InetSocketAddress(0));\n-            if (server.getLocalAddress() instanceof InetSocketAddress isa) {\n-                port = isa.getPort();\n-            } else {\n-                port = -1;\n-            }\n-        }\n-\n-        int getPort() {\n-            return port;\n-        }\n-\n-        static String ok = \"HTTP\/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-        static String notok1 = \"HTTP\/1.1 500 Internal Server Error\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-        static String notok2 = \"HTTP\/1.1 501 Not Implemented\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-\n-        static void reply(String msg, Writer writer) throws IOException {\n-            writer.write(msg);\n-            writer.flush();\n-        }\n-\n-        public void run() {\n-            try {\n-                c = server.accept();\n-                var cs = StandardCharsets.US_ASCII;\n-                LineNumberReader reader = new LineNumberReader(Channels.newReader(c, cs));\n-                Writer writer = Channels.newWriter(c, cs);\n-\n-                String line;\n-                while ((line=reader.readLine()) != null) {\n-                    if (line.indexOf(\"Proxy-Authorization\") != -1) {\n-                        reply(notok1, writer);\n-                        return;\n-                    }\n-                    if (line.equals(\"\")) {\n-                        \/\/ end of headers\n-                        reply(ok, writer);\n-                        return;\n-                    }\n-                }\n-                reply(notok2, writer);\n-            } catch (IOException e) {\n-            }\n-            try {\n-                server.close();\n-                c.close();\n-            } catch (IOException ee) {}\n-        }\n-    }\n-\n-    private static InetSocketAddress getLoopback(int port) throws IOException {\n-        if (IPSupport.hasIPv4()) {\n-            return new InetSocketAddress(\"127.0.0.1\", port);\n-        } else {\n-            return new InetSocketAddress(\"::1\", port);\n-        }\n-    }\n-\n-    public static void test(boolean useProxy) throws Exception {\n-        HttpServer server = createServer();\n-        int port = server.getAddress().getPort();\n-        ProxyServer proxy;\n-\n-        InetSocketAddress proxyAddr;\n-        String authHdr;\n-        if (useProxy) {\n-            proxy = new ProxyServer();\n-            proxyAddr = getLoopback(proxy.getPort());\n-            proxy.start();\n-            authHdr = \"Proxy-Authorization\";\n-        } else {\n-            authHdr = \"Authorization\";\n-            proxyAddr = null;\n-        }\n-\n-        server.start();\n-\n-        \/\/ proxyAddr == null => proxying disabled\n-        HttpClient client = HttpClient\n-                .newBuilder()\n-                .authenticator(new Auth())\n-                .proxy(ProxySelector.of(proxyAddr))\n-                .build();\n-\n-\n-        URI uri = new URI(\"http:\/\/127.0.0.1:\" + Integer.toString(port));\n-\n-        HttpRequest request = HttpRequest.newBuilder(uri)\n-                .header(authHdr, \"nonsense\")\n-                .GET()\n-                .build();\n-\n-        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n-        int r = response.statusCode();\n-        System.out.println(r);\n-        server.stop(0);\n-        if (r != 200)\n-            throw new RuntimeException(\"Test failed : \" + r);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilter.java","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8326949\n+ * @run main\/othervm UserAuthWithAuthenticator\n+ * @summary Authorization header is removed when a proxy Authenticator is set\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.regex.*;\n+import java.util.*;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n+public class UserAuthWithAuthenticator {\n+\n+    static final String data = \"0123456789\";\n+\n+    static final String data1 = \"ABCDEFGHIJKL\";\n+\n+    static final String[] proxyResponses = {\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data.length() + \"\\r\\n\\r\\n\" + data\n+    };\n+\n+    static final String[] proxyWithErrorResponses = {\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+    };\n+\n+    static final String[] serverResponses = {\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data1.length() + \"\\r\\n\\r\\n\" + data1\n+    };\n+\n+    static final String[] authenticatorResponses = {\n+        \"HTTP\/1.1 401 Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"WWW-Authenticate: Basic realm=\\\"Access to the server\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data1.length() + \"\\r\\n\\r\\n\" + data1\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        testServerOnly();\n+        testServerWithProxy();\n+        testServerWithProxyError();\n+        testServerOnlyAuthenticator();\n+    }\n+\n+    static void testServerWithProxy() throws IOException, InterruptedException {\n+        Mocker proxyMock = new Mocker(proxyResponses);\n+        proxyMock.start();\n+        try {\n+\n+            var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .proxy(new ProxySel(proxyMock.getPort()))\n+                .authenticator(new ProxyAuth())\n+                .build();\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var badCreds = \"user:wrong\";\n+            var encoded1 = java.util.Base64.getEncoder().encodeToString(badCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(\"http:\/\/127.0.0.1\/some_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Authorization\", \"Basic \" + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data, response.body());\n+            var proxyStr = proxyMock.getRequest(1);\n+\n+            assertContains(proxyStr, \"\/some_url\");\n+            assertPattern(\".*^Proxy-Authorization:.*Basic \" + encoded + \".*\", proxyStr);\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", proxyStr);\n+            assertPattern(\".*^Authorization:.*Basic.*\", proxyStr);\n+            System.out.println(\"testServerWithProxy: OK\");\n+        } finally {\n+            proxyMock.stopMocker();\n+        }\n+    }\n+\n+    static void testServerWithProxyError() throws IOException, InterruptedException {\n+        Mocker proxyMock = new Mocker(proxyWithErrorResponses);\n+        proxyMock.start();\n+        try {\n+\n+            var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .proxy(new ProxySel(proxyMock.getPort()))\n+                .authenticator(new ProxyAuth())\n+                .build();\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var badCreds = \"user:wrong\";\n+            var encoded1 = java.util.Base64.getEncoder().encodeToString(badCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(\"http:\/\/127.0.0.1\/some_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Proxy-Authorization\", \"Basic \" + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+            assertEquals(407, response.statusCode());\n+            System.out.println(\"testServerWithProxy: OK\");\n+        } finally {\n+            proxyMock.stopMocker();\n+        }\n+    }\n+\n+    static void testServerOnly() throws IOException, InterruptedException {\n+        Mocker serverMock = new Mocker(serverResponses);\n+        serverMock.start();\n+        try {\n+            var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .build();\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(serverMock.baseURL() + \"\/some_serv_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Authorization\", \"Basic \" + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data1, response.body());\n+\n+            var serverStr = serverMock.getRequest(0);\n+            assertContains(serverStr, \"\/some_serv_url\");\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", serverStr);\n+            assertPattern(\".*^Authorization:.*Basic \" + encoded + \".*\", serverStr);\n+            System.out.println(\"testServerOnly: OK\");\n+        } finally {\n+            serverMock.stopMocker();\n+        }\n+    }\n+\n+    \/\/ This is effectively a regression test for existing behavior\n+    static void testServerOnlyAuthenticator() throws IOException, InterruptedException {\n+        Mocker serverMock = new Mocker(authenticatorResponses);\n+        serverMock.start();\n+        try {\n+            var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .authenticator(new ServerAuth())\n+                .build();\n+\n+            \/\/ credentials set in the server authenticator\n+            var plainCreds = \"serverUser:serverPwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(serverMock.baseURL() + \"\/some_serv_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data1, response.body());\n+\n+            var serverStr = serverMock.getRequest(1);\n+            assertContains(serverStr, \"\/some_serv_url\");\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", serverStr);\n+            assertPattern(\".*^Authorization:.*Basic \" + encoded + \".*\", serverStr);\n+            System.out.println(\"testServerOnlyAuthenticator: OK\");\n+        } finally {\n+            serverMock.stopMocker();\n+        }\n+    }\n+\n+    static void close(Closeable... clarray) {\n+        for (Closeable c : clarray) {\n+            try {\n+                c.close();\n+            } catch (Exception e) {}\n+        }\n+    }\n+\n+    static class Mocker extends Thread {\n+        final ServerSocket ss;\n+        final String[] responses;\n+        volatile List<String> requests;\n+        volatile InputStream in;\n+        volatile OutputStream out;\n+        volatile Socket s = null;\n+\n+        public Mocker(String[] responses) throws IOException {\n+            this.ss = new ServerSocket(0);\n+            this.responses = responses;\n+            this.requests = new LinkedList<>();\n+        }\n+\n+        public void stopMocker() {\n+            close(ss, s, in, out);\n+        }\n+\n+        public int getPort() {\n+            return ss.getLocalPort();\n+        }\n+\n+        public String baseURL() {\n+            return \"http:\/\/127.0.0.1:\" + getPort();\n+        }\n+\n+        private String readRequest() throws IOException {\n+            String req = \"\";\n+            while (!req.endsWith(\"\\r\\n\\r\\n\")) {\n+                int x = in.read();\n+                if (x == -1) {\n+                    s.close();\n+                    s = ss.accept();\n+                    in = s.getInputStream();\n+                    out = s.getOutputStream();\n+                }\n+                req += (char)x;\n+            }\n+            return req;\n+        }\n+\n+        public String getRequest(int i) {\n+            return requests.get(i);\n+        }\n+\n+        public void run() {\n+            try {\n+                int index=0;\n+                s = ss.accept();\n+                in = s.getInputStream();\n+                out = s.getOutputStream();\n+                while (index < responses.length) {\n+                    requests.add(readRequest());\n+                    out.write(responses[index++].getBytes(US_ASCII));\n+                }\n+            } catch (Exception e) {\n+                \/\/e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    static class ProxySel extends ProxySelector {\n+        final int port;\n+\n+        ProxySel(int port) {\n+            this.port = port;\n+        }\n+        @Override\n+        public List<Proxy> select(URI uri) {\n+          return List.of(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\"localhost\", port)));\n+        }\n+\n+        @Override\n+        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {}\n+\n+    }\n+\n+    static class ProxyAuth extends Authenticator {\n+        @Override\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            if (getRequestorType() != RequestorType.PROXY) {\n+                \/\/ We only want to handle proxy authentication here\n+                return null;\n+            }\n+            return new PasswordAuthentication(\"proxyUser\", \"proxyPwd\".toCharArray());\n+        }\n+    }\n+\n+    static class ServerAuth extends Authenticator {\n+        @Override\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            if (getRequestorType() != RequestorType.SERVER) {\n+                \/\/ We only want to handle proxy authentication here\n+                return null;\n+            }\n+            return new PasswordAuthentication(\"serverUser\", \"serverPwd\".toCharArray());\n+        }\n+    }\n+\n+    static void assertEquals(int a, int b) {\n+        if (a != b) {\n+            String msg = String.format(\"Error: expected %d Got %d\", a, b);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertEquals(String s1, String s2) {\n+        if (!s1.equals(s2)) {\n+            String msg = String.format(\"Error: expected %s Got %s\", s1, s2);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertContains(String container, String containee) {\n+        if (!container.contains(containee)) {\n+            String msg = String.format(\"Error: expected %s Got %s\", container, containee);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertPattern(String pattern, String candidate) {\n+        Pattern pat = Pattern.compile(pattern, Pattern.DOTALL | Pattern.MULTILINE);\n+        Matcher matcher = pat.matcher(candidate);\n+        if (!matcher.matches()) {\n+            String msg = String.format(\"Error: expected %s Got %s\", pattern, candidate);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/UserAuthWithAuthenticator.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"}]}