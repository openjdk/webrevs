{"files":[{"patch":"@@ -246,0 +246,3 @@\n+        boolean authenticatorPresent =\n+            exchange.client().authenticator().isPresent();\n+        boolean userSetAuth = req.tryUserSetAuthorization();\n@@ -247,1 +250,13 @@\n-        if (status != PROXY_UNAUTHORIZED) {\n+        if (userSetAuth && status != PROXY_UNAUTHORIZED && status != UNAUTHORIZED) {\n+            return null;\n+        }\n+\n+        if (authenticatorPresent && userSetAuth &&\n+            (status == PROXY_UNAUTHORIZED || status == UNAUTHORIZED))\n+        {\n+            \/\/ a user set Authorization header is allowed to\n+            \/\/ override the Authenticator, but this behavior\n+            \/\/ is disabled if authentication fails\n+            req.tryUserSetAuthorization(false);\n+        }\n+        if (!userSetAuth && status != PROXY_UNAUTHORIZED) {\n@@ -269,1 +284,1 @@\n-        if (authvals.isEmpty() && exchange.client().authenticator().isPresent()) {\n+        if (authvals.isEmpty() && authenticatorPresent) {\n@@ -333,1 +348,1 @@\n-            if (exchange.client().authenticator().isEmpty()) return null;\n+            if (!authenticatorPresent) return null;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-            return Utils.PROXY_TUNNEL_RESTRICTED(client);\n+            return Utils.PROXY_TUNNEL_RESTRICTED(client, request);\n@@ -365,1 +365,1 @@\n-            return Utils.CONTEXT_RESTRICTED(client);\n+            return Utils.CONTEXT_RESTRICTED(client, request);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    private volatile boolean tryUserSetAuthorization = true;\n@@ -336,0 +337,8 @@\n+    public boolean tryUserSetAuthorization() {\n+        return tryUserSetAuthorization;\n+    }\n+\n+    public void tryUserSetAuthorization(boolean value) {\n+        this.tryUserSetAuthorization = value;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestImpl.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -781,1 +781,1 @@\n-        userh = HttpHeaders.of(userh.map(), Utils.CONTEXT_RESTRICTED(client()));\n+        userh = HttpHeaders.of(userh.map(), Utils.CONTEXT_RESTRICTED(client(), request));\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,4 +220,26 @@\n-    public static final BiPredicate<String, String> CONTEXT_RESTRICTED(HttpClient client) {\n-        return (k, v) -> client.authenticator().isEmpty() ||\n-                (!k.equalsIgnoreCase(\"Authorization\")\n-                        && !k.equalsIgnoreCase(\"Proxy-Authorization\"));\n+    public static final BiPredicate<String, String> CONTEXT_RESTRICTED(\n+        HttpClient client, HttpRequestImpl req)\n+    {\n+\/*\n+        return (k, v) -> client.authenticator().isEmpty()\n+            || (!k.equalsIgnoreCase(\"Authorization\")\n+                && !k.equalsIgnoreCase(\"Proxy-Authorization\"))\n+\n+            \/\/ flag may be true for first attempt, and will be false\n+            \/\/ for subsequent attempts if the first attempt failed\n+            \/\/ due to 401\/407\n+\n+            || req.tryUserSetAuthorization();\n+*\/\n+        return (k, v) -> {\n+            boolean r = client.authenticator().isEmpty()\n+            || (!k.equalsIgnoreCase(\"Authorization\")\n+                && !k.equalsIgnoreCase(\"Proxy-Authorization\"))\n+\n+            \/\/ flag may be true for first attempt, and will be false\n+            \/\/ for subsequent attempts if the first attempt failed\n+            \/\/ due to 401\/407\n+\n+            || req.tryUserSetAuthorization();\n+            return r;\n+        };\n@@ -229,2 +251,2 @@\n-    public static final BiPredicate<String, String> PROXY_TUNNEL_RESTRICTED(HttpClient client)  {\n-        return CONTEXT_RESTRICTED(client).and(HOST_RESTRICTED);\n+    public static final BiPredicate<String, String> PROXY_TUNNEL_RESTRICTED(HttpClient client, HttpRequestImpl req)  {\n+        return CONTEXT_RESTRICTED(client, req).and(HOST_RESTRICTED);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8326949\n+ * @run main\/othervm UserAuthWithAuthenticator\n+ * @summary Authorization header is removed when a proxy Authenticator is set\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.regex.*;\n+import java.util.*;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n+public class UserAuthWithAuthenticator {\n+\n+    static final String data = \"0123456789\";\n+\n+    static final String data1 = \"ABCDEFGHIJKL\";\n+\n+    static final String[] proxyResponses = {\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data.length() + \"\\r\\n\\r\\n\" + data\n+    };\n+\n+    static final String[] serverResponses = {\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data1.length() + \"\\r\\n\\r\\n\" + data1\n+    };\n+\n+    static final String[] authenticatorResponses = {\n+        \"HTTP\/1.1 401 Authentication Required\\r\\n\"+\n+        \"WWW-Authenticate: Basic realm=\\\"Access to the server\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data1.length() + \"\\r\\n\\r\\n\" + data1\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        testServerOnly();\n+        testServerWithProxy();\n+        testServerOnlyAuthenticator();\n+    }\n+\n+    static void testServerWithProxy() throws IOException, InterruptedException {\n+        Mocker proxyMock = new Mocker(proxyResponses);\n+        proxyMock.start();\n+        try {\n+\n+            var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .proxy(new ProxySel(proxyMock.getPort()))\n+                .authenticator(new ProxyAuth())\n+                .build();\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var badCreds = \"user:wrong\";\n+            var encoded1 = java.util.Base64.getEncoder().encodeToString(badCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(\"http:\/\/127.0.0.1\/some_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Authorization\", \"Basic \" + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data, response.body());\n+            var proxyStr = proxyMock.getRequest(1);\n+\n+            assertContains(proxyStr, \"\/some_url\");\n+            assertPattern(\".*^Proxy-Authorization:.*Basic \" + encoded + \".*\", proxyStr);\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", proxyStr);\n+            assertPattern(\".*^Authorization:.*Basic.*\", proxyStr);\n+            System.out.println(\"testServerWithProxy: OK\");\n+        } finally {\n+            proxyMock.stopMocker();\n+        }\n+    }\n+\n+    static void testServerOnly() throws IOException, InterruptedException {\n+        Mocker serverMock = new Mocker(serverResponses);\n+        serverMock.start();\n+        try {\n+            var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .build();\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(serverMock.baseURL() + \"\/some_serv_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Authorization\", \"Basic \" + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data1, response.body());\n+\n+            var serverStr = serverMock.getRequest(0);\n+            assertContains(serverStr, \"\/some_serv_url\");\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", serverStr);\n+            assertPattern(\".*^Authorization:.*Basic \" + encoded + \".*\", serverStr);\n+            System.out.println(\"testServerOnly: OK\");\n+        } finally {\n+            serverMock.stopMocker();\n+        }\n+    }\n+\n+    \/\/ This is effectively a regression test for existing behavior\n+    static void testServerOnlyAuthenticator() throws IOException, InterruptedException {\n+        Mocker serverMock = new Mocker(authenticatorResponses);\n+        serverMock.start();\n+        try {\n+            var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .authenticator(new ServerAuth())\n+                .build();\n+\n+            \/\/ credentials set in the server authenticator\n+            var plainCreds = \"serverUser:serverPwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(serverMock.baseURL() + \"\/some_serv_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data1, response.body());\n+\n+            var serverStr = serverMock.getRequest(1);\n+            assertContains(serverStr, \"\/some_serv_url\");\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", serverStr);\n+            assertPattern(\".*^Authorization:.*Basic \" + encoded + \".*\", serverStr);\n+            System.out.println(\"testServerOnlyAuthenticator: OK\");\n+        } finally {\n+            serverMock.stopMocker();\n+        }\n+    }\n+\n+    static void close(Closeable... clarray) {\n+        for (Closeable c : clarray) {\n+            try {\n+                c.close();\n+            } catch (Exception e) {}\n+        }\n+    }\n+\n+    static class Mocker extends Thread {\n+        final ServerSocket ss;\n+        final String[] responses;\n+        volatile List<String> requests;\n+        volatile InputStream in;\n+        volatile OutputStream out;\n+        volatile Socket s = null;\n+\n+        public Mocker(String[] responses) throws IOException {\n+            this.ss = new ServerSocket(0);\n+            this.responses = responses;\n+            this.requests = new LinkedList<>();\n+        }\n+\n+        public void stopMocker() {\n+            close(ss, s, in, out);\n+        }\n+\n+        public int getPort() {\n+            return ss.getLocalPort();\n+        }\n+\n+        public String baseURL() {\n+            return \"http:\/\/127.0.0.1:\" + getPort();\n+        }\n+\n+        private String readRequest() throws IOException {\n+            String req = \"\";\n+            while (!req.endsWith(\"\\r\\n\\r\\n\")) {\n+                int x = in.read();\n+                if (x == -1) {\n+                    s.close();\n+                    s = ss.accept();\n+                    in = s.getInputStream();\n+                    out = s.getOutputStream();\n+                }\n+                req += (char)x;\n+            }\n+            return req;\n+        }\n+\n+        public String getRequest(int i) {\n+            return requests.get(i);\n+        }\n+\n+        public void run() {\n+            try {\n+                int index=0;\n+                s = ss.accept();\n+                in = s.getInputStream();\n+                out = s.getOutputStream();\n+                while (true) {\n+                    requests.add(readRequest());\n+                    out.write(responses[index++].getBytes(US_ASCII));\n+                }\n+            } catch (Exception e) {\n+                System.err.println(\"Delete this: \" + e);\n+                \/\/e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    static class ProxySel extends ProxySelector {\n+        final int port;\n+\n+        ProxySel(int port) {\n+            this.port = port;\n+        }\n+        @Override\n+        public List<Proxy> select(URI uri) {\n+          return List.of(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\"localhost\", port)));\n+        }\n+\n+        @Override\n+        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {}\n+\n+    }\n+\n+    static class ProxyAuth extends Authenticator {\n+        @Override\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            if (getRequestorType() != RequestorType.PROXY) {\n+                \/\/ We only want to handle proxy authentication here\n+                return null;\n+            }\n+            return new PasswordAuthentication(\"proxyUser\", \"proxyPwd\".toCharArray());\n+        }\n+    }\n+\n+    static class ServerAuth extends Authenticator {\n+        @Override\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            if (getRequestorType() != RequestorType.SERVER) {\n+                \/\/ We only want to handle proxy authentication here\n+                return null;\n+            }\n+            return new PasswordAuthentication(\"serverUser\", \"serverPwd\".toCharArray());\n+        }\n+    }\n+\n+    static void assertEquals(int a, int b) {\n+        if (a != b) {\n+            String msg = String.format(\"Error: expected %d Got %d\", a, b);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertEquals(String s1, String s2) {\n+        if (!s1.equals(s2)) {\n+            String msg = String.format(\"Error: expected %s Got %s\", s1, s2);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertContains(String container, String containee) {\n+        if (!container.contains(containee)) {\n+            String msg = String.format(\"Error: expected %s Got %s\", container, containee);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertPattern(String pattern, String candidate) {\n+        Pattern pat = Pattern.compile(pattern, Pattern.DOTALL | Pattern.MULTILINE);\n+        Matcher matcher = pat.matcher(candidate);\n+        if (!matcher.matches()) {\n+            String msg = String.format(\"Error: expected %s Got %s\", pattern, candidate);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/UserAuthWithAuthenticator.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"}]}