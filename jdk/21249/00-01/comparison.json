{"files":[{"patch":"@@ -413,0 +413,5 @@\n+         * @apiNote\n+         * If a {@link HttpRequest} has an {@code Authorization} or {@code\n+         * Proxy-Authorization} header set then its value will override any\n+         * value derived from the given {@link Authenticator}.\n+         *\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -246,3 +246,0 @@\n-        boolean authenticatorPresent =\n-            exchange.client().authenticator().isPresent();\n-        boolean userSetAuth = req.tryUserSetAuthorization();\n@@ -250,1 +247,5 @@\n-        if (userSetAuth && status != PROXY_UNAUTHORIZED && status != UNAUTHORIZED) {\n+        if (req.getUserSetAuthFlag(SERVER) && status == 401) {\n+            \/\/ return the response. We don't handle it.\n+            return null;\n+        } else if (req.getUserSetAuthFlag(PROXY) && status == 407) {\n+            \/\/ same\n@@ -254,9 +255,1 @@\n-        if (authenticatorPresent && userSetAuth &&\n-            (status == PROXY_UNAUTHORIZED || status == UNAUTHORIZED))\n-        {\n-            \/\/ a user set Authorization header is allowed to\n-            \/\/ override the Authenticator, but this behavior\n-            \/\/ is disabled if authentication fails\n-            req.tryUserSetAuthorization(false);\n-        }\n-        if (!userSetAuth && status != PROXY_UNAUTHORIZED) {\n+        if (status != PROXY_UNAUTHORIZED) {\n@@ -284,1 +277,1 @@\n-        if (authvals.isEmpty() && authenticatorPresent) {\n+        if (authvals.isEmpty() && exchange.client().authenticator().isPresent()) {\n@@ -348,1 +341,1 @@\n-            if (!authenticatorPresent) return null;\n+            if (exchange.client().authenticator().isEmpty()) return null;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -94,1 +96,0 @@\n-\n@@ -109,0 +110,2 @@\n+        Utils.setUserAuthFlags(request, userHeaders);\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-            return Utils.PROXY_TUNNEL_RESTRICTED(client, request);\n+            return Utils.PROXY_TUNNEL_RESTRICTED(client);\n@@ -365,1 +365,1 @@\n-            return Utils.CONTEXT_RESTRICTED(client, request);\n+            return (k, v) -> true;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.net.Authenticator;\n@@ -50,0 +51,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -69,1 +72,2 @@\n-    private volatile boolean tryUserSetAuthorization = true;\n+    private volatile boolean userSetAuthorization;\n+    private volatile boolean userSetProxyAuthorization;\n@@ -337,2 +341,14 @@\n-    public boolean tryUserSetAuthorization() {\n-        return tryUserSetAuthorization;\n+    \/**\n+     * These flags are set if the user set an Authorization or Proxy-Authorization header\n+     * overriding headers produced by an Authenticator that was also set\n+     *\n+     * The values are checked in the AuthenticationFilter which tells the library\n+     * to return whatever response received to the user instead of causing request\n+     * to be resent, in case of error.\n+     *\/\n+    public void setUserSetAuthFlag(Authenticator.RequestorType type, boolean value) {\n+        if (type == SERVER) {\n+            userSetAuthorization = value;\n+        } else {\n+            userSetProxyAuthorization = value;\n+        }\n@@ -341,2 +357,6 @@\n-    public void tryUserSetAuthorization(boolean value) {\n-        this.tryUserSetAuthorization = value;\n+    public boolean getUserSetAuthFlag(Authenticator.RequestorType type) {\n+        if (type == SERVER) {\n+            return userSetAuthorization;\n+        } else {\n+            return userSetProxyAuthorization;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestImpl.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+                                    System.out.println(\"CLOSING DELEGATE\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainTunnelingConnection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -781,1 +781,2 @@\n-        userh = HttpHeaders.of(userh.map(), Utils.CONTEXT_RESTRICTED(client(), request));\n+        userh = HttpHeaders.of(userh.map(), (k, v) -> true);\n+        Utils.setUserAuthFlags(request, userh);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -213,35 +215,0 @@\n-    \/\/ Headers that are not generally restricted, and can therefore be set by users,\n-    \/\/ but can in some contexts be overridden by the implementation.\n-    \/\/ Currently, only contains \"Authorization\" which will\n-    \/\/ be overridden, when an Authenticator is set on the HttpClient.\n-    \/\/ Needs to be BiPred<String,String> to fit with general form of predicates\n-    \/\/ used by caller.\n-\n-    public static final BiPredicate<String, String> CONTEXT_RESTRICTED(\n-        HttpClient client, HttpRequestImpl req)\n-    {\n-\/*\n-        return (k, v) -> client.authenticator().isEmpty()\n-            || (!k.equalsIgnoreCase(\"Authorization\")\n-                && !k.equalsIgnoreCase(\"Proxy-Authorization\"))\n-\n-            \/\/ flag may be true for first attempt, and will be false\n-            \/\/ for subsequent attempts if the first attempt failed\n-            \/\/ due to 401\/407\n-\n-            || req.tryUserSetAuthorization();\n-*\/\n-        return (k, v) -> {\n-            boolean r = client.authenticator().isEmpty()\n-            || (!k.equalsIgnoreCase(\"Authorization\")\n-                && !k.equalsIgnoreCase(\"Proxy-Authorization\"))\n-\n-            \/\/ flag may be true for first attempt, and will be false\n-            \/\/ for subsequent attempts if the first attempt failed\n-            \/\/ due to 401\/407\n-\n-            || req.tryUserSetAuthorization();\n-            return r;\n-        };\n-    }\n-\n@@ -251,2 +218,2 @@\n-    public static final BiPredicate<String, String> PROXY_TUNNEL_RESTRICTED(HttpClient client, HttpRequestImpl req)  {\n-        return CONTEXT_RESTRICTED(client, req).and(HOST_RESTRICTED);\n+    public static final BiPredicate<String, String> PROXY_TUNNEL_RESTRICTED(HttpClient client)  {\n+        return HOST_RESTRICTED;\n@@ -335,0 +302,13 @@\n+    \/**\n+     * Check the user headers to see if the Authorization or ProxyAuthorization\n+     * were set. We need to set special flags in the request if so. Otherwise\n+     * we can't distinguish user set from Authenticator set headers\n+     *\/\n+    public static void setUserAuthFlags(HttpRequestImpl request, HttpHeaders userHeaders) {\n+        if (userHeaders.firstValue(\"Authorization\").isPresent()) {\n+            request.setUserSetAuthFlag(SERVER, true);\n+        }\n+        if (userHeaders.firstValue(\"Proxy-Authorization\").isPresent()) {\n+            request.setUserSetAuthFlag(PROXY, true);\n+        }\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":17,"deletions":37,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.net.httpserver.Headers;\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import java.io.*;\n-import java.net.Authenticator;\n-import java.net.InetSocketAddress;\n-import java.net.ProxySelector;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.nio.channels.*;\n-import java.nio.charset.StandardCharsets;\n-\n-import jdk.test.lib.net.IPSupport;\n-\n-\/**\n- * @test\n- * @bug 8263442\n- * @summary Potential bug in jdk.internal.net.http.common.Utils.CONTEXT_RESTRICTED\n- * @library \/test\/lib\n- * @run main\/othervm AuthFilter\n- *\/\n-\n-public class AuthFilter {\n-    static class Auth extends Authenticator {\n-    }\n-\n-    static HttpServer createServer() throws IOException {\n-        HttpServer server = HttpServer.create(new InetSocketAddress(0), 5);\n-        HttpHandler handler = (HttpExchange e) -> {\n-            InputStream is = e.getRequestBody();\n-            is.readAllBytes();\n-            is.close();\n-            Headers reqh = e.getRequestHeaders();\n-            if (reqh.containsKey(\"authorization\")) {\n-                e.sendResponseHeaders(500, -1);\n-            } else {\n-                e.sendResponseHeaders(200, -1);\n-            }\n-        };\n-        server.createContext(\"\/\", handler);\n-        return server;\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        test(false);\n-        test(true);\n-    }\n-\n-    \/**\n-     *  Fake proxy. Just looks for Proxy-Authorization header\n-     *  and returns error if seen. Returns 200 OK if not.\n-     *  Does not actually forward the request\n-     *\/\n-    static class ProxyServer extends Thread {\n-\n-        final ServerSocketChannel server;\n-        final int port;\n-        volatile SocketChannel c;\n-\n-        ProxyServer() throws IOException {\n-            server = ServerSocketChannel.open();\n-            server.bind(new InetSocketAddress(0));\n-            if (server.getLocalAddress() instanceof InetSocketAddress isa) {\n-                port = isa.getPort();\n-            } else {\n-                port = -1;\n-            }\n-        }\n-\n-        int getPort() {\n-            return port;\n-        }\n-\n-        static String ok = \"HTTP\/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-        static String notok1 = \"HTTP\/1.1 500 Internal Server Error\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-        static String notok2 = \"HTTP\/1.1 501 Not Implemented\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-\n-        static void reply(String msg, Writer writer) throws IOException {\n-            writer.write(msg);\n-            writer.flush();\n-        }\n-\n-        public void run() {\n-            try {\n-                c = server.accept();\n-                var cs = StandardCharsets.US_ASCII;\n-                LineNumberReader reader = new LineNumberReader(Channels.newReader(c, cs));\n-                Writer writer = Channels.newWriter(c, cs);\n-\n-                String line;\n-                while ((line=reader.readLine()) != null) {\n-                    if (line.indexOf(\"Proxy-Authorization\") != -1) {\n-                        reply(notok1, writer);\n-                        return;\n-                    }\n-                    if (line.equals(\"\")) {\n-                        \/\/ end of headers\n-                        reply(ok, writer);\n-                        return;\n-                    }\n-                }\n-                reply(notok2, writer);\n-            } catch (IOException e) {\n-            }\n-            try {\n-                server.close();\n-                c.close();\n-            } catch (IOException ee) {}\n-        }\n-    }\n-\n-    private static InetSocketAddress getLoopback(int port) throws IOException {\n-        if (IPSupport.hasIPv4()) {\n-            return new InetSocketAddress(\"127.0.0.1\", port);\n-        } else {\n-            return new InetSocketAddress(\"::1\", port);\n-        }\n-    }\n-\n-    public static void test(boolean useProxy) throws Exception {\n-        HttpServer server = createServer();\n-        int port = server.getAddress().getPort();\n-        ProxyServer proxy;\n-\n-        InetSocketAddress proxyAddr;\n-        String authHdr;\n-        if (useProxy) {\n-            proxy = new ProxyServer();\n-            proxyAddr = getLoopback(proxy.getPort());\n-            proxy.start();\n-            authHdr = \"Proxy-Authorization\";\n-        } else {\n-            authHdr = \"Authorization\";\n-            proxyAddr = null;\n-        }\n-\n-        server.start();\n-\n-        \/\/ proxyAddr == null => proxying disabled\n-        HttpClient client = HttpClient\n-                .newBuilder()\n-                .authenticator(new Auth())\n-                .proxy(ProxySelector.of(proxyAddr))\n-                .build();\n-\n-\n-        URI uri = new URI(\"http:\/\/127.0.0.1:\" + Integer.toString(port));\n-\n-        HttpRequest request = HttpRequest.newBuilder(uri)\n-                .header(authHdr, \"nonsense\")\n-                .GET()\n-                .build();\n-\n-        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n-        int r = response.statusCode();\n-        System.out.println(r);\n-        server.stop(0);\n-        if (r != 200)\n-            throw new RuntimeException(\"Test failed : \" + r);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilter.java","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -54,0 +54,1 @@\n+        \"Content-Length: 0\\r\\n\" +\n@@ -62,0 +63,10 @@\n+    static final String[] proxyWithErrorResponses = {\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+    };\n+\n@@ -71,0 +82,1 @@\n+        \"Content-Length: 0\\r\\n\" +\n@@ -82,0 +94,1 @@\n+        testServerWithProxyError();\n@@ -121,0 +134,29 @@\n+    static void testServerWithProxyError() throws IOException, InterruptedException {\n+        Mocker proxyMock = new Mocker(proxyWithErrorResponses);\n+        proxyMock.start();\n+        try {\n+\n+            var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .proxy(new ProxySel(proxyMock.getPort()))\n+                .authenticator(new ProxyAuth())\n+                .build();\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var badCreds = \"user:wrong\";\n+            var encoded1 = java.util.Base64.getEncoder().encodeToString(badCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(\"http:\/\/127.0.0.1\/some_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Proxy-Authorization\", \"Basic \" + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+            assertEquals(407, response.statusCode());\n+            System.out.println(\"testServerWithProxy: OK\");\n+        } finally {\n+            proxyMock.stopMocker();\n+        }\n+    }\n+\n@@ -240,1 +282,1 @@\n-                while (true) {\n+                while (index < responses.length) {\n@@ -245,1 +287,0 @@\n-                System.err.println(\"Delete this: \" + e);\n","filename":"test\/jdk\/java\/net\/httpclient\/UserAuthWithAuthenticator.java","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"}]}