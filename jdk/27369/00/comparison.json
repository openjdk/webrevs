{"files":[{"patch":"@@ -1678,1 +1678,1 @@\n-    {\n+    if (worker_id == 0) {\n@@ -1681,1 +1681,1 @@\n-      log_trace(gc, phases)(\"Fill dense prefix by worker %u: %.3f ms\", worker_id, (Ticks::now() - start).seconds() * 1000);\n+      log_trace(gc, phases)(\"Fill dense prefix by worker 0: %.3f ms\", (Ticks::now() - start).seconds() * 1000);\n@@ -1694,0 +1694,1 @@\n+      \/\/ The preceding live obj.\n@@ -1695,2 +1696,2 @@\n-      HeapWord* after_obj = obj_start + cast_to_oop(obj_start)->size();\n-      assert(after_obj == start, \"precondition\");\n+      HeapWord* obj_end = obj_start + cast_to_oop(obj_start)->size();\n+      assert(obj_end == start, \"precondition\");\n@@ -1716,12 +1717,1 @@\n-  if (bottom == prefix_end) {\n-    return;\n-  }\n-\n-  size_t bottom_region = _summary_data.addr_to_region_idx(bottom);\n-  size_t prefix_end_region = _summary_data.addr_to_region_idx(prefix_end);\n-\n-  size_t start_region;\n-  size_t end_region;\n-  split_regions_for_worker(bottom_region, prefix_end_region,\n-                           worker_id, num_workers,\n-                           &start_region, &end_region);\n+  const size_t region_size = ParallelCompactData::RegionSize;\n@@ -1729,3 +1719,3 @@\n-  if (start_region == end_region) {\n-    return;\n-  }\n+  \/\/ Fill dead space in [start_addr, end_addr)\n+  HeapWord* const start_addr = bottom;\n+  HeapWord* const end_addr   = prefix_end;\n@@ -1733,2 +1723,11 @@\n-  HeapWord* const start_addr = _summary_data.region_to_addr(start_region);\n-  HeapWord* const end_addr = _summary_data.region_to_addr(end_region);\n+  for (HeapWord* cur_addr = start_addr; cur_addr < end_addr; \/* empty *\/) {\n+    RegionData* cur_region_ptr = _summary_data.addr_to_region_ptr(cur_addr);\n+    if (cur_region_ptr->data_size() == region_size) {\n+      \/\/ Full; no dead space. Next region.\n+      if (_summary_data.is_region_aligned(cur_addr)) {\n+        cur_addr += region_size;\n+      } else {\n+        cur_addr = _summary_data.region_align_up(cur_addr);\n+      }\n+      continue;\n+    }\n@@ -1736,10 +1735,4 @@\n-  \/\/ Skip live partial obj (if any) from previous region.\n-  HeapWord* cur_addr;\n-  RegionData* start_region_ptr = _summary_data.region(start_region);\n-  if (start_region_ptr->partial_obj_size() != 0) {\n-    HeapWord* partial_obj_start = start_region_ptr->partial_obj_addr();\n-    assert(bitmap->is_marked(partial_obj_start), \"inv\");\n-    cur_addr = partial_obj_start + cast_to_oop(partial_obj_start)->size();\n-  } else {\n-    cur_addr = start_addr;\n-  }\n+    \/\/ Fill dead space inside cur_region.\n+    if (_summary_data.is_region_aligned(cur_addr)) {\n+      cur_addr += cur_region_ptr->partial_obj_size();\n+    }\n@@ -1747,7 +1740,7 @@\n-  \/\/ end_addr is inclusive to handle regions starting with dead space.\n-  while (cur_addr <= end_addr) {\n-    \/\/ Use prefix_end to handle trailing obj in each worker region-chunk.\n-    HeapWord* live_start = bitmap->find_obj_beg(cur_addr, prefix_end);\n-    if (cur_addr != live_start) {\n-      \/\/ Only worker 0 handles proceeding dead space.\n-      if (cur_addr != start_addr || worker_id == 0) {\n+    HeapWord* region_end_addr = _summary_data.region_align_up(cur_addr + 1);\n+    assert(region_end_addr <= end_addr, \"inv\");\n+    while (cur_addr < region_end_addr) {\n+      \/\/ Use end_addr to allow filler-obj to cross region boundary.\n+      HeapWord* live_start = bitmap->find_obj_beg(cur_addr, end_addr);\n+      if (cur_addr != live_start) {\n+        \/\/ Found dead space [cur_addr, live_start).\n@@ -1756,0 +1749,6 @@\n+      if (live_start >= region_end_addr) {\n+        cur_addr = live_start;\n+        break;\n+      }\n+      assert(bitmap->is_marked(live_start), \"inv\");\n+      cur_addr = live_start + cast_to_oop(live_start)->size();\n@@ -1757,5 +1756,0 @@\n-    if (live_start >= end_addr) {\n-      break;\n-    }\n-    assert(bitmap->is_marked(live_start), \"inv\");\n-    cur_addr = live_start + cast_to_oop(live_start)->size();\n@@ -1794,7 +1788,31 @@\n-  HeapWord* cur_addr = bottom;\n-  while (cur_addr < dense_prefix_end) {\n-    oop obj = cast_to_oop(cur_addr);\n-    oopDesc::verify(obj);\n-    if (!mark_bitmap()->is_marked(cur_addr)) {\n-      Klass* k = cast_to_oop(cur_addr)->klass();\n-      assert(k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass(), \"inv\");\n+\n+  const size_t region_size = ParallelCompactData::RegionSize;\n+\n+  for (HeapWord* cur_addr = bottom; cur_addr < dense_prefix_end; \/* empty *\/) {\n+    RegionData* cur_region_ptr = _summary_data.addr_to_region_ptr(cur_addr);\n+    if (cur_region_ptr->data_size() == region_size) {\n+      \/\/ Full; no dead space. Next region.\n+      if (_summary_data.is_region_aligned(cur_addr)) {\n+        cur_addr += region_size;\n+      } else {\n+        cur_addr = _summary_data.region_align_up(cur_addr);\n+      }\n+      continue;\n+    }\n+\n+    \/\/ This region contains filler objs.\n+    if (_summary_data.is_region_aligned(cur_addr)) {\n+      cur_addr += cur_region_ptr->partial_obj_size();\n+    }\n+\n+    HeapWord* region_end_addr = _summary_data.region_align_up(cur_addr + 1);\n+    assert(region_end_addr <= dense_prefix_end, \"inv\");\n+\n+    while (cur_addr < region_end_addr) {\n+      oop obj = cast_to_oop(cur_addr);\n+      oopDesc::verify(obj);\n+      if (!mark_bitmap()->is_marked(cur_addr)) {\n+        Klass* k = cast_to_oop(cur_addr)->klass();\n+        assert(k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass(), \"inv\");\n+      }\n+      cur_addr += obj->size();\n@@ -1802,1 +1820,0 @@\n-    cur_addr += obj->size();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":68,"deletions":51,"binary":false,"changes":119,"status":"modified"}]}