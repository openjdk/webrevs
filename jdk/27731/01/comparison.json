{"files":[{"patch":"@@ -430,0 +430,32 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciInstanceKlass::get_field_type_by_offset\n+\/\/\n+\/\/ This is essentially a shortcut for:\n+\/\/  get_field_type_by_offset(field_offset, is_static)->layout_type()\n+\/\/ except this does not require allocating memory for a new ciField\n+BasicType ciInstanceKlass::get_field_type_by_offset(int field_offset, bool is_static) {\n+  if (!is_static) {\n+    for (int i = 0, len = nof_nonstatic_fields(); i < len; i++) {\n+      ciField* field = _nonstatic_fields->at(i);\n+      int field_off = field->offset_in_bytes();\n+      if (field_off == field_offset)\n+        return field->layout_type();\n+    }\n+    return T_ILLEGAL;\n+  }\n+\n+  \/\/ Avoid allocating a new ciField by obtaining the field type directly\n+  VM_ENTRY_MARK;\n+  InstanceKlass* k = get_instanceKlass();\n+  fieldDescriptor fd;\n+  if (!k->find_field_from_offset(field_offset, is_static, &fd)) {\n+    return T_ILLEGAL;\n+  }\n+\n+  \/\/ Reproduce the behavior of ciField::layout_type\n+  BasicType field_type = fd.field_type();\n+  if (is_reference_type(field_type)) {\n+    return T_OBJECT;\n+  }\n+  return type2field[make(field_type)->basic_type()];\n+}\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -207,0 +207,1 @@\n+  BasicType get_field_type_by_offset(int field_offset, bool is_static);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3481,1 +3481,1 @@\n-          ciField* field = nullptr;\n+          BasicType basic_elem_type = T_ILLEGAL;\n@@ -3484,1 +3484,1 @@\n-            field = k->get_field_by_offset(_offset, true);\n+            basic_elem_type = k->get_field_type_by_offset(_offset, true);\n@@ -3486,2 +3486,1 @@\n-          if (field != nullptr) {\n-            BasicType basic_elem_type = field->layout_type();\n+          if (basic_elem_type != T_ILLEGAL) {\n@@ -3495,3 +3494,2 @@\n-          ciField* field = ik->get_field_by_offset(_offset, false);\n-          if (field != nullptr) {\n-            BasicType basic_elem_type = field->layout_type();\n+          BasicType basic_elem_type = ik->get_field_type_by_offset(_offset, false);;\n+          if (basic_elem_type != T_ILLEGAL) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+package compiler.loopopts;\n+\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8366990\n+ * @summary Loop optimizations verification results in hitting the memory limit.\n+ *          This is caused by the high number of verification passes triggered\n+ *          in PhaseIdealLoop::split_if_with_blocks_post and repetitive memory\n+ *          allocations while building the ideal Loop tree in preparation for\n+ *          the verification.\n+ *\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:CompileCommand=compileonly,compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit::test\n+ *      -XX:-TieredCompilation -Xcomp -XX:CompileCommand=dontinline,*::*\n+ *      -XX:+StressLoopPeeling -XX:PerMethodTrapLimit=0 -XX:+VerifyLoopOptimizations\n+ *      -XX:StressSeed=1870557292\n+ *      compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n+ * @run main compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n+ *\n+ *\/\n+\n+public class TestVerifyLoopOptimizationsHitsMemLimit {\n+    static final int a = 400;\n+    static long b;\n+    static int c;\n+    static float k;\n+    static double d;\n+    static long e;\n+    static byte f;\n+    static boolean l;\n+    static long g[];\n+    static volatile int h[];\n+\n+    static void j(int i) {\n+    }\n+\n+    static void test(String[] m) {\n+        int n, o = 2, p, q[] = new int[a];\n+        short r = 10492;\n+        boolean s[] = new boolean[a];\n+        j(0);\n+        for (n = 1; n < a; ++n) {\n+            p = 1;\n+            do {\n+                g[n] -= p;\n+                switch (n) {\n+                    case 133:\n+                    case 85:\n+                    case 93:\n+                        e = 1;\n+                    case 45:\n+                        q[1] = c;\n+                        break;\n+                    case 163:\n+                    case 62:\n+                    case 304:\n+                    case 72:\n+                    case 319:\n+                        h[1] -= o;\n+                    case 109:\n+                    case 47:\n+                    case 91:\n+                    case 68:\n+                    case 162:\n+                        k += b;\n+                    case 76:\n+                    case 60:\n+                    case 66:\n+                        s[1] = l;\n+                    case 83:\n+                    case 339:\n+                    case 365:\n+                        d = r;\n+                    case 219:\n+                    case 42:\n+                    case 314:\n+                        k = 2;\n+                    case 215:\n+                        f = (byte) k;\n+                        break;\n+                    case 212:\n+                    case 53:\n+                    case 74:\n+                        d -= o;\n+                    case 89:\n+                    case 210:\n+                    case 208:\n+                    case 128:\n+                    case 52:\n+                    case 56:\n+                    case 144:\n+                        h[1] |= e;\n+                }\n+            } while (++p < 24);\n+        }\n+    }\n+\n+    public static void main(String[] t) {\n+        try {\n+            test(t);\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestVerifyLoopOptimizationsHitsMemLimit.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}