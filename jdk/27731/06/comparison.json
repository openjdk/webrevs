{"files":[{"patch":"@@ -394,0 +394,12 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciInstanceKlass::get_non_static_field_by_offset\n+ciField* ciInstanceKlass::get_non_static_field_by_offset(const int field_offset) {\n+  for (int i = 0, len = nof_nonstatic_fields(); i < len; i++) {\n+    ciField* field = _nonstatic_fields->at(i);\n+    int  field_off = field->offset_in_bytes();\n+    if (field_off == field_offset)\n+      return field;\n+  }\n+  return nullptr;\n+}\n+\n@@ -398,7 +410,1 @@\n-    for (int i = 0, len = nof_nonstatic_fields(); i < len; i++) {\n-      ciField* field = _nonstatic_fields->at(i);\n-      int  field_off = field->offset_in_bytes();\n-      if (field_off == field_offset)\n-        return field;\n-    }\n-    return nullptr;\n+    return get_non_static_field_by_offset(field_offset);\n@@ -430,0 +436,27 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciInstanceKlass::get_field_type_by_offset\n+\/\/\n+\/\/ This is essentially a shortcut for:\n+\/\/  get_field_by_offset(field_offset, is_static)->layout_type()\n+\/\/ except this does not require allocating memory for a new ciField\n+BasicType ciInstanceKlass::get_field_type_by_offset(const int field_offset, const bool is_static) {\n+  if (!is_static) {\n+    ciField* field = get_non_static_field_by_offset(field_offset);\n+    return field != nullptr ? field->layout_type() : T_ILLEGAL;\n+  }\n+\n+  \/\/ Avoid allocating a new ciField by obtaining the field type directly\n+  VM_ENTRY_MARK;\n+  InstanceKlass* k = get_instanceKlass();\n+  fieldDescriptor fd;\n+  if (!k->find_field_from_offset(field_offset, is_static, &fd)) {\n+    return T_ILLEGAL;\n+  }\n+\n+  \/\/ Reproduce the behavior of ciField::layout_type\n+  BasicType field_type = fd.field_type();\n+  if (is_reference_type(field_type)) {\n+    return T_OBJECT;\n+  }\n+  return type2field[make(field_type)->basic_type()];\n+}\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":40,"deletions":7,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+  ciField* get_non_static_field_by_offset(int field_offset);\n+\n@@ -207,0 +209,1 @@\n+  BasicType get_field_type_by_offset(int field_offset, bool is_static);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3481,1 +3481,1 @@\n-          ciField* field = nullptr;\n+          BasicType basic_elem_type = T_ILLEGAL;\n@@ -3484,1 +3484,1 @@\n-            field = k->get_field_by_offset(_offset, true);\n+            basic_elem_type = k->get_field_type_by_offset(_offset, true);\n@@ -3486,2 +3486,1 @@\n-          if (field != nullptr) {\n-            BasicType basic_elem_type = field->layout_type();\n+          if (basic_elem_type != T_ILLEGAL) {\n@@ -3495,3 +3494,2 @@\n-          ciField* field = ik->get_field_by_offset(_offset, false);\n-          if (field != nullptr) {\n-            BasicType basic_elem_type = field->layout_type();\n+          BasicType basic_elem_type = ik->get_field_type_by_offset(_offset, false);\n+          if (basic_elem_type != T_ILLEGAL) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts;\n+\n+\/**\n+ * @test\n+ * @bug 8366990\n+ * @summary Loop optimizations verification results in hitting the memory limit.\n+ *          This is caused by the high number of verification passes triggered\n+ *          in PhaseIdealLoop::split_if_with_blocks_post and repetitive memory\n+ *          allocations while building the ideal Loop tree in preparation for\n+ *          the verification.\n+ *\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:CompileCommand=compileonly,compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit::test\n+ *      -XX:CompileCommand=memlimit,compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit::test,100M~crash\n+ *      -XX:-TieredCompilation -Xcomp -XX:CompileCommand=dontinline,*::*\n+ *      -XX:+StressLoopPeeling -XX:PerMethodTrapLimit=0 -XX:+VerifyLoopOptimizations\n+ *      -XX:StressSeed=1870557292\n+ *      compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n+ * @run main compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n+ *\n+ *\/\n+\n+public class TestVerifyLoopOptimizationsHitsMemLimit {\n+    final int a = 400;\n+    int b;\n+    float c;\n+    static double d;\n+    static byte f;\n+    long g[];\n+    volatile int h[];\n+\n+    void test() {\n+        int j, k = 2, l, o[] = new int[a];\n+        short m = 10492;\n+        for (j = 1;; ++j) {\n+            l = 1;\n+            do {\n+                g[j] = l;\n+                switch (j) {\n+                    case 45:\n+                        o[1] = b;\n+                    case 163:\n+                    case 62:\n+                    case 72:\n+                    case 319:\n+                        h[1] -= k;\n+                    case 109:\n+                    case 47:\n+                    case 91:\n+                    case 68:\n+                    case 162:\n+                    case 76:\n+                    case 60:\n+                    case 66:\n+                    case 83:\n+                        d = m;\n+                    case 2314:\n+                        f = (byte) c;\n+                }\n+            } while (++l < 4);\n+        }\n+    }\n+\n+    public static void main(String[] n) {\n+        try {\n+            TestVerifyLoopOptimizationsHitsMemLimit test = new TestVerifyLoopOptimizationsHitsMemLimit();\n+            test.test();\n+            throw new RuntimeException(\"Expected a NPE for uninitialized array\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestVerifyLoopOptimizationsHitsMemLimit.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}