{"files":[{"patch":"@@ -5254,1 +5254,12 @@\n-            Env<AttrContext> errEnv = env.dup(env.tree, env.info.dup());\n+            WriteableScope newScope = env.info.scope;\n+\n+            if (env.tree instanceof JCClassDecl) {\n+                Symbol fakeOwner =\n+                    new MethodSymbol(BLOCK, names.empty, null,\n+                        env.info.scope.owner);\n+                newScope = newScope.dupUnshared(fakeOwner);\n+            }\n+\n+            Env<AttrContext> errEnv =\n+                    env.dup(env.tree,\n+                            env.info.dup(newScope));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-    protected JCErroneous syntaxError(int pos, List<JCTree> errs, Error errorKey) {\n+    protected JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey) {\n@@ -4736,0 +4736,6 @@\n+            } else if (isDefiniteStatementStartToken()) {\n+                int startPos = token.pos;\n+                List<JCStatement> statements = blockStatement();\n+                return List.of(syntaxError(startPos,\n+                                           statements,\n+                                           Errors.StatementNotExpected));\n@@ -4913,1 +4919,13 @@\n-        }\n+    }\n+\n+    \/**\n+     * {@return true if and only if the current token is definitelly a token that\n+     *  starts a statement.}\n+     *\/\n+    private boolean isDefiniteStatementStartToken() {\n+        return switch (token.kind) {\n+            case IF, WHILE, DO, SWITCH, RETURN, TRY, FOR, ASSERT, BREAK,\n+                 CONTINUE, THROW -> true;\n+            default -> false;\n+        };\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    protected JCErroneous syntaxError(int pos, List<JCTree> errs, Error errorKey) {\n+    protected JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1619,0 +1619,3 @@\n+compiler.err.statement.not.expected=\\\n+    statements not expected outside of methods and initializers\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,2 +24,1 @@\n-module org.myapp {\n-    requires org.lib;\n+\/\/ key: compiler.err.statement.not.expected\n@@ -27,1 +26,2 @@\n-    uses org.lib.Service;\n+class StatementNotExpected {\n+    return null;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StatementNotExpected.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.myapp\/module-info.java","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976\n@@ -2412,0 +2412,74 @@\n+    @Test \/\/JDK-8337976\n+    void testStatementsInClass() throws IOException {\n+        String code = \"\"\"\n+                      package test;\n+                      public class Test {\n+                          if (true);\n+                          while (true);\n+                          do {} while (true);\n+                          for ( ; ; );\n+                          switch (0) { default: }\n+                          assert true;\n+                          break;\n+                          continue;\n+                          return ;\n+                          throw new RuntimeException();\n+                          try {\n+                          } catch (RuntimeException ex) {}\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package test;\n+                     \\n\\\n+                     public class Test {\n+                         (ERROR: if (true) ;)\n+                         (ERROR: while (true) ;)\n+                         (ERROR: do {\n+                     } while (true);)\n+                         (ERROR: for (; ; ) ;)\n+                         (ERROR: switch (0) {\n+                     default:\n+\n+                     })\n+                         (ERROR: assert true;)\n+                         (ERROR: break;)\n+                         (ERROR: continue;)\n+                         (ERROR: return;)\n+                         (ERROR: throw new RuntimeException();)\n+                         (ERROR: try {\n+                     } catch (RuntimeException ex) {\n+                     })\n+                     }\"\"\");\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testStatementsInClass: \" + codes,\n+                     List.of(\"3:5:compiler.err.statement.not.expected\",\n+                             \"4:5:compiler.err.statement.not.expected\",\n+                             \"5:5:compiler.err.statement.not.expected\",\n+                             \"6:5:compiler.err.statement.not.expected\",\n+                             \"7:5:compiler.err.statement.not.expected\",\n+                             \"8:5:compiler.err.statement.not.expected\",\n+                             \"9:5:compiler.err.statement.not.expected\",\n+                             \"10:5:compiler.err.statement.not.expected\",\n+                             \"11:5:compiler.err.statement.not.expected\",\n+                             \"12:5:compiler.err.statement.not.expected\",\n+                             \"13:5:compiler.err.statement.not.expected\"),\n+                     codes);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -1361,1 +1361,1 @@\n-            assertFail(\"compiler.err.illegal.start.of.type\",\n+            assertFail(\"compiler.err.statement.not.expected\",\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8337976\n+ * @summary Verify javac does not crash and produces nice errors for certain erroneous code.\n+ * @compile\/fail\/ref=T8337976.out -XDrawDiagnostics -XDshould-stop.at=FLOW -XDdev T8337976.java\n+ *\/\n+public class T8337976 {\n+    switch (0) { default: undefined u;}\n+    if (true) { undefined u; }\n+}\n","filename":"test\/langtools\/tools\/javac\/recovery\/T8337976.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+T8337976.java:8:5: compiler.err.statement.not.expected\n+T8337976.java:9:5: compiler.err.statement.not.expected\n+T8337976.java:8:27: compiler.err.cant.resolve.location: kindname.class, undefined, , , (compiler.misc.location: kindname.class, T8337976, null)\n+T8337976.java:9:17: compiler.err.cant.resolve.location: kindname.class, undefined, , , (compiler.misc.location: kindname.class, T8337976, null)\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/recovery\/T8337976.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"}]}