{"files":[{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotClassInitializer.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+\n+bool AOTClassInitializer::can_archive_initialized_mirror(InstanceKlass* ik) {\n+  assert(!ArchiveBuilder::current()->is_in_buffer_space(ik), \"must be source klass\");\n+  if (!CDSConfig::is_initing_classes_at_dump_time()) {\n+    return false;\n+  }\n+\n+  if (ik->is_initialized() && ik->java_super() == vmClasses::Enum_klass()) {\n+    return true;\n+  } else if (ik->name()->equals(\"jdk\/internal\/constant\/PrimitiveClassDescImpl\") ||\n+             ik->name()->equals(\"jdk\/internal\/constant\/ReferenceClassDescImpl\") ||\n+             ik->name()->equals(\"java\/lang\/constant\/ConstantDescs\")) {\n+    assert(ik->is_initialized(), \"must be\");\n+    \/\/ The above 3 classes are special cases needed to support the aot-caching of\n+    \/\/ java.lang.invoke.MethodType instances:\n+    \/\/ - MethodType points to sun.invoke.util.Wrapper enums\n+    \/\/ - The Wrapper enums point to static final fields in the above 3 classes.\n+    \/\/   E.g., ConstantDescs.CD_Boolean.\n+    \/\/ - If we re-run the <clinit> of these 3 classes again during the production\n+    \/\/   run, ConstantDescs.CD_Boolean will get a new value that has a different\n+    \/\/   object identity than the value referenced by the the Wrapper enums.\n+    \/\/ - However, Wrapper requires object identity (it allows the use of == to\n+    \/\/   test the equality of ClassDesc, etc).\n+    \/\/ Therefore, we must preserve the static fields of these 3 classes from\n+    \/\/ the assembly phase.\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCLASSINITIALIZER_HPP\n+#define SHARE_CDS_AOTCLASSINITIALIZER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+class InstanceKlass;\n+\n+class AOTClassInitializer : AllStatic {\n+public:\n+  \/\/ Called by heapShared.cpp to see if src_ik->java_mirror() can be archived in\n+  \/\/ the initialized state.\n+  static bool can_archive_initialized_mirror(InstanceKlass* src_ik);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTCLASSINITIALIZER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -94,0 +95,24 @@\n+  \/\/ Initialize the InstanceKlasses of all archived heap objects that are reachable from the\n+  \/\/ archived java class mirrors.\n+  \/\/\n+  \/\/ Only the classes in the static archive can have archived mirrors.\n+  AOTLinkedClassTable* static_table = AOTLinkedClassTable::for_static_archive();\n+  switch (class_category) {\n+  case AOTLinkedClassCategory::BOOT1:\n+    \/\/ Delayed until finish_loading_javabase_classes(), as the VM is not ready to\n+    \/\/ execute some of the <clinit> methods.\n+    break;\n+  case AOTLinkedClassCategory::BOOT2:\n+    init_required_classes_for_loader(h_loader, static_table->boot2(), CHECK);\n+    break;\n+  case AOTLinkedClassCategory::PLATFORM:\n+    init_required_classes_for_loader(h_loader, static_table->platform(), CHECK);\n+    break;\n+  case AOTLinkedClassCategory::APP:\n+    init_required_classes_for_loader(h_loader, static_table->app(), CHECK);\n+    break;\n+  case AOTLinkedClassCategory::UNREGISTERED:\n+    ShouldNotReachHere();\n+    break;\n+  }\n+\n@@ -215,0 +240,26 @@\n+\n+void AOTLinkedClassBulkLoader::finish_loading_javabase_classes(TRAPS) {\n+  init_required_classes_for_loader(Handle(), AOTLinkedClassTable::for_static_archive()->boot(), CHECK);\n+}\n+\n+\/\/ Some AOT-linked classes for <class_loader> must be initialized early. This includes\n+\/\/ - classes that were AOT-initialized by AOTClassInitializer\n+\/\/ - the classes of all objects that are reachable from the archived mirrors of\n+\/\/   the AOT-linked classes for <class_loader>.\n+void AOTLinkedClassBulkLoader::init_required_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n+  if (classes != nullptr) {\n+    for (int i = 0; i < classes->length(); i++) {\n+      InstanceKlass* ik = classes->at(i);\n+      if (ik->class_loader_data() == nullptr) {\n+        \/\/ This class is not yet loaded. We will initialize it in a later phase.\n+        \/\/ For example, we have loaded only BOOT classes but k is part of BOOT2.\n+        continue;\n+      }\n+      if (ik->has_aot_initialized_mirror()) {\n+        ik->initialize_from_cds(CHECK);\n+      }\n+    }\n+  }\n+\n+  HeapShared::init_classes_reachable_from_archived_mirrors(class_loader, CHECK);\n+}\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  static void init_required_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n@@ -58,0 +59,1 @@\n+  static void finish_loading_javabase_classes(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -766,1 +766,2 @@\n-  x ## _a += aotlinked ? 1 : 0;\n+  x ## _a += aotlinked ? 1 : 0; \\\n+  x ## _i += inited ? 1 : 0;\n@@ -770,1 +771,2 @@\n-  int x ## _a = 0;\n+  int x ## _a = 0; \\\n+  int x ## _i = 0;\n@@ -779,1 +781,1 @@\n-\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_enum_klasses);\n@@ -803,0 +805,1 @@\n+    const char* kind = \"\";\n@@ -806,0 +809,1 @@\n+    const char* inited_msg = \"\";\n@@ -822,0 +826,1 @@\n+      bool inited = ik->has_aot_initialized_mirror();\n@@ -875,0 +880,7 @@\n+      if (ik->is_interface()) {\n+        kind = \" interface\";\n+      } else if (src_ik->java_super() == vmClasses::Enum_klass()) {\n+        kind = \" enum\";\n+        ADD_COUNT(num_enum_klasses);\n+      }\n+\n@@ -886,0 +898,3 @@\n+      if (inited) {\n+        inited_msg = \" inited\";\n+      }\n@@ -893,1 +908,1 @@\n-      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s\", i,\n+      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s%s%s\", i,\n@@ -895,1 +910,1 @@\n-                            hidden, unlinked, generated, aotlinked_msg);\n+                            kind, hidden, unlinked, generated, aotlinked_msg, inited_msg);\n@@ -899,2 +914,2 @@\n-#define STATS_FORMAT    \"= %5d, aot-linked = %5d\"\n-#define STATS_PARAMS(x) num_ ## x, num_ ## x ## _a\n+#define STATS_FORMAT    \"= %5d, aot-linked = %5d, inited = %5d\"\n+#define STATS_PARAMS(x) num_ ## x, num_ ## x ## _a, num_ ## x ## _i\n@@ -909,0 +924,1 @@\n+  log_info(cds)(\"      (enum)           \" STATS_FORMAT, STATS_PARAMS(enum_klasses));\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -503,1 +504,8 @@\n-  if (!CompressedOops::is_null(source_referent)) {\n+  if (source_referent != nullptr) {\n+    if (java_lang_Class::is_instance(source_referent)) {\n+      \/\/ When the source object points to a \"real\" mirror, the buffered object should point\n+      \/\/ to the \"scratch\" mirror, which has all unarchivable fields scrubbed (to be reinstated\n+      \/\/ at run time).\n+      source_referent = HeapShared::scratch_java_mirror(source_referent);\n+      assert(source_referent != nullptr, \"must be\");\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -496,0 +496,4 @@\n+bool CDSConfig::is_loading_heap() {\n+  return ArchiveHeapLoader::is_in_use();\n+}\n+\n@@ -554,0 +558,4 @@\n+\n+bool CDSConfig::is_initing_classes_at_dump_time() {\n+  return is_dumping_heap() && is_dumping_aot_linked_classes();\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -111,0 +111,2 @@\n+  static bool is_loading_heap()                              NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_initing_classes_at_dump_time()              NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -141,1 +142,1 @@\n-  InstanceKlass* _ik;\n+  InstanceKlass* _ik; \/\/ The class whose static fields are being checked.\n@@ -156,1 +157,1 @@\n-      Klass* klass = static_obj_field->klass();\n+      Klass* klass_of_field = static_obj_field->klass();\n@@ -176,3 +177,3 @@\n-      if (klass->has_archived_enum_objs()) {\n-        \/\/ This klass is a subclass of java.lang.Enum. If any instance of this klass\n-        \/\/ has been archived, we will archive all static fields of this klass.\n+      if (klass_of_field->has_archived_enum_objs()) {\n+        \/\/ This field is an Enum. If any instance of this Enum has been archived, we will archive\n+        \/\/ all static fields of this Enum as well.\n@@ -182,0 +183,10 @@\n+      if (klass_of_field->is_instance_klass()) {\n+        if (InstanceKlass::cast(klass_of_field)->is_initialized() &&\n+            AOTClassInitializer::can_archive_initialized_mirror(InstanceKlass::cast(klass_of_field))) {\n+          return;\n+        }\n+      }\n+\n+      if (AOTClassInitializer::can_archive_initialized_mirror(_ik)) {\n+        return;\n+      }\n@@ -283,0 +294,3 @@\n+  if (java_lang_Class::is_instance(orig_obj)) {\n+    st->print(\" (%s)\", java_lang_Class::as_Klass(orig_obj)->external_name());\n+  }\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -98,1 +99,1 @@\n-static const Klass* _test_class = nullptr;\n+static Klass* _test_class = nullptr;\n@@ -135,0 +136,1 @@\n+ArchivedKlassSubGraphInfoRecord* HeapShared::_runtime_default_subgraph_info;\n@@ -278,0 +280,1 @@\n+    debug_trace();\n@@ -289,2 +292,13 @@\n-      log_debug(cds, heap)(\"Archived heap object \" PTR_FORMAT \" : %s\",\n-                           p2i(obj), obj->klass()->external_name());\n+      LogTarget(Debug, cds, heap) log;\n+      LogStream out(log);\n+      out.print(\"Archived heap object \" PTR_FORMAT \" : %s \",\n+                p2i(obj), obj->klass()->external_name());\n+      if (java_lang_Class::is_instance(obj)) {\n+        Klass* k = java_lang_Class::as_Klass(obj);\n+        if (k != nullptr) {\n+          out.print(\"%s\", k->external_name());\n+        } else {\n+          out.print(\"primitive\");\n+        }\n+      }\n+      out.cr();\n@@ -351,0 +365,25 @@\n+\/\/ Given java_mirror that represents a (primitive or reference) type T,\n+\/\/ return the \"scratch\" version that represents the same type T.\n+\/\/ Note that if java_mirror will be returned if it's already a\n+\/\/ scratch mirror.\n+\/\/\n+\/\/ See java_lang_Class::create_scratch_mirror() for more info.\n+oop HeapShared::scratch_java_mirror(oop java_mirror) {\n+  assert(java_lang_Class::is_instance(java_mirror), \"must be\");\n+\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (!is_reference_type(bt)) {\n+      if (_scratch_basic_type_mirrors[i].resolve() == java_mirror) {\n+        return java_mirror;\n+      }\n+    }\n+  }\n+\n+  if (java_lang_Class::is_primitive(java_mirror)) {\n+    return scratch_java_mirror(java_lang_Class::as_BasicType(java_mirror));\n+  } else {\n+    return scratch_java_mirror(java_lang_Class::as_Klass(java_mirror));\n+  }\n+}\n+\n@@ -372,0 +411,73 @@\n+void HeapShared::copy_aot_initialized_mirror(Klass* orig_k, oop orig_mirror, oop m) {\n+  if (!orig_k->is_instance_klass()) {\n+    return;\n+  }\n+  InstanceKlass* ik = InstanceKlass::cast(orig_k);\n+  if (!ik->is_initialized() || !AOTClassInitializer::can_archive_initialized_mirror(ik)) {\n+    return;\n+  }\n+\n+  int nfields = 0;\n+  for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      int offset = fd.offset();\n+      switch (fd.field_type()) {\n+      case T_OBJECT:\n+      case T_ARRAY:\n+        m->obj_field_put(offset, orig_mirror->obj_field(offset));\n+        break;\n+      case T_BOOLEAN:\n+        m->bool_field_put(offset, orig_mirror->bool_field(offset));\n+        break;\n+      case T_BYTE:\n+        m->byte_field_put(offset, orig_mirror->byte_field(offset));\n+        break;\n+      case T_SHORT:\n+        m->short_field_put(offset, orig_mirror->short_field(offset));\n+        break;\n+      case T_CHAR:\n+        m->char_field_put(offset, orig_mirror->char_field(offset));\n+        break;\n+      case T_INT:\n+        m->int_field_put(offset, orig_mirror->int_field(offset));\n+        break;\n+      case T_LONG:\n+        m->long_field_put(offset, orig_mirror->long_field(offset));\n+        break;\n+      case T_FLOAT:\n+        m->float_field_put(offset, orig_mirror->float_field(offset));\n+        break;\n+      case T_DOUBLE:\n+        m->double_field_put(offset, orig_mirror->double_field(offset));\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      }\n+      nfields ++;\n+    }\n+  }\n+\n+  \/\/ Class::reflectData use SoftReference, which cannot be archived. Set it\n+  \/\/ to null and it will be recreated at runtime.\n+  java_lang_Class::set_reflection_data(m, nullptr);\n+\n+  if (log_is_enabled(Info, cds, init)) {\n+    ResourceMark rm;\n+    log_debug(cds, init)(\"copied %3d field(s) in aot-initialized mirror %s%s\", nfields, ik->external_name(),\n+                         ik->is_hidden() ? \" (hidden)\" : \"\");\n+  }\n+\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n+  buffered_ik->set_has_aot_initialized_mirror();\n+}\n+\n+static void copy_java_mirror_hashcode(oop orig_mirror, oop scratch_m) {\n+  int src_hash = orig_mirror->identity_hash();\n+  scratch_m->set_mark(markWord::prototype().copy_set_hash(src_hash));\n+  assert(scratch_m->mark().is_unlocked(), \"sanity\");\n+\n+  DEBUG_ONLY(int archived_hash = scratch_m->identity_hash());\n+  assert(src_hash == archived_hash, \"Java mirror wrong hash: original %x, scratch %x\", src_hash, archived_hash);\n+}\n+\n@@ -376,0 +488,1 @@\n+      oop orig_mirror = Universe::java_mirror(bt);\n@@ -378,0 +491,1 @@\n+      copy_java_mirror_hashcode(orig_mirror, m);\n@@ -391,0 +505,1 @@\n+\n@@ -393,0 +508,11 @@\n+    oop orig_mirror = orig_k->java_mirror();\n+    oop m = scratch_java_mirror(orig_k);\n+    if (m != nullptr) {\n+      copy_java_mirror_hashcode(orig_mirror, m);\n+      copy_aot_initialized_mirror(orig_k, orig_mirror, m);\n+    }\n+  }\n+\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* orig_k = klasses->at(i);\n+    oop orig_mirror = orig_k->java_mirror();\n@@ -716,1 +842,1 @@\n-struct CopyKlassSubGraphInfoToArchive : StackObj {\n+class HeapShared::CopyKlassSubGraphInfoToArchive : StackObj {\n@@ -718,0 +844,1 @@\n+public:\n@@ -722,4 +849,1 @@\n-      ArchivedKlassSubGraphInfoRecord* record =\n-        (ArchivedKlassSubGraphInfoRecord*)ArchiveBuilder::ro_region_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));\n-      record->init(&info);\n-\n+      ArchivedKlassSubGraphInfoRecord* record = HeapShared::archive_subgraph_info(&info);\n@@ -735,0 +859,10 @@\n+ArchivedKlassSubGraphInfoRecord* HeapShared::archive_subgraph_info(KlassSubGraphInfo* info) {\n+  ArchivedKlassSubGraphInfoRecord* record =\n+      (ArchivedKlassSubGraphInfoRecord*)ArchiveBuilder::ro_region_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));\n+  record->init(info);\n+  if (info ==  _default_subgraph_info) {\n+    _runtime_default_subgraph_info = record;\n+  }\n+  return record;\n+}\n+\n@@ -785,0 +919,1 @@\n+  soc->do_ptr(&_runtime_default_subgraph_info);\n@@ -839,0 +974,46 @@\n+\/\/ The main purpose of this call is to initialize any classes that are reachable\n+\/\/ from the archived Java mirrors that belong to the <class_loader>.\n+\/\/\n+\/\/ For example, if this enum class is initialized at AOT cache assembly time:\n+\/\/\n+\/\/    enum Fruit {\n+\/\/       APPLE, ORANGE, BANANA;\n+\/\/       static final Set<Fruit> HAVE_SEEDS = new HashSet<>(Arrays.asList(APPLE, ORANGE));\n+\/\/   }\n+\/\/\n+\/\/ the pre-inited mirror of Fruit references HashSet, which should be initialized\n+\/\/ before any Java code can access the Fruit class. Note that HashSet itself doesn't\n+\/\/ necessary need to be an aot-initialized class.\n+\/\/\n+\/\/ The set of classes that are required to be initialized for the archived\n+\/\/ java mirrors are recorded in _runtime_default_subgraph_info (which probably\n+\/\/ needs a better name).\n+void HeapShared::init_classes_reachable_from_archived_mirrors(Handle class_loader, TRAPS) {\n+  if (!ArchiveHeapLoader::is_in_use()) {\n+    return;\n+  }\n+\n+  assert( _runtime_default_subgraph_info != nullptr, \"must be\");\n+  Array<Klass*>* klasses = _runtime_default_subgraph_info->subgraph_object_klasses();\n+  if (klasses != nullptr) {\n+    for (int pass = 0; pass < 2; pass ++) {\n+      for (int i = 0; i < klasses->length(); i++) {\n+        Klass* k = klasses->at(i);\n+        if (k->class_loader_data() == nullptr) {\n+          \/\/ This class is not yet loaded. We will initialize it in a later phase.\n+          continue;\n+        }\n+        if (k->class_loader() == class_loader()) {\n+          if (pass == 0) {\n+            if (k->is_instance_klass()) {\n+              InstanceKlass::cast(k)->link_class(CHECK);\n+            }\n+          } else {\n+            resolve_or_init(k, \/*do_init*\/true, CHECK);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -1091,0 +1272,14 @@\n+void HeapShared::init_box_classes(TRAPS) {\n+  if (ArchiveHeapLoader::is_in_use()) {\n+    vmClasses::Boolean_klass()->initialize(CHECK);\n+    vmClasses::Character_klass()->initialize(CHECK);\n+    vmClasses::Float_klass()->initialize(CHECK);\n+    vmClasses::Double_klass()->initialize(CHECK);\n+    vmClasses::Byte_klass()->initialize(CHECK);\n+    vmClasses::Short_klass()->initialize(CHECK);\n+    vmClasses::Integer_klass()->initialize(CHECK);\n+    vmClasses::Long_klass()->initialize(CHECK);\n+    vmClasses::Void_klass()->initialize(CHECK);\n+  }\n+}\n+\n@@ -1105,1 +1300,2 @@\n-    log_error(cds, heap)(\"Cannot archive object of class %s\", orig_obj->klass()->external_name());\n+    log_error(cds, heap)(\"Cannot archive object \" PTR_FORMAT \" of class %s\", p2i(orig_obj), orig_obj->klass()->external_name());\n+    debug_trace();\n@@ -1109,8 +1305,45 @@\n-  \/\/ java.lang.Class instances cannot be included in an archived object sub-graph. We only support\n-  \/\/ them as Klass::_archived_mirror because they need to be specially restored at run time.\n-  \/\/\n-  \/\/ If you get an error here, you probably made a change in the JDK library that has added a Class\n-  \/\/ object that is referenced (directly or indirectly) by static fields.\n-  if (java_lang_Class::is_instance(orig_obj) && subgraph_info != _default_subgraph_info) {\n-    log_error(cds, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n-    MetaspaceShared::unrecoverable_writing_error();\n+  if (log_is_enabled(Debug, cds, heap) && java_lang_Class::is_instance(orig_obj)) {\n+    ResourceMark rm;\n+    LogTarget(Debug, cds, heap) log;\n+    LogStream out(log);\n+    out.print(\"Found java mirror \" PTR_FORMAT \" \", p2i(orig_obj));\n+    Klass* k = java_lang_Class::as_Klass(orig_obj);\n+    if (k != nullptr) {\n+      out.print(\"%s\", k->external_name());\n+    } else {\n+      out.print(\"primitive\");\n+    }\n+    out.print_cr(\"; scratch mirror = \"  PTR_FORMAT,\n+                 p2i(scratch_java_mirror(orig_obj)));\n+  }\n+\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    if (java_lang_Class::is_instance(orig_obj)) {\n+      orig_obj = scratch_java_mirror(orig_obj);\n+      assert(orig_obj != nullptr, \"must be archived\");\n+    }\n+  } else if (java_lang_Class::is_instance(orig_obj) && subgraph_info != _default_subgraph_info) {\n+    \/\/ Without CDSConfig::is_initing_classes_at_dump_time(), we only allow archived objects to\n+    \/\/ point to the mirrors of (1) j.l.Object, (2) primitive classes, and (3) box classes. These are initialized\n+    \/\/ very early by HeapShared::init_box_classes().\n+    if (orig_obj == vmClasses::Object_klass()->java_mirror()\n+        || java_lang_Class::is_primitive(orig_obj)\n+        || orig_obj == vmClasses::Boolean_klass()->java_mirror()\n+        || orig_obj == vmClasses::Character_klass()->java_mirror()\n+        || orig_obj == vmClasses::Float_klass()->java_mirror()\n+        || orig_obj == vmClasses::Double_klass()->java_mirror()\n+        || orig_obj == vmClasses::Byte_klass()->java_mirror()\n+        || orig_obj == vmClasses::Short_klass()->java_mirror()\n+        || orig_obj == vmClasses::Integer_klass()->java_mirror()\n+        || orig_obj == vmClasses::Long_klass()->java_mirror()\n+        || orig_obj == vmClasses::Void_klass()->java_mirror()) {\n+      orig_obj = scratch_java_mirror(orig_obj);\n+      assert(orig_obj != nullptr, \"must be archived\");\n+    } else {\n+      \/\/ If you get an error here, you probably made a change in the JDK library that has added a Class\n+      \/\/ object that is referenced (directly or indirectly) by an ArchivableStaticFieldInfo\n+      \/\/ defined at the top of this file.\n+      log_error(cds, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n+      debug_trace();\n+      MetaspaceShared::unrecoverable_writing_error();\n+    }\n@@ -1156,2 +1389,7 @@\n-  if (CDSEnumKlass::is_enum_obj(orig_obj)) {\n-    CDSEnumKlass::handle_enum_obj(level + 1, subgraph_info, orig_obj);\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    \/\/ The enum klasses are archived with aot-initialized mirror.\n+    \/\/ See AOTClassInitializer::can_archive_initialized_mirror().\n+  } else {\n+    if (CDSEnumKlass::is_enum_obj(orig_obj)) {\n+      CDSEnumKlass::handle_enum_obj(level + 1, subgraph_info, orig_obj);\n+    }\n@@ -1159,0 +1397,1 @@\n+\n@@ -1276,0 +1515,4 @@\n+  if (java_lang_Class::is_instance(obj)) {\n+    obj = scratch_java_mirror(obj);\n+    assert(obj != nullptr, \"must be\");\n+  }\n@@ -1290,0 +1533,4 @@\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    return;\n+  }\n+\n@@ -1294,1 +1541,10 @@\n-    if (log_is_enabled(Info, cds, heap)) {\n+    Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n+    if (subgraph_k->is_instance_klass() &&\n+        name != vmSymbols::java_lang_Class() &&\n+        name != vmSymbols::java_lang_String() &&\n+        name != vmSymbols::java_lang_ArithmeticException() &&\n+        name != vmSymbols::java_lang_ArrayIndexOutOfBoundsException() &&\n+        name != vmSymbols::java_lang_ArrayStoreException() &&\n+        name != vmSymbols::java_lang_ClassCastException() &&\n+        name != vmSymbols::java_lang_InternalError() &&\n+        name != vmSymbols::java_lang_NullPointerException()) {\n@@ -1296,3 +1552,1 @@\n-      log_info(cds, heap)(\n-          \"Archived object klass (default subgraph %d) => %s\",\n-          i, subgraph_k->external_name());\n+      fatal(\"default subgraph cannot have objects of type %s\", subgraph_k->external_name());\n@@ -1300,11 +1554,0 @@\n-\n-    Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n-    guarantee(name == vmSymbols::java_lang_Class() ||\n-              name == vmSymbols::java_lang_String() ||\n-              name == vmSymbols::java_lang_ArithmeticException() ||\n-              name == vmSymbols::java_lang_NullPointerException() ||\n-              name == vmSymbols::java_lang_InternalError() ||\n-              name == vmSymbols::object_array_signature() ||\n-              name == vmSymbols::byte_array_signature() ||\n-              name == vmSymbols::char_array_signature(),\n-              \"default subgraph can have only these objects\");\n@@ -1533,0 +1776,19 @@\n+\n+void HeapShared::initialize_test_class_from_archive(JavaThread* current) {\n+  Klass* k = _test_class;\n+  if (k != nullptr && ArchiveHeapLoader::is_in_use()) {\n+    JavaThread* THREAD = current;\n+    ExceptionMark em(THREAD);\n+    const ArchivedKlassSubGraphInfoRecord* record =\n+      resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/false, THREAD);\n+\n+    \/\/ The _test_class is in the unnamed module, so it can't call CDS.initializeFromArchive()\n+    \/\/ from its <clinit> method. So we set up its \"archivedObjects\" field first, before\n+    \/\/ calling its <clinit>. This is not strictly clean, but it's a convenient way to write unit\n+    \/\/ test cases (see test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java).\n+    if (record != nullptr) {\n+      init_archived_fields_for(k, record);\n+    }\n+    resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/true, THREAD);\n+  }\n+}\n@@ -1608,0 +1870,9 @@\n+void HeapShared::debug_trace() {\n+  ResourceMark rm;\n+  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+  if (walker != nullptr) {\n+    LogStream ls(Log(cds, heap)::error());\n+    CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":305,"deletions":34,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -164,2 +164,3 @@\n-  static oop scratch_java_mirror(BasicType t) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-  static oop scratch_java_mirror(Klass* k)    NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop scratch_java_mirror(BasicType t)     NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop scratch_java_mirror(Klass* k)        NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop scratch_java_mirror(oop java_mirror) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -182,0 +183,1 @@\n+  static void debug_trace();\n@@ -188,0 +190,2 @@\n+  class CopyKlassSubGraphInfoToArchive;\n+\n@@ -250,0 +254,1 @@\n+  static ArchivedKlassSubGraphInfoRecord* archive_subgraph_info(KlassSubGraphInfo* info);\n@@ -288,1 +293,1 @@\n-  \/\/    - Klass::java_mirror()\n+  \/\/    - Klass::java_mirror() -- including initialized mirrors such as those of Enum klasses.\n@@ -291,0 +296,1 @@\n+  static ArchivedKlassSubGraphInfoRecord* _runtime_default_subgraph_info;\n@@ -327,1 +333,1 @@\n-\n+  static void copy_aot_initialized_mirror(Klass* orig_k, oop orig_mirror, oop m);\n@@ -418,0 +424,1 @@\n+  static void init_box_classes(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -433,0 +440,1 @@\n+  static void initialize_test_class_from_archive(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -434,0 +442,2 @@\n+\n+  static void init_classes_reachable_from_archived_mirrors(Handle loader, TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -818,0 +818,1 @@\n+int java_lang_Class::_reflectionData_offset;\n@@ -1254,0 +1255,5 @@\n+void java_lang_Class::set_reflection_data(oop java_class, oop reflection_data) {\n+  assert(_reflectionData_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_reflectionData_offset, reflection_data);\n+}\n+\n@@ -1444,0 +1450,1 @@\n+  macro(_reflectionData_offset,      k, \"reflectionData\",      java_lang_ref_SoftReference_signature, false); \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -238,0 +238,1 @@\n+  static int _reflectionData_offset;\n@@ -305,0 +306,1 @@\n+  static void set_reflection_data(oop java_class, oop reflection_data);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,0 +180,1 @@\n+  do_klass(Void_klass,                                  java_lang_Void                                        ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  template(java_lang_Void,                            \"java\/lang\/Void\")                           \\\n@@ -313,0 +314,2 @@\n+  template(java_lang_ref_SoftReference_signature,         \"Ljava\/lang\/ref\/SoftReference;\")        \\\n+                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -782,0 +782,71 @@\n+static bool are_super_types_initialized(InstanceKlass* ik) {\n+  InstanceKlass* s = ik->java_super();\n+  if (s != nullptr && !s->is_initialized()) {\n+    if (log_is_enabled(Info, cds, init)) {\n+      ResourceMark rm;\n+      log_info(cds, init)(\"%s takes slow path because super class %s is not initialized\",\n+                          ik->external_name(), s->external_name());\n+    }\n+    return false;\n+  }\n+\n+  if (ik->has_nonstatic_concrete_methods()) {\n+    \/\/ Only need to recurse if has_nonstatic_concrete_methods which includes declaring and\n+    \/\/ having a superinterface that declares, non-static, concrete methods\n+    Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+    int len = interfaces->length();\n+    for (int i = 0; i < len; i++) {\n+      InstanceKlass* intf = interfaces->at(i);\n+      if (!intf->is_initialized()) {\n+        if (log_is_enabled(Info, cds, init)) {\n+          ResourceMark rm;\n+          log_info(cds, init)(\"%s takes slow path because interface %s is not initialized\",\n+                              ik->external_name(), intf->external_name());\n+        }\n+        return false;\n+      }\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+void InstanceKlass::initialize_from_cds(TRAPS) {\n+  if (is_initialized()) {\n+    return;\n+  }\n+\n+  if (has_aot_initialized_mirror() && CDSConfig::is_loading_heap() &&\n+      are_super_types_initialized(this)) {\n+    if (log_is_enabled(Info, cds, init)) {\n+      ResourceMark rm;\n+      log_info(cds, init)(\"%s (quickest)\", external_name());\n+    }\n+\n+    link_class(CHECK);\n+\n+#ifdef ASSERT\n+    {\n+      Handle h_init_lock(THREAD, init_lock());\n+      ObjectLocker ol(h_init_lock, THREAD);\n+      assert(!is_initialized(), \"sanity\");\n+      assert(!is_being_initialized(), \"sanity\");\n+      assert(!is_in_error_state(), \"sanity\");\n+    }\n+#endif\n+\n+    set_init_thread(THREAD);\n+    set_initialization_state_and_notify(fully_initialized, CHECK);\n+    return;\n+  }\n+\n+  if (log_is_enabled(Info, cds, init)) {\n+    \/\/ If we have a preinit mirror, we may come to here if a supertype is not\n+    \/\/ yet initialized. It will still be quicker than usual, as we will skip the\n+    \/\/ execution of <clinit> of this class.\n+    ResourceMark rm;\n+    log_info(cds, init)(\"%s%s\", external_name(),\n+                        (has_aot_initialized_mirror() && CDSConfig::is_loading_heap()) ? \" (quicker)\" : \"\");\n+  }\n+  initialize(THREAD);\n+}\n@@ -1578,1 +1649,3 @@\n-  if (has_archived_enum_objs()) {\n+  if (has_aot_initialized_mirror() && CDSConfig::is_loading_heap()) {\n+    return;\n+  } else if (has_archived_enum_objs()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":74,"deletions":1,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -532,0 +532,1 @@\n+  void initialize_from_cds(TRAPS);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -193,1 +193,3 @@\n-    _is_generated_shared_class             = 1 << 5\n+    _is_generated_shared_class             = 1 << 5,\n+    \/\/ The archived mirror is already initialized dur AOT-cache assembly. No need to call <clinit>\n+    _has_aot_initialized_mirror            = 1 << 6,\n@@ -376,0 +378,8 @@\n+  void set_has_aot_initialized_mirror() {\n+    CDS_ONLY(_shared_class_flags |= _has_aot_initialized_mirror;)\n+  }\n+  bool has_aot_initialized_mirror() const {\n+    CDS_ONLY(return (_shared_class_flags & _has_aot_initialized_mirror) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -354,0 +355,2 @@\n+  HeapShared::init_box_classes(CHECK);\n+\n@@ -721,0 +724,4 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::finish_loading_javabase_classes(CHECK_JNI_ERR);\n+  }\n+\n@@ -739,0 +746,3 @@\n+#ifndef PRODUCT\n+  HeapShared::initialize_test_class_from_archive(THREAD);\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @modules java.base\/sun.invoke.util java.logging\n+ * @modules java.logging\n@@ -38,1 +38,1 @@\n- *             CDSTestClassE CDSTestClassF CDSTestClassG\n+ *             CDSTestClassE CDSTestClassF CDSTestClassG CDSTestClassG$MyEnum CDSTestClassG$Wrapper\n@@ -162,5 +162,8 @@\n-        if (false) { \/\/ JDK-8293187\n-            testCase(\"sun.invoke.util.Wrapper\");\n-            output = dumpBootAndHello(CDSTestClassG_name);\n-            mustSucceed(output);\n-        }\n+        testCase(\"Complex enums\");\n+        output = dumpBootAndHello(CDSTestClassG_name, \"-XX:+AOTClassLinking\", \"-Xlog:cds+class=debug\");\n+        mustSucceed(output);\n+\n+        TestCommon.run(\"-Xbootclasspath\/a:\" + bootJar, \"-cp\", appJar, \"-Xlog:cds+heap,cds+init\",\n+                       CDSTestClassG_name)\n+            .assertNormalExit(\"init subgraph \" + CDSTestClassG_name,\n+                              \"Initialized from CDS\");\n@@ -174,6 +177,21 @@\n-        archivedObjects = new Object[5];\n-        archivedObjects[0] = output;\n-        archivedObjects[1] = new CDSTestClassA[0];\n-        archivedObjects[2] = new YY();\n-        archivedObjects[3] = new int[0];\n-        archivedObjects[4] = new int[2][2];\n+        \/\/ The usual convention would be to call this here:\n+        \/\/     CDS.initializeFromArchive(CDSTestClassA.class);\n+        \/\/ However, the CDS class is not exported to the unnamed module by default,\n+        \/\/ and we don't want to use \"--add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\", as\n+        \/\/ that would disable the archived full module graph, which will disable\n+        \/\/ CDSConfig::is_using_aot_linked_classes().\n+        \/\/\n+        \/\/ Instead, HeapShared::initialize_test_class_from_archive() will set up the\n+        \/\/ \"archivedObjects\" field first, before calling CDSTestClassA.<clinit>. So\n+        \/\/ if we see that archivedObjects is magically non-null here, that means\n+        \/\/ it has been restored from the CDS archive.\n+        if (archivedObjects == null) {\n+            archivedObjects = new Object[5];\n+            archivedObjects[0] = output;\n+            archivedObjects[1] = new CDSTestClassA[0];\n+            archivedObjects[2] = new YY();\n+            archivedObjects[3] = new int[0];\n+            archivedObjects[4] = new int[2][2];\n+        } else {\n+            System.out.println(\"Initialized from CDS\");\n+        }\n@@ -272,3 +290,138 @@\n-        \/\/ Not in java.base\n-        archivedObjects = new Object[1];\n-        archivedObjects[0] = sun.invoke.util.Wrapper.BOOLEAN;\n+        if (archivedObjects == null) {\n+            archivedObjects = new Object[13];\n+            archivedObjects[0] = Wrapper.BOOLEAN;\n+            archivedObjects[1] = Wrapper.INT.zero();\n+            archivedObjects[2] = Wrapper.DOUBLE.zero();\n+            archivedObjects[3] = MyEnum.DUMMY1;\n+\n+            archivedObjects[4] = Boolean.class;\n+            archivedObjects[5] = Byte.class;\n+            archivedObjects[6] = Character.class;\n+            archivedObjects[7] = Short.class;\n+            archivedObjects[8] = Integer.class;\n+            archivedObjects[9] = Long.class;\n+            archivedObjects[10] = Float.class;\n+            archivedObjects[11] = Double.class;\n+            archivedObjects[12] = Void.class;\n+        } else {\n+            System.out.println(\"Initialized from CDS\");\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        if (archivedObjects[0] != Wrapper.BOOLEAN) {\n+            throw new RuntimeException(\"Huh 0\");\n+        }\n+\n+        if (archivedObjects[1] != Wrapper.INT.zero()) {\n+            throw new RuntimeException(\"Huh 1\");\n+        }\n+\n+        if (archivedObjects[2] != Wrapper.DOUBLE.zero()) {\n+            throw new RuntimeException(\"Huh 2\");\n+        }\n+\n+        if (archivedObjects[3] != MyEnum.DUMMY1) {\n+            throw new RuntimeException(\"Huh 3\");\n+        }\n+\n+        if (MyEnum.BOOLEAN != true) {\n+            throw new RuntimeException(\"Huh 10.1\");\n+        }\n+        if (MyEnum.BYTE != -128) {\n+            throw new RuntimeException(\"Huh 10.2\");\n+        }\n+        if (MyEnum.CHAR != 'c') {\n+            throw new RuntimeException(\"Huh 10.3\");\n+        }\n+        if (MyEnum.SHORT != -12345) {\n+            throw new RuntimeException(\"Huh 10.4\");\n+        }\n+        if (MyEnum.INT != -123456) {\n+            throw new RuntimeException(\"Huh 10.5\");\n+        }\n+        if (MyEnum.LONG != 0x1234567890L) {\n+            throw new RuntimeException(\"Huh 10.6\");\n+        }\n+        if (MyEnum.LONG2 != -0x1234567890L) {\n+            throw new RuntimeException(\"Huh 10.7\");\n+        }\n+        if (MyEnum.FLOAT != 567891.0f) {\n+            throw new RuntimeException(\"Huh 10.8\");\n+        }\n+        if (MyEnum.DOUBLE != 12345678905678.890) {\n+            throw new RuntimeException(\"Huh 10.9\");\n+        }\n+\n+        checkClass(4, Boolean.class);\n+        checkClass(5, Byte.class);\n+        checkClass(6, Character.class);\n+        checkClass(7, Short.class);\n+        checkClass(8, Integer.class);\n+        checkClass(9, Long.class);\n+        checkClass(10, Float.class);\n+        checkClass(11, Double.class);\n+        checkClass(12, Void.class);\n+\n+        System.out.println(\"Success!\");\n+    }\n+\n+    static void checkClass(int index, Class c) {\n+        if (archivedObjects[index] != c) {\n+            throw new RuntimeException(\"archivedObjects[\" + index + \"] should be \" + c);\n+        }\n+    }\n+\n+    \/\/ Simplified version of sun.invoke.util.Wrapper\n+    public enum Wrapper {\n+        \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray\n+        BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0]),\n+        INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0]),\n+        DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0])\n+        ;\n+\n+        public static final int COUNT = 10;\n+        private static final Object DOUBLE_ZERO = (Double)(double)0;\n+\n+        private final Class<?> wrapperType;\n+        private final Class<?> primitiveType;\n+        private final char     basicTypeChar;\n+        private final String   basicTypeString;\n+        private final Object   emptyArray;\n+\n+        Wrapper(Class<?> wtype,\n+                String wtypeName,\n+                Class<?> ptype,\n+                String ptypeName,\n+                char tchar,\n+                Object emptyArray) {\n+            this.wrapperType = wtype;\n+            this.primitiveType = ptype;\n+            this.basicTypeChar = tchar;\n+            this.basicTypeString = String.valueOf(this.basicTypeChar);\n+            this.emptyArray = emptyArray;\n+        }\n+\n+        public Object zero() {\n+            return switch (this) {\n+                case BOOLEAN -> Boolean.FALSE;\n+                case INT -> (Integer)0;\n+                case DOUBLE -> DOUBLE_ZERO;\n+                default -> null;\n+            };\n+        }\n+    }\n+\n+    enum MyEnum {\n+        DUMMY1,\n+        DUMMY2;\n+\n+        static final boolean BOOLEAN = true;\n+        static final byte    BYTE    = -128;\n+        static final short   SHORT   = -12345;\n+        static final char    CHAR    = 'c';\n+        static final int     INT     = -123456;\n+        static final long    LONG    =  0x1234567890L;\n+        static final long    LONG2   = -0x1234567890L;\n+        static final float   FLOAT   = 567891.0f;\n+        static final double  DOUBLE  = 12345678905678.890;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java","additions":170,"deletions":17,"binary":false,"changes":187,"status":"modified"}]}