{"files":[{"patch":"@@ -31,0 +31,57 @@\n+class AOTClassInitializer::AllowedSpec {\n+  const char* _class_name;\n+  bool _is_prefix;\n+  int _len;\n+public:\n+  AllowedSpec(const char* class_name, bool is_prefix = false)\n+    : _class_name(class_name), _is_prefix(is_prefix)\n+  {\n+    _len = (class_name == nullptr) ? 0 : (int)strlen(class_name);\n+  }\n+  const char* class_name() { return _class_name; }\n+\n+  bool matches(Symbol* name, int len) {\n+    if (_is_prefix) {\n+      return len >= _len && name->starts_with(_class_name);\n+    } else {\n+      return len == _len && name->equals(_class_name);\n+    }\n+  }\n+};\n+\n+\n+bool AOTClassInitializer::is_allowed(AllowedSpec* specs, InstanceKlass* ik) {\n+  Symbol* name = ik->name();\n+  int len = name->utf8_length();\n+  for (AllowedSpec* s = specs; s->class_name() != nullptr; s++) {\n+    if (s->matches(name, len)) {\n+      \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n+      \/\/   - all super classes must be included\n+      \/\/   - all super interfaces that have <clinit> must be included.\n+      \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n+      \/\/ ik's <clinit>.\n+      if (ik->java_super() != nullptr) {\n+        DEBUG_ONLY(ResourceMark rm);\n+        assert(AOTClassInitializer::can_archive_initialized_mirror(ik->java_super()),\n+               \"super class %s of %s must be aot-initialized\", ik->java_super()->external_name(),\n+               ik->external_name());\n+      }\n+\n+      Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+      int len = interfaces->length();\n+      for (int i = 0; i < len; i++) {\n+        InstanceKlass* intf = interfaces->at(i);\n+        if (intf->class_initializer() != nullptr) {\n+          assert(AOTClassInitializer::can_archive_initialized_mirror(intf),\n+                 \"super interface %s (which has <clinit>) of %s must be aot-initialized\", intf->external_name(),\n+                 ik->external_name());\n+        }\n+      }\n+\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\n@@ -37,1 +94,5 @@\n-  if (ik->is_initialized() && ik->java_super() == vmClasses::Enum_klass()) {\n+  if (!ik->is_initialized()) {\n+    return false;\n+  }\n+\n+  if (ik->java_super() == vmClasses::Enum_klass()) {\n@@ -39,5 +100,17 @@\n-  } else if (ik->name()->equals(\"jdk\/internal\/constant\/PrimitiveClassDescImpl\") ||\n-             ik->name()->equals(\"jdk\/internal\/constant\/ReferenceClassDescImpl\") ||\n-             ik->name()->equals(\"java\/lang\/constant\/ConstantDescs\")) {\n-    assert(ik->is_initialized(), \"must be\");\n-    \/\/ The above 3 classes are special cases needed to support the aot-caching of\n+  }\n+\n+  const bool IS_PREFIX = true;\n+\n+  {\n+    static AllowedSpec specs[] = {\n+      {\"java\/lang\/Object\"},\n+      {\"java\/lang\/Enum\"},\n+     {nullptr}\n+    };\n+    if (is_allowed(specs, ik)) {\n+      return true;\n+    }\n+  }\n+\n+  {\n+    \/\/ These classes are special cases needed to support the aot-caching of\n@@ -46,1 +119,1 @@\n-    \/\/ - The Wrapper enums point to static final fields in the above 3 classes.\n+    \/\/ - The Wrapper enums point to static final fields in these classes.\n@@ -48,1 +121,1 @@\n-    \/\/ - If we re-run the <clinit> of these 3 classes again during the production\n+    \/\/ - If we re-run the <clinit> of these classes again during the production\n@@ -53,1 +126,1 @@\n-    \/\/ Therefore, we must preserve the static fields of these 3 classes from\n+    \/\/ Therefore, we must preserve the static fields of these classes from\n@@ -55,3 +128,36 @@\n-    return true;\n-  } else {\n-    return false;\n+    static AllowedSpec specs[] = {\n+      {\"java\/lang\/constant\/DynamicConstantDesc\"},\n+      {\"jdk\/internal\/constant\/PrimitiveClassDescImpl\"},\n+      {\"jdk\/internal\/constant\/ReferenceClassDescImpl\"},\n+      {\"java\/lang\/constant\/ConstantDescs\"},\n+      {nullptr}\n+    };\n+    if (is_allowed(specs, ik)) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+#ifdef ASSERT\n+void AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(InstanceKlass* ik) {\n+  assert(ik->has_aot_initialized_mirror(), \"must be\");\n+\n+  InstanceKlass* s = ik->java_super();\n+  if (s != nullptr) {\n+    DEBUG_ONLY(ResourceMark rm);\n+    assert(s->is_initialized(), \"super class %s of aot-inited class %s must have been initialized\",\n+           s->external_name(), ik->external_name());\n+    AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(s);\n+  }\n+\n+  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = interfaces->at(i);\n+    if (!intf->is_initialized()) {\n+      \/\/ Note: interfaces with no <clinit> are not marked as is_initialized().\n+      assert(intf->class_initializer() == nullptr, \"uninitialized super interface %s of aot-inited class %s must not have <clinit>\",\n+             intf->external_name(), ik->external_name());\n+    }\n@@ -60,0 +166,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":119,"deletions":12,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+  class AllowedSpec;\n+  static bool is_allowed(AllowedSpec* specs, InstanceKlass* ik);\n+\n@@ -38,0 +41,2 @@\n+\n+  static void assert_no_clinit_will_run_for_aot_init_class(InstanceKlass* ik) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -254,5 +255,4 @@\n-        \/\/ ik's <clinit> will not be executed as its mirror was already initialized\n-        \/\/ during AOT cache assembly.\n-        \/\/ Note that we allow the supertypes of ik to be *not* aot-initialized, so\n-        \/\/ the following call may execute the <clinit> of some supertypes.\n-        \/\/ TODO -- see if we can require all supertypes of be aot-initialized.\n+        \/\/ No <clinit> of ik or any of its supertypes will be executed.\n+        \/\/ Their mirrors were already initialized during AOT cache assembly.\n+        AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(ik);\n+\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -788,10 +789,5 @@\n-static bool are_super_types_initialized(InstanceKlass* ik) {\n-  InstanceKlass* s = ik->java_super();\n-  if (s != nullptr && !s->is_initialized()) {\n-    if (log_is_enabled(Info, cds, init)) {\n-      ResourceMark rm;\n-      log_info(cds, init)(\"%s takes slow path because super class %s is not initialized\",\n-                          ik->external_name(), s->external_name());\n-    }\n-    return false;\n-  }\n+static bool check_supertypes_of_aot_inited_class(InstanceKlass* ik) {\n+  assert(ik->has_aot_initialized_mirror(), \"must be\");\n+\n+  \/\/ Sanity check of all superclasses and superinterfaces.\n+  AOTClassInitializer::assert_no_clinit_will_run_for_aot_init_class(ik);\n@@ -800,2 +796,0 @@\n-    \/\/ Only need to recurse if has_nonstatic_concrete_methods which includes declaring and\n-    \/\/ having a superinterface that declares, non-static, concrete methods\n@@ -807,0 +801,1 @@\n+        assert(intf->class_initializer() == nullptr, \"should have been asserted\");\n@@ -809,2 +804,3 @@\n-          log_info(cds, init)(\"%s takes slow path because interface %s is not initialized\",\n-                              ik->external_name(), intf->external_name());\n+          log_info(cds, init)(\"%s takes slow path because interface %s (%s <clinit>) is not yet initialized\",\n+                              ik->external_name(), intf->external_name(),\n+                              (intf->class_initializer() != nullptr) ? \"has\" : \"no\");\n@@ -826,1 +822,1 @@\n-      are_super_types_initialized(this)) {\n+      check_supertypes_of_aot_inited_class(this)) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -549,0 +549,1 @@\n+ -runtime\/cds\/appcds\/TestZGCWithCDS.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}