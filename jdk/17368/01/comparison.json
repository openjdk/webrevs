{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -144,1 +145,8 @@\n-void WorkerThreads::set_indirectly_suspendible_threads() {\n+template <typename Function>\n+void WorkerThreads::threads_do_f(Function function) const {\n+  for (uint i = 0; i < _created_workers; i++) {\n+    function(_workers[i]);\n+  }\n+}\n+\n+void WorkerThreads::set_indirect_states() {\n@@ -146,2 +154,7 @@\n-  class SetIndirectlySuspendibleThreadClosure : public ThreadClosure {\n-    virtual void do_thread(Thread* thread) {\n+  const bool is_suspendible = Thread::current()->is_suspendible_thread();\n+  const bool is_safepointed = Thread::current()->is_VM_thread() && SafepointSynchronize::is_at_safepoint();\n+\n+  threads_do_f([&](Thread* thread) {\n+    assert(!thread->is_indirectly_suspendible_thread(), \"Unexpected\");\n+    assert(!thread->is_indirectly_safepoint_thread(), \"Unexpected\");\n+    if (is_suspendible) {\n@@ -150,6 +163,4 @@\n-  };\n-\n-  if (Thread::current()->is_suspendible_thread()) {\n-    SetIndirectlySuspendibleThreadClosure cl;\n-    threads_do(&cl);\n-  }\n+    if (is_safepointed) {\n+      thread->set_indirectly_safepoint_thread();\n+    }\n+  });\n@@ -159,1 +170,1 @@\n-void WorkerThreads::clear_indirectly_suspendible_threads() {\n+void WorkerThreads::clear_indirect_states() {\n@@ -161,10 +172,4 @@\n-  class ClearIndirectlySuspendibleThreadClosure : public ThreadClosure {\n-    virtual void do_thread(Thread* thread) {\n-      thread->clear_indirectly_suspendible_thread();\n-    }\n-  };\n-\n-  if (Thread::current()->is_suspendible_thread()) {\n-    ClearIndirectlySuspendibleThreadClosure cl;\n-    threads_do(&cl);\n-  }\n+  threads_do_f([&](Thread* thread) {\n+    thread->clear_indirectly_suspendible_thread();\n+    thread->clear_indirectly_safepoint_thread();\n+  });\n@@ -175,1 +180,1 @@\n-  set_indirectly_suspendible_threads();\n+  set_indirect_states();\n@@ -177,1 +182,1 @@\n-  clear_indirectly_suspendible_threads();\n+  clear_indirect_states();\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -96,2 +96,2 @@\n-  void set_indirectly_suspendible_threads();\n-  void clear_indirectly_suspendible_threads();\n+  void set_indirect_states();\n+  void clear_indirect_states();\n@@ -114,0 +114,2 @@\n+  template <typename Function>\n+  void threads_do_f(Function function) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"code\/codeCache.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"gc\/z\/zVerify.hpp\"\n@@ -36,1 +36,0 @@\n-#include \"runtime\/continuation.hpp\"\n@@ -323,8 +322,0 @@\n-inline void z_assert_is_barrier_safe() {\n-  assert(!Thread::current()->is_ConcurrentGC_thread() ||          \/* Need extra checks for ConcurrentGCThreads *\/\n-         Thread::current()->is_suspendible_thread() ||            \/* Thread prevents safepoints *\/\n-         Thread::current()->is_indirectly_suspendible_thread() || \/* Coordinator thread prevents safepoints *\/\n-         SafepointSynchronize::is_at_safepoint(),                 \/* Is at safepoint *\/\n-         \"Shouldn't perform load barrier\");\n-}\n-\n@@ -333,1 +324,1 @@\n-  z_assert_is_barrier_safe();\n+  z_verify_safepoints_are_blocked();\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -289,0 +289,4 @@\n+bool ZGeneration::is_relocate_queue_active() const {\n+  return _relocate.is_queue_active();\n+}\n+\n@@ -1500,1 +1504,1 @@\n-  \/\/ TODO: The STS joiner is only needed to satisfy z_assert_is_barrier_safe that doesn't\n+  \/\/ TODO: The STS joiner is only needed to satisfy ZBarrier::assert_is_state_barrier_safe that doesn't\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+  bool is_relocate_queue_active() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zVerify.hpp\"\n@@ -34,0 +35,9 @@\n+  \/\/ This is a good place to make sure that we can't concurrently iterate over\n+  \/\/ objects while VMThread operations think they have exclusive access to the\n+  \/\/ object graph.\n+  \/\/\n+  \/\/ One example that have caused problems is the JFR Leak Profiler, which\n+  \/\/ sets the mark word to a value that makes the object arrays look like\n+  \/\/ invisible objects.\n+  z_verify_safepoints_are_blocked();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zIterator.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    _is_active(false),\n@@ -106,0 +107,14 @@\n+void ZRelocateQueue::activate(uint nworkers) {\n+  _is_active = true;\n+  join(nworkers);\n+}\n+\n+void ZRelocateQueue::deactivate() {\n+  Atomic::store(&_is_active, false);\n+  clear();\n+}\n+\n+bool ZRelocateQueue::is_active() const {\n+  return Atomic::load(&_is_active);\n+}\n+\n@@ -330,1 +345,1 @@\n-  _queue.join(workers()->active_workers());\n+  _queue.activate(workers()->active_workers());\n@@ -1091,0 +1106,3 @@\n+\n+    \/\/ Signal that we're not using the queue anymore. Used mostly for asserts.\n+    _queue->deactivate();\n@@ -1235,2 +1253,0 @@\n-\n-  _queue.clear();\n@@ -1319,0 +1335,4 @@\n+\n+bool ZRelocate::is_queue_active() const {\n+  return _queue.is_active();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  volatile bool        _is_active;\n@@ -56,0 +57,4 @@\n+  void activate(uint nworkers);\n+  void deactivate();\n+  bool is_active() const;\n+\n@@ -102,0 +107,2 @@\n+\n+  bool is_queue_active() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -109,0 +109,3 @@\n+    \/\/ Join the STS to block out VMThreads while running promote_barrier_on_young_oop_field\n+    SuspendibleThreadSetJoiner sts_joiner;\n+\n@@ -114,0 +117,2 @@\n+\n+      SuspendibleThreadSet::yield();\n@@ -121,0 +126,2 @@\n+\n+      SuspendibleThreadSet::yield();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/z\/zBarrier.hpp\"\n@@ -36,1 +37,1 @@\n-  z_assert_is_barrier_safe();\n+  z_verify_safepoints_are_blocked();\n","filename":"src\/hotspot\/share\/gc\/z\/zUncoloredRoot.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -51,0 +52,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -56,0 +58,49 @@\n+#ifdef ASSERT\n+\n+\/\/ Used to verify that safepoints operations can't be scheduled concurrently\n+\/\/ with callers to this function. Typically used to verify that object oops\n+\/\/ and headers are safe to access.\n+void z_verify_safepoints_are_blocked() {\n+  Thread* current = Thread::current();\n+\n+  if (current->is_ConcurrentGC_thread()) {\n+    assert(current->is_suspendible_thread(), \/\/ Thread prevents safepoints\n+        \"Safepoints are not blocked by current thread\");\n+\n+  } else if (current->is_Worker_thread()) {\n+    assert(\/\/ Check if ...\n+        \/\/ the thread prevents safepoints\n+        current->is_suspendible_thread() ||\n+        \/\/ the coordinator thread is the safepointing VMThread\n+        current->is_indirectly_safepoint_thread() ||\n+        \/\/ the coordinator thread prevents safepoints\n+        current->is_indirectly_suspendible_thread() ||\n+        \/\/ the RelocateQueue prevents safepoints\n+        \/\/\n+        \/\/ RelocateQueue acts as a pseudo STS leaver\/joiner and blocks\n+        \/\/ safepoints. There's currently no infrastructure  to check if the\n+        \/\/ current thread is active or not, so check the global states instead.\n+        ZGeneration::young()->is_relocate_queue_active() ||\n+        ZGeneration::old()->is_relocate_queue_active(),\n+        \"Safepoints are not blocked by current thread\");\n+\n+  } else if (current->is_Java_thread()) {\n+    JavaThreadState state = JavaThread::cast(current)->thread_state();\n+    assert(state == _thread_in_Java || state == _thread_in_vm || state == _thread_new,\n+        \"Safepoints are not blocked by current thread from state: %d\", state);\n+\n+  } else if (current->is_JfrSampler_thread()) {\n+    \/\/ The JFR sampler thread blocks out safepoints with this lock.\n+    assert_lock_strong(Threads_lock);\n+\n+  } else if (current->is_VM_thread()) {\n+    \/\/ The VM Thread doesn't schedule new safepoints while executing\n+    \/\/ other safepoint or handshake operations.\n+\n+  } else {\n+    fatal(\"Unexpected thread type\");\n+  }\n+}\n+\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+NOT_DEBUG(inline) void z_verify_safepoints_are_blocked() NOT_DEBUG_RETURN;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  DEBUG_ONLY(clear_indirectly_safepoint_thread();)\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+  DEBUG_ONLY(bool _indirectly_safepoint_thread;)\n@@ -228,0 +229,4 @@\n+\n+  void set_indirectly_safepoint_thread()   { _indirectly_safepoint_thread = true; }\n+  void clear_indirectly_safepoint_thread() { _indirectly_safepoint_thread = false; }\n+  bool is_indirectly_safepoint_thread()    { return _indirectly_safepoint_thread; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}