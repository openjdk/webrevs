{"files":[{"patch":"@@ -382,0 +382,43 @@\n+\n+\/**\n+ * parse jcmd common option\n+ * @param line - a command line with leading common options \"[options] <cmd>\"\n+ * @param updated_line - return value with \"<cmd>\"\n+ *\/\n+static JcmdOptions parse_common_options(const CmdLine& line, stringStream *updated_line) {\n+  JcmdOptions options = {0};\n+\n+  \/\/ there is only TIMESTAMP option so far\n+  const char TIMESTAMP[] = \"-T\";\n+\n+  const char* line_str = line.cmd_addr();\n+\n+  stringStream cmd;\n+  cmd.print(\"%s\", line.cmd_addr());\n+  char* rest = cmd.as_string();\n+  for (char* token = strtok_r(rest, \" \", &rest);\n+      token != nullptr;\n+      token = strtok_r(nullptr, \" \", &rest)) {\n+\n+    \/\/ there only one option for now.\n+    if (strcmp(token, TIMESTAMP) == 0) {\n+      options.timestamp = true;\n+\n+      \/\/ save the remainder before\n+      line_str = strstr(line_str, rest);\n+    } else {\n+      break;\n+    }\n+  }\n+\n+  updated_line->write(line_str, strlen(line_str));\n+\n+  return options;\n+}\n+\n+\n+static void print_local_time(outputStream* output) {\n+  char buf[32];\n+  output->print_cr(\"%s\", os::local_time_string(buf, sizeof(buf)));\n+}\n+\n@@ -396,1 +439,13 @@\n-    CmdLine line = iter.next();\n+\n+    \/\/ > jcmd [options] <command> [args]\n+    \/\/        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    const CmdLine line_optioned = iter.next();\n+\n+    \/\/ parse options\n+    stringStream ss_line_naked;\n+    const JcmdOptions options = parse_common_options(line_optioned, &ss_line_naked);\n+\n+    \/\/ > jcmd [options] <command> [args]\n+    \/\/                  ^^^^^^^^^^^^^^^^\n+    CmdLine line(ss_line_naked.base(), ss_line_naked.size(), false);\n+\n@@ -400,0 +455,1 @@\n+\n@@ -401,2 +457,0 @@\n-      \/\/ Allow for \"<cmd> -h|-help|--help\" to enable the help diagnostic command.\n-      \/\/ Ignores any additional arguments.\n@@ -404,0 +458,3 @@\n+\n+      \/\/ treat trailing {-h,-help,--help} as help command\n+      \/\/ Ignores any additional arguments.\n@@ -414,0 +471,5 @@\n+\n+      if (options.timestamp) {\n+        print_local_time(_out);\n+      }\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":65,"deletions":3,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -167,0 +167,5 @@\n+\n+struct JcmdOptions {\n+  bool timestamp;\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,5 +53,4 @@\n-        if (args[0].equals(\"-?\") ||\n-            args[0].equals(\"-h\") ||\n-            args[0].equals(\"--help\") ||\n-            \/\/ -help: legacy.\n-            args[0].equals(\"-help\")) {\n+        if (args[0].equals(\"-?\")\n+                || args[0].equals(\"-h\")\n+                || args[0].equals(\"--help\")\n+                || args[0].equals(\"-help\")) { \/\/ -help: legacy.\n@@ -62,2 +61,1 @@\n-        processString = args[0];\n-\n+        int argsCounter = 0;\n@@ -65,1 +63,18 @@\n-        for (int i = 1; i < args.length; i++) {\n+\n+        \/\/ {<PID>, <main class>}\n+        processString = args[argsCounter];\n+        argsCounter++;\n+\n+        \/\/ common flags: [-T]\n+        if (argsCounter < args.length           \/\/ \"jcmd <PID>\" is not an error and acts as \"jcmd <PID> help\"\n+                && args[argsCounter].equals(\"-T\")) {\n+            sb.append(args[argsCounter]).append(\" \");\n+            argsCounter++;\n+\n+            if (argsCounter == args.length) {\n+                \/\/ common flag followed by nothing\n+                throw new IllegalArgumentException(\"Not enough arguments\");\n+            }\n+        }\n+\n+        for (int i = argsCounter; i < args.length; i++) {\n@@ -111,1 +126,1 @@\n-        System.out.println(\"Usage: jcmd <pid | main class> <command ...|PerfCounter.print|-f file>\");\n+        System.out.println(\"Usage: jcmd <pid | main class> [-T] <command ...|PerfCounter.print|-f file>\");\n@@ -113,1 +128,3 @@\n-        System.out.println(\"   or: jcmd -h                                                    \");\n+        System.out.println(\"   or: jcmd <-h | --help>                                         \");\n+        System.out.println(\"                                                                  \");\n+        System.out.println(\"  -T flag ensures the dignostic command begins with a timestamp   \");\n@@ -115,1 +132,1 @@\n-        System.out.println(\"  command must be a valid jcmd command for the selected jvm.      \");\n+        System.out.println(\"  command must be a valid jcmd command for the selected JVM.      \");\n@@ -125,1 +142,1 @@\n-        System.out.println(\"  -? -h --help print this help message                            \");\n+        System.out.println(\"  -? -h --help  print this help message                           \");\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jcmd\/Arguments.java","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-`jcmd` \\[*pid* \\| *main-class*\\] *command*... \\| `PerfCounter.print` \\| `-f`\n+`jcmd` \\[*pid* \\| *main-class*\\] [`-T`] *command*... \\| `PerfCounter.print` \\| `-f`\n@@ -51,0 +51,3 @@\n+`-T`\n+:   When used, the diagnostic commands output starts with a timestamp.\n+\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.md","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.Duration;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.dcmd.FileJcmdExecutor;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.dcmd.JcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/*\n+ * @test\n+ * @summary test jcmd generic flag \"-T\" to make sure dignostic coommand is timestamped\n+ * @library \/test\/lib\n+ * @run main\/othervm TestJcmdTimestamp\n+ *\/\n+public class TestJcmdTimestamp {\n+\n+    public static void main(String[] args) throws Exception {\n+        TestJcmdTimestamp(new PidJcmdExecutor(), \"-T VM.version\", true \/* expectTimestamp *\/);\n+        TestJcmdTimestamp(new PidJcmdExecutor(), \"VM.version\", false \/* expectTimestamp *\/);\n+        TestJcmdTimestamp(new FileJcmdExecutor(), \"-T VM.version\", true \/* expectTimestamp *\/);\n+        TestJcmdTimestamp(new FileJcmdExecutor(), \"VM.version\", false \/* expectTimestamp *\/);\n+    }\n+\n+    \/\/ timestamp should be there and it should be recent\n+    public static void assertTimestamp(final String line) throws java.time.format.DateTimeParseException {\n+        final String timePattern = \"yyyy-MM-dd HH:mm:ss\";\n+        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(timePattern);\n+        final LocalDateTime parsedDateTime = LocalDateTime.parse(line, formatter);\n+\n+        final Duration duration = Duration.between(parsedDateTime, LocalDateTime.now());\n+        Asserts.assertLessThan(duration.getSeconds(), 5L, \"the timestamp is not recent\");\n+    }\n+\n+\n+    private static void TestJcmdTimestamp(final JcmdExecutor executor,\n+            final String command,\n+            final boolean expectTimestamp) throws Exception {\n+\n+        OutputAnalyzer output = executor.execute(command);\n+        output.shouldHaveExitValue(0);\n+\n+        final String secondLine = output.getOutput().split(\"\\\\r?\\\\n\")[1];\n+\n+        if (expectTimestamp) {\n+            assertTimestamp(secondLine);\n+        }\n+        else {\n+            Asserts.assertThrows(java.time.format.DateTimeParseException.class, () -> assertTimestamp(secondLine));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdTimestamp.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-Usage: jcmd <pid | main class> <command ...|PerfCounter.print|-f file>\n+Usage: jcmd <pid | main class> [-T] <command ...|PerfCounter.print|-f file>\n@@ -3,1 +3,1 @@\n-   or: jcmd -h                                                    \n+   or: jcmd <-h | --help>                                         \n@@ -5,1 +5,3 @@\n-  command must be a valid jcmd command for the selected jvm.      \n+  -T flag ensures the dignostic command begins with a timestamp   \n+                                                                  \n+  command must be a valid jcmd command for the selected JVM.      \n@@ -15,1 +17,1 @@\n-  -? -h --help print this help message                            \n+  -? -h --help  print this help message                           \n","filename":"test\/jdk\/sun\/tools\/jcmd\/usage.out","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}