{"files":[{"patch":"@@ -320,1 +320,1 @@\n-    find_scalar_replaceable_allocs(jobj_worklist);\n+    find_scalar_replaceable_allocs(jobj_worklist, reducible_merges);\n@@ -3055,0 +3055,35 @@\n+void ConnectionGraph::revisit_reducible_phi_status(JavaObjectNode* jobj, Unique_Node_List& reducible_merges) {\n+  assert(jobj != nullptr && !jobj->scalar_replaceable(), \"jobj should be set as NSR before calling this function.\");\n+\n+  \/\/ Look for 'phis' that refer to 'jobj' as the last\n+  \/\/ remaining scalar replaceable input.\n+  uint reducible_merges_cnt = reducible_merges.size();\n+  for (uint i = 0; i < reducible_merges_cnt; i++) {\n+    Node* phi = reducible_merges.at(i);\n+\n+    \/\/ This 'Phi' will be a 'good' if it still points to\n+    \/\/ at least one scalar replaceable object. Note that 'obj'\n+    \/\/ was\/should be marked as NSR before calling this function.\n+    bool good_phi = false;\n+\n+    for (uint j = 1; j < phi->req(); j++) {\n+      JavaObjectNode* phi_in_obj = unique_java_object(phi->in(j));\n+      if (phi_in_obj != nullptr && phi_in_obj->scalar_replaceable()) {\n+        good_phi = true;\n+        break;\n+      }\n+    }\n+\n+    if (!good_phi) {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Phi %d became non-reducible after node %d became NSR.\", phi->_idx, jobj->ideal_node()->_idx);)\n+      reducible_merges.remove(i);\n+\n+      \/\/ Decrement the index because the 'remove' call above actually\n+      \/\/ moves the last entry of the list to position 'i'.\n+      i--;\n+\n+      reducible_merges_cnt--;\n+    }\n+  }\n+}\n+\n@@ -3056,1 +3091,1 @@\n-void ConnectionGraph::find_scalar_replaceable_allocs(GrowableArray<JavaObjectNode*>& jobj_worklist) {\n+void ConnectionGraph::find_scalar_replaceable_allocs(GrowableArray<JavaObjectNode*>& jobj_worklist, Unique_Node_List &reducible_merges) {\n@@ -3075,0 +3110,4 @@\n+              \/\/ Any merge that had only 'jobj' as scalar-replaceable will now be non-reducible,\n+              \/\/ because there is no point in reducing a Phi that won't improve the number of SR\n+              \/\/ objects.\n+              revisit_reducible_phi_status(jobj, reducible_merges);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -475,0 +475,3 @@\n+  \/\/ Reevaluate Phis reducible status after 'obj' became NSR.\n+  void revisit_reducible_phi_status(JavaObjectNode* jobj, Unique_Node_List& reducible_merges);\n+\n@@ -476,1 +479,1 @@\n-  void find_scalar_replaceable_allocs(GrowableArray<JavaObjectNode*>& jobj_worklist);\n+  void find_scalar_replaceable_allocs(GrowableArray<JavaObjectNode*>& jobj_worklist, Unique_Node_List &reducible_merges);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340454\n+ * @summary Check that Reduce Allocation Merges doesn't crash when\n+ *          a reducible Phi becomes irreducible after the last of\n+ *          its SR inputs is flagged as NSR.\n+ * @run main\/othervm -XX:CompileCommand=dontinline,*TestReduceAllocationAndNonReduciblePhi*::test\n+ *                   -XX:CompileCommand=compileonly,*TestReduceAllocationAndNonReduciblePhi*::test\n+ *                   -XX:CompileCommand=compileonly,*Picture*::*\n+ *                   -XX:CompileCommand=compileonly,*Point*::*\n+ *                   -XX:CompileCommand=inline,*Picture*::*\n+ *                   -XX:CompileCommand=inline,*Point*::*\n+ *                   -XX:CompileCommand=exclude,*::dummy*\n+ *                   -Xbatch\n+ *                   -server\n+ *                   compiler.escapeAnalysis.TestReduceAllocationAndNonReduciblePhi\n+ *\n+ * @run main compiler.escapeAnalysis.TestReduceAllocationAndNonReduciblePhi\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+public class TestReduceAllocationAndNonReduciblePhi {\n+    public static void main(String args[]) {\n+        int result = 0;\n+\n+        for (int i = 0; i < 20000; i++) {\n+            result += test(i % 2 == 0, i % 3);\n+        }\n+\n+        System.out.println(\"Result is = \" + result);\n+    }\n+\n+    public static int test(boolean flag1, int pos) {\n+        Point p0 = new Point();\n+        Point p1 = flag1 ? null : p0;\n+\n+        Picture pic = new Picture();\n+        pic.p = p0;\n+\n+        Picture[] ps = new Picture[5];\n+        ps[pos] = pic;\n+\n+        return p1 != null ? dummy1() : dummy2();\n+    }\n+\n+    public static int dummy1() { return 1; }\n+\n+    public static int dummy2() { return 2; }\n+\n+    private static class Picture {\n+        public Point p;\n+    }\n+\n+    private static class Point { }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestReduceAllocationAndNonReduciblePhi.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}