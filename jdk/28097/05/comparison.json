{"files":[{"patch":"@@ -25,1 +25,1 @@\n-#include \"memory\/allocation.inline.hpp\"\n+#include \"jni_md.h\"\n@@ -31,0 +31,1 @@\n+#include \"opto\/node.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -33,0 +35,2 @@\n+#include \"opto\/type.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -34,0 +38,2 @@\n+#include <cstdint>\n+#include <type_traits>\n@@ -595,4 +601,35 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  const Type *bot = bottom_type();\n-  return MulHiValue(t1, t2, bot);\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+\n+  \/\/ Either input is TOP ==> the result is TOP\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ Either input is ZERO, the result always ZERO\n+  if (t1 == TypeLong::ZERO || t2 == TypeLong::ZERO) {\n+    return TypeLong::ZERO;\n+  }\n+\n+  const TypeLong* longType1 = t1->is_long();\n+  const TypeLong* longType2 = t2->is_long();\n+\n+  \/\/ Both are constant, directly computed the result\n+  if (longType1->is_con() && longType2->is_con()) {\n+    jlong highResult = multiply_high_signed(longType1->get_con(), longType2->get_con());\n+    return TypeLong::make(highResult);\n+  }\n+\n+  \/\/ If the 64-bit product cannot overflow and its sign is known, the result is constant.\n+  const IntegerTypeMultiplication<jlong> multiplication(longType1, longType2);\n+  if (!multiplication.does_overflow()) {\n+    const TypeLong* result = multiplication.compute()->is_long();\n+    if (result->_lo >= 0) {\n+      return TypeLong::ZERO;\n+    }\n+    if (result->_hi < 0) {\n+      return TypeLong::MINUS_1;\n+    }\n+  }\n+\n+  return bottom_type();\n@@ -602,5 +639,2 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  const Type *bot = bottom_type();\n-  return MulHiValue(t1, t2, bot);\n-}\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n@@ -608,2 +642,0 @@\n-\/\/ A common routine used by UMulHiLNode and MulHiLNode\n-const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot) {\n@@ -611,2 +643,3 @@\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -614,4 +647,4 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  \/\/ Either input is ZERO, the result always ZERO\n+  if (t1 == TypeLong::ZERO || t2 == TypeLong::ZERO) {\n+    return TypeLong::ZERO;\n+  }\n@@ -619,2 +652,17 @@\n-  \/\/ It is not worth trying to constant fold this stuff!\n-  return TypeLong::LONG;\n+  const TypeLong* longType1 = t1->is_long();\n+  const TypeLong* longType2 = t2->is_long();\n+  const int widen = MIN2(longType1->_widen, longType2->_widen);\n+\n+  \/\/ Both are constant, directly computed the result\n+  if (longType1->is_con() && longType2->is_con()) {\n+    julong highResult = multiply_high_unsigned(longType1->get_con(), longType2->get_con());\n+    TypeIntPrototype<jlong, julong> proto{{min_jlong, max_jlong}, {highResult, highResult}, {0, 0}};\n+    return TypeLong::make_or_top(proto, widen);\n+  }\n+\n+  \/\/ If both operands are within the unsigned 32-bit range, the upper 64 bits of the 128-bit product are always zero.\n+  if (longType1->_uhi <= max_juint && longType2->_uhi <= max_juint) {\n+    return TypeLong::ZERO;\n+  }\n+\n+  return bottom_type();\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":68,"deletions":20,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -184,1 +184,0 @@\n-const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot);\n@@ -194,1 +193,0 @@\n-  friend const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot);\n@@ -205,1 +203,0 @@\n-  friend const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8370196\n+ * @summary Test that Value method of MulHiLNode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.MulHiLNodeValueTests\n+ *\/\n+public class MulHiLNodeValueTests {\n+    private static final RestrictableGenerator<Long> LONGS = Generators.G.longs();\n+    private static final long C1 = LONGS.next(), C2 = LONGS.next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"givenConstants\", \"givenLeftZero\",\n+            \"givenRightZero\", \"givenTwoLong\"\n+    })\n+    public void runWithLongInputs() {\n+        long aLong = LONGS.next();\n+        long bLong = LONGS.next();\n+        long minLong = Long.MIN_VALUE;\n+        long maxLong = Long.MAX_VALUE;\n+\n+        assertLongInputsResult(0, 0);\n+        assertLongInputsResult(aLong, bLong);\n+        assertLongInputsResult(minLong, minLong);\n+        assertLongInputsResult(maxLong, maxLong);\n+    }\n+\n+    @DontCompile\n+    public void assertLongInputsResult(long a, long b) {\n+        Asserts.assertEquals(Math.multiplyHigh(C1, C2), givenConstants());\n+        Asserts.assertEquals(Math.multiplyHigh(0, b), givenLeftZero(b));\n+        Asserts.assertEquals(Math.multiplyHigh(a, 0), givenRightZero(a));\n+        Asserts.assertEquals(Math.multiplyHigh(a, b), givenTwoLong(a, b));\n+    }\n+\n+    @Run(test = {\n+            \"givenNoOverflowPositiveInt\", \"givenNoOverflowNegativeInt\"\n+    })\n+    public void runWithIntInputs() {\n+        assertIntInputsResult(LONGS.next(), LONGS.next());\n+    }\n+\n+    @DontCompile\n+    public void assertIntInputsResult(long a, long b) {\n+        long x = nonZeroPositiveInt(a);\n+        long y = (a * b > 0) ? nonZeroPositiveInt(b) : negativeInt(b);\n+        long expected = Math.multiplyHigh(x, y);\n+        Asserts.assertEquals(expected, (a * b > 0) ? givenNoOverflowPositiveInt(x, y) : givenNoOverflowNegativeInt(x, y));\n+    }\n+\n+    \/**\n+     * If two parameters are constant, folding to constant node\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenConstants() {\n+        return Math.multiplyHigh(C1, C2);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenLeftZero(long b) {\n+        return Math.multiplyHigh(0, b);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenRightZero(long a) {\n+        return Math.multiplyHigh(a, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HI_L, \"1\"})\n+    public long givenTwoLong(long a, long b) {\n+        return Math.multiplyHigh(a, b);\n+    }\n+\n+    \/**\n+     * Product is always non-negative and fits into 64 bits -> high word is zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenNoOverflowPositiveInt(long a, long b) {\n+        long x = nonZeroPositiveInt(a);\n+        long y = nonZeroPositiveInt(b);\n+        return Math.multiplyHigh(x, y);\n+    }\n+\n+    \/**\n+     * Product is always negative (non-negative * negative) and fits into 64 bits -> high word is -1\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenNoOverflowNegativeInt(long a, long b) {\n+        long x = nonZeroPositiveInt(a);\n+        long y = negativeInt(b);\n+        return Math.multiplyHigh(x, y);\n+    }\n+\n+    @ForceInline\n+    private static long nonZeroPositiveInt(long v) {\n+        return (v & 0x7fffffffL) + 1L;\n+    }\n+\n+    @ForceInline\n+    private static long negativeInt(long v) {\n+        return -((v & 0x7fffffffL) + 1L);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/MulHiLNodeValueTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8370196\n+ * @summary Test that Value method of UMulHiLNode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.UMulHiLNodeValueTests\n+ *\/\n+public class UMulHiLNodeValueTests {\n+    private static final RestrictableGenerator<Long> LONGS = Generators.G.longs();\n+    private static final long C1 = LONGS.next(), C2 = LONGS.next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"givenTwoConstant\", \"givenLeftZero\",\n+            \"givenRightZero\", \"givenTwoLong\"\n+    })\n+    public void run() {\n+        long aLong = LONGS.next();\n+        long bLong = LONGS.next();\n+        long minLong = Long.MIN_VALUE;\n+        long maxLong = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(aLong, bLong);\n+        assertResult(minLong, minLong);\n+        assertResult(maxLong, maxLong);\n+    }\n+\n+    @Run(test = \"givenUint32RangeFolded\")\n+    public void runWithUint32Inputs() {\n+        assertUint32Result(LONGS.next(), LONGS.next());\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(C1, C2), givenTwoConstant());\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(0, b), givenLeftZero(b));\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(a, 0), givenRightZero(a));\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(a, b), givenTwoLong(a, b));\n+    }\n+\n+    @DontCompile\n+    public void assertUint32Result(long a, long b) {\n+        long x = toUint32(a);\n+        long y = toUint32(b);\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(x, y), givenUint32RangeFolded(a, b));\n+    }\n+\n+    \/**\n+     * If two parameters are constant, folding to constant node\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenTwoConstant() {\n+        return Math.unsignedMultiplyHigh(C1, C2);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenLeftZero(long b) {\n+        return Math.unsignedMultiplyHigh(0, b);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenRightZero(long a) {\n+        return Math.unsignedMultiplyHigh(a, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMUL_HI_L, \"1\"})\n+    public long givenTwoLong(long a, long b) {\n+        return Math.unsignedMultiplyHigh(a, b);\n+    }\n+\n+    \/**\n+     * Both operands are in [0, 0xffffffff] so high word is always zero.\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenUint32RangeFolded(long a, long b) {\n+        long x = toUint32(a);\n+        long y = toUint32(b);\n+        return Math.unsignedMultiplyHigh(x, y);\n+    }\n+\n+    @ForceInline\n+    private static long toUint32(long v) {\n+        return v & 0xffffffffL;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/UMulHiLNodeValueTests.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -1476,0 +1476,10 @@\n+    public static final String MUL_HI_L = PREFIX + \"MUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HI_L, \"MulHiL\");\n+    }\n+\n+    public static final String UMUL_HI_L = PREFIX + \"UMUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMUL_HI_L, \"UMulHiL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -248,1 +248,5 @@\n-        \/\/ TODO: Math and other classes.\n+        \/\/ ------------ Math -------------\n+        ops.add(Expression.make(LONGS, \"Math.multiplyHigh(\", LONGS, \",\", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Math.unsignedMultiplyHigh(\", LONGS, \",\", LONGS, \")\"));\n+\n+        \/\/ TODO: rest of Math and other classes.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Operations.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}