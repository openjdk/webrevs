{"files":[{"patch":"@@ -25,0 +25,1 @@\n+#include \"jni_md.h\"\n@@ -32,0 +33,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -36,0 +38,2 @@\n+#include <cstdint>\n+#include <type_traits>\n@@ -619,0 +623,12 @@\n+  \/\/ If the 64-bit product cannot overflow and its sign is known, the result is constant.\n+  const IntegerTypeMultiplication<jlong> multiplication(longType1, longType2);\n+  if (!multiplication.does_overflow()) {\n+    const TypeLong* result = multiplication.compute()->is_long();\n+    if (result->_lo >= 0) {\n+      return TypeLong::ZERO;\n+    }\n+    if (result->_hi < 0) {\n+      return TypeLong::MINUS_1;\n+    }\n+  }\n+\n@@ -638,0 +654,1 @@\n+  const int widen = MIN2(longType1->_widen, longType2->_widen);\n@@ -641,2 +658,8 @@\n-    jlong highResult = multiply_high_unsigned(longType1->get_con(), longType2->get_con());\n-    return TypeLong::make(highResult);\n+    julong highResult = multiply_high_unsigned(longType1->get_con(), longType2->get_con());\n+    TypeIntPrototype<jlong, julong> proto{{min_jlong, max_jlong}, {highResult, highResult}, {0, 0}};\n+    return TypeLong::make_or_top(proto, widen);\n+  }\n+\n+  \/\/ If both operands are within the unsigned 32-bit range, the upper 64 bits of the 128-bit product are always zero.\n+  if (longType1->_uhi <= max_juint && longType2->_uhi <= max_juint) {\n+    return TypeLong::ZERO;\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @summary Test that Value method of NulHiLNode is working as expected.\n+ * @summary Test that Value method of MulHiLNode is working as expected.\n@@ -48,1 +48,1 @@\n-            \"givenTwoConstant\", \"givenLeftZero\",\n+            \"givenConstants\", \"givenLeftZero\",\n@@ -51,1 +51,1 @@\n-    public void run() {\n+    public void runWithLongInputs() {\n@@ -57,4 +57,4 @@\n-        assertResult(0, 0);\n-        assertResult(aLong, bLong);\n-        assertResult(minLong, minLong);\n-        assertResult(maxLong, maxLong);\n+        assertLongInputsResult(0, 0);\n+        assertLongInputsResult(aLong, bLong);\n+        assertLongInputsResult(minLong, minLong);\n+        assertLongInputsResult(maxLong, maxLong);\n@@ -64,2 +64,2 @@\n-    public void assertResult(long a, long b) {\n-        Asserts.assertEquals(Math.multiplyHigh(C1, C2), givenTwoConstant());\n+    public void assertLongInputsResult(long a, long b) {\n+        Asserts.assertEquals(Math.multiplyHigh(C1, C2), givenConstants());\n@@ -71,0 +71,15 @@\n+    @Run(test = {\n+            \"givenNoOverflowPositiveInt\", \"givenNoOverflowNegativeInt\"\n+    })\n+    public void runWithIntInputs() {\n+        assertIntInputsResult(LONGS.next(), LONGS.next());\n+    }\n+\n+    @DontCompile\n+    public void assertIntInputsResult(long a, long b) {\n+        long x = nonZeroPositiveInt(a);\n+        long y = (a * b > 0) ? nonZeroPositiveInt(b) : negativeInt(b);\n+        long expected = Math.multiplyHigh(x, y);\n+        Asserts.assertEquals(expected, (a * b > 0) ? givenNoOverflowPositiveInt(x, y) : givenNoOverflowNegativeInt(x, y));\n+    }\n+\n@@ -75,3 +90,2 @@\n-    @IR(failOn = {IRNode.MUL_HI_L})\n-    @IR(counts = {IRNode.CON_L, \"1\"})\n-    public long givenTwoConstant() {\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenConstants() {\n@@ -85,2 +99,1 @@\n-    @IR(failOn = {IRNode.MUL_HI_L})\n-    @IR(counts = {IRNode.CON_L, \"1\"})\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n@@ -95,2 +108,1 @@\n-    @IR(failOn = {IRNode.MUL_HI_L})\n-    @IR(counts = {IRNode.CON_L, \"1\"})\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n@@ -106,0 +118,33 @@\n+\n+    \/**\n+     * Product is always non-negative and fits into 64 bits -> high word is zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenNoOverflowPositiveInt(long a, long b) {\n+        long x = nonZeroPositiveInt(a);\n+        long y = nonZeroPositiveInt(b);\n+        return Math.multiplyHigh(x, y);\n+    }\n+\n+    \/**\n+     * Product is always negative (non-negative * negative) and fits into 64 bits -> high word is -1\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenNoOverflowNegativeInt(long a, long b) {\n+        long x = nonZeroPositiveInt(a);\n+        long y = negativeInt(b);\n+        return Math.multiplyHigh(x, y);\n+    }\n+\n+    @ForceInline\n+    private static long nonZeroPositiveInt(long v) {\n+        return (v & 0x7fffffffL) + 1L;\n+    }\n+\n+    @ForceInline\n+    private static long negativeInt(long v) {\n+        return -((v & 0x7fffffffL) + 1L);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/MulHiLNodeValueTests.java","additions":61,"deletions":16,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -63,0 +63,5 @@\n+    @Run(test = \"givenUint32RangeFolded\")\n+    public void runWithUint32Inputs() {\n+        assertUint32Result(LONGS.next(), LONGS.next());\n+    }\n+\n@@ -71,0 +76,7 @@\n+    @DontCompile\n+    public void assertUint32Result(long a, long b) {\n+        long x = toUint32(a);\n+        long y = toUint32(b);\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(x, y), givenUint32RangeFolded(a, b));\n+    }\n+\n@@ -106,0 +118,17 @@\n+\n+    \/**\n+     * Both operands are in [0, 0xffffffff] so high word is always zero.\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenUint32RangeFolded(long a, long b) {\n+        long x = toUint32(a);\n+        long y = toUint32(b);\n+        return Math.unsignedMultiplyHigh(x, y);\n+    }\n+\n+    @ForceInline\n+    private static long toUint32(long v) {\n+        return v & 0xffffffffL;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/UMulHiLNodeValueTests.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1476,0 +1476,10 @@\n+    public static final String MUL_HI_L = PREFIX + \"MUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HI_L, \"MulHiL\");\n+    }\n+\n+    public static final String UMUL_HI_L = PREFIX + \"UMUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMUL_HI_L, \"UMulHiL\");\n+    }\n+\n@@ -1531,10 +1541,0 @@\n-    public static final String MUL_HI_L = PREFIX + \"MUL_HI_L\" + POSTFIX;\n-    static {\n-        superWordNodes(MUL_HI_L, \"MulHiL\");\n-    }\n-\n-    public static final String UMUL_HI_L = PREFIX + \"UMUL_HI_L\" + POSTFIX;\n-    static {\n-        superWordNodes(UMUL_HI_L, \"UMulHiL\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}