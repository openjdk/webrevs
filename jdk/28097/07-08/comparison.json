{"files":[{"patch":"@@ -25,1 +25,0 @@\n-#include \"jni_md.h\"\n@@ -39,3 +38,0 @@\n-#include <cstdint>\n-#include <type_traits>\n-\n@@ -601,0 +597,17 @@\n+template <typename T>\n+static const TypeLong* range_fold(const T t1_lo, const T t1_hi, const T t2_lo, const T t2_hi, const int widen) {\n+  auto multiply = [](const T lo, const T hi) -> T {\n+    return std::is_signed<T>::value ? multiply_high_signed(lo, hi) : multiply_high_unsigned(lo, hi);\n+  };\n+  auto make = [](T lo, T hi, int widen) -> const TypeLong* {\n+    return std::is_signed<T>::value ? TypeLong::make(lo, hi, widen) : TypeLong::make_unsigned(lo, hi, widen);\n+  };\n+  T p00 = multiply(t1_lo, t2_lo);\n+  T p01 = multiply(t1_lo, t2_hi);\n+  T p10 = multiply(t1_hi, t2_lo);\n+  T p11 = multiply(t1_hi, t2_hi);\n+  T lo = MIN4(p00, p01, p10, p11);\n+  T hi = MAX4(p00, p01, p10, p11);\n+  return make(lo, hi, widen);\n+}\n+\n@@ -604,1 +617,0 @@\n-\n@@ -609,4 +621,0 @@\n-  \/\/ Either input is ZERO, the result always ZERO\n-  if (t1 == TypeLong::ZERO || t2 == TypeLong::ZERO) {\n-    return TypeLong::ZERO;\n-  }\n@@ -616,20 +624,3 @@\n-\n-  \/\/ Both are constant, directly compute the result.\n-  if (longType1->is_con() && longType2->is_con()) {\n-    jlong highResult = multiply_high_signed(longType1->get_con(), longType2->get_con());\n-    return TypeLong::make(highResult);\n-  }\n-\n-  \/\/ If the 64-bit result cannot overflow and its sign is known, the result is constant.\n-  const IntegerTypeMultiplication<jlong> multiplication(longType1, longType2);\n-  if (!multiplication.does_overflow()) {\n-    const TypeLong* result = multiplication.compute()->is_long();\n-    if (result->_lo >= 0) {\n-      return TypeLong::ZERO;\n-    }\n-    if (result->_hi < 0) {\n-      return TypeLong::MINUS_1;\n-    }\n-  }\n-\n-  return bottom_type();\n+  return range_fold<jlong>(longType1->_lo, longType1->_hi,\n+                           longType2->_lo, longType2->_hi,\n+                           MIN2(longType1->_widen, longType2->_widen));\n@@ -641,1 +632,0 @@\n-\n@@ -646,4 +636,0 @@\n-  \/\/ Either input is ZERO, the result always ZERO\n-  if (t1 == TypeLong::ZERO || t2 == TypeLong::ZERO) {\n-    return TypeLong::ZERO;\n-  }\n@@ -654,13 +640,7 @@\n-  \/\/ Both are constant, directly compute the result.\n-  if (longType1->is_con() && longType2->is_con()) {\n-    julong highResult = multiply_high_unsigned(longType1->get_con(), longType2->get_con());\n-    return TypeLong::make_unsigned(highResult);\n-  }\n-\n-  \/\/ Range-based fold: if both inputs fit in 32-bit unsigned, high word is guaranteed zero.\n-  \/\/ If both inputs are within the unsigned 32-bit range, the upper 64 bits of the 128-bit result are always zero.\n-  if (longType1->_uhi <= max_juint && longType2->_uhi <= max_juint) {\n-    return TypeLong::ZERO;\n-  }\n-\n-  return bottom_type();\n+  julong p00 = multiply_high_unsigned(longType1->_ulo, longType2->_ulo);\n+  julong p01 = multiply_high_unsigned(longType1->_ulo, longType2->_uhi);\n+  julong p10 = multiply_high_unsigned(longType1->_uhi, longType2->_ulo);\n+  julong p11 = multiply_high_unsigned(longType1->_uhi, longType2->_uhi);\n+  julong lo = MIN4(p00, p01, p10, p11);\n+  julong hi = MAX4(p00, p01, p10, p11);\n+  return TypeLong::make_unsigned(lo, hi, MAX2(longType1->_widen, longType2->_widen));\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":27,"deletions":47,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jni_md.h\"\n@@ -45,1 +44,0 @@\n-#include \"utilities\/ostream.hpp\"\n@@ -47,0 +45,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -49,2 +48,0 @@\n-#include <type_traits>\n-\n@@ -1923,6 +1920,0 @@\n-const TypeLong* TypeLong::make_unsigned(julong ucon) {\n-  jlong con = ucon;\n-  return (new TypeLong(TypeIntPrototype<jlong, julong>{{con, con}, {ucon, ucon}, {~ucon, ucon}},\n-                       WidenMin, false))->hashcons()->is_long();\n-}\n-\n@@ -1934,0 +1925,5 @@\n+const TypeLong* TypeLong::make_unsigned(julong lo, julong hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return make_or_top(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {lo, hi}, {0, 0}}, widen)->is_long();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -878,1 +878,0 @@\n-  static const TypeLong* make_unsigned(julong ucon);\n@@ -881,0 +880,1 @@\n+  static const TypeLong* make_unsigned(julong lo, julong hi, int widen);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}