{"files":[{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"opto\/node.hpp\"\n@@ -33,0 +33,2 @@\n+#include \"opto\/type.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -595,4 +597,23 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  const Type *bot = bottom_type();\n-  return MulHiValue(t1, t2, bot);\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+\n+  \/\/ Either input is TOP ==> the result is TOP\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ Either input is ZERO, the result always ZERO\n+  if (t1 == TypeLong::ZERO || t2 == TypeLong::ZERO) {\n+    return TypeLong::ZERO;\n+  }\n+\n+  const TypeLong* longType1 = t1->is_long();\n+  const TypeLong* longType2 = t2->is_long();\n+\n+  \/\/ Both are constant, directly computed the result\n+  if (longType1->is_con() && longType2->is_con()) {\n+    jlong highResult = multiply_high_signed(longType1->get_con(), longType2->get_con());\n+    return TypeLong::make(highResult);\n+  }\n+\n+  return bottom_type();\n@@ -602,5 +623,2 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  const Type *bot = bottom_type();\n-  return MulHiValue(t1, t2, bot);\n-}\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n@@ -608,2 +626,0 @@\n-\/\/ A common routine used by UMulHiLNode and MulHiLNode\n-const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot) {\n@@ -611,2 +627,3 @@\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -614,4 +631,4 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  \/\/ Either input is ZERO, the result always ZERO\n+  if (t1 == TypeLong::ZERO || t2 == TypeLong::ZERO) {\n+    return TypeLong::ZERO;\n+  }\n@@ -619,2 +636,10 @@\n-  \/\/ It is not worth trying to constant fold this stuff!\n-  return TypeLong::LONG;\n+  const TypeLong* longType1 = t1->is_long();\n+  const TypeLong* longType2 = t2->is_long();\n+\n+  \/\/ Both are constant, directly computed the result\n+  if (longType1->is_con() && longType2->is_con()) {\n+    jlong highResult = multiply_high_unsigned(longType1->get_con(), longType2->get_con());\n+    return TypeLong::make(highResult);\n+  }\n+\n+  return bottom_type();\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":45,"deletions":20,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -184,1 +184,0 @@\n-const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot);\n@@ -194,1 +193,0 @@\n-  friend const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot);\n@@ -205,1 +203,0 @@\n-  friend const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8370196\n+ * @summary Test that Value method of NulHiLNode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.MulHiLNodeValueTests\n+ *\/\n+public class MulHiLNodeValueTests {\n+    private static final RestrictableGenerator<Long> LONGS = Generators.G.longs();\n+    private static final long C1 = LONGS.next(), C2 = LONGS.next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"givenTwoConstant\", \"givenLeftZero\",\n+            \"givenRightZero\", \"givenTwoLong\"\n+    })\n+    public void run() {\n+        long aLong = LONGS.next();\n+        long bLong = LONGS.next();\n+        long minLong = Long.MIN_VALUE;\n+        long maxLong = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(aLong, bLong);\n+        assertResult(minLong, minLong);\n+        assertResult(maxLong, maxLong);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEquals(Math.multiplyHigh(C1, C2), givenTwoConstant());\n+        Asserts.assertEquals(Math.multiplyHigh(0, b), givenLeftZero(b));\n+        Asserts.assertEquals(Math.multiplyHigh(a, 0), givenRightZero(a));\n+        Asserts.assertEquals(Math.multiplyHigh(a, b), givenTwoLong(a, b));\n+    }\n+\n+    \/**\n+     * If two parameters are constant, folding to constant node\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenTwoConstant() {\n+        return Math.multiplyHigh(C1, C2);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenLeftZero(long b) {\n+        return Math.multiplyHigh(0, b);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenRightZero(long a) {\n+        return Math.multiplyHigh(a, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HI_L, \"1\"})\n+    public long givenTwoLong(long a, long b) {\n+        return Math.multiplyHigh(a, b);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/MulHiLNodeValueTests.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8370196\n+ * @summary Test that Value method of UMulHiLNode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.UMulHiLNodeValueTests\n+ *\/\n+public class UMulHiLNodeValueTests {\n+    private static final RestrictableGenerator<Long> LONGS = Generators.G.longs();\n+    private static final long C1 = LONGS.next(), C2 = LONGS.next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"givenTwoConstant\", \"givenLeftZero\",\n+            \"givenRightZero\", \"givenTwoLong\"\n+    })\n+    public void run() {\n+        long aLong = LONGS.next();\n+        long bLong = LONGS.next();\n+        long minLong = Long.MIN_VALUE;\n+        long maxLong = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(aLong, bLong);\n+        assertResult(minLong, minLong);\n+        assertResult(maxLong, maxLong);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(C1, C2), givenTwoConstant());\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(0, b), givenLeftZero(b));\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(a, 0), givenRightZero(a));\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(a, b), givenTwoLong(a, b));\n+    }\n+\n+    \/**\n+     * If two parameters are constant, folding to constant node\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenTwoConstant() {\n+        return Math.unsignedMultiplyHigh(C1, C2);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenLeftZero(long b) {\n+        return Math.unsignedMultiplyHigh(0, b);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenRightZero(long a) {\n+        return Math.unsignedMultiplyHigh(a, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMUL_HI_L, \"1\"})\n+    public long givenTwoLong(long a, long b) {\n+        return Math.unsignedMultiplyHigh(a, b);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/UMulHiLNodeValueTests.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -1531,0 +1531,10 @@\n+    public static final String MUL_HI_L = PREFIX + \"MUL_HI_L\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_HI_L, \"MulHiL\");\n+    }\n+\n+    public static final String UMUL_HI_L = PREFIX + \"UMUL_HI_L\" + POSTFIX;\n+    static {\n+        superWordNodes(UMUL_HI_L, \"UMulHiL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -248,1 +248,5 @@\n-        \/\/ TODO: Math and other classes.\n+        \/\/ ------------ Math -------------\n+        ops.add(Expression.make(LONGS, \"Math.multiplyHigh(\", LONGS, \",\", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Math.unsignedMultiplyHigh(\", LONGS, \",\", LONGS, \")\"));\n+\n+        \/\/ TODO: other classes.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Operations.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}