{"files":[{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"opto\/node.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -33,0 +34,2 @@\n+#include \"opto\/type.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -594,5 +597,15 @@\n-const Type* MulHiLNode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  const Type *bot = bottom_type();\n-  return MulHiValue(t1, t2, bot);\n+template <typename T>\n+static const TypeLong* range_fold(const T t1_lo, const T t1_hi, const T t2_lo, const T t2_hi, const int widen) {\n+  auto multiply = [](const T lo, const T hi) -> T {\n+    return std::is_signed<T>::value ? multiply_high_signed(lo, hi) : multiply_high_unsigned(lo, hi);\n+  };\n+  auto make = [](T lo, T hi, int widen) -> const TypeLong* {\n+    return std::is_signed<T>::value ? TypeLong::make(lo, hi, widen) : TypeLong::make_unsigned(lo, hi, widen);\n+  };\n+  T p00 = multiply(t1_lo, t2_lo);\n+  T p01 = multiply(t1_lo, t2_hi);\n+  T p10 = multiply(t1_hi, t2_lo);\n+  T p11 = multiply(t1_hi, t2_hi);\n+  T lo = MIN4(p00, p01, p10, p11);\n+  T hi = MAX4(p00, p01, p10, p11);\n+  return make(lo, hi, widen);\n@@ -601,5 +614,13 @@\n-const Type* UMulHiLNode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  const Type *bot = bottom_type();\n-  return MulHiValue(t1, t2, bot);\n+const Type* MulHiLNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  \/\/ Either input is TOP ==> the result is TOP\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  const TypeLong* longType1 = t1->is_long();\n+  const TypeLong* longType2 = t2->is_long();\n+  return range_fold<jlong>(longType1->_lo, longType1->_hi,\n+                           longType2->_lo, longType2->_hi,\n+                           MIN2(longType1->_widen, longType2->_widen));\n@@ -608,2 +629,3 @@\n-\/\/ A common routine used by UMulHiLNode and MulHiLNode\n-const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot) {\n+const Type* UMulHiLNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n@@ -611,2 +633,3 @@\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -614,4 +637,2 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  const TypeLong* longType1 = t1->is_long();\n+  const TypeLong* longType2 = t2->is_long();\n@@ -619,2 +640,7 @@\n-  \/\/ It is not worth trying to constant fold this stuff!\n-  return TypeLong::LONG;\n+  julong p00 = multiply_high_unsigned(longType1->_ulo, longType2->_ulo);\n+  julong p01 = multiply_high_unsigned(longType1->_ulo, longType2->_uhi);\n+  julong p10 = multiply_high_unsigned(longType1->_uhi, longType2->_ulo);\n+  julong p11 = multiply_high_unsigned(longType1->_uhi, longType2->_uhi);\n+  julong lo = MIN4(p00, p01, p10, p11);\n+  julong hi = MAX4(p00, p01, p10, p11);\n+  return TypeLong::make_unsigned(lo, hi, MAX2(longType1->_widen, longType2->_widen));\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":47,"deletions":21,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -184,2 +184,0 @@\n-const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot);\n-\n@@ -189,1 +187,1 @@\n-  MulHiLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n+  MulHiLNode(Node* in1, Node* in2) : Node(nullptr, in1, in2) {}\n@@ -192,1 +190,1 @@\n-  const Type *bottom_type() const { return TypeLong::LONG; }\n+  const Type* bottom_type() const { return TypeLong::LONG; }\n@@ -194,1 +192,0 @@\n-  friend const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot);\n@@ -200,1 +197,1 @@\n-  UMulHiLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n+  UMulHiLNode(Node* in1, Node* in2) : Node(nullptr, in1, in2) {}\n@@ -203,1 +200,1 @@\n-  const Type *bottom_type() const { return TypeLong::LONG; }\n+  const Type* bottom_type() const { return TypeLong::LONG; }\n@@ -205,1 +202,0 @@\n-  friend const Type* MulHiValue(const Type *t1, const Type *t2, const Type *bot);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"classfile\/vmSymbols.hpp\"\n@@ -32,1 +31,0 @@\n-#include \"memory\/oopFactory.hpp\"\n@@ -34,1 +32,0 @@\n-#include \"oops\/instanceKlass.hpp\"\n@@ -36,2 +33,0 @@\n-#include \"oops\/objArrayKlass.hpp\"\n-#include \"oops\/typeArrayKlass.hpp\"\n@@ -49,0 +44,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -50,1 +46,0 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n@@ -1930,0 +1925,5 @@\n+const TypeLong* TypeLong::make_unsigned(julong lo, julong hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return make_or_top(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {lo, hi}, {0, 0}}, widen)->is_long();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/handles.hpp\"\n@@ -881,0 +880,1 @@\n+  static const TypeLong* make_unsigned(julong lo, julong hi, int widen);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8370196\n+ * @summary Test that Value method of MulHiLNode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.MulHiLNodeValueTests\n+ *\/\n+public class MulHiLNodeValueTests {\n+    private static final RestrictableGenerator<Long> LONGS = Generators.G.longs();\n+    private static final long C1 = LONGS.next(), C2 = LONGS.next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"givenConstants\", \"givenLeftZero\",\n+            \"givenRightZero\", \"givenTwoLong\"\n+    })\n+    public void runWithLongInputs() {\n+        long aLong = LONGS.next();\n+        long bLong = LONGS.next();\n+        long minLong = Long.MIN_VALUE;\n+        long maxLong = Long.MAX_VALUE;\n+\n+        assertLongInputsResult(0, 0);\n+        assertLongInputsResult(aLong, bLong);\n+        assertLongInputsResult(minLong, minLong);\n+        assertLongInputsResult(maxLong, maxLong);\n+    }\n+\n+    @DontCompile\n+    public void assertLongInputsResult(long a, long b) {\n+        Asserts.assertEquals(Math.multiplyHigh(C1, C2), givenConstants());\n+        Asserts.assertEquals(Math.multiplyHigh(0, b), givenLeftZero(b));\n+        Asserts.assertEquals(Math.multiplyHigh(a, 0), givenRightZero(a));\n+        Asserts.assertEquals(Math.multiplyHigh(a, b), givenTwoLong(a, b));\n+    }\n+\n+    @Run(test = {\n+            \"givenNoOverflowPositiveInt\", \"givenNoOverflowNegativeInt\"\n+    })\n+    public void runWithIntInputs() {\n+        assertIntInputsResult(LONGS.next(), LONGS.next());\n+    }\n+\n+    @DontCompile\n+    public void assertIntInputsResult(long a, long b) {\n+        long x = nonZeroPositiveInt(a);\n+        long y = (a * b > 0) ? nonZeroPositiveInt(b) : negativeInt(b);\n+        long expected = Math.multiplyHigh(x, y);\n+        Asserts.assertEquals(expected, (a * b > 0) ? givenNoOverflowPositiveInt(x, y) : givenNoOverflowNegativeInt(x, y));\n+    }\n+\n+    \/**\n+     * If two parameters are constant, folding to constant node\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenConstants() {\n+        return Math.multiplyHigh(C1, C2);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenLeftZero(long b) {\n+        return Math.multiplyHigh(0, b);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenRightZero(long a) {\n+        return Math.multiplyHigh(a, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HI_L, \"1\"})\n+    public long givenTwoLong(long a, long b) {\n+        return Math.multiplyHigh(a, b);\n+    }\n+\n+    \/**\n+     * Product is always non-negative and fits into 64 bits -> high word is zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenNoOverflowPositiveInt(long a, long b) {\n+        long x = nonZeroPositiveInt(a);\n+        long y = nonZeroPositiveInt(b);\n+        return Math.multiplyHigh(x, y);\n+    }\n+\n+    \/**\n+     * Product is always negative (non-negative * negative) and fits into 64 bits -> high word is -1\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.MUL_HI_L}, counts = {IRNode.CON_L, \"1\"})\n+    public long givenNoOverflowNegativeInt(long a, long b) {\n+        long x = nonZeroPositiveInt(a);\n+        long y = negativeInt(b);\n+        return Math.multiplyHigh(x, y);\n+    }\n+\n+    @ForceInline\n+    private static long nonZeroPositiveInt(long v) {\n+        return (v & 0x7fffffffL) + 1L;\n+    }\n+\n+    @ForceInline\n+    private static long negativeInt(long v) {\n+        return -((v & 0x7fffffffL) + 1L);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/MulHiLNodeValueTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8370196\n+ * @summary Test that Value method of UMulHiLNode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.UMulHiLNodeValueTests\n+ *\/\n+public class UMulHiLNodeValueTests {\n+    private static final RestrictableGenerator<Long> LONGS = Generators.G.longs();\n+    private static final long C1 = LONGS.next(), C2 = LONGS.next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"givenTwoConstant\", \"givenLeftZero\",\n+            \"givenRightZero\", \"givenTwoLong\"\n+    })\n+    public void run() {\n+        long aLong = LONGS.next();\n+        long bLong = LONGS.next();\n+        long minLong = Long.MIN_VALUE;\n+        long maxLong = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(aLong, bLong);\n+        assertResult(minLong, minLong);\n+        assertResult(maxLong, maxLong);\n+    }\n+\n+    @Run(test = \"givenUint32RangeFolded\")\n+    public void runWithUint32Inputs() {\n+        assertUint32Result(LONGS.next(), LONGS.next());\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(C1, C2), givenTwoConstant());\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(0, b), givenLeftZero(b));\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(a, 0), givenRightZero(a));\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(a, b), givenTwoLong(a, b));\n+    }\n+\n+    @DontCompile\n+    public void assertUint32Result(long a, long b) {\n+        long x = toUint32(a);\n+        long y = toUint32(b);\n+        Asserts.assertEquals(Math.unsignedMultiplyHigh(x, y), givenUint32RangeFolded(a, b));\n+    }\n+\n+    \/**\n+     * If two parameters are constant, folding to constant node\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenTwoConstant() {\n+        return Math.unsignedMultiplyHigh(C1, C2);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenLeftZero(long b) {\n+        return Math.unsignedMultiplyHigh(0, b);\n+    }\n+\n+    \/**\n+     * One of parameters is zero, the result always zero\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenRightZero(long a) {\n+        return Math.unsignedMultiplyHigh(a, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMUL_HI_L, \"1\"})\n+    public long givenTwoLong(long a, long b) {\n+        return Math.unsignedMultiplyHigh(a, b);\n+    }\n+\n+    \/**\n+     * Both operands are in [0, 0xffffffff] so high word is always zero.\n+     *\/\n+    @Test\n+    @IR(failOn = {IRNode.UMUL_HI_L})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    public long givenUint32RangeFolded(long a, long b) {\n+        long x = toUint32(a);\n+        long y = toUint32(b);\n+        return Math.unsignedMultiplyHigh(x, y);\n+    }\n+\n+    @ForceInline\n+    private static long toUint32(long v) {\n+        return v & 0xffffffffL;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/UMulHiLNodeValueTests.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -1476,0 +1476,10 @@\n+    public static final String MUL_HI_L = PREFIX + \"MUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HI_L, \"MulHiL\");\n+    }\n+\n+    public static final String UMUL_HI_L = PREFIX + \"UMUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMUL_HI_L, \"UMulHiL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -248,1 +248,5 @@\n-        \/\/ TODO: Math and other classes.\n+        \/\/ ------------ Math -------------\n+        ops.add(Expression.make(LONGS, \"Math.multiplyHigh(\", LONGS, \",\", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Math.unsignedMultiplyHigh(\", LONGS, \",\", LONGS, \")\"));\n+\n+        \/\/ TODO: rest of Math and other classes.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Operations.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}