{"files":[{"patch":"@@ -679,54 +679,19 @@\n-void G1BarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {\n-  assert(node->Opcode() == Op_CastP2X, \"ConvP2XNode required\");\n-  assert(node->outcnt() <= 2, \"expects 1 or 2 users: Xor and URShift nodes\");\n-  \/\/ It could be only one user, URShift node, in Object.clone() intrinsic\n-  \/\/ but the new allocation is passed to arraycopy stub and it could not\n-  \/\/ be scalar replaced. So we don't check the case.\n-\n-  \/\/ An other case of only one user (Xor) is when the value check for NULL\n-  \/\/ in G1 post barrier is folded after CCP so the code which used URShift\n-  \/\/ is removed.\n-\n-  \/\/ Take Region node before eliminating post barrier since it also\n-  \/\/ eliminates CastP2X node when it has only one user.\n-  Node* this_region = node->in(0);\n-  assert(this_region != NULL, \"\");\n-\n-  \/\/ Remove G1 post barrier.\n-\n-  \/\/ Search for CastP2X->Xor->URShift->Cmp path which\n-  \/\/ checks if the store done to a different from the value's region.\n-  \/\/ And replace Cmp with #0 (false) to collapse G1 post barrier.\n-  Node* xorx = node->find_out_with(Op_XorX);\n-  if (xorx != NULL) {\n-    Node* shift = xorx->unique_out();\n-    Node* cmpx = shift->unique_out();\n-    assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n-    cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n-    \"missing region check in G1 post barrier\");\n-    macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n-\n-    \/\/ Remove G1 pre barrier.\n-\n-    \/\/ Search \"if (marking != 0)\" check and set it to \"false\".\n-    \/\/ There is no G1 pre barrier if previous stored value is NULL\n-    \/\/ (for example, after initialization).\n-    if (this_region->is_Region() && this_region->req() == 3) {\n-      int ind = 1;\n-      if (!this_region->in(ind)->is_IfFalse()) {\n-        ind = 2;\n-      }\n-      if (this_region->in(ind)->is_IfFalse() &&\n-          this_region->in(ind)->in(0)->Opcode() == Op_If) {\n-        Node* bol = this_region->in(ind)->in(0)->in(1);\n-        assert(bol->is_Bool(), \"\");\n-        cmpx = bol->in(1);\n-        if (bol->as_Bool()->_test._test == BoolTest::ne &&\n-            cmpx->is_Cmp() && cmpx->in(2) == macro->intcon(0) &&\n-            cmpx->in(1)->is_Load()) {\n-          Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n-          const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-          if (adr->is_AddP() && adr->in(AddPNode::Base) == macro->top() &&\n-              adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n-              adr->in(AddPNode::Offset) == macro->MakeConX(marking_offset)) {\n-            macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+bool G1BarrierSetC2::is_g1_pre_val_load(Node* n) {\n+  if (n->is_Load() && n->as_Load()->has_pinned_control_dependency()) {\n+    \/\/ Make sure the only users of it are: CmpP, StoreP, and a call to write_ref_field_pre_entry\n+\n+    \/\/ Skip possible decode\n+    if (n->outcnt() == 1 && n->unique_out()->is_DecodeN()) {\n+      n = n->unique_out();\n+    }\n+\n+    if (n->outcnt() == 3) {\n+      int found = 0;\n+      for (SimpleDUIterator iter(n); iter.has_next(); iter.next()) {\n+        Node* use = iter.get();\n+        if (use->is_Cmp() || use->is_Store()) {\n+          ++found;\n+        } else if (use->is_CallLeaf()) {\n+          CallLeafNode* call = use->as_CallLeaf();\n+          if (strcmp(call->_name, \"write_ref_field_pre_entry\") == 0) {\n+            ++found;\n@@ -736,0 +701,3 @@\n+      if (found == 3) {\n+        return true;\n+      }\n@@ -737,0 +705,11 @@\n+  }\n+  return false;\n+}\n+\n+bool G1BarrierSetC2::is_gc_pre_barrier_node(Node *node) const {\n+  return is_g1_pre_val_load(node);\n+}\n+\n+void G1BarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {\n+  if (is_g1_pre_val_load(node)) {\n+    macro->replace_node(node, macro->zerocon(node->as_Load()->bottom_type()->basic_type()));\n@@ -738,15 +717,78 @@\n-    assert(!use_ReduceInitialCardMarks(), \"can only happen with card marking\");\n-    \/\/ This is a G1 post barrier emitted by the Object.clone() intrinsic.\n-    \/\/ Search for the CastP2X->URShiftX->AddP->LoadB->Cmp path which checks if the card\n-    \/\/ is marked as young_gen and replace the Cmp with 0 (false) to collapse the barrier.\n-    Node* shift = node->find_out_with(Op_URShiftX);\n-    assert(shift != NULL, \"missing G1 post barrier\");\n-    Node* addp = shift->unique_out();\n-    Node* load = addp->find_out_with(Op_LoadB);\n-    assert(load != NULL, \"missing G1 post barrier\");\n-    Node* cmpx = load->unique_out();\n-    assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n-           cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n-           \"missing card value check in G1 post barrier\");\n-    macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n-    \/\/ There is no G1 pre barrier in this case\n+    assert(node->Opcode() == Op_CastP2X, \"ConvP2XNode required\");\n+    assert(node->outcnt() <= 2, \"expects 1 or 2 users: Xor and URShift nodes\");\n+    \/\/ It could be only one user, URShift node, in Object.clone() intrinsic\n+    \/\/ but the new allocation is passed to arraycopy stub and it could not\n+    \/\/ be scalar replaced. So we don't check the case.\n+\n+    \/\/ An other case of only one user (Xor) is when the value check for NULL\n+    \/\/ in G1 post barrier is folded after CCP so the code which used URShift\n+    \/\/ is removed.\n+\n+    \/\/ Take Region node before eliminating post barrier since it also\n+    \/\/ eliminates CastP2X node when it has only one user.\n+    Node* this_region = node->in(0);\n+    assert(this_region != NULL, \"\");\n+\n+    \/\/ Remove G1 post barrier.\n+\n+    \/\/ Search for CastP2X->Xor->URShift->Cmp path which\n+    \/\/ checks if the store done to a different from the value's region.\n+    \/\/ And replace Cmp with #0 (false) to collapse G1 post barrier.\n+    Node* xorx = node->find_out_with(Op_XorX);\n+    if (xorx != NULL) {\n+      Node* shift = xorx->unique_out();\n+      Node* cmpx = shift->unique_out();\n+      assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n+          cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n+          \"missing region check in G1 post barrier\");\n+      macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+\n+      \/\/ Remove G1 pre barrier.\n+\n+      \/\/ Search \"if (marking != 0)\" check and set it to \"false\".\n+      \/\/ There is no G1 pre barrier if previous stored value is NULL\n+      \/\/ (for example, after initialization).\n+      if (this_region->is_Region() && this_region->req() == 3) {\n+        int ind = 1;\n+        if (!this_region->in(ind)->is_IfFalse()) {\n+          ind = 2;\n+        }\n+        if (this_region->in(ind)->is_IfFalse() &&\n+            this_region->in(ind)->in(0)->Opcode() == Op_If) {\n+          Node* bol = this_region->in(ind)->in(0)->in(1);\n+          assert(bol->is_Bool(), \"\");\n+          cmpx = bol->in(1);\n+          if (bol->as_Bool()->_test._test == BoolTest::ne &&\n+              cmpx->is_Cmp() && cmpx->in(2) == macro->intcon(0) &&\n+              cmpx->in(1)->is_Load()) {\n+            Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n+            const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n+            if (adr->is_AddP() && adr->in(AddPNode::Base) == macro->top() &&\n+                adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n+                adr->in(AddPNode::Offset) == macro->MakeConX(marking_offset)) {\n+              macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+            }\n+          }\n+        }\n+      }\n+    } else {\n+      assert(!use_ReduceInitialCardMarks(), \"can only happen with card marking\");\n+      \/\/ This is a G1 post barrier emitted by the Object.clone() intrinsic.\n+      \/\/ Search for the CastP2X->URShiftX->AddP->LoadB->Cmp path which checks if the card\n+      \/\/ is marked as young_gen and replace the Cmp with 0 (false) to collapse the barrier.\n+      Node* shift = node->find_out_with(Op_URShiftX);\n+      assert(shift != NULL, \"missing G1 post barrier\");\n+      Node* addp = shift->unique_out();\n+      Node* load = addp->find_out_with(Op_LoadB);\n+      assert(load != NULL, \"missing G1 post barrier\");\n+      Node* cmpx = load->unique_out();\n+      assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n+          cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n+          \"missing card value check in G1 post barrier\");\n+      macro->replace_node(cmpx, macro->makecon(TypeInt::CC_EQ));\n+      \/\/ There is no G1 pre barrier in this case\n+    }\n+    \/\/ Now CastP2X can be removed since it is used only on dead path\n+    \/\/ which currently still alive until igvn optimize it.\n+    assert(node->outcnt() == 0 || node->unique_out()->Opcode() == Op_URShiftX, \"\");\n+    macro->replace_node(node, macro->top());\n@@ -754,4 +796,0 @@\n-  \/\/ Now CastP2X can be removed since it is used only on dead path\n-  \/\/ which currently still alive until igvn optimize it.\n-  assert(node->outcnt() == 0 || node->unique_out()->Opcode() == Op_URShiftX, \"\");\n-  macro->replace_node(node, macro->top());\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":111,"deletions":73,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+  static bool is_g1_pre_val_load(Node* n);\n@@ -94,0 +95,1 @@\n+  virtual bool is_gc_pre_barrier_node(Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+  virtual bool is_gc_pre_barrier_node(Node* node) const { return false; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -719,0 +719,5 @@\n+\n+bool ShenandoahBarrierSetC2::is_gc_pre_barrier_node(Node* node) const {\n+  return is_shenandoah_wb_pre_call(node);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+  virtual bool is_gc_pre_barrier_node(Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,3 +61,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-#include \"gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp\"\n-#endif\n@@ -585,0 +582,1 @@\n+    BarrierSetC2 *bs = BarrierSet::barrier_set()->barrier_set_c2();\n@@ -601,2 +599,1 @@\n-          if (!n->is_Store() && n->Opcode() != Op_CastP2X\n-              SHENANDOAHGC_ONLY(&& (!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n))) ) {\n+          if (!n->is_Store() && n->Opcode() != Op_CastP2X && !bs->is_gc_pre_barrier_node(n)) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+  Node* zerocon(BasicType bt)   const { return _igvn.zerocon(bt); }\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1212,3 +1212,0 @@\n-  if (has_pinned_control_dependency()) {\n-    return this;\n-  }\n@@ -1232,1 +1229,5 @@\n-    return value;\n+    if (!has_pinned_control_dependency() || value->is_Con()) {\n+      return value;\n+    } else {\n+      return this;\n+    }\n@@ -1235,0 +1236,3 @@\n+  if (has_pinned_control_dependency()) {\n+    return this;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8295066\n+ * @summary Test various scalarization scenarios\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestScalarReplacement\n+ *\/\n+public class TestScalarReplacement {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+    static class X1 {\n+        int x = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    public static int test1() {\n+        X1[] array = new X1[1];\n+        array[0] = new X1();\n+        return array[0].x;\n+    }\n+\n+    static class X2 {\n+        int x = 42;\n+        int y = 43;\n+        public int hash() { return x + y; }\n+    }\n+    static final class ObjectWrapper {\n+        public Object obj;\n+\n+        public ObjectWrapper(Object obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    public static int test2(X2 obj) {\n+        ObjectWrapper val = new ObjectWrapper(obj);\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                val.obj = val.obj;\n+            }\n+        }\n+        return ((X2)val.obj).hash();\n+    }\n+\n+    @Run(test = \"test2\")\n+    public static void test2_runner() {\n+        X2 obj = new X2();\n+        test2(obj);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestScalarReplacement.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}