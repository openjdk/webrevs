{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -101,1 +100,1 @@\n-        String pref = GetPropertyAction.privilegedGetProperty(\"http.auth.preference\");\n+        String pref = System.getProperty(\"http.auth.preference\");\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationHeader.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n@@ -70,4 +68,1 @@\n-    @SuppressWarnings(\"removal\")\n-    static final boolean serializeAuth = java.security.AccessController.doPrivileged(\n-            new sun.security.action.GetBooleanAction(\n-                \"http.auth.serializeRequests\")).booleanValue();\n+    static final boolean serializeAuth = Boolean.getBoolean(\"http.auth.serializeRequests\");\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationInfo.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-import java.io.IOException;\n-import java.io.OutputStream;\n@@ -39,1 +37,0 @@\n-import java.util.Objects;\n@@ -54,3 +51,0 @@\n-    @java.io.Serial\n-    private static final long serialVersionUID = 100L;\n-\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/BasicAuthentication.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import java.security.AccessController;\n@@ -41,1 +40,0 @@\n-import java.security.PrivilegedAction;\n@@ -45,1 +43,0 @@\n-import java.util.Collections;\n@@ -48,1 +45,0 @@\n-import java.util.Objects;\n@@ -70,3 +66,0 @@\n-    @java.io.Serial\n-    private static final long serialVersionUID = 100L;\n-\n@@ -113,4 +106,1 @@\n-        @SuppressWarnings(\"removal\")\n-        Boolean b = AccessController.doPrivileged(\n-            (PrivilegedAction<Boolean>) () -> NetProperties.getBoolean(compatPropName)\n-        );\n+        Boolean b = NetProperties.getBoolean(compatPropName);\n@@ -119,5 +109,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String secprops = AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> Security.getProperty(secPropName)\n-        );\n-\n+        String secprops = Security.getProperty(secPropName);\n@@ -125,1 +111,0 @@\n-\n@@ -129,4 +114,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String netprops = AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> NetProperties.get(enabledAlgPropName)\n-        );\n+        String netprops = NetProperties.get(enabledAlgPropName);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/DigestAuthentication.java","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.security.PrivilegedAction;\n@@ -40,1 +39,0 @@\n-import java.net.SocketPermission;\n@@ -50,1 +48,0 @@\n-import java.net.URLPermission;\n@@ -52,3 +49,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n-import java.security.PrivilegedActionException;\n@@ -84,1 +78,0 @@\n-import java.util.Properties;\n@@ -93,2 +86,0 @@\n-import sun.security.action.GetIntegerAction;\n-import sun.security.action.GetPropertyAction;\n@@ -181,2 +172,1 @@\n-     * backwards compatibility reasons rather than throwing a\n-     * SecurityException. For example, some applets set the\n+     * backwards compatibility reasons. For example, some applets set the\n@@ -225,6 +215,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private static String getNetProperty(String name) {\n-        PrivilegedAction<String> pa = () -> NetProperties.get(name);\n-        return AccessController.doPrivileged(pa);\n-    }\n-\n@@ -243,5 +227,3 @@\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n-        maxRedirects = GetIntegerAction.privilegedGetProperty(\n-                \"http.maxRedirects\", defaultmaxRedirects);\n-        version = props.getProperty(\"java.version\");\n-        String agent = props.getProperty(\"http.agent\");\n+        maxRedirects = Integer.getInteger(\"http.maxRedirects\", defaultmaxRedirects);\n+        version = System.getProperty(\"java.version\");\n+        String agent = System.getProperty(\"http.agent\");\n@@ -257,1 +239,1 @@\n-        String p = getNetProperty(\"jdk.http.auth.tunneling.disabledSchemes\");\n+        String p = NetProperties.get(\"jdk.http.auth.tunneling.disabledSchemes\");\n@@ -259,1 +241,1 @@\n-        p = getNetProperty(\"jdk.http.auth.proxying.disabledSchemes\");\n+        p = NetProperties.get(\"jdk.http.auth.proxying.disabledSchemes\");\n@@ -262,4 +244,2 @@\n-        validateProxy = Boolean.parseBoolean(\n-                props.getProperty(\"http.auth.digest.validateProxy\"));\n-        validateServer = Boolean.parseBoolean(\n-                props.getProperty(\"http.auth.digest.validateServer\"));\n+        validateProxy = Boolean.getBoolean(\"http.auth.digest.validateProxy\");\n+        validateServer = Boolean.getBoolean(\"http.auth.digest.validateServer\");\n@@ -267,3 +247,2 @@\n-        enableESBuffer = Boolean.parseBoolean(\n-                props.getProperty(\"sun.net.http.errorstream.enableBuffering\"));\n-        int esBufferTimeout = GetIntegerAction.privilegedGetProperty(\n+        enableESBuffer = Boolean.getBoolean(\"sun.net.http.errorstream.enableBuffering\");\n+        int esBufferTimeout = Integer.getInteger(\n@@ -276,1 +255,1 @@\n-        int esBufSize = GetIntegerAction.privilegedGetProperty(\n+        int esBufSize = Integer.getInteger(\n@@ -283,2 +262,1 @@\n-        allowRestrictedHeaders = Boolean.parseBoolean(\n-                props.getProperty(\"sun.net.http.allowRestrictedHeaders\"));\n+        allowRestrictedHeaders = Boolean.getBoolean(\"sun.net.http.allowRestrictedHeaders\");\n@@ -295,1 +273,1 @@\n-        String maxHeaderSizeStr = getNetProperty(\"jdk.http.maxHeaderSize\");\n+        String maxHeaderSizeStr = NetProperties.get(\"jdk.http.maxHeaderSize\");\n@@ -442,3 +420,0 @@\n-    \/* A permission converted from a URLPermission *\/\n-    private SocketPermission socketPermission;\n-\n@@ -465,1 +440,1 @@\n-     * privileged request password authentication\n+     * Calls Authenticator.requestPasswordAuthentication\n@@ -468,27 +443,21 @@\n-    @SuppressWarnings(\"removal\")\n-    private static PasswordAuthentication\n-    privilegedRequestPasswordAuthentication(\n-                            final Authenticator authenticator,\n-                            final String host,\n-                            final InetAddress addr,\n-                            final int port,\n-                            final String protocol,\n-                            final String prompt,\n-                            final String scheme,\n-                            final URL url,\n-                            final RequestorType authType) {\n-        return java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<>() {\n-                public PasswordAuthentication run() {\n-                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {\n-                        logger.finest(\"Requesting Authentication: host =\" + host + \" url = \" + url);\n-                    }\n-                    PasswordAuthentication pass = Authenticator.requestPasswordAuthentication(\n-                        authenticator, host, addr, port, protocol,\n-                        prompt, scheme, url, authType);\n-                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {\n-                        logger.finest(\"Authentication returned: \" + (pass != null ? pass.toString() : \"null\"));\n-                    }\n-                    return pass;\n-                }\n-            });\n+    private static PasswordAuthentication requestPassword(\n+            final Authenticator authenticator,\n+            final String host,\n+            final InetAddress addr,\n+            final int port,\n+            final String protocol,\n+            final String prompt,\n+            final String scheme,\n+            final URL url,\n+            final RequestorType authType) {\n+\n+        if (logger.isLoggable(PlatformLogger.Level.FINEST)) {\n+            logger.finest(\"Requesting Authentication: host =\" + host + \" url = \" + url);\n+        }\n+        PasswordAuthentication pass = Authenticator.requestPasswordAuthentication(\n+                authenticator, host, addr, port, protocol,\n+                prompt, scheme, url, authType);\n+        if (logger.isLoggable(PlatformLogger.Level.FINEST)) {\n+            logger.finest(\"Authentication returned: \" + (pass != null ? pass.toString() : \"null\"));\n+        }\n+        return pass;\n@@ -643,1 +612,0 @@\n-                checkURLFile();\n@@ -657,3 +625,1 @@\n-            if (reqHost == null ||\n-                (!reqHost.equalsIgnoreCase(host) && !checkSetHost()))\n-            {\n+            if (reqHost == null || !reqHost.equalsIgnoreCase(host)) {\n@@ -779,41 +745,0 @@\n-    private boolean checkSetHost() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager s = System.getSecurityManager();\n-        if (s != null) {\n-            String name = s.getClass().getName();\n-            if (name.equals(\"sun.plugin2.applet.AWTAppletSecurityManager\") ||\n-                name.equals(\"sun.plugin2.applet.FXAppletSecurityManager\") ||\n-                name.equals(\"com.sun.javaws.security.JavaWebStartSecurity\") ||\n-                name.equals(\"sun.plugin.security.ActivatorSecurityManager\"))\n-            {\n-                int CHECK_SET_HOST = -2;\n-                try {\n-                    s.checkConnect(url.toExternalForm(), CHECK_SET_HOST);\n-                } catch (SecurityException ex) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private void checkURLFile() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager s = System.getSecurityManager();\n-        if (s != null) {\n-            String name = s.getClass().getName();\n-            if (name.equals(\"sun.plugin2.applet.AWTAppletSecurityManager\") ||\n-                name.equals(\"sun.plugin2.applet.FXAppletSecurityManager\") ||\n-                name.equals(\"com.sun.javaws.security.JavaWebStartSecurity\") ||\n-                name.equals(\"sun.plugin.security.ActivatorSecurityManager\"))\n-            {\n-                int CHECK_SUBPATH = -3;\n-                try {\n-                    s.checkConnect(url.toExternalForm(), CHECK_SUBPATH);\n-                } catch (SecurityException ex) {\n-                    throw new SecurityException(\"denied access outside a permitted URL subpath\", ex);\n-                }\n-            }\n-        }\n-    }\n-\n@@ -925,1 +850,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -934,113 +858,2 @@\n-        if (instProxy instanceof sun.net.ApplicationProxy) {\n-            \/* Application set Proxies should not have access to cookies\n-             * in a secure environment unless explicitly allowed. *\/\n-            try {\n-                cookieHandler = CookieHandler.getDefault();\n-            } catch (SecurityException se) { \/* swallow exception *\/ }\n-        } else {\n-            cookieHandler = java.security.AccessController.doPrivileged(\n-                new java.security.PrivilegedAction<>() {\n-                public CookieHandler run() {\n-                    return CookieHandler.getDefault();\n-                }\n-            });\n-        }\n-        cacheHandler = java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<>() {\n-                public ResponseCache run() {\n-                return ResponseCache.getDefault();\n-            }\n-        });\n-    }\n-\n-    \/**\n-     * opens a stream allowing redirects only to the same host.\n-     *\/\n-    public static InputStream openConnectionCheckRedirects(URLConnection c)\n-        throws IOException\n-    {\n-        boolean redir;\n-        int redirects = 0;\n-        InputStream in;\n-        Authenticator a = null;\n-\n-        do {\n-            if (c instanceof HttpURLConnection) {\n-                ((HttpURLConnection) c).setInstanceFollowRedirects(false);\n-                if (a == null) {\n-                    a = ((HttpURLConnection) c).authenticator;\n-                }\n-            }\n-\n-            \/\/ We want to open the input stream before\n-            \/\/ getting headers, because getHeaderField()\n-            \/\/ et al swallow IOExceptions.\n-            in = c.getInputStream();\n-            redir = false;\n-\n-            if (c instanceof HttpURLConnection) {\n-                HttpURLConnection http = (HttpURLConnection) c;\n-                int stat = http.getResponseCode();\n-                if (stat >= 300 && stat <= 307 && stat != 306 &&\n-                        stat != HttpURLConnection.HTTP_NOT_MODIFIED) {\n-                    URL base = http.getURL();\n-                    String loc = http.getHeaderField(\"Location\");\n-                    URL target = null;\n-                    if (loc != null) {\n-                        target = newURL(base, loc);\n-                    }\n-                    http.disconnect();\n-                    if (target == null\n-                        || !base.getProtocol().equals(target.getProtocol())\n-                        || base.getPort() != target.getPort()\n-                        || !hostsEqual(base, target)\n-                        || redirects >= 5)\n-                    {\n-                        throw new SecurityException(\"illegal URL redirect\");\n-                    }\n-                    redir = true;\n-                    c = target.openConnection();\n-                    if (a != null && c instanceof HttpURLConnection) {\n-                        ((HttpURLConnection)c).setAuthenticator(a);\n-                    }\n-                    redirects++;\n-                }\n-            }\n-        } while (redir);\n-        return in;\n-    }\n-\n-\n-    \/\/\n-    \/\/ Same as java.net.URL.hostsEqual\n-    \/\/\n-    @SuppressWarnings(\"removal\")\n-    private static boolean hostsEqual(URL u1, URL u2) {\n-        final String h1 = u1.getHost();\n-        final String h2 = u2.getHost();\n-\n-        if (h1 == null) {\n-            return h2 == null;\n-        } else if (h2 == null) {\n-            return false;\n-        } else if (h1.equalsIgnoreCase(h2)) {\n-            return true;\n-        }\n-        \/\/ Have to resolve addresses before comparing, otherwise\n-        \/\/ names like tachyon and tachyon.eng would compare different\n-        final boolean result[] = {false};\n-\n-        java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<>() {\n-                public Void run() {\n-                try {\n-                    InetAddress a1 = InetAddress.getByName(h1);\n-                    InetAddress a2 = InetAddress.getByName(h2);\n-                    result[0] = a1.equals(a2);\n-                } catch(UnknownHostException | SecurityException e) {\n-                }\n-                return null;\n-            }\n-        });\n-\n-        return result[0];\n+        cookieHandler = CookieHandler.getDefault();\n+        cacheHandler = ResponseCache.getDefault();\n@@ -1076,28 +889,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private String getHostAndPort(URL url) {\n-        String host = url.getHost();\n-        final String hostarg = host;\n-        try {\n-            \/\/ lookup hostname and use IP address if available\n-            host = AccessController.doPrivileged(\n-                new PrivilegedExceptionAction<>() {\n-                    public String run() throws IOException {\n-                            InetAddress addr = InetAddress.getByName(hostarg);\n-                            return addr.getHostAddress();\n-                    }\n-                }\n-            );\n-        } catch (PrivilegedActionException e) {}\n-        int port = url.getPort();\n-        if (port == -1) {\n-            String scheme = url.getProtocol();\n-            if (\"http\".equals(scheme)) {\n-                return host + \":80\";\n-            } else { \/\/ scheme must be https\n-                return host + \":443\";\n-            }\n-        }\n-        return host + \":\" + Integer.toString(port);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n@@ -1113,60 +898,1 @@\n-        SocketPermission p = URLtoSocketPermission(this.url);\n-        if (p != null) {\n-            try {\n-                AccessController.doPrivilegedWithCombiner(\n-                    new PrivilegedExceptionAction<>() {\n-                        public Void run() throws IOException {\n-                            plainConnect0();\n-                            return null;\n-                        }\n-                    }, null, p\n-                );\n-            } catch (PrivilegedActionException e) {\n-                    throw (IOException) e.getException();\n-            }\n-        } else {\n-            \/\/ run without additional permission\n-            plainConnect0();\n-        }\n-    }\n-\n-    \/**\n-     *  if the caller has a URLPermission for connecting to the\n-     *  given URL, then return a SocketPermission which permits\n-     *  access to that destination. Return null otherwise. The permission\n-     *  is cached in a field (which can only be changed by redirects)\n-     *\/\n-    SocketPermission URLtoSocketPermission(URL url) throws IOException {\n-\n-        if (socketPermission != null) {\n-            return socketPermission;\n-        }\n-\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-\n-        if (sm == null) {\n-            return null;\n-        }\n-\n-        \/\/ the permission, which we might grant\n-\n-        SocketPermission newPerm = new SocketPermission(\n-            getHostAndPort(url), \"connect\"\n-        );\n-\n-        String actions = getRequestMethod()+\":\" +\n-                getUserSetHeaders().getHeaderNamesInList();\n-\n-        String urlstring = url.getProtocol() + \":\/\/\" + url.getAuthority()\n-                + url.getPath();\n-\n-        URLPermission p = new URLPermission(urlstring, actions);\n-        try {\n-            sm.checkPermission(p);\n-            socketPermission = newPerm;\n-            return socketPermission;\n-        } catch (SecurityException e) {\n-            \/\/ fall thru\n-        }\n-        return null;\n+        plainConnect0();\n@@ -1218,8 +944,1 @@\n-                @SuppressWarnings(\"removal\")\n-                ProxySelector sel =\n-                    java.security.AccessController.doPrivileged(\n-                        new java.security.PrivilegedAction<>() {\n-                            public ProxySelector run() {\n-                                     return ProxySelector.getDefault();\n-                                 }\n-                             });\n+                final ProxySelector sel = ProxySelector.getDefault();\n@@ -1402,1 +1121,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1408,17 +1126,1 @@\n-            SocketPermission p = URLtoSocketPermission(this.url);\n-\n-            if (p != null) {\n-                try {\n-                    return AccessController.doPrivilegedWithCombiner(\n-                            new PrivilegedExceptionAction<>() {\n-                                public OutputStream run() throws IOException {\n-                                    return getOutputStream0();\n-                                }\n-                            }, null, p\n-                    );\n-                } catch (PrivilegedActionException e) {\n-                    throw (IOException) e.getException();\n-                }\n-            } else {\n-                return getOutputStream0();\n-            }\n+            return getOutputStream0();\n@@ -1594,1 +1296,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1600,17 +1301,1 @@\n-            SocketPermission p = URLtoSocketPermission(this.url);\n-\n-            if (p != null) {\n-                try {\n-                    return AccessController.doPrivilegedWithCombiner(\n-                            new PrivilegedExceptionAction<>() {\n-                                public InputStream run() throws IOException {\n-                                    return getInputStream0();\n-                                }\n-                            }, null, p\n-                    );\n-                } catch (PrivilegedActionException e) {\n-                    throw (IOException) e.getException();\n-                }\n-            } else {\n-                return getInputStream0();\n-            }\n+            return getInputStream0();\n@@ -2063,11 +1748,3 @@\n-            @SuppressWarnings(\"removal\")\n-            IOException chainedException =\n-                java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedExceptionAction<>() {\n-                        public IOException run() throws Exception {\n-                            return (IOException)\n-                                rememberedException.getClass()\n-                                .getConstructor(new Class<?>[] { String.class })\n-                                .newInstance(args);\n-                        }\n-                    });\n+            IOException chainedException = rememberedException.getClass()\n+                    .getConstructor(new Class<?>[] { String.class })\n+                    .newInstance(args);\n@@ -2395,1 +2072,1 @@\n-    @SuppressWarnings({\"removal\",\"fallthrough\"})\n+    @SuppressWarnings(\"fallthrough\")\n@@ -2433,22 +2110,17 @@\n-                switch (authScheme) {\n-                case BASIC:\n-                    InetAddress addr = null;\n-                    try {\n-                        final String finalHost = host;\n-                        addr = java.security.AccessController.doPrivileged(\n-                            new java.security.PrivilegedExceptionAction<>() {\n-                                public InetAddress run()\n-                                    throws java.net.UnknownHostException {\n-                                    return InetAddress.getByName(finalHost);\n-                                }\n-                            });\n-                    } catch (java.security.PrivilegedActionException ignored) {\n-                        \/\/ User will have an unknown host.\n-                    }\n-                    PasswordAuthentication a =\n-                        privilegedRequestPasswordAuthentication(\n-                                    authenticator,\n-                                    host, addr, port, \"http\",\n-                                    realm, scheme, url, RequestorType.PROXY);\n-                    if (a != null) {\n-                        ret = new BasicAuthentication(true, host, port, realm, a, isUTF8);\n+                ret = switch (authScheme) {\n+                    case BASIC -> {\n+                        InetAddress addr = null;\n+                        try {\n+                            addr = InetAddress.getByName(host);\n+                        } catch (UnknownHostException uhe) {\n+                            \/\/ Ignore the exception. The Authenticator instance will\n+                            \/\/ be passed a null InetAddress when requesting a password from the\n+                            \/\/ Authenticator.\n+                        }\n+                        final PasswordAuthentication a = requestPassword(authenticator,\n+                                host, addr, port, \"http\",\n+                                realm, scheme, url, RequestorType.PROXY);\n+                        if (a != null) {\n+                            yield new BasicAuthentication(true, host, port, realm, a, isUTF8);\n+                        }\n+                        yield null;\n@@ -2456,11 +2128,11 @@\n-                    break;\n-                case DIGEST:\n-                    a = privilegedRequestPasswordAuthentication(\n-                                    authenticator,\n-                                    host, null, port, url.getProtocol(),\n-                                    realm, scheme, url, RequestorType.PROXY);\n-                    if (a != null) {\n-                        DigestAuthentication.Parameters params =\n-                            new DigestAuthentication.Parameters();\n-                        ret = new DigestAuthentication(true, host, port, realm,\n-                                             scheme, a, params);\n+                    case DIGEST -> {\n+                        final PasswordAuthentication a = requestPassword(authenticator,\n+                                host, null, port, url.getProtocol(),\n+                                realm, scheme, url, RequestorType.PROXY);\n+                        if (a != null) {\n+                            DigestAuthentication.Parameters params =\n+                                    new DigestAuthentication.Parameters();\n+                            yield new DigestAuthentication(true, host, port, realm,\n+                                    scheme, a, params);\n+                        }\n+                        yield null;\n@@ -2468,3 +2140,4 @@\n-                    break;\n-                case NTLM:\n-                    if (NTLMAuthenticationProxy.supported) {\n+                    case NTLM -> {\n+                        if (!NTLMAuthenticationProxy.supported) {\n+                            yield null;\n+                        }\n@@ -2487,1 +2160,1 @@\n-                        a = null;\n+                        PasswordAuthentication a = null;\n@@ -2491,4 +2164,4 @@\n-                            a = privilegedRequestPasswordAuthentication(\n-                                                authenticator,\n-                                                host, null, port, url.getProtocol(),\n-                                                \"\", scheme, url, RequestorType.PROXY);\n+                            a = requestPassword(\n+                                    authenticator,\n+                                    host, null, port, url.getProtocol(),\n+                                    \"\", scheme, url, RequestorType.PROXY);\n@@ -2503,0 +2176,1 @@\n+                        AuthenticationInfo authInfo = null;\n@@ -2504,2 +2178,2 @@\n-                              (!tryTransparentNTLMProxy && a != null)) {\n-                            ret = NTLMAuthenticationProxy.proxy.create(true, host, port, a);\n+                                (!tryTransparentNTLMProxy && a != null)) {\n+                            authInfo = NTLMAuthenticationProxy.proxy.create(true, host, port, a);\n@@ -2510,0 +2184,1 @@\n+                        yield authInfo;\n@@ -2511,10 +2186,9 @@\n-                    break;\n-                case NEGOTIATE:\n-                    ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), \"Negotiate\"));\n-                    break;\n-                case KERBEROS:\n-                    ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), \"Kerberos\"));\n-                    break;\n-                case UNKNOWN:\n-                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {\n-                        logger.finest(\"Unknown\/Unsupported authentication scheme: \" + scheme);\n+                    case NEGOTIATE ->\n+                            new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), \"Negotiate\"));\n+                    case KERBEROS ->\n+                            new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), \"Kerberos\"));\n+                    case UNKNOWN -> {\n+                        if (logger.isLoggable(PlatformLogger.Level.FINEST)) {\n+                            logger.finest(\"Unknown\/Unsupported authentication scheme: \" + scheme);\n+                        }\n+                        yield null;\n@@ -2522,4 +2196,1 @@\n-                \/*fall through*\/\n-                default:\n-                    throw new AssertionError(\"should not reach here\");\n-                }\n+                };\n@@ -2607,1 +2278,1 @@\n-                        privilegedRequestPasswordAuthentication(\n+                        requestPassword(\n@@ -2616,1 +2287,1 @@\n-                    a = privilegedRequestPasswordAuthentication(\n+                    a = requestPassword(\n@@ -2653,1 +2324,1 @@\n-                            a = privilegedRequestPasswordAuthentication(\n+                            a = requestPassword(\n@@ -2756,1 +2427,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2786,21 +2456,1 @@\n-\n-        final URL locUrl0 = locUrl;\n-        socketPermission = null; \/\/ force recalculation\n-        SocketPermission p = URLtoSocketPermission(locUrl);\n-\n-        if (p != null) {\n-            try {\n-                return AccessController.doPrivilegedWithCombiner(\n-                    new PrivilegedExceptionAction<>() {\n-                        public Boolean run() throws IOException {\n-                            return followRedirect0(loc, stat, locUrl0);\n-                        }\n-                    }, null, p\n-                );\n-            } catch (PrivilegedActionException e) {\n-                throw (IOException) e.getException();\n-            }\n-        } else {\n-            \/\/ run without additional permission\n-            return followRedirect0(loc, stat, locUrl);\n-        }\n+        return followRedirect0(loc, stat, locUrl);\n@@ -2841,6 +2491,0 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager security = System.getSecurityManager();\n-            if (security != null) {\n-                security.checkConnect(proxyHost, proxyPort);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":101,"deletions":457,"binary":false,"changes":558,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -50,3 +49,0 @@\n-    @java.io.Serial\n-    private static final long serialVersionUID = 100L;\n-\n@@ -64,8 +60,0 @@\n-    \/* Whether cache is enabled for Negotiate\/Kerberos *\/\n-    private static final boolean cacheSPNEGO;\n-    static {\n-        String spnegoCacheProp =\n-            GetPropertyAction.privilegedGetProperty(\"jdk.spnego.cache\", \"true\");\n-        cacheSPNEGO = Boolean.parseBoolean(spnegoCacheProp);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/NegotiateAuthentication.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.net.InetAddress;\n@@ -51,1 +50,0 @@\n-import sun.security.action.*;\n@@ -141,4 +139,2 @@\n-        String ciphers [];\n-        String cipherString =\n-                GetPropertyAction.privilegedGetProperty(\"https.cipherSuites\");\n-\n+        String[] ciphers;\n+        String cipherString = System.getProperty(\"https.cipherSuites\");\n@@ -165,4 +161,2 @@\n-        String protocols [];\n-        String protocolString =\n-                GetPropertyAction.privilegedGetProperty(\"https.protocols\");\n-\n+        String[] protocols;\n+        String protocolString = System.getProperty(\"https.protocols\");\n@@ -186,9 +180,0 @@\n-    private String getUserAgent() {\n-        String userAgent =\n-                GetPropertyAction.privilegedGetProperty(\"https.agent\");\n-        if (userAgent == null || userAgent.isEmpty()) {\n-            userAgent = \"JSSE\";\n-        }\n-        return userAgent;\n-    }\n-\n@@ -197,23 +182,0 @@\n-\n-    \/**\n-     * Create an HTTPS client URL.  Traffic will be tunneled through any\n-     * intermediate nodes rather than proxied, so that confidentiality\n-     * of data exchanged can be preserved.  However, note that all the\n-     * anonymous SSL flavors are subject to \"person-in-the-middle\"\n-     * attacks against confidentiality.  If you enable use of those\n-     * flavors, you may be giving up the protection you get through\n-     * SSL tunneling.\n-     *\n-     * Use New to get new HttpsClient. This constructor is meant to be\n-     * used only by New method. New properly checks for URL spoofing.\n-     *\n-     * @param url https URL with which a connection must be established\n-     *\/\n-    private HttpsClient(SSLSocketFactory sf, URL url)\n-    throws IOException\n-    {\n-        \/\/ HttpClient-level proxying is always disabled,\n-        \/\/ because we override doConnect to do tunneling instead.\n-        this(sf, url, (String)null, -1);\n-    }\n-\n@@ -221,10 +183,1 @@\n-     *  Create an HTTPS client URL.  Traffic will be tunneled through\n-     * the specified proxy server.\n-     *\/\n-    HttpsClient(SSLSocketFactory sf, URL url, String proxyHost, int proxyPort)\n-        throws IOException {\n-        this(sf, url, proxyHost, proxyPort, -1);\n-    }\n-\n-    \/**\n-     *  Create an HTTPS client URL.  Traffic will be tunneled through\n+     * Create an HTTPS client URL. Traffic will be tunneled through\n@@ -233,12 +186,0 @@\n-    HttpsClient(SSLSocketFactory sf, URL url, String proxyHost, int proxyPort,\n-                int connectTimeout)\n-        throws IOException {\n-        this(sf, url,\n-             (proxyHost == null? null:\n-                HttpClient.newHttpProxy(proxyHost, proxyPort, \"https\")),\n-                connectTimeout);\n-    }\n-\n-    \/**\n-     *  Same as previous constructor except using a Proxy\n-     *\/\n@@ -271,31 +212,0 @@\n-    static HttpClient New(SSLSocketFactory sf, URL url, HostnameVerifier hv,\n-                          HttpURLConnection httpuc)\n-            throws IOException {\n-        return HttpsClient.New(sf, url, hv, true, httpuc);\n-    }\n-\n-    \/** See HttpClient for the model for this method. *\/\n-    static HttpClient New(SSLSocketFactory sf, URL url,\n-            HostnameVerifier hv, boolean useCache,\n-            HttpURLConnection httpuc) throws IOException {\n-        return HttpsClient.New(sf, url, hv, (String)null, -1, useCache, httpuc);\n-    }\n-\n-    \/**\n-     * Get a HTTPS client to the URL.  Traffic will be tunneled through\n-     * the specified proxy server.\n-     *\/\n-    static HttpClient New(SSLSocketFactory sf, URL url, HostnameVerifier hv,\n-                           String proxyHost, int proxyPort,\n-                           HttpURLConnection httpuc) throws IOException {\n-        return HttpsClient.New(sf, url, hv, proxyHost, proxyPort, true, httpuc);\n-    }\n-\n-    static HttpClient New(SSLSocketFactory sf, URL url, HostnameVerifier hv,\n-                           String proxyHost, int proxyPort, boolean useCache,\n-                           HttpURLConnection httpuc)\n-        throws IOException {\n-        return HttpsClient.New(sf, url, hv, proxyHost, proxyPort, useCache, -1,\n-                               httpuc);\n-    }\n-\n@@ -382,9 +292,0 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager security = System.getSecurityManager();\n-            if (security != null) {\n-                if (ret.proxy == Proxy.NO_PROXY || ret.proxy == null) {\n-                    security.checkConnect(InetAddress.getByName(url.getHost()).getHostAddress(), url.getPort());\n-                } else {\n-                    security.checkConnect(url.getHost(), url.getPort());\n-                }\n-            }\n@@ -398,2 +299,1 @@\n-    \/\/ METHODS\n-    void setHostnameVerifier(HostnameVerifier hv) {\n+    private void setHostnameVerifier(HostnameVerifier hv) {\n@@ -403,1 +303,1 @@\n-    void setSSLSocketFactory(SSLSocketFactory sf) {\n+    private void setSSLSocketFactory(SSLSocketFactory sf) {\n@@ -407,4 +307,0 @@\n-    SSLSocketFactory getSSLSocketFactory() {\n-        return sslSocketFactory;\n-    }\n-\n@@ -413,1 +309,1 @@\n-     * and overridden here so that the socket facroty is used to create\n+     * and overridden here so that the socket factory is used to create\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":9,"deletions":113,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-    private static final long serialVersionUID = 170L;\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/http\/ntlm\/NTLMAuthentication.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}