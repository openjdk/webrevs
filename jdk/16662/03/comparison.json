{"files":[{"patch":"@@ -5579,1 +5579,0 @@\n-    \/\/ Free methods\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -540,0 +540,2 @@\n+      \/\/ Do the pointer maintenance before releasing the metadata\n+      method->clear_jmethod_id();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2266,0 +2266,19 @@\n+void Method::clear_jmethod_id() {\n+  if (method_holder() == nullptr) {\n+    \/\/ the method has not been fully initialized and has no link to its holder\n+    \/\/ jmethodIDs are kept in the cache in the holder and so, without the holder there is no associated jmethodID\n+    return;\n+  }\n+  \/\/ Being at a safepoint prevents racing against other class redefinitions\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n+  \/\/ The jmethodID is not stored in the Method instance, we need to look it up first\n+  jmethodID methodid = find_jmethod_id_or_null();\n+  \/\/ We need to make sure that jmethodID actually resolves to this method\n+  \/\/ - multiple redefined versions may share jmethodID slots and if a method\n+  \/\/   has already been rewired to a newer version we could be removing reference\n+  \/\/   to a still existing method instance\n+  if (methodid != nullptr && *((Method**)methodid) == this) {\n+    *((Method**)methodid) = nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -718,0 +718,1 @@\n+  void clear_jmethod_id();\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2630,0 +2630,4 @@\n+WB_ENTRY(void, WB_CleanMetaspaces(JNIEnv* env, jobject target))\n+  ClassLoaderDataGraph::safepoint_and_clean_metaspaces();\n+WB_END\n+\n@@ -2916,0 +2920,1 @@\n+  {CC\"cleanMetaspaces\", CC\"()V\",                      (void*)&WB_CleanMetaspaces},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8313816\n+ * @summary Test that a sequence of method retransformation and stacktrace capture while the old method\n+ *          version is still on stack does not lead to a crash when that method's jmethodID is used as\n+ *          an argument for JVMTI functions.\n+ * @requires vm.jvmti\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @modules java.instrument\n+ *          java.compiler\n+ * @compile GetStackTraceAndRetransformTest.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -javaagent:redefineagent.jar -agentlib:GetStackTraceAndRetransformTest GetStackTraceAndRetransformTest\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+class Transformable {\n+  static final String newClass = \"\"\"\n+    class Transformable {\n+      static final String newClass = \"\";\n+      static void redefineAndStacktrace() throws Exception {}\n+      static void stacktrace() throws Exception {\n+        capture(Thread.currentThread());\n+      }\n+      public static native void capture(Thread thread);\n+    }\n+  \"\"\";\n+  static void redefineAndStacktrace() throws Exception {\n+    \/\/ This call will cause the class to be retransformed.\n+    \/\/ However, this method is still on stack so the subsequent attempt to capture the stacktrace\n+    \/\/ will result into this frame being identified by the jmethodID of the previous method version.\n+    RedefineClassHelper.redefineClass(Transformable.class, newClass);\n+    capture(Thread.currentThread());\n+  }\n+\n+  static void stacktrace() throws Exception {\n+  }\n+\n+  public static native void capture(Thread thread);\n+}\n+\n+public class GetStackTraceAndRetransformTest {\n+    public static void main(String args[]) throws Throwable {\n+        initialize(Transformable.class);\n+\n+        Transformable.redefineAndStacktrace();\n+        Transformable.stacktrace();\n+\n+        WhiteBox.getWhiteBox().cleanMetaspaces();\n+        check(2);\n+    }\n+\n+    public static native void initialize(Class<?> target);\n+    public static native void check(int expected);\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/GetStackTraceAndRetransformTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+#include \"..\/get_stack_trace.h\"\n+\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jmethodID* ids = NULL;\n+static int ids_size = 0;\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  ids = (jmethodID*)malloc(sizeof(jmethodID) * 10);\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetStackTraceAndRetransformTest_initialize(JNIEnv *env, jclass cls, jclass tgt) {\n+  \/\/ we need to force jmethodids to be created for the methods we are going to retransform\n+  env->GetStaticMethodID(tgt, \"redefineAndStacktrace\", \"()V\");\n+  env->GetStaticMethodID(tgt, \"stacktrace\", \"()V\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_Transformable_capture(JNIEnv *env, jclass cls, jthread thread) {\n+  jint count;\n+  const int MAX_NUMBER_OF_FRAMES = 32;\n+  jvmtiFrameInfo frames[MAX_NUMBER_OF_FRAMES];\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_NUMBER_OF_FRAMES, frames, &count);\n+  check_jvmti_status(env, err, \"GetStackTrace failed.\");\n+\n+  ids[ids_size++] = frames[1].method;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetStackTraceAndRetransformTest_check(JNIEnv *jni, jclass cls, jint expected) {\n+  if (ids_size != expected) {\n+    fprintf(stderr, \"Unexpected number methods captured: %d (expected %d)\\n\", ids_size, expected);\n+    exit(2);\n+  }\n+  for (int i = 0; i < ids_size; i++) {\n+    jclass rslt = NULL;\n+    char* class_name = NULL;\n+    jvmti->GetMethodDeclaringClass(ids[i], &rslt);\n+    if (rslt != NULL) {\n+        jvmti->GetClassSignature(rslt, &class_name, NULL);\n+    }\n+  }\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/libGetStackTraceAndRetransformTest.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -524,0 +524,2 @@\n+  public native void cleanMetaspaces();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}