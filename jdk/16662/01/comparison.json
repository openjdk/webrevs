{"files":[{"patch":"@@ -5579,1 +5579,0 @@\n-    \/\/ Free methods\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -540,0 +540,2 @@\n+      \/\/ Do the pointer maintenance before releasing the metadata\n+      method->clear_jmethod_id();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2266,0 +2266,19 @@\n+void Method::clear_jmethod_id() {\n+  \/\/ Being at a safepoint prevents racing against other class redefinitions\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n+  if (method_holder() == nullptr) {\n+    \/\/ the method has not been fully initialized and has no link to its holder\n+    \/\/ jmethodIDs are kept in the cache in the holder and so, without the holder there is no associated jmethodID\n+    return;\n+  }\n+  \/\/ The jmethodID is not stored in the Method instance, we need to look it up first\n+  jmethodID methodid = find_jmethod_id_or_null();\n+  \/\/ We need to make sure that jmethodID actually resolves to this method\n+  \/\/ - multiple redefined versions may share jmethodID slots and if a method\n+  \/\/   has already been rewired to a newer version we could be removing reference\n+  \/\/   to a still existing method instance\n+  if (methodid != nullptr && *((Method**)methodid) == this) {\n+    *((Method**)methodid) = nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -718,0 +718,1 @@\n+  void clear_jmethod_id();\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2630,0 +2630,4 @@\n+WB_ENTRY(void, WB_CleanMetaspaces(JNIEnv* env, jobject target))\n+  ClassLoaderDataGraph::safepoint_and_clean_metaspaces();\n+WB_END\n+\n@@ -2916,0 +2920,1 @@\n+  {CC\"cleanMetaspaces\", CC\"()V\",                      (void*)&WB_CleanMetaspaces},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2023, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8313816\n+ * @summary Test that a sequence of method retransformation and stacktrace capture while the old method\n+ *          version is still on stack does not lead to a crash when that method's jmethodID is used as\n+ *          an argument for JVMTI functions.\n+ * @requires vm.jvmti\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @modules java.instrument java.base\/jdk.internal.org.objectweb.asm\n+ * @compile GetStackTraceAndRetransformTest.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver GetStackTraceAndRetransformTest build-jar\n+ * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -javaagent:.\/agent.jar -agentlib:GetStackTraceAndRetransformTest GetStackTraceAndRetransformTest\n+ *\/\n+\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.lang.instrument.Instrumentation;\n+import java.lang.instrument.UnmodifiableClassException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.ProtectionDomain;\n+\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class GetStackTraceAndRetransformTest {\n+    public static final class Shared {\n+        public static volatile Instrumentation inst;\n+\n+        public static void retransform() {\n+            try {\n+                Shared.inst.retransformClasses(new Class[] { Transformable.class });\n+            } catch (UnmodifiableClassException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    private static String agentManifest =\n+            \"Premain-Class: \" + GetStackTraceAndRetransformTest.Agent.class.getName() + \"\\n\"\n+                    + \"Can-Retransform-Classes: true\\n\";\n+\n+    public static void main(String args[]) throws Throwable {\n+        if (args.length == 1 && args[0].equals(\"build-jar\")) {\n+            buildAgent();\n+            return;\n+        }\n+        initialize(Transformable.class);\n+\n+        Transformable.retransformAndStacktrace();\n+        Transformable.stacktrace();\n+\n+        WhiteBox.getWhiteBox().cleanMetaspaces();\n+        check(2);\n+    }\n+\n+    private static String buildAgent() throws Exception {\n+        Path jar = Paths.get(\".\", \"agent.jar\");\n+        String jarPath = jar.toAbsolutePath().toString();\n+        ClassFileInstaller.writeJar(jarPath,\n+                ClassFileInstaller.Manifest.fromString(agentManifest),\n+                Agent.class.getName());\n+        return jarPath;\n+    }\n+\n+    private static class Transformable {\n+        static void retransformAndStacktrace() {\n+            Shared.retransform();\n+            capture(Thread.currentThread());\n+        }\n+\n+        static void stacktrace() {\n+            capture(Thread.currentThread());\n+        }\n+    }\n+\n+    public static class Agent implements ClassFileTransformer {\n+        public static void premain(String args, Instrumentation inst) {\n+            inst.addTransformer(new SimpleTransformer(), true);\n+            Shared.inst = inst;\n+        }\n+    }\n+\n+    private static class SimpleTransformer implements ClassFileTransformer {\n+        private static int counter = 0;\n+        @Override\n+        public byte[] transform(ClassLoader loader,\n+                                String className,\n+                                Class<?> classBeingRedefined,\n+                                ProtectionDomain protectionDomain,\n+                                byte[] classfileBuffer\n+        ) throws IllegalClassFormatException {\n+            \/\/ only if Transformable is being retransformed\n+            if (classBeingRedefined != null && className.equals(\"GetStackTraceAndRetransformTest$Transformable\")) {\n+                ClassReader cr = new ClassReader(classfileBuffer);\n+                ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);\n+\n+                try {\n+                    ClassVisitor cv = new ClassVisitor(Opcodes.ASM9, cw) {\n+                        @Override\n+                        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+                            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+                            return new MethodVisitor(Opcodes.ASM5, mv) {\n+                                @Override\n+                                public void visitCode() {\n+                                    super.visitCode();\n+                                    mv.visitFieldInsn(Opcodes.GETSTATIC, System.class.getName().replace('.', '\/'), \"err\", Type.getDescriptor(java.io.PrintStream.class));\n+                                    mv.visitLdcInsn(\"Hello from transformed method: \" + name + \"#\" + (++counter));\n+                                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, java.io.PrintStream.class.getName().replace('.', '\/'), \"println\", \"(Ljava\/lang\/String;)V\", false);\n+                                }\n+                            };\n+                        }\n+                    };\n+                    cr.accept(cv, 0);\n+                    return cw.toByteArray();\n+                } catch (Throwable t) {\n+                    t.printStackTrace(System.err);\n+                    throw t;\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static native void initialize(Class<?> target);\n+    public static native void capture(Thread thread);\n+    public static native void check(int expected);\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/GetStackTraceAndRetransformTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+#include \"..\/get_stack_trace.h\"\n+\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jmethodID* ids = NULL;\n+static int ids_size = 0;\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  ids = (jmethodID*)malloc(sizeof(jmethodID) * 10);\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetStackTraceAndRetransformTest_initialize(JNIEnv *env, jclass cls, jclass tgt) {\n+  \/\/ we need to force jmethodids to be created for the methods we are going to retransform\n+  env->GetStaticMethodID(tgt, \"retransformAndStacktrace\", \"()V\");\n+  env->GetStaticMethodID(tgt, \"stacktrace\", \"()V\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetStackTraceAndRetransformTest_capture(JNIEnv *env, jclass cls, jthread thread) {\n+  jint count;\n+  const int MAX_NUMBER_OF_FRAMES = 32;\n+  jvmtiFrameInfo frames[MAX_NUMBER_OF_FRAMES];\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_NUMBER_OF_FRAMES, frames, &count);\n+  check_jvmti_status(env, err, \"GetStackTrace failed.\");\n+\n+  ids[ids_size++] = frames[1].method;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetStackTraceAndRetransformTest_check(JNIEnv *jni, jclass cls, jint expected) {\n+  if (ids_size != expected) {\n+    fprintf(stderr, \"Unexpected number methods captured: %d (expected %d)\\n\", ids_size, expected);\n+    exit(2);\n+  }\n+  for (int i = 0; i < ids_size; i++) {\n+    jclass rslt = NULL;\n+    char* class_name = NULL;\n+    jvmti->GetMethodDeclaringClass(ids[i], &rslt);\n+    if (rslt != NULL) {\n+        jvmti->GetClassSignature(rslt, &class_name, NULL);\n+    }\n+  }\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/libGetStackTraceAndRetransformTest.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -524,0 +524,2 @@\n+  public native void cleanMetaspaces();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}