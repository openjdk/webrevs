{"files":[{"patch":"@@ -34,1 +34,2 @@\n- * @modules java.instrument java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.instrument\n+ *          java.compiler\n@@ -37,2 +38,2 @@\n- * @run driver GetStackTraceAndRetransformTest build-jar\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -javaagent:.\/agent.jar -agentlib:GetStackTraceAndRetransformTest GetStackTraceAndRetransformTest\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -javaagent:redefineagent.jar -agentlib:GetStackTraceAndRetransformTest GetStackTraceAndRetransformTest\n@@ -41,15 +42,0 @@\n-import java.lang.instrument.ClassFileTransformer;\n-import java.lang.instrument.IllegalClassFormatException;\n-import java.lang.instrument.Instrumentation;\n-import java.lang.instrument.UnmodifiableClassException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.ProtectionDomain;\n-\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.test.lib.helpers.ClassFileInstaller;\n@@ -58,11 +44,9 @@\n-public class GetStackTraceAndRetransformTest {\n-    public static final class Shared {\n-        public static volatile Instrumentation inst;\n-\n-        public static void retransform() {\n-            try {\n-                Shared.inst.retransformClasses(new Class[] { Transformable.class });\n-            } catch (UnmodifiableClassException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n+class Transformable {\n+  static final String newClass = \"\"\"\n+    class Transformable {\n+      static final String newClass = \"\";\n+      static void redefineAndStacktrace() throws Exception {}\n+      static void stacktrace() throws Exception {\n+        capture(Thread.currentThread());\n+      }\n+      public static native void capture(Thread thread);\n@@ -70,0 +54,14 @@\n+  \"\"\";\n+  static void redefineAndStacktrace() throws Exception {\n+    \/\/ This call will cause the class to be retransformed.\n+    \/\/ However, this method is still on stack so the subsequent attempt to capture the stacktrace\n+    \/\/ will result into this frame being identified by the jmethodID of the previous method version.\n+    RedefineClassHelper.redefineClass(Transformable.class, newClass);\n+    capture(Thread.currentThread());\n+  }\n+\n+  static void stacktrace() throws Exception {\n+  }\n+\n+  public static native void capture(Thread thread);\n+}\n@@ -71,4 +69,1 @@\n-    private static String agentManifest =\n-            \"Premain-Class: \" + GetStackTraceAndRetransformTest.Agent.class.getName() + \"\\n\"\n-                    + \"Can-Retransform-Classes: true\\n\";\n-\n+public class GetStackTraceAndRetransformTest {\n@@ -76,4 +71,0 @@\n-        if (args.length == 1 && args[0].equals(\"build-jar\")) {\n-            buildAgent();\n-            return;\n-        }\n@@ -82,1 +73,1 @@\n-        Transformable.retransformAndStacktrace();\n+        Transformable.redefineAndStacktrace();\n@@ -89,68 +80,0 @@\n-    private static String buildAgent() throws Exception {\n-        Path jar = Paths.get(\".\", \"agent.jar\");\n-        String jarPath = jar.toAbsolutePath().toString();\n-        ClassFileInstaller.writeJar(jarPath,\n-                ClassFileInstaller.Manifest.fromString(agentManifest),\n-                Agent.class.getName());\n-        return jarPath;\n-    }\n-\n-    private static class Transformable {\n-        static void retransformAndStacktrace() {\n-            Shared.retransform();\n-            capture(Thread.currentThread());\n-        }\n-\n-        static void stacktrace() {\n-            capture(Thread.currentThread());\n-        }\n-    }\n-\n-    public static class Agent implements ClassFileTransformer {\n-        public static void premain(String args, Instrumentation inst) {\n-            inst.addTransformer(new SimpleTransformer(), true);\n-            Shared.inst = inst;\n-        }\n-    }\n-\n-    private static class SimpleTransformer implements ClassFileTransformer {\n-        private static int counter = 0;\n-        @Override\n-        public byte[] transform(ClassLoader loader,\n-                                String className,\n-                                Class<?> classBeingRedefined,\n-                                ProtectionDomain protectionDomain,\n-                                byte[] classfileBuffer\n-        ) throws IllegalClassFormatException {\n-            \/\/ only if Transformable is being retransformed\n-            if (classBeingRedefined != null && className.equals(\"GetStackTraceAndRetransformTest$Transformable\")) {\n-                ClassReader cr = new ClassReader(classfileBuffer);\n-                ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);\n-\n-                try {\n-                    ClassVisitor cv = new ClassVisitor(Opcodes.ASM9, cw) {\n-                        @Override\n-                        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-                            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-                            return new MethodVisitor(Opcodes.ASM5, mv) {\n-                                @Override\n-                                public void visitCode() {\n-                                    super.visitCode();\n-                                    mv.visitFieldInsn(Opcodes.GETSTATIC, System.class.getName().replace('.', '\/'), \"err\", Type.getDescriptor(java.io.PrintStream.class));\n-                                    mv.visitLdcInsn(\"Hello from transformed method: \" + name + \"#\" + (++counter));\n-                                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, java.io.PrintStream.class.getName().replace('.', '\/'), \"println\", \"(Ljava\/lang\/String;)V\", false);\n-                                }\n-                            };\n-                        }\n-                    };\n-                    cr.accept(cv, 0);\n-                    return cw.toByteArray();\n-                } catch (Throwable t) {\n-                    t.printStackTrace(System.err);\n-                    throw t;\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n@@ -158,1 +81,0 @@\n-    public static native void capture(Thread thread);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/GetStackTraceAndRetransformTest.java","additions":29,"deletions":107,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  env->GetStaticMethodID(tgt, \"retransformAndStacktrace\", \"()V\");\n+  env->GetStaticMethodID(tgt, \"redefineAndStacktrace\", \"()V\");\n@@ -56,1 +56,1 @@\n-Java_GetStackTraceAndRetransformTest_capture(JNIEnv *env, jclass cls, jthread thread) {\n+Java_Transformable_capture(JNIEnv *env, jclass cls, jthread thread) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/libGetStackTraceAndRetransformTest.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}