{"files":[{"patch":"@@ -84,1 +84,1 @@\n-void SuspendResumeManager::set_suspended_with_id(int64_t id, bool register_vthread_SR) {\n+void SuspendResumeManager::set_suspended_current_thread(int64_t vthread_id, bool register_vthread_SR) {\n@@ -88,1 +88,2 @@\n-    JvmtiVTSuspender::register_vthread_suspend(id);\n+    assert(_target == JavaThread::current(), \"should be current thread\");\n+    JvmtiVTSuspender::register_vthread_suspend(vthread_id);\n@@ -104,1 +105,1 @@\n-    set_suspended_with_id(id, register_vthread_SR);\n+    set_suspended_current_thread(id, register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,2 +62,4 @@\n-  \/\/ The specific 'set_suspended' implementation for self suspend.\n-  void set_suspended_with_id(int64_t id, bool register_vthread_SR);\n+  \/\/ The specific 'set_suspended' implementation only for self suspend.\n+  \/\/ It is called when the thread is already blocked, and it is not possible to\n+  \/\/ read oop for vthread from the _target.\n+  void set_suspended_current_thread(int64_t vthread_id, bool register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}