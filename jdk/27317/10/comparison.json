{"files":[{"patch":"@@ -717,2 +717,1 @@\n-JvmtiVTSuspender::register_vthread_suspend(oop vt) {\n-  int64_t id = java_lang_Thread::thread_id(vt);\n+JvmtiVTSuspender::register_vthread_suspend(int64_t id) {\n@@ -733,0 +732,6 @@\n+void\n+JvmtiVTSuspender::register_vthread_suspend(oop vt) {\n+  int64_t id = java_lang_Thread::thread_id(vt);\n+  register_vthread_suspend(id);\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+  static void register_vthread_suspend(int64_t id);\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,0 +84,11 @@\n+void SuspendResumeManager::set_suspended_current_thread(int64_t vthread_id, bool register_vthread_SR) {\n+  assert(_target == JavaThread::current(), \"should be current thread\");\n+#if INCLUDE_JVMTI\n+  if (register_vthread_SR) {\n+    assert(_target->is_vthread_mounted(), \"sanity check\");\n+    JvmtiVTSuspender::register_vthread_suspend(vthread_id);\n+  }\n+#endif\n+  AtomicAccess::store(&_suspended, true);\n+}\n+\n@@ -89,1 +100,3 @@\n-    \/\/ and just suspend directly\n+    \/\/ and just suspend directly.\n+    \/\/ The vthread() oop must only be accessed before state is set to _thread_blocked.\n+    int64_t id = java_lang_Thread::thread_id(_target->vthread());\n@@ -92,1 +105,1 @@\n-    set_suspended(true, register_vthread_SR);\n+    set_suspended_current_thread(id, register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -62,0 +62,5 @@\n+  \/\/ The specific 'set_suspended' implementation only for self suspend.\n+  \/\/ It is called when the thread is already blocked, and it is not possible to\n+  \/\/ read oop for vthread from the _target.\n+  void set_suspended_current_thread(int64_t vthread_id, bool register_vthread_SR);\n+\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,5 @@\n-            while(!isSuspended(t1)) {\n+            selfSuspend();\n+        });\n+        Thread t3 = Thread.ofVirtual().factory().newThread(() -> {\n+            testJvmtiThreadState(Thread.currentThread(), RUNNABLE);\n+            while(!isSuspended(t1) || !isSuspended(t2)) {\n@@ -91,0 +95,1 @@\n+            testJvmtiThreadState(t2, SUSPENDED);\n@@ -93,0 +98,1 @@\n+            resume(t2);\n@@ -99,0 +105,1 @@\n+        testJvmtiThreadState(t3, NEW);\n@@ -102,0 +109,1 @@\n+        t3.start();\n@@ -103,1 +111,1 @@\n-        while(!isSuspended(t2)) {\n+        while(!isSuspended(t3)) {\n@@ -107,1 +115,1 @@\n-        testJvmtiThreadState(t2, SUSPENDED);\n+        testJvmtiThreadState(t3, SUSPENDED);\n@@ -111,0 +119,1 @@\n+        t3.join();\n@@ -116,0 +125,1 @@\n+        testJvmtiThreadState(t3, TERMINATED);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SelfSuspendDisablerTest\/SelfSuspendDisablerTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"}]}