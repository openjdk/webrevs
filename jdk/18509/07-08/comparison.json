{"files":[{"patch":"@@ -105,1 +105,1 @@\n-     }\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitorPreview.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8140442 8324651\n+ * @enablePreview\n+ * @summary Test ElementKindVisitorX w.r.t. component local variable\n+ * @library \/tools\/javac\/lib\n+ * @build   JavacTestingAbstractProcessor TestElementVisitorsForComponentVariables\n+ * @compile -J--enable-preview -processor TestElementVisitorsForComponentVariables -proc:only TestElementVisitorsForComponentVariables.java\n+ *\/\n+\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import java.util.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.*;\n+\n+\/**\n+ * Test basic workings ElementKindVisitorX with regards to component\n+ * local variables.\n+ *\/\n+public class TestElementVisitorsForComponentVariables extends JavacTestingAbstractProcessor {\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            TypeElement outer = eltUtils.getTypeElement(\"Outer\");\n+            Element componentVariable = findComponentLocalVariable(outer);\n+\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor6<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor7<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor8<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor9<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor14<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitorPreview<>() {\n+                @Override\n+                protected Void defaultAction(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+\n+            boolean[] seenComponentVariable = new boolean[1];\n+\n+            new ElementKindVisitorPreview<Void, Void>() {\n+                @Override\n+                public Void visitVariableAsComponentLocalVariable(VariableElement e, Void p) {\n+                    seenComponentVariable[0] = true;\n+                    return null; \/\/OK\n+                }\n+                @Override\n+                protected Void defaultAction(Element e, Void p) {\n+                    throw new RuntimeException(\"Should not get here!\");\n+                }\n+            }.visit(componentVariable, null);\n+        }\n+        return true;\n+    }\n+\n+    private Element findComponentLocalVariable(Element root) {\n+        Trees trees = Trees.instance(processingEnv);\n+        TreePath topLevelPath = trees.getPath(root);\n+        Element[] componentLocalVariable = new Element[1];\n+        new TreePathScanner<Void, Void>() {\n+            @Override\n+            public Void visitIdentifier(IdentifierTree node, Void p) {\n+                Element el = trees.getElement(getCurrentPath());\n+\n+                if (el != null && el.getKind() == ElementKind.COMPONENT_LOCAL_VARIABLE) {\n+                    componentLocalVariable[0] = el;\n+                }\n+\n+                return super.visitIdentifier(node, p);\n+            }\n+\n+        }.scan(topLevelPath, null);\n+\n+        if (componentLocalVariable[0] == null) {\n+            throw new RuntimeException(\"Cannot find component variable.\");\n+        }\n+\n+        return componentLocalVariable[0];\n+    }\n+\n+    private void checkExceptionThrown(Element componentLocalVariable,\n+                                      ElementKindVisitor6<Void, Void> v) {\n+        try {\n+            v.visit(componentLocalVariable);\n+            throw new RuntimeException(\"Should have thrown an exception.\");\n+        } catch (DefaultAction ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    private static class DefaultAction extends RuntimeException {}\n+}\n+\n+class Outer {\n+    private void nested() {\n+        record R(int i) {}\n+        R r = null;\n+        r = r with { i = 0; };\n+        new Runnable() {\n+            public void run() {}\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestElementVisitorsForComponentVariables.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,1 +31,1 @@\n- * @compile -processor TestOutermostTypeElement -proc:only TestOutermostTypeElement.java\n+ * @compile -J--enable-preview -processor TestOutermostTypeElement -proc:only TestOutermostTypeElement.java\n@@ -33,1 +34,11 @@\n-import java.io.Writer;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.DerivedInstanceTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n@@ -47,0 +58,1 @@\n+            Trees trees = Trees.instance(processingEnv);\n@@ -65,0 +77,4 @@\n+\n+                var treeBasedScanner = new OuterTreeBaseScanner();\n+                treeBasedScanner.scan(e, vacuousElts);\n+                treeBasedScanner.scan(e, eltUtils);\n@@ -93,0 +109,72 @@\n+\n+    private class OuterTreeBaseScanner extends TreePathScanner<Void, Elements> {\n+        private final Trees trees;\n+        private TypeElement topLevel;\n+\n+        public OuterTreeBaseScanner() {\n+            this.trees = Trees.instance(processingEnv);\n+        }\n+\n+        public void scan(TypeElement el, Elements elts) {\n+            TreePath topLevelPath = trees.getPath(el);\n+\n+            topLevel = el;\n+            scan(topLevelPath, elts);\n+        }\n+\n+        @Override\n+        public Void visitClass(ClassTree node, Elements p) {\n+            handleDeclaration(p);\n+            return super.visitClass(node, p);\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Elements p) {\n+            handleDeclaration(p);\n+            return super.visitVariable(node, p);\n+        }\n+\n+        @Override\n+        public Void visitMethod(MethodTree node, Elements p) {\n+            handleDeclaration(p);\n+            return super.visitMethod(node, p);\n+        }\n+\n+        @Override\n+        public Void visitDerivedInstance(DerivedInstanceTree node, Elements p) {\n+            for (StatementTree st : node.getBlock().getStatements()) {\n+                if (st.getKind() == Kind.EXPRESSION_STATEMENT) {\n+                    ExpressionStatementTree est = (ExpressionStatementTree) st;\n+\n+                    if (est.getExpression().getKind() == Kind.ASSIGNMENT) {\n+                        AssignmentTree at = (AssignmentTree) est.getExpression();\n+                        TreePath left = TreePath.getPath(getCurrentPath(), at.getVariable());\n+                        Element componentVariable = trees.getElement(left);\n+\n+                        assertNotNull(componentVariable);\n+\n+                        if (componentVariable.getKind() != ElementKind.COMPONENT_LOCAL_VARIABLE) {\n+                            throw new RuntimeException(\"Unexpected variable kind: \" + componentVariable.getKind());\n+                        }\n+\n+                        checkOuter(componentVariable, topLevel, p);\n+                    }\n+                }\n+            }\n+\n+            return super.visitDerivedInstance(node, p);\n+        }\n+\n+        private void handleDeclaration(Elements els) {\n+            Element el = trees.getElement(getCurrentPath());\n+\n+            assertNotNull(el);\n+            checkOuter(el, topLevel, els);\n+        }\n+\n+        private static void assertNotNull(Object o) {\n+            if (o == null) {\n+                throw new RuntimeException(\"Unexpected null value.\");\n+            }\n+        }\n+    }\n@@ -124,0 +212,14 @@\n+\n+        private void nested() {\n+            int i = 0;\n+            try (AutoCloseable a = null) {\n+                boolean b = a instanceof Runnable r;\n+            } catch (Exception ex) {\n+            }\n+            record R(int i) {}\n+            R r = null;\n+            r = r with { i = 0; };\n+            new Runnable() {\n+                public void run() {}\n+            };\n+        }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestOutermostTypeElement.java","additions":105,"deletions":3,"binary":false,"changes":108,"status":"modified"}]}