{"files":[{"patch":"@@ -84,0 +84,2 @@\n+        @JEP(number=468, title=\"Derived Record Creation\", status=\"Preview\")\n+        DERIVED_RECORD_CREATION,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -124,1 +126,8 @@\n-    BINDING_VARIABLE;\n+    BINDING_VARIABLE,\n+\n+    \/**\n+     * A local component variable in a derived record creation expression.\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    COMPONENT_LOCAL_VARIABLE;\n@@ -203,1 +212,2 @@\n-     * {@code RESOURCE_VARIABLE}, and {@code BINDING_VARIABLE}.\n+     * {@code RESOURCE_VARIABLE}, {@code BINDING_VARIABLE}, and\n+     * {@code COMPONENT_LOCAL_VARIABLE}.\n@@ -212,1 +222,1 @@\n-             BINDING_VARIABLE -> true;\n+             BINDING_VARIABLE, COMPONENT_LOCAL_VARIABLE -> true;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ElementKind.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -267,0 +269,3 @@\n+        case COMPONENT_LOCAL_VARIABLE:\n+            return visitVariableAsComponentLocalVariable(e, p);\n+\n@@ -367,0 +372,16 @@\n+    \/**\n+     * Visits a {@code COMPONENT_LOCAL_VARIABLE} variable element.\n+     *\n+     * @implSpec This implementation calls {@code visitUnknown}.\n+     *\n+     * @param e the element to visit\n+     * @param p a visitor-specified parameter\n+     * @return  the result of {@code visitUnknown}\n+     *\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    public R visitVariableAsComponentLocalVariable(VariableElement e, P p) {\n+        return visitUnknown(e, p);\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor6.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -91,0 +91,17 @@\n+\n+    \/**\n+     * {@inheritDoc ElementKindVisitor6}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param e {@inheritDoc ElementKindVisitor6}\n+     * @param p {@inheritDoc ElementKindVisitor6}\n+     * @return  the result of {@code defaultAction}\n+     *\n+     * @since 23\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    public R visitVariableAsComponentLocalVariable(VariableElement e, P p) {\n+        return defaultAction(e, p);\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitorPreview.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A tree node for a derived record creation expression.\n+ *\n+ * For example:\n+ * <pre>\n+ *   <em>expression<\/em> with { <em>assignments<\/em> }\n+ * <\/pre>\n+ *\n+ * @jls 15.30 Derived Record Creation Expression\n+ *\n+ * @since 23\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+public interface DerivedInstanceTree extends ExpressionTree {\n+    \/**\n+     * {@return the origin expression of the derived record creation expression.}\n+     *\/\n+    ExpressionTree getExpression();\n+\n+    \/**\n+     * {@return the reconstruction block.}\n+     *\/\n+    BlockTree getBlock();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DerivedInstanceTree.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -222,0 +224,7 @@\n+        \/**\n+         * Used for instances of {@link DerivedInstanceTree}.\n+         * @since 23\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+        DERIVED_INSTANCE(DerivedInstanceTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -370,0 +372,10 @@\n+    \/**\n+     * Visits a {@code DerivedInstanceTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    R visitDerivedInstance(DerivedInstanceTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -546,0 +547,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 23\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    public R visitDerivedInstance(DerivedInstanceTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -664,0 +665,18 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 23\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    public R visitDerivedInstance(DerivedInstanceTree node, P p) {\n+        R r = scan(node.getExpression(), p);\n+        r = scanAndReduce(node.getBlock(), p, r);\n+        return r;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -392,0 +392,5 @@\n+    \/**\n+     * Flag to indicate component local variables.\n+     *\/\n+    public static final long COMPONENT_LOCAL_VARIABLE = 1L<<62; \/\/ VarSymbols\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,0 +212,1 @@\n+            case DERIVED_INSTANCE -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+        DERIVED_INSTANCE(JDK23, Fragments.FeatureDerivedInstance, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1766,0 +1766,3 @@\n+            } else if ((flags & COMPONENT_LOCAL_VARIABLE) != 0) {\n+                ElementKind kind = ElementKind.COMPONENT_LOCAL_VARIABLE;\n+                return kind;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3962,0 +3962,39 @@\n+    @Override\n+    public void visitDerivedInstance(JCDerivedInstance tree) {\n+        Type exprType = attribExpr(tree.expr, env);\n+        Env<AttrContext> blockEnv =\n+            env.dup(tree, env.info.dup(env.info.scope.dup()));\n+\n+        try {\n+            ListBuffer<JCVariableDecl> componentLocalVariableDeclaration = new ListBuffer<>();\n+\n+            if ((exprType.tsym.flags() & RECORD) == 0) {\n+                log.error(tree, Errors.DerivedExpressionNoRecord);\n+            } else {\n+                ClassSymbol recordType = (ClassSymbol) exprType.tsym;\n+\n+                for (RecordComponent component : recordType.getRecordComponents()) {\n+                    VarSymbol outgoing = new VarSymbol(COMPONENT_LOCAL_VARIABLE,\n+                                                       component.name,\n+                                                       types.memberType(exprType, component),\n+                                                       env.info.scope.owner);\n+\n+                    outgoing.pos = tree.pos;\n+                    componentLocalVariableDeclaration.append(make.at(tree).VarDef(outgoing, null));\n+                    blockEnv.info.scope.enter(outgoing);\n+                }\n+            }\n+\n+            tree.componentLocalVariableDeclarations = componentLocalVariableDeclaration.toList();\n+\n+            attribStat(tree.block, blockEnv);\n+\n+            chk.checkDerivedInstanceBlockStructure(tree);\n+\n+            result = check(tree, exprType, KindSelector.VAL, resultInfo);;\n+        } finally {\n+            blockEnv.info.scope.leave();\n+        }\n+\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+import java.util.function.Function;\n@@ -4891,0 +4892,89 @@\n+    void checkDerivedInstanceBlockStructure(JCDerivedInstance instance) {\n+        new TreeScanner() {\n+            private final Set<JCTree> seenTrees =\n+                    Collections.newSetFromMap(new IdentityHashMap<>());\n+            private final Set<VarSymbol> seenVariables = new HashSet<>();\n+            @Override\n+            public void scan(JCTree tree) {\n+                seenTrees.add(tree);\n+                super.scan(tree);\n+            }\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                \/\/no limits on the inside of the nested class decl\n+            }\n+            @Override\n+            public void visitReturn(JCReturn tree) {\n+                log.error(tree.pos(), Errors.WithReturnNotAllowed);\n+                super.visitReturn(tree);\n+            }\n+\n+            @Override\n+            public void visitBreak(JCBreak tree) {\n+                if (!seenTrees.contains(tree.target)) {\n+                    log.error(tree.pos(), Errors.WithBreakNotAllowed);\n+                }\n+                super.visitBreak(tree);\n+            }\n+\n+            @Override\n+            public void visitContinue(JCContinue tree) {\n+                if (!seenTrees.contains(tree.target)) {\n+                    log.error(tree.pos(), Errors.WithContinueNotAllowed);\n+                }\n+                super.visitContinue(tree);\n+            }\n+\n+            @Override\n+            public void visitYield(JCYield tree) {\n+                if (!seenTrees.contains(tree.target)) {\n+                    log.error(tree.pos(), Errors.WithYieldNotAllowed);\n+                }\n+                super.visitYield(tree);\n+            }\n+\n+            @Override\n+            public void visitVarDef(JCVariableDecl tree) {\n+                seenVariables.add(tree.sym);\n+                super.visitVarDef(tree);\n+            }\n+            @Override\n+            public void visitAssign(JCAssign tree) {\n+                checkInvalidAssignTarget(tree.lhs);\n+                super.visitAssign(tree);\n+            }\n+\n+            @Override\n+            public void visitAssignop(JCAssignOp tree) {\n+                checkInvalidAssignTarget(tree.lhs);\n+                super.visitAssignop(tree);\n+            }\n+\n+            @Override\n+            public void visitUnary(JCUnary tree) {\n+                switch (tree.getTag()) {\n+                    case PREDEC, PREINC, POSTDEC, POSTINC -> {\n+                        checkInvalidAssignTarget(tree.arg);\n+                    }\n+                }\n+                super.visitUnary(tree);\n+            }\n+\n+            private void checkInvalidAssignTarget(JCTree operand) {\n+                if (operand instanceof JCIdent var &&\n+                    !seenVariables.contains(var.sym)) {\n+                    log.error(var.pos(), Errors.WithAssignmentNotAllowed(var.sym));\n+                }\n+            }\n+\n+            @Override\n+            public void visitDerivedInstance(JCDerivedInstance tree) {\n+                tree.componentLocalVariableDeclarations\n+                    .stream()\n+                    .map(var -> var.sym)\n+                    .forEach(seenVariables::add);\n+                super.visitDerivedInstance(tree);\n+            }\n+        }.scan(instance);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -3213,0 +3213,12 @@\n+        @Override\n+        public void visitDerivedInstance(JCDerivedInstance tree) {\n+            scan(tree.expr);\n+            int nextadrPrev = nextadr;\n+            for (JCVariableDecl component : tree.componentLocalVariableDeclarations) {\n+                newVar(component);\n+                letInit(tree.pos(), component.sym);\n+            }\n+            scan(tree.block);\n+            nextadr = nextadrPrev;\n+        }\n+\n@@ -3455,0 +3467,11 @@\n+        @Override\n+        public void visitDerivedInstance(JCDerivedInstance tree) {\n+            if (declaredInsideGuard != null) {\n+                tree.componentLocalVariableDeclarations\n+                    .stream()\n+                    .map(var -> var.sym)\n+                    .forEach(declaredInsideGuard::enter);\n+            }\n+            super.visitDerivedInstance(tree);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -4443,0 +4443,75 @@\n+    @Override\n+    public void visitDerivedInstance(JCDerivedInstance tree) {\n+        \/\/for record R(C1, C2, ..., Cn), and a derived record creation expression:\n+        \/\/expr with { ...body... }\n+        \/\/generate let expression:\n+        \/\/{\n+        \/\/    R $temp = expr; \/\/skipped if \"expr\" is a local variable\n+        \/\/    typeof(C1) c1 = $temp.c1();\n+        \/\/    typeof(C2) c2 = $temp.c2();\n+        \/\/    ...\n+        \/\/    typeof(Cn) cn = $temp.cn();\n+        \/\/\n+        \/\/    { ...body...}\n+        \/\/\n+        \/\/    \"yield\" new R(c1, c2, ..., cn);\n+        \/\/}\n+        ListBuffer<JCStatement> newBlock = new ListBuffer<>();\n+        VarSymbol temp;\n+        if (tree.expr instanceof JCIdent i &&\n+            i.sym.kind == Kinds.Kind.VAR &&\n+            (i.sym.owner.kind == Kinds.Kind.MTH || i.sym.owner.kind == Kinds.Kind.VAR)) {\n+            temp = (VarSymbol) i.sym;\n+        } else {\n+            temp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(\"expr\" + tree.pos().getPreferredPosition() +\n+                                     target.syntheticNameChar() + \"temp\"),\n+                    tree.expr.type,\n+                    currentMethodSym);\n+            newBlock.add(make.VarDef(temp, translate(tree.expr)));\n+        }\n+\n+\n+        ClassSymbol recordClass = (ClassSymbol) tree.expr.type.tsym;\n+        List<JCVariableDecl> outgoingBindingsIt = tree.componentLocalVariableDeclarations;\n+        List<? extends RecordComponent> recordComponentsIt = recordClass.getRecordComponents();\n+\n+        while (outgoingBindingsIt.nonEmpty()) {\n+            Type erasedComponentType = types.erasure(recordComponentsIt.head.type);\n+            JCVariableDecl var = outgoingBindingsIt.head;\n+\n+            var.init = make.App(make.Select(make.Ident(temp),\n+                                            recordComponentsIt.head.accessor))\n+                           .setType(erasedComponentType);\n+            newBlock.append(var);\n+            outgoingBindingsIt = outgoingBindingsIt.tail;\n+            recordComponentsIt = recordComponentsIt.tail;\n+        }\n+\n+        newBlock.add(translate(tree.block));\n+\n+        JCNewClass createNew = make.NewClass(null,\n+                                             List.nil(),\n+                                             make.QualIdent(recordClass),\n+                                             tree.componentLocalVariableDeclarations.map(decl -> make.Ident(decl.sym)),\n+                                             null);\n+\n+        createNew.type = tree.type;\n+\n+        List<Type> canonicalConstructorTypes =\n+                recordClass.getRecordComponents()\n+                           .stream()\n+                           .map(c -> types.erasure(c.type))\n+                           .collect(List.collector());\n+        MethodSymbol init = rs.resolveInternalMethod(tree.pos(),\n+                                                     attrEnv,\n+                                                     tree.type,\n+                                                     names.init,\n+                                                     canonicalConstructorTypes,\n+                                                     List.nil());\n+        createNew.constructor = init;\n+\n+        result = make.LetExpr(newBlock.toList(), createNew).setType(tree.type);\n+    }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -738,0 +738,8 @@\n+    @Override\n+    public void visitDerivedInstance(JCDerivedInstance tree) {\n+        tree.expr = translate(tree.expr, pt);\n+        tree.block = translate(tree.block);\n+        tree.type = erasure(tree.expr.type);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1234,14 +1234,1 @@\n-                while (code.state.stacksize > 0) {\n-                    Type type = code.state.peek();\n-                    Name varName = names.fromString(target.syntheticNameChar() +\n-                                                    \"stack\" +\n-                                                    target.syntheticNameChar() +\n-                                                    tree.pos +\n-                                                    target.syntheticNameChar() +\n-                                                    code.state.stacksize);\n-                    VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,\n-                                                  this.env.enclMethod.sym);\n-                    LocalItem item = items.new LocalItem(type, code.newLocal(var));\n-                    stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);\n-                    item.store();\n-                }\n+                stackBeforeSwitchExpression = stashStackToLocalVariables(tree);\n@@ -1262,4 +1249,0 @@\n-    \/\/where:\n-        private boolean hasTry(JCSwitchExpression tree) {\n-            class HasTryScanner extends TreeScanner {\n-                private boolean hasTry;\n@@ -1267,4 +1250,3 @@\n-                @Override\n-                public void visitTry(JCTry tree) {\n-                    hasTry = true;\n-                }\n+    private boolean hasTry(JCTree tree) {\n+        class HasTryScanner extends TreeScanner {\n+            private boolean hasTry;\n@@ -1272,4 +1254,4 @@\n-                @Override\n-                public void visitSynchronized(JCSynchronized tree) {\n-                    hasTry = true;\n-                }\n+            @Override\n+            public void visitTry(JCTry tree) {\n+                hasTry = true;\n+            }\n@@ -1277,3 +1259,4 @@\n-                @Override\n-                public void visitClassDef(JCClassDecl tree) {\n-                }\n+            @Override\n+            public void visitSynchronized(JCSynchronized tree) {\n+                hasTry = true;\n+            }\n@@ -1281,4 +1264,8 @@\n-                @Override\n-                public void visitLambda(JCLambda tree) {\n-                }\n-            };\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+            }\n+\n+            @Override\n+            public void visitLambda(JCLambda tree) {\n+            }\n+        };\n@@ -1286,1 +1273,1 @@\n-            HasTryScanner hasTryScanner = new HasTryScanner();\n+        HasTryScanner hasTryScanner = new HasTryScanner();\n@@ -1288,3 +1275,3 @@\n-            hasTryScanner.scan(tree);\n-            return hasTryScanner.hasTry;\n-        }\n+        hasTryScanner.scan(tree);\n+        return hasTryScanner.hasTry;\n+    }\n@@ -1864,2 +1851,1 @@\n-            for (LocalItem li : stackBeforeSwitchExpression)\n-                li.load();\n+            reloadStackFromVariables(stackBeforeSwitchExpression);\n@@ -1868,0 +1854,5 @@\n+    private void reloadStackFromVariables(List<LocalItem> variables) {\n+        for (LocalItem li : variables)\n+            li.load();\n+    }\n+\n@@ -2424,0 +2415,11 @@\n+        List<LocalItem> stashedStack;\n+\n+        if (hasTry(tree)) {\n+            \/\/if the let expression contains try-catch, the catch handlers need to have\n+            \/\/an empty stack. So stash whole stack to local variables, and restore it\n+            \/\/at the end:\n+            stashedStack = stashStackToLocalVariables(tree);\n+        } else {\n+            stashedStack = List.nil();\n+        }\n+\n@@ -2430,0 +2432,1 @@\n+            reloadStackFromVariables(stashedStack);\n@@ -2435,0 +2438,20 @@\n+    private List<LocalItem> stashStackToLocalVariables(JCTree tree) {\n+        List<LocalItem> variables = List.nil();\n+\n+        while (code.state.stacksize > 0) {\n+            Type type = code.state.peek();\n+            Name varName = names.fromString(target.syntheticNameChar() +\n+                                            \"stack\" +\n+                                            target.syntheticNameChar() +\n+                                            tree.pos +\n+                                            target.syntheticNameChar() +\n+                                            code.state.stacksize);\n+            VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,\n+                                          this.env.enclMethod.sym);\n+            LocalItem item = items.new LocalItem(type, code.newLocal(var));\n+            variables = variables.prepend(item);\n+            item.store();\n+        }\n+\n+        return variables;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":62,"deletions":39,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1861,0 +1861,11 @@\n+            } else if (isMode(EXPR) && token.kind == IDENTIFIER &&\n+                       token.name() == names.with && peekToken(LBRACE)) {\n+                int pos = token.pos;\n+\n+                checkSourceLevel(pos, Feature.DERIVED_INSTANCE);\n+\n+                nextToken();\n+\n+                JCBlock block = block();\n+\n+                t = F.at(pos).DerivedInstance(t, block);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3221,0 +3221,3 @@\n+compiler.misc.feature.derived.instance=\\\n+    derived record creation\n+\n@@ -3935,0 +3938,19 @@\n+# 0: symbol\n+compiler.err.with.assignment.not.allowed=\\\n+    assignment to {0} not allowed inside the block of the derived record creation expression\n+\n+compiler.err.with.return.not.allowed=\\\n+    return not allowed inside the block of the derived record creation expression\n+\n+compiler.err.with.break.not.allowed=\\\n+    break statement not allowed to transfer control outside of the block of the derived record creation expression\n+\n+compiler.err.with.continue.not.allowed=\\\n+    continue statement not allowed to transfer control outside of the block of the derived record creation expression\n+\n+compiler.err.with.yield.not.allowed=\\\n+    yield statement not allowed to transfer control outside of the block of the derived record creation expression\n+\n+compiler.err.derived.expression.no.record=\\\n+    the parameter for the derived record creation expression is not a record class\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -228,0 +228,4 @@\n+        \/** Derived record creation expression, of type JCDerivedInstance.\n+         *\/\n+        DERIVEDRECORDCREATION,\n+\n@@ -2045,0 +2049,30 @@\n+    \/**\n+     * A reconstruction subexpression ( ... )\n+     *\/\n+    public static class JCDerivedInstance extends JCExpression implements DerivedInstanceTree {\n+        public JCExpression expr;\n+        public JCBlock block;\n+        public List<JCVariableDecl> componentLocalVariableDeclarations;\n+        protected JCDerivedInstance(JCExpression expr, JCBlock block) {\n+            this.expr = expr;\n+            this.block = block;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitDerivedInstance(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.DERIVED_INSTANCE; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getExpression() { return expr; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCBlock getBlock() { return block; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitDerivedInstance(this, d);\n+        }\n+        @Override\n+        public Tag getTag() {\n+            return DERIVEDRECORDCREATION;\n+        }\n+    }\n+\n@@ -3513,0 +3547,1 @@\n+        public void visitDerivedInstance(JCDerivedInstance that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1479,0 +1479,11 @@\n+    @Override\n+    public void visitDerivedInstance(JCDerivedInstance tree) {\n+        try {\n+            printExpr(tree.expr);\n+            print(\" with \");\n+            printExpr(tree.block);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -351,0 +351,8 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDerivedInstance(DerivedInstanceTree node, P p) {\n+        JCDerivedInstance t = (JCDerivedInstance) node;\n+        JCExpression expr = copy(t.expr, p);\n+        JCBlock block = copy(t.block, p);\n+        return M.at(t.pos).DerivedInstance(expr, block);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -624,0 +624,4 @@\n+            case DERIVEDRECORDCREATION: {\n+                JCDerivedInstance node = (JCDerivedInstance) tree;\n+                return getStartPos(node.expr);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -450,0 +450,6 @@\n+    }\n+\n+    public JCDerivedInstance DerivedInstance(JCExpression expr, JCBlock block) {\n+        JCDerivedInstance tree = new JCDerivedInstance(expr, block);\n+        tree.pos = pos;\n+        return tree;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -279,0 +279,5 @@\n+    public void visitDerivedInstance(JCDerivedInstance tree) {\n+        scan(tree.expr);\n+        scan(tree.block);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -327,0 +327,7 @@\n+    @Override\n+    public void visitDerivedInstance(JCDerivedInstance tree) {\n+        tree.expr = translate(tree.expr);\n+        tree.block = translate(tree.block);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+        \"var v = a with { i = 0; };\",\n@@ -92,1 +93,2 @@\n-        \"record.length()\"\n+        \"record.length()\",\n+        \"a with { i = 0; }\",\n@@ -135,0 +137,1 @@\n+        \"var v = a with { i = 0; }\",\n@@ -232,0 +235,1 @@\n+        \"a with {\",\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324651\n+ * @summary Support for derived record creation expression in JShell\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jshell\n+ * @build Compiler KullaTesting TestingInputStream ExpectedDiagnostic\n+ * @run testng DerivedRecordCreationTest\n+ *\/\n+\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+\n+@Test\n+public class DerivedRecordCreationTest extends KullaTesting {\n+\n+    public void derivedRecordInVarInit() {\n+        assertEval(\"record A(int i) {}\");\n+        assertEval(\"var v1 = new A(0);\");\n+        assertEval(\"var v2 = v1 with { i = -1; };\");\n+        assertEval(\"v2\", \"A[i=-1]\");\n+    }\n+\n+    public void derivedRecordInClass() {\n+        assertEval(\"record A(int i) {}\");\n+        assertEval(\"\"\"\n+                   class Test {\n+                       public static A test(A arg) {\n+                           A a = arg with {\n+                               i = 32;\n+                           };\n+                           return a;\n+                       }\n+                   }\n+                   \"\"\");\n+    }\n+\n+    @BeforeMethod\n+    public void setUp() {\n+        setUp(bc -> bc.compilerOptions(\"--enable-preview\",\n+                                       \"--source\", System.getProperty(\"java.specification.version\"))\n+                      .remoteVMOptions(\"--enable-preview\"));\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/DerivedRecordCreationTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.derived.expression.no.record\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class DerivedExpressionNoRecord {\n+    Object test(Object o) {\n+        return o with { };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DerivedExpressionNoRecord.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.derived.instance\n+\/\/ key: compiler.err.preview.feature.disabled\n+\/\/ options: --release 22\n+\n+class FeatureDerivedInstance {\n+    R test(R r) {\n+        return r with {\n+            value = \"\";\n+        };\n+    }\n+\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureDerivedInstance.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.assignment.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithAssignmentNotAllowed {\n+    R test(R r) {\n+        int i;\n+        return r with {\n+            i = 0;\n+        };\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithAssignmentNotAllowed.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.break.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithBreakNotAllowed {\n+    void test(R r) {\n+        while (true) {\n+            r = r with {\n+                break;\n+            };\n+        }\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithBreakNotAllowed.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.continue.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithContinueNotAllowed {\n+    void test(R r) {\n+        while (true) {\n+            r = r with {\n+                continue;\n+            };\n+        }\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithContinueNotAllowed.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.return.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithReturnNotAllowed {\n+    R test(R r) {\n+        r = r with {\n+            return r;\n+        };\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithReturnNotAllowed.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.yield.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithYieldNotAllowed {\n+    R test(R r) {\n+        return switch(0) {\n+            default -> r with {\n+                yield r;\n+            };\n+        };\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithYieldNotAllowed.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @enablePreview\n+ * @compile Exceptions.java\n+ * @run main Exceptions\n+ *\/\n+public class Exceptions {\n+    public static void main(String... args) {\n+        R r;\n+        r = new R(\"\", \"a\");\n+        try {\n+            r = r with {\n+                throw new AssertionError(\"Should not get here!\");\n+            };\n+        } catch (Intentional ex) {\n+            if (!\"s1\".equals(ex.getMessage())) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        r = new R(\"a\", \"\");\n+        try {\n+            r = r with {\n+                throw new AssertionError(\"Should not get here!\");\n+            };\n+        } catch (Intentional ex) {\n+            if (!\"s2\".equals(ex.getMessage())) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        r = new R(\"a\", \"a\");\n+        try {\n+            r = r with {\n+                throw new Intentional(\"in body\");\n+            };\n+        } catch (Intentional ex) {\n+            if (!\"in body\".equals(ex.getMessage())) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        try {\n+            keepOnStack(0, r with {\n+                try {\n+                    throw new Intentional(\"in body\");\n+                } catch (Intentional ex) {\n+                    \/\/ignored...\n+                }\n+            });\n+        } catch (Intentional ex) {\n+            if (!\"in body\".equals(ex.getMessage())) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        r = null;\n+        try {\n+            r = r with {};\n+            throw new AssertionError(\"Should not get here!\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    private static void keepOnStack(int value, R r) { }\n+\n+    record R(String s1, String s2) {\n+\n+        public String s1() {\n+            if (s1.isEmpty()) {\n+                throw new Intentional(\"s1\");\n+            }\n+            return s1;\n+        }\n+\n+        public String s2() {\n+            if (s2.isEmpty()) {\n+                throw new Intentional(\"s2\");\n+            }\n+            return s2;\n+        }\n+\n+    }\n+\n+    public static class Intentional extends RuntimeException {\n+\n+        public Intentional(String msg) {\n+            super(msg);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/Exceptions.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8324651\n+ * @summary Verify separate compilation works w.r.t. derived record creation expression\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main SeparateCompilation\n+*\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+public class SeparateCompilation extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new SeparateCompilation().runTests();\n+    }\n+\n+    SeparateCompilation() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testPattern(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"record A(int i) {}\",\n+                          \"\"\"\n+                          class Test {\n+                              public static A test(A arg) {\n+                                  A a = arg with {\n+                                      i = 32;\n+                                  };\n+                                  return a;\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"--release\", System.getProperty(\"java.specification.version\"))\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src.resolve(\"A.java\")))\n+            .run()\n+            .writeAll();\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\",\n+                     \"--release\", System.getProperty(\"java.specification.version\"))\n+            .classpath(classes.toString())\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src.resolve(\"Test.java\")))\n+            .run()\n+            .writeAll();\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/SeparateCompilation.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8324651\n+ * @summary Support for derived record creation expression\n+ * @enablePreview\n+ * @compile SimpleWithers.java\n+ * @run main SimpleWithers\n+ *\/\n+public class SimpleWithers {\n+    public static void main(String... args) {\n+        R r = new R(1, 2, 3);\n+        r = r with {\n+            val1 = -1;\n+            val3 = -3;\n+        };\n+        if (r.val1() != (-1) ||\n+            r.val2() != 2 ||\n+            r.val3() != (-3)) {\n+            throw new AssertionError(\"Incorrect value: \" + r);\n+        }\n+        R rp = r;\n+        boolean match = switch (rp) {\n+            case R(var i1, var i2, var i3) when rp with {\n+                val1 = -1;\n+                val3 = -3;\n+            }.val1() == -1 -> true;\n+            default -> false;\n+        };\n+        if (!match) {\n+            throw new AssertionError(\"Did not match.\");\n+        }\n+        \/\/shadowing:\n+        R2 r2 = new R2(r);\n+        R2 r2p = r2 with {\n+            val1 = val1 with {\n+                val1 = -2;\n+                val3 = -6;\n+            };\n+        };\n+        if (r2p.val1().val1() != (-2) ||\n+            r2p.val1().val2() != 2 ||\n+            r2p.val1().val3() != (-6)) {\n+            throw new AssertionError(\"Incorrect value: \" + r);\n+        }\n+        {\n+            int val1 = 0;\n+            if (r with {\n+                    val1 = -3;\n+                } instanceof R(var v1, var v2, var v3) && v1 != (-3)) {\n+                throw new AssertionError(\"Incorrect value: \" + v1);\n+            }\n+        }\n+        if (r instanceof R(var val1, var val2, var val3) && r with {\n+                val1 = -4;\n+            } instanceof R(var v1, var v2, var v3) && v1 != (-4)) {\n+            throw new AssertionError(\"Incorrect value: \" + v1);\n+        }\n+        C c = l -> l with {\n+            val1 = -5;\n+            val3 = -6;\n+        };\n+        \/\/component local variables may shadow:\n+        int val1 = 0, val2 = 0, val3 = 0;\n+        if (r with {\n+                val1 = -7;\n+                val2 = -8;\n+                val3 = -9;\n+            } instanceof R(var v1, var v2, var v3) && v1 != (-7)) {\n+            throw new AssertionError(\"Incorrect value: \" + v1);\n+        }\n+        if (r2 with {\n+                val1 = val1 with { val1 = -10; };\n+            } instanceof R2(R(var v, _, _)) && v != (-10)) {\n+            throw new AssertionError(\"Incorrect value: \" + v);\n+        }\n+        \/\/the values are definitelly assigned:\n+        r = new R(0, 0, 0);\n+        if (r with {\n+                val1++;\n+                val2 += 2;\n+                val3 = val3 + 3;\n+            } instanceof R(var v1, var v2, var v3) && (v1 != 1 || v2 != 2 || v3 != 3)) {\n+            throw new AssertionError(\"Incorrect value(s): \" + v1 + \", \" + v2 + \", \" + v3);\n+        }\n+        R3<String> r3 = new R3<>(\"\");\n+        if (r3 with {\n+                t = \"new\";\n+            } instanceof R3(var t) && !\"new\".equals(t)) {\n+            throw new AssertionError(\"Incorrect value: \" + t);\n+        }\n+    }\n+\n+    record R(int val1, int val2, int val3) {}\n+    record R2(R val1) {}\n+    record R3<T>(T t) {}\n+    interface C {\n+        R apply(R r);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/SimpleWithers.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8324651\n+ * @summary Support for derived record creation expression\n+ * @compile\/fail\/ref=SourceLevelCheck.out --release 22 -XDrawDiagnostics SourceLevelCheck.java\n+ *\/\n+public class SourceLevelCheck {\n+    public static void main(String... args) {\n+        R r = new R(0);\n+        r = r with {\n+            val = -1;\n+        };\n+    }\n+    record R(int val) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/SourceLevelCheck.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+SourceLevelCheck.java:10:15: compiler.err.preview.feature.disabled: (compiler.misc.feature.derived.instance)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/SourceLevelCheck.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,243 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8324651\n+ * @summary Support for derived record creation expression\n+ * @enablePreview\n+ * @compile\/fail\/ref=WithErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW WithErrors.java\n+ *\/\n+\n+import java.util.List;\n+\n+public class WithErrors {\n+\n+    private int field;\n+\n+    private void assignments(R input) {\n+        int i = 0;\n+\n+        input = input with {\n+            int l;\n+\n+            value = \"nue\"; \/\/OK - assignment to the component\n+            i = ++i + i++ + --i + i-- + -i + +i; \/\/error - assignment to outter variable\n+            i += 1; \/\/error - (compound) assignment to outter variable\n+            field = 0; \/\/error - unqualified assignment to field\n+            this.field = 0; \/\/ OK - qualified assignment\n+            l = 0; \/\/OK - assignment to a variable local to the block\n+        };\n+\n+        input = input with {\n+            int l1;\n+            Runnable _ = () -> {\n+                int l2;\n+\n+                value = \"nue\"; \/\/error - cannot assign inside lambda\n+                i = 0; \/\/error - assignment to outter variable, and inside lambda\n+                i += 1; \/\/error - (compound) assignment to outter variable\n+                field = 0; \/\/error - unqualified assignment to field\n+                this.field = 0; \/\/ OK - qualified assignment\n+                l1 = 0; \/\/error - cannot assign inside lambda\n+                l2 = 0; \/\/OK - assignment to a variable local to the block\n+            };\n+        };\n+\n+        input = input with {\n+            Runnable _ = () -> {\n+                String _ = value; \/\/error - \"value\" is not effectivelly final\n+            };\n+            value = \"nue\";\n+        };\n+\n+        input = input with {\n+            Runnable _ = () -> {\n+                String _ = value; \/\/OK - \"value\" is effectivelly final\n+            };\n+        };\n+\n+        input = input with {\n+            int l1;\n+            Runnable _ = new Runnable() {\n+                public void run () {\n+                    int l2;\n+\n+                    value = \"nue\"; \/\/error - cannot assign inside the anonymous class\n+                    i = 0; \/\/error - cannot assign inside the anonymous class\n+                    field = 0; \/\/OK - assignment to outer field from inside the anonymous class\n+                    WithErrors.this.field = 0; \/\/ OK - qualified assignment\n+                    l1 = 0; \/\/error - cannot assign inside lambda\n+                    l2 = 0; \/\/OK - assignment to a variable local to this block\/method\n+                }\n+            };\n+        };\n+\n+        input = input with {\n+            Runnable _ = new Runnable() {\n+                public void run () {\n+                    String _ = value; \/\/error - \"value\" is not effectivelly final\n+                }\n+            };\n+            value = \"nue\";\n+        };\n+\n+        input = input with {\n+            Runnable _ = new Runnable() {\n+                public void run () {\n+                    String _ = value; \/\/OK - \"value\" is effectivelly final\n+                }\n+            };\n+        };\n+\n+        String _ = \"\" with {};\n+        int _ = 1 with {};\n+    }\n+\n+    private void controlFlow(R input) {\n+        if (true) {\n+            input = input with {\n+                return ;\n+            };\n+        }\n+\n+        for (;;) {\n+            input = input with {\n+                break;\n+            };\n+        }\n+\n+        input = input with {\n+            for (;;) {\n+                break;\n+            }\n+        };\n+\n+        for (String s : List.of(\"\")) {\n+            input = input with {\n+                break;\n+            };\n+        }\n+\n+        input = input with {\n+            for (String s : List.of(\"\")) {\n+                break;\n+            }\n+        };\n+\n+        while (true) {\n+            input = input with {\n+                break;\n+            };\n+        }\n+\n+        input = input with {\n+            while (true) {\n+                break;\n+            }\n+        };\n+\n+        do {\n+            input = input with {\n+                break;\n+            };\n+        } while (true);\n+\n+        input = input with {\n+            do {\n+                break;\n+            } while (true);\n+        };\n+\n+        switch (0) {\n+            default ->\n+                input = input with {\n+                    break;\n+                };\n+        }\n+\n+        input = input with {\n+            switch (0) {\n+                default -> {break;}\n+            }\n+        };\n+\n+        if (true) {\n+            for (;;) {\n+                input = input with {\n+                    continue;\n+                };\n+            }\n+        }\n+\n+        if (true) {\n+            input = input with {\n+                for (;;) {\n+                    continue;\n+                }\n+            };\n+        }\n+\n+        if (true) {\n+            for (String s : List.of(\"\")) {\n+                input = input with {\n+                    continue;\n+                };\n+            }\n+        }\n+\n+        if (true) {\n+            input = input with {\n+                for (String s : List.of(\"\")) {\n+                    continue;\n+                }\n+            };\n+        }\n+\n+        if (true) {\n+            while (true) {\n+                input = input with {\n+                    continue;\n+                };\n+            }\n+        }\n+\n+        if (true) {\n+            input = input with {\n+                while (true) {\n+                    continue;\n+                }\n+            };\n+        }\n+\n+        if (true) {\n+            do {\n+                input = input with {\n+                    continue;\n+                };\n+            } while (true);\n+        }\n+\n+        if (true) {\n+            input = input with {\n+                do {\n+                    continue;\n+                } while (true);\n+            };\n+        }\n+\n+        int _ = switch (0) {\n+            default -> {\n+                input = input with {\n+                    yield 0;\n+                };\n+            }\n+        };\n+\n+        input = input with {\n+            int _ = switch (0) {\n+                default -> { yield 0; }\n+            };\n+        };\n+    }\n+\n+    record R(String value) {}\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/WithErrors.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+WithErrors.java:22:13: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:22:19: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:22:23: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:22:31: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:22:35: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:23:13: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:24:13: compiler.err.with.assignment.not.allowed: field\n+WithErrors.java:35:17: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:36:17: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:37:17: compiler.err.with.assignment.not.allowed: field\n+WithErrors.java:90:23: compiler.err.derived.expression.no.record\n+WithErrors.java:91:19: compiler.err.derived.expression.no.record\n+WithErrors.java:97:17: compiler.err.with.return.not.allowed\n+WithErrors.java:103:17: compiler.err.with.break.not.allowed\n+WithErrors.java:115:17: compiler.err.with.break.not.allowed\n+WithErrors.java:127:17: compiler.err.with.break.not.allowed\n+WithErrors.java:139:17: compiler.err.with.break.not.allowed\n+WithErrors.java:152:21: compiler.err.with.break.not.allowed\n+WithErrors.java:165:21: compiler.err.with.continue.not.allowed\n+WithErrors.java:181:21: compiler.err.with.continue.not.allowed\n+WithErrors.java:197:21: compiler.err.with.continue.not.allowed\n+WithErrors.java:213:21: compiler.err.with.continue.not.allowed\n+WithErrors.java:229:21: compiler.err.with.yield.not.allowed\n+WithErrors.java:34:17: compiler.err.cant.ref.non.effectively.final.var: value, (compiler.misc.lambda)\n+WithErrors.java:39:17: compiler.err.cant.ref.non.effectively.final.var: l1, (compiler.misc.lambda)\n+WithErrors.java:46:28: compiler.err.cant.ref.non.effectively.final.var: value, (compiler.misc.lambda)\n+WithErrors.java:63:21: compiler.err.cant.ref.non.effectively.final.var: value, (compiler.misc.inner.cls)\n+WithErrors.java:64:21: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.inner.cls)\n+WithErrors.java:67:21: compiler.err.cant.ref.non.effectively.final.var: l1, (compiler.misc.inner.cls)\n+WithErrors.java:76:32: compiler.err.cant.ref.non.effectively.final.var: value, (compiler.misc.inner.cls)\n+- compiler.note.preview.filename: WithErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+30 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/WithErrors.out","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8324651\n+ * @summary Support for derived record creation expression\n+ * @enablePreview\n+ * @compile WithPriority.java\n+ * @run main WithPriority\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class WithPriority {\n+    public static void main(String... args) {\n+        new WithPriority().run();\n+    }\n+\n+    private void run() {\n+        assertEquals(new R(\"true\"), ternary(true, new R(\"\")));\n+        assertEquals(new R(\"false\"), ternary(false, new R(\"\")));\n+        assertEquals(new R(\"nue\"), new R(\"\") with { value = \"nue\"; });\n+        assertEquals(\"nue\", new R(\"\") with { value = \"nue\"; }.value());\n+    }\n+\n+    private R ternary(boolean c, R input) {\n+        R trueInput = input with { value = \"true\"; };\n+        return c ? trueInput : input with { value = \"false\"; };\n+    }\n+\n+    private void forWithDisambiguation(String[] values) {\n+        for (var with : values) {}\n+        for (int with = 0; ;) {}\n+    }\n+\n+    record R(String value) {}\n+\n+    private static void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/WithPriority.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8222430 8282411\n+ * @bug 8222430 8282411 8329556\n@@ -97,1 +97,2 @@\n-                                       ElementKind.BINDING_VARIABLE).contains(k),\n+                                       ElementKind.BINDING_VARIABLE,\n+                                       ElementKind.COMPONENT_LOCAL_VARIABLE).contains(k),\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestElementKindPredicates.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8140442 8324651\n+ * @enablePreview\n+ * @summary Test ElementKindVisitorX w.r.t. component local variable\n+ * @library \/tools\/javac\/lib\n+ * @build   JavacTestingAbstractProcessor TestElementVisitorsForComponentVariables\n+ * @compile -J--enable-preview -processor TestElementVisitorsForComponentVariables -proc:only TestElementVisitorsForComponentVariables.java\n+ *\/\n+\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import java.util.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.*;\n+\n+\/**\n+ * Test basic workings ElementKindVisitorX with regards to component\n+ * local variables.\n+ *\/\n+public class TestElementVisitorsForComponentVariables extends JavacTestingAbstractProcessor {\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            TypeElement outer = eltUtils.getTypeElement(\"Outer\");\n+            Element componentVariable = findComponentLocalVariable(outer);\n+\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor6<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor7<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor8<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor9<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitor14<>() {\n+                @Override\n+                public Void visitUnknown(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+            checkExceptionThrown(componentVariable, new ElementKindVisitorPreview<>() {\n+                @Override\n+                protected Void defaultAction(Element e, Void p) {\n+                    throw new DefaultAction();\n+                }\n+            });\n+\n+            boolean[] seenComponentVariable = new boolean[1];\n+\n+            new ElementKindVisitorPreview<Void, Void>() {\n+                @Override\n+                public Void visitVariableAsComponentLocalVariable(VariableElement e, Void p) {\n+                    seenComponentVariable[0] = true;\n+                    return null; \/\/OK\n+                }\n+                @Override\n+                protected Void defaultAction(Element e, Void p) {\n+                    throw new RuntimeException(\"Should not get here!\");\n+                }\n+            }.visit(componentVariable, null);\n+        }\n+        return true;\n+    }\n+\n+    private Element findComponentLocalVariable(Element root) {\n+        Trees trees = Trees.instance(processingEnv);\n+        TreePath topLevelPath = trees.getPath(root);\n+        Element[] componentLocalVariable = new Element[1];\n+        new TreePathScanner<Void, Void>() {\n+            @Override\n+            public Void visitIdentifier(IdentifierTree node, Void p) {\n+                Element el = trees.getElement(getCurrentPath());\n+\n+                if (el != null && el.getKind() == ElementKind.COMPONENT_LOCAL_VARIABLE) {\n+                    componentLocalVariable[0] = el;\n+                }\n+\n+                return super.visitIdentifier(node, p);\n+            }\n+\n+        }.scan(topLevelPath, null);\n+\n+        if (componentLocalVariable[0] == null) {\n+            throw new RuntimeException(\"Cannot find component variable.\");\n+        }\n+\n+        return componentLocalVariable[0];\n+    }\n+\n+    private void checkExceptionThrown(Element componentLocalVariable,\n+                                      ElementKindVisitor6<Void, Void> v) {\n+        try {\n+            v.visit(componentLocalVariable);\n+            throw new RuntimeException(\"Should have thrown an exception.\");\n+        } catch (DefaultAction ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    private static class DefaultAction extends RuntimeException {}\n+}\n+\n+class Outer {\n+    private void nested() {\n+        record R(int i) {}\n+        R r = null;\n+        r = r with { i = 0; };\n+        new Runnable() {\n+            public void run() {}\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestElementVisitorsForComponentVariables.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,1 +31,1 @@\n- * @compile -processor TestOutermostTypeElement -proc:only TestOutermostTypeElement.java\n+ * @compile -J--enable-preview -processor TestOutermostTypeElement -proc:only TestOutermostTypeElement.java\n@@ -33,1 +34,11 @@\n-import java.io.Writer;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.DerivedInstanceTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n@@ -47,0 +58,1 @@\n+            Trees trees = Trees.instance(processingEnv);\n@@ -65,0 +77,4 @@\n+\n+                var treeBasedScanner = new OuterTreeBaseScanner();\n+                treeBasedScanner.scan(e, vacuousElts);\n+                treeBasedScanner.scan(e, eltUtils);\n@@ -93,0 +109,72 @@\n+\n+    private class OuterTreeBaseScanner extends TreePathScanner<Void, Elements> {\n+        private final Trees trees;\n+        private TypeElement topLevel;\n+\n+        public OuterTreeBaseScanner() {\n+            this.trees = Trees.instance(processingEnv);\n+        }\n+\n+        public void scan(TypeElement el, Elements elts) {\n+            TreePath topLevelPath = trees.getPath(el);\n+\n+            topLevel = el;\n+            scan(topLevelPath, elts);\n+        }\n+\n+        @Override\n+        public Void visitClass(ClassTree node, Elements p) {\n+            handleDeclaration(p);\n+            return super.visitClass(node, p);\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Elements p) {\n+            handleDeclaration(p);\n+            return super.visitVariable(node, p);\n+        }\n+\n+        @Override\n+        public Void visitMethod(MethodTree node, Elements p) {\n+            handleDeclaration(p);\n+            return super.visitMethod(node, p);\n+        }\n+\n+        @Override\n+        public Void visitDerivedInstance(DerivedInstanceTree node, Elements p) {\n+            for (StatementTree st : node.getBlock().getStatements()) {\n+                if (st.getKind() == Kind.EXPRESSION_STATEMENT) {\n+                    ExpressionStatementTree est = (ExpressionStatementTree) st;\n+\n+                    if (est.getExpression().getKind() == Kind.ASSIGNMENT) {\n+                        AssignmentTree at = (AssignmentTree) est.getExpression();\n+                        TreePath left = TreePath.getPath(getCurrentPath(), at.getVariable());\n+                        Element componentVariable = trees.getElement(left);\n+\n+                        assertNotNull(componentVariable);\n+\n+                        if (componentVariable.getKind() != ElementKind.COMPONENT_LOCAL_VARIABLE) {\n+                            throw new RuntimeException(\"Unexpected variable kind: \" + componentVariable.getKind());\n+                        }\n+\n+                        checkOuter(componentVariable, topLevel, p);\n+                    }\n+                }\n+            }\n+\n+            return super.visitDerivedInstance(node, p);\n+        }\n+\n+        private void handleDeclaration(Elements els) {\n+            Element el = trees.getElement(getCurrentPath());\n+\n+            assertNotNull(el);\n+            checkOuter(el, topLevel, els);\n+        }\n+\n+        private static void assertNotNull(Object o) {\n+            if (o == null) {\n+                throw new RuntimeException(\"Unexpected null value.\");\n+            }\n+        }\n+    }\n@@ -124,0 +212,14 @@\n+\n+        private void nested() {\n+            int i = 0;\n+            try (AutoCloseable a = null) {\n+                boolean b = a instanceof Runnable r;\n+            } catch (Exception ex) {\n+            }\n+            record R(int i) {}\n+            R r = null;\n+            r = r with { i = 0; };\n+            new Runnable() {\n+                public void run() {}\n+            };\n+        }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestOutermostTypeElement.java","additions":105,"deletions":3,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324651\n+ * @summary Verify the Trees model for derived record creation expression\n+ * @library \/tools\/javac\/lib\n+ * @enablePreview\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ * @build JavacTestingAbstractProcessor\n+ * @compile WithExpressions.java\n+ * @compile\/ref=WithExpressions.out -J--enable-preview -processor WithExpressions -XDshould-stop.at=FLOW -XDrawDiagnostics WithExpressions.java\n+ *\/\n+\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.util.TreePath;\n+import java.util.Set;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DerivedInstanceTree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.SourcePositions;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import javax.lang.model.element.ElementKind;\n+\n+public class WithExpressions extends JavacTestingAbstractProcessor {\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (roundEnv.processingOver()) {\n+            JavacTask.instance(processingEnv).addTaskListener(new TaskListener() {\n+                @Override\n+                public void finished(TaskEvent e) {\n+                    if (e.getKind() == TaskEvent.Kind.ANALYZE) {\n+                        performCheck(e.getCompilationUnit());\n+                    }\n+                }\n+            });\n+        }\n+        return false;\n+    }\n+\n+    private void performCheck(CompilationUnitTree cut) {\n+        Trees trees = Trees.instance(processingEnv);\n+        SourcePositions sp = trees.getSourcePositions();\n+\n+        new TreePathScanner<Void, Void>() {\n+            @Override\n+            public Void visitDerivedInstance(DerivedInstanceTree node, Void p) {\n+                System.err.println(\"visitDerivedInstance start\");\n+                try {\n+                    int start = (int) sp.getStartPosition(cut, node);\n+                    int end = (int) sp.getEndPosition(cut, node);\n+                    System.err.println(node.toString());\n+                    System.err.println(cut.getSourceFile()\n+                                          .getCharContent(true)\n+                                          .subSequence(start, end));\n+                    return super.visitDerivedInstance(node, p);\n+                } catch (IOException ex) {\n+                    throw new RuntimeException(ex);\n+                } finally {\n+                    System.err.println(\"visitDerivedInstance end\");\n+                }\n+            }\n+\n+            @Override\n+            public Void visitAssignment(AssignmentTree node, Void p) {\n+                Element varEl = trees.getElement(new TreePath(new TreePath(getCurrentPath(), node), node.getVariable()));\n+                if (varEl.getKind() == ElementKind.COMPONENT_LOCAL_VARIABLE) {\n+                    System.err.println(varEl.getSimpleName());\n+                }\n+                return super.visitAssignment(node, p);\n+            }\n+        }.scan(cut, null);\n+    }\n+\n+    private static void test() {\n+        record R(String val1, Integer val2) {}\n+        R r = new R(\"\", 0);\n+        r = r with {\n+            val1 = \"a\";\n+            val2 = -1;\n+        };\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/tree\/WithExpressions.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+visitDerivedInstance start\n+r with {\n+    val1 = \"a\";\n+    val2 = -1;\n+}\n+r with {\n+            val1 = \"a\";\n+            val2 = -1;\n+        }\n+val1\n+val2\n+visitDerivedInstance end\n+- compiler.note.preview.filename: WithExpressions.java, DEFAULT\n+- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/tree\/WithExpressions.out","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -95,0 +95,1 @@\n+                                \"java.base\/jdk.internal.javac\",\n","filename":"test\/langtools\/tools\/jdeps\/listdeps\/ListModuleDeps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}