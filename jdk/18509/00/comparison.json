{"files":[{"patch":"@@ -84,0 +84,2 @@\n+        @JEP(number=468, title=\"Derived Record Creation\", status=\"Preview\")\n+        DERIVED_RECORD_CREATION,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -124,1 +126,8 @@\n-    BINDING_VARIABLE;\n+    BINDING_VARIABLE,\n+\n+    \/**\n+     * A local component variable in a derived record creation expression.\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    COMPONENT_LOCAL_VARIABLE;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ElementKind.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A tree node for a derived record creation expression.\n+ *\n+ * For example:\n+ * <pre>\n+ *   <em>expression<\/em> with { <em>assignments<\/em> }\n+ * <\/pre>\n+ *\n+ * @jls 15.30 Derived Record Creation Expression\n+ *\n+ * @since 23\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+public interface DerivedInstanceTree extends ExpressionTree {\n+    \/**\n+     * {@return the origin expression of the derived record creation expression.}\n+     *\/\n+    ExpressionTree getExpression();\n+\n+    \/**\n+     * {@return the reconstruction block.}\n+     *\/\n+    BlockTree getBlock();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DerivedInstanceTree.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,0 +231,7 @@\n+        \/**\n+         * Used for instances of {@link DerivedInstanceTree}.\n+         * @since 23\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+        DERIVED_INSTANCE(DerivedInstanceTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -382,0 +382,10 @@\n+    \/**\n+     * Visits a {@code DerivedInstanceTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    R visitDerivedInstance(DerivedInstanceTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -547,0 +547,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 23\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    public R visitDerivedInstance(DerivedInstanceTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -672,0 +672,18 @@\n+     * @return the result of scanning\n+     * @since 23\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.DERIVED_RECORD_CREATION, reflective=true)\n+    public R visitDerivedInstance(DerivedInstanceTree node, P p) {\n+        R r = scan(node.getExpression(), p);\n+        r = scanAndReduce(node.getBlock(), p, r);\n+        return r;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -392,0 +392,5 @@\n+    \/**\n+     * Flag to indicate component local variables.\n+     *\/\n+    public static final long COMPONENT_LOCAL_VARIABLE = 1L<<62; \/\/ VarSymbols\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,0 +213,1 @@\n+            case DERIVED_INSTANCE -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+        DERIVED_INSTANCE(JDK23, Fragments.FeatureDerivedInstance, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1766,0 +1766,3 @@\n+            } else if ((flags & COMPONENT_LOCAL_VARIABLE) != 0) {\n+                ElementKind kind = ElementKind.COMPONENT_LOCAL_VARIABLE;\n+                return kind;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -3966,0 +3966,39 @@\n+    @Override\n+    public void visitReconstruction(JCDerivedInstance tree) {\n+        Type exprType = attribExpr(tree.expr, env);\n+        Env<AttrContext> blockEnv =\n+            env.dup(tree, env.info.dup(env.info.scope.dup()));\n+\n+        try {\n+            ListBuffer<VarSymbol> componentLocalVariables = new ListBuffer<>();\n+\n+            if ((exprType.tsym.flags() & RECORD) == 0) {\n+                log.error(tree, Errors.DerivedExpressionNoRecord);\n+            } else {\n+                ClassSymbol recordType = (ClassSymbol) exprType.tsym;\n+\n+                for (RecordComponent component : recordType.getRecordComponents()) {\n+                    VarSymbol outgoing = new VarSymbol(COMPONENT_LOCAL_VARIABLE,\n+                                                       component.name,\n+                                                       types.memberType(exprType, component),\n+                                                       env.info.scope.owner);\n+\n+                    outgoing.pos = tree.pos;\n+                    componentLocalVariables.append(outgoing);\n+                    blockEnv.info.scope.enter(outgoing);\n+                }\n+            }\n+\n+            tree.componentLocalVariables = componentLocalVariables.toList();\n+\n+            attribStat(tree.block, blockEnv);\n+\n+            chk.checkDerivedInstanceBlockStructure(tree);\n+\n+            result = check(tree, exprType, KindSelector.VAL, resultInfo);;\n+        } finally {\n+            blockEnv.info.scope.leave();\n+        }\n+\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,1 @@\n+import java.util.function.Function;\n@@ -4911,0 +4912,86 @@\n+    void checkDerivedInstanceBlockStructure(JCDerivedInstance instance) {\n+        new TreeScanner() {\n+            private final Set<JCTree> seenTrees =\n+                    Collections.newSetFromMap(new IdentityHashMap<>());\n+            private final Set<VarSymbol> seenVariables = new HashSet<>();\n+            @Override\n+            public void scan(JCTree tree) {\n+                seenTrees.add(tree);\n+                super.scan(tree);\n+            }\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                \/\/no limits on the inside of the nested class decl\n+            }\n+            @Override\n+            public void visitReturn(JCReturn tree) {\n+                log.error(tree.pos(), Errors.WithReturnNotAllowed);\n+                super.visitReturn(tree);\n+            }\n+\n+            @Override\n+            public void visitBreak(JCBreak tree) {\n+                if (!seenTrees.contains(tree.target)) {\n+                    log.error(tree.pos(), Errors.WithBreakNotAllowed);\n+                }\n+                super.visitBreak(tree);\n+            }\n+\n+            @Override\n+            public void visitContinue(JCContinue tree) {\n+                if (!seenTrees.contains(tree.target)) {\n+                    log.error(tree.pos(), Errors.WithContinueNotAllowed);\n+                }\n+                super.visitContinue(tree);\n+            }\n+\n+            @Override\n+            public void visitYield(JCYield tree) {\n+                if (!seenTrees.contains(tree.target)) {\n+                    log.error(tree.pos(), Errors.WithYieldNotAllowed);\n+                }\n+                super.visitYield(tree);\n+            }\n+\n+            @Override\n+            public void visitVarDef(JCVariableDecl tree) {\n+                seenVariables.add(tree.sym);\n+                super.visitVarDef(tree);\n+            }\n+            @Override\n+            public void visitAssign(JCAssign tree) {\n+                checkInvalidAssignTarget(tree.lhs);\n+                super.visitAssign(tree);\n+            }\n+\n+            @Override\n+            public void visitAssignop(JCAssignOp tree) {\n+                checkInvalidAssignTarget(tree.lhs);\n+                super.visitAssignop(tree);\n+            }\n+\n+            @Override\n+            public void visitUnary(JCUnary tree) {\n+                switch (tree.getTag()) {\n+                    case PREDEC, PREINC, POSTDEC, POSTINC -> {\n+                        checkInvalidAssignTarget(tree.arg);\n+                    }\n+                }\n+                super.visitUnary(tree);\n+            }\n+\n+            private void checkInvalidAssignTarget(JCTree operand) {\n+                if (operand instanceof JCIdent var &&\n+                    !seenVariables.contains(var.sym)) {\n+                    log.error(var.pos(), Errors.WithAssignmentNotAllowed(var.sym));\n+                }\n+            }\n+\n+            @Override\n+            public void visitReconstruction(JCDerivedInstance tree) {\n+                seenVariables.addAll(tree.componentLocalVariables);\n+                super.visitReconstruction(tree);\n+            }\n+        }.scan(instance);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":88,"deletions":1,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2114,1 +2114,2 @@\n-        \/** A mapping from addresses to variable symbols.\n+        \/** A mapping from addresses to variable symbols, and their diagnostic\n+         *  position.\n@@ -2116,1 +2117,2 @@\n-        protected JCVariableDecl[] vardecls;\n+        protected VarSymbol[] vars;\n+        protected JCTree[]    vardecls;\n@@ -2184,1 +2186,1 @@\n-                    if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {\n+                    if (!(isFinalUninitializedStaticField(vars[address]))) {\n@@ -2219,1 +2221,9 @@\n-            VarSymbol sym = varDecl.sym;\n+            newVar(varDecl, varDecl.sym);\n+        }\n+\n+        \/** Initialize new trackable variable by setting its address field\n+         *  to the next available sequence number and entering it under that\n+         *  index into the vars array.\n+         *\/\n+        void newVar(JCTree pos,VarSymbol sym) {\n+            vars = ArrayUtils.ensureCapacity(vars, nextadr);\n@@ -2225,1 +2235,2 @@\n-            vardecls[nextadr] = varDecl;\n+            vars[nextadr] = sym;\n+            vardecls[nextadr] = pos;\n@@ -2301,1 +2312,1 @@\n-                (sym.flags_field & CLASH) == 0) {\n+                (sym.flags_field & (CLASH | COMPONENT_LOCAL_VARIABLE)) == 0) {\n@@ -2434,2 +2445,1 @@\n-                        JCVariableDecl vardecl = vardecls[i];\n-                        VarSymbol var = vardecl.sym;\n+                        VarSymbol var = vars[i];\n@@ -2437,0 +2447,1 @@\n+                            JCTree vardecl = vardecls[i];\n@@ -2521,2 +2532,2 @@\n-                            JCVariableDecl vardecl = vardecls[i];\n-                            VarSymbol var = vardecl.sym;\n+                            VarSymbol var = vars[i];\n+                            JCTree vardecl = vardecls[i];\n@@ -2579,1 +2590,1 @@\n-                        checkInit(exit.tree.pos(), vardecls[i].sym);\n+                        checkInit(exit.tree.pos(), vars[i]);\n@@ -3047,1 +3058,1 @@\n-                        VarSymbol sym = vardecls[address].sym;\n+                        VarSymbol sym = vars[address];\n@@ -3209,0 +3220,12 @@\n+        @Override\n+        public void visitReconstruction(JCDerivedInstance tree) {\n+            scan(tree.expr);\n+            int nextadrPrev = nextadr;\n+            for (VarSymbol component : tree.componentLocalVariables) {\n+                newVar(null, component);\n+                letInit(tree.pos(), component);\n+            }\n+            scan(tree.block);\n+            nextadr = nextadrPrev;\n+        }\n+\n@@ -3236,0 +3259,5 @@\n+                if (vars == null)\n+                    vars = new VarSymbol[32];\n+                else\n+                    for (int i=0; i<vars.length; i++)\n+                        vars[i] = null;\n@@ -3253,0 +3281,4 @@\n+                if (vars != null) {\n+                    for (int i=0; i<vars.length; i++)\n+                        vars[i] = null;\n+                }\n@@ -3451,0 +3483,8 @@\n+        @Override\n+        public void visitReconstruction(JCDerivedInstance tree) {\n+            if (declaredInsideGuard != null) {\n+                tree.componentLocalVariables.forEach(declaredInsideGuard::enter);\n+            }\n+            super.visitReconstruction(tree);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":52,"deletions":12,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCDerivedInstance;\n@@ -105,0 +106,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCYield;\n@@ -1361,0 +1363,46 @@\n+    @Override\n+    public void visitReconstruction(JCDerivedInstance tree) {\n+        ListBuffer<JCStatement> newBlock = new ListBuffer<>();\n+        VarSymbol temp;\n+        if (tree.expr instanceof JCIdent i &&\n+            i.sym.kind == Kind.VAR &&\n+            (i.sym.owner.kind == Kind.MTH || i.sym.owner.kind == Kind.VAR)) {\n+            temp = (VarSymbol) i.sym;\n+        } else {\n+            temp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(\"expr\" + variableIndex++ + target.syntheticNameChar() + \"temp\"),\n+                    tree.expr.type,\n+                    currentMethodSym);\n+            newBlock.add(make.VarDef(temp, translate(tree.expr)));\n+        }\n+\n+\n+        ClassSymbol recordClass = (ClassSymbol) tree.expr.type.tsym;\n+        List<VarSymbol> outgoingBindingsIt = tree.componentLocalVariables;\n+        List<? extends RecordComponent> recordComponentsIt = recordClass.getRecordComponents();\n+\n+        while (outgoingBindingsIt.nonEmpty()) {\n+            Type erasedComponentType = types.erasure(recordComponentsIt.head.type);\n+            newBlock.add(make.VarDef(outgoingBindingsIt.head,\n+                                     make.App(make.Select(make.Ident(temp),\n+                                                          recordComponentsIt.head.accessor))\n+                                         .setType(erasedComponentType)));\n+            outgoingBindingsIt = outgoingBindingsIt.tail;\n+            recordComponentsIt = recordComponentsIt.tail;\n+        }\n+\n+        newBlock.add(translate(tree.block));\n+\n+        JCNewClass createNew = make.NewClass(null,\n+                                             List.nil(),\n+                                             make.QualIdent(recordClass),\n+                                             tree.componentLocalVariables.map(make::Ident),\n+                                             null);\n+\n+        createNew.type = tree.type;\n+        createNew.constructor = recordClass.members()\n+                                           .findFirst(names.init, s -> (s.flags() & Flags.RECORD) != 0);\n+\n+        result = make.LetExpr(newBlock.toList(), createNew).setType(tree.type);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -738,0 +738,8 @@\n+    @Override\n+    public void visitReconstruction(JCDerivedInstance tree) {\n+        tree.expr = translate(tree.expr, pt);\n+        tree.block = translate(tree.block);\n+        tree.type = erasure(tree.expr.type);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1225,14 +1225,1 @@\n-                while (code.state.stacksize > 0) {\n-                    Type type = code.state.peek();\n-                    Name varName = names.fromString(target.syntheticNameChar() +\n-                                                    \"stack\" +\n-                                                    target.syntheticNameChar() +\n-                                                    tree.pos +\n-                                                    target.syntheticNameChar() +\n-                                                    code.state.stacksize);\n-                    VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,\n-                                                  this.env.enclMethod.sym);\n-                    LocalItem item = items.new LocalItem(type, code.newLocal(var));\n-                    stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);\n-                    item.store();\n-                }\n+                stackBeforeSwitchExpression = stashStackToLocalVariables(tree);\n@@ -1253,4 +1240,0 @@\n-    \/\/where:\n-        private boolean hasTry(JCSwitchExpression tree) {\n-            class HasTryScanner extends TreeScanner {\n-                private boolean hasTry;\n@@ -1258,4 +1241,3 @@\n-                @Override\n-                public void visitTry(JCTry tree) {\n-                    hasTry = true;\n-                }\n+    private boolean hasTry(JCTree tree) {\n+        class HasTryScanner extends TreeScanner {\n+            private boolean hasTry;\n@@ -1263,4 +1245,4 @@\n-                @Override\n-                public void visitSynchronized(JCSynchronized tree) {\n-                    hasTry = true;\n-                }\n+            @Override\n+            public void visitTry(JCTry tree) {\n+                hasTry = true;\n+            }\n@@ -1268,3 +1250,4 @@\n-                @Override\n-                public void visitClassDef(JCClassDecl tree) {\n-                }\n+            @Override\n+            public void visitSynchronized(JCSynchronized tree) {\n+                hasTry = true;\n+            }\n@@ -1272,4 +1255,8 @@\n-                @Override\n-                public void visitLambda(JCLambda tree) {\n-                }\n-            };\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+            }\n+\n+            @Override\n+            public void visitLambda(JCLambda tree) {\n+            }\n+        };\n@@ -1277,1 +1264,1 @@\n-            HasTryScanner hasTryScanner = new HasTryScanner();\n+        HasTryScanner hasTryScanner = new HasTryScanner();\n@@ -1279,3 +1266,3 @@\n-            hasTryScanner.scan(tree);\n-            return hasTryScanner.hasTry;\n-        }\n+        hasTryScanner.scan(tree);\n+        return hasTryScanner.hasTry;\n+    }\n@@ -1855,2 +1842,1 @@\n-            for (LocalItem li : stackBeforeSwitchExpression)\n-                li.load();\n+            reloadStackFromVariables(stackBeforeSwitchExpression);\n@@ -1859,0 +1845,5 @@\n+    private void reloadStackFromVariables(List<LocalItem> variables) {\n+        for (LocalItem li : variables)\n+            li.load();\n+    }\n+\n@@ -2415,0 +2406,11 @@\n+        List<LocalItem> stashedStack;\n+\n+        if (hasTry(tree)) {\n+            \/\/if the let expression contains try-catch, the catch handlers need to have\n+            \/\/an empty stack. So stash whole stack to local variables, and restore it\n+            \/\/at the end:\n+            stashedStack = stashStackToLocalVariables(tree);\n+        } else {\n+            stashedStack = List.nil();\n+        }\n+\n@@ -2421,0 +2423,1 @@\n+            reloadStackFromVariables(stashedStack);\n@@ -2426,0 +2429,20 @@\n+    private List<LocalItem> stashStackToLocalVariables(JCTree tree) {\n+        List<LocalItem> variables = List.nil();\n+\n+        while (code.state.stacksize > 0) {\n+            Type type = code.state.peek();\n+            Name varName = names.fromString(target.syntheticNameChar() +\n+                                            \"stack\" +\n+                                            target.syntheticNameChar() +\n+                                            tree.pos +\n+                                            target.syntheticNameChar() +\n+                                            code.state.stacksize);\n+            VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,\n+                                          this.env.enclMethod.sym);\n+            LocalItem item = items.new LocalItem(type, code.newLocal(var));\n+            variables = variables.prepend(item);\n+            item.store();\n+        }\n+\n+        return variables;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":62,"deletions":39,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCDerivedInstance;\n@@ -1570,0 +1571,6 @@\n+\n+            @Override\n+            public void visitReconstruction(JCDerivedInstance tree) {\n+                hasPatterns |= true;\n+                super.visitReconstruction(tree);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1823,0 +1823,11 @@\n+            } else if (isMode(EXPR) && token.kind == IDENTIFIER &&\n+                       token.name() == names.with && peekToken(LBRACE)) {\n+                int pos = token.pos;\n+\n+                checkSourceLevel(pos, Feature.DERIVED_INSTANCE);\n+\n+                nextToken();\n+\n+                JCBlock block = block();\n+\n+                t = F.at(pos).DerivedInstance(t, block);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3234,0 +3234,3 @@\n+compiler.misc.feature.derived.instance=\\\n+    derived record creation\n+\n@@ -3948,0 +3951,19 @@\n+# 0: symbol\n+compiler.err.with.assignment.not.allowed=\\\n+    assignment to {0} not allowed inside the block of the derived record creation expression\n+\n+compiler.err.with.return.not.allowed=\\\n+    return not allowed inside the block of the derived record creation expression\n+\n+compiler.err.with.break.not.allowed=\\\n+    break statement not allowed to transfer control outside of the block of the derived record creation expression\n+\n+compiler.err.with.continue.not.allowed=\\\n+    continue statement not allowed to transfer control outside of the block of the derived record creation expression\n+\n+compiler.err.with.yield.not.allowed=\\\n+    yield statement not allowed to transfer control outside of the block of the derived record creation expression\n+\n+compiler.err.derived.expression.no.record=\\\n+    the parameter for the derived record creation expression is not a record class\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -228,0 +228,4 @@\n+        \/** Derived record creation expression, of type JCDerivedInstance.\n+         *\/\n+        DERIVEDRECORDCREATION,\n+\n@@ -2049,0 +2053,30 @@\n+    \/**\n+     * A reconstruction subexpression ( ... )\n+     *\/\n+    public static class JCDerivedInstance extends JCExpression implements DerivedInstanceTree {\n+        public JCExpression expr;\n+        public JCBlock block;\n+        public List<VarSymbol> componentLocalVariables;\n+        protected JCDerivedInstance(JCExpression expr, JCBlock block) {\n+            this.expr = expr;\n+            this.block = block;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitReconstruction(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.DERIVED_INSTANCE; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getExpression() { return expr; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCBlock getBlock() { return block; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitDerivedInstance(this, d);\n+        }\n+        @Override\n+        public Tag getTag() {\n+            return DERIVEDRECORDCREATION;\n+        }\n+    }\n+\n@@ -3573,0 +3607,1 @@\n+        public void visitReconstruction(JCDerivedInstance that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,0 +359,8 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDerivedInstance(DerivedInstanceTree node, P p) {\n+        JCDerivedInstance t = (JCDerivedInstance) node;\n+        JCExpression expr = copy(t.expr, p);\n+        JCBlock block = copy(t.block, p);\n+        return M.at(t.pos).DerivedInstance(expr, block);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -452,0 +452,6 @@\n+    public JCDerivedInstance DerivedInstance(JCExpression expr, JCBlock block) {\n+        JCDerivedInstance tree = new JCDerivedInstance(expr, block);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,0 +279,5 @@\n+    public void visitReconstruction(JCDerivedInstance tree) {\n+        scan(tree.expr);\n+        scan(tree.block);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,0 +327,7 @@\n+    @Override\n+    public void visitReconstruction(JCDerivedInstance tree) {\n+        tree.expr = translate(tree.expr);\n+        tree.block = translate(tree.block);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.derived.expression.no.record\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class DerivedExpressionNoRecord {\n+    Object test(Object o) {\n+        return o with { };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DerivedExpressionNoRecord.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.derived.instance\n+\/\/ key: compiler.err.preview.feature.disabled\n+\/\/ options: --release 22\n+\n+class FeatureDerivedInstance {\n+    R test(R r) {\n+        return r with {\n+            value = \"\";\n+        };\n+    }\n+\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureDerivedInstance.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.assignment.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithAssignmentNotAllowed {\n+    R test(R r) {\n+        int i;\n+        return r with {\n+            i = 0;\n+        };\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithAssignmentNotAllowed.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.break.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithBreakNotAllowed {\n+    void test(R r) {\n+        while (true) {\n+            r = r with {\n+                break;\n+            };\n+        }\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithBreakNotAllowed.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.continue.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithContinueNotAllowed {\n+    void test(R r) {\n+        while (true) {\n+            r = r with {\n+                continue;\n+            };\n+        }\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithContinueNotAllowed.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.return.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithReturnNotAllowed {\n+    R test(R r) {\n+        r = r with {\n+            return r;\n+        };\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithReturnNotAllowed.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.with.yield.not.allowed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --release ${jdk.version}\n+\n+class WithYieldNotAllowed {\n+    R test(R r) {\n+        return switch(0) {\n+            default -> r with {\n+                yield r;\n+            };\n+        };\n+    }\n+    record R(String value) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WithYieldNotAllowed.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @enablePreview\n+ * @compile Exceptions.java\n+ * @run main Exceptions\n+ *\/\n+public class Exceptions {\n+    public static void main(String... args) {\n+        R r;\n+        r = new R(\"\", \"a\");\n+        try {\n+            r = r with {\n+                throw new AssertionError(\"Should not get here!\");\n+            };\n+        } catch (Intentional ex) {\n+            if (!\"s1\".equals(ex.getMessage())) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        r = new R(\"a\", \"\");\n+        try {\n+            r = r with {\n+                throw new AssertionError(\"Should not get here!\");\n+            };\n+        } catch (Intentional ex) {\n+            if (!\"s2\".equals(ex.getMessage())) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        r = new R(\"a\", \"a\");\n+        try {\n+            r = r with {\n+                throw new Intentional(\"in body\");\n+            };\n+        } catch (Intentional ex) {\n+            if (!\"in body\".equals(ex.getMessage())) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        try {\n+            keepOnStack(0, r with {\n+                try {\n+                    throw new Intentional(\"in body\");\n+                } catch (Intentional ex) {\n+                    \/\/ignored...\n+                }\n+            });\n+        } catch (Intentional ex) {\n+            if (!\"in body\".equals(ex.getMessage())) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        r = null;\n+        try {\n+            r = r with {};\n+            throw new AssertionError(\"Should not get here!\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    private static void keepOnStack(int value, R r) { }\n+\n+    record R(String s1, String s2) {\n+\n+        public String s1() {\n+            if (s1.isEmpty()) {\n+                throw new Intentional(\"s1\");\n+            }\n+            return s1;\n+        }\n+\n+        public String s2() {\n+            if (s2.isEmpty()) {\n+                throw new Intentional(\"s2\");\n+            }\n+            return s2;\n+        }\n+\n+    }\n+\n+    public static class Intentional extends RuntimeException {\n+\n+        public Intentional(String msg) {\n+            super(msg);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/Exceptions.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8256266 8281238\n+ * @summary Verify annotations work correctly on binding variables\n+ * @library \/tools\/javac\/lib\n+ * @enablePreview\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ *          java.base\/jdk.internal.classfile.impl\n+ * @build JavacTestingAbstractProcessor\n+ * @compile Model.java\n+ * @compile\/ref=Model.out -J--enable-preview -processor Model -XDshould-stop.at=FLOW -XDrawDiagnostics Model.java\n+ *\/\n+\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.util.TreePath;\n+import java.util.Set;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DerivedInstanceTree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import javax.lang.model.element.ElementKind;\n+\n+public class Model extends JavacTestingAbstractProcessor {\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (roundEnv.processingOver()) {\n+            JavacTask.instance(processingEnv).addTaskListener(new TaskListener() {\n+                @Override\n+                public void finished(TaskEvent e) {\n+                    if (e.getKind() == TaskEvent.Kind.ANALYZE) {\n+                        performCheck(e.getCompilationUnit());\n+                    }\n+                }\n+            });\n+        }\n+        return false;\n+    }\n+\n+    private void performCheck(CompilationUnitTree cut) {\n+        Trees trees = Trees.instance(processingEnv);\n+\n+        new TreePathScanner<Void, Void>() {\n+            @Override\n+            public Void visitDerivedInstance(DerivedInstanceTree node, Void p) {\n+                System.err.println(\"visitDerivedInstance start\");\n+                try {\n+                    return super.visitDerivedInstance(node, p);\n+                } finally {\n+                    System.err.println(\"visitDerivedInstance end\");\n+                }\n+            }\n+\n+            @Override\n+            public Void visitAssignment(AssignmentTree node, Void p) {\n+                Element varEl = trees.getElement(new TreePath(new TreePath(getCurrentPath(), node), node.getVariable()));\n+                if (varEl.getKind() == ElementKind.COMPONENT_LOCAL_VARIABLE) {\n+                    System.err.println(varEl.getSimpleName());\n+                }\n+                return super.visitAssignment(node, p);\n+            }\n+        }.scan(cut, null);\n+    }\n+\n+    private static void test() {\n+        record R(String val1, Integer val2) {}\n+        R r = new R(\"\", 0);\n+        r = r with {\n+            val1 = \"a\";\n+            val2 = -1;\n+        };\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/Model.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+visitDerivedInstance start\n+val1\n+val2\n+visitDerivedInstance end\n+- compiler.note.preview.filename: Model.java, DEFAULT\n+- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/Model.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @enablePreview\n+ * @compile SimpleWithers.java\n+ * @run main SimpleWithers\n+ *\/\n+public class SimpleWithers {\n+    public static void main(String... args) {\n+        R r = new R(1, 2, 3);\n+        r = r with {\n+            val1 = -1;\n+            val3 = -3;\n+        };\n+        if (r.val1() != (-1) ||\n+            r.val2() != 2 ||\n+            r.val3() != (-3)) {\n+            throw new AssertionError(\"Incorrect value: \" + r);\n+        }\n+        R rp = r;\n+        boolean match = switch (rp) {\n+            case R(var i1, var i2, var i3) when rp with {\n+                val1 = -1;\n+                val3 = -3;\n+            }.val1() == -1 -> true;\n+            default -> false;\n+        };\n+        if (!match) {\n+            throw new AssertionError(\"Did not match.\");\n+        }\n+        \/\/shadowing:\n+        R2 r2 = new R2(r);\n+        R2 r2p = r2 with {\n+            val1 = val1 with {\n+                val1 = -2;\n+                val3 = -6;\n+            };\n+        };\n+        if (r2p.val1().val1() != (-2) ||\n+            r2p.val1().val2() != 2 ||\n+            r2p.val1().val3() != (-6)) {\n+            throw new AssertionError(\"Incorrect value: \" + r);\n+        }\n+        {\n+            int val1 = 0;\n+            if (r with {\n+                    val1 = -3;\n+                } instanceof R(var v1, var v2, var v3) && v1 != (-3)) {\n+                throw new AssertionError(\"Incorrect value: \" + v1);\n+            }\n+        }\n+        if (r instanceof R(var val1, var val2, var val3) && r with {\n+                val1 = -4;\n+            } instanceof R(var v1, var v2, var v3) && v1 != (-4)) {\n+            throw new AssertionError(\"Incorrect value: \" + v1);\n+        }\n+        C c = l -> l with {\n+            val1 = -5;\n+            val3 = -6;\n+        };\n+        \/\/component local variables may shadow:\n+        int val1 = 0, val2 = 0, val3 = 0;\n+        if (r with {\n+                val1 = -7;\n+                val2 = -8;\n+                val3 = -9;\n+            } instanceof R(var v1, var v2, var v3) && v1 != (-7)) {\n+            throw new AssertionError(\"Incorrect value: \" + v1);\n+        }\n+        if (r2 with {\n+                val1 = val1 with { val1 = -10; };\n+            } instanceof R2(R(var v, _, _)) && v != (-10)) {\n+            throw new AssertionError(\"Incorrect value: \" + v);\n+        }\n+        \/\/the values are definitelly assigned:\n+        r = new R(0, 0, 0);\n+        if (r with {\n+                val1++;\n+                val2 += 2;\n+                val3 = val3 + 3;\n+            } instanceof R(var v1, var v2, var v3) && (v1 != 1 || v2 != 2 || v3 != 3)) {\n+            throw new AssertionError(\"Incorrect value(s): \" + v1 + \", \" + v2 + \", \" + v3);\n+        }\n+    }\n+\n+    record R(int val1, int val2, int val3) {}\n+    record R2(R val1) {}\n+    interface C {\n+        R apply(R r);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/SimpleWithers.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @compile\/fail\/ref=SourceLevelCheck.out --release 22 -XDrawDiagnostics SourceLevelCheck.java\n+ *\/\n+public class SourceLevelCheck {\n+    public static void main(String... args) {\n+        R r = new R(0);\n+        r = r with {\n+            val = -1;\n+        };\n+    }\n+    record R(int val) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/SourceLevelCheck.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+SourceLevelCheck.java:31:15: compiler.err.preview.feature.disabled: (compiler.misc.feature.derived.instance)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/SourceLevelCheck.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @enablePreview\n+ * @compile\/fail\/ref=WithErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW WithErrors.java\n+ *\/\n+\n+import java.util.List;\n+\n+public class WithErrors {\n+\n+    private int field;\n+\n+    private void assignments(R input) {\n+        int i = 0;\n+\n+        input = input with {\n+            int l;\n+\n+            value = \"nue\"; \/\/OK - assignment to the component\n+            i = ++i + i++ + --i + i-- + -i + +i; \/\/error - assignment to outter variable\n+            i += 1; \/\/error - (compound) assignment to outter variable\n+            field = 0; \/\/error - unqualified assignment to field\n+            this.field = 0; \/\/ OK - qualified assignment\n+            l = 0; \/\/OK - assignment to a variable local to the block\n+        };\n+\n+        input = input with {\n+            int l1;\n+            Runnable _ = () -> {\n+                int l2;\n+\n+                value = \"nue\"; \/\/error - cannot assign inside lambda\n+                i = 0; \/\/error - assignment to outter variable, and inside lambda\n+                i += 1; \/\/error - (compound) assignment to outter variable\n+                field = 0; \/\/error - unqualified assignment to field\n+                this.field = 0; \/\/ OK - qualified assignment\n+                l1 = 0; \/\/error - cannot assign inside lambda\n+                l2 = 0; \/\/OK - assignment to a variable local to the block\n+            };\n+        };\n+\n+        input = input with {\n+            Runnable _ = () -> {\n+                String _ = value; \/\/error - \"value\" is not effectivelly final\n+            };\n+            value = \"nue\";\n+        };\n+\n+        input = input with {\n+            Runnable _ = () -> {\n+                String _ = value; \/\/OK - \"value\" is effectivelly final\n+            };\n+        };\n+\n+        input = input with {\n+            int l1;\n+            Runnable _ = new Runnable() {\n+                public void run () {\n+                    int l2;\n+\n+                    value = \"nue\"; \/\/error - cannot assign inside the anonymous class\n+                    i = 0; \/\/error - cannot assign inside the anonymous class\n+                    field = 0; \/\/OK - assignment to outer field from inside the anonymous class\n+                    WithErrors.this.field = 0; \/\/ OK - qualified assignment\n+                    l1 = 0; \/\/error - cannot assign inside lambda\n+                    l2 = 0; \/\/OK - assignment to a variable local to this block\/method\n+                }\n+            };\n+        };\n+\n+        input = input with {\n+            Runnable _ = new Runnable() {\n+                public void run () {\n+                    String _ = value; \/\/error - \"value\" is not effectivelly final\n+                }\n+            };\n+            value = \"nue\";\n+        };\n+\n+        input = input with {\n+            Runnable _ = new Runnable() {\n+                public void run () {\n+                    String _ = value; \/\/OK - \"value\" is effectivelly final\n+                }\n+            };\n+        };\n+\n+        String _ = \"\" with {};\n+        int _ = 1 with {};\n+    }\n+\n+    private void controlFlow(R input) {\n+        if (true) {\n+            input = input with {\n+                return ;\n+            };\n+        }\n+\n+        for (;;) {\n+            input = input with {\n+                break;\n+            };\n+        }\n+\n+        input = input with {\n+            for (;;) {\n+                break;\n+            }\n+        };\n+\n+        for (String s : List.of(\"\")) {\n+            input = input with {\n+                break;\n+            };\n+        }\n+\n+        input = input with {\n+            for (String s : List.of(\"\")) {\n+                break;\n+            }\n+        };\n+\n+        while (true) {\n+            input = input with {\n+                break;\n+            };\n+        }\n+\n+        input = input with {\n+            while (true) {\n+                break;\n+            }\n+        };\n+\n+        do {\n+            input = input with {\n+                break;\n+            };\n+        } while (true);\n+\n+        input = input with {\n+            do {\n+                break;\n+            } while (true);\n+        };\n+\n+        switch (0) {\n+            default ->\n+                input = input with {\n+                    break;\n+                };\n+        }\n+\n+        input = input with {\n+            switch (0) {\n+                default -> {break;}\n+            }\n+        };\n+\n+        if (true) {\n+            for (;;) {\n+                input = input with {\n+                    continue;\n+                };\n+            }\n+        }\n+\n+        if (true) {\n+            input = input with {\n+                for (;;) {\n+                    continue;\n+                }\n+            };\n+        }\n+\n+        if (true) {\n+            for (String s : List.of(\"\")) {\n+                input = input with {\n+                    continue;\n+                };\n+            }\n+        }\n+\n+        if (true) {\n+            input = input with {\n+                for (String s : List.of(\"\")) {\n+                    continue;\n+                }\n+            };\n+        }\n+\n+        if (true) {\n+            while (true) {\n+                input = input with {\n+                    continue;\n+                };\n+            }\n+        }\n+\n+        if (true) {\n+            input = input with {\n+                while (true) {\n+                    continue;\n+                }\n+            };\n+        }\n+\n+        if (true) {\n+            do {\n+                input = input with {\n+                    continue;\n+                };\n+            } while (true);\n+        }\n+\n+        if (true) {\n+            input = input with {\n+                do {\n+                    continue;\n+                } while (true);\n+            };\n+        }\n+\n+        int _ = switch (0) {\n+            default -> {\n+                input = input with {\n+                    yield 0;\n+                };\n+            }\n+        };\n+\n+        input = input with {\n+            int _ = switch (0) {\n+                default -> { yield 0; }\n+            };\n+        };\n+    }\n+\n+    record R(String value) {}\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/WithErrors.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+WithErrors.java:43:13: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:43:19: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:43:23: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:43:31: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:43:35: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:44:13: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:45:13: compiler.err.with.assignment.not.allowed: field\n+WithErrors.java:56:17: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:57:17: compiler.err.with.assignment.not.allowed: i\n+WithErrors.java:58:17: compiler.err.with.assignment.not.allowed: field\n+WithErrors.java:111:23: compiler.err.derived.expression.no.record\n+WithErrors.java:112:19: compiler.err.derived.expression.no.record\n+WithErrors.java:118:17: compiler.err.with.return.not.allowed\n+WithErrors.java:124:17: compiler.err.with.break.not.allowed\n+WithErrors.java:136:17: compiler.err.with.break.not.allowed\n+WithErrors.java:148:17: compiler.err.with.break.not.allowed\n+WithErrors.java:160:17: compiler.err.with.break.not.allowed\n+WithErrors.java:173:21: compiler.err.with.break.not.allowed\n+WithErrors.java:186:21: compiler.err.with.continue.not.allowed\n+WithErrors.java:202:21: compiler.err.with.continue.not.allowed\n+WithErrors.java:218:21: compiler.err.with.continue.not.allowed\n+WithErrors.java:234:21: compiler.err.with.continue.not.allowed\n+WithErrors.java:250:21: compiler.err.with.yield.not.allowed\n+WithErrors.java:55:17: compiler.err.cant.ref.non.effectively.final.var: value, (compiler.misc.lambda)\n+WithErrors.java:60:17: compiler.err.cant.ref.non.effectively.final.var: l1, (compiler.misc.lambda)\n+WithErrors.java:67:28: compiler.err.cant.ref.non.effectively.final.var: value, (compiler.misc.lambda)\n+WithErrors.java:84:21: compiler.err.cant.ref.non.effectively.final.var: value, (compiler.misc.inner.cls)\n+WithErrors.java:85:21: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.inner.cls)\n+WithErrors.java:88:21: compiler.err.cant.ref.non.effectively.final.var: l1, (compiler.misc.inner.cls)\n+WithErrors.java:97:32: compiler.err.cant.ref.non.effectively.final.var: value, (compiler.misc.inner.cls)\n+- compiler.note.preview.filename: WithErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+30 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/WithErrors.out","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @enablePreview\n+ * @compile WithPriority.java\n+ * @run main WithPriority\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class WithPriority {\n+    public static void main(String... args) {\n+        new WithPriority().run();\n+    }\n+\n+    private void run() {\n+        assertEquals(new R(\"true\"), ternary(true, new R(\"\")));\n+        assertEquals(new R(\"false\"), ternary(false, new R(\"\")));\n+        assertEquals(new R(\"nue\"), new R(\"\") with { value = \"nue\"; });\n+        assertEquals(\"nue\", new R(\"\") with { value = \"nue\"; }.value());\n+    }\n+\n+    private R ternary(boolean c, R input) {\n+        R trueInput = input with { value = \"true\"; };\n+        return c ? trueInput : input with { value = \"false\"; };\n+    }\n+\n+    private void forWithDisambiguation(String[] values) {\n+        for (var with : values) {}\n+        for (int with = 0; ;) {}\n+    }\n+\n+    record R(String value) {}\n+\n+    private static void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/withers\/WithPriority.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"}]}