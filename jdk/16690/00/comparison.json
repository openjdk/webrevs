{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"hugepages.hpp\"\n@@ -29,0 +30,7 @@\n+  if (HugePages::thp_requested()) {\n+    \/\/ Check if the OS config turned off transparent huge pages for shmem.\n+    _os_enforced_transparent_mode = HugePages::shmem_thp_info().is_disabled();\n+    _state = _os_enforced_transparent_mode ? Disabled : Transparent;\n+    return;\n+  }\n+\n@@ -30,7 +38,2 @@\n-    if (UseTransparentHugePages) {\n-      _state = Transparent;\n-    } else {\n-      _state = Explicit;\n-    }\n-  } else {\n-    _state = Disabled;\n+    _state = Explicit;\n+    return;\n@@ -38,0 +41,4 @@\n+\n+  \/\/ Check if the OS config turned on transparent huge pages for shmem.\n+  _os_enforced_transparent_mode = HugePages::shmem_thp_info().is_forced();\n+  _state = _os_enforced_transparent_mode ? Transparent : Disabled;\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zLargePages_linux.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"hugepages.hpp\"\n@@ -449,2 +450,4 @@\n-  \/\/ Advise mapping to use transparent huge pages\n-  os::realign_memory((char*)addr, length, ZGranuleSize);\n+  \/\/ Maybe madvise the mapping to use transparent huge pages\n+  if (HugePages::should_madvise_shmem_thps()) {\n+    os::Linux::madvise_transparent_huge_pages(addr, length);\n+  }\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -230,0 +231,81 @@\n+ShmemTHPSupport::ShmemTHPSupport() :\n+    _initialized(false), _mode(ShmemTHPMode::never) {}\n+\n+ShmemTHPMode ShmemTHPSupport::mode() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _mode;\n+}\n+\n+bool ShmemTHPSupport::is_forced() const {\n+  return _mode == ShmemTHPMode::always || _mode == ShmemTHPMode::force || _mode == ShmemTHPMode::within_size;\n+}\n+\n+bool ShmemTHPSupport::is_enabled() const {\n+  return is_forced() || _mode == ShmemTHPMode::advise;\n+}\n+\n+bool ShmemTHPSupport::is_disabled() const {\n+  return _mode == ShmemTHPMode::never || _mode == ShmemTHPMode::deny || _mode == ShmemTHPMode::unknown;\n+}\n+\n+void ShmemTHPSupport::scan_os() {\n+  \/\/ Scan \/sys\/kernel\/mm\/transparent_hugepage\/shmem_enabled\n+  \/\/ see mm\/huge_memory.c\n+  _mode = ShmemTHPMode::never;\n+  const char* filename = \"\/sys\/kernel\/mm\/transparent_hugepage\/shmem_enabled\";\n+  FILE* f = ::fopen(filename, \"r\");\n+  if (f != nullptr) {\n+    char buf[64];\n+    char* s = fgets(buf, sizeof(buf), f);\n+    assert(s == buf, \"Should have worked\");\n+    if (::strstr(buf, \"[always]\") != nullptr) {\n+      _mode = ShmemTHPMode::always;\n+    } else if (::strstr(buf, \"[within_size]\") != nullptr) {\n+      _mode = ShmemTHPMode::within_size;\n+    } else if (::strstr(buf, \"[advise]\") != nullptr) {\n+      _mode = ShmemTHPMode::advise;\n+    } else if (::strstr(buf, \"[never]\") != nullptr) {\n+      _mode = ShmemTHPMode::never;\n+    } else if (::strstr(buf, \"[deny]\") != nullptr) {\n+      _mode = ShmemTHPMode::deny;\n+    } else if (::strstr(buf, \"[force]\") != nullptr) {\n+      _mode = ShmemTHPMode::force;\n+    } else {\n+      assert(false, \"Weird content of %s: %s\", filename, buf);\n+      _mode = ShmemTHPMode::unknown;\n+    }\n+    fclose(f);\n+  }\n+\n+  \/\/ Scan large page size for THP from hpage_pmd_size\n+  _initialized = true;\n+\n+  LogTarget(Info, pagesize) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    print_on(&ls);\n+  }\n+}\n+\n+const char* ShmemTHPSupport::mode_to_string(ShmemTHPMode mode) {\n+  switch (mode) {\n+    case  ShmemTHPMode::always:     return \"always\";\n+    case ShmemTHPMode::advise:      return \"advise\";\n+    case ShmemTHPMode::within_size: return \"within_size\";\n+    case ShmemTHPMode::never:       return \"never\";\n+    case ShmemTHPMode::deny:        return \"deny\";\n+    case ShmemTHPMode::force:       return \"force\";\n+    case ShmemTHPMode::unknown:      \/\/ Fallthrough\n+    default:                        return \"unknown\";\n+  };\n+}\n+\n+void ShmemTHPSupport::print_on(outputStream* os) {\n+  if (_initialized) {\n+    os->print_cr(\"Shared memory transparent hugepage (THP) support:\");\n+    os->print_cr(\"  Shared memory THP mode: %s\", mode_to_string(_mode));\n+  } else {\n+    os->print_cr(\"  unknown.\");\n+  }\n+}\n+\n@@ -232,0 +314,2 @@\n+ShmemTHPSupport HugePages::_shmem_thp_support;\n+bool HugePages::_thp_requested{false};\n@@ -236,0 +320,4 @@\n+  _shmem_thp_support.scan_os();\n+\n+  const bool huge_pages_turned_off = !FLAG_IS_DEFAULT(UseLargePages) && !UseLargePages;\n+  _thp_requested = UseTransparentHugePages && !huge_pages_turned_off;\n@@ -241,0 +329,1 @@\n+  _shmem_thp_support.print_on(os);\n","filename":"src\/hotspot\/os\/linux\/hugepages.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -94,0 +94,28 @@\n+enum class ShmemTHPMode { always, within_size, advise, never, deny, force, unknown };\n+\n+\/\/ for transparent shmem hugepages\n+class ShmemTHPSupport {\n+  bool _initialized;\n+\n+  \/\/ See \/sys\/kernel\/mm\/transparent_hugepage\/shmem_enabled\n+  ShmemTHPMode _mode;\n+\n+  static const char* mode_to_string(ShmemTHPMode mode);\n+\n+public:\n+\n+  ShmemTHPSupport();\n+\n+  \/\/ Queries the OS, fills in object\n+  void scan_os();\n+\n+  ShmemTHPMode mode() const;\n+\n+  bool is_forced() const;\n+  bool is_enabled() const;\n+  bool is_disabled() const;\n+\n+  \/\/ Printing\n+  void print_on(outputStream* os);\n+};\n+\n@@ -99,0 +127,4 @@\n+  static ShmemTHPSupport _shmem_thp_support;\n+\n+  static bool _huge_pages_requested;\n+  static bool _thp_requested;\n@@ -104,0 +136,1 @@\n+  static const ShmemTHPSupport& shmem_thp_info() { return _shmem_thp_support; }\n@@ -107,1 +140,1 @@\n-  static THPMode thp_mode()                     { return _thp_support.mode(); }\n+\n@@ -109,0 +142,1 @@\n+  static THPMode thp_mode()                     { return _thp_support.mode(); }\n@@ -111,0 +145,6 @@\n+  static bool supports_shmem_thp()              { return _shmem_thp_support.is_enabled(); }\n+  static bool forced_shmem_thp()                { return _shmem_thp_support.is_forced(); }\n+  static bool thp_requested()                   { return _thp_requested; }\n+  static bool should_madvise_anonymous_thps()   { return _thp_requested && _thp_support.mode() == THPMode::madvise; }\n+  static bool should_madvise_shmem_thps()       { return _thp_requested && _shmem_thp_support.mode() == ShmemTHPMode::advise; }\n+\n","filename":"src\/hotspot\/os\/linux\/hugepages.hpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2181,0 +2181,2 @@\n+  _print_ascii_file_h(\"\/sys\/kernel\/mm\/transparent_hugepage\/shmem_enabled\",\n+                      \"\/sys\/kernel\/mm\/transparent_hugepage\/shmem_enabled\", st);\n@@ -2877,0 +2879,6 @@\n+void os::Linux::madvise_transparent_huge_pages(void* addr, size_t bytes) {\n+  \/\/ We don't check the return value: madvise(MADV_HUGEPAGE) may not\n+  \/\/ be supported or the memory may already be backed by huge pages.\n+  ::madvise(addr, bytes, MADV_HUGEPAGE);\n+}\n+\n@@ -2878,4 +2886,2 @@\n-  if (UseTransparentHugePages && alignment_hint > vm_page_size()) {\n-    \/\/ We don't check the return value: madvise(MADV_HUGEPAGE) may not\n-    \/\/ be supported or the memory may already be backed by huge pages.\n-    ::madvise(addr, bytes, MADV_HUGEPAGE);\n+  if (HugePages::should_madvise_anonymous_thps() && alignment_hint > vm_page_size()) {\n+    Linux::madvise_transparent_huge_pages(addr, bytes);\n@@ -3699,1 +3705,1 @@\n-void warn_no_large_pages_configured() {\n+static void warn_no_large_pages_configured() {\n@@ -3705,0 +3711,14 @@\n+static void warn_thp_not_configured() {\n+  if (FLAG_IS_DEFAULT(UseTransparentHugePages)) {\n+    \/\/ Don't warn if user didn't set the flag\n+    return;\n+  }\n+\n+  if (UseZGC && HugePages::thp_requested() && HugePages::supports_shmem_thp()) {\n+    \/\/ ZGC uses shared memory THPs; don't warn if those are configured\n+    return;\n+  }\n+\n+  log_warning(pagesize)(\"UseTransparentHugePages disabled, transparent huge pages are not supported by the operating system.\");\n+}\n+\n@@ -3716,1 +3736,1 @@\n-        ls.print(\"Large page support disabled.\");\n+        ls.print(\"Large page support %sdisabled.\", uses_zgc_shmem_thp() ? \"partially \" : \"\");\n@@ -3720,0 +3740,8 @@\n+\n+  static bool uses_zgc_shmem_thp() {\n+    return UseZGC &&\n+        \/\/ If user requested THP\n+        ((HugePages::thp_requested() && HugePages::supports_shmem_thp()) ||\n+        \/\/ If OS forced THP\n+         HugePages::forced_shmem_thp());\n+  }\n@@ -3725,1 +3753,1 @@\n-  \/\/ Query OS information first.\n+  \/\/ Query OS information first and store flag values before changing their values.\n@@ -3758,3 +3786,1 @@\n-    if (!FLAG_IS_DEFAULT(UseTransparentHugePages)) {\n-      log_warning(pagesize)(\"UseTransparentHugePages disabled, transparent huge pages are not supported by the operating system.\");\n-    }\n+    warn_thp_not_configured();\n@@ -3764,0 +3790,1 @@\n+\n@@ -3766,1 +3793,1 @@\n-    UseLargePages = UseTransparentHugePages = false;\n+    UseLargePages = false;\n@@ -3774,1 +3801,1 @@\n-    assert(HugePages::supports_thp() && HugePages::thp_pagesize() > 0, \"Missing OS info\");\n+    assert(HugePages::thp_pagesize() > 0, \"Missing OS info\");\n@@ -3799,6 +3826,6 @@\n-        LargePageSizeInBytes == 0 ||\n-        LargePageSizeInBytes == default_large_page_size) {\n-      large_page_size = default_large_page_size;\n-      log_info(pagesize)(\"Using the default large page size: \" SIZE_FORMAT \"%s\",\n-                         byte_size_in_exact_unit(large_page_size),\n-                         exact_unit_for_byte_size(large_page_size));\n+       LargePageSizeInBytes == 0 ||\n+       LargePageSizeInBytes == default_large_page_size) {\n+     large_page_size = default_large_page_size;\n+     log_info(pagesize)(\"Using the default large page size: \" SIZE_FORMAT \"%s\",\n+                        byte_size_in_exact_unit(large_page_size),\n+                        exact_unit_for_byte_size(large_page_size));\n@@ -3829,1 +3856,0 @@\n-      UseTransparentHugePages = false;\n@@ -3860,1 +3886,2 @@\n-  assert(UseLargePages && !UseTransparentHugePages, \"Should only get here for static hugepage mode (+UseLargePages)\");\n+  assert(UseLargePages, \"Should only get here for huge pages\");\n+  assert(!UseTransparentHugePages, \"Should only get here for static hugepage mode\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":47,"deletions":20,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -178,0 +178,2 @@\n+  static void madvise_transparent_huge_pages(void* addr, size_t bytes);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+bool ZLargePages::_os_enforced_transparent_mode;\n@@ -44,1 +45,5 @@\n-    return \"Enabled (Transparent)\";\n+    if (_os_enforced_transparent_mode) {\n+      return \"Enabled (Transparent, OS enforced)\";\n+    } else {\n+      return \"Enabled (Transparent)\";\n+    }\n@@ -47,1 +52,5 @@\n-    return \"Disabled\";\n+    if (_os_enforced_transparent_mode) {\n+      return \"Disabled (OS enforced)\";\n+    } else {\n+      return \"Disabled\";\n+    }\n","filename":"src\/hotspot\/share\/gc\/z\/zLargePages.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  static bool  _os_enforced_transparent_mode;\n","filename":"src\/hotspot\/share\/gc\/z\/zLargePages.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Set;\n@@ -71,0 +70,3 @@\n+    enum ShmemTHPMode {always, within_size, advise, never, deny, force, unknown}\n+    ShmemTHPMode _shmemThpMode;\n+\n@@ -92,0 +94,4 @@\n+    public ShmemTHPMode getShmemThpMode() {\n+        return _shmemThpMode;\n+    }\n+\n@@ -97,1 +103,1 @@\n-    public HugePageConfiguration(Set<StaticHugePageConfig> _staticHugePageConfigurations, long _staticDefaultHugePageSize, THPMode _thpMode, long _thpPageSize) {\n+    public HugePageConfiguration(Set<StaticHugePageConfig> _staticHugePageConfigurations, long _staticDefaultHugePageSize, THPMode _thpMode, long _thpPageSize, ShmemTHPMode _shmemThpMode) {\n@@ -102,0 +108,1 @@\n+        this._shmemThpMode = _shmemThpMode;\n@@ -111,0 +118,1 @@\n+                \", _shmemThpMode=\" + _shmemThpMode +\n@@ -120,1 +128,2 @@\n-                Objects.equals(_staticHugePageConfigurations, that._staticHugePageConfigurations) && _thpMode == that._thpMode;\n+                Objects.equals(_staticHugePageConfigurations, that._staticHugePageConfigurations) && _thpMode == that._thpMode &&\n+                _shmemThpMode == that._shmemThpMode;\n@@ -125,1 +134,0 @@\n-        long result = 0;\n@@ -202,0 +210,28 @@\n+    private static ShmemTHPMode readShmemTHPModeFromOS() {\n+        ShmemTHPMode mode = ShmemTHPMode.unknown;\n+        String file = \"\/sys\/kernel\/mm\/transparent_hugepage\/shmem_enabled\";\n+        try (FileReader fr = new FileReader(file);\n+             BufferedReader reader = new BufferedReader(fr)) {\n+            String s = reader.readLine();\n+            if (s.contains(\"[always]\")) {\n+                mode = ShmemTHPMode.always;\n+            } else if (s.contains(\"[within_size]\")) {\n+                mode = ShmemTHPMode.within_size;\n+            } else if (s.contains(\"[advise]\")) {\n+                mode = ShmemTHPMode.advise;\n+            } else if (s.contains(\"[never]\")) {\n+                mode = ShmemTHPMode.never;\n+            } else if (s.contains(\"[deny]\")) {\n+                mode = ShmemTHPMode.deny;\n+            } else if (s.contains(\"[force]\")) {\n+                mode = ShmemTHPMode.force;\n+            } else {\n+                throw new RuntimeException(\"Unexpected content of \" + file + \": \" + s);\n+            }\n+        } catch (IOException e) {\n+            System.out.println(\"Failed to read \" + file);\n+            \/\/ Happens when the kernel is not built to support THPs.\n+        }\n+        return mode;\n+    }\n+\n@@ -207,1 +243,2 @@\n-                readTHPPageSizeFromOS());\n+                readTHPPageSizeFromOS(),\n+                readShmemTHPModeFromOS());\n@@ -230,0 +267,2 @@\n+        \/\/ [0.001s][info][pagesize] Shared memory transparent hugepage (THP) support:\n+        \/\/ [0.001s][info][pagesize]   Shared memory THP mode: always\n@@ -233,0 +272,1 @@\n+        ShmemTHPMode shmemThpMode = ShmemTHPMode.unknown;\n@@ -236,2 +276,3 @@\n-        Pattern patternTHPPageSize = Pattern.compile(\".*\\\\[pagesize] *THP pagesize: (\\\\d+)([KMG])\");\n-        Pattern patternTHPMode = Pattern.compile(\".*\\\\[pagesize] *THP mode: (\\\\S+)\");\n+        Pattern patternTHPPageSize = Pattern.compile(\".*\\\\[pagesize] *  THP pagesize: (\\\\d+)([KMG])\");\n+        Pattern patternTHPMode = Pattern.compile(\".*\\\\[pagesize] *  THP mode: (\\\\S+)\");\n+        Pattern patternShmemTHPMode = Pattern.compile(\".*\\\\[pagesize] *Shared memory THP mode: (\\\\S+)\");\n@@ -265,0 +306,4 @@\n+            mat = patternShmemTHPMode.matcher(s);\n+            if (mat.matches()) {\n+                shmemThpMode = ShmemTHPMode.valueOf(mat.group(1));\n+            }\n@@ -267,1 +312,1 @@\n-        return new HugePageConfiguration(staticHugePageConfigs, defaultHugepageSize, thpMode, thpPageSize);\n+        return new HugePageConfiguration(staticHugePageConfigs, defaultHugepageSize, thpMode, thpPageSize, shmemThpMode);\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/HugePageConfiguration.java","additions":53,"deletions":8,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+        static final Pattern THP_ELIGIBLE_PATT = Pattern.compile(\"^THPeligible:\\\\s+(\\\\d*)\");\n@@ -150,0 +151,1 @@\n+        String thpEligible;\n@@ -157,0 +159,1 @@\n+            thpEligible = null;\n@@ -162,1 +165,1 @@\n-                RangeWithPageSize range = new RangeWithPageSize(start, end, ps, vmFlags);\n+                RangeWithPageSize range = new RangeWithPageSize(start, end, ps, thpEligible, vmFlags);\n@@ -170,1 +173,1 @@\n-            debug(\"\" + (lineno++) + \" \" + line);\n+            \/\/  For better debugging experience call finish here before the debug() call.\n@@ -174,0 +177,5 @@\n+            }\n+\n+            debug(\"\" + (lineno++) + \" \" + line);\n+\n+            if (matSectionStart.matches()) {\n@@ -185,0 +193,5 @@\n+                Matcher matTHPEligible = THP_ELIGIBLE_PATT.matcher(line);\n+                if (matTHPEligible.matches()) {\n+                    thpEligible = matTHPEligible.group(1);\n+                    return;\n+                }\n@@ -329,0 +342,1 @@\n+    private boolean thpEligible;\n@@ -331,0 +345,1 @@\n+    private boolean isTHP;\n@@ -332,1 +347,1 @@\n-    public RangeWithPageSize(String start, String end, String pageSize, String vmFlags) {\n+    public RangeWithPageSize(String start, String end, String pageSize, String thpEligible, String vmFlags) {\n@@ -338,0 +353,1 @@\n+        this.thpEligible = Integer.parseInt(thpEligible) == 1;\n@@ -351,0 +367,7 @@\n+\n+        \/\/ When the THP policy is 'always' instead of 'madvise, the vmFlagHG property is false.\n+        \/\/ Check the THPeligible property instead.\n+        isTHP = !vmFlagHT && this.thpEligible;\n+\n+        \/\/ vmFlagHG should imply isTHP\n+        assert !vmFlagHG || isTHP;\n@@ -358,1 +381,1 @@\n-        return vmFlagHG;\n+        return isTHP;\n@@ -371,1 +394,1 @@\n-               \"pageSize=\" + pageSize + \"KB isTHP=\" + vmFlagHG + \" isHUGETLB=\" + vmFlagHT;\n+               \"pageSize=\" + pageSize + \"KB isTHP=\" + isTHP + \" isHUGETLB=\" + vmFlagHT;\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"}]}