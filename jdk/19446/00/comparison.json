{"files":[{"patch":"@@ -151,9 +151,11 @@\n-    ShenandoahReentrantLocker locker(nm_data->lock());\n-\n-    \/\/ Heal oops and disarm\n-    if (_bs->is_armed(nm)) {\n-      ShenandoahEvacOOMScope oom_evac_scope;\n-      ShenandoahNMethod::heal_nmethod_metadata(nm_data);\n-      \/\/ Code cache unloading needs to know about on-stack nmethods. Arm the nmethods to get\n-      \/\/ mark_as_maybe_on_stack() callbacks when they are used again.\n-      _bs->set_guard_value(nm, 0);\n+    {\n+      ShenandoahReentrantLocker locker(nm_data->lock());\n+\n+      \/\/ Heal oops and disarm\n+      if (_bs->is_armed(nm)) {\n+        ShenandoahEvacOOMScope oom_evac_scope;\n+        ShenandoahNMethod::heal_nmethod_metadata(nm_data);\n+        \/\/ Code cache unloading needs to know about on-stack nmethods. Arm the nmethods to get\n+        \/\/ mark_as_maybe_on_stack() callbacks when they are used again.\n+        _bs->set_guard_value(nm, 0);\n+      }\n@@ -163,0 +165,1 @@\n+    ShenandoahReentrantLocker locker(nm_data->ic_lock());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  _nm(nm), _oops(nullptr), _oops_count(0), _unregistered(false) {\n+  _nm(nm), _oops(nullptr), _oops_count(0), _unregistered(false), _lock(), _ic_lock() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  ShenandoahReentrantLock _ic_lock;\n@@ -54,0 +55,1 @@\n+  inline ShenandoahReentrantLock* ic_lock();\n@@ -62,0 +64,1 @@\n+  static inline ShenandoahReentrantLock* ic_lock_for_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+ShenandoahReentrantLock* ShenandoahNMethod::ic_lock() {\n+  return &_ic_lock;\n+}\n+\n@@ -88,0 +92,4 @@\n+ShenandoahReentrantLock* ShenandoahNMethod::ic_lock_for_nmethod(nmethod* nm) {\n+  return gc_data(nm)->ic_lock();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    ShenandoahReentrantLock* const lock = ShenandoahNMethod::lock_for_nmethod(nm);\n+    ShenandoahReentrantLock* const lock = ShenandoahNMethod::ic_lock_for_nmethod(nm);\n@@ -101,1 +101,1 @@\n-    ShenandoahReentrantLock* const lock = ShenandoahNMethod::lock_for_nmethod(nm);\n+    ShenandoahReentrantLock* const lock = ShenandoahNMethod::ic_lock_for_nmethod(nm);\n@@ -111,1 +111,1 @@\n-    ShenandoahReentrantLock* const lock = ShenandoahNMethod::lock_for_nmethod(nm);\n+    ShenandoahReentrantLock* const lock = ShenandoahNMethod::ic_lock_for_nmethod(nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,0 +102,4 @@\n+XReentrantLock* XNMethod::ic_lock_for_nmethod(nmethod* nm) {\n+  return gc_data(nm)->ic_lock();\n+}\n+\n@@ -298,1 +302,2 @@\n-    XLocker<XReentrantLock> locker(XNMethod::lock_for_nmethod(nm));\n+    {\n+      XLocker<XReentrantLock> locker(XNMethod::lock_for_nmethod(nm));\n@@ -300,4 +305,5 @@\n-    if (XNMethod::is_armed(nm)) {\n-      \/\/ Heal oops and arm phase invariantly\n-      XNMethod::nmethod_oops_barrier(nm);\n-      XNMethod::set_guard_value(nm, 0);\n+      if (XNMethod::is_armed(nm)) {\n+        \/\/ Heal oops and arm phase invariantly\n+        XNMethod::nmethod_oops_barrier(nm);\n+        XNMethod::set_guard_value(nm, 0);\n+      }\n@@ -307,0 +313,1 @@\n+    XLocker<XReentrantLock> locker(XNMethod::ic_lock_for_nmethod(nm));\n","filename":"src\/hotspot\/share\/gc\/x\/xNMethod.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  static XReentrantLock* ic_lock_for_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/x\/xNMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    _ic_lock(),\n@@ -79,0 +80,4 @@\n+XReentrantLock* XNMethodData::ic_lock() {\n+  return &_ic_lock;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/x\/xNMethodData.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  XReentrantLock             _ic_lock;\n@@ -66,0 +67,1 @@\n+  XReentrantLock* ic_lock();\n","filename":"src\/hotspot\/share\/gc\/x\/xNMethodData.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-    XReentrantLock* const lock = XNMethod::lock_for_nmethod(nm);\n+    XReentrantLock* const lock = XNMethod::ic_lock_for_nmethod(nm);\n@@ -96,1 +96,1 @@\n-    XReentrantLock* const lock = XNMethod::lock_for_nmethod(nm);\n+    XReentrantLock* const lock = XNMethod::ic_lock_for_nmethod(nm);\n@@ -105,1 +105,1 @@\n-    XReentrantLock* const lock = XNMethod::lock_for_nmethod(nm);\n+    XReentrantLock* const lock = XNMethod::ic_lock_for_nmethod(nm);\n","filename":"src\/hotspot\/share\/gc\/x\/xUnload.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,0 +107,4 @@\n+ZReentrantLock* ZNMethod::ic_lock_for_nmethod(nmethod* nm) {\n+  return gc_data(nm)->ic_lock();\n+}\n+\n@@ -354,1 +358,2 @@\n-    ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));\n+    {\n+      ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));\n@@ -356,3 +361,3 @@\n-    if (ZNMethod::is_armed(nm)) {\n-      const uintptr_t prev_color = ZNMethod::color(nm);\n-      assert(prev_color != ZPointerStoreGoodMask, \"Potentially non-monotonic transition\");\n+      if (ZNMethod::is_armed(nm)) {\n+        const uintptr_t prev_color = ZNMethod::color(nm);\n+        assert(prev_color != ZPointerStoreGoodMask, \"Potentially non-monotonic transition\");\n@@ -360,3 +365,3 @@\n-      \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n-      ZUncoloredRootProcessOopClosure cl(prev_color);\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+        \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n+        ZUncoloredRootProcessOopClosure cl(prev_color);\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n@@ -364,4 +369,4 @@\n-      \/\/ Disarm for marking and relocation, but leave the remset bits so this isn't store good.\n-      \/\/ This makes sure the mutator still takes a slow path to fill in the nmethod epoch for\n-      \/\/ the sweeper, to track continuations, if they exist in the system.\n-      const zpointer new_disarm_value_ptr = ZAddress::color(zaddress::null, ZPointerMarkGoodMask | ZPointerRememberedMask);\n+        \/\/ Disarm for marking and relocation, but leave the remset bits so this isn't store good.\n+        \/\/ This makes sure the mutator still takes a slow path to fill in the nmethod epoch for\n+        \/\/ the sweeper, to track continuations, if they exist in the system.\n+        const zpointer new_disarm_value_ptr = ZAddress::color(zaddress::null, ZPointerMarkGoodMask | ZPointerRememberedMask);\n@@ -369,4 +374,4 @@\n-      \/\/ The new disarm value is mark good, and hence never store good. Therefore, this operation\n-      \/\/ never completely disarms the nmethod. Therefore, we don't need to patch barriers yet\n-      \/\/ via ZNMethod::nmethod_patch_barriers.\n-      ZNMethod::set_guard_value(nm, (int)untype(new_disarm_value_ptr));\n+        \/\/ The new disarm value is mark good, and hence never store good. Therefore, this operation\n+        \/\/ never completely disarms the nmethod. Therefore, we don't need to patch barriers yet\n+        \/\/ via ZNMethod::nmethod_patch_barriers.\n+        ZNMethod::set_guard_value(nm, (int)untype(new_disarm_value_ptr));\n@@ -374,2 +379,3 @@\n-      log_trace(gc, nmethod)(\"nmethod: \" PTR_FORMAT \" visited by unlinking [\" PTR_FORMAT \" -> \" PTR_FORMAT \"]\", p2i(nm), prev_color, untype(new_disarm_value_ptr));\n-      assert(ZNMethod::is_armed(nm), \"Must be considered armed\");\n+        log_trace(gc, nmethod)(\"nmethod: \" PTR_FORMAT \" visited by unlinking [\" PTR_FORMAT \" -> \" PTR_FORMAT \"]\", p2i(nm), prev_color, untype(new_disarm_value_ptr));\n+        assert(ZNMethod::is_armed(nm), \"Must be considered armed\");\n+      }\n@@ -379,0 +385,1 @@\n+    ZLocker<ZReentrantLock> locker(ZNMethod::ic_lock_for_nmethod(nm));\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  static ZReentrantLock* ic_lock_for_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+    _ic_lock(),\n@@ -39,0 +40,4 @@\n+ZReentrantLock* ZNMethodData::ic_lock() {\n+  return &_ic_lock;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodData.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  ZReentrantLock              _ic_lock;\n@@ -49,0 +50,1 @@\n+  ZReentrantLock* ic_lock();\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodData.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);\n+    ZReentrantLock* const lock = ZNMethod::ic_lock_for_nmethod(nm);\n@@ -99,1 +99,1 @@\n-    ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);\n+    ZReentrantLock* const lock = ZNMethod::ic_lock_for_nmethod(nm);\n@@ -108,1 +108,1 @@\n-    ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);\n+    ZReentrantLock* const lock = ZNMethod::ic_lock_for_nmethod(nm);\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}