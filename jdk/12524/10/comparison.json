{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,3 @@\n+    \/\/ Flag to indicate readEnd should expect 64 bit Data Descriptor size fields\n+    private boolean expect64BitDataDescriptor;\n+\n@@ -526,0 +529,7 @@\n+\n+        \/\/ Expect 32-bit Data Descriptor size fields by default\n+        expect64BitDataDescriptor = false;\n+\n+        long csize = get32(tmpbuf, LOCSIZ);\n+        long size = get32(tmpbuf, LOCLEN);\n+\n@@ -534,2 +544,2 @@\n-            e.csize = get32(tmpbuf, LOCSIZ);\n-            e.size = get32(tmpbuf, LOCLEN);\n+            e.csize = csize;\n+            e.size = size;\n@@ -543,0 +553,2 @@\n+            \/\/ Determine if readEnd should expect 64-bit size fields in the Data Descriptor\n+            expect64BitDataDescriptor = expect64BitDataDescriptor(extra, flag, csize, size);\n@@ -582,1 +594,2 @@\n-                inf.getBytesRead() > ZIP64_MAGICVAL) {\n+                inf.getBytesRead() > ZIP64_MAGICVAL ||\n+                    expect64BitDataDescriptor) {\n@@ -630,0 +643,85 @@\n+    \/**\n+     * Determine whether the {@link #readEnd(ZipEntry)} method should interpret the\n+     * 'compressed size' and 'uncompressed size' fields of the Data Descriptor record\n+     * as 64-bit numbers instead of the regular 32-bit numbers.\n+     *\n+     * Returns true if the LOC has the 'streaming mode' flag set, the 'compressed size' and\n+     * 'uncompressed size' are set to the Zip64 magic value 0xFFFFFFFF, and the LOC's extra field\n+     * contains a Zip64 field where both 'Original Size' and 'Compressed Size' are set to zero.\n+     *\n+     * @param extra the LOC extra field to look for a Zip64 field in\n+     * @param flag the value of the 'general purpose bit flag' field in the LOC\n+     * @param csize the value of the 'compressed size' field in the LOC\n+     * @param size  the value of the 'uncompressed size' field in the LOC\n+     *\/\n+    private boolean expect64BitDataDescriptor(byte[] extra, int flag, long csize, long size)  {\n+        \/\/ The LOC's 'general purpose bit flag' 3 must indicate use of a Data Descriptor\n+        if ((flag & 8) == 0) {\n+            return false;\n+        }\n+\n+        \/\/ The LOC's 'compressed size' and 'uncompressed size' must both be marked for Zip64\n+        if (csize != ZIP64_MAGICVAL || size != ZIP64_MAGICVAL) {\n+            return false;\n+        }\n+\n+        \/\/ Look for a Zip64 field valid for use with data descriptors\n+        int headerSize = 2 * Short.BYTES; \/\/ id + size\n+        if (extra != null) {\n+            for (int i = 0; i + headerSize < extra.length;) {\n+                int id = get16(extra, i);\n+                int dsize = get16(extra, i + Short.BYTES);\n+                if (i + headerSize + dsize > extra.length) {\n+                    return false; \/\/ Invalid size\n+                }\n+                if (isZip64DataDescriptorField(id, extra, i + headerSize, dsize)) {\n+                    return true;\n+                }\n+                i += headerSize + dsize;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns true if the given extra field is a Zip64 field with both 'Original Size'\n+     * and 'Compressed Size' fields set to zero, making it valid for use with a Data Descriptor.\n+     * <p>\n+     * The order of the Zip64 fields is fixed, but the fields MUST\n+     * only appear if the corresponding LOC field is set to 0xFFFFFFFF:\n+     * Uncompressed Size - 8 bytes\n+     * Compressed Size   - 8 bytes\n+     * <p>\n+     * This entry in the Local header MUST include BOTH original\n+     * and compressed file size fields.\n+     * <p>\n+     * See PKWare APP.Note Section 4.5.3 for more details\n+     *\n+     * @param headerId the extra field header id\n+     * @param extra the array where the extra block is stored\n+     * @param blockStart the offset into the array where the extra block starts\n+     * @param blockSize the size of the extra field data block\n+     * @return true if the extra field is a Zip64 extra field compatible with data descriptors\n+     *\/\n+    private static boolean isZip64DataDescriptorField(int headerId, byte[] extra, int blockStart, int blockSize) {\n+        if (headerId != ZIP64_EXTID) {\n+            return false; \/\/ Not a Zip64 extra field \n+        }\n+        \n+        if (blockSize != 16) {\n+            return false; \/\/ MUST include BOTH original and compressed file size\n+        }\n+\n+        \/\/ Sanity check that we can access the full block size in the array\n+        if (extra == null || blockStart + blockSize > extra.length) {\n+            return false;\n+        }\n+\n+        \/\/ Read the original and compressed size fields\n+        long size = get64(extra, blockStart);\n+        long csize = get64(extra, blockStart + 8);\n+\n+        \/\/ Used with Data Descriptors, both fields should be zero\n+        return size == 0 && csize == 0;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":102,"deletions":4,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303866\n+ * @summary ZipInputStream should read 8-byte data descriptors if the LOC has\n+ *   a ZIP64 extended information extra field\n+ * @run junit Zip64DataDescriptor\n+ *\/\n+\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HexFormat;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class Zip64DataDescriptor {\n+\n+    \/\/ A byte array holding a small-sized Zip64 ZIP file, described below\n+    private byte[] zip64File;\n+\n+    \/\/ A byte array holding a ZIP used for testing invalid Zip64 extra fields\n+    private byte[] invalidZip64;\n+\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        \/*\n+         * Structure of the ZIP64 file used below . Note the presence\n+         * of a Zip64 extended information extra field and the\n+         * Data Descriptor having 8-byte values for csize and size.\n+         *\n+         * The file was produced using the zip command on MacOS\n+         * (zip 3.0, by Info-ZIP), in streamming mode (to enable Zip64),\n+         * using the -fd option (to force the use of data descriptors)\n+         *\n+         * The following command was used:\n+         * <pre>echo hello | zip -fd > hello.zip<\/pre>\n+         *\n+         * ------  Local File Header  ------\n+         * 000000  signature          0x04034b50\n+         * 000004  version            45\n+         * 000006  flags              0x0008\n+         * 000008  method             8              Deflated\n+         * 000010  time               0xb180         22:12\n+         * 000012  date               0x565c         2023-02-28\n+         * 000014  crc                0x00000000\n+         * 000018  csize              -1\n+         * 000022  size               -1\n+         * 000026  nlen               1\n+         * 000028  elen               20\n+         * 000030  name               1 bytes        '-'\n+         * 000031  ext id             0x0001         Zip64 extended information extra field\n+         * 000033  ext size           16\n+         * 000035  z64 size           0\n+         * 000043  z64 csize          0\n+         *\n+         * ------  File Data  ------\n+         * 000051  data               8 bytes\n+         *\n+         * ------  Data Desciptor  ------\n+         * 000059  signature          0x08074b50\n+         * 000063  crc                0x363a3020\n+         * 000067  csize              8\n+         * 000075  size               6\n+         * 000083  ...\n+         *\/\n+\n+        String hex = \"\"\"\n+                504b03042d000800080080b15c5600000000ffffffffffffffff01001400\n+                2d0100100000000000000000000000000000000000cb48cdc9c9e7020050\n+                4b070820303a3608000000000000000600000000000000504b01021e032d\n+                000800080080b15c5620303a360800000006000000010000000000000001\n+                000000b011000000002d504b050600000000010001002f00000053000000\n+                0000\"\"\";\n+\n+        zip64File = HexFormat.of().parseHex(hex.replaceAll(\"\\n\", \"\"));\n+\n+        \/\/ Create the ZIP file used for testing that invalid Zip64 extra fields are ignored\n+        \/\/ This ZIP has the regular 4-bit data descriptor\n+\n+        byte[] extra = new byte[Long.BYTES  + Long.BYTES + Short.BYTES * 2]; \/\/ Size of a regular Zip64 extra field\n+        ByteBuffer buffer = ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putShort(0, (short) 123); \/\/ Not processed by ZipEntry.setExtra\n+        buffer.putShort(Short.BYTES, (short) (extra.length - 4));\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(baos)) {\n+            ZipEntry ze = new ZipEntry(\"hello\");\n+            ze.setExtra(extra);\n+            zo.putNextEntry(ze);\n+            zo.write(\"hello\\n\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        invalidZip64 = baos.toByteArray();\n+\n+        \/\/ Set Zip64 magic values on compressed and uncompressed size fields\n+        ByteBuffer.wrap(invalidZip64).order(ByteOrder.LITTLE_ENDIAN)\n+                .putInt(ZipFile.LOCSIZ, 0xFFFFFFFF)\n+                .putInt(ZipFile.LOCLEN, 0xFFFFFFFF);\n+\n+    }\n+\n+    \/*\n+     * Verify that small-sized Zip64 entries can be parsed by ZipInputStream\n+     *\/\n+    @Test\n+    public void shouldReadZip64Descriptor() throws IOException {\n+        readZipInputStream(zip64File);\n+    }\n+\n+    \/*\n+     * For maximal backward compatibility when reading Zip64 descriptors, invalid\n+     * Zip64 extra data sizes should be ignored\n+     *\/\n+    @Test\n+    public void shouldIgnoreInvalidExtraSize() throws IOException {\n+\n+        setExtraSize((short) 42);\n+\n+\n+        readZipInputStream(invalidZip64);\n+\n+    }\n+\n+    \/*\n+     * Validate that an extra data size exceeding the length of the extra field is ignored\n+     *\/\n+    @Test\n+    public void shouldIgnoreExcessiveExtraSize() throws IOException {\n+\n+        setExtraSize(Short.MAX_VALUE);\n+\n+\n+        readZipInputStream(invalidZip64);\n+    }\n+\n+    \/*\n+     * Validate that the Data Descriptor is read with 32-bit fields if neither the\n+     * LOC's 'uncompressed size' or 'compressed size' fields have the Zip64 magic value,\n+     * even when there is a Zip64 field in the extra field.\n+     *\/\n+    @Test\n+    public void shouldIgnoreNoMagicMarkers() throws IOException {\n+        \/\/ Set compressed and uncompressed size fields to zero\n+        ByteBuffer.wrap(invalidZip64).order(ByteOrder.LITTLE_ENDIAN)\n+                .putInt(ZipFile.LOCSIZ, 0)\n+                .putInt(ZipFile.LOCLEN, 0);\n+\n+\n+        readZipInputStream(invalidZip64);\n+    }\n+\n+    \/*\n+     * Validate that an extra data size exceeding the length of the extra field is ignored\n+     *\/\n+    @Test\n+    public void shouldIgnoreTrucatedZip64Extra() throws IOException {\n+\n+        truncateZip64();\n+\n+        readZipInputStream(invalidZip64);\n+    }\n+\n+    \/**\n+     * Updates the 16-bit 'data size' field of the Zip64 extended information field,\n+     * potentially to an invalid value.\n+     * @param size the value to set in the 'data size' field.\n+     *\/\n+    private void setExtraSize(short size) {\n+        ByteBuffer buffer = ByteBuffer.wrap(zip64File).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Compute the offset to the Zip64 data block size field\n+        short nlen = buffer.getShort(ZipFile.LOCNAM);\n+        int dataSizeOffset = ZipFile.LOCHDR + nlen + Short.BYTES;\n+        buffer.putShort(dataSizeOffset, size);\n+    }\n+\n+    \/**\n+     * Puts a truncated Zip64 field (just the tag) at the end of the LOC extra field.\n+     * The beginning of the extra field is filled with a generic extra field containing\n+     * just zeros.\n+     *\/\n+    private void truncateZip64() {\n+        ByteBuffer buffer = ByteBuffer.wrap(invalidZip64).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Get the LOC name and extra sizes\n+        short nlen = buffer.getShort(ZipFile.LOCNAM);\n+        short elen = buffer.getShort(ZipFile.LOCEXT);\n+        int cenOffset = ZipFile.LOCHDR + nlen + elen;\n+\n+        \/\/ Zero out the extra field\n+        int estart = ZipFile.LOCHDR + nlen;\n+        buffer.put(estart, new byte[elen]);\n+        \/\/ Put a generic extra field in the start\n+        buffer.putShort(estart, (short) 42);\n+        buffer.putShort(estart + Short.BYTES, (short) (elen - 4 - 2));\n+        \/\/ Put a truncated (just the tag) Zip64 field at the end\n+        buffer.putShort(cenOffset - Short.BYTES, (short) 0x0001);\n+    }\n+\n+    \/*\n+     * Consume all entries in a ZipInputStream, possibly throwing a\n+     * ZipException if the reading of any entry stream fails.\n+     *\/\n+    private void readZipInputStream(byte[] zip) throws IOException {\n+        try (ZipInputStream in = new ZipInputStream(new ByteArrayInputStream(zip))) {\n+            ZipEntry e;\n+            while ( (e = in.getNextEntry()) != null) {\n+                assertEquals(\"hello\\n\", new String(in.readAllBytes(), StandardCharsets.UTF_8));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipInputStream\/Zip64DataDescriptor.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"}]}