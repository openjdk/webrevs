{"files":[{"patch":"@@ -581,1 +581,2 @@\n-            if (inf.getBytesWritten() > ZIP64_MAGICVAL ||\n+            if (hasZip64Extra(e) ||\n+                inf.getBytesWritten() > ZIP64_MAGICVAL ||\n@@ -630,0 +631,62 @@\n+    \/**\n+     * Returns true if the ZipEntry has a valid Zip64 extended information extra field.\n+     *\n+     * This method is used by {@link #readEnd(ZipEntry)} to determine whether the\n+     * 'size' and 'compressed size' fields of the Data Descriptor record should\n+     * be interpreted as 64-bit numbers instead of the regular 32-bit numbers.\n+     *\n+     * While ZipOutputStream only produces a Zip64 extra field if either the size or\n+     * compressed size of the entry exceeds 0XFFFFFFFF, the ZIP APPNOTE.txt format\n+     * specification explicitly allows the use of Zip64 format for entries of any size:\n+     *\n+     * <pre>\n+     * When extracting, if the zip64 extended information extra\n+     * field is present for the file the compressed and\n+     * uncompressed sizes will be 8 byte values.\n+     * <\/pre>\n+     *\n+     * To guard against invalid or corrupt extra fields, this method validates that\n+     * any Zip64 extended field has one of the four valid sizes.\n+     *\n+     * This method returns false for any invalid extra field lengths, as if the extra\n+     * data contained no Zip64 field.\n+     *\/\n+    private boolean hasZip64Extra(ZipEntry e) throws IOException {\n+        byte[] extra = e.extra;\n+        int fixedSize = 2 * Short.BYTES; \/\/ id + size\n+        if (extra != null && extra.length > fixedSize) {\n+            for (int i = 0; i < extra.length;) {\n+                int id = get16(extra, i);\n+                int size = get16(extra, i + Short.BYTES);\n+                if (i + fixedSize + size > extra.length) {\n+                    return false; \/\/ Invalid size\n+                }\n+                if (id == ZIP64_EXTID) {\n+                    return isZip64ExtBlockSizeValid(size);\n+                }\n+                i += fixedSize + size;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Validate the size of a Zip64 extended information field in the\n+     * LOC header.\n+     *\n+     * The order of the Zip64 fields is fixed, but the fields MUST\n+     * only appear if the corresponding LOC field is set to 0xFFFFFFFF:\n+     * Uncompressed Size - 8 bytes\n+     * Compressed Size   - 8 bytes\n+     * See PKWare APP.Note Section 4.5.3 for more details\n+     *\n+     * @param blockSize the Zip64 Extended Information Extra Field size\n+     * @return true if the extra block size is valid; false otherwise\n+     *\/\n+    private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n+        return switch (blockSize) {\n+            case 8, 16 -> true;\n+            default -> false;\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary ZipInputStream should read 8-byte data descriptors if the LOC has\n+ *   a ZIP64 extended information extra field\n+ * @run junit Zip64DataDescriptor\n+ *\/\n+\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HexFormat;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipInputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class Zip64DataDescriptor {\n+\n+    \/\/ A byte array holding a small-sized Zip64 ZIP file, described below\n+    private byte[] zip64File;\n+\n+    @BeforeEach\n+    public void setup() {\n+        \/*\n+         * Structure of the ZIP64 file used below . Note the precense\n+         * of a Zip64 extended information extra field and the\n+         * Data Descriptor having 8-byte values for csize and size.\n+         *\n+         * The file was produced using the following command:\n+         * <pre>echo hello | zip -fd > hello.zip<\/pre>\n+         *\n+         * ------  Local File Header  ------\n+         * 000000  signature          0x04034b50\n+         * 000004  version            45\n+         * 000006  flags              0x0008\n+         * 000008  method             8              Deflated\n+         * 000010  time               0xb180         22:12\n+         * 000012  date               0x565c         2023-02-28\n+         * 000014  crc                0x00000000\n+         * 000018  csize              -1\n+         * 000022  size               -1\n+         * 000026  nlen               1\n+         * 000028  elen               20\n+         * 000030  name               1 bytes        '-'\n+         * 000031  ext id             0x0001         Zip64 extended information extra field\n+         * 000033  ext size           16\n+         * 000035  z64 size           0\n+         * 000043  z64 csize          0\n+         *\n+         * ------  File Data  ------\n+         * 000051  data               8 bytes\n+         *\n+         * ------  Data Desciptor  ------\n+         * 000059  signature          0x08074b50\n+         * 000063  crc                0x363a3020\n+         * 000067  csize              8\n+         * 000075  size               6\n+         * 000083  ...\n+         *\/\n+\n+        String hex = \"\"\"\n+                504b03042d000800080080b15c5600000000ffffffffffffffff01001400\n+                2d0100100000000000000000000000000000000000cb48cdc9c9e7020050\n+                4b070820303a3608000000000000000600000000000000504b01021e032d\n+                000800080080b15c5620303a360800000006000000010000000000000001\n+                000000b011000000002d504b050600000000010001002f00000053000000\n+                0000\"\"\";\n+\n+        zip64File = HexFormat.of().parseHex(hex.replaceAll(\"\\n\", \"\"));\n+    }\n+\n+    \/*\n+     * Verify that small-sized Zip64 entries can be parsed by ZipInputStream\n+     *\/\n+    @Test\n+    public void shouldReadZip64Descriptor() throws IOException {\n+        readZipInputStream();\n+    }\n+\n+    \/*\n+     * For maximal backward compatibility when reading Zip64 descriptors, invalid\n+     * Zip64 extra data sizes should be ignored\n+     *\/\n+    @Test\n+    public void shouldIgnoreInvalidExtraSize() {\n+\n+        setExtraSize((short) 42);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            readZipInputStream();\n+        });\n+\n+        assertEquals(\"invalid entry size (expected 0 but got 6 bytes)\", ex.getMessage());\n+    }\n+\n+    \/*\n+     * Validate that an extra data size exceeding the length of the extra field is ignored\n+     *\/\n+    @Test\n+    public void shouldIgnoreExcessiveExtraSize() {\n+\n+        setExtraSize(Short.MAX_VALUE);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            readZipInputStream();\n+        });\n+\n+        assertEquals(\"invalid entry size (expected 0 but got 6 bytes)\", ex.getMessage());\n+    }\n+\n+    \/**\n+     * Updates the 16-bit 'data size' field of the Zip64 extended information field,\n+     * potentially to an invalid value.\n+     * @param size the value to set in the 'data size' field.\n+     *\/\n+    private void setExtraSize(short size) {\n+        int extSizeOffset = 33;\n+        ByteBuffer.wrap(zip64File).order(ByteOrder.LITTLE_ENDIAN)\n+                .putShort(extSizeOffset, size);\n+    }\n+\n+    \/*\n+     * Consume all entries in a ZipInputStream, possibly throwing a\n+     * ZipException if the reading of any entry stream fails.\n+     *\/\n+    private void readZipInputStream() throws IOException {\n+        try (ZipInputStream in = new ZipInputStream(new ByteArrayInputStream(zip64File))) {\n+            ZipEntry e;\n+            while ( (e = in.getNextEntry()) != null) {\n+                in.transferTo(OutputStream.nullOutputStream());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipInputStream\/Zip64DataDescriptor.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"}]}