{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,5 @@\n-import sun.nio.cs.UTF_8;\n-\n-import java.io.*;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PushbackInputStream;\n@@ -34,0 +36,2 @@\n+import sun.nio.cs.UTF_8;\n+\n@@ -89,0 +93,3 @@\n+    \/\/ Flag to indicate readEnd should expect 64 bit Data Descriptor size fields\n+    private boolean expect64BitDataDescriptor;\n+\n@@ -522,0 +529,7 @@\n+\n+        \/\/ Expect 32-bit Data Descriptor size fields by default\n+        expect64BitDataDescriptor = false;\n+\n+        long csize = get32(tmpbuf, LOCSIZ);\n+        long size = get32(tmpbuf, LOCLEN);\n+\n@@ -530,2 +544,2 @@\n-            e.csize = get32(tmpbuf, LOCSIZ);\n-            e.size = get32(tmpbuf, LOCLEN);\n+            e.csize = csize;\n+            e.size = size;\n@@ -539,0 +553,2 @@\n+            \/\/ Determine if readEnd should expect 64-bit size fields in the Data Descriptor\n+            expect64BitDataDescriptor = expect64BitDataDescriptor(extra, flag, csize, size);\n@@ -579,1 +595,1 @@\n-                hasZip64Extra(e)) {\n+                    expect64BitDataDescriptor) {\n@@ -628,21 +644,12 @@\n-     * Returns true if the ZipEntry has a valid Zip64 extended information extra field.\n-     *\n-     * This method is used by {@link #readEnd(ZipEntry)} to determine whether the\n-     * 'size' and 'compressed size' fields of the Data Descriptor record should\n-     * be interpreted as 64-bit numbers instead of the regular 32-bit numbers.\n-     *\n-     * While ZipOutputStream only produces a Zip64 extra field if either the size or\n-     * compressed size of the entry exceeds 0XFFFFFFFF, the ZIP APPNOTE.txt format\n-     * specification explicitly allows the use of Zip64 format for entries of any size:\n-     *\n-     * <pre>\n-     * When extracting, if the zip64 extended information extra\n-     * field is present for the file the compressed and\n-     * uncompressed sizes will be 8 byte values.\n-     * <\/pre>\n-     *\n-     * To guard against invalid or corrupt extra fields, this method validates that\n-     * any Zip64 extended field has a valid block size.\n-     *\n-     * This method returns false for any invalid extra block sizes, as if the extra\n-     * data contained no Zip64 field.\n+     * Determine whether the {@link #readEnd(ZipEntry)} method should interpret the\n+     * 'compressed size' and 'uncompressed size' fields of the Data Descriptor record\n+     * as 64-bit numbers instead of the regular 32-bit numbers.\n+     *\n+     * Returns true if the LOC has the 'streaming mode' flag set, the 'compressed size' and\n+     * 'uncompressed size' are set to the Zip64 magic value 0xFFFFFFFF, and the LOC's extra field\n+     * contains a Zip64 field where both 'Original Size' and 'Compressed Size' are set to zero.\n+     *\n+     * @param extra the LOC extra field to look for a Zip64 field in\n+     * @param flag the value of the 'general purpose bit flag' field in the LOC\n+     * @param csize the value of the 'compressed size' field in the LOC\n+     * @param size  the value of the 'uncompressed size' field in the LOC\n@@ -650,5 +657,15 @@\n-    private boolean hasZip64Extra(ZipEntry e)  {\n-        byte[] extra = e.extra;\n-        int fixedSize = 2 * Short.BYTES; \/\/ id + size\n-        if (extra != null && extra.length > fixedSize) {\n-            for (int i = 0; i < extra.length;) {\n+    private boolean expect64BitDataDescriptor(byte[] extra, int flag, long csize, long size)  {\n+        \/\/ The LOC's 'general purpose bit flag' 3 must indicate use of a Data Descriptor\n+        if ((flag & 8) == 0) {\n+            return false;\n+        }\n+\n+        \/\/ The LOC's 'compressed size' and 'uncompressed size' must both be marked for Zip64\n+        if (csize != ZIP64_MAGICVAL || size != ZIP64_MAGICVAL) {\n+            return false;\n+        }\n+\n+        \/\/ Look for a Zip64 field valid for use with data descriptors\n+        int headerSize = 2 * Short.BYTES; \/\/ id + size\n+        if (extra != null) {\n+            for (int i = 0; i + headerSize < extra.length;) {\n@@ -656,2 +673,2 @@\n-                int size = get16(extra, i + Short.BYTES);\n-                if (i + fixedSize + size > extra.length) {\n+                int dsize = get16(extra, i + Short.BYTES);\n+                if (i + headerSize + dsize > extra.length) {\n@@ -660,2 +677,2 @@\n-                if (id == ZIP64_EXTID) {\n-                    return isZip64ExtBlockSizeValid(size);\n+                if (isZip64DataDescriptorField(id, extra, i + headerSize, dsize)) {\n+                    return true;\n@@ -663,1 +680,1 @@\n-                i += fixedSize + size;\n+                i += headerSize + dsize;\n@@ -670,3 +687,3 @@\n-     * Validate the size of a Zip64 extended information field in the\n-     * LOC header.\n-     *\n+     * Returns true if the given extra field is a Zip64 field with both 'Original Size'\n+     * and 'Compressed Size' fields set to zero, making it valid for use with a Data Descriptor.\n+     * <p>\n@@ -677,1 +694,1 @@\n-     *\n+     * <p>\n@@ -680,1 +697,1 @@\n-     *\n+     * <p>\n@@ -683,2 +700,5 @@\n-     * @param blockSize the Zip64 Extended Information Extra Field size\n-     * @return true if the extra block size is valid in a LOC header; false otherwise\n+     * @param headerId the extra field header id\n+     * @param extra the array where the extra block is stored\n+     * @param blockStart the offset into the array where the extra block starts\n+     * @param blockSize the size of the extra field data block\n+     * @return true if the extra field is a Zip64 extra field compatible with data descriptors\n@@ -686,3 +706,20 @@\n-    private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n-        \/\/ Uncompressed and compressed size fields are 8 bytes each\n-        return blockSize == 16;\n+    private static boolean isZip64DataDescriptorField(int headerId, byte[] extra, int blockStart, int blockSize) {\n+        if (headerId != ZIP64_EXTID) {\n+            return false; \/\/ Not a Zip64 extra field \n+        }\n+        \n+        if (blockSize != 16) {\n+            return false; \/\/ MUST include BOTH original and compressed file size\n+        }\n+\n+        \/\/ Sanity check that we can access the full block size in the array\n+        if (extra == null || blockStart + blockSize > extra.length) {\n+            return false;\n+        }\n+\n+        \/\/ Read the original and compressed size fields\n+        long size = get64(extra, blockStart);\n+        long csize = get64(extra, blockStart + 8);\n+\n+        \/\/ Used with Data Descriptors, both fields should be zero\n+        return size == 0 && csize == 0;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":85,"deletions":48,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -41,0 +42,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -42,3 +44,1 @@\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipException;\n-import java.util.zip.ZipInputStream;\n+import java.util.zip.*;\n@@ -54,2 +54,2 @@\n-    \/\/ The offset in the ZIP file holding the Zip64 extra block size\n-    private static final int ZIP64_BLOCK_SIZE_OFFSET = 33;\n+    \/\/ A byte array holding a ZIP used for testing invalid Zip64 extra fields\n+    private byte[] invalidZip64;\n@@ -58,1 +58,1 @@\n-    public void setup() {\n+    public void setup() throws IOException {\n@@ -109,0 +109,24 @@\n+\n+        \/\/ Create the ZIP file used for testing that invalid Zip64 extra fields are ignored\n+        \/\/ This ZIP has the regular 4-bit data descriptor\n+\n+        byte[] extra = new byte[Long.BYTES  + Long.BYTES + Short.BYTES * 2]; \/\/ Size of a regular Zip64 extra field\n+        ByteBuffer buffer = ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN);\n+        buffer.putShort(0, (short) 123); \/\/ Not processed by ZipEntry.setExtra\n+        buffer.putShort(Short.BYTES, (short) (extra.length - 4));\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(baos)) {\n+            ZipEntry ze = new ZipEntry(\"hello\");\n+            ze.setExtra(extra);\n+            zo.putNextEntry(ze);\n+            zo.write(\"hello\\n\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        invalidZip64 = baos.toByteArray();\n+\n+        \/\/ Set Zip64 magic values on compressed and uncompressed size fields\n+        ByteBuffer.wrap(invalidZip64).order(ByteOrder.LITTLE_ENDIAN)\n+                .putInt(ZipFile.LOCSIZ, 0xFFFFFFFF)\n+                .putInt(ZipFile.LOCLEN, 0xFFFFFFFF);\n+\n@@ -116,1 +140,1 @@\n-        readZipInputStream();\n+        readZipInputStream(zip64File);\n@@ -124,1 +148,1 @@\n-    public void shouldIgnoreInvalidExtraSize() {\n+    public void shouldIgnoreInvalidExtraSize() throws IOException {\n@@ -128,3 +152,0 @@\n-        ZipException ex = assertThrows(ZipException.class, () -> {\n-            readZipInputStream();\n-        });\n@@ -132,1 +153,2 @@\n-        assertEquals(\"invalid entry size (expected 0 but got 6 bytes)\", ex.getMessage());\n+        readZipInputStream(invalidZip64);\n+\n@@ -139,1 +161,1 @@\n-    public void shouldIgnoreExcessiveExtraSize() {\n+    public void shouldIgnoreExcessiveExtraSize() throws IOException {\n@@ -143,3 +165,0 @@\n-        ZipException ex = assertThrows(ZipException.class, () -> {\n-            readZipInputStream();\n-        });\n@@ -147,1 +166,28 @@\n-        assertEquals(\"invalid entry size (expected 0 but got 6 bytes)\", ex.getMessage());\n+        readZipInputStream(invalidZip64);\n+    }\n+\n+    \/*\n+     * Validate that the Data Descriptor is read with 32-bit fields if neither the\n+     * LOC's 'uncompressed size' or 'compressed size' fields have the Zip64 magic value,\n+     * even when there is a Zip64 field in the extra field.\n+     *\/\n+    @Test\n+    public void shouldIgnoreNoMagicMarkers() throws IOException {\n+        \/\/ Set compressed and uncompressed size fields to zero\n+        ByteBuffer.wrap(invalidZip64).order(ByteOrder.LITTLE_ENDIAN)\n+                .putInt(ZipFile.LOCSIZ, 0)\n+                .putInt(ZipFile.LOCLEN, 0);\n+\n+\n+        readZipInputStream(invalidZip64);\n+    }\n+\n+    \/*\n+     * Validate that an extra data size exceeding the length of the extra field is ignored\n+     *\/\n+    @Test\n+    public void shouldIgnoreTrucatedZip64Extra() throws IOException {\n+\n+        truncateZip64();\n+\n+        readZipInputStream(invalidZip64);\n@@ -156,2 +202,27 @@\n-        ByteBuffer.wrap(zip64File).order(ByteOrder.LITTLE_ENDIAN)\n-                .putShort(ZIP64_BLOCK_SIZE_OFFSET, size);\n+        ByteBuffer buffer = ByteBuffer.wrap(zip64File).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Compute the offset to the Zip64 data block size field\n+        short nlen = buffer.getShort(ZipFile.LOCNAM);\n+        int dataSizeOffset = ZipFile.LOCHDR + nlen + Short.BYTES;\n+        buffer.putShort(dataSizeOffset, size);\n+    }\n+\n+    \/**\n+     * Puts a truncated Zip64 field (just the tag) at the end of the LOC extra field.\n+     * The beginning of the extra field is filled with a generic extra field containing\n+     * just zeros.\n+     *\/\n+    private void truncateZip64() {\n+        ByteBuffer buffer = ByteBuffer.wrap(invalidZip64).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Get the LOC name and extra sizes\n+        short nlen = buffer.getShort(ZipFile.LOCNAM);\n+        short elen = buffer.getShort(ZipFile.LOCEXT);\n+        int cenOffset = ZipFile.LOCHDR + nlen + elen;\n+\n+        \/\/ Zero out the extra field\n+        int estart = ZipFile.LOCHDR + nlen;\n+        buffer.put(estart, new byte[elen]);\n+        \/\/ Put a generic extra field in the start\n+        buffer.putShort(estart, (short) 42);\n+        buffer.putShort(estart + Short.BYTES, (short) (elen - 4 - 2));\n+        \/\/ Put a truncated (just the tag) Zip64 field at the end\n+        buffer.putShort(cenOffset - Short.BYTES, (short) 0x0001);\n@@ -164,2 +235,2 @@\n-    private void readZipInputStream() throws IOException {\n-        try (ZipInputStream in = new ZipInputStream(new ByteArrayInputStream(zip64File))) {\n+    private void readZipInputStream(byte[] zip) throws IOException {\n+        try (ZipInputStream in = new ZipInputStream(new ByteArrayInputStream(zip))) {\n@@ -168,1 +239,1 @@\n-                in.transferTo(OutputStream.nullOutputStream());\n+                assertEquals(\"hello\\n\", new String(in.readAllBytes(), StandardCharsets.UTF_8));\n","filename":"test\/jdk\/java\/util\/zip\/ZipInputStream\/Zip64DataDescriptor.java","additions":94,"deletions":23,"binary":false,"changes":117,"status":"modified"}]}