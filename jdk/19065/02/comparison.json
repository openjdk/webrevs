{"files":[{"patch":"@@ -1907,0 +1907,10 @@\n+#define INSN(NAME, op, funct3, Vs1, funct6)                                    \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, VectorMask vm = unmasked) { \\\n+    patch_VArith(op, Vd, funct3, Vs1, Vs2, vm, funct6);                        \\\n+  }\n+\n+  \/\/ Vector Basic Bit-manipulation (Zvbb) Extension\n+  INSN(vcpop_v,  0b1010111, 0b010, 0b01110, 0b010010);\n+\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+  product(bool, UseZvbb, false, EXPERIMENTAL, \"Use Zvbb instructions\")                         \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+      case Op_PopCountVL:\n+      case Op_PopCountVI:\n+        return UseZvbb;\n@@ -3787,0 +3790,31 @@\n+\n+\/\/ ------------------------------ Popcount vector ------------------------------\n+\n+instruct vpopcount_mask(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (PopCountVI dst_src v0));\n+  match(Set dst_src (PopCountVL dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcpop_v $dst_src, $dst_src, $v0\\t# vcpop_v with mask\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vcpop_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcount(vReg dst, vReg src) %{\n+  match(Set dst (PopCountVI src));\n+  match(Set dst (PopCountVL src));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcpop_v $dst, $src\\t# vcpop_v without mask\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vcpop_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -248,0 +248,6 @@\n+  \/\/ UseZvbb (depends on RVV).\n+  if (UseZvbb && !UseRVV) {\n+    FLAG_SET_DEFAULT(UseZvbb, false);\n+    warning(\"Cannot enable UseZvbb on cpu without RVV support.\");\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+  decl(ext_Zvbb        , \"Zvbb\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZvbb))        \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -178,0 +178,3 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZVBB)) {\n+    VM_Version::ext_Zvbb.enable_feature();\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,1 +105,3 @@\n-        \"sve\"\n+        \"sve\",\n+        \/\/ Riscv64\n+        \"zvbb\"\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,0 +147,5 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\",\"UsePopCountInstruction\", \"true\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\",\n+                  IRNode.POPCOUNT_VL, \">= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestGeneralizedReductions.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+        int err = 0;\n@@ -48,1 +49,1 @@\n-        test.checkResult();\n+        err += test.checkResult();\n@@ -54,1 +55,4 @@\n-        test.checkResult();\n+        err += test.checkResult();\n+        if (err > 0) {\n+            throw new RuntimeException(\"Error!\");\n+        }\n@@ -71,1 +75,2 @@\n-    public void checkResult() {\n+    public int checkResult() {\n+        int err = 0;\n@@ -75,1 +80,3 @@\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+                err++;\n+                System.err.println(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected +\n+                                   \", input[\" + i + \"] == \" + Integer.toBinaryString(input[i]));\n@@ -78,0 +85,1 @@\n+        return err;\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVector.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n-*           os.simpleArch == \"aarch64\"\n+*           os.simpleArch == \"aarch64\" |\n+*           (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zvbb,.*\")\n@@ -35,0 +36,1 @@\n+\n@@ -65,1 +67,3 @@\n-        checkResult();\n+        if (checkResult() > 0) {\n+            throw new RuntimeException(\"Error!\");\n+        }\n@@ -68,1 +72,2 @@\n-    public void checkResult() {\n+    public int checkResult() {\n+        int err = 0;\n@@ -72,1 +77,3 @@\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+                err++;\n+                System.err.println(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected +\n+                                   \", input[\" + i + \"] == \" + Long.toBinaryString(input[i]));\n@@ -75,0 +82,1 @@\n+        return err;\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"}]}