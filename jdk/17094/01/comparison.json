{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2899,1 +2899,0 @@\n-\n@@ -2902,4 +2901,1 @@\n-  int result_count = 0;\n-  \/\/ First, count the fields.\n-  FilteredFieldStream flds(ik, true, true);\n-  result_count = flds.field_count();\n+  FilteredJavaFieldStream flds(ik);\n@@ -2907,5 +2903,1 @@\n-  \/\/ Allocate the result and fill it in\n-  jfieldID* result_list = (jfieldID*) jvmtiMalloc(result_count * sizeof(jfieldID));\n-  \/\/ The JVMTI spec requires fields in the order they occur in the class file,\n-  \/\/ this is the reverse order of what FieldStream hands out.\n-  int id_index = (result_count - 1);\n+  int result_count = flds.field_count();\n@@ -2913,4 +2905,6 @@\n-  for (FilteredFieldStream src_st(ik, true, true); !src_st.eos(); src_st.next()) {\n-    result_list[id_index--] = jfieldIDWorkaround::to_jfieldID(\n-                                            ik, src_st.offset(),\n-                                            src_st.access_flags().is_static());\n+  \/\/ Allocate the result and fill it in.\n+  jfieldID* result_list = (jfieldID*)jvmtiMalloc(result_count * sizeof(jfieldID));\n+  for (int i = 0; i < result_count; i++, flds.next()) {\n+    result_list[i] = jfieldIDWorkaround::to_jfieldID(\n+          ik, flds.offset(),\n+          flds.access_flags().is_static());\n@@ -2918,1 +2912,2 @@\n-  assert(id_index == -1, \"just checking\");\n+  assert(flds.done(), \"just checking\");\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -240,0 +241,32 @@\n+\/\/ Iterate over Java fields filtering fields like reflection does.\n+class FilteredJavaFieldStream : public JavaFieldStream {\n+private:\n+  InstanceKlass* _klass;\n+  int  _filtered_fields_count;\n+  bool has_filtered_field() const { return (_filtered_fields_count > 0); }\n+  void skip_filtered_fields() {\n+    if (has_filtered_field()) {\n+      while (!done() && FilteredFieldsMap::is_filtered_field((Klass*)_klass, offset())) {\n+        JavaFieldStream::next();\n+      }\n+    }\n+  }\n+\n+public:\n+  FilteredJavaFieldStream(InstanceKlass* klass)\n+    : JavaFieldStream(klass),\n+      _klass(klass),\n+      _filtered_fields_count(FilteredFieldsMap::filtered_fields_count(klass, true))\n+  {\n+    \/\/ skip filtered fields at the beginning\n+    skip_filtered_fields();\n+  }\n+  int field_count() const {\n+    return _klass->java_fields_count() - _filtered_fields_count;\n+  }\n+  void next() {\n+    JavaFieldStream::next();\n+    skip_filtered_fields();\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.hpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}