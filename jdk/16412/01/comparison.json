{"files":[{"patch":"@@ -108,0 +108,13 @@\n+\n+JVMFlag::Error MonitorUnlinkBatchConstraintFunc(intx value, bool verbose) {\n+  if (value < 1 || value > MonitorDeflationMax || value > max_jint) {\n+    JVMFlag::printError(verbose,\n+                        \"MonitorUnlinkBatch (\" INTX_FORMAT \") must be positive, \"\n+                        \"less or equal MonitorDeflationMax (\" INTX_FORMAT \"), \"\n+                        \"and less than limit (%d) \\n\",\n+                        value, MonitorDeflationMax, max_jint);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  } else {\n+    return JVMFlag::SUCCESS;\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-  f(size_t, NUMAInterleaveGranularityConstraintFunc)\n+  f(size_t, NUMAInterleaveGranularityConstraintFunc)  \\\n+  f(intx,   MonitorUnlinkBatchConstraintFunc)\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -736,0 +736,4 @@\n+  product(intx, MonitorUnlinkBatch, 500, DIAGNOSTIC,                        \\\n+          \"The maximum number of monitors to unlink in one batch.\")         \\\n+          constraint(MonitorUnlinkBatchConstraintFunc, AfterErgo)           \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  size_t unlink_batch = 0;\n@@ -133,2 +134,2 @@\n-  ObjectMonitor* head = Atomic::load_acquire(&_head);\n-  ObjectMonitor* m = head;\n+  ObjectMonitor* m = Atomic::load_acquire(&_head);\n+\n@@ -138,1 +139,2 @@\n-      \/\/ Find next live ObjectMonitor.\n+      \/\/ Find next live ObjectMonitor. Batch up the unlinkable monitors, so we can\n+      \/\/ modify the list once per batch. The batch starts at \"m\".\n@@ -145,2 +147,9 @@\n-        if (unlinked_count >= (size_t)MonitorDeflationMax) {\n-          \/\/ Reached the max so bail out on the gathering loop.\n+        if (unlink_batch++ >= (size_t)MonitorUnlinkBatch) {\n+          \/\/ Reached the max batch, so bail out of the gathering loop.\n+          unlink_batch = 0;\n+          break;\n+        }\n+        if (prev == nullptr && Atomic::load(&_head) != m) {\n+          \/\/ Current batch used to be at head, but it is not at head anymore.\n+          \/\/ Bail out and figure out where we currently are. This avoids long\n+          \/\/ walks searching for new prev during unlink under heavy list inserts.\n@@ -150,0 +159,2 @@\n+\n+      \/\/ Unlink the found batch.\n@@ -151,3 +162,5 @@\n-        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, head, next);\n-        if (prev_head != head) {\n-          \/\/ Find new prev ObjectMonitor that just got inserted.\n+        \/\/ The batch is not preceded by another monitor. There is a chance the batch starts at head.\n+        \/\/ Optimistically assume no inserts happened, and try to remove the entire batch from the head.\n+        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, m, next);\n+        if (prev_head != m) {\n+          \/\/ Something must have updated the head. Figure out the actual prev for this batch.\n@@ -157,0 +170,1 @@\n+          assert(prev != nullptr, \"Should have found the batch head\");\n@@ -160,0 +174,3 @@\n+        \/\/ The batch is preceded by another monitor. This guarantees the current batch does not\n+        \/\/ start at head. Remove the entire batch without updating the head.\n+        assert(Atomic::load(&_head) != m, \"Sanity\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test id=defaults\n+ * @bug 8319048\n+ * @summary Test the MonitorUnlinkBatch options\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest defaults\n+ *\/\n+\n+\/*\n+ * @test id=illegal\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest illegal\n+ *\/\n+\n+\/*\n+ * @test id=aggressive\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest aggressive\n+ *\/\n+\n+\/*\n+ * @test id=lazy\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest lazy\n+ *\/\n+\n+\n+public class MonitorUnlinkBatchTest {\n+\n+    public static class Test {\n+        \/\/ Inflate a lot of monitors, so that threshold heuristics definitely fires\n+        private static final int MONITORS = 10_000;\n+\n+        \/\/ Use a handful of threads to inflate the monitors, to eat the cost of\n+        \/\/ wait(1) calls. This can be larger than available parallelism, since threads\n+        \/\/ would be time-waiting.\n+        private static final int THREADS = 16;\n+\n+        private static Thread[] threads;\n+        private static Object[] monitors;\n+\n+        public static void main(String... args) throws Exception {\n+            monitors = new Object[MONITORS];\n+            threads = new Thread[THREADS];\n+\n+            for (int t = 0; t < THREADS; t++) {\n+                int monStart = t * MONITORS \/ THREADS;\n+                int monEnd = (t + 1) * MONITORS \/ THREADS;\n+                threads[t] = new Thread(() -> {\n+                    for (int m = monStart; m < monEnd; m++) {\n+                        Object o = new Object();\n+                        synchronized (o) {\n+                            try {\n+                                o.wait(1);\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                        monitors[m] = o;\n+                    }\n+                });\n+                threads[t].start();\n+            }\n+\n+            for (Thread t : threads) {\n+                t.join();\n+            }\n+\n+            try {\n+                Thread.sleep(10_000);\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Expect the test label\");\n+        }\n+\n+        String test = args[0];\n+        switch (test) {\n+            case \"defaults\":\n+                test(true);\n+                break;\n+\n+            case \"illegal\":\n+                \/\/ Quick tests that should fail on JVM flags verification.\n+                test(false,\n+                    \"-XX:MonitorUnlinkBatch=-1\"\n+                );\n+                test(false,\n+                    \"-XX:MonitorUnlinkBatch=0\"\n+                );\n+                test(false,\n+                    \"-XX:MonitorDeflationMax=100000\",\n+                    \"-XX:MonitorUnlinkBatch=100001\"\n+                );\n+                break;\n+\n+            case \"aggressive\":\n+                \/\/ The smallest batch possible.\n+                test(true,\n+                    \"-XX:MonitorUnlinkBatch=1\"\n+                );\n+                break;\n+\n+            case \"lazy\":\n+                \/\/ The largest batch possible.\n+                test(true,\n+                    \"-XX:MonitorDeflationMax=1000000\",\n+                    \"-XX:MonitorUnlinkBatch=1000000\"\n+                );\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unknown test: \" + test);\n+        }\n+    }\n+\n+    public static void test(boolean expectPass, String... args) throws Exception {\n+        List<String> opts = new ArrayList<>();\n+        opts.add(\"-Xmx128M\");\n+        opts.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        opts.add(\"-XX:GuaranteedAsyncDeflationInterval=100\");\n+        opts.addAll(Arrays.asList(args));\n+        opts.add(\"MonitorUnlinkBatchTest$Test\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(opts);\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        if (expectPass) {\n+            oa.shouldHaveExitValue(0);\n+        } else {\n+            oa.shouldNotHaveExitValue(0);\n+            oa.shouldContain(\"must be positive, less or equal MonitorDeflationMax\");\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUnlinkBatchTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"}]}