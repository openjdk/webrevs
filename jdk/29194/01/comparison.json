{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        pipelineBuilder.excludeDirFromCopying(outputDir)\n+        pipelineBuilder\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-        if (!app.contentDirs().isEmpty()) {\n+        if (!app.contentDirSources().isEmpty()) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import java.util.stream.Collectors;\n+import jdk.jpackage.internal.util.RootedPath;\n+import java.util.stream.Stream;\n@@ -146,1 +149,3 @@\n-        for (var contentDir : app.contentDirs()) {\n+        app.contentDirSources().stream().filter(rootedPath -> {\n+            return rootedPath.branch().getNameCount() == 1;\n+        }).map(RootedPath::fullPath).forEach(contentDir -> {\n@@ -150,1 +155,1 @@\n-            } else if (!CONTENTS_SUB_DIRS.contains(contentDir.getFileName().toString())) {\n+            } else if (!CONTENTS_SUB_DIRS.contains(contentDir.getFileName())) {\n@@ -154,1 +159,1 @@\n-        }\n+        });\n@@ -261,2 +266,7 @@\n-    private static final Set<String> CONTENTS_SUB_DIRS = Set.of(\"MacOS\",\n-            \"Resources\", \"Frameworks\", \"PlugIns\", \"SharedSupport\");\n+    private static final Set<Path> CONTENTS_SUB_DIRS = Stream.of(\n+            \"MacOS\",\n+            \"Resources\",\n+            \"Frameworks\",\n+            \"PlugIns\",\n+            \"SharedSupport\"\n+    ).map(Path::of).collect(Collectors.toUnmodifiableSet());\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationBuilder.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Collection;\n@@ -33,0 +34,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -40,2 +42,2 @@\n-    MacDmgPackageBuilder dmgContent(List<Path> v) {\n-        dmgContent = v;\n+    MacDmgPackageBuilder dmgRootDirSources(Collection<RootedPath> v) {\n+        dmgRootDirSources = v;\n@@ -50,2 +52,2 @@\n-    List<Path> validatedDmgContent() {\n-        return Optional.ofNullable(dmgContent).orElseGet(List::of);\n+    private Collection<RootedPath> validatedDmgRootDirSources() {\n+        return Optional.ofNullable(dmgRootDirSources).orElseGet(List::of);\n@@ -59,1 +61,1 @@\n-                validatedDmgContent()));\n+                validatedDmgRootDirSources()));\n@@ -63,1 +65,1 @@\n-    private List<Path> dmgContent;\n+    private Collection<RootedPath> dmgRootDirSources;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackageBuilder.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -64,1 +65,0 @@\n-                .excludeDirFromCopying(outputDir)\n@@ -134,3 +134,1 @@\n-        for (Path path : pkg.content()) {\n-            FileUtils.copyRecursive(path, srcFolder.resolve(path.getFileName()));\n-        }\n+        RootedPath.copy(pkg.dmgRootDirSources().stream(), srcFolder);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackager.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import java.util.Collection;\n@@ -78,0 +79,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -95,1 +97,8 @@\n-        MAC_DMG_CONTENT.ifPresentIn(options, pkgBuilder::dmgContent);\n+        MAC_DMG_CONTENT.findIn(options).map((List<Collection<RootedPath>> v) -> {\n+            \/\/ Reverse the order of content sources.\n+            \/\/ If there are multiple source files for the same\n+            \/\/ destination file, only the first will be used.\n+            \/\/ Reversing the order of content sources makes it use the last file\n+            \/\/ from the original list of source files for the given destination file.\n+            return v.reversed().stream().flatMap(Collection::stream).toList();\n+        }).ifPresent(pkgBuilder::dmgRootDirSources);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromOptions.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -218,1 +218,0 @@\n-                .excludeDirFromCopying(outputDir)\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackager.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.util.List;\n+import java.util.Collection;\n@@ -30,0 +30,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -36,1 +37,1 @@\n-     * Returns additional top=level content for DMG package.\n+     * Returns the source paths that should be copied into the top-level directory of a DMG package.\n@@ -40,1 +41,1 @@\n-     * @return the additional top=level content for DMG package\n+     * @return the source paths of additional top-level content for DMG package\n@@ -42,1 +43,1 @@\n-    List<Path> content();\n+    Collection<RootedPath> dmgRootDirSources();\n@@ -44,1 +45,1 @@\n-    record Stub(Optional<Path> icon, List<Path> content) implements MacDmgPackageMixin {\n+    record Stub(Optional<Path> icon, Collection<RootedPath> dmgRootDirSources) implements MacDmgPackageMixin {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacDmgPackageMixin.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Collection;\n@@ -47,0 +48,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -68,2 +70,2 @@\n-                Optional.ofNullable(srcDir),\n-                Optional.ofNullable(contentDirs).orElseGet(List::of),\n+                Optional.ofNullable(appDirSources).orElseGet(List::of),\n+                Optional.ofNullable(contentDirSources).orElseGet(List::of),\n@@ -129,2 +131,2 @@\n-    ApplicationBuilder srcDir(Path v) {\n-        srcDir = v;\n+    ApplicationBuilder appDirSources(Collection<RootedPath> v) {\n+        appDirSources = v;\n@@ -134,2 +136,2 @@\n-    ApplicationBuilder contentDirs(List<Path> v) {\n-        contentDirs = v;\n+    ApplicationBuilder contentDirSources(Collection<RootedPath> v) {\n+        contentDirSources = v;\n@@ -249,2 +251,2 @@\n-                app.srcDir(),\n-                app.contentDirs(),\n+                app.appDirSources(),\n+                app.contentDirSources(),\n@@ -297,1 +299,1 @@\n-    private Path srcDir;\n+    private Collection<RootedPath> appDirSources;\n@@ -299,1 +301,1 @@\n-    private List<Path> contentDirs;\n+    private Collection<RootedPath> contentDirSources;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n-import java.io.IOException;\n@@ -35,1 +32,0 @@\n-import java.util.ArrayList;\n@@ -37,0 +33,1 @@\n+import java.util.Map;\n@@ -39,2 +36,0 @@\n-import java.util.function.Supplier;\n-import java.util.stream.Stream;\n@@ -48,1 +43,1 @@\n-import jdk.jpackage.internal.util.FileUtils;\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -89,1 +84,1 @@\n-    static ApplicationImageTaskAction<Application, ApplicationLayout> createCopyContentAction(Supplier<List<Path>> excludeCopyDirs) {\n+    static ApplicationImageTaskAction<Application, ApplicationLayout> createCopyContentAction() {\n@@ -91,13 +86,6 @@\n-            var excludeCandidates = Stream.concat(\n-                    excludeCopyDirs.get().stream(),\n-                    Stream.of(env.env().buildRoot(), env.env().appImageDir())\n-            ).map(Path::toAbsolutePath).toList();\n-\n-            env.app().srcDir().ifPresent(toConsumer(srcDir -> {\n-                copyRecursive(srcDir, env.resolvedLayout().appDirectory(), excludeCandidates);\n-            }));\n-\n-            for (var srcDir : env.app().contentDirs()) {\n-                copyRecursive(srcDir,\n-                        env.resolvedLayout().contentDirectory().resolve(srcDir.getFileName()),\n-                        excludeCandidates);\n+            for (var e : List.of(\n+                    Map.entry(env.app().appDirSources(), env.resolvedLayout().appDirectory()),\n+                    Map.entry(env.app().contentDirSources(), env.resolvedLayout().contentDirectory())\n+            )) {\n+                RootedPath.copy(e.getKey().stream(), e.getValue(),\n+                        StandardCopyOption.REPLACE_EXISTING, LinkOption.NOFOLLOW_LINKS);\n@@ -129,17 +117,0 @@\n-\n-    private static void copyRecursive(Path srcDir, Path dstDir, List<Path> excludeDirs) throws IOException {\n-        srcDir = srcDir.toAbsolutePath();\n-\n-        List<Path> excludes = new ArrayList<>();\n-\n-        for (var path : excludeDirs) {\n-            if (Files.isDirectory(path)) {\n-                if (path.startsWith(srcDir) && !Files.isSameFile(path, srcDir)) {\n-                    excludes.add(path);\n-                }\n-            }\n-        }\n-\n-        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes,\n-                LinkOption.NOFOLLOW_LINKS, StandardCopyOption.REPLACE_EXISTING);\n-    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":10,"deletions":39,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -149,2 +149,1 @@\n-        pipelineBuilder.excludeDirFromCopying(outputDir.getParent())\n-                .create().execute(BuildEnv.withAppImageDir(env, outputDir), app);\n+        pipelineBuilder.create().execute(BuildEnv.withAppImageDir(env, outputDir), app);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DefaultBundlingEnvironment.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import java.util.Collection;\n@@ -63,0 +64,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -171,2 +173,9 @@\n-        INPUT.ifPresentIn(options, appBuilder::srcDir);\n-        APP_CONTENT.ifPresentIn(options, appBuilder::contentDirs);\n+        INPUT.ifPresentIn(options, appBuilder::appDirSources);\n+        APP_CONTENT.findIn(options).map((List<Collection<RootedPath>> v) -> {\n+            \/\/ Reverse the order of content sources.\n+            \/\/ If there are multiple source files for the same\n+            \/\/ destination file, only the first will be used.\n+            \/\/ Reversing the order of content sources makes it use the last file\n+            \/\/ from the original list of source files for the given destination file.\n+            return v.reversed().stream().flatMap(Collection::stream).toList();\n+        }).ifPresent(appBuilder::contentDirSources);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromOptions.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -94,1 +95,3 @@\n-            INPUT.ifPresentIn(options, startupInfoBuilder::inputDir);\n+            INPUT.findIn(options).flatMap(v -> {\n+                return v.stream().findAny().map(RootedPath::root);\n+            }).ifPresent(startupInfoBuilder::inputDir);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherFromOptions.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.ArrayList;\n@@ -431,6 +430,0 @@\n-        Builder excludeDirFromCopying(Path path) {\n-            Objects.requireNonNull(path);\n-            excludeCopyDirs.add(path);\n-            return this;\n-        }\n-\n@@ -459,1 +452,0 @@\n-        private final List<Path> excludeCopyDirs = new ArrayList<>();\n@@ -493,1 +485,1 @@\n-                .applicationAction(ApplicationImageUtils.createCopyContentAction(() -> builder.excludeCopyDirs)).add();\n+                .applicationAction(ApplicationImageUtils.createCopyContentAction()).add();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import static jdk.jpackage.internal.cli.OptionValueConverter.convertString;\n@@ -568,1 +569,1 @@\n-                    return converter.convert(optionName(), StringToken.of(v));\n+                    return convertString(converter, optionName(), StringToken.of(v));\n@@ -582,1 +583,1 @@\n-                            final var singleTokenConversionResult = converter.convert(optionName(), StringToken.of(str));\n+                            final var singleTokenConversionResult = convertString(converter, optionName(), StringToken.of(str));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/JOptSimpleOptionsBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-interface OptionArrayValueConverter<T> extends OptionValueConverter<T[]> {\n+interface OptionArrayValueConverter<T> extends OptionValueConverter<String, T[]> {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionArrayValueConverter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jpackage.internal.util.Result;\n@@ -59,1 +60,1 @@\n-        Optional<OptionValueConverter<T>> converter,\n+        Optional<OptionValueConverter<String, T>> converter,\n@@ -137,1 +138,1 @@\n-    <U> OptionSpec<U> copyWithConverter(OptionValueConverter<U> converter) {\n+    <U> OptionSpec<U> copyWithConverter(OptionValueConverter<String, U> converter) {\n@@ -172,0 +173,4 @@\n+    Result<T> convert(OptionName optionName, StringToken optionValue) {\n+        return OptionValueConverter.convertString(converter().orElseThrow(), optionName, optionValue);\n+    }\n+\n@@ -177,1 +182,1 @@\n-    private static <T> Optional<Class<? extends T>> valueType(Optional<OptionValueConverter<T>> valueConverter) {\n+    private static <T> Optional<Class<? extends T>> valueType(Optional<OptionValueConverter<String, T>> valueConverter) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpec.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -64,1 +66,1 @@\n-    OptionSpecBuilder(OptionSpecBuilder<T> other) {\n+    private OptionSpecBuilder(OptionSpecBuilder<T> other) {\n@@ -66,5 +68,1 @@\n-        name = other.name;\n-        nameAliases.addAll(other.nameAliases);\n-        description = other.description;\n-        mergePolicy = other.mergePolicy;\n-        scope = Set.copyOf(other.scope);\n+        initFrom(other);\n@@ -73,1 +71,0 @@\n-        valuePattern = other.valuePattern;\n@@ -80,0 +77,2 @@\n+        } else {\n+            arrayDefaultValue = null;\n@@ -81,0 +80,29 @@\n+    }\n+\n+    private <U> OptionSpecBuilder(OptionSpecBuilder<U> other, ValueConverter<U, T> converter) {\n+        Function<U, T> converterFunction = toFunction(converter::convert);\n+\n+        this.valueType = converter.valueType();\n+        initFrom(other);\n+        converter(other, converter);\n+\n+        other.defaultValue().map(converterFunction).ifPresent(this::defaultValue);\n+        other.defaultOptionalValue().map(converterFunction).ifPresent(this::defaultOptionalValue);\n+\n+        if (other.arrayDefaultValue != null) {\n+            arrayDefaultValue = Stream.of(other.arrayDefaultValue).map(converterFunction).toArray(length -> {\n+                @SuppressWarnings(\"unchecked\")\n+                var arr = (T[])Array.newInstance(valueType, length);\n+                return arr;\n+            });\n+        }\n+    }\n+\n+    private void initFrom(OptionSpecBuilder<?> other) {\n+        name = other.name;\n+        nameAliases.clear();\n+        nameAliases.addAll(other.nameAliases);\n+        description = other.description;\n+        mergePolicy = other.mergePolicy;\n+        scope = Set.copyOf(other.scope);\n+        valuePattern = other.valuePattern;\n@@ -89,0 +117,8 @@\n+    <U> OptionSpecBuilder<U> map(ValueConverter<T, U> converter) {\n+        return new OptionSpecBuilder<>(this, converter);\n+    }\n+\n+    <U> OptionSpecBuilder<U> map(Function<OptionSpecBuilder<T>, OptionSpecBuilder<U>> mapper) {\n+        return mapper.apply(this);\n+    }\n+\n@@ -180,2 +216,2 @@\n-    OptionSpecBuilder<T> validatorExceptionFormatString(UnaryOperator<String> mutator) {\n-        validatorBuilder.formatString(mutator.apply(validatorBuilder.formatString().orElse(null)));\n+    OptionSpecBuilder<T> validatorExceptionFormatString(UnaryOperator<String> mapper) {\n+        validatorBuilder.formatString(mapper.apply(validatorBuilder.formatString().orElse(null)));\n@@ -191,2 +227,2 @@\n-    OptionSpecBuilder<T> converterExceptionFormatString(UnaryOperator<String> mutator) {\n-        converterBuilder.formatString(mutator.apply(converterBuilder.formatString().orElse(null)));\n+    OptionSpecBuilder<T> converterExceptionFormatString(UnaryOperator<String> mapper) {\n+        converterBuilder.formatString(mapper.apply(converterBuilder.formatString().orElse(null)));\n@@ -202,2 +238,2 @@\n-    OptionSpecBuilder<T> validatorExceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mutator) {\n-        return validatorExceptionFactory(mutator.apply(validatorBuilder.exceptionFactory().orElse(null)));\n+    OptionSpecBuilder<T> validatorExceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mapper) {\n+        return validatorExceptionFactory(mapper.apply(validatorBuilder.exceptionFactory().orElse(null)));\n@@ -211,2 +247,2 @@\n-    OptionSpecBuilder<T> converterExceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mutator) {\n-        return converterExceptionFactory(mutator.apply(converterBuilder.exceptionFactory().orElse(null)));\n+    OptionSpecBuilder<T> converterExceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mapper) {\n+        return converterExceptionFactory(mapper.apply(converterBuilder.exceptionFactory().orElse(null)));\n@@ -219,2 +255,2 @@\n-    OptionSpecBuilder<T> exceptionFormatString(UnaryOperator<String> mutator) {\n-        return validatorExceptionFormatString(mutator).converterExceptionFormatString(mutator);\n+    OptionSpecBuilder<T> exceptionFormatString(UnaryOperator<String> mapper) {\n+        return validatorExceptionFormatString(mapper).converterExceptionFormatString(mapper);\n@@ -227,2 +263,2 @@\n-    OptionSpecBuilder<T> exceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mutator) {\n-        return validatorExceptionFactory(mutator).converterExceptionFactory(mutator);\n+    OptionSpecBuilder<T> exceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mapper) {\n+        return validatorExceptionFactory(mapper).converterExceptionFactory(mapper);\n@@ -231,1 +267,1 @@\n-    OptionSpecBuilder<T> converter(ValueConverter<T> v) {\n+    OptionSpecBuilder<T> converter(ValueConverter<String, T> v) {\n@@ -236,1 +272,11 @@\n-    OptionSpecBuilder<T> converter(Function<String, T> v) {\n+    <U> OptionSpecBuilder<T> converter(OptionSpecBuilder<U> other, ValueConverter<U, T> v) {\n+        converterBuilder = other.finalizeConverterBuilder().map(v);\n+        return this;\n+    }\n+\n+    <U> OptionSpecBuilder<T> interimConverter(OptionSpecBuilder<U> other) {\n+        converterBuilder = converterBuilder.map(other.finalizeConverterBuilder());\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> converter(ValueConverterFunction<String, T> v) {\n@@ -254,2 +300,2 @@\n-    OptionSpecBuilder<T> validator(UnaryOperator<Validator.Builder<T, RuntimeException>> mutator) {\n-        validatorBuilder = mutator.apply(validatorBuilder);\n+    OptionSpecBuilder<T> validator(UnaryOperator<Validator.Builder<T, RuntimeException>> mapper) {\n+        validatorBuilder = mapper.apply(validatorBuilder);\n@@ -306,2 +352,2 @@\n-    OptionSpecBuilder<T> scope(UnaryOperator<Set<OptionScope>> mutator) {\n-        return scope(mutator.apply(scope().orElseGet(Set::of)));\n+    OptionSpecBuilder<T> scope(UnaryOperator<Set<OptionScope>> mapper) {\n+        return scope(mapper.apply(scope().orElseGet(Set::of)));\n@@ -427,1 +473,1 @@\n-        return converterBuilder.converter().map(_ -> {\n+        if (converterBuilder.hasConverter()) {\n@@ -429,2 +475,4 @@\n-            return tokens[tokens.length - 1];\n-        });\n+            return Optional.of(tokens[tokens.length - 1]);\n+        } else {\n+            return Optional.empty();\n+        }\n@@ -440,5 +488,3 @@\n-    private Optional<OptionValueConverter<T>> createConverter() {\n-        if (converterBuilder.converter().isPresent()) {\n-            final var newBuilder = converterBuilder.copy();\n-            createValidator().ifPresent(newBuilder::validator);\n-            return Optional.of(newBuilder.create());\n+    private Optional<OptionValueConverter<String, T>> createConverter() {\n+        if (converterBuilder.hasConverter()) {\n+            return Optional.of(finalizeConverterBuilder().create());\n@@ -450,1 +496,7 @@\n-    private OptionValueConverter<T[]> createArrayConverter() {\n+    private OptionValueConverter.Builder<T> finalizeConverterBuilder() {\n+        final var newBuilder = converterBuilder.copy();\n+        createValidator().ifPresent(newBuilder::validator);\n+        return newBuilder;\n+    }\n+\n+    private OptionValueConverter<String, T[]> createArrayConverter() {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpecBuilder.java","additions":86,"deletions":34,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.LinkedHashMap;\n@@ -30,0 +31,2 @@\n+import java.util.Optional;\n+import java.util.SequencedMap;\n@@ -33,0 +36,3 @@\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.IdentityWrapper;\n@@ -45,1 +51,1 @@\n- * @param <T> the type of context\n+ * @param <U> the type of context\n@@ -47,1 +53,1 @@\n-interface OptionSpecMapperOptionScope<T, U> extends OptionScope {\n+sealed interface OptionSpecMapperOptionScope<T, U> extends OptionScope {\n@@ -55,1 +61,1 @@\n-        return optionSpec.scope().stream()\n+        var mappedOptionSpec = optionSpec.scope().stream()\n@@ -65,0 +71,19 @@\n+\n+        Optional<?> valueType = optionSpec.converter().map(OptionValueConverter::valueType);\n+        Optional<?> mappedValueType = mappedOptionSpec.converter().map(OptionValueConverter::valueType);\n+\n+        while (!mappedValueType.equals(valueType)) {\n+            \/\/ Source and mapped option specs have different option value types.\n+            if (Stream.of(valueType, mappedValueType).anyMatch(Optional::isEmpty) &&\n+                    Stream.of(valueType, mappedValueType)\n+                    .filter(Optional::isPresent).map(Optional::get)\n+                    .anyMatch(Predicate.isEqual(Boolean.class))) {\n+                \/\/ One option spec doesn't have a converter and another has a converter of type `Boolean`.\n+                \/\/ They are compatible, let it pass.\n+                break;\n+            }\n+\n+            throw new IllegalStateException(String.format(\"Bad option spec mapping from %s to %s\", valueType, mappedValueType));\n+        }\n+\n+        return mappedOptionSpec;\n@@ -97,1 +122,5 @@\n-                    .map(AccumulatingContextOptionScope.class::cast)\n+                    .map(v -> {\n+                        @SuppressWarnings(\"unchecked\")\n+                        var tv = (AccumulatingContextOptionScope<T, U>)v;\n+                        return tv;\n+                    })\n@@ -102,0 +131,1 @@\n+\n@@ -103,6 +133,1 @@\n-                @SuppressWarnings(\"unchecked\")\n-                var mutators = (AccumulatingContextOptionScope<T, U>)v;\n-                mutators.addMutator(optionSpecBuilderMutator);\n-                if (optionSpecBuilder != mutators.optionSpecBuilder) {\n-                    throw new IllegalArgumentException();\n-                }\n+                v.addMutator(optionSpecBuilder, optionSpecBuilderMutator);\n@@ -112,2 +137,2 @@\n-                var mutators = new AccumulatingContextOptionScope<T, U>(optionSpecBuilder, contextType);\n-                mutators.addMutator(optionSpecBuilderMutator);\n+                var mutators = new AccumulatingContextOptionScope<T, U>(contextType);\n+                mutators.addMutator(optionSpecBuilder, optionSpecBuilderMutator);\n@@ -122,2 +147,1 @@\n-            AccumulatingContextOptionScope(OptionSpecBuilder<T> optionSpecBuilder, Class<? extends U> contextType) {\n-                this.optionSpecBuilder = Objects.requireNonNull(optionSpecBuilder);\n+            AccumulatingContextOptionScope(Class<? extends U> contextType) {\n@@ -130,3 +154,5 @@\n-                var copy = optionSpecBuilder.copy();\n-                for (var mutator : optionSpecBuilderMutators) {\n-                    mutator.accept(copy, context);\n+                var it = builders.values().iterator();\n+\n+                var builder = it.next().initBuilder(context, Optional.empty());\n+                while (it.hasNext()) {\n+                    builder = it.next().initBuilder(context, Optional.of(builder));\n@@ -136,1 +162,1 @@\n-                    return (OptionSpec<T>)copy.createArrayOptionSpec();\n+                    return (OptionSpec<T>)builder.createArrayOptionSpec();\n@@ -138,1 +164,1 @@\n-                    return copy.createOptionSpec();\n+                    return (OptionSpec<T>)builder.createOptionSpec();\n@@ -147,2 +173,7 @@\n-            void addMutator(BiConsumer<OptionSpecBuilder<T>, U> mutator) {\n-                optionSpecBuilderMutators.add(mutator);\n+            <V> void addMutator(OptionSpecBuilder<V> builder, BiConsumer<OptionSpecBuilder<V>, U> mutator) {\n+                @SuppressWarnings(\"unchecked\")\n+                var builderWithMutators = ((OptionSpecBuilderWithMutators<V, U>)builders.computeIfAbsent(new IdentityWrapper<>(builder), _ -> {\n+                    return new OptionSpecBuilderWithMutators<V, U>(builder);\n+                }));\n+\n+                builderWithMutators.addMutator(mutator);\n@@ -151,1 +182,0 @@\n-            private final OptionSpecBuilder<T> optionSpecBuilder;\n@@ -153,1 +183,1 @@\n-            private final List<BiConsumer<OptionSpecBuilder<T>, U>> optionSpecBuilderMutators = new ArrayList<>();\n+            private final SequencedMap<IdentityWrapper<OptionSpecBuilder<?>>, OptionSpecBuilderWithMutators<?, U>> builders = new LinkedHashMap<>();\n@@ -156,0 +186,25 @@\n+        private static final class OptionSpecBuilderWithMutators<T, U> {\n+\n+            OptionSpecBuilderWithMutators(OptionSpecBuilder<T> builder) {\n+                this.builder = Objects.requireNonNull(builder);\n+            }\n+\n+            OptionSpecBuilder<T> initBuilder(U context, Optional<OptionSpecBuilder<?>> other) {\n+                Objects.requireNonNull(context);\n+                Objects.requireNonNull(other);\n+\n+                var copy = builder.copy();\n+                other.ifPresent(copy::interimConverter);\n+                for (var mutator : mutators) {\n+                    mutator.accept(copy, context);\n+                }\n+                return copy;\n+            }\n+\n+            void addMutator(BiConsumer<OptionSpecBuilder<T>, U> mutator) {\n+                mutators.add(Objects.requireNonNull(mutator));\n+            }\n+\n+            private final OptionSpecBuilder<T> builder;\n+            private final List<BiConsumer<OptionSpecBuilder<T>, U>> mutators = new ArrayList<>();\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpecMapperOptionScope.java","additions":79,"deletions":24,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Defines creating an option value of type {@link T} from a string.\n+ * Defines creating an option value of type {@link U} from value of type {@link T}.\n@@ -40,1 +40,2 @@\n- * @param <T> option value type\n+ * @param <T> input option value type\n+ * @param <U> output option value type\n@@ -42,1 +43,1 @@\n-interface OptionValueConverter<T> {\n+interface OptionValueConverter<T, U> {\n@@ -45,2 +46,2 @@\n-     * Converts the given string value corresponding to the given option name into a\n-     * Java type.\n+     * Converts the given value of type {@link T} corresponding to the given option name\n+     * and option string value to an object of type {@link U}.\n@@ -49,1 +50,2 @@\n-     * @param optionValue the string value of the option to convert\n+     * @param optionValue the string value of the option\n+     * @param value       the value of the option to convert\n@@ -51,0 +53,1 @@\n+     * @throws ConverterException if internal converter error occurs\n@@ -52,1 +55,1 @@\n-    Result<T> convert(OptionName optionName, StringToken optionValue);\n+    Result<U> convert(OptionName optionName, StringToken optionValue, T value) throws ConverterException;\n@@ -59,1 +62,5 @@\n-    Class<? extends T> valueType();\n+    Class<? extends U> valueType();\n+\n+    static <T> Result<T> convertString(OptionValueConverter<String, T> converter, OptionName optionName, StringToken optionValue) {\n+        return converter.convert(optionName, optionValue, optionValue.value());\n+    }\n@@ -77,0 +84,1 @@\n+\n@@ -80,0 +88,5 @@\n+            this(new OneStepBackend<>(new StepBuilder<>(true)));\n+        }\n+\n+        private Builder(Backend<T> backend) {\n+            this.backend = Objects.requireNonNull(backend);\n@@ -83,2 +96,1 @@\n-            converter = other.converter;\n-            validator = other.validator;\n+            backend = other.backend.copy();\n@@ -86,2 +98,0 @@\n-            formatString = other.formatString;\n-            exceptionFactory = other.exceptionFactory;\n@@ -94,18 +104,32 @@\n-        OptionValueConverter<T> create() {\n-            return new DefaultOptionValueConverter<>(\n-                    converter,\n-                    formatString().orElseGet(() -> {\n-                        if (exceptionFactory == null) {\n-                            return \"\";\n-                        } else {\n-                            return null;\n-                        }\n-                    }),\n-                    exceptionFactory().orElseGet(() -> {\n-                        if (formatString == null) {\n-                            return OptionValueExceptionFactory.unreachable();\n-                        } else {\n-                            return null;\n-                        }\n-                    }),\n-                    validator());\n+        <U> Builder<U> map(ValueConverter<T, U> converter) {\n+            Objects.requireNonNull(converter);\n+            return new Builder<>(new TwoStepBackend<>(\n+                    backend,\n+                    new StepBuilder<T, U>(false).converter(converter))).tokenizer(tokenizer);\n+        }\n+\n+        <U> Builder<T> map(Builder<U> other) {\n+            Objects.requireNonNull(other);\n+            switch (backend) {\n+                case OneStepBackend<T> _ -> {\n+                    throw new UnsupportedOperationException();\n+                }\n+                case TwoStepBackend<?, T> b -> {\n+                    var fromInterimValueType = other.backend.valueType().orElseThrow();\n+                    var toInterimValueType = b.interimValueType();\n+                    if (fromInterimValueType.equals(toInterimValueType)) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        var twoStepBackend = (TwoStepBackend<U, T>)b;\n+                        return new Builder<>(new TwoStepBackend<>(\n+                                other.backend,\n+                                twoStepBackend.otherConvBuilder())).tokenizer(tokenizer);\n+                    } else {\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Expected (%s); actual (%s)\", toInterimValueType, fromInterimValueType));\n+                    }\n+                }\n+            }\n+        }\n+\n+        OptionValueConverter<String, T> create() {\n+            return backend.create();\n@@ -118,2 +142,9 @@\n-        Builder<T> converter(ValueConverter<T> v) {\n-            converter = v;\n+        Builder<T> converter(ValueConverter<String, T> v) {\n+            switch (backend) {\n+                case OneStepBackend<T> b -> {\n+                    b.stringConvBuilder().converter(v);\n+                }\n+                case TwoStepBackend<?, T> _ -> {\n+                    throw new UnsupportedOperationException();\n+                }\n+            }\n@@ -124,1 +155,1 @@\n-            validator = v;\n+            backend.validator(v);\n@@ -134,1 +165,1 @@\n-            formatString = v;\n+            backend.formatString(v);\n@@ -139,1 +170,1 @@\n-            exceptionFactory = v;\n+            backend.exceptionFactory(v);\n@@ -148,2 +179,9 @@\n-        Optional<ValueConverter<T>> converter() {\n-            return Optional.ofNullable(converter);\n+        boolean hasConverter() {\n+            switch (backend) {\n+                case OneStepBackend<T> b -> {\n+                    return b.stringConvBuilder().converter().isPresent();\n+                }\n+                case TwoStepBackend<?, T> _ -> {\n+                    return true;\n+                }\n+            }\n@@ -153,1 +191,12 @@\n-            return Optional.ofNullable(validator);\n+            return backend.validator();\n+        }\n+\n+        Optional<ValueConverter<String, T>> converter() {\n+            switch (backend) {\n+                case OneStepBackend<T> b -> {\n+                    return b.stringConvBuilder().converter();\n+                }\n+                case TwoStepBackend<?, T> _ -> {\n+                    throw new UnsupportedOperationException();\n+                }\n+            }\n@@ -161,1 +210,1 @@\n-            return Optional.ofNullable(formatString);\n+            return backend.formatString();\n@@ -165,54 +214,1 @@\n-            return Optional.ofNullable(exceptionFactory);\n-        }\n-\n-\n-        private record DefaultOptionValueConverter<T>(ValueConverter<T> converter, String formatString,\n-                OptionValueExceptionFactory<? extends RuntimeException> exceptionFactory,\n-                Optional<Validator<T, ? extends RuntimeException>> validator) implements OptionValueConverter<T> {\n-\n-            DefaultOptionValueConverter {\n-                Objects.requireNonNull(converter);\n-                Objects.requireNonNull(formatString);\n-                Objects.requireNonNull(exceptionFactory);\n-                Objects.requireNonNull(validator);\n-            }\n-\n-            @Override\n-            public Result<T> convert(OptionName optionName, StringToken optionValue) {\n-                Objects.requireNonNull(optionName);\n-\n-                final T convertedValue;\n-                try {\n-                    convertedValue = converter.convert(optionValue.value());\n-                } catch (Exception ex) {\n-                    return handleException(optionName, optionValue, ex);\n-                }\n-\n-                final List<? extends Exception> validationExceptions = validator.map(val -> {\n-                    try {\n-                        return val.validate(optionName, ParsedValue.create(convertedValue, optionValue));\n-                    } catch (Validator.ValidatorException ex) {\n-                        \/\/ All unexpected exceptions that the converter yields should be tunneled via ConverterException.\n-                        throw new ConverterException(ex.getCause());\n-                    }\n-                }).orElseGet(List::of);\n-\n-                if (validationExceptions.isEmpty()) {\n-                    return Result.ofValue(convertedValue);\n-                } else {\n-                    return Result.ofErrors(validationExceptions);\n-                }\n-            }\n-\n-            @Override\n-            public Class<? extends T> valueType() {\n-                return converter.valueType();\n-            }\n-\n-            private Result<T> handleException(OptionName optionName, StringToken optionValue, Exception ex) {\n-                if (ex instanceof IllegalArgumentException) {\n-                    return Result.ofError(exceptionFactory.create(optionName, optionValue, formatString, Optional.of(ex)));\n-                } else {\n-                    throw new ConverterException(ex);\n-                }\n-            }\n+            return backend.exceptionFactory();\n@@ -222,1 +218,1 @@\n-        private record DefaultOptionArrayValueConverter<T>(OptionValueConverter<T> elementConverter,\n+        private record DefaultOptionArrayValueConverter<T>(OptionValueConverter<String, T> elementConverter,\n@@ -232,1 +228,5 @@\n-            public Result<T[]> convert(OptionName optionName, StringToken optionValue) {\n+            public Result<T[]> convert(OptionName optionName, StringToken optionValue, String value) {\n+\n+                if (!value.equals(optionValue.value())) {\n+                    throw new IllegalArgumentException();\n+                }\n@@ -239,1 +239,1 @@\n-                    final var result = elementConverter.convert(optionName, StringToken.of(optionValue.value(), token));\n+                    final var result = elementConverter.convert(optionName, StringToken.of(optionValue.value(), token), token);\n@@ -267,2 +267,304 @@\n-        private ValueConverter<T> converter;\n-        private Validator<T, ? extends RuntimeException> validator;\n+\n+        private record TwoStepOptionValueConverter<T, U>(OptionValueConverter<String, T> stringConverter,\n+                OptionValueConverter<T, U> converter) implements OptionValueConverter<String, U> {\n+\n+            TwoStepOptionValueConverter {\n+                Objects.requireNonNull(stringConverter);\n+                Objects.requireNonNull(converter);\n+            }\n+\n+            @Override\n+            public Result<U> convert(OptionName optionName, StringToken optionValue, String value) {\n+                final var interimResult = stringConverter.convert(optionName, optionValue, value);\n+                return interimResult.flatMap(interimValue -> {\n+                    return converter.convert(optionName, optionValue, interimValue);\n+                });\n+            }\n+\n+            @Override\n+            public Class<? extends U> valueType() {\n+                return converter.valueType();\n+            }\n+        }\n+\n+\n+        private sealed interface Backend<T> {\n+\n+            OptionValueConverter<String, T> create();\n+\n+            Backend<T> copy();\n+\n+            void validator(Validator<T, ? extends RuntimeException> v);\n+\n+            void formatString(String v);\n+\n+            void exceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v);\n+\n+            Optional<Class<? extends T>> valueType();\n+\n+            Optional<Validator<T, ? extends RuntimeException>> validator();\n+\n+            Optional<String> formatString();\n+\n+            Optional<OptionValueExceptionFactory<? extends RuntimeException>> exceptionFactory();\n+        }\n+\n+\n+        private record OneStepBackend<T>(StepBuilder<String, T> stringConvBuilder) implements Backend<T> {\n+\n+            OneStepBackend {\n+                Objects.requireNonNull(stringConvBuilder);\n+            }\n+\n+            @Override\n+            public Backend<T> copy() {\n+                return new OneStepBackend<>(stringConvBuilder.copy());\n+            }\n+\n+            @Override\n+            public OptionValueConverter<String, T> create() {\n+                return stringConvBuilder.create();\n+            }\n+\n+            @Override\n+            public void validator(Validator<T, ? extends RuntimeException> v) {\n+                stringConvBuilder.validator(v);\n+            }\n+\n+            @Override\n+            public void formatString(String v) {\n+                stringConvBuilder.formatString(v);\n+            }\n+\n+            @Override\n+            public void exceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+                stringConvBuilder.exceptionFactory(v);\n+            }\n+\n+            @Override\n+            public Optional<Class<? extends T>> valueType() {\n+                return stringConvBuilder.converter().map(ValueConverter::valueType);\n+            }\n+\n+            @Override\n+            public Optional<Validator<T, ? extends RuntimeException>> validator() {\n+                return stringConvBuilder.validator();\n+            }\n+\n+            @Override\n+            public Optional<String> formatString() {\n+                return stringConvBuilder.formatString();\n+            }\n+\n+            @Override\n+            public Optional<OptionValueExceptionFactory<? extends RuntimeException>> exceptionFactory() {\n+                return stringConvBuilder.exceptionFactory();\n+            }\n+        }\n+\n+\n+        private record TwoStepBackend<T, U>(Backend<T> stringConvBuilder, StepBuilder<T, U> otherConvBuilder) implements Backend<U> {\n+\n+            TwoStepBackend {\n+                Objects.requireNonNull(stringConvBuilder);\n+                Objects.requireNonNull(otherConvBuilder);\n+            }\n+\n+            Class<? extends T> interimValueType() {\n+                return stringConvBuilder.valueType().orElseThrow();\n+            }\n+\n+            @Override\n+            public Backend<U> copy() {\n+                return new TwoStepBackend<>(stringConvBuilder.copy(), otherConvBuilder.copy());\n+            }\n+\n+            @Override\n+            public OptionValueConverter<String, U> create() {\n+                return new TwoStepOptionValueConverter<>(stringConvBuilder.create(), otherConvBuilder.create());\n+            }\n+\n+            @Override\n+            public void validator(Validator<U, ? extends RuntimeException> v) {\n+                otherConvBuilder.validator(v);\n+            }\n+\n+            @Override\n+            public void formatString(String v) {\n+                otherConvBuilder.formatString(v);\n+            }\n+\n+            @Override\n+            public void exceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+                otherConvBuilder.exceptionFactory(v);\n+            }\n+\n+            @Override\n+            public Optional<Class<? extends U>> valueType() {\n+                return otherConvBuilder.converter().map(ValueConverter::valueType);\n+            }\n+\n+            @Override\n+            public Optional<Validator<U, ? extends RuntimeException>> validator() {\n+                return otherConvBuilder.validator();\n+            }\n+\n+            @Override\n+            public Optional<String> formatString() {\n+                return otherConvBuilder.formatString();\n+            }\n+\n+            @Override\n+            public Optional<OptionValueExceptionFactory<? extends RuntimeException>> exceptionFactory() {\n+                return otherConvBuilder.exceptionFactory();\n+            }\n+        }\n+\n+\n+        private static final class StepBuilder<T, U> {\n+\n+            private StepBuilder(boolean starter) {\n+                this.starter = starter;\n+            }\n+\n+            private StepBuilder(StepBuilder<T, U> other) {\n+                starter = other.starter;\n+                converter = other.converter;\n+                validator = other.validator;\n+                formatString = other.formatString;\n+                exceptionFactory = other.exceptionFactory;\n+            }\n+\n+            StepBuilder<T, U> copy() {\n+                return new StepBuilder<>(this);\n+            }\n+\n+            OptionValueConverter<T, U> create() {\n+                return new DefaultOptionValueConverter<>(\n+                        converter,\n+                        formatString().orElseGet(() -> {\n+                            if (exceptionFactory == null) {\n+                                return \"\";\n+                            } else {\n+                                return null;\n+                            }\n+                        }),\n+                        exceptionFactory().orElseGet(() -> {\n+                            if (formatString == null) {\n+                                return OptionValueExceptionFactory.unreachable();\n+                            } else {\n+                                return null;\n+                            }\n+                        }),\n+                        validator(),\n+                        starter);\n+            }\n+\n+            StepBuilder<T, U> converter(ValueConverter<T, U> v) {\n+                converter = v;\n+                return this;\n+            }\n+\n+            StepBuilder<T, U> validator(Validator<U, ? extends RuntimeException> v) {\n+                validator = v;\n+                return this;\n+            }\n+\n+            StepBuilder<T, U> formatString(String v) {\n+                formatString = v;\n+                return this;\n+            }\n+\n+            StepBuilder<T, U> exceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+                exceptionFactory = v;\n+                return this;\n+            }\n+\n+            Optional<ValueConverter<T, U>> converter() {\n+                return Optional.ofNullable(converter);\n+            }\n+\n+            Optional<Validator<U, ? extends RuntimeException>> validator() {\n+                return Optional.ofNullable(validator);\n+            }\n+\n+            Optional<String> formatString() {\n+                return Optional.ofNullable(formatString);\n+            }\n+\n+            Optional<OptionValueExceptionFactory<? extends RuntimeException>> exceptionFactory() {\n+                return Optional.ofNullable(exceptionFactory);\n+            }\n+\n+\n+            private record DefaultOptionValueConverter<T, U>(\n+                    ValueConverter<T, U> converter,\n+                    String formatString,\n+                    OptionValueExceptionFactory<? extends RuntimeException> exceptionFactory,\n+                    Optional<Validator<U, ? extends RuntimeException>> validator,\n+                    boolean starter) implements OptionValueConverter<T, U> {\n+\n+                DefaultOptionValueConverter {\n+                    Objects.requireNonNull(converter);\n+                    Objects.requireNonNull(formatString);\n+                    Objects.requireNonNull(exceptionFactory);\n+                    Objects.requireNonNull(validator);\n+                }\n+\n+                @Override\n+                public Result<U> convert(OptionName optionName, StringToken optionValue, T value) {\n+                    Objects.requireNonNull(optionName);\n+                    Objects.requireNonNull(optionValue);\n+                    Objects.requireNonNull(value);\n+\n+                    if (starter && !value.equals(optionValue.value())) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    final U convertedValue;\n+                    try {\n+                        convertedValue = converter.convert(value);\n+                    } catch (Exception ex) {\n+                        return handleException(optionName, optionValue, ex);\n+                    }\n+\n+                    final List<? extends Exception> validationExceptions = validator.map(val -> {\n+                        try {\n+                            return val.validate(optionName, ParsedValue.create(convertedValue, optionValue));\n+                        } catch (Validator.ValidatorException ex) {\n+                            \/\/ All unexpected exceptions that the converter yields should be tunneled via ConverterException.\n+                            throw new ConverterException(ex.getCause());\n+                        }\n+                    }).orElseGet(List::of);\n+\n+                    if (validationExceptions.isEmpty()) {\n+                        return Result.ofValue(convertedValue);\n+                    } else {\n+                        return Result.ofErrors(validationExceptions);\n+                    }\n+                }\n+\n+                @Override\n+                public Class<? extends U> valueType() {\n+                    return converter.valueType();\n+                }\n+\n+                private Result<U> handleException(OptionName optionName, StringToken optionValue, Exception ex) {\n+                    if (ex instanceof IllegalArgumentException) {\n+                        return Result.ofError(exceptionFactory.create(optionName, optionValue, formatString, Optional.of(ex)));\n+                    } else {\n+                        throw new ConverterException(ex);\n+                    }\n+                }\n+            }\n+\n+\n+            private final boolean starter;\n+            private ValueConverter<T, U> converter;\n+            private Validator<U, ? extends RuntimeException> validator;\n+            private String formatString;\n+            private OptionValueExceptionFactory<? extends RuntimeException> exceptionFactory;\n+        }\n+\n+\n+        private final Backend<T> backend;\n@@ -270,2 +572,0 @@\n-        private String formatString;\n-        private OptionValueExceptionFactory<? extends RuntimeException> exceptionFactory;\n@@ -274,0 +574,1 @@\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionValueConverter.java","additions":402,"deletions":101,"binary":false,"changes":503,"status":"modified"},{"patch":"@@ -275,1 +275,0 @@\n-                        .converter().orElseThrow()\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionsAnalyzer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import static jdk.jpackage.internal.cli.OptionValueConverter.convertString;\n@@ -383,2 +384,2 @@\n-        public Result<Options[]> convert(OptionName optionName, StringToken optionValue) {\n-            return converter.convert(optionName, optionValue).flatMap(arr -> {\n+        public Result<Options[]> convert(OptionName optionName, StringToken optionValue, String value) {\n+            return convertString(converter, optionName, optionValue).flatMap(arr -> {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionsProcessor.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-                return spec.converter().orElseThrow().convert(spec.name(), StringToken.of(v)).orElseThrow();\n+                return spec.convert(spec.name(), StringToken.of(v)).orElseThrow();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardAppImageFileOption.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import static jdk.jpackage.internal.cli.StandardValueConverter.explodedPathConverter;\n@@ -47,0 +48,1 @@\n+import java.util.Collection;\n@@ -52,0 +54,1 @@\n+import java.util.function.Function;\n@@ -64,1 +67,1 @@\n-import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -123,1 +126,1 @@\n-    public static final OptionValue<Path> INPUT = directoryOption(\"input\").addAliases(\"i\")\n+    public static final OptionValue<? extends Collection<RootedPath>> INPUT = directoryOption(\"input\").addAliases(\"i\")\n@@ -125,1 +128,4 @@\n-            .create();\n+            .map(explodedPathOptionMapper(explodedPathConverter().create()))\n+            .create(optionValueBuilder -> {\n+                return optionValueBuilder.to(List::of).create();\n+            });\n@@ -196,1 +202,1 @@\n-    public static final OptionValue<List<Path>> APP_CONTENT = pathOption(\"app-content\")\n+    public static final OptionValue<List<Collection<RootedPath>>> APP_CONTENT = existingPathOption(\"app-content\")\n@@ -200,0 +206,1 @@\n+            .map(explodedPathOptionMapper(explodedPathConverter().withPathFileName().create()))\n@@ -205,1 +212,1 @@\n-            .createArray(toList());\n+            .createArray(toExplodedPathList());\n@@ -327,1 +334,1 @@\n-    public static final OptionValue<List<Path>> MAC_DMG_CONTENT = pathOption(\"mac-dmg-content\")\n+    public static final OptionValue<List<Collection<RootedPath>>> MAC_DMG_CONTENT = existingPathOption(\"mac-dmg-content\")\n@@ -330,1 +337,2 @@\n-            .createArray(toList());\n+            .map(explodedPathOptionMapper(explodedPathConverter().withPathFileName().create()))\n+            .createArray(toExplodedPathList());\n@@ -516,0 +524,6 @@\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    b.validatorExceptionFactory(forMessageWithOptionValueAndName(propertyFile));\n+                    b.validatorExceptionFormatString(\"error.properties-parameter-not-directory\");\n+                });\n+            }))\n@@ -522,0 +536,39 @@\n+    static Consumer<OptionSpecBuilder<Path>> existingPathOptionMutator() {\n+\n+        return builder -> {\n+            builder.mutate(pathOptionMutator())\n+            .validator(createExistingPathValidator(Validator.<Path, RuntimeException>build().exceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME), true))\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    var validatorBuilder = Validator.<Path, RuntimeException>build();\n+                    validatorBuilder.exceptionFactory(forMessageWithOptionValueAndName(propertyFile));\n+                    b.validator(createExistingPathValidator(validatorBuilder, false));\n+                });\n+            }));\n+        };\n+    }\n+\n+    private static Validator<Path, RuntimeException> createExistingPathValidator(Validator.Builder<Path, RuntimeException> builder, boolean cmdline) {\n+\n+        if (cmdline) {\n+            builder.formatString(\"error.parameter-not-directory\");\n+        } else {\n+            builder.formatString(\"error.properties-parameter-not-directory\");\n+        }\n+\n+        var isDirectoryValidator = builder.predicate(StandardValidator.IS_DIRECTORY).create();\n+\n+        if (cmdline) {\n+            builder.formatString(\"error.parameter-not-file\");\n+        } else {\n+            builder.formatString(\"error.properties-parameter-not-file\");\n+        }\n+\n+        var isFileValidator = builder.predicate(StandardValidator.IS_FILE_OR_SYMLINK).create();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        var validator = (Validator<Path, RuntimeException>)isDirectoryValidator.or(isFileValidator);\n+\n+        return validator;\n+    }\n+\n@@ -549,0 +602,24 @@\n+    static Function<OptionSpecBuilder<Path>, OptionSpecBuilder<RootedPath[]>> explodedPathOptionMapper(ValueConverter<Path, RootedPath[]> conv) {\n+        Objects.requireNonNull(conv);\n+        return builder -> {\n+            return builder.map(conv)\n+                    .converterExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                    .converterExceptionFormatString(\"error.path-parameter-ioexception\")\n+                    \/\/ Add empty mutator to OptionSpecMapperOptionScope to make\n+                    \/\/ mapped option spec have `RootedPath[]` type.\n+                    \/\/ Otherwise, it will have `Path` type.\n+                    .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                    }));\n+        };\n+    }\n+\n+    private static <T> Function<OptionValue.Builder<RootedPath[][]>, OptionValue<List<Collection<RootedPath>>>> toExplodedPathList() {\n+        return builder -> {\n+            return builder.to((RootedPath[][] v) -> {\n+                return Stream.of(v).map(arr -> {\n+                    return (Collection<RootedPath>)List.of(arr);\n+                }).toList();\n+            }).create();\n+        };\n+    }\n+\n@@ -577,0 +654,4 @@\n+    private static OptionSpecBuilder<Path> existingPathOption(String name) {\n+        return option(name, Path.class).mutate(existingPathOptionMutator());\n+    }\n+\n@@ -627,2 +708,1 @@\n-        OptionValueConverter<Path> propertyFileConverter = fileOption(name)\n-                .create().getSpec().converter().orElseThrow();\n+        var propertyFileSpec = fileOption(name).create().getSpec();\n@@ -660,1 +740,1 @@\n-                        propertyFile = propertyFileConverter.convert(OptionName.of(name),\n+                        propertyFile = propertyFileSpec.convert(OptionName.of(name),\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardOption.java","additions":90,"deletions":10,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.io.IOException;\n+import java.nio.file.Files;\n@@ -31,0 +33,1 @@\n+import java.util.function.Function;\n@@ -33,0 +36,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -40,1 +44,1 @@\n-    static ValueConverter<String> identityConv() {\n+    static ValueConverter<String, String> identityConv() {\n@@ -44,1 +48,1 @@\n-    static ValueConverter<Path> pathConv() {\n+    static ValueConverter<String, Path> pathConv() {\n@@ -48,1 +52,1 @@\n-    static ValueConverter<UUID> uuidConv() {\n+    static ValueConverter<String, UUID> uuidConv() {\n@@ -52,1 +56,1 @@\n-    static ValueConverter<Boolean> booleanConv() {\n+    static ValueConverter<String, Boolean> booleanConv() {\n@@ -56,1 +60,1 @@\n-    static ValueConverter<LauncherShortcut> mainLauncherShortcutConv() {\n+    static ValueConverter<String, LauncherShortcut> mainLauncherShortcutConv() {\n@@ -60,1 +64,1 @@\n-    static ValueConverter<LauncherShortcut> addLauncherShortcutConv() {\n+    static ValueConverter<String, LauncherShortcut> addLauncherShortcutConv() {\n@@ -64,1 +68,27 @@\n-    private static final ValueConverter<String> IDENTITY_CONV = ValueConverter.create(x -> x, String.class);\n+    static ExplodedPathConverterBuilder explodedPathConverter() {\n+        return new ExplodedPathConverterBuilder();\n+    }\n+\n+    static final class ExplodedPathConverterBuilder {\n+        private ExplodedPathConverterBuilder() {\n+        }\n+\n+        ValueConverter<Path, RootedPath[]> create() {\n+            return ValueConverter.create(path -> {\n+                return explodePath(path, withPathFileName);\n+            }, RootedPath[].class);\n+        }\n+\n+        ExplodedPathConverterBuilder withPathFileName(boolean v) {\n+            withPathFileName = v;\n+            return this;\n+        }\n+\n+        ExplodedPathConverterBuilder withPathFileName() {\n+            return withPathFileName(true);\n+        }\n+\n+        private boolean withPathFileName;\n+    }\n+\n+    private static final ValueConverter<String, String> IDENTITY_CONV = ValueConverter.create(x -> x, String.class);\n@@ -66,1 +96,1 @@\n-    private static final ValueConverter<Path> PATH_CONV = ValueConverter.create(str -> {\n+    private static final ValueConverter<String, Path> PATH_CONV = ValueConverter.create(str -> {\n@@ -74,1 +104,1 @@\n-    private static final ValueConverter<UUID> UUID_CONV = ValueConverter.create(UUID::fromString, UUID.class);\n+    private static final ValueConverter<String, UUID> UUID_CONV = ValueConverter.create(UUID::fromString, UUID.class);\n@@ -76,1 +106,1 @@\n-    private static final ValueConverter<Boolean> BOOLEAN_CONV = ValueConverter.create(Boolean::valueOf, Boolean.class);\n+    private static final ValueConverter<String, Boolean> BOOLEAN_CONV = ValueConverter.create(Boolean::valueOf, Boolean.class);\n@@ -78,1 +108,1 @@\n-    private static final ValueConverter<LauncherShortcut> MAIN_LAUNCHER_SHORTCUT_CONV = ValueConverter.create(\n+    private static final ValueConverter<String, LauncherShortcut> MAIN_LAUNCHER_SHORTCUT_CONV = ValueConverter.create(\n@@ -81,1 +111,1 @@\n-    private static final ValueConverter<LauncherShortcut> ADD_LAUNCHER_SHORTCUT_CONV = ValueConverter.create(\n+    private static final ValueConverter<String, LauncherShortcut> ADD_LAUNCHER_SHORTCUT_CONV = ValueConverter.create(\n@@ -83,0 +113,20 @@\n+\n+    private static RootedPath[] explodePath(Path path, boolean withPathFileName) throws Exception {\n+\n+        Function<Path, RootedPath> mapper;\n+        if (withPathFileName) {\n+            mapper = RootedPath.toRootedPath(path.getParent());\n+        } else {\n+            mapper = RootedPath.toRootedPath(path);\n+        }\n+\n+        RootedPath[] items;\n+        try (var walk = Files.walk(path)) {\n+            items = walk.map(mapper).toArray(RootedPath[]::new);\n+        } catch (IOException ex) {\n+            \/\/ IOException is not a converter error, it is a converting error, so map it into IAE.\n+            throw new IllegalArgumentException(ex);\n+        }\n+\n+        return items;\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardValueConverter.java","additions":63,"deletions":13,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -37,1 +37,9 @@\n-    List<U> validate(OptionName optionName, ParsedValue<T> optionValue);\n+    \/**\n+     * Validates the given option value.\n+     *\n+     * @param optionName  the name of an option to validate\n+     * @param optionValue the value of an option to validate\n+     * @return the list of validation errors\n+     * @throws ValidatorException if internal validator error occurs\n+     *\/\n+    List<U> validate(OptionName optionName, ParsedValue<T> optionValue) throws ValidatorException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Validator.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.function.Function;\n@@ -30,11 +29,1 @@\n-interface ValueConverter<T> {\n-\n-    \/**\n-     * Converts the given string value into a Java type.\n-     *\n-     * @param value the string to convert\n-     * @return the converted value\n-     * @throws IllegalArgumentException if the given string value can not be\n-     *                                  converted to an object of type {@link T}\n-     *\/\n-    T convert(String value) throws IllegalArgumentException;\n+interface ValueConverter<T, U> extends ValueConverterFunction<T, U> {\n@@ -47,1 +36,1 @@\n-    Class<? extends T> valueType();\n+    Class<? extends U> valueType();\n@@ -49,2 +38,2 @@\n-    static <T> ValueConverter<T> create(Function<String, T> mapper, Class<? extends T> type) {\n-        Objects.requireNonNull(mapper);\n+    static <T, U> ValueConverter<T, U> create(ValueConverterFunction<T, U> conv, Class<? extends U> type) {\n+        Objects.requireNonNull(conv);\n@@ -56,1 +45,1 @@\n-            public T convert(String value) {\n+            public U convert(T value) throws Exception {\n@@ -58,1 +47,1 @@\n-                return Objects.requireNonNull(mapper.apply(value));\n+                return Objects.requireNonNull(conv.convert(value));\n@@ -62,1 +51,1 @@\n-            public Class<? extends T> valueType() {\n+            public Class<? extends U> valueType() {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/ValueConverter.java","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+@FunctionalInterface\n+interface ValueConverterFunction<T, U> {\n+\n+    \/**\n+     * Converts value of one type into another.\n+     *\n+     * @param value the value to convert\n+     * @return the converted value\n+     * @throws IllegalArgumentException if the given value can not be converted to\n+     *                                  an object of type {@link U}\n+     * @throws Exception                if internal converter error occurs\n+     *\/\n+    U convert(T value) throws Exception, IllegalArgumentException;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/ValueConverterFunction.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Collection;\n@@ -33,0 +34,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -81,2 +83,3 @@\n-     * Gets the source directory of this application if available or an empty\n-     * {@link Optional} instance.\n+     * Gets the source paths that should be copied into\n+     * {@link ApplicationLayout#appDirectory()} directory of the image of this\n+     * application.\n@@ -84,1 +87,1 @@\n-     * Source directory is a directory with the applications's classes and other\n+     * Source paths are supposed to contain the applications's classes and other\n@@ -87,1 +90,1 @@\n-     * @return the source directory of this application\n+     * @return the source paths\n@@ -89,1 +92,1 @@\n-    Optional<Path> srcDir();\n+    Collection<RootedPath> appDirSources();\n@@ -92,6 +95,3 @@\n-     * Gets the input content directories of this application.\n-     * <p>\n-     * Contents of the content directories will be copied as-is into the dedicated\n-     * location of the application image.\n-     *\n-     * @see ApplicationLayout#contentDirectory\n+     * Gets the source paths that should be copied into\n+     * {@link ApplicationLayout#contentDirectory()} directory of the image of this\n+     * application.\n@@ -99,1 +99,1 @@\n-     * @return the input content directories of this application\n+     * @return the source paths\n@@ -101,1 +101,1 @@\n-    List<Path> contentDirs();\n+    Collection<RootedPath> contentDirSources();\n@@ -247,3 +247,12 @@\n-    record Stub(String name, String description, String version, String vendor, String copyright, Optional<Path> srcDir,\n-            List<Path> contentDirs, AppImageLayout imageLayout, Optional<RuntimeBuilder> runtimeBuilder,\n-            List<Launcher> launchers,  Map<String, String> extraAppImageFileData) implements Application {\n+    record Stub(\n+            String name,\n+            String description,\n+            String version,\n+            String vendor,\n+            String copyright,\n+            Collection<RootedPath> appDirSources,\n+            Collection<RootedPath> contentDirSources,\n+            AppImageLayout imageLayout,\n+            Optional<RuntimeBuilder> runtimeBuilder,\n+            List<Launcher> launchers,\n+            Map<String, String> extraAppImageFileData) implements Application {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Application.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+error.properties-parameter-not-directory=The value \"{0}\" provided for property \"{1}\" in \"{2}\" file is not a directory\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,6 +60,0 @@\n-        copyRecursive(src, dest, List.of(), options);\n-    }\n-\n-    public static void copyRecursive(Path src, Path dest,\n-            final List<Path> excludes, CopyOption... options)\n-            throws IOException {\n@@ -74,6 +68,2 @@\n-                    if (isPathMatch(dir, excludes)) {\n-                        return FileVisitResult.SKIP_SUBTREE;\n-                    } else {\n-                        copyActions.add(new CopyAction(null, dest.resolve(src.relativize(dir))));\n-                        return FileVisitResult.CONTINUE;\n-                    }\n+                    copyActions.add(new CopyAction(null, dest.resolve(src.relativize(dir))));\n+                    return FileVisitResult.CONTINUE;\n@@ -85,3 +75,1 @@\n-                    if (!isPathMatch(file, excludes)) {\n-                        copyActions.add(new CopyAction(file, dest.resolve(src.relativize(file))));\n-                    }\n+                    copyActions.add(new CopyAction(file, dest.resolve(src.relativize(file))));\n@@ -91,1 +79,1 @@\n-        } else if (!isPathMatch(src, excludes)) {\n+        } else {\n@@ -116,4 +104,0 @@\n-    private static boolean isPathMatch(Path what, List<Path> paths) {\n-        return paths.stream().anyMatch(what::endsWith);\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/FileUtils.java","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.CopyOption;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A relative path (branch) rooted at the root.\n+ *\/\n+public sealed interface RootedPath {\n+\n+    Path root();\n+    Path branch();\n+\n+    default Path fullPath() {\n+        return root().resolve(branch());\n+    }\n+\n+    public static Function<Path, RootedPath> toRootedPath(Path root) {\n+        return path -> {\n+            if (!path.startsWith(root)) {\n+                throw new IllegalArgumentException(String.format(\"Expected path [%s] to start with [%s] root\", path, root));\n+            }\n+            return new Details.DefaultRootedPath(root, root.relativize(path), Files.isDirectory(path));\n+        };\n+    }\n+\n+    public static void copy(Stream<RootedPath> rootedPaths, Path dest, CopyOption...options) throws IOException {\n+        Objects.requireNonNull(rootedPaths);\n+        Objects.requireNonNull(dest);\n+\n+        var marks = new HashMap<Path, Details.PathMark>();\n+\n+        \/\/ Preset marks for the preexisting paths.\n+        Files.walkFileTree(dest, new FileVisitor<Path>() {\n+\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                marks.put(dir, new Details.PathMark(true, true));\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                marks.put(file, new Details.PathMark(false, true));\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                return FileVisitResult.TERMINATE;\n+            }\n+\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+        });\n+\n+        var replacePreexisting = Set.of(options).contains(StandardCopyOption.REPLACE_EXISTING);\n+\n+        Predicate<Details.PathMark> canReplace = v -> {\n+            return v.isPreexisting() && replacePreexisting;\n+        };\n+\n+        try {\n+            rootedPaths.sequential().map(Details.DefaultRootedPath.class::cast).forEach(rootedPath -> {\n+\n+                final var dstPath = dest.resolve(rootedPath.branch());\n+\n+                var dstPathMark = marks.get(dstPath);\n+\n+                if (!Optional.ofNullable(dstPathMark).map(canReplace::test).orElse(true)) {\n+                    \/\/ Destination path can not be replaced, bail out.\n+                    return;\n+                }\n+\n+                \/\/ Check the ancestors of the destination path.\n+                for (var ancestor : Details.ancestorPaths(rootedPath.branch())) {\n+                    var mark = Optional.ofNullable(marks.get(dest.resolve(ancestor)));\n+\n+                    if (!mark.map(Details.PathMark::isDirectory).orElse(true)) {\n+                        \/\/ `ancestor` is a file, don't overwrite it.\n+                        return;\n+                    }\n+                }\n+\n+                dstPathMark = rootedPath.createPathMark();\n+                marks.put(dstPath, dstPathMark);\n+\n+                try {\n+                    if (replacePreexisting && (rootedPath.isDirectory() != dstPathMark.isDirectory())) {\n+                        FileUtils.deleteRecursive(dstPath);\n+                    }\n+\n+                    if (rootedPath.isDirectory()) {\n+                        Files.createDirectories(dstPath);\n+                    } else {\n+                        Files.createDirectories(dstPath.getParent());\n+                        Files.copy(rootedPath.fullPath(), dstPath, options);\n+                    }\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            });\n+        } catch (UncheckedIOException ex) {\n+            throw ex.getCause();\n+        }\n+    }\n+\n+    static final class Details {\n+\n+        private Details() {\n+        }\n+\n+        private record DefaultRootedPath(Path root, Path branch, boolean isDirectory) implements RootedPath {\n+\n+            DefaultRootedPath {\n+                Objects.requireNonNull(root);\n+                Objects.requireNonNull(branch);\n+                if (branch.isAbsolute()) {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+\n+            PathMark createPathMark() {\n+                return new PathMark(isDirectory);\n+            }\n+        }\n+\n+        private record PathMark(boolean isDirectory, boolean isPreexisting) {\n+            PathMark(boolean isDirectory) {\n+                this(isDirectory, false);\n+            }\n+        }\n+\n+        private static List<Path> ancestorPaths(Path path) {\n+            var ancestors = new ArrayList<Path>();\n+            while ((path = path.getParent()) != null) {\n+                ancestors.add(path);\n+            }\n+            return ancestors;\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/RootedPath.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -55,1 +55,1 @@\n-        pipelineBuilder.excludeDirFromCopying(outputDir)\n+        pipelineBuilder\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExePackager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-        pipelineBuilder.excludeDirFromCopying(outputDir)\n+        pipelineBuilder\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiPackager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-                    Optional.empty(),\n+                    List.of(),\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/AppImageFileTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -619,1 +619,1 @@\n-                Optional.empty(),\n+                List.of(),\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-        assertEquals(\"731\", mappedSpec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+        assertEquals(\"731\", mappedSpec.convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n@@ -82,1 +82,1 @@\n-        assertEquals(\"123\", spec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+        assertEquals(\"123\", spec.convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n@@ -102,1 +102,1 @@\n-        assertArrayEquals(new String[] {\"731\"}, mappedSpec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+        assertArrayEquals(new String[] {\"731\"}, mappedSpec.convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n@@ -106,1 +106,1 @@\n-        assertArrayEquals(new String[] {\"123\"}, spec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+        assertArrayEquals(new String[] {\"123\"}, spec.convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionSpecMutatorOptionScopeTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,1 +296,1 @@\n-    private static <T> OptionValueConverter<T> converter(ValueConverter<T> conv) {\n+    private static <T> OptionValueConverter<String, T> converter(ValueConverter<String, T> conv) {\n@@ -300,1 +300,1 @@\n-    private static <T> OptionValueConverter.Builder<T> buildConverter(ValueConverter<T> conv) {\n+    private static <T> OptionValueConverter.Builder<T> buildConverter(ValueConverter<String, T> conv) {\n@@ -332,1 +332,1 @@\n-        OptionSpecBuilder<T> converter(OptionValueConverter<T> v) {\n+        OptionSpecBuilder<T> converter(OptionValueConverter<String, T> v) {\n@@ -358,1 +358,1 @@\n-        private OptionValueConverter<T> converter;\n+        private OptionValueConverter<String, T> converter;\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionSpecTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import static jdk.jpackage.internal.cli.OptionValueConverter.convertString;\n@@ -29,0 +30,1 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -36,0 +38,1 @@\n+import java.nio.file.Path;\n@@ -58,1 +61,1 @@\n-            assertEquals(758, converter.convert(OptionName.of(\"number\"), token).orElseThrow());\n+            assertEquals(758, convertString(converter, OptionName.of(\"number\"), token).orElseThrow());\n@@ -61,1 +64,1 @@\n-            final var result = converter.convert(OptionName.of(\"number\"), token);\n+            final var result = convertString(converter, OptionName.of(\"number\"), token);\n@@ -80,1 +83,1 @@\n-            return converter.convert(OptionName.of(\"foo\"), StringToken.of(v));\n+            return convertString(converter, OptionName.of(\"foo\"), StringToken.of(v));\n@@ -92,1 +95,1 @@\n-                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .converter(phonyConverter(Integer.class))\n@@ -97,1 +100,1 @@\n-                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .converter(phonyConverter(Integer.class))\n@@ -102,2 +105,3 @@\n-    @Test\n-    public void test_Builder_copy() {\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_Builder_copy(boolean twoStep) {\n@@ -107,3 +111,10 @@\n-        var builder = OptionValueConverter.<Integer>build()\n-                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n-                .validator(Validator.<Integer, RuntimeException>build().predicate(_ -> true).create())\n+        final OptionValueConverter.Builder<Integer> builder;\n+        if (twoStep) {\n+            builder = OptionValueConverter.<Path>build()\n+                    .converter(phonyConverter(Path.class))\n+                    .map(phonyConverter(Integer.class));\n+        } else {\n+            builder = OptionValueConverter.<Integer>build().converter(phonyConverter(Integer.class));\n+        }\n+\n+        builder.validator(Validator.<Integer, RuntimeException>build().predicate(_ -> true).create())\n@@ -117,1 +128,4 @@\n-        assertSame(builder.converter().orElse(null), copy.converter().orElse(null));\n+        if (!twoStep) {\n+            assertSame(builder.converter().orElse(null), copy.converter().orElse(null));\n+        }\n+\n@@ -128,0 +142,17 @@\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_Builder_hasConverter(boolean twoStep) {\n+\n+        if (twoStep) {\n+            final var builder = OptionValueConverter.<Path>build()\n+                    .converter(phonyConverter(Path.class))\n+                    .map(phonyConverter(String.class));\n+            assertTrue(builder.hasConverter());\n+        } else {\n+            final var builder = OptionValueConverter.<String>build();\n+            assertFalse(builder.hasConverter());\n+            builder.converter(phonyConverter(String.class));\n+            assertTrue(builder.hasConverter());\n+        }\n+    }\n+\n@@ -137,1 +168,1 @@\n-        assertNotEquals(List.of(100, 67, 145), List.of(converter.convert(OptionName.of(\"foo\"), StringToken.of(\"110:67:145\")).orElseThrow()));\n+        assertNotEquals(List.of(100, 67, 145), List.of(convertString(converter, OptionName.of(\"foo\"), StringToken.of(\"110:67:145\")).orElseThrow()));\n@@ -173,1 +204,1 @@\n-        var result = converter.convert(OptionName.of(\"foo\"), StringToken.of(\"100:-10:-10:67:str:145:-7\"));\n+        var result = convertString(converter, OptionName.of(\"foo\"), StringToken.of(\"100:-10:-10:67:str:145:-7\"));\n@@ -195,1 +226,1 @@\n-        final var ex = assertThrowsExactly(ConverterException.class, () -> converter.convert(OptionName.of(\"number\"), token));\n+        final var ex = assertThrowsExactly(ConverterException.class, () -> convertString(converter, OptionName.of(\"number\"), token));\n@@ -212,1 +243,1 @@\n-        final var ex = assertThrowsExactly(ConverterException.class, () -> converter.convert(OptionName.of(\"number\"), token));\n+        final var ex = assertThrowsExactly(ConverterException.class, () -> convertString(converter, OptionName.of(\"number\"), token));\n@@ -216,0 +247,125 @@\n+\n+    @Test\n+    public void testTwoStep() {\n+\n+        final var multiplyConverter = ValueConverter.<Integer, Long>create(v -> {\n+            return (long)(v * -1);\n+        }, Long.class);\n+\n+        final var converter = OptionValueConverter.<Integer>build()\n+                .converter(ValueConverter.create(Integer::parseInt, Integer.class))\n+                .map(multiplyConverter)\n+                .create();\n+\n+        assertEquals(Long.class, converter.valueType());\n+\n+        var result = convertString(converter, OptionName.of(\"foo\"), StringToken.of(\"123\")).orElseThrow();\n+        assertEquals(-123, result);\n+    }\n+\n+    @Test\n+    public void testMultiStep() {\n+\n+        final var converter = OptionValueConverter.<Path>build()\n+                .converter(ValueConverter.create(Path::of, Path.class))\n+                .map(ValueConverter.create(v -> {\n+                    return v.normalize().toString();\n+                }, String.class))\n+                .map(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .create();\n+\n+        assertEquals(Integer.class, converter.valueType());\n+\n+        var result = convertString(converter, OptionName.of(\"foo\"), StringToken.of(\".\/123\")).orElseThrow();\n+        assertEquals(123, result);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 2})\n+    public void testTwoStep_map(int type) {\n+\n+        var tolower = ValueConverter.<String, String>create(String::toLowerCase, String.class);\n+        var toupper = ValueConverter.<String, String>create(String::toUpperCase, String.class);\n+        var reverse = ValueConverter.<String, String>create(str -> {\n+            return new StringBuilder(str).reverse().toString();\n+        }, String.class);\n+\n+        final var baseBuilder = OptionValueConverter.<String>build().converter(toupper);\n+\n+        switch (type) {\n+            case 0 -> {\n+                assertThrowsExactly(UnsupportedOperationException.class, () -> {\n+                    baseBuilder.map(OptionValueConverter.<Object>build());\n+                });\n+            }\n+            case 1 -> {\n+                var builder = baseBuilder.map(reverse);\n+                var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+                    builder.map(OptionValueConverter.<Object>build().converter(phonyConverter(Object.class)));\n+                });\n+                assertEquals(String.format(\"Expected (%s); actual (%s)\", String.class, Object.class), ex.getMessage());\n+\n+                assertEquals(\"CBA\", convertString(builder.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+\n+                var copy = builder.map(baseBuilder);\n+                assertNotSame(copy,  builder);\n+                assertEquals(\"CBA\", convertString(copy.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+                assertEquals(\"CBA\", convertString(builder.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+\n+                copy = builder.map(baseBuilder.copy().converter(tolower));\n+                assertNotSame(copy,  builder);\n+                assertEquals(\"cba\", convertString(copy.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+                assertEquals(\"CBA\", convertString(builder.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+            }\n+            case 2 -> {\n+                var builder = baseBuilder.map(reverse).map(reverse);\n+                var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+                    builder.map(OptionValueConverter.<Object>build().converter(phonyConverter(Object.class)));\n+                });\n+                assertEquals(String.format(\"Expected (%s); actual (%s)\", String.class, Object.class), ex.getMessage());\n+\n+                assertEquals(\"ABC\", convertString(builder.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+\n+                var copy = builder.map(baseBuilder.map(reverse));\n+                assertNotSame(copy,  builder);\n+                assertEquals(\"ABC\", convertString(copy.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+                assertEquals(\"ABC\", convertString(builder.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+\n+                copy = builder.map(baseBuilder.copy().converter(tolower).map(reverse));\n+                assertNotSame(copy,  builder);\n+                assertEquals(\"abc\", convertString(copy.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+                assertEquals(\"ABC\", convertString(builder.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+\n+                copy = builder.map(baseBuilder.copy().converter(tolower));\n+                assertNotSame(copy,  builder);\n+                assertEquals(\"cba\", convertString(copy.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+                assertEquals(\"ABC\", convertString(builder.create(), OptionName.of(\"foo\"), StringToken.of(\"aBc\")).orElseThrow());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTwoStep_converter() {\n+\n+        final var builder = OptionValueConverter.<Path>build()\n+                \/\/ Create the \"String -> Path\" converter\n+                .converter(ValueConverter.create(Path::of, Path.class))\n+                \/\/ Map the \"String -> Path\" converter into the \"Path -> String\" converter\n+                .map(phonyConverter(String.class))\n+                \/\/ Map the \"Path -> String\" converter into the \"String -> String\" converter\n+                .map(phonyConverter(String.class));\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> {\n+            builder.converter(phonyConverter(String.class));\n+        });\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> {\n+            builder.converter();\n+        });\n+    }\n+\n+    private static <T, U> ValueConverter<T, U> phonyConverter(Class<? extends U> valueType) {\n+        return ValueConverter.create(v -> {\n+            throw new AssertionError();\n+        }, valueType);\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionValueConverterTest.java","additions":172,"deletions":16,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.cli.TestUtils.assertExceptionListEquals;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -61,0 +63,1 @@\n+import jdk.jpackage.internal.util.RootedPath;\n@@ -64,0 +67,1 @@\n+import jdk.jpackage.test.JUnitUtils;\n@@ -114,1 +118,1 @@\n-        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(name));\n+        var result = spec.convert(spec.name(), StringToken.of(name));\n@@ -124,1 +128,1 @@\n-        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(workDir.toString()));\n+        var result = spec.convert(spec.name(), StringToken.of(workDir.toString()));\n@@ -138,1 +142,1 @@\n-        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(workDir.toString()));\n+        var result = spec.convert(spec.name(), StringToken.of(workDir.toString()));\n@@ -153,1 +157,1 @@\n-        var value = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(tempRoot.toString())).orElseThrow();\n+        var value = spec.convert(spec.name(), StringToken.of(tempRoot.toString())).orElseThrow();\n@@ -168,1 +172,1 @@\n-                spec.converter().orElseThrow().convert(spec.name(), StringToken.of(tempRoot.toString()))::orElseThrow);\n+                spec.convert(spec.name(), StringToken.of(tempRoot.toString()))::orElseThrow);\n@@ -175,1 +179,1 @@\n-                spec.converter().orElseThrow().convert(spec.name(), StringToken.of(tempRoot.toString()))::orElseThrow);\n+                spec.convert(spec.name(), StringToken.of(tempRoot.toString()))::orElseThrow);\n@@ -203,1 +207,1 @@\n-        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(name));\n+        var result = spec.convert(spec.name(), StringToken.of(name));\n@@ -210,0 +214,133 @@\n+    @Test\n+    public void test_APP_CONTENT_valid(@TempDir Path workDir) throws IOException {\n+\n+        var spec = StandardOption.APP_CONTENT.getSpec();\n+\n+        var contentDir = workDir.resolve(\"a\");\n+        var emptyDir = contentDir.resolve(\"b\/empty-dir\");\n+        var file = contentDir.resolve(\"file.txt\");\n+\n+        Files.createDirectories(emptyDir);\n+        Files.createDirectories(file.getParent());\n+        Files.createFile(file);\n+\n+        Object convertedValue = spec.convert(\n+                spec.name(),\n+                StringToken.of(Stream.of(contentDir, file).map(Path::toString).collect(joining(\",\")))\n+        ).orElseThrow();\n+\n+        var paths = StandardOption.APP_CONTENT.getFrom(Options.of(Map.of(StandardOption.APP_CONTENT, convertedValue)));\n+        var sortedPathList = paths.stream().flatMap(Collection::stream).map(RootedPath::branch).sorted().toList();\n+\n+        var expectedPathList = Stream.of(\n+                \"a\",\n+                \"a\/b\",\n+                \"a\/b\/empty-dir\",\n+                \"a\/file.txt\",\n+                \"file.txt\"\n+        ).map(Path::of).sorted().toList();\n+\n+        assertEquals(expectedPathList, sortedPathList);\n+    }\n+\n+    @Test\n+    public void test_APP_CONTENT_invalid(@TempDir Path workDir) throws IOException {\n+        var spec = StandardOption.APP_CONTENT.getSpec();\n+\n+        var token = StringToken.of(workDir.resolve(\"nonexistent\").toString());\n+        var result = spec.convert(spec.name(), token);\n+\n+        assertExceptionListEquals(Stream.of(\n+                \"error.parameter-not-directory\",\n+                \"error.parameter-not-file\"\n+        ).map(key -> {\n+            return new JPackageException(I18N.format(key, token.value(), spec.name().formatForCommandLine()));\n+        }).toList(), result.errors());\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(OptionMutatorTest.TestType.class)\n+    public void test_pathOptionMutator(OptionMutatorTest.TestType type) {\n+        new OptionMutatorTest<>(StandardOption.pathOptionMutator(), StandardValueConverter.pathConv())\n+                .validValue(\"file.txt\")\n+                .invalidValue(\"\\0\")\n+                .cmdlineErrorFormatKeys(\"error.parameter-not-path\")\n+                .propertyFileErrorFormatKeys(\"error.properties-parameter-not-path\")\n+                .test(OptionSpecBuilder.create(Path.class), type);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(OptionMutatorTest.TestType.class)\n+    public void test_existingPathOptionMutator(OptionMutatorTest.TestType type, @TempDir Path workDir) {\n+        new OptionMutatorTest<>(StandardOption.existingPathOptionMutator(), StandardValueConverter.pathConv())\n+                .validValue(workDir.toString())\n+                .invalidValue(workDir.resolve(\"nonexistent\").toString())\n+                .cmdlineErrorFormatKeys(\"error.parameter-not-directory\", \"error.parameter-not-file\")\n+                .propertyFileErrorFormatKeys(\"error.properties-parameter-not-directory\", \"error.properties-parameter-not-file\")\n+                .test(OptionSpecBuilder.create(Path.class), type);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(OptionMutatorTest.TestType.class)\n+    public void test_directoryOptionMutator(OptionMutatorTest.TestType type, @TempDir Path workDir) {\n+        new OptionMutatorTest<>(StandardOption.directoryOptionMutator(), StandardValueConverter.pathConv())\n+                .validValue(workDir.toString())\n+                .invalidValue(workDir.resolve(\"nonexistent\").toString())\n+                .cmdlineErrorFormatKeys(\"error.parameter-not-directory\")\n+                .propertyFileErrorFormatKeys(\"error.properties-parameter-not-directory\")\n+                .test(OptionSpecBuilder.create(Path.class), type);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(OptionMutatorTest.TestType.class)\n+    public void test_fileOptionMutator(OptionMutatorTest.TestType type, @TempDir Path workDir) throws IOException {\n+        var test = new OptionMutatorTest<>(StandardOption.fileOptionMutator(), StandardValueConverter.pathConv())\n+                .invalidValue(workDir.resolve(\"nonexistent\").toString())\n+                .cmdlineErrorFormatKeys(\"error.parameter-not-file\")\n+                .propertyFileErrorFormatKeys(\"error.properties-parameter-not-file\");\n+\n+        switch (type) {\n+            case TEST_CMDLINE_VALID, TEST_PROPERTY_FILE_VALID -> {\n+                var file = workDir.resolve(\"file.txt\");\n+                Files.createFile(file);\n+                test.validValue(file.toString());\n+            }\n+            default -> {}\n+        }\n+\n+        test.test(OptionSpecBuilder.create(Path.class), type);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(OptionMutatorTest.TestType.class)\n+    public void test_explodedPathOptionMapper(OptionMutatorTest.TestType type, @TempDir Path workDir) throws IOException {\n+\n+        var explodePath = StandardValueConverter.explodedPathConverter().withPathFileName().create();\n+\n+        ValueConverter<String, RootedPath[]> conv = ValueConverter.create(str -> {\n+            var path = StandardValueConverter.pathConv().convert(str);\n+            return explodePath.convert(path);\n+        }, RootedPath[].class);\n+\n+        var test = new OptionMutatorTest<>(_ -> {}, conv)\n+                .invalidValue(workDir.resolve(\"nonexistent\").toString())\n+                .cmdlineErrorFormatKeys(\"error.parameter-not-directory\")\n+                .propertyFileErrorFormatKeys(\"error.properties-parameter-not-directory\");\n+\n+        switch (type) {\n+            case TEST_CMDLINE_VALID, TEST_PROPERTY_FILE_VALID -> {\n+                var dir = workDir.resolve(\"dir\");\n+                Files.createDirectories(dir);\n+                for (var file : List.of(\"foo.txt\", \"bar.txt\")) {\n+                    Files.createFile(workDir.resolve(file));\n+                }\n+                test.validValue(dir.toString());\n+            }\n+            default -> {}\n+        }\n+\n+        test.test(OptionSpecBuilder.create(Path.class)\n+                .mutate(StandardOption.directoryOptionMutator())\n+                .map(StandardOption.explodedPathOptionMapper(explodePath)), type);\n+    }\n+\n@@ -224,0 +361,7 @@\n+    @Test\n+    public void test_booleanOptionMutator_in_property_file() {\n+        new OptionMutatorTest<>(StandardOption.booleanOptionMutator(), StandardValueConverter.booleanConv())\n+                .validValue(Boolean.TRUE.toString())\n+                .test(OptionSpecBuilder.create(Boolean.class), OptionMutatorTest.TestType.TEST_PROPERTY_FILE_VALID);\n+    }\n+\n@@ -306,1 +450,1 @@\n-        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(value));\n+        var result = spec.convert(spec.name(), StringToken.of(value));\n@@ -353,1 +497,1 @@\n-            var bundleType = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(bundleTypeStr)).orElseThrow();\n+            var bundleType = spec.convert(spec.name(), StringToken.of(bundleTypeStr)).orElseThrow();\n@@ -394,0 +538,94 @@\n+    static final class OptionMutatorTest<T> {\n+\n+        enum TestType {\n+            TEST_CMDLINE_VALID,\n+            TEST_PROPERTY_FILE_VALID,\n+            TEST_CMDLINE_INVALID,\n+            TEST_PROPERTY_FILE_INVALID;\n+        }\n+\n+        OptionMutatorTest(Consumer<OptionSpecBuilder<T>> testee, ValueConverter<String, T> conv) {\n+            this.testee = Objects.requireNonNull(testee);\n+            this.conv = Objects.requireNonNull(conv);\n+        }\n+\n+        void test(OptionSpecBuilder<T> specBuilder, TestType type) {\n+            var srcSpec = specBuilder.name(\"foo\").mutate(testee).createOptionSpec();\n+            OptionSpec<T> spec;\n+\n+            var propertyFile = Path.of(\"foo.properties\");\n+\n+            switch (type) {\n+                case TEST_PROPERTY_FILE_VALID, TEST_PROPERTY_FILE_INVALID -> {\n+                    spec = new StandardOptionContext().forFile(propertyFile).mapOptionSpec(srcSpec);\n+                }\n+                default -> {\n+                    spec = srcSpec;\n+                }\n+            }\n+\n+            StringToken token;\n+            switch (type) {\n+                case TEST_CMDLINE_VALID, TEST_PROPERTY_FILE_VALID -> {\n+                    token = StringToken.of(Objects.requireNonNull(validValue));\n+                }\n+                default -> {\n+                    token = StringToken.of(Objects.requireNonNull(invalidValue));\n+                }\n+            }\n+\n+            var result = spec.convert(spec.name(), token);\n+\n+            switch (type) {\n+                case TEST_CMDLINE_VALID, TEST_PROPERTY_FILE_VALID -> {\n+                    var expected = toFunction(conv::convert).apply(token.value());\n+                    var actual = result.orElseThrow();\n+\n+                    if (spec.valueType().isArray()) {\n+                        JUnitUtils.assertArrayEquals(expected, actual);\n+                    } else {\n+                        assertEquals(expected, actual);\n+                    }\n+                }\n+                case TEST_CMDLINE_INVALID -> {\n+                    assertExceptionListEquals(cmdlineErrorFormatKeys.stream().map(key -> {\n+                        return new JPackageException(I18N.format(key, token.value(), spec.name().formatForCommandLine()));\n+                    }).map(JUnitUtils::removeExceptionCause).toList(), result.errors().stream().map(JUnitUtils::removeExceptionCause).toList());\n+                }\n+                case TEST_PROPERTY_FILE_INVALID -> {\n+                    assertExceptionListEquals(propertyFileErrorFormatKeys.stream().map(key -> {\n+                        return new JPackageException(I18N.format(key, token.value(), spec.name().name(), propertyFile));\n+                    }).map(JUnitUtils::removeExceptionCause).toList(), result.errors().stream().map(JUnitUtils::removeExceptionCause).toList());\n+                }\n+            }\n+        }\n+\n+        OptionMutatorTest<T> validValue(String v) {\n+            validValue = v;\n+            return this;\n+        }\n+\n+        OptionMutatorTest<T> invalidValue(String v) {\n+            invalidValue = v;\n+            return this;\n+        }\n+\n+        OptionMutatorTest<T> cmdlineErrorFormatKeys(String... v) {\n+            cmdlineErrorFormatKeys = List.of(v);\n+            return this;\n+        }\n+\n+        OptionMutatorTest<T> propertyFileErrorFormatKeys(String... v) {\n+            propertyFileErrorFormatKeys = List.of(v);\n+            return this;\n+        }\n+\n+        private final Consumer<OptionSpecBuilder<T>> testee;\n+        private final ValueConverter<String, T> conv;\n+        private List<String> cmdlineErrorFormatKeys;\n+        private List<String> propertyFileErrorFormatKeys;\n+        private String validValue;\n+        private String invalidValue;\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardOptionTest.java","additions":247,"deletions":9,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    public void test_identityConv() {\n+    public void test_identityConv() throws Exception {\n@@ -61,1 +61,1 @@\n-    public void test_pathConv(boolean positive) {\n+    public void test_pathConv(boolean positive) throws Exception {\n@@ -75,1 +75,1 @@\n-    public void test_booleanConv(String value, Boolean expected) {\n+    public void test_booleanConv(String value, Boolean expected) throws Exception {\n@@ -82,1 +82,1 @@\n-    public void test_mainLauncherShortcutConv(String value, LauncherShortcut expected) {\n+    public void test_mainLauncherShortcutConv(String value, LauncherShortcut expected) throws Exception {\n@@ -96,1 +96,1 @@\n-    public void test_addLauncherShortcutConv(String value, LauncherShortcut expected) {\n+    public void test_addLauncherShortcutConv(String value, LauncherShortcut expected) throws Exception {\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardValueConverterTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -33,2 +31,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+import org.junit.jupiter.api.Test;\n@@ -36,3 +33,0 @@\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.EnumSource;\n-import org.junit.jupiter.params.provider.ValueSource;\n@@ -43,3 +37,2 @@\n-    @ParameterizedTest\n-    @EnumSource(ExcludeType.class)\n-    public void test_copyRecursive_dir(ExcludeType exclude, @TempDir Path workdir) throws IOException {\n+    @Test\n+    public void test_copyRecursive_dir(@TempDir Path workdir) throws IOException {\n@@ -50,16 +43,1 @@\n-        List<Path> excludes = new ArrayList<>();\n-        switch (exclude) {\n-            case EXCLUDE_FILE -> {\n-                excludes.add(Path.of(\"file.txt\"));\n-            }\n-            case EXCLUDE_DIR -> {\n-                excludes.add(Path.of(\"bar\"));\n-            }\n-            case EXCLUDE_SUBDIR -> {\n-                excludes.add(Path.of(\"foo\"));\n-            }\n-            case EXCLUDE_NONE -> {\n-            }\n-        }\n-\n-        FileUtils.copyRecursive(workdir.resolve(\"from\"), workdir.resolve(\"to\"), excludes);\n+        FileUtils.copyRecursive(workdir.resolve(\"from\"), workdir.resolve(\"to\"));\n@@ -68,18 +46,1 @@\n-\n-        switch (exclude) {\n-            case EXCLUDE_FILE -> {\n-                assertFalse(Files.exists(workdir.resolve(\"to\/foo\/bar\/file.txt\")));\n-                assertTrue(Files.isDirectory(workdir.resolve(\"to\/foo\/bar\")));\n-            }\n-            case EXCLUDE_DIR -> {\n-                assertFalse(Files.exists(workdir.resolve(\"to\/foo\/bar\")));\n-                assertTrue(Files.isDirectory(workdir.resolve(\"to\/foo\/buz\")));\n-            }\n-            case EXCLUDE_SUBDIR -> {\n-                assertFalse(Files.exists(workdir.resolve(\"to\/foo\")));\n-                assertTrue(Files.isDirectory(workdir.resolve(\"to\")));\n-            }\n-            case EXCLUDE_NONE -> {\n-                assertEquals(\"Hello\", Files.readString(workdir.resolve(\"to\/foo\/bar\/file.txt\")));\n-            }\n-        }\n+        assertEquals(\"Hello\", Files.readString(workdir.resolve(\"to\/foo\/bar\/file.txt\")));\n@@ -88,3 +49,2 @@\n-    @ParameterizedTest\n-    @ValueSource(booleans = {true, false})\n-    public void test_copyRecursive_file(boolean exclude, @TempDir Path workdir) throws IOException {\n+    @Test\n+    public void test_copyRecursive_file(@TempDir Path workdir) throws IOException {\n@@ -94,6 +54,1 @@\n-        List<Path> excludes = new ArrayList<>();\n-        if (exclude) {\n-            excludes.add(Path.of(\"bar\/file.txt\"));\n-        }\n-\n-        FileUtils.copyRecursive(workdir.resolve(\"from\/foo\/bar\/file.txt\"), workdir.resolve(\"to\/foo\/bar\/file.txt\"), excludes);\n+        FileUtils.copyRecursive(workdir.resolve(\"from\/foo\/bar\/file.txt\"), workdir.resolve(\"to\/foo\/bar\/file.txt\"));\n@@ -102,12 +57,1 @@\n-        if (exclude) {\n-            assertFalse(Files.exists(workdir.resolve(\"to\")));\n-        } else {\n-            assertEquals(\"Hello\", Files.readString(workdir.resolve(\"to\/foo\/bar\/file.txt\")));\n-        }\n-    }\n-\n-    enum ExcludeType {\n-        EXCLUDE_NONE,\n-        EXCLUDE_FILE,\n-        EXCLUDE_DIR,\n-        EXCLUDE_SUBDIR,\n+        assertEquals(\"Hello\", Files.readString(workdir.resolve(\"to\/foo\/bar\/file.txt\")));\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/FileUtilsTest.java","additions":10,"deletions":66,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,4 @@\n+    public static Exception removeExceptionCause(Exception ex) {\n+        return new ExceptionCauseRemover(ex);\n+    }\n+\n@@ -120,0 +124,17 @@\n+    private static final class ExceptionCauseRemover extends Exception {\n+\n+        ExceptionCauseRemover(Exception ex) {\n+            super(ex.getMessage());\n+            type = ex.getClass();\n+        }\n+\n+        public Class<?> getType() {\n+            return type;\n+        }\n+\n+        private final Class<?> type;\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitUtils.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import java.util.function.Function;\n@@ -88,0 +89,1 @@\n+    @ParameterSupplier\n@@ -129,0 +131,8 @@\n+    public static Collection<Object[]> testAppImage() {\n+        return Stream.of(\n+                build().add(NonExistentPath.create(\"*output-app-image*\", JPackageCommand::outputBundle))\n+        ).map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n@@ -153,1 +163,1 @@\n-            if (contentFactories.stream().flatMap(List::stream).anyMatch(TEST_BAD::equals)) {\n+            if (contentFactories.stream().flatMap(List::stream).anyMatch(NonExistentPath.class::isInstance)) {\n@@ -162,1 +172,1 @@\n-            .addRunOnceInitializer(_ -> {\n+            .addInitializer(cmd -> {\n@@ -164,1 +174,3 @@\n-                    return group.stream().map(ContentFactory::create).toList();\n+                    return group.stream().map(contentFactory -> {\n+                        return contentFactory.create(cmd);\n+                    }).toList();\n@@ -195,0 +207,4 @@\n+                if (expectedJPackageExitCode != 0) {\n+                    return;\n+                }\n+\n@@ -332,1 +348,1 @@\n-        Content create();\n+        Content create(JPackageCommand cmd);\n@@ -340,6 +356,1 @@\n-    private sealed interface PathVerifier permits\n-            RegularFileVerifier,\n-            DirectoryVerifier,\n-            SymlinkTargetVerifier,\n-            NoPathVerifier {\n-\n+    private sealed interface PathVerifier {\n@@ -470,1 +481,7 @@\n-    private static final class NonExistantPath implements ContentFactory {\n+    private static final class NonExistentPath implements ContentFactory {\n+\n+        private NonExistentPath(String label, Function<JPackageCommand, Path> makePath) {\n+            this.label = Objects.requireNonNull(label);\n+            this.makePath = Objects.requireNonNull(makePath);\n+        }\n+\n@@ -472,6 +489,4 @@\n-        public Content create() {\n-            var nonExistant = TKit.createTempFile(\"non-existant\");\n-            try {\n-                TKit.deleteIfExists(nonExistant);\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n+        public Content create(JPackageCommand cmd) {\n+            var nonexistent = makePath.apply(cmd);\n+            if (Files.exists(nonexistent)) {\n+                throw new IllegalStateException();\n@@ -479,1 +494,1 @@\n-            return new FileContent(nonExistant, 0);\n+            return new FileContent(nonexistent, 0);\n@@ -484,1 +499,1 @@\n-            return \"*non-existant*\";\n+            return label;\n@@ -486,0 +501,19 @@\n+\n+        static NonExistentPath create(String label, Function<JPackageCommand, Path> makePath) {\n+            return new NonExistentPath(label, makePath);\n+        }\n+\n+        static NonExistentPath create(String path) {\n+            return new NonExistentPath(String.format(\"*%s*\", Objects.requireNonNull(path)), _ -> {\n+                var nonexistent = TKit.createTempFile(path);\n+                try {\n+                    TKit.deleteIfExists(nonexistent);\n+                    return nonexistent;\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            });\n+        }\n+\n+        private final String label;\n+        private final Function<JPackageCommand, Path> makePath;\n@@ -568,1 +602,1 @@\n-        public Content create() {\n+        public Content create(JPackageCommand cmd) {\n@@ -642,1 +676,1 @@\n-        public Content create() {\n+        public Content create(JPackageCommand cmd) {\n@@ -675,1 +709,1 @@\n-    private static final ContentFactory TEST_BAD = new NonExistantPath();\n+    private static final ContentFactory TEST_BAD = NonExistentPath.create(\"non-existent\");\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":57,"deletions":23,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.io.UncheckedIOException;\n@@ -31,0 +32,1 @@\n+import java.util.HashSet;\n@@ -33,0 +35,1 @@\n+import java.util.function.Consumer;\n@@ -34,1 +37,0 @@\n-import java.util.stream.Stream;\n@@ -36,1 +38,0 @@\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n@@ -41,0 +42,1 @@\n+import jdk.jpackage.test.ConfigurationTarget;\n@@ -42,1 +44,0 @@\n-import jdk.jpackage.test.JPackageCommand.StandardAssert;\n@@ -47,0 +48,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n@@ -79,19 +81,0 @@\n-    @Parameters(ifNotOS = OperatingSystem.MACOS)\n-    public static Collection<Object[]> appContentInputOther() {\n-        return List.of(new Object[][]{\n-            {PackageTypeAlias.IMAGE, wrap(cmd -> {\n-                additionalContent(cmd, \"--app-content\", cmd.outputBundle());\n-            }, \"--app-content same as output bundle\")},\n-        });\n-    }\n-\n-    @Parameters(ifOS = OperatingSystem.MACOS)\n-    public static Collection<Object[]> appContentInputOSX() {\n-        var contentsFolder = \"Contents\/MacOS\";\n-        return List.of(new Object[][]{\n-            {PackageTypeAlias.IMAGE, wrap(cmd -> {\n-                additionalContent(cmd, \"--app-content\", cmd.outputBundle().resolve(contentsFolder));\n-            }, String.format(\"--app-content same as the \\\"%s\\\" folder in the output bundle\", contentsFolder))},\n-        });\n-    }\n-\n@@ -149,1 +132,1 @@\n-    public void test() throws Exception {\n+    public void test() {\n@@ -154,5 +137,1 @@\n-        return new Envelope(v, label);\n-    }\n-\n-    private static boolean isAppImageValid(JPackageCommand cmd) {\n-        return !cmd.hasArgument(\"--app-content\") && !cmd.hasArgument(\"--mac-dmg-content\");\n+        return new Envelope(ThrowingConsumer.toConsumer(v), label);\n@@ -162,2 +141,15 @@\n-            ThrowingConsumer<JPackageCommand, ? extends Exception> configure) throws Exception {\n-        ThrowingConsumer<JPackageCommand, Exception> configureWrapper = cmd -> {\n+            Consumer<JPackageCommand> configure) {\n+\n+        ConfigurationTarget cfg;\n+        if (packageTypes.contains(PackageType.IMAGE)) {\n+            cfg = new ConfigurationTarget(\n+                    JPackageCommand.helloAppImage(JAR_PATH.toString() + \":\"));\n+        } else {\n+            cfg = new ConfigurationTarget(new PackageTest()\n+                    .forTypes(packageTypes)\n+                    .configureHelloApp(JAR_PATH.toString() + \":\"));\n+        }\n+\n+        var verifier = new AppDirContentVerifier();\n+\n+        cfg.addInitializer(cmd -> {\n@@ -170,1 +162,1 @@\n-                \/\/ Request to build app image wit user supplied temp directory,\n+                \/\/ Request to build app image with user supplied temp directory,\n@@ -177,0 +169,3 @@\n+        })\n+        .addInitializer(JPackageCommand::executePrerequisiteActions)\n+        .addInitializer(verifier::captureInputDir);\n@@ -178,6 +173,1 @@\n-            if (!isAppImageValid(cmd)) {\n-                \/\/ Standard asserts for .jpackage.xml fail in messed up app image. Disable them.\n-                \/\/ Other standard asserts for app image contents should pass.\n-                cmd.excludeStandardAsserts(StandardAssert.APP_IMAGE_FILE);\n-            }\n-        };\n+        cfg.cmd().ifPresent(JPackageCommand::executeAndAssertHelloAppImageCreated);\n@@ -185,7 +175,1 @@\n-        if (packageTypes.contains(PackageType.IMAGE)) {\n-            JPackageCommand cmd = JPackageCommand.helloAppImage(JAR_PATH.toString() + \":\");\n-            configureWrapper.accept(cmd);\n-            cmd.executeAndAssertHelloAppImageCreated();\n-            if (isAppImageValid(cmd)) {\n-                verifyAppImage(cmd);\n-            }\n+        cfg.addInstallVerifier(verifier::verify);\n@@ -193,17 +177,3 @@\n-            if (cmd.hasArgument(\"--app-content\")) {\n-                \/\/ `--app-content` can be set to the app image directory which\n-                \/\/ should not exist before jpackage is executed:\n-                \/\/  jpackage --name Foo --dest output --app-content output\/Foo\n-                \/\/ Verify the directory exists after jpackage execution.\n-                \/\/ At least this will catch the case when the value of\n-                \/\/ `--app-content` option refers to a path unrelated to jpackage I\/O.\n-                TKit.assertDirectoryExists(Path.of(cmd.getArgumentValue(\"--app-content\")));\n-            }\n-        } else {\n-            new PackageTest()\n-                    .forTypes(packageTypes)\n-                    .configureHelloApp(JAR_PATH.toString() + \":\")\n-                    .addInitializer(configureWrapper)\n-                    .addInstallVerifier(InOutPathTest::verifyAppImage)\n-                    .run(CREATE_AND_UNPACK);\n-        }\n+        cfg.test().ifPresent(pkg -> {\n+            pkg.run(CREATE_AND_UNPACK);\n+        });\n@@ -220,2 +190,1 @@\n-    private static void outputDirSameAsInputDir(JPackageCommand cmd) throws\n-            IOException {\n+    private static void outputDirSameAsInputDir(JPackageCommand cmd) {\n@@ -241,32 +210,1 @@\n-    private static void verifyAppImage(JPackageCommand cmd) throws IOException {\n-        if (!isAppImageValid(cmd)) {\n-            \/\/ Don't verify the contents of app image as it is invalid.\n-            \/\/ jpackage exited without getting stuck in infinite spiral.\n-            \/\/ No more expectations from the tool for the give arguments.\n-            return;\n-        }\n-\n-        final Path rootDir = cmd.isImagePackageType() ? cmd.outputBundle() : cmd.pathToUnpackedPackageFile(\n-                cmd.appInstallationDirectory());\n-        final Path appDir = ApplicationLayout.platformAppImage().resolveAt(\n-                rootDir).appDirectory();\n-\n-        final var knownFiles = Set.of(\n-                JAR_PATH.getName(0).toString(),\n-                PackageFile.getPathInAppImage(Path.of(\"\")).getFileName().toString(),\n-                AppImageFile.getPathInAppImage(Path.of(\"\")).getFileName().toString(),\n-                cmd.name() + \".cfg\"\n-        );\n-\n-        TKit.assertFileExists(appDir.resolve(JAR_PATH));\n-\n-        try (Stream<Path> actualFilesStream = Files.list(appDir)) {\n-            var unexpectedFiles = actualFilesStream.map(path -> {\n-                return path.getFileName().toString();\n-            }).filter(Predicate.not(knownFiles::contains)).toList();\n-            TKit.assertStringListEquals(List.of(), unexpectedFiles,\n-                    \"Check there are no unexpected files in `app` folder\");\n-        }\n-    }\n-\n-    private static final record Envelope(ThrowingConsumer<JPackageCommand, ? extends Exception> value, String label) {\n+    private record Envelope(Consumer<JPackageCommand> value, String label) {\n@@ -294,0 +232,41 @@\n+    private static final class AppDirContentVerifier {\n+\n+        void captureInputDir(JPackageCommand cmd) {\n+            var root = Path.of(cmd.getArgumentValue(\"--input\"));\n+            try (var walk = Files.walk(root)) {\n+                inputDirFiles = walk.map(root::relativize).toList();\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        void verify(JPackageCommand cmd) {\n+            var expectedContent = new HashSet<>(inputDirFiles);\n+\n+            expectedContent.add(Path.of(cmd.name() + \".cfg\"));\n+            if (cmd.isImagePackageType()) {\n+                expectedContent.add(AppImageFile.getPathInAppImage(Path.of(\"\")).getFileName());\n+            } else {\n+                expectedContent.add(PackageFile.getPathInAppImage(Path.of(\"\")).getFileName());\n+            }\n+\n+            final var rootDir = cmd.isImagePackageType() ? cmd.outputBundle() : cmd.pathToUnpackedPackageFile(\n+                    cmd.appInstallationDirectory());\n+            final var appDir = ApplicationLayout.platformAppImage().resolveAt(rootDir).appDirectory();\n+\n+            try (var walk = Files.walk(appDir)) {\n+                var unexpectedFiles = walk\n+                        .map(appDir::relativize)\n+                        .filter(Predicate.not(expectedContent::contains))\n+                        .map(Path::toString)\n+                        .toList();\n+                TKit.assertStringListEquals(List.of(), unexpectedFiles,\n+                        \"Check there are no unexpected files in `app` folder\");\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private Collection<Path> inputDirFiles;\n+    }\n+\n@@ -295,1 +274,1 @@\n-    private final ThrowingConsumer<JPackageCommand, ? extends Exception> configure;\n+    private final Consumer<JPackageCommand> configure;\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":76,"deletions":97,"binary":false,"changes":173,"status":"modified"}]}