{"files":[{"patch":"@@ -3665,0 +3665,144 @@\n+  address generate_cont_thaw(Continuation::thaw_kind kind) {\n+    bool return_barrier = Continuation::is_thaw_return_barrier(kind);\n+    bool return_barrier_exception = Continuation::is_thaw_return_barrier_exception(kind);\n+\n+    address start = __ pc();\n+\n+    if (return_barrier) {\n+      __ ld(sp, Address(xthread, JavaThread::cont_entry_offset()));\n+    }\n+\n+#ifndef PRODUCT\n+    {\n+      Label OK;\n+      __ ld(t0, Address(xthread, JavaThread::cont_entry_offset()));\n+      __ beq(sp, t0, OK);\n+      __ stop(\"incorrect sp\");\n+      __ bind(OK);\n+    }\n+#endif\n+\n+    if (return_barrier) {\n+      \/\/ preserve possible return value from a method returning to the return barrier\n+      __ sub(sp, sp, 2 * wordSize);\n+      __ fsd(f10, Address(sp, 0 * wordSize));\n+      __ sd(x10, Address(sp, 1 * wordSize));\n+    }\n+\n+    __ mv(c_rarg1, (return_barrier ? 1 : 0));\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, Continuation::prepare_thaw), xthread, c_rarg1);\n+    __ mv(t1, x10); \/\/ x10 contains the size of the frames to thaw, 0 if overflow or no more frames\n+\n+    if (return_barrier) {\n+      \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n+      __ ld(x10, Address(sp, 1 * wordSize));\n+      __ fld(f10, Address(sp, 0 * wordSize));\n+      __ add(sp, sp, 2 * wordSize);\n+    }\n+\n+#ifndef PRODUCT\n+    {\n+      Label OK;\n+      __ ld(t0, Address(xthread, JavaThread::cont_entry_offset()));\n+      __ beq(sp, t0, OK);\n+      __ stop(\"incorrect sp\");\n+      __ bind(OK);\n+    }\n+#endif\n+\n+    Label thaw_success;\n+    \/\/ t1 contains the size of the frames to thaw, 0 if overflow or no more frames\n+    __ bnez(t1, thaw_success);\n+    __ la(t0, ExternalAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ jr(t0);\n+    __ bind(thaw_success);\n+\n+    \/\/ make room for the thawed frames\n+    __ sub(t0, sp, t1);\n+    __ andi(sp, t0, -16); \/\/ align\n+\n+    if (return_barrier) {\n+      \/\/ save original return value -- again\n+      __ sub(sp, sp, 2 * wordSize);\n+      __ fsd(f10, Address(sp, 0 * wordSize));\n+      __ sd(x10, Address(sp, 1 * wordSize));\n+    }\n+\n+    \/\/ If we want, we can templatize thaw by kind, and have three different entries\n+    __ mv(c_rarg1, kind);\n+\n+    __ call_VM_leaf(Continuation::thaw_entry(), xthread, c_rarg1);\n+    __ mv(t1, x10); \/\/ x10 is the sp of the yielding frame\n+\n+    if (return_barrier) {\n+      \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n+      __ ld(x10, Address(sp, 1 * wordSize));\n+      __ fld(f10, Address(sp, 0 * wordSize));\n+      __ add(sp, sp, 2 * wordSize);\n+    } else {\n+      __ mv(x10, zr); \/\/ return 0 (success) from doYield\n+    }\n+\n+    \/\/ we're now on the yield frame (which is in an address above us b\/c sp has been pushed down)\n+    __ mv(fp, t1);\n+    __ sub(sp, t1, 2 * wordSize); \/\/ now pointing to fp spill\n+\n+    if (return_barrier_exception) {\n+      __ ld(c_rarg1, Address(fp, -1 * wordSize)); \/\/ return address\n+      __ verify_oop(x10);\n+      __ mv(x9, x10); \/\/ save return value contaning the exception oop in callee-saved x9\n+\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), xthread, c_rarg1);\n+\n+      \/\/ see OptoRuntime::generate_exception_blob: x10 -- exception oop, x13 -- exception pc\n+\n+      __ mv(x11, x10); \/\/ the exception handler\n+      __ mv(x10, x9); \/\/ restore return value contaning the exception oop\n+      __ verify_oop(x10);\n+\n+      __ leave();\n+      __ mv(x13, ra);\n+      __ jr(x11); \/\/ the exception handler\n+    } else {\n+      \/\/ We're \"returning\" into the topmost thawed frame; see Thaw::push_return_frame\n+      __ leave();\n+      __ ret();\n+    }\n+\n+    return start;\n+  }\n+\n+  address generate_cont_thaw() {\n+    if (!Continuations::enabled()) return nullptr;\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"Cont thaw\");\n+    address start = __ pc();\n+    generate_cont_thaw(Continuation::thaw_top);\n+    return start;\n+  }\n+\n+  address generate_cont_returnBarrier() {\n+    if (!Continuations::enabled()) return nullptr;\n+\n+    \/\/ TODO: will probably need multiple return barriers depending on return type\n+    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier\");\n+    address start = __ pc();\n+\n+    generate_cont_thaw(Continuation::thaw_return_barrier);\n+\n+    return start;\n+  }\n+\n+  address generate_cont_returnBarrier_exception() {\n+    if (!Continuations::enabled()) return nullptr;\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier exception handler\");\n+    address start = __ pc();\n+\n+    generate_cont_thaw(Continuation::thaw_return_barrier_exception);\n+\n+    return start;\n+  }\n+\n+#if COMPILER2_OR_JVMCI\n+\n@@ -3667,0 +3811,1 @@\n+\n@@ -4047,110 +4192,0 @@\n-#undef __\n-#define __ masm->\n-\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n-    assert_cond(runtime_entry != nullptr);\n-    enum layout {\n-      fp_off = 0,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    const int insts_size = 1024;\n-    const int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    assert_cond(oop_maps != nullptr && masm != nullptr);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and RA before call\n-\n-    assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n-\n-    \/\/ ra and fp are already in place\n-    __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mv(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mv(c_rarg2, arg2);\n-    }\n-    __ mv(c_rarg0, xthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call(runtime_entry);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-    assert_cond(map != nullptr);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-    __ bnez(t0, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    assert(stub != nullptr, \"create runtime stub fail!\");\n-    return stub->entry_point();\n-  }\n@@ -4161,142 +4196,0 @@\n-  address generate_cont_thaw(Continuation::thaw_kind kind) {\n-    bool return_barrier = Continuation::is_thaw_return_barrier(kind);\n-    bool return_barrier_exception = Continuation::is_thaw_return_barrier_exception(kind);\n-\n-    address start = __ pc();\n-\n-    if (return_barrier) {\n-      __ ld(sp, Address(xthread, JavaThread::cont_entry_offset()));\n-    }\n-\n-#ifndef PRODUCT\n-    {\n-      Label OK;\n-      __ ld(t0, Address(xthread, JavaThread::cont_entry_offset()));\n-      __ beq(sp, t0, OK);\n-      __ stop(\"incorrect sp\");\n-      __ bind(OK);\n-    }\n-#endif\n-\n-    if (return_barrier) {\n-      \/\/ preserve possible return value from a method returning to the return barrier\n-      __ sub(sp, sp, 2 * wordSize);\n-      __ fsd(f10, Address(sp, 0 * wordSize));\n-      __ sd(x10, Address(sp, 1 * wordSize));\n-    }\n-\n-    __ mv(c_rarg1, (return_barrier ? 1 : 0));\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, Continuation::prepare_thaw), xthread, c_rarg1);\n-    __ mv(t1, x10); \/\/ x10 contains the size of the frames to thaw, 0 if overflow or no more frames\n-\n-    if (return_barrier) {\n-      \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n-      __ ld(x10, Address(sp, 1 * wordSize));\n-      __ fld(f10, Address(sp, 0 * wordSize));\n-      __ add(sp, sp, 2 * wordSize);\n-    }\n-\n-#ifndef PRODUCT\n-    {\n-      Label OK;\n-      __ ld(t0, Address(xthread, JavaThread::cont_entry_offset()));\n-      __ beq(sp, t0, OK);\n-      __ stop(\"incorrect sp\");\n-      __ bind(OK);\n-    }\n-#endif\n-\n-    Label thaw_success;\n-    \/\/ t1 contains the size of the frames to thaw, 0 if overflow or no more frames\n-    __ bnez(t1, thaw_success);\n-    __ la(t0, ExternalAddress(StubRoutines::throw_StackOverflowError_entry()));\n-    __ jr(t0);\n-    __ bind(thaw_success);\n-\n-    \/\/ make room for the thawed frames\n-    __ sub(t0, sp, t1);\n-    __ andi(sp, t0, -16); \/\/ align\n-\n-    if (return_barrier) {\n-      \/\/ save original return value -- again\n-      __ sub(sp, sp, 2 * wordSize);\n-      __ fsd(f10, Address(sp, 0 * wordSize));\n-      __ sd(x10, Address(sp, 1 * wordSize));\n-    }\n-\n-    \/\/ If we want, we can templatize thaw by kind, and have three different entries\n-    __ mv(c_rarg1, kind);\n-\n-    __ call_VM_leaf(Continuation::thaw_entry(), xthread, c_rarg1);\n-    __ mv(t1, x10); \/\/ x10 is the sp of the yielding frame\n-\n-    if (return_barrier) {\n-      \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n-      __ ld(x10, Address(sp, 1 * wordSize));\n-      __ fld(f10, Address(sp, 0 * wordSize));\n-      __ add(sp, sp, 2 * wordSize);\n-    } else {\n-      __ mv(x10, zr); \/\/ return 0 (success) from doYield\n-    }\n-\n-    \/\/ we're now on the yield frame (which is in an address above us b\/c sp has been pushed down)\n-    __ mv(fp, t1);\n-    __ sub(sp, t1, 2 * wordSize); \/\/ now pointing to fp spill\n-\n-    if (return_barrier_exception) {\n-      __ ld(c_rarg1, Address(fp, -1 * wordSize)); \/\/ return address\n-      __ verify_oop(x10);\n-      __ mv(x9, x10); \/\/ save return value contaning the exception oop in callee-saved x9\n-\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), xthread, c_rarg1);\n-\n-      \/\/ see OptoRuntime::generate_exception_blob: x10 -- exception oop, x13 -- exception pc\n-\n-      __ mv(x11, x10); \/\/ the exception handler\n-      __ mv(x10, x9); \/\/ restore return value contaning the exception oop\n-      __ verify_oop(x10);\n-\n-      __ leave();\n-      __ mv(x13, ra);\n-      __ jr(x11); \/\/ the exception handler\n-    } else {\n-      \/\/ We're \"returning\" into the topmost thawed frame; see Thaw::push_return_frame\n-      __ leave();\n-      __ ret();\n-    }\n-\n-    return start;\n-  }\n-\n-  address generate_cont_thaw() {\n-    if (!Continuations::enabled()) return nullptr;\n-\n-    StubCodeMark mark(this, \"StubRoutines\", \"Cont thaw\");\n-    address start = __ pc();\n-    generate_cont_thaw(Continuation::thaw_top);\n-    return start;\n-  }\n-\n-  address generate_cont_returnBarrier() {\n-    if (!Continuations::enabled()) return nullptr;\n-\n-    \/\/ TODO: will probably need multiple return barriers depending on return type\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier\");\n-    address start = __ pc();\n-\n-    generate_cont_thaw(Continuation::thaw_return_barrier);\n-\n-    return start;\n-  }\n-\n-  address generate_cont_returnBarrier_exception() {\n-    if (!Continuations::enabled()) return nullptr;\n-\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier exception handler\");\n-    address start = __ pc();\n-\n-    generate_cont_thaw(Continuation::thaw_return_barrier_exception);\n-\n-    return start;\n-  }\n-\n@@ -5152,1 +5045,1 @@\n-\n+#endif \/\/ COMPILER2_OR_JVMCI\n@@ -5467,0 +5360,108 @@\n+  \/\/ Continuation point for throwing of implicit exceptions that are\n+  \/\/ not handled in the current activation. Fabricates an exception\n+  \/\/ oop and initiates normal exception dispatching in this\n+  \/\/ frame. Since we need to preserve callee-saved values (currently\n+  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+  \/\/ map and therefore have to make these stubs into RuntimeStubs\n+  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+  \/\/ be preserved between the fault point and the exception handler\n+  \/\/ then it must assume responsibility for that in\n+  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n+  \/\/ implicit exceptions (e.g., NullPointerException or\n+  \/\/ AbstractMethodError on entry) are either at call sites or\n+  \/\/ otherwise assume that stack unwinding will be initiated, so\n+  \/\/ caller saved registers were assumed volatile in the compiler.\n+\n+#undef __\n+#define __ masm->\n+\n+  address generate_throw_exception(const char* name,\n+                                   address runtime_entry,\n+                                   Register arg1 = noreg,\n+                                   Register arg2 = noreg) {\n+    \/\/ Information about frame layout at time of blocking runtime call.\n+    \/\/ Note that we only have to preserve callee-saved registers since\n+    \/\/ the compilers are responsible for supplying a continuation point\n+    \/\/ if they expect all registers to be preserved.\n+    \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n+    assert_cond(runtime_entry != nullptr);\n+    enum layout {\n+      fp_off = 0,\n+      fp_off2,\n+      return_off,\n+      return_off2,\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    const int insts_size = 1024;\n+    const int locs_size  = 64;\n+\n+    CodeBuffer code(name, insts_size, locs_size);\n+    OopMapSet* oop_maps  = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    assert_cond(oop_maps != nullptr && masm != nullptr);\n+\n+    address start = __ pc();\n+\n+    \/\/ This is an inlined and slightly modified version of call_VM\n+    \/\/ which has the ability to fetch the return PC out of\n+    \/\/ thread-local storage and also sets up last_Java_sp slightly\n+    \/\/ differently than the real call_VM\n+\n+    __ enter(); \/\/ Save FP and RA before call\n+\n+    assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n+\n+    \/\/ ra and fp are already in place\n+    __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n+\n+    int frame_complete = __ pc() - start;\n+\n+    \/\/ Set up last_Java_sp and last_Java_fp\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(sp, fp, the_pc, t0);\n+\n+    \/\/ Call runtime\n+    if (arg1 != noreg) {\n+      assert(arg2 != c_rarg1, \"clobbered\");\n+      __ mv(c_rarg1, arg1);\n+    }\n+    if (arg2 != noreg) {\n+      __ mv(c_rarg2, arg2);\n+    }\n+    __ mv(c_rarg0, xthread);\n+    BLOCK_COMMENT(\"call runtime_entry\");\n+    __ call(runtime_entry);\n+\n+    \/\/ Generate oop map\n+    OopMap* map = new OopMap(framesize, 0);\n+    assert_cond(map != nullptr);\n+\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    __ reset_last_Java_frame(true);\n+\n+    __ leave();\n+\n+    \/\/ check for pending exceptions\n+#ifdef ASSERT\n+    Label L;\n+    __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n+    __ bnez(t0, L);\n+    __ should_not_reach_here();\n+    __ bind(L);\n+#endif \/\/ ASSERT\n+    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub* stub =\n+      RuntimeStub::new_runtime_stub(name,\n+                                    &code,\n+                                    frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    assert(stub != nullptr, \"create runtime stub fail!\");\n+    return stub->entry_point();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":254,"deletions":253,"binary":false,"changes":507,"status":"modified"}]}