{"files":[{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -2750,1 +2751,1 @@\n-  char* my_path;\n+  char my_path[JVM_MAXPATHLEN];\n@@ -2752,3 +2753,1 @@\n-\n-  const char* dump_file_name = \"java_pid\";\n-  const char* dump_file_ext  = HeapDumpGzipLevel > 0 ? \".hprof.gz\" : \".hprof\";\n+  const char* dump_file_name = HeapDumpGzipLevel > 0 ? \"java_pid%p.hprof.gz\" : \"java_pid%p.hprof\";\n@@ -2760,7 +2759,3 @@\n-    \/\/ Calculate potentially longest base path and check if we have enough\n-    \/\/ allocated statically.\n-    const size_t total_length =\n-                      (HeapDumpPath == nullptr ? 0 : strlen(HeapDumpPath)) +\n-                      strlen(os::file_separator()) + max_digit_chars +\n-                      strlen(dump_file_name) + strlen(dump_file_ext) + 1;\n-    if (total_length > sizeof(base_path)) {\n+    \/\/ Set base path (name or directory, default or custom, without seq no), doing %p substitution.\n+    const char *path_src = (HeapDumpPath != nullptr && HeapDumpPath[0] != '\\0') ? HeapDumpPath : dump_file_name;\n+    if (!Arguments::copy_expand_pid(path_src, strlen(path_src), base_path, JVM_MAXPATHLEN - max_digit_chars)) {\n@@ -2770,21 +2765,11 @@\n-\n-    bool use_default_filename = true;\n-    if (HeapDumpPath == nullptr || HeapDumpPath[0] == '\\0') {\n-      \/\/ HeapDumpPath=<file> not specified\n-    } else {\n-      strcpy(base_path, HeapDumpPath);\n-      \/\/ check if the path is a directory (must exist)\n-      DIR* dir = os::opendir(base_path);\n-      if (dir == nullptr) {\n-        use_default_filename = false;\n-      } else {\n-        \/\/ HeapDumpPath specified a directory. We append a file separator\n-        \/\/ (if needed).\n-        os::closedir(dir);\n-        size_t fs_len = strlen(os::file_separator());\n-        if (strlen(base_path) >= fs_len) {\n-          char* end = base_path;\n-          end += (strlen(base_path) - fs_len);\n-          if (strcmp(end, os::file_separator()) != 0) {\n-            strcat(base_path, os::file_separator());\n-          }\n+    \/\/ Check if the path is an existing directory\n+    DIR* dir = os::opendir(base_path);\n+    if (dir != nullptr) {\n+      os::closedir(dir);\n+      \/\/ Path is a directory.  Append a file separator (if needed).\n+      size_t fs_len = strlen(os::file_separator());\n+      if (strlen(base_path) >= fs_len) {\n+        char* end = base_path;\n+        end += (strlen(base_path) - fs_len);\n+        if (strcmp(end, os::file_separator()) != 0) {\n+          strcat(base_path, os::file_separator());\n@@ -2793,0 +2778,7 @@\n+      \/\/ Then add the default name, with %p substitution.  Use my_path temporarily.\n+      if (!Arguments::copy_expand_pid(dump_file_name, strlen(dump_file_name), my_path, JVM_MAXPATHLEN - max_digit_chars)) {\n+        warning(\"Cannot create heap dump file.  HeapDumpPath is too long.\");\n+        return;\n+      }\n+      const size_t dlen = strlen(base_path);\n+      jio_snprintf(&base_path[dlen], sizeof(base_path) - dlen, \"%s\", my_path);\n@@ -2794,13 +2786,1 @@\n-    \/\/ If HeapDumpPath wasn't a file name then we append the default name\n-    if (use_default_filename) {\n-      const size_t dlen = strlen(base_path);  \/\/ if heap dump dir specified\n-      jio_snprintf(&base_path[dlen], sizeof(base_path)-dlen, \"%s%d%s\",\n-                   dump_file_name, os::current_process_id(), dump_file_ext);\n-    }\n-    const size_t len = strlen(base_path) + 1;\n-    my_path = (char*)os::malloc(len, mtInternal);\n-    if (my_path == nullptr) {\n-      warning(\"Cannot create heap dump file.  Out of system memory.\");\n-      return;\n-    }\n-    strncpy(my_path, base_path, len);\n+    strncpy(my_path, base_path, JVM_MAXPATHLEN);\n@@ -2810,5 +2790,0 @@\n-    my_path = (char*)os::malloc(len, mtInternal);\n-    if (my_path == nullptr) {\n-      warning(\"Cannot create heap dump file.  Out of system memory.\");\n-      return;\n-    }\n@@ -2822,1 +2797,0 @@\n-  os::free(my_path);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":25,"deletions":51,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+        System.out.println(\"PASSED\");\n@@ -77,1 +78,2 @@\n-        String heapdumpFilename = type + \".hprof\";\n+        \/\/ Test using %p pid substitution in HeapDumpPath:\n+        String heapdumpFilename = type + \".%p.hprof\";\n@@ -97,7 +99,5 @@\n-        output.shouldContain(\"Dumping heap to \" + type + \".hprof\");\n-        File dump = new File(heapdumpFilename);\n-        Asserts.assertTrue(dump.exists() && dump.isFile(),\n-                \"Could not find dump file \" + dump.getAbsolutePath());\n-\n-        HprofParser.parse(new File(heapdumpFilename));\n-        System.out.println(\"PASSED\");\n+        String expectedHeapdumpFilename = type + \".\" + output.pid() + \".hprof\";\n+        output.shouldContain(\"Dumping heap to \" + expectedHeapdumpFilename);\n+        File dump = new File(expectedHeapdumpFilename);\n+        Asserts.assertTrue(dump.exists() && dump.isFile(), \"Expected heap dump file \" + dump.getAbsolutePath());\n+        HprofParser.parse(new File(expectedHeapdumpFilename));\n@@ -105,1 +105,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestHeapDumpOnOutOfMemoryError.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"}]}