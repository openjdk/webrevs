{"files":[{"patch":"@@ -0,0 +1,566 @@\n+diff --git a\/src\/hotspot\/share\/runtime\/objectMonitor.cpp b\/src\/hotspot\/share\/runtime\/objectMonitor.cpp\n+index ee7629ec6f5..b1c806308ff 100644\n+--- a\/src\/hotspot\/share\/runtime\/objectMonitor.cpp\n++++ b\/src\/hotspot\/share\/runtime\/objectMonitor.cpp\n+@@ -338,15 +338,6 @@ void ObjectMonitor::ExitOnSuspend::operator()(JavaThread* current) {\n+   }\n+ }\n+ \n+-void ObjectMonitor::ClearSuccOnSuspend::operator()(JavaThread* current) {\n+-  if (current->is_suspended()) {\n+-    if (_om->has_successor(current)) {\n+-      _om->clear_successor();\n+-      OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n+-    }\n+-  }\n+-}\n+-\n+ #define assert_mark_word_consistency()                                         \\\n+   assert(UseObjectMonitorTable || object()->mark() == markWord::encode(this),  \\\n+          \"object mark must match encoded this: mark=\" INTPTR_FORMAT            \\\n+@@ -499,7 +490,7 @@ bool ObjectMonitor::spin_enter(JavaThread* current) {\n+   return false;\n+ }\n+ \n+-bool ObjectMonitor::enter(JavaThread* current) {\n++bool ObjectMonitor::enter(JavaThread* current, bool post_jvmti_events) {\n+   assert(current == JavaThread::current(), \"must be\");\n+ \n+   if (spin_enter(current)) {\n+@@ -520,7 +511,7 @@ bool ObjectMonitor::enter(JavaThread* current) {\n+   }\n+ \n+   \/\/ At this point this ObjectMonitor cannot be deflated, finish contended enter\n+-  enter_with_contention_mark(current, contention_mark);\n++  enter_with_contention_mark(current, contention_mark, post_jvmti_events);\n+   return true;\n+ }\n+ \n+@@ -539,7 +530,7 @@ void ObjectMonitor::notify_contended_enter(JavaThread* current) {\n+   }\n+ }\n+ \n+-void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm) {\n++void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm, bool post_jvmti_events) {\n+   assert(current == JavaThread::current(), \"must be\");\n+   assert(!has_owner(current), \"must be\");\n+   assert(cm._monitor == this, \"must be\");\n+@@ -643,7 +634,7 @@ void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonito\n+   \/\/ spinning we could increment JVMStat counters, etc.\n+ \n+   DTRACE_MONITOR_PROBE(contended__entered, this, object(), current);\n+-  if (JvmtiExport::should_post_monitor_contended_entered()) {\n++  if (post_jvmti_events && JvmtiExport::should_post_monitor_contended_entered()) {\n+     JvmtiExport::post_monitor_contended_entered(current, this);\n+ \n+     \/\/ The current thread already owns the monitor and is not going to\n+@@ -1101,11 +1092,10 @@ void ObjectMonitor::enter_internal(JavaThread* current) {\n+ \n+ void ObjectMonitor::reenter_internal(JavaThread* current, ObjectWaiter* currentNode) {\n+   assert(current != nullptr, \"invariant\");\n+-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n++  assert(current->thread_state() == _thread_blocked, \"invariant\");\n+   assert(currentNode != nullptr, \"invariant\");\n+   assert(currentNode->_thread == current, \"invariant\");\n+   assert(_waiters > 0, \"invariant\");\n+-  assert_mark_word_consistency();\n+ \n+   \/\/ If there are unmounted virtual threads ahead in the _entry_list we want\n+   \/\/ to do a timed-park instead to alleviate some deadlock cases where one\n+@@ -1141,22 +1131,15 @@ void ObjectMonitor::reenter_internal(JavaThread* current, ObjectWaiter* currentN\n+ \n+     {\n+       OSThreadContendState osts(current->osthread());\n+-\n+-      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n+-\n+-      {\n+-        ClearSuccOnSuspend csos(this);\n+-        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n+-        if (do_timed_parked) {\n+-          current->_ParkEvent->park(recheck_interval);\n+-          \/\/ Increase the recheck_interval, but clamp the value.\n+-          recheck_interval *= 8;\n+-          if (recheck_interval > MAX_RECHECK_INTERVAL) {\n+-            recheck_interval = MAX_RECHECK_INTERVAL;\n+-          }\n+-        } else {\n+-          current->_ParkEvent->park();\n++      if (do_timed_parked) {\n++        current->_ParkEvent->park(recheck_interval);\n++        \/\/ Increase the recheck_interval, but clamp the value.\n++        recheck_interval *= 8;\n++        if (recheck_interval > MAX_RECHECK_INTERVAL) {\n++          recheck_interval = MAX_RECHECK_INTERVAL;\n+         }\n++      } else {\n++        current->_ParkEvent->park();\n+       }\n+     }\n+ \n+@@ -1183,7 +1166,6 @@ void ObjectMonitor::reenter_internal(JavaThread* current, ObjectWaiter* currentN\n+ \n+   \/\/ Current has acquired the lock -- Unlink current from the _entry_list.\n+   assert(has_owner(current), \"invariant\");\n+-  assert_mark_word_consistency();\n+   unlink_after_acquire(current, currentNode);\n+   if (has_successor(current)) clear_successor();\n+   assert(!has_successor(current), \"invariant\");\n+@@ -1893,8 +1875,7 @@ void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {\n+     assert(current->thread_state() == _thread_in_vm, \"invariant\");\n+ \n+     {\n+-      ClearSuccOnSuspend csos(this);\n+-      ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n++      ThreadBlockInVM tbivm(current, false \/* allow_suspend *\/);\n+       if (interrupted || HAS_PENDING_EXCEPTION) {\n+         \/\/ Intentionally empty\n+       } else if (node.TState == ObjectWaiter::TS_WAIT) {\n+@@ -1946,6 +1927,41 @@ void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {\n+     \/\/ although the raw address of the object may have changed.\n+     \/\/ (Don't cache naked oops over safepoints, of course).\n+ \n++    OrderAccess::fence();\n++\n++    assert(!has_owner(current), \"invariant\");\n++    ObjectWaiter::TStates v = node.TState;\n++    if (v == ObjectWaiter::TS_RUN) {\n++      \/\/ We use the NoPreemptMark for the very rare case where the previous\n++      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n++      \/\/ could succeed but we can't unmount now.\n++      NoPreemptMark npm(current);\n++      enter(current);\n++    } else {\n++      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n++      ExitOnSuspend eos(this);\n++      {\n++        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos, true \/* allow_suspend *\/);\n++        reenter_internal(current, &node);\n++        \/\/ We can go to a safepoint at the end of this block. If we\n++        \/\/ do a thread dump during that safepoint, then this thread will show\n++        \/\/ as having \"-locked\" the monitor, but the OS and java.lang.Thread\n++        \/\/ states will still report that the thread is blocked trying to\n++        \/\/ acquire it.\n++        \/\/ If there is a suspend request, ExitOnSuspend will exit the OM\n++        \/\/ and set the OM as pending.\n++      }\n++      if (eos.exited()) {\n++        \/\/ ExitOnSuspend exit the OM\n++        assert(!has_owner(current), \"invariant\");\n++        guarantee(node.TState == ObjectWaiter::TS_RUN, \"invariant\");\n++        current->set_current_pending_monitor(nullptr);\n++        enter(current, false \/* post_jvmti_events *\/);\n++      }\n++      assert(has_owner(current), \"invariant\");\n++      node.wait_reenter_end(this);\n++    }\n++\n+     \/\/ post monitor waited event. Note that this is past-tense, we are done waiting.\n+     if (JvmtiExport::should_post_monitor_waited()) {\n+       JvmtiExport::post_monitor_waited(current, this, ret == OS_TIMEOUT);\n+@@ -1974,22 +1990,6 @@ void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {\n+       post_monitor_wait_event(&wait_event, this, node._notifier_tid, millis, ret == OS_TIMEOUT);\n+     }\n+ \n+-    OrderAccess::fence();\n+-\n+-    assert(!has_owner(current), \"invariant\");\n+-    ObjectWaiter::TStates v = node.TState;\n+-    if (v == ObjectWaiter::TS_RUN) {\n+-      \/\/ We use the NoPreemptMark for the very rare case where the previous\n+-      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n+-      \/\/ could succeed but we can't unmount now.\n+-      NoPreemptMark npm(current);\n+-      enter(current);\n+-    } else {\n+-      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n+-      reenter_internal(current, &node);\n+-      node.wait_reenter_end(this);\n+-    }\n+-\n+     \/\/ current has reacquired the lock.\n+     \/\/ Lifecycle - the node representing current must not appear on any queues.\n+     \/\/ Node is about to go out-of-scope, but even if it were immortal we wouldn't\n+diff --git a\/src\/hotspot\/share\/runtime\/objectMonitor.hpp b\/src\/hotspot\/share\/runtime\/objectMonitor.hpp\n+index 53b64f1e8a5..d9ade27eecd 100644\n+--- a\/src\/hotspot\/share\/runtime\/objectMonitor.hpp\n++++ b\/src\/hotspot\/share\/runtime\/objectMonitor.hpp\n+@@ -362,23 +362,16 @@ class ObjectMonitor : public CHeapObj<mtObjectMonitor> {\n+     void operator()(JavaThread* current);\n+     bool exited() { return _om_exited; }\n+   };\n+-  class ClearSuccOnSuspend {\n+-   protected:\n+-    ObjectMonitor* _om;\n+-   public:\n+-    ClearSuccOnSuspend(ObjectMonitor* om) : _om(om)  {}\n+-    void operator()(JavaThread* current);\n+-  };\n+ \n+   bool      enter_is_async_deflating();\n+   void      notify_contended_enter(JavaThread *current);\n+  public:\n+   void      enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n+   bool      enter_for(JavaThread* locking_thread);\n+-  bool      enter(JavaThread* current);\n++  bool      enter(JavaThread* current, bool post_jvmti_events = true);\n+   bool      try_enter(JavaThread* current, bool check_for_recursion = true);\n+   bool      spin_enter(JavaThread* current);\n+-  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n++  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark, bool post_jvmti_events = true);\n+   void      exit(JavaThread* current, bool not_suspended = true);\n+   bool      resume_operation(JavaThread* current, ObjectWaiter* node, ContinuationWrapper& cont);\n+   void      wait(jlong millis, bool interruptible, TRAPS);\n+diff --git a\/test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java b\/test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java\n+index 3a747a3e86b..12a84b1a3d2 100644\n+--- a\/test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java\n++++ b\/test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java\n+@@ -28,7 +28,27 @@\n+  * @requires vm.jvmti\n+  * @library \/test\/lib\n+  * @compile SuspendWithObjectMonitorWait.java\n+- * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait\n++ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 1\n++ *\/\n++\n++\/*\n++ * @test\n++ * @bug 4413752 8262881\n++ * @summary Test SuspendThread with ObjectMonitor wait.\n++ * @requires vm.jvmti\n++ * @library \/test\/lib\n++ * @compile SuspendWithObjectMonitorWait.java\n++ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 2\n++ *\/\n++\n++\/*\n++ * @test\n++ * @bug 4413752 8262881\n++ * @summary Test SuspendThread with ObjectMonitor wait.\n++ * @requires vm.jvmti\n++ * @library \/test\/lib\n++ * @compile SuspendWithObjectMonitorWait.java\n++ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 3\n+  *\/\n+ \n+ import java.io.PrintStream;\n+@@ -87,6 +107,7 @@ public class SuspendWithObjectMonitorWait {\n+     native static int wait4ContendedEnter(SuspendWithObjectMonitorWaitWorker thr);\n+ \n+     public static void main(String[] args) throws Exception {\n++        int test = Integer.parseInt(args[0]);\n+         try {\n+             System.loadLibrary(AGENT_LIB);\n+             log(\"Loaded library: \" + AGENT_LIB);\n+@@ -122,7 +143,7 @@ public static void main(String[] args) throws Exception {\n+             }\n+         }\n+ \n+-        System.exit(run(timeMax, System.out) + exit_delta);\n++        System.exit(run(timeMax, System.out, test) + exit_delta);\n+     }\n+ \n+     public static void logDebug(String mesg) {\n+@@ -141,8 +162,14 @@ public static void usage() {\n+         System.exit(1);\n+     }\n+ \n+-    public static int run(int timeMax, PrintStream out) {\n+-        return (new SuspendWithObjectMonitorWait()).doWork(timeMax, out);\n++    public static int run(int timeMax, PrintStream out, int test) {\n++        switch (test) {\n++            case 1: return (new SuspendWithObjectMonitorWait()).doWork1(timeMax, out);\n++            case 2: return (new SuspendWithObjectMonitorWait()).doWork2(timeMax, out);\n++            case 3: return (new SuspendWithObjectMonitorWait()).doWork3(timeMax, out);\n++            default: throw new RuntimeException(\"Unknown test\");\n++        }\n++\n+     }\n+ \n+     public static void checkTestState(int exp) {\n+@@ -153,7 +180,8 @@ public static void checkTestState(int exp) {\n+         }\n+     }\n+ \n+-    public int doWork(int timeMax, PrintStream out) {\n++    \/\/ Default scenario, the resumer thread is always able to grab the threadLock once notified by the main thread.\n++    public int doWork1(int timeMax, PrintStream out) {\n+         SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+         SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n+ \n+@@ -265,18 +293,266 @@ public int doWork(int timeMax, PrintStream out) {\n+ \n+         return 0;\n+     }\n++\n++    \/\/ Notify the resumer while holding the threadLock\n++    public int doWork2(int timeMax, PrintStream out) {\n++        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n++        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n++\n++        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n++\n++        long start_time = System.currentTimeMillis();\n++        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n++            count++;\n++            testState = TS_INIT;  \/\/ starting the test loop\n++\n++            \/\/ launch the waiter thread\n++            synchronized (barrierLaunch) {\n++                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n++                waiter.start();\n++\n++                while (testState != TS_WAITER_RUNNING) {\n++                    try {\n++                        barrierLaunch.wait(0);  \/\/ wait until it is running\n++                    } catch (InterruptedException ex) {\n++                    }\n++                }\n++            }\n++\n++            \/\/ launch the resumer thread\n++            synchronized (barrierLaunch) {\n++                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n++                resumer.start();\n++\n++                while (testState != TS_RESUMER_RUNNING) {\n++                    try {\n++                        barrierLaunch.wait(0);  \/\/ wait until it is running\n++                    } catch (InterruptedException ex) {\n++                    }\n++                }\n++            }\n++\n++            checkTestState(TS_RESUMER_RUNNING);\n++\n++            \/\/ The waiter thread was synchronized on threadLock before it\n++            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n++            \/\/ we cannot enter threadLock until the waiter thread calls\n++            \/\/ threadLock.wait().\n++            synchronized (threadLock) {\n++                \/\/ notify waiter thread so it can try to reenter threadLock\n++                testState = TS_READY_TO_NOTIFY;\n++                threadLock.notify();\n++\n++                \/\/ wait for the waiter thread to block\n++                logDebug(\"before contended enter wait\");\n++                int retCode = wait4ContendedEnter(waiter);\n++                if (retCode != 0) {\n++                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n++                                                + \"retCode=\" + retCode);\n++                }\n++                logDebug(\"done contended enter wait\");\n++\n++                checkTestState(TS_READY_TO_NOTIFY);\n++                testState = TS_CALL_SUSPEND;\n++                logDebug(\"before suspend thread\");\n++                retCode = suspendThread(waiter);\n++                if (retCode != 0) {\n++                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n++                                                + \"retCode=\" + retCode);\n++                }\n++                logDebug(\"suspended thread\");\n++\n++                \/\/\n++                \/\/ At this point, all of the child threads are running\n++                \/\/ and we can get to meat of the test:\n++                \/\/\n++                \/\/ - suspended threadLock waiter (trying to reenter)\n++                \/\/ - a threadLock enter in the resumer thread\n++                \/\/ - resumption of the waiter thread\n++                \/\/ - a threadLock enter in the freshly resumed waiter thread\n++                \/\/\n++\n++                synchronized (barrierResumer) {\n++                    checkTestState(TS_CALL_SUSPEND);\n++\n++                    \/\/ tell resumer thread to resume waiter thread\n++                    testState = TS_READY_TO_RESUME;\n++                    barrierResumer.notify();\n++\n++                    \/\/ Can't call checkTestState() here because the\n++                    \/\/ resumer thread may have already resumed the\n++                    \/\/ waiter thread.\n++                }\n++                try {\n++                    Thread.sleep(1000);\n++                } catch(Exception e) {}\n++            }\n++\n++            try {\n++                resumer.join(JOIN_MAX * 1000);\n++                if (resumer.isAlive()) {\n++                    System.err.println(\"Failure at \" + count + \" loops.\");\n++                    throw new InternalError(\"resumer thread is stuck\");\n++                }\n++                waiter.join(JOIN_MAX * 1000);\n++                if (waiter.isAlive()) {\n++                    System.err.println(\"Failure at \" + count + \" loops.\");\n++                    throw new InternalError(\"waiter thread is stuck\");\n++                }\n++            } catch (InterruptedException ex) {\n++            }\n++\n++            checkTestState(TS_WAITER_DONE);\n++        }\n++\n++        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n++                \" seconds.\");\n++\n++        return 0;\n++    }\n++\n++    \/\/ Suspend on the re-entry path of wait.\n++    public int doWork3(int timeMax, PrintStream out) {\n++        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n++        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n++\n++        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n++\n++        long start_time = System.currentTimeMillis();\n++        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n++            count++;\n++            testState = TS_INIT;  \/\/ starting the test loop\n++\n++            \/\/ launch the waiter thread\n++            synchronized (barrierLaunch) {\n++                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\", 1);\n++                waiter.start();\n++\n++                while (testState != TS_WAITER_RUNNING) {\n++                    try {\n++                        barrierLaunch.wait(0);  \/\/ wait until it is running\n++                    } catch (InterruptedException ex) {\n++                    }\n++                }\n++            }\n++\n++            \/\/ launch the resumer thread\n++            synchronized (barrierLaunch) {\n++                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n++                resumer.start();\n++\n++                while (testState != TS_RESUMER_RUNNING) {\n++                    try {\n++                        barrierLaunch.wait(0);  \/\/ wait until it is running\n++                    } catch (InterruptedException ex) {\n++                    }\n++                }\n++            }\n++\n++            try {\n++                Thread.sleep(1000);\n++            } catch(Exception e) {}\n++\n++            checkTestState(TS_RESUMER_RUNNING);\n++\n++            \/\/ The waiter thread was synchronized on threadLock before it\n++            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n++            \/\/ we cannot enter threadLock until the waiter thread calls\n++            \/\/ threadLock.wait().\n++            synchronized (threadLock) {\n++                \/\/ notify waiter thread so it can try to reenter threadLock\n++                testState = TS_READY_TO_NOTIFY;\n++                threadLock.notify();\n++\n++                \/\/ wait for the waiter thread to block\n++                logDebug(\"before contended enter wait\");\n++                int retCode = wait4ContendedEnter(waiter);\n++                if (retCode != 0) {\n++                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n++                                                 + \"retCode=\" + retCode);\n++                }\n++                logDebug(\"done contended enter wait\");\n++\n++                checkTestState(TS_READY_TO_NOTIFY);\n++                testState = TS_CALL_SUSPEND;\n++                logDebug(\"before suspend thread\");\n++                retCode = suspendThread(waiter);\n++                if (retCode != 0) {\n++                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n++                                                + \"retCode=\" + retCode);\n++                }\n++                logDebug(\"suspended thread\");\n++\n++                \/\/\n++                \/\/ At this point, all of the child threads are running\n++                \/\/ and we can get to meat of the test:\n++                \/\/\n++                \/\/ - suspended threadLock waiter (trying to reenter)\n++                \/\/ - a threadLock enter in the resumer thread\n++                \/\/ - resumption of the waiter thread\n++                \/\/ - a threadLock enter in the freshly resumed waiter thread\n++                \/\/\n++\n++                synchronized (barrierResumer) {\n++                    checkTestState(TS_CALL_SUSPEND);\n++\n++                    \/\/ tell resumer thread to resume waiter thread\n++                    testState = TS_READY_TO_RESUME;\n++                    barrierResumer.notify();\n++\n++                    \/\/ Can't call checkTestState() here because the\n++                    \/\/ resumer thread may have already resumed the\n++                    \/\/ waiter thread.\n++                }\n++                try {\n++                    Thread.sleep(1000);\n++                } catch(Exception e) {}\n++            }\n++\n++            try {\n++                resumer.join(JOIN_MAX * 1000);\n++                if (resumer.isAlive()) {\n++                    System.err.println(\"Failure at \" + count + \" loops.\");\n++                    throw new InternalError(\"resumer thread is stuck\");\n++                }\n++                waiter.join(JOIN_MAX * 1000);\n++                if (waiter.isAlive()) {\n++                    System.err.println(\"Failure at \" + count + \" loops.\");\n++                    throw new InternalError(\"waiter thread is stuck\");\n++                }\n++            } catch (InterruptedException ex) {\n++            }\n++\n++            checkTestState(TS_WAITER_DONE);\n++        }\n++\n++        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n++                \" seconds.\");\n++\n++        return 0;\n++    }\n+ }\n+ \n++\n++\n+ class SuspendWithObjectMonitorWaitWorker extends Thread {\n+     private SuspendWithObjectMonitorWaitWorker target;  \/\/ target for resume operation\n++    private final long waitTimeout;\n+ \n+     public SuspendWithObjectMonitorWaitWorker(String name) {\n+         super(name);\n++        this.waitTimeout = 0;\n++    }\n++\n++    public SuspendWithObjectMonitorWaitWorker(String name, long waitTimeout) {\n++        super(name);\n++        this.waitTimeout = waitTimeout;\n+     }\n+ \n+     public SuspendWithObjectMonitorWaitWorker(String name, SuspendWithObjectMonitorWaitWorker target) {\n+         super(name);\n+         this.target = target;\n++        this.waitTimeout = 0;\n+     }\n+ \n+     native static int resumeThread(SuspendWithObjectMonitorWaitWorker thr);\n+@@ -311,7 +587,7 @@ public void run() {\n+                 \/\/ waiter thread out of this threadLock.wait(0) call:\n+                 while (SuspendWithObjectMonitorWait.testState <= SuspendWithObjectMonitorWait.TS_READY_TO_NOTIFY) {\n+                     try {\n+-                        SuspendWithObjectMonitorWait.threadLock.wait(0);\n++                        SuspendWithObjectMonitorWait.threadLock.wait(waitTimeout);\n+                     } catch (InterruptedException ex) {\n+                     }\n+                 }\n","filename":"patch.txt","additions":566,"deletions":0,"binary":false,"changes":566,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n@@ -131,1 +131,1 @@\n-  JfrSpinlockHelper mutex(&_lock);\n+  SpinCriticalSection scs(&_lock);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n@@ -345,1 +345,1 @@\n-  JfrSpinlockHelper mutex(&_lock);\n+  SpinCriticalSection scs(&_lock);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAdaptiveSampler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_JFR_UTILITIES_JFRSPINLOCKHELPER_HPP\n-#define SHARE_JFR_UTILITIES_JFRSPINLOCKHELPER_HPP\n-\n-#include \"runtime\/javaThread.hpp\"\n-\n-class JfrSpinlockHelper {\n- private:\n-  volatile int* const _lock;\n-\n- public:\n-  JfrSpinlockHelper(volatile int* lock) : _lock(lock) {\n-    Thread::SpinAcquire(_lock);\n-  }\n-\n-  ~JfrSpinlockHelper() {\n-    Thread::SpinRelease(_lock);\n-  }\n-};\n-\n-#endif \/\/ SHARE_JFR_UTILITIES_JFRSPINLOCKHELPER_HPP\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSpinlockHelper.hpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n@@ -319,1 +320,1 @@\n-    if (AtomicAccess::cmpxchg(&_object_strong_lock, 0, 1) == 0) {\n+    auto setObjectStrongLambda = [&](OopHandle& object_strong, const WeakHandle& object) {\n@@ -322,1 +323,1 @@\n-        _object_strong = OopHandle(JavaThread::thread_oop_storage(), _object.resolve());\n+        object_strong = OopHandle(JavaThread::thread_oop_storage(), _object.resolve());\n@@ -324,2 +325,2 @@\n-      AtomicAccess::release_store(&_object_strong_lock, 0);\n-    }\n+    };\n+    SpinSingleSection<decltype(setObjectStrongLambda), OopHandle, WeakHandle> sss(&_object_strong_lock, setObjectStrongLambda, _object_strong, _object);\n@@ -1866,3 +1867,4 @@\n-  Thread::SpinAcquire(&_wait_set_lock);\n-  add_waiter(&node);\n-  Thread::SpinRelease(&_wait_set_lock);\n+  {\n+    SpinCriticalSection scs(&_wait_set_lock);\n+    add_waiter(&node);\n+  }\n@@ -1925,1 +1927,1 @@\n-      Thread::SpinAcquire(&_wait_set_lock);\n+      SpinCriticalSection scs(&_wait_set_lock);\n@@ -1930,1 +1932,0 @@\n-      Thread::SpinRelease(&_wait_set_lock);\n@@ -2039,16 +2040,17 @@\n-  Thread::SpinAcquire(&_wait_set_lock);\n-  ObjectWaiter* iterator = dequeue_waiter();\n-  if (iterator != nullptr) {\n-    guarantee(iterator->TState == ObjectWaiter::TS_WAIT, \"invariant\");\n-\n-    if (iterator->is_vthread()) {\n-      oop vthread = iterator->vthread();\n-      java_lang_VirtualThread::set_notified(vthread, true);\n-      int old_state = java_lang_VirtualThread::state(vthread);\n-      \/\/ If state is not WAIT\/TIMED_WAIT then target could still be on\n-      \/\/ unmount transition, or wait could have already timed-out or target\n-      \/\/ could have been interrupted. In the first case, the target itself\n-      \/\/ will set the state to BLOCKED at the end of the unmount transition.\n-      \/\/ In the other cases the target would have been already unblocked so\n-      \/\/ there is nothing to do.\n-      if (old_state == java_lang_VirtualThread::WAIT ||\n+  {\n+    SpinCriticalSection scs(&_wait_set_lock);\n+    ObjectWaiter* iterator = dequeue_waiter();\n+    if (iterator != nullptr) {\n+      guarantee(iterator->TState == ObjectWaiter::TS_WAIT, \"invariant\");\n+\n+      if (iterator->is_vthread()) {\n+        oop vthread = iterator->vthread();\n+        java_lang_VirtualThread::set_notified(vthread, true);\n+        int old_state = java_lang_VirtualThread::state(vthread);\n+        \/\/ If state is not WAIT\/TIMED_WAIT then target could still be on\n+        \/\/ unmount transition, or wait could have already timed-out or target\n+        \/\/ could have been interrupted. In the first case, the target itself\n+        \/\/ will set the state to BLOCKED at the end of the unmount transition.\n+        \/\/ In the other cases the target would have been already unblocked so\n+        \/\/ there is nothing to do.\n+        if (old_state == java_lang_VirtualThread::WAIT ||\n@@ -2056,1 +2058,6 @@\n-        java_lang_VirtualThread::cmpxchg_state(vthread, old_state, java_lang_VirtualThread::BLOCKED);\n+          java_lang_VirtualThread::cmpxchg_state(vthread, old_state, java_lang_VirtualThread::BLOCKED);\n+        }\n+        \/\/ Increment counter *before* adding the vthread to the _entry_list.\n+        \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+        \/\/ a fence that prevents reordering of the stores.\n+        inc_unmounted_vthreads();\n@@ -2058,5 +2065,0 @@\n-      \/\/ Increment counter *before* adding the vthread to the _entry_list.\n-      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n-      \/\/ a fence that prevents reordering of the stores.\n-      inc_unmounted_vthreads();\n-    }\n@@ -2064,31 +2066,32 @@\n-    iterator->_notifier_tid = JFR_THREAD_ID(current);\n-    did_notify = true;\n-    add_to_entry_list(current, iterator);\n-\n-    \/\/ _wait_set_lock protects the wait queue, not the entry_list.  We could\n-    \/\/ move the add-to-entry_list operation, above, outside the critical section\n-    \/\/ protected by _wait_set_lock.  In practice that's not useful.  With the\n-    \/\/ exception of  wait() timeouts and interrupts the monitor owner\n-    \/\/ is the only thread that grabs _wait_set_lock.  There's almost no contention\n-    \/\/ on _wait_set_lock so it's not profitable to reduce the length of the\n-    \/\/ critical section.\n-\n-    if (!iterator->is_vthread()) {\n-      iterator->wait_reenter_begin(this);\n-\n-      \/\/ Read counter *after* adding the thread to the _entry_list.\n-      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n-      \/\/ a fence that prevents this load from floating up previous store.\n-      if (has_unmounted_vthreads()) {\n-        \/\/ Wake up the thread to alleviate some deadlock cases where the successor\n-        \/\/ that will be picked up when this thread releases the monitor is an unmounted\n-        \/\/ virtual thread that cannot run due to having run out of carriers. Upon waking\n-        \/\/ up, the thread will call reenter_internal() which will use timed-park in case\n-        \/\/ there is contention and there are still vthreads in the _entry_list.\n-        \/\/ If the target was interrupted or the wait timed-out at the same time, it could\n-        \/\/ have reached reenter_internal and read a false value of has_unmounted_vthreads()\n-        \/\/ before we added it to the _entry_list above. To deal with that case, we set _do_timed_park\n-        \/\/ which will be read by the target on the next loop iteration in reenter_internal.\n-        iterator->_do_timed_park = true;\n-        JavaThread* t = iterator->thread();\n-        t->_ParkEvent->unpark();\n+      iterator->_notifier_tid = JFR_THREAD_ID(current);\n+      did_notify = true;\n+      add_to_entry_list(current, iterator);\n+\n+      \/\/ _wait_set_lock protects the wait queue, not the entry_list.  We could\n+      \/\/ move the add-to-entry_list operation, above, outside the critical section\n+      \/\/ protected by _wait_set_lock.  In practice that's not useful.  With the\n+      \/\/ exception of  wait() timeouts and interrupts the monitor owner\n+      \/\/ is the only thread that grabs _wait_set_lock.  There's almost no contention\n+      \/\/ on _wait_set_lock so it's not profitable to reduce the length of the\n+      \/\/ critical section.\n+\n+      if (!iterator->is_vthread()) {\n+        iterator->wait_reenter_begin(this);\n+\n+        \/\/ Read counter *after* adding the thread to the _entry_list.\n+        \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+        \/\/ a fence that prevents this load from floating up previous store.\n+        if (has_unmounted_vthreads()) {\n+          \/\/ Wake up the thread to alleviate some deadlock cases where the successor\n+          \/\/ that will be picked up when this thread releases the monitor is an unmounted\n+          \/\/ virtual thread that cannot run due to having run out of carriers. Upon waking\n+          \/\/ up, the thread will call reenter_internal() which will use timed-park in case\n+          \/\/ there is contention and there are still vthreads in the _entry_list.\n+          \/\/ If the target was interrupted or the wait timed-out at the same time, it could\n+          \/\/ have reached reenter_internal and read a false value of has_unmounted_vthreads()\n+          \/\/ before we added it to the _entry_list above. To deal with that case, we set _do_timed_park\n+          \/\/ which will be read by the target on the next loop iteration in reenter_internal.\n+          iterator->_do_timed_park = true;\n+          JavaThread* t = iterator->thread();\n+          t->_ParkEvent->unpark();\n+        }\n@@ -2098,1 +2101,0 @@\n-  Thread::SpinRelease(&_wait_set_lock);\n@@ -2201,3 +2203,4 @@\n-  Thread::SpinAcquire(&_wait_set_lock);\n-  add_waiter(node);\n-  Thread::SpinRelease(&_wait_set_lock);\n+  {\n+    SpinCriticalSection scs(&_wait_set_lock);\n+    add_waiter(node);\n+  }\n@@ -2224,1 +2227,1 @@\n-    Thread::SpinAcquire(&_wait_set_lock);\n+    SpinCriticalSection scs(&_wait_set_lock);\n@@ -2229,1 +2232,0 @@\n-    Thread::SpinRelease(&_wait_set_lock);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":70,"deletions":68,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n@@ -63,1 +64,0 @@\n-  Thread::SpinAcquire(&ListLock);\n@@ -65,3 +65,6 @@\n-    ev = FreeList;\n-    if (ev != nullptr) {\n-      FreeList = ev->FreeNext;\n+    SpinCriticalSection scs(&ListLock);\n+    {\n+      ev = FreeList;\n+      if (ev != nullptr) {\n+        FreeList = ev->FreeNext;\n+      }\n@@ -70,1 +73,0 @@\n-  Thread::SpinRelease(&ListLock);\n@@ -91,1 +93,0 @@\n-  Thread::SpinAcquire(&ListLock);\n@@ -93,0 +94,1 @@\n+    SpinCriticalSection scs(&ListLock);\n@@ -96,1 +98,0 @@\n-  Thread::SpinRelease(&ListLock);\n","filename":"src\/hotspot\/share\/runtime\/park.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -569,46 +569,0 @@\n-\n-\/\/ Ad-hoc mutual exclusion primitive: spin lock\n-\/\/\n-\/\/ We employ a spin lock _only for low-contention, fixed-length\n-\/\/ short-duration critical sections where we're concerned\n-\/\/ about native mutex_t or HotSpot Mutex:: latency.\n-\n-void Thread::SpinAcquire(volatile int * adr) {\n-  if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) {\n-    return;   \/\/ normal fast-path return\n-  }\n-\n-  \/\/ Slow-path : We've encountered contention -- Spin\/Yield\/Block strategy.\n-  int ctr = 0;\n-  int Yields = 0;\n-  for (;;) {\n-    while (*adr != 0) {\n-      ++ctr;\n-      if ((ctr & 0xFFF) == 0 || !os::is_MP()) {\n-        if (Yields > 5) {\n-          os::naked_short_sleep(1);\n-        } else {\n-          os::naked_yield();\n-          ++Yields;\n-        }\n-      } else {\n-        SpinPause();\n-      }\n-    }\n-    if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) return;\n-  }\n-}\n-\n-void Thread::SpinRelease(volatile int * adr) {\n-  assert(*adr != 0, \"invariant\");\n-  \/\/ Roach-motel semantics.\n-  \/\/ It's safe if subsequent LDs and STs float \"up\" into the critical section,\n-  \/\/ but prior LDs and STs within the critical section can't be allowed\n-  \/\/ to reorder or float past the ST that releases the lock.\n-  \/\/ Loads and stores in the critical section - which appear in program\n-  \/\/ order before the store that releases the lock - must also appear\n-  \/\/ before the store that releases the lock in memory visibility order.\n-  \/\/ So we need a #loadstore|#storestore \"release\" memory barrier before\n-  \/\/ the ST of 0 into the lock-word which releases the lock.\n-  AtomicAccess::release_store(adr, 0);\n-}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -605,5 +605,0 @@\n-  \/\/ Low-level leaf-lock primitives used to implement synchronization.\n-  \/\/ Not for general synchronization use.\n-  static void SpinAcquire(volatile int * Lock);\n-  static void SpinRelease(volatile int * Lock);\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/atomicAccess.hpp\"\n+#include \"utilities\/spinCriticalSection.hpp\"\n+\n+ \/\/ Ad-hoc mutual exclusion primitive: spin lock\n+ \/\/\n+ \/\/ We employ a spin lock _only for low-contention, fixed-length\n+ \/\/ short-duration critical sections where we're concerned\n+ \/\/ about native mutex_t or HotSpot Mutex:: latency.\n+void SpinCriticalSectionHelper::spin_acquire(volatile int* adr) {\n+  if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) {\n+    return;   \/\/ normal fast-path return\n+  }\n+\n+  \/\/ Slow-path : We've encountered contention -- Spin\/Yield\/Block strategy.\n+  int ctr = 0;\n+  int yields = 0;\n+  for (;;) {\n+    while (*adr != 0) {\n+      ++ctr;\n+      if ((ctr & 0xFFF) == 0 || !os::is_MP()) {\n+        if (yields > 5) {\n+          os::naked_short_sleep(1);\n+        }\n+        else {\n+          os::naked_yield();\n+          ++yields;\n+        }\n+      }\n+      else {\n+        SpinPause();\n+      }\n+    }\n+    if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) return;\n+  }\n+}\n+\n+void SpinCriticalSectionHelper::spin_release(volatile int* adr) {\n+  assert(*adr != 0, \"invariant\");\n+  \/\/ Roach-motel semantics.\n+  \/\/ It's safe if subsequent LDs and STs float \"up\" into the critical section,\n+  \/\/ but prior LDs and STs within the critical section can't be allowed\n+  \/\/ to reorder or float past the ST that releases the lock.\n+  \/\/ Loads and stores in the critical section - which appear in program\n+  \/\/ order before the store that releases the lock - must also appear\n+  \/\/ before the store that releases the lock in memory visibility order.\n+  \/\/ So we need a #loadstore|#storestore \"release\" memory barrier before\n+  \/\/ the ST of 0 into the lock-word which releases the lock.\n+  AtomicAccess::release_store(adr, 0);\n+}\n+\n+bool SpinCriticalSectionHelper::try_spin_acquire(volatile int* adr) {\n+  if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/spinCriticalSection.cpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_SPINCRITICALSECTION_HPP\n+#define SHARE_UTILITIES_SPINCRITICALSECTION_HPP\n+\n+#include \"runtime\/javaThread.hpp\"\n+\n+class SpinCriticalSectionHelper {\n+  friend class SpinCriticalSection;\n+  template<class Lambda, class...Args>\n+  friend class SpinSingleSection;\n+  \/\/ Low-level leaf-lock primitives used to implement synchronization.\n+  \/\/ Not for general synchronization use.\n+  static void spin_acquire(volatile int* Lock);\n+  static void spin_release(volatile int* Lock);\n+  static bool try_spin_acquire(volatile int* Lock);\n+};\n+\n+\/\/ Short critical section. To be used when having a\n+\/\/ mutex is considered to be expensive.\n+class SpinCriticalSection {\n+private:\n+  volatile int* const _lock;\n+public:\n+  SpinCriticalSection(volatile int* lock) : _lock(lock) {\n+    SpinCriticalSectionHelper::spin_acquire(_lock);\n+  }\n+  ~SpinCriticalSection() {\n+    SpinCriticalSectionHelper::spin_release(_lock);\n+  }\n+};\n+\n+template<class Lambda, class...Args>\n+class SpinSingleSection {\n+private:\n+  volatile int* const _lock;\n+  Thread* _lock_owner;\n+public:\n+  SpinSingleSection(volatile int* lock, Lambda& F, Args&... args) : _lock(lock), _lock_owner(nullptr) {\n+    if (SpinCriticalSectionHelper::try_spin_acquire(_lock)) {\n+      _lock_owner = Thread::current();\n+      F(args...);\n+    }\n+  }\n+  ~SpinSingleSection() {\n+    \/\/ It is safe to not have any atomic operations here,\n+    \/\/ as a thread either sees a nullptr or a pointer to a thread which\n+    \/\/ succeeded in locking the lock. Comparison will fail in both\n+    \/\/ cases if it is not a succeeded thread.\n+    if (_lock_owner == Thread::current()) {\n+      SpinCriticalSectionHelper::spin_release(_lock);\n+    }\n+  }\n+};\n+#endif \/\/SHARE_UTILITIES_SPINCRITICALSECTION_HPP\n","filename":"src\/hotspot\/share\/utilities\/spinCriticalSection.hpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n","filename":"test\/hotspot\/gtest\/jfr\/test_adaptiveSampler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}