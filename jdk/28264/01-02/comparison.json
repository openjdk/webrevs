{"files":[{"patch":"@@ -0,0 +1,566 @@\n+diff --git a\/src\/hotspot\/share\/runtime\/objectMonitor.cpp b\/src\/hotspot\/share\/runtime\/objectMonitor.cpp\n+index ee7629ec6f5..b1c806308ff 100644\n+--- a\/src\/hotspot\/share\/runtime\/objectMonitor.cpp\n++++ b\/src\/hotspot\/share\/runtime\/objectMonitor.cpp\n+@@ -338,15 +338,6 @@ void ObjectMonitor::ExitOnSuspend::operator()(JavaThread* current) {\n+   }\n+ }\n+ \n+-void ObjectMonitor::ClearSuccOnSuspend::operator()(JavaThread* current) {\n+-  if (current->is_suspended()) {\n+-    if (_om->has_successor(current)) {\n+-      _om->clear_successor();\n+-      OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n+-    }\n+-  }\n+-}\n+-\n+ #define assert_mark_word_consistency()                                         \\\n+   assert(UseObjectMonitorTable || object()->mark() == markWord::encode(this),  \\\n+          \"object mark must match encoded this: mark=\" INTPTR_FORMAT            \\\n+@@ -499,7 +490,7 @@ bool ObjectMonitor::spin_enter(JavaThread* current) {\n+   return false;\n+ }\n+ \n+-bool ObjectMonitor::enter(JavaThread* current) {\n++bool ObjectMonitor::enter(JavaThread* current, bool post_jvmti_events) {\n+   assert(current == JavaThread::current(), \"must be\");\n+ \n+   if (spin_enter(current)) {\n+@@ -520,7 +511,7 @@ bool ObjectMonitor::enter(JavaThread* current) {\n+   }\n+ \n+   \/\/ At this point this ObjectMonitor cannot be deflated, finish contended enter\n+-  enter_with_contention_mark(current, contention_mark);\n++  enter_with_contention_mark(current, contention_mark, post_jvmti_events);\n+   return true;\n+ }\n+ \n+@@ -539,7 +530,7 @@ void ObjectMonitor::notify_contended_enter(JavaThread* current) {\n+   }\n+ }\n+ \n+-void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm) {\n++void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm, bool post_jvmti_events) {\n+   assert(current == JavaThread::current(), \"must be\");\n+   assert(!has_owner(current), \"must be\");\n+   assert(cm._monitor == this, \"must be\");\n+@@ -643,7 +634,7 @@ void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonito\n+   \/\/ spinning we could increment JVMStat counters, etc.\n+ \n+   DTRACE_MONITOR_PROBE(contended__entered, this, object(), current);\n+-  if (JvmtiExport::should_post_monitor_contended_entered()) {\n++  if (post_jvmti_events && JvmtiExport::should_post_monitor_contended_entered()) {\n+     JvmtiExport::post_monitor_contended_entered(current, this);\n+ \n+     \/\/ The current thread already owns the monitor and is not going to\n+@@ -1101,11 +1092,10 @@ void ObjectMonitor::enter_internal(JavaThread* current) {\n+ \n+ void ObjectMonitor::reenter_internal(JavaThread* current, ObjectWaiter* currentNode) {\n+   assert(current != nullptr, \"invariant\");\n+-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n++  assert(current->thread_state() == _thread_blocked, \"invariant\");\n+   assert(currentNode != nullptr, \"invariant\");\n+   assert(currentNode->_thread == current, \"invariant\");\n+   assert(_waiters > 0, \"invariant\");\n+-  assert_mark_word_consistency();\n+ \n+   \/\/ If there are unmounted virtual threads ahead in the _entry_list we want\n+   \/\/ to do a timed-park instead to alleviate some deadlock cases where one\n+@@ -1141,22 +1131,15 @@ void ObjectMonitor::reenter_internal(JavaThread* current, ObjectWaiter* currentN\n+ \n+     {\n+       OSThreadContendState osts(current->osthread());\n+-\n+-      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n+-\n+-      {\n+-        ClearSuccOnSuspend csos(this);\n+-        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n+-        if (do_timed_parked) {\n+-          current->_ParkEvent->park(recheck_interval);\n+-          \/\/ Increase the recheck_interval, but clamp the value.\n+-          recheck_interval *= 8;\n+-          if (recheck_interval > MAX_RECHECK_INTERVAL) {\n+-            recheck_interval = MAX_RECHECK_INTERVAL;\n+-          }\n+-        } else {\n+-          current->_ParkEvent->park();\n++      if (do_timed_parked) {\n++        current->_ParkEvent->park(recheck_interval);\n++        \/\/ Increase the recheck_interval, but clamp the value.\n++        recheck_interval *= 8;\n++        if (recheck_interval > MAX_RECHECK_INTERVAL) {\n++          recheck_interval = MAX_RECHECK_INTERVAL;\n+         }\n++      } else {\n++        current->_ParkEvent->park();\n+       }\n+     }\n+ \n+@@ -1183,7 +1166,6 @@ void ObjectMonitor::reenter_internal(JavaThread* current, ObjectWaiter* currentN\n+ \n+   \/\/ Current has acquired the lock -- Unlink current from the _entry_list.\n+   assert(has_owner(current), \"invariant\");\n+-  assert_mark_word_consistency();\n+   unlink_after_acquire(current, currentNode);\n+   if (has_successor(current)) clear_successor();\n+   assert(!has_successor(current), \"invariant\");\n+@@ -1893,8 +1875,7 @@ void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {\n+     assert(current->thread_state() == _thread_in_vm, \"invariant\");\n+ \n+     {\n+-      ClearSuccOnSuspend csos(this);\n+-      ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n++      ThreadBlockInVM tbivm(current, false \/* allow_suspend *\/);\n+       if (interrupted || HAS_PENDING_EXCEPTION) {\n+         \/\/ Intentionally empty\n+       } else if (node.TState == ObjectWaiter::TS_WAIT) {\n+@@ -1946,6 +1927,41 @@ void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {\n+     \/\/ although the raw address of the object may have changed.\n+     \/\/ (Don't cache naked oops over safepoints, of course).\n+ \n++    OrderAccess::fence();\n++\n++    assert(!has_owner(current), \"invariant\");\n++    ObjectWaiter::TStates v = node.TState;\n++    if (v == ObjectWaiter::TS_RUN) {\n++      \/\/ We use the NoPreemptMark for the very rare case where the previous\n++      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n++      \/\/ could succeed but we can't unmount now.\n++      NoPreemptMark npm(current);\n++      enter(current);\n++    } else {\n++      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n++      ExitOnSuspend eos(this);\n++      {\n++        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos, true \/* allow_suspend *\/);\n++        reenter_internal(current, &node);\n++        \/\/ We can go to a safepoint at the end of this block. If we\n++        \/\/ do a thread dump during that safepoint, then this thread will show\n++        \/\/ as having \"-locked\" the monitor, but the OS and java.lang.Thread\n++        \/\/ states will still report that the thread is blocked trying to\n++        \/\/ acquire it.\n++        \/\/ If there is a suspend request, ExitOnSuspend will exit the OM\n++        \/\/ and set the OM as pending.\n++      }\n++      if (eos.exited()) {\n++        \/\/ ExitOnSuspend exit the OM\n++        assert(!has_owner(current), \"invariant\");\n++        guarantee(node.TState == ObjectWaiter::TS_RUN, \"invariant\");\n++        current->set_current_pending_monitor(nullptr);\n++        enter(current, false \/* post_jvmti_events *\/);\n++      }\n++      assert(has_owner(current), \"invariant\");\n++      node.wait_reenter_end(this);\n++    }\n++\n+     \/\/ post monitor waited event. Note that this is past-tense, we are done waiting.\n+     if (JvmtiExport::should_post_monitor_waited()) {\n+       JvmtiExport::post_monitor_waited(current, this, ret == OS_TIMEOUT);\n+@@ -1974,22 +1990,6 @@ void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {\n+       post_monitor_wait_event(&wait_event, this, node._notifier_tid, millis, ret == OS_TIMEOUT);\n+     }\n+ \n+-    OrderAccess::fence();\n+-\n+-    assert(!has_owner(current), \"invariant\");\n+-    ObjectWaiter::TStates v = node.TState;\n+-    if (v == ObjectWaiter::TS_RUN) {\n+-      \/\/ We use the NoPreemptMark for the very rare case where the previous\n+-      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n+-      \/\/ could succeed but we can't unmount now.\n+-      NoPreemptMark npm(current);\n+-      enter(current);\n+-    } else {\n+-      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n+-      reenter_internal(current, &node);\n+-      node.wait_reenter_end(this);\n+-    }\n+-\n+     \/\/ current has reacquired the lock.\n+     \/\/ Lifecycle - the node representing current must not appear on any queues.\n+     \/\/ Node is about to go out-of-scope, but even if it were immortal we wouldn't\n+diff --git a\/src\/hotspot\/share\/runtime\/objectMonitor.hpp b\/src\/hotspot\/share\/runtime\/objectMonitor.hpp\n+index 53b64f1e8a5..d9ade27eecd 100644\n+--- a\/src\/hotspot\/share\/runtime\/objectMonitor.hpp\n++++ b\/src\/hotspot\/share\/runtime\/objectMonitor.hpp\n+@@ -362,23 +362,16 @@ class ObjectMonitor : public CHeapObj<mtObjectMonitor> {\n+     void operator()(JavaThread* current);\n+     bool exited() { return _om_exited; }\n+   };\n+-  class ClearSuccOnSuspend {\n+-   protected:\n+-    ObjectMonitor* _om;\n+-   public:\n+-    ClearSuccOnSuspend(ObjectMonitor* om) : _om(om)  {}\n+-    void operator()(JavaThread* current);\n+-  };\n+ \n+   bool      enter_is_async_deflating();\n+   void      notify_contended_enter(JavaThread *current);\n+  public:\n+   void      enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n+   bool      enter_for(JavaThread* locking_thread);\n+-  bool      enter(JavaThread* current);\n++  bool      enter(JavaThread* current, bool post_jvmti_events = true);\n+   bool      try_enter(JavaThread* current, bool check_for_recursion = true);\n+   bool      spin_enter(JavaThread* current);\n+-  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n++  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark, bool post_jvmti_events = true);\n+   void      exit(JavaThread* current, bool not_suspended = true);\n+   bool      resume_operation(JavaThread* current, ObjectWaiter* node, ContinuationWrapper& cont);\n+   void      wait(jlong millis, bool interruptible, TRAPS);\n+diff --git a\/test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java b\/test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java\n+index 3a747a3e86b..12a84b1a3d2 100644\n+--- a\/test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java\n++++ b\/test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java\n+@@ -28,7 +28,27 @@\n+  * @requires vm.jvmti\n+  * @library \/test\/lib\n+  * @compile SuspendWithObjectMonitorWait.java\n+- * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait\n++ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 1\n++ *\/\n++\n++\/*\n++ * @test\n++ * @bug 4413752 8262881\n++ * @summary Test SuspendThread with ObjectMonitor wait.\n++ * @requires vm.jvmti\n++ * @library \/test\/lib\n++ * @compile SuspendWithObjectMonitorWait.java\n++ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 2\n++ *\/\n++\n++\/*\n++ * @test\n++ * @bug 4413752 8262881\n++ * @summary Test SuspendThread with ObjectMonitor wait.\n++ * @requires vm.jvmti\n++ * @library \/test\/lib\n++ * @compile SuspendWithObjectMonitorWait.java\n++ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 3\n+  *\/\n+ \n+ import java.io.PrintStream;\n+@@ -87,6 +107,7 @@ public class SuspendWithObjectMonitorWait {\n+     native static int wait4ContendedEnter(SuspendWithObjectMonitorWaitWorker thr);\n+ \n+     public static void main(String[] args) throws Exception {\n++        int test = Integer.parseInt(args[0]);\n+         try {\n+             System.loadLibrary(AGENT_LIB);\n+             log(\"Loaded library: \" + AGENT_LIB);\n+@@ -122,7 +143,7 @@ public static void main(String[] args) throws Exception {\n+             }\n+         }\n+ \n+-        System.exit(run(timeMax, System.out) + exit_delta);\n++        System.exit(run(timeMax, System.out, test) + exit_delta);\n+     }\n+ \n+     public static void logDebug(String mesg) {\n+@@ -141,8 +162,14 @@ public static void usage() {\n+         System.exit(1);\n+     }\n+ \n+-    public static int run(int timeMax, PrintStream out) {\n+-        return (new SuspendWithObjectMonitorWait()).doWork(timeMax, out);\n++    public static int run(int timeMax, PrintStream out, int test) {\n++        switch (test) {\n++            case 1: return (new SuspendWithObjectMonitorWait()).doWork1(timeMax, out);\n++            case 2: return (new SuspendWithObjectMonitorWait()).doWork2(timeMax, out);\n++            case 3: return (new SuspendWithObjectMonitorWait()).doWork3(timeMax, out);\n++            default: throw new RuntimeException(\"Unknown test\");\n++        }\n++\n+     }\n+ \n+     public static void checkTestState(int exp) {\n+@@ -153,7 +180,8 @@ public static void checkTestState(int exp) {\n+         }\n+     }\n+ \n+-    public int doWork(int timeMax, PrintStream out) {\n++    \/\/ Default scenario, the resumer thread is always able to grab the threadLock once notified by the main thread.\n++    public int doWork1(int timeMax, PrintStream out) {\n+         SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+         SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n+ \n+@@ -265,18 +293,266 @@ public int doWork(int timeMax, PrintStream out) {\n+ \n+         return 0;\n+     }\n++\n++    \/\/ Notify the resumer while holding the threadLock\n++    public int doWork2(int timeMax, PrintStream out) {\n++        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n++        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n++\n++        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n++\n++        long start_time = System.currentTimeMillis();\n++        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n++            count++;\n++            testState = TS_INIT;  \/\/ starting the test loop\n++\n++            \/\/ launch the waiter thread\n++            synchronized (barrierLaunch) {\n++                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n++                waiter.start();\n++\n++                while (testState != TS_WAITER_RUNNING) {\n++                    try {\n++                        barrierLaunch.wait(0);  \/\/ wait until it is running\n++                    } catch (InterruptedException ex) {\n++                    }\n++                }\n++            }\n++\n++            \/\/ launch the resumer thread\n++            synchronized (barrierLaunch) {\n++                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n++                resumer.start();\n++\n++                while (testState != TS_RESUMER_RUNNING) {\n++                    try {\n++                        barrierLaunch.wait(0);  \/\/ wait until it is running\n++                    } catch (InterruptedException ex) {\n++                    }\n++                }\n++            }\n++\n++            checkTestState(TS_RESUMER_RUNNING);\n++\n++            \/\/ The waiter thread was synchronized on threadLock before it\n++            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n++            \/\/ we cannot enter threadLock until the waiter thread calls\n++            \/\/ threadLock.wait().\n++            synchronized (threadLock) {\n++                \/\/ notify waiter thread so it can try to reenter threadLock\n++                testState = TS_READY_TO_NOTIFY;\n++                threadLock.notify();\n++\n++                \/\/ wait for the waiter thread to block\n++                logDebug(\"before contended enter wait\");\n++                int retCode = wait4ContendedEnter(waiter);\n++                if (retCode != 0) {\n++                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n++                                                + \"retCode=\" + retCode);\n++                }\n++                logDebug(\"done contended enter wait\");\n++\n++                checkTestState(TS_READY_TO_NOTIFY);\n++                testState = TS_CALL_SUSPEND;\n++                logDebug(\"before suspend thread\");\n++                retCode = suspendThread(waiter);\n++                if (retCode != 0) {\n++                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n++                                                + \"retCode=\" + retCode);\n++                }\n++                logDebug(\"suspended thread\");\n++\n++                \/\/\n++                \/\/ At this point, all of the child threads are running\n++                \/\/ and we can get to meat of the test:\n++                \/\/\n++                \/\/ - suspended threadLock waiter (trying to reenter)\n++                \/\/ - a threadLock enter in the resumer thread\n++                \/\/ - resumption of the waiter thread\n++                \/\/ - a threadLock enter in the freshly resumed waiter thread\n++                \/\/\n++\n++                synchronized (barrierResumer) {\n++                    checkTestState(TS_CALL_SUSPEND);\n++\n++                    \/\/ tell resumer thread to resume waiter thread\n++                    testState = TS_READY_TO_RESUME;\n++                    barrierResumer.notify();\n++\n++                    \/\/ Can't call checkTestState() here because the\n++                    \/\/ resumer thread may have already resumed the\n++                    \/\/ waiter thread.\n++                }\n++                try {\n++                    Thread.sleep(1000);\n++                } catch(Exception e) {}\n++            }\n++\n++            try {\n++                resumer.join(JOIN_MAX * 1000);\n++                if (resumer.isAlive()) {\n++                    System.err.println(\"Failure at \" + count + \" loops.\");\n++                    throw new InternalError(\"resumer thread is stuck\");\n++                }\n++                waiter.join(JOIN_MAX * 1000);\n++                if (waiter.isAlive()) {\n++                    System.err.println(\"Failure at \" + count + \" loops.\");\n++                    throw new InternalError(\"waiter thread is stuck\");\n++                }\n++            } catch (InterruptedException ex) {\n++            }\n++\n++            checkTestState(TS_WAITER_DONE);\n++        }\n++\n++        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n++                \" seconds.\");\n++\n++        return 0;\n++    }\n++\n++    \/\/ Suspend on the re-entry path of wait.\n++    public int doWork3(int timeMax, PrintStream out) {\n++        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n++        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n++\n++        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n++\n++        long start_time = System.currentTimeMillis();\n++        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n++            count++;\n++            testState = TS_INIT;  \/\/ starting the test loop\n++\n++            \/\/ launch the waiter thread\n++            synchronized (barrierLaunch) {\n++                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\", 1);\n++                waiter.start();\n++\n++                while (testState != TS_WAITER_RUNNING) {\n++                    try {\n++                        barrierLaunch.wait(0);  \/\/ wait until it is running\n++                    } catch (InterruptedException ex) {\n++                    }\n++                }\n++            }\n++\n++            \/\/ launch the resumer thread\n++            synchronized (barrierLaunch) {\n++                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n++                resumer.start();\n++\n++                while (testState != TS_RESUMER_RUNNING) {\n++                    try {\n++                        barrierLaunch.wait(0);  \/\/ wait until it is running\n++                    } catch (InterruptedException ex) {\n++                    }\n++                }\n++            }\n++\n++            try {\n++                Thread.sleep(1000);\n++            } catch(Exception e) {}\n++\n++            checkTestState(TS_RESUMER_RUNNING);\n++\n++            \/\/ The waiter thread was synchronized on threadLock before it\n++            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n++            \/\/ we cannot enter threadLock until the waiter thread calls\n++            \/\/ threadLock.wait().\n++            synchronized (threadLock) {\n++                \/\/ notify waiter thread so it can try to reenter threadLock\n++                testState = TS_READY_TO_NOTIFY;\n++                threadLock.notify();\n++\n++                \/\/ wait for the waiter thread to block\n++                logDebug(\"before contended enter wait\");\n++                int retCode = wait4ContendedEnter(waiter);\n++                if (retCode != 0) {\n++                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n++                                                 + \"retCode=\" + retCode);\n++                }\n++                logDebug(\"done contended enter wait\");\n++\n++                checkTestState(TS_READY_TO_NOTIFY);\n++                testState = TS_CALL_SUSPEND;\n++                logDebug(\"before suspend thread\");\n++                retCode = suspendThread(waiter);\n++                if (retCode != 0) {\n++                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n++                                                + \"retCode=\" + retCode);\n++                }\n++                logDebug(\"suspended thread\");\n++\n++                \/\/\n++                \/\/ At this point, all of the child threads are running\n++                \/\/ and we can get to meat of the test:\n++                \/\/\n++                \/\/ - suspended threadLock waiter (trying to reenter)\n++                \/\/ - a threadLock enter in the resumer thread\n++                \/\/ - resumption of the waiter thread\n++                \/\/ - a threadLock enter in the freshly resumed waiter thread\n++                \/\/\n++\n++                synchronized (barrierResumer) {\n++                    checkTestState(TS_CALL_SUSPEND);\n++\n++                    \/\/ tell resumer thread to resume waiter thread\n++                    testState = TS_READY_TO_RESUME;\n++                    barrierResumer.notify();\n++\n++                    \/\/ Can't call checkTestState() here because the\n++                    \/\/ resumer thread may have already resumed the\n++                    \/\/ waiter thread.\n++                }\n++                try {\n++                    Thread.sleep(1000);\n++                } catch(Exception e) {}\n++            }\n++\n++            try {\n++                resumer.join(JOIN_MAX * 1000);\n++                if (resumer.isAlive()) {\n++                    System.err.println(\"Failure at \" + count + \" loops.\");\n++                    throw new InternalError(\"resumer thread is stuck\");\n++                }\n++                waiter.join(JOIN_MAX * 1000);\n++                if (waiter.isAlive()) {\n++                    System.err.println(\"Failure at \" + count + \" loops.\");\n++                    throw new InternalError(\"waiter thread is stuck\");\n++                }\n++            } catch (InterruptedException ex) {\n++            }\n++\n++            checkTestState(TS_WAITER_DONE);\n++        }\n++\n++        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n++                \" seconds.\");\n++\n++        return 0;\n++    }\n+ }\n+ \n++\n++\n+ class SuspendWithObjectMonitorWaitWorker extends Thread {\n+     private SuspendWithObjectMonitorWaitWorker target;  \/\/ target for resume operation\n++    private final long waitTimeout;\n+ \n+     public SuspendWithObjectMonitorWaitWorker(String name) {\n+         super(name);\n++        this.waitTimeout = 0;\n++    }\n++\n++    public SuspendWithObjectMonitorWaitWorker(String name, long waitTimeout) {\n++        super(name);\n++        this.waitTimeout = waitTimeout;\n+     }\n+ \n+     public SuspendWithObjectMonitorWaitWorker(String name, SuspendWithObjectMonitorWaitWorker target) {\n+         super(name);\n+         this.target = target;\n++        this.waitTimeout = 0;\n+     }\n+ \n+     native static int resumeThread(SuspendWithObjectMonitorWaitWorker thr);\n+@@ -311,7 +587,7 @@ public void run() {\n+                 \/\/ waiter thread out of this threadLock.wait(0) call:\n+                 while (SuspendWithObjectMonitorWait.testState <= SuspendWithObjectMonitorWait.TS_READY_TO_NOTIFY) {\n+                     try {\n+-                        SuspendWithObjectMonitorWait.threadLock.wait(0);\n++                        SuspendWithObjectMonitorWait.threadLock.wait(waitTimeout);\n+                     } catch (InterruptedException ex) {\n+                     }\n+                 }\n","filename":"patch.txt","additions":566,"deletions":0,"binary":false,"changes":566,"status":"added"},{"patch":"@@ -316,9 +316,0 @@\n-ObjectMonitor::SetObjectStrongFunctor::SetObjectStrongFunctor(OopHandle* object_strong, WeakHandle const* object) : _object_strong(object_strong), _object(object){}\n-\n-void ObjectMonitor::SetObjectStrongFunctor::operator()() {\n-  if (_object_strong->is_empty()) {\n-    assert(_object->resolve() != nullptr, \"\");\n-    *_object_strong = OopHandle(JavaThread::thread_oop_storage(), _object->resolve());\n-  }\n-}\n-\n@@ -329,2 +320,7 @@\n-    SetObjectStrongFunctor F(&_object_strong, &_object);\n-    SpinSingleSection sss(&_object_strong_lock, F);\n+    auto setObjectStrongLambda = [&](OopHandle& object_strong, const WeakHandle& object) {\n+      if (_object_strong.is_empty()) {\n+        assert(_object.resolve() != nullptr, \"\");\n+        object_strong = OopHandle(JavaThread::thread_oop_storage(), _object.resolve());\n+      }\n+    };\n+    SpinSingleSection<decltype(setObjectStrongLambda), OopHandle, WeakHandle> sss(&_object_strong_lock, setObjectStrongLambda, _object_strong, _object);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -373,7 +373,0 @@\n-  class SetObjectStrongFunctor : public SpinSingleSection::Functor {\n-    OopHandle* _object_strong;\n-    WeakHandle const* _object;\n-  public:\n-    SetObjectStrongFunctor(OopHandle* object_strong, WeakHandle const* object);\n-    void operator()();\n-  };\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -95,4 +95,2 @@\n-    {\n-      ev->FreeNext = FreeList;\n-      FreeList = ev;\n-    }\n+    ev->FreeNext = FreeList;\n+    FreeList = ev;\n","filename":"src\/hotspot\/share\/runtime\/park.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-void SpinCriticalSectionHelper::SpinAcquire(volatile int* adr) {\n+void SpinCriticalSectionHelper::spin_acquire(volatile int* adr) {\n@@ -40,1 +40,1 @@\n-  int Yields = 0;\n+  int yields = 0;\n@@ -45,1 +45,1 @@\n-        if (Yields > 5) {\n+        if (yields > 5) {\n@@ -50,1 +50,1 @@\n-          ++Yields;\n+          ++yields;\n@@ -61,1 +61,1 @@\n-void SpinCriticalSectionHelper::SpinRelease(volatile int* adr) {\n+void SpinCriticalSectionHelper::spin_release(volatile int* adr) {\n@@ -75,1 +75,1 @@\n-bool SpinCriticalSectionHelper::TrySpinAcquire(volatile int* adr) {\n+bool SpinCriticalSectionHelper::try_spin_acquire(volatile int* adr) {\n","filename":"src\/hotspot\/share\/utilities\/spinCriticalSection.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+  template<class Lambda, class...Args>\n@@ -35,3 +36,3 @@\n-  static void SpinAcquire(volatile int* Lock);\n-  static void SpinRelease(volatile int* Lock);\n-  static bool TrySpinAcquire(volatile int* Lock);\n+  static void spin_acquire(volatile int* Lock);\n+  static void spin_release(volatile int* Lock);\n+  static bool try_spin_acquire(volatile int* Lock);\n@@ -47,1 +48,1 @@\n-    SpinCriticalSectionHelper::SpinAcquire(_lock);\n+    SpinCriticalSectionHelper::spin_acquire(_lock);\n@@ -50,1 +51,1 @@\n-    SpinCriticalSectionHelper::SpinRelease(_lock);\n+    SpinCriticalSectionHelper::spin_release(_lock);\n@@ -54,2 +55,1 @@\n-\/\/ A short section which is to be executed by only one thread.\n-\/\/ The payload code is to be put into an object inherited from the Functor class.\n+template<class Lambda, class...Args>\n@@ -61,6 +61,2 @@\n-  class Functor {\n-  public:\n-    virtual void operator()() = 0;\n-  };\n-  SpinSingleSection(volatile int* lock, Functor& F) : _lock(lock), _lock_owner(nullptr) {\n-    if (SpinCriticalSectionHelper::TrySpinAcquire(_lock)) {\n+  SpinSingleSection(volatile int* lock, Lambda& F, Args&... args) : _lock(lock), _lock_owner(nullptr) {\n+    if (SpinCriticalSectionHelper::try_spin_acquire(_lock)) {\n@@ -68,1 +64,1 @@\n-      F();\n+      F(args...);\n@@ -77,1 +73,1 @@\n-      SpinCriticalSectionHelper::SpinRelease(_lock);\n+      SpinCriticalSectionHelper::spin_release(_lock);\n","filename":"src\/hotspot\/share\/utilities\/spinCriticalSection.hpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"utilities\/spinCriticalSection.hpp\"\n","filename":"test\/hotspot\/gtest\/jfr\/test_adaptiveSampler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}