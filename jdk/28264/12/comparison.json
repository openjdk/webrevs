{"files":[{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n@@ -131,1 +131,1 @@\n-  JfrSpinlockHelper mutex(&_lock);\n+  SpinCriticalSection scs(&_lock);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n@@ -345,1 +345,1 @@\n-  JfrSpinlockHelper mutex(&_lock);\n+  SpinCriticalSection scs(&_lock);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAdaptiveSampler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_JFR_UTILITIES_JFRSPINLOCKHELPER_HPP\n-#define SHARE_JFR_UTILITIES_JFRSPINLOCKHELPER_HPP\n-\n-#include \"runtime\/javaThread.hpp\"\n-\n-class JfrSpinlockHelper {\n- private:\n-  volatile int* const _lock;\n-\n- public:\n-  JfrSpinlockHelper(volatile int* lock) : _lock(lock) {\n-    Thread::SpinAcquire(_lock);\n-  }\n-\n-  ~JfrSpinlockHelper() {\n-    Thread::SpinRelease(_lock);\n-  }\n-};\n-\n-#endif \/\/ SHARE_JFR_UTILITIES_JFRSPINLOCKHELPER_HPP\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSpinlockHelper.hpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n@@ -1866,3 +1867,4 @@\n-  Thread::SpinAcquire(&_wait_set_lock);\n-  add_waiter(&node);\n-  Thread::SpinRelease(&_wait_set_lock);\n+  {\n+    SpinCriticalSection scs(&_wait_set_lock);\n+    add_waiter(&node);\n+  }\n@@ -1925,1 +1927,1 @@\n-      Thread::SpinAcquire(&_wait_set_lock);\n+      SpinCriticalSection scs(&_wait_set_lock);\n@@ -1930,1 +1932,0 @@\n-      Thread::SpinRelease(&_wait_set_lock);\n@@ -2039,1 +2040,1 @@\n-  Thread::SpinAcquire(&_wait_set_lock);\n+  SpinCriticalSection scs(&_wait_set_lock);\n@@ -2098,1 +2099,0 @@\n-  Thread::SpinRelease(&_wait_set_lock);\n@@ -2201,3 +2201,4 @@\n-  Thread::SpinAcquire(&_wait_set_lock);\n-  add_waiter(node);\n-  Thread::SpinRelease(&_wait_set_lock);\n+  {\n+    SpinCriticalSection scs(&_wait_set_lock);\n+    add_waiter(node);\n+  }\n@@ -2224,1 +2225,1 @@\n-    Thread::SpinAcquire(&_wait_set_lock);\n+    SpinCriticalSection scs(&_wait_set_lock);\n@@ -2229,1 +2230,0 @@\n-    Thread::SpinRelease(&_wait_set_lock);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n@@ -63,1 +64,0 @@\n-  Thread::SpinAcquire(&ListLock);\n@@ -65,0 +65,1 @@\n+    SpinCriticalSection scs(&ListLock);\n@@ -70,1 +71,0 @@\n-  Thread::SpinRelease(&ListLock);\n@@ -91,1 +91,0 @@\n-  Thread::SpinAcquire(&ListLock);\n@@ -93,0 +92,1 @@\n+    SpinCriticalSection scs(&ListLock);\n@@ -96,1 +96,0 @@\n-  Thread::SpinRelease(&ListLock);\n","filename":"src\/hotspot\/share\/runtime\/park.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n-NoSafepointVerifier::NoSafepointVerifier(bool active) : _thread(Thread::current()), _active(active) {\n+NoSafepointVerifier::NoSafepointVerifier(bool active)\n+  : _thread(active ? Thread::current() : nullptr),\n+    _active(active) {\n","filename":"src\/hotspot\/share\/runtime\/safepointVerifiers.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -569,46 +569,0 @@\n-\n-\/\/ Ad-hoc mutual exclusion primitive: spin lock\n-\/\/\n-\/\/ We employ a spin lock _only for low-contention, fixed-length\n-\/\/ short-duration critical sections where we're concerned\n-\/\/ about native mutex_t or HotSpot Mutex:: latency.\n-\n-void Thread::SpinAcquire(volatile int * adr) {\n-  if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) {\n-    return;   \/\/ normal fast-path return\n-  }\n-\n-  \/\/ Slow-path : We've encountered contention -- Spin\/Yield\/Block strategy.\n-  int ctr = 0;\n-  int Yields = 0;\n-  for (;;) {\n-    while (*adr != 0) {\n-      ++ctr;\n-      if ((ctr & 0xFFF) == 0 || !os::is_MP()) {\n-        if (Yields > 5) {\n-          os::naked_short_sleep(1);\n-        } else {\n-          os::naked_yield();\n-          ++Yields;\n-        }\n-      } else {\n-        SpinPause();\n-      }\n-    }\n-    if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) return;\n-  }\n-}\n-\n-void Thread::SpinRelease(volatile int * adr) {\n-  assert(*adr != 0, \"invariant\");\n-  \/\/ Roach-motel semantics.\n-  \/\/ It's safe if subsequent LDs and STs float \"up\" into the critical section,\n-  \/\/ but prior LDs and STs within the critical section can't be allowed\n-  \/\/ to reorder or float past the ST that releases the lock.\n-  \/\/ Loads and stores in the critical section - which appear in program\n-  \/\/ order before the store that releases the lock - must also appear\n-  \/\/ before the store that releases the lock in memory visibility order.\n-  \/\/ So we need a #loadstore|#storestore \"release\" memory barrier before\n-  \/\/ the ST of 0 into the lock-word which releases the lock.\n-  AtomicAccess::release_store(adr, 0);\n-}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -605,5 +605,0 @@\n-  \/\/ Low-level leaf-lock primitives used to implement synchronization.\n-  \/\/ Not for general synchronization use.\n-  static void SpinAcquire(volatile int * Lock);\n-  static void SpinRelease(volatile int * Lock);\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/atomicAccess.hpp\"\n+#include \"utilities\/spinCriticalSection.hpp\"\n+\n+void SpinCriticalSection::spin_acquire(volatile int* adr) {\n+  if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) {\n+    return;   \/\/ normal fast-path return\n+  }\n+\n+  \/\/ Slow-path : We've encountered contention -- Spin\/Yield\/Block strategy.\n+  int ctr = 0;\n+  int Yields = 0;\n+  for (;;) {\n+    while (*adr != 0) {\n+      ++ctr;\n+      if ((ctr & 0xFFF) == 0 || !os::is_MP()) {\n+        if (Yields > 5) {\n+          os::naked_short_sleep(1);\n+        }\n+        else {\n+          os::naked_yield();\n+          ++Yields;\n+        }\n+      }\n+      else {\n+        SpinPause();\n+      }\n+    }\n+    if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) return;\n+  }\n+}\n+\n+void SpinCriticalSection::spin_release(volatile int* adr) {\n+  assert(*adr != 0, \"invariant\");\n+  \/\/ Roach-motel semantics.\n+  \/\/ It's safe if subsequent LDs and STs float \"up\" into the critical section,\n+  \/\/ but prior LDs and STs within the critical section can't be allowed\n+  \/\/ to reorder or float past the ST that releases the lock.\n+  \/\/ Loads and stores in the critical section - which appear in program\n+  \/\/ order before the store that releases the lock - must also appear\n+  \/\/ before the store that releases the lock in memory visibility order.\n+  \/\/ So we need a #loadstore|#storestore \"release\" memory barrier before\n+  \/\/ the ST of 0 into the lock-word which releases the lock.\n+  AtomicAccess::release_store(adr, 0);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/spinCriticalSection.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_SPINCRITICALSECTION_HPP\n+#define SHARE_UTILITIES_SPINCRITICALSECTION_HPP\n+\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ Ad-hoc mutual exclusion primitive: spin critical section,\n+\/\/ which employs a spin lock.\n+\/\/\n+\/\/ We use this critical section only for low-contention code, and\n+\/\/ when it is know that the duration is short. To be used where\n+\/\/ we're concerned about native mutex_t or HotSpot Mutex:: latency.\n+\/\/ This class uses low-level leaf-lock primitives to implement\n+\/\/ synchronization and is not for general synchronization use.\n+class SpinCriticalSection {\n+private:\n+  \/\/ We use int type as 32-bit atomic operation is the most performant\n+  \/\/ compared to  smaller\/larger types.\n+  volatile int* const _lock;\n+  DEBUG_ONLY(NoSafepointVerifier _nsv;)\n+\n+  static void spin_acquire(volatile int* Lock);\n+  static void spin_release(volatile int* Lock);\n+public:\n+  NONCOPYABLE(SpinCriticalSection);\n+  SpinCriticalSection(volatile int* lock)\n+    : _lock(lock)\n+      DEBUG_ONLY(COMMA _nsv(Thread::current_or_null_safe() != nullptr)) {\n+    spin_acquire(_lock);\n+  }\n+  ~SpinCriticalSection() {\n+    spin_release(_lock);\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_SPINCRITICALSECTION_HPP\n","filename":"src\/hotspot\/share\/utilities\/spinCriticalSection.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n@@ -42,1 +41,0 @@\n-#include \"runtime\/atomicAccess.hpp\"\n@@ -44,0 +42,1 @@\n+#include \"utilities\/spinCriticalSection.hpp\"\n","filename":"test\/hotspot\/gtest\/jfr\/test_adaptiveSampler.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}