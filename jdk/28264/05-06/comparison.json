{"files":[{"patch":"@@ -320,1 +320,1 @@\n-    auto setObjectStrongLambda = [&](OopHandle& object_strong, const WeakHandle& object) {\n+    if (AtomicAccess::cmpxchg(&_object_strong_lock, 0, 1) == 0) {\n@@ -323,1 +323,1 @@\n-        object_strong = OopHandle(JavaThread::thread_oop_storage(), _object.resolve());\n+        _object_strong = OopHandle(JavaThread::thread_oop_storage(), _object.resolve());\n@@ -325,2 +325,2 @@\n-    };\n-    SpinSingleSection<decltype(setObjectStrongLambda), OopHandle, WeakHandle> sss(&_object_strong_lock, setObjectStrongLambda, _object_strong, _object);\n+      AtomicAccess::release_store(&_object_strong_lock, 0);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,5 +66,3 @@\n-    {\n-      ev = FreeList;\n-      if (ev != nullptr) {\n-        FreeList = ev->FreeNext;\n-      }\n+    ev = FreeList;\n+    if (ev != nullptr) {\n+      FreeList = ev->FreeNext;\n","filename":"src\/hotspot\/share\/runtime\/park.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -28,5 +29,0 @@\n- \/\/ Ad-hoc mutual exclusion primitive: spin lock\n- \/\/\n- \/\/ We employ a spin lock _only for low-contention, fixed-length\n- \/\/ short-duration critical sections where we're concerned\n- \/\/ about native mutex_t or HotSpot Mutex:: latency.\n@@ -38,0 +34,2 @@\n+  SpinYield sy(4096, 5, 1000000);\n+\n@@ -39,2 +37,0 @@\n-  int ctr = 0;\n-  int yields = 0;\n@@ -43,13 +39,1 @@\n-      ++ctr;\n-      if ((ctr & 0xFFF) == 0 || !os::is_MP()) {\n-        if (yields > 5) {\n-          os::naked_short_sleep(1);\n-        }\n-        else {\n-          os::naked_yield();\n-          ++yields;\n-        }\n-      }\n-      else {\n-        SpinPause();\n-      }\n+      sy.wait();\n@@ -75,7 +59,0 @@\n-bool SpinCriticalSectionHelper::try_spin_acquire(volatile int* adr) {\n-  if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/spinCriticalSection.cpp","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-class SpinCriticalSectionHelper {\n+class SpinCriticalSectionHelper : AllStatic {\n@@ -38,1 +38,0 @@\n-  static bool try_spin_acquire(volatile int* Lock);\n@@ -41,2 +40,6 @@\n-\/\/ Short critical section. To be used when having a\n-\/\/ mutex is considered to be expensive.\n+\/\/ Ad-hoc mutual exclusion primitive: spin critical section,\n+\/\/ which employs a spin lock.\n+\/\/\n+\/\/ We use this critical section _only for low-contention code, and\n+\/\/ when it is know that the duration is short. To be used where\n+\/\/ we're concerned about native mutex_t or HotSpot Mutex:: latency.\n@@ -47,0 +50,1 @@\n+  NONCOPYABLE(SpinCriticalSection);\n@@ -55,23 +59,1 @@\n-template<class Lambda, class...Args>\n-class SpinSingleSection {\n-private:\n-  volatile int* const _lock;\n-  Thread* _lock_owner;\n-public:\n-  SpinSingleSection(volatile int* lock, Lambda& F, Args&... args) : _lock(lock), _lock_owner(nullptr) {\n-    if (SpinCriticalSectionHelper::try_spin_acquire(_lock)) {\n-      _lock_owner = Thread::current();\n-      F(args...);\n-    }\n-  }\n-  ~SpinSingleSection() {\n-    \/\/ It is safe to not have any atomic operations here,\n-    \/\/ as a thread either sees a nullptr or a pointer to a thread which\n-    \/\/ succeeded in locking the lock. Comparison will fail in both\n-    \/\/ cases if it is not a succeeded thread.\n-    if (_lock_owner == Thread::current()) {\n-      SpinCriticalSectionHelper::spin_release(_lock);\n-    }\n-  }\n-};\n-#endif \/\/SHARE_UTILITIES_SPINCRITICALSECTION_HPP\n+#endif \/\/ SHARE_UTILITIES_SPINCRITICALSECTION_HPP\n","filename":"src\/hotspot\/share\/utilities\/spinCriticalSection.hpp","additions":9,"deletions":27,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/atomicAccess.hpp\"\n","filename":"test\/hotspot\/gtest\/jfr\/test_adaptiveSampler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}