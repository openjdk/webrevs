{"files":[{"patch":"@@ -833,0 +833,2 @@\n+    case JVM_CONSTANT_Methodref:\n+    case JVM_CONSTANT_InterfaceMethodref:\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -261,3 +261,1 @@\n-        if (rfe->is_resolved(Bytecodes::_getstatic) ||\n-            rfe->is_resolved(Bytecodes::_putstatic) ||\n-            rfe->is_resolved(Bytecodes::_getfield) ||\n+        if (rfe->is_resolved(Bytecodes::_getfield) ||\n@@ -270,0 +268,13 @@\n+\n+    Array<ResolvedMethodEntry>* method_entries = cp->cache()->resolved_method_entries();\n+    if (method_entries != nullptr) {\n+      for (int i = 0; i < method_entries->length(); i++) {\n+        ResolvedMethodEntry* rme = method_entries->adr_at(i);\n+        if (rme->is_resolved(Bytecodes::_invokevirtual) ||\n+            rme->is_resolved(Bytecodes::_invokespecial) ||\n+            rme->is_resolved(Bytecodes::_invokeinterface)) {\n+          list.at_put(rme->constant_pool_index(), true);\n+          print = true;\n+        }\n+      }\n+    }\n@@ -279,1 +290,3 @@\n-               cp_tag.value() == JVM_CONSTANT_Fieldref, \"sanity\");\n+               cp_tag.value() == JVM_CONSTANT_Fieldref ||\n+               cp_tag.value() == JVM_CONSTANT_Methodref||\n+               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -92,1 +92,3 @@\n-  } else if (cp->tag_at(cp_index).is_field()) {\n+  } else if (cp->tag_at(cp_index).is_field() ||\n+             cp->tag_at(cp_index).is_method() ||\n+             cp->tag_at(cp_index).is_interface_method()) {\n@@ -266,0 +268,8 @@\n+      case Bytecodes::_invokespecial:\n+      case Bytecodes::_invokevirtual:\n+      case Bytecodes::_invokeinterface:\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n@@ -304,0 +314,6 @@\n+  case Bytecodes::_invokevirtual:\n+  case Bytecodes::_invokespecial:\n+  case Bytecodes::_invokeinterface:\n+    InterpreterRuntime::cds_resolve_invoke(bc, raw_index, cp, CHECK);\n+    break;\n+\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+  msg.info(\"Method CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n+           _num_method_cp_entries, _num_method_cp_entries_archived,\n+           percent_of(_num_method_cp_entries_archived, _num_method_cp_entries),\n+           _num_method_cp_entries_reverted);\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+  int _num_method_cp_entries;\n+  int _num_method_cp_entries_archived;\n+  int _num_method_cp_entries_reverted;\n@@ -87,0 +90,3 @@\n+    _num_method_cp_entries          = 0;\n+    _num_method_cp_entries_archived = 0;\n+    _num_method_cp_entries_reverted = 0;\n@@ -125,0 +131,6 @@\n+  void record_method_cp_entry(bool archived, bool reverted) {\n+    _num_method_cp_entries ++;\n+    _num_method_cp_entries_archived += archived ? 1 : 0;\n+    _num_method_cp_entries_reverted += reverted ? 1 : 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -835,1 +835,0 @@\n-  ConstantPoolCache* cache = pool->cache();\n@@ -860,0 +859,7 @@\n+  update_invoke_cp_cache_entry(info, bytecode, resolved_method, pool, method_index);\n+}\n+\n+void InterpreterRuntime::update_invoke_cp_cache_entry(CallInfo& info, Bytecodes::Code bytecode,\n+                                                      methodHandle& resolved_method,\n+                                                      constantPoolHandle& pool,\n+                                                      int method_index) {\n@@ -864,0 +870,1 @@\n+  ConstantPoolCache* cache = pool->cache();\n@@ -915,0 +922,27 @@\n+void InterpreterRuntime::cds_resolve_invoke(Bytecodes::Code bytecode, int method_index,\n+                                            constantPoolHandle& pool, TRAPS) {\n+  LinkInfo link_info(pool, method_index, bytecode, CHECK);\n+\n+  if (!link_info.resolved_klass()->is_instance_klass() || InstanceKlass::cast(link_info.resolved_klass())->is_linked()) {\n+    CallInfo call_info;\n+    switch (bytecode) {\n+      case Bytecodes::_invokevirtual:   LinkResolver::cds_resolve_virtual_call  (call_info, link_info, CHECK); break;\n+      case Bytecodes::_invokeinterface: LinkResolver::cds_resolve_interface_call(call_info, link_info, CHECK); break;\n+      case Bytecodes::_invokespecial:   LinkResolver::cds_resolve_special_call  (call_info, link_info, CHECK); break;\n+\n+      default: fatal(\"Unimplemented: %s\", Bytecodes::name(bytecode));\n+    }\n+    methodHandle resolved_method(THREAD, call_info.resolved_method());\n+    guarantee(resolved_method->method_holder()->is_linked(), \"\");\n+    update_invoke_cp_cache_entry(call_info, bytecode, resolved_method, pool, method_index);\n+  } else {\n+    \/\/ FIXME: why a shared class is not linked yet?\n+    \/\/ Can't link it here since there are no guarantees it'll be prelinked on the next run.\n+    ResourceMark rm;\n+    InstanceKlass* resolved_iklass = InstanceKlass::cast(link_info.resolved_klass());\n+    log_info(cds, resolve)(\"Not resolved: class not linked: %s %s %s\",\n+                           resolved_iklass->is_shared() ? \"is_shared\" : \"\",\n+                           resolved_iklass->init_state_name(),\n+                           resolved_iklass->external_name());\n+  }\n+}\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  \/\/ Used by ClassListParser.\n+  \/\/ Used by ClassPrelinker\n@@ -98,0 +98,2 @@\n+  static void cds_resolve_invoke(Bytecodes::Code bytecode, int method_index,\n+                                 constantPoolHandle& pool, TRAPS);\n@@ -108,0 +110,3 @@\n+  static void update_invoke_cp_cache_entry(CallInfo& info, Bytecodes::Code bytecode,\n+                                           methodHandle& resolved_method,\n+                                           constantPoolHandle& pool, int method_index);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -145,1 +145,3 @@\n-  assert(resolved_method->signature() == selected_method->signature(), \"signatures must correspond\");\n+  if (selected_method.not_null()) {\n+    assert(resolved_method->signature() == selected_method->signature(), \"signatures must correspond\");\n+  }\n@@ -154,1 +156,3 @@\n-  CompilationPolicy::compile_if_required(selected_method, THREAD);\n+  if (selected_method.not_null()) {\n+    CompilationPolicy::compile_if_required(selected_method, THREAD);\n+  }\n@@ -1155,0 +1159,4 @@\n+void LinkResolver::cds_resolve_special_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  resolve_special_call(result, Handle(), link_info, CHECK);\n+}\n+\n@@ -1336,1 +1344,11 @@\n-                                 check_null_and_abstract, CHECK);\n+                                 check_null_and_abstract,\n+                                 \/*is_abstract_interpretation*\/ false, CHECK);\n+}\n+\n+void LinkResolver::cds_resolve_virtual_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  Method* resolved_method = linktime_resolve_virtual_method(link_info, CHECK);\n+  runtime_resolve_virtual_method(result, methodHandle(THREAD, resolved_method),\n+                                 link_info.resolved_klass(),\n+                                 Handle(), nullptr,\n+                                 \/*check_null_and_abstract*\/ false,\n+                                 \/*is_abstract_interpretation*\/ true, CHECK);\n@@ -1388,0 +1406,1 @@\n+                                                  bool is_abstract_interpretation,\n@@ -1389,0 +1408,3 @@\n+  \/\/ is_abstract_interpretation is true IFF CDS is resolving method references without\n+  \/\/ running any actual bytecode. Therefore, we don't have an actual recv\/recv_klass, so\n+  \/\/ we cannot check the actual selected_method (which is not needed by CDS anyway).\n@@ -1409,1 +1431,3 @@\n-    selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+    if (!is_abstract_interpretation) {\n+      selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+    }\n@@ -1423,1 +1447,3 @@\n-      selected_method = resolved_method;\n+      if (!is_abstract_interpretation) {\n+        selected_method = resolved_method;\n+      }\n@@ -1425,1 +1451,3 @@\n-      selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+      if (!is_abstract_interpretation) {\n+        selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+      }\n@@ -1429,4 +1457,5 @@\n-  \/\/ check if method exists\n-  if (selected_method.is_null()) {\n-    throw_abstract_method_error(resolved_method, recv_klass, CHECK);\n-  }\n+  if (!is_abstract_interpretation) {\n+    \/\/ check if method exists\n+    if (selected_method.is_null()) {\n+      throw_abstract_method_error(resolved_method, recv_klass, CHECK);\n+    }\n@@ -1434,5 +1463,5 @@\n-  \/\/ check if abstract\n-  if (check_null_and_abstract && selected_method->is_abstract()) {\n-    \/\/ Pass arguments for generating a verbose error message.\n-    throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);\n-  }\n+    \/\/ check if abstract\n+    if (check_null_and_abstract && selected_method->is_abstract()) {\n+      \/\/ Pass arguments for generating a verbose error message.\n+      throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);\n+    }\n@@ -1440,4 +1469,5 @@\n-  if (log_develop_is_enabled(Trace, vtables)) {\n-    trace_method_resolution(\"invokevirtual selected method: receiver-class:\",\n-                            recv_klass, resolved_klass, selected_method(),\n-                            false, vtable_index);\n+    if (log_develop_is_enabled(Trace, vtables)) {\n+      trace_method_resolution(\"invokevirtual selected method: receiver-class:\",\n+                              recv_klass, resolved_klass, selected_method(),\n+                              false, vtable_index);\n+    }\n@@ -1445,0 +1475,1 @@\n+\n@@ -1447,1 +1478,3 @@\n-  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  if (selected_method.not_null()) {\n+    JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  }\n@@ -1457,1 +1490,10 @@\n-                                   recv, recv_klass, check_null_and_abstract, CHECK);\n+                                   recv, recv_klass, check_null_and_abstract,\n+                                   \/*is_abstract_interpretation*\/ false, CHECK);\n+}\n+\n+void LinkResolver::cds_resolve_interface_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);\n+  runtime_resolve_interface_method(result, methodHandle(THREAD, resolved_method), link_info.resolved_klass(),\n+                                   Handle(), nullptr,\n+                                   \/*check_null_and_abstract*\/ false,\n+                                   \/*is_abstract_interpretation*\/ true, CHECK);\n@@ -1476,1 +1518,3 @@\n-                                                    bool check_null_and_abstract, TRAPS) {\n+                                                    bool check_null_and_abstract,\n+                                                    bool is_abstract_interpretation, TRAPS) {\n+  \/\/ is_abstract_interpretation -- see comments in runtime_resolve_virtual_method()\n@@ -1484,1 +1528,1 @@\n-  if (!recv_klass->is_subtype_of(resolved_klass)) {\n+  if (!is_abstract_interpretation && !recv_klass->is_subtype_of(resolved_klass)) {\n@@ -1493,1 +1537,5 @@\n-  methodHandle selected_method = resolved_method;\n+  methodHandle selected_method;\n+\n+  if (!is_abstract_interpretation) {\n+    selected_method = resolved_method;\n+  }\n@@ -1496,1 +1544,1 @@\n-  if (!resolved_method()->is_private()) {\n+  if (!is_abstract_interpretation && !resolved_method()->is_private()) {\n@@ -1542,1 +1590,1 @@\n-    assert(vtable_index == selected_method->vtable_index(), \"sanity check\");\n+    assert(is_abstract_interpretation || vtable_index == selected_method->vtable_index(), \"sanity check\");\n@@ -1559,1 +1607,3 @@\n-  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  if (!is_abstract_interpretation) {\n+    JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":77,"deletions":27,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -245,1 +245,2 @@\n-                                                 bool check_null_and_abstract, TRAPS);\n+                                                 bool check_null_and_abstract,\n+                                                 bool is_abstract_interpretation, TRAPS);\n@@ -251,1 +252,2 @@\n-                                                 bool check_null_and_abstract, TRAPS);\n+                                                 bool check_null_and_abstract,\n+                                                 bool is_abstract_interpretation, TRAPS);\n@@ -328,0 +330,4 @@\n+  static void cds_resolve_virtual_call  (CallInfo& result, const LinkInfo& link_info, TRAPS);\n+  static void cds_resolve_interface_call(CallInfo& result, const LinkInfo& link_info, TRAPS);\n+  static void cds_resolve_special_call  (CallInfo& result, const LinkInfo& link_info, TRAPS);\n+\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -411,3 +412,1 @@\n-    for (int i = 0; i < _resolved_method_entries->length(); i++) {\n-      resolved_method_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_method_entries_if_non_deterministic();\n@@ -451,0 +450,90 @@\n+\n+void ConstantPoolCache::remove_resolved_method_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_method_entries->length(); i++) {\n+    ResolvedMethodEntry* rme = _resolved_method_entries->adr_at(i);\n+    int cp_index = rme->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rme->is_resolved(Bytecodes::_invokevirtual)   ||\n+                    rme->is_resolved(Bytecodes::_invokespecial)   ||\n+                    rme->is_resolved(Bytecodes::_invokeinterface);\n+\n+    \/\/ Just for safety -- this should not happen, but do not archive if we ever see this.\n+    resolved &= !(rme->is_resolved(Bytecodes::_invokehandle) ||\n+                  rme->is_resolved(Bytecodes::_invokestatic));\n+\n+    if (resolved && can_archive_resolved_method(rme)) {\n+      rme->mark_and_relocate(src_cp);\n+      archived = true;\n+    } else {\n+      rme->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+        Symbol* name = cp->uncached_name_ref_at(cp_index);\n+        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+        log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n+                  cp_index,\n+                  cp->pool_holder()->name()->as_C_string(),\n+                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+        if (archived) {\n+          Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n+          log.print(\" => %s%s\",\n+                    resolved_klass->name()->as_C_string(),\n+                    (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n+        }\n+      }\n+      ArchiveBuilder::alloc_stats()->record_method_cp_entry(archived, resolved && !archived);\n+    }\n+  }\n+}\n+\n+bool ConstantPoolCache::can_archive_resolved_method(ResolvedMethodEntry* method_entry) {\n+  InstanceKlass* pool_holder = constant_pool()->pool_holder();\n+  if (!(pool_holder->is_shared_boot_class() || pool_holder->is_shared_platform_class() ||\n+        pool_holder->is_shared_app_class())) {\n+    \/\/ Archiving resolved cp entries for classes from non-builtin loaders\n+    \/\/ is not yet supported.\n+    return false;\n+  }\n+\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n+    \/\/ InstanceKlass::methods() has been resorted. We need to\n+    \/\/ update the vtable_index in method_entry (not implemented)\n+    return false;\n+  }\n+\n+  if (!method_entry->is_resolved(Bytecodes::_invokevirtual)) {\n+    if (method_entry->method() == nullptr) {\n+      return false;\n+    }\n+    if (method_entry->method()->is_continuation_native_intrinsic()) {\n+      return false; \/\/ FIXME: corresponding stub is generated on demand during method resolution (see LinkResolver::resolve_static_call).\n+    }\n+  }\n+\n+  int cp_index = method_entry->constant_pool_index();\n+  ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n+  assert(src_cp->tag_at(cp_index).is_method() || src_cp->tag_at(cp_index).is_interface_method(), \"sanity\");\n+\n+  if (!ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+    return false;\n+  }\n+\n+  if (method_entry->is_resolved(Bytecodes::_invokeinterface) ||\n+      method_entry->is_resolved(Bytecodes::_invokevirtual) ||\n+      method_entry->is_resolved(Bytecodes::_invokespecial)) {\n+    return true;\n+  } else {\n+    \/\/ invokestatic and invokehandle are not supported yet.\n+    return false;\n+  }\n+\n+}\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,2 @@\n+  void remove_resolved_method_entries_if_non_deterministic();\n+  bool can_archive_resolved_method(ResolvedMethodEntry* method_entry);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,0 +85,15 @@\n+  void copy_from(const ResolvedMethodEntry& other) {\n+    _method = other._method;\n+    _entry_specific = other._entry_specific;\n+    _cpool_index = other._cpool_index;\n+    _number_of_parameters = other._number_of_parameters;\n+    _tos_state = other._tos_state;\n+    _flags = other._flags;\n+    _bytecode1 = other._bytecode1;\n+    _bytecode2 = other._bytecode2;\n+#ifdef ASSERT\n+    _has_interface_klass = other._has_interface_klass;\n+    _has_table_index = other._has_table_index;\n+#endif\n+  }\n+\n@@ -102,0 +117,10 @@\n+    ResolvedMethodEntry(const ResolvedMethodEntry& other) {\n+      copy_from(other);\n+    }\n+\n+    ResolvedMethodEntry& operator=(const ResolvedMethodEntry& other) {\n+      copy_from(other);\n+      return *this;\n+    }\n+\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+          \/\/ Class References ---\n+\n@@ -73,0 +75,2 @@\n+          \/\/ Field References ---\n+\n@@ -83,1 +87,0 @@\n-\n@@ -88,0 +91,35 @@\n+          \/\/ Method References ---\n+\n+            \/\/ Should resolve references to own constructor\n+            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp ResolvedConstantsApp.<init>:\")\n+            \/\/ Should resolve references to super constructor\n+            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp java\/lang\/Object.<init>:\")\n+\n+            \/\/ Should resolve interface methods in VM classes\n+            .shouldMatch(\"cds,resolve.*archived interface method .* ResolvedConstantsApp java\/lang\/Runnable.run:\")\n+\n+            \/\/ Should resolve references to own non-static method (private or public)\n+            .shouldMatch(\"archived method.*: ResolvedConstantsBar ResolvedConstantsBar.doBar:\")\n+            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.privateInstanceCall:\")\n+            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.publicInstanceCall:\")\n+\n+            \/\/ Should not resolve references to static method\n+            .shouldNotMatch(\" archived method CP entry.*: ResolvedConstantsApp ResolvedConstantsApp.staticCall:\")\n+\n+            \/\/ Should resolve references to method in super type\n+            .shouldMatch(\" archived method CP entry.*: ResolvedConstantsBar ResolvedConstantsFoo.doBar:\")\n+\n+            \/\/ App class cannot resolve references to methods in boot classes:\n+            \/\/    When the app class loader tries to resolve a class X that's normally loaded by\n+            \/\/    the boot loader, it's possible for the app class loader to get a different copy of\n+            \/\/    X (by using MethodHandles.Lookup.defineClass(), etc). Therefore, let's be on\n+            \/\/    the side of safety and revert all such references.\n+            \/\/\n+            \/\/    This will be addressed in JDK-8315737.\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsApp java\/io\/PrintStream.println:\")\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsBar java\/lang\/Class.getName:\")\n+\n+            \/\/ Should not resolve methods in unrelated classes.\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsApp ResolvedConstantsBar.doit:\")\n+\n+          \/\/ End ---\n@@ -95,1 +133,5 @@\n-        Object a = new ResolvedConstantsApp();\n+        ResolvedConstantsApp app = new ResolvedConstantsApp();\n+        ResolvedConstantsApp.staticCall();\n+        app.privateInstanceCall();\n+        app.publicInstanceCall();\n+        Object a = app;\n@@ -104,0 +146,4 @@\n+    private static void staticCall() {}\n+    private void privateInstanceCall() {}\n+    public void publicInstanceCall() {}\n+\n@@ -127,0 +173,2 @@\n+\n+        ((ResolvedConstantsFoo)this).doBar(this);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"}]}