{"files":[{"patch":"@@ -828,0 +828,23 @@\n+    \/\/ IEEE 754 floating point comparison treats 0.0 and -0.0 as equals.\n+\n+    \/\/ Division of a zero by a zero results in NaN.\n+    if (t1->getf() == 0.0f && t2->getf() == 0.0f) {\n+      return TypeH::make(NAN);\n+    }\n+\n+    \/\/ As per C++ standard section 7.6.5 (expr.mul), behavior is undefined only if\n+    \/\/ the second operand is 0.0. In all other situations, we can expect a standard-compliant\n+    \/\/ C++ compiler to generate code following IEEE 754 semantics.\n+    if (t2->getf() == 0.0) {\n+      \/\/ If either operand is NaN, the result is NaN\n+      if (g_isnan(t1->getf())) {\n+        return TypeH::make(NAN);\n+      } else {\n+        \/\/ Division of a nonzero finite value by a zero results in a signed infinity. Also,\n+        \/\/ division of an infinity by a finite value results in a signed infinity.\n+        bool res_sign_neg = (jint_cast(t1->getf()) < 0) ^ (jint_cast(t2->getf()) < 0);\n+        const TypeF* res = res_sign_neg ? TypeF::NEG_INF : TypeF::POS_INF;\n+        return TypeH::make(res->getf());\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}