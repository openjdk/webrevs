{"files":[{"patch":"@@ -1362,0 +1362,25 @@\n+\/\/ vector eor3 (unpredicated)\n+\n+instruct veor3_neon(vReg dst, vReg src1, vReg src2, vReg src3) %{\n+  predicate(VM_Version::supports_sha3() &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (XorV src1 (XorV src2 src3)));\n+  format %{ \"veor3_neon $dst, $src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ eor3($dst$$FloatRegister, __ T16B, $src1$$FloatRegister,\n+            $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct veor3_sve(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseSVE == 2 && VM_Version::supports_svesha3() &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (XorV dst_src1 (XorV src2 src3)));\n+  format %{ \"veor3_sve $dst_src1, $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ sve_eor3($dst_src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -689,0 +689,25 @@\n+\/\/ vector eor3 (unpredicated)\n+\n+instruct veor3_neon(vReg dst, vReg src1, vReg src2, vReg src3) %{\n+  predicate(VM_Version::supports_sha3() &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (XorV src1 (XorV src2 src3)));\n+  format %{ \"veor3_neon $dst, $src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ eor3($dst$$FloatRegister, __ T16B, $src1$$FloatRegister,\n+            $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct veor3_sve(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseSVE == 2 && VM_Version::supports_svesha3() &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (XorV dst_src1 (XorV src2 src3)));\n+  format %{ \"veor3_sve $dst_src1, $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ sve_eor3($dst_src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3861,0 +3861,11 @@\n+\/\/ SVE2 bitwise ternary operations\n+#define INSN(NAME, opc)                                               \\\n+  void NAME(FloatRegister Zdn, FloatRegister Zm, FloatRegister Zk) {  \\\n+    starti;                                                           \\\n+    f(0b00000100, 31, 24), f(opc, 23, 21), rf(Zm, 16);                \\\n+    f(0b001110, 15, 10), rf(Zk, 5), rf(Zdn, 0);                       \\\n+  }\n+\n+  INSN(sve_eor3, 0b001); \/\/ Bitwise exclusive OR of three vectors\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+    decl(SVESHA3,       svesha3,       29)    \\\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,0 +87,4 @@\n+#ifndef HWCAP2_SVESHA3\n+#define HWCAP2_SVESHA3 (1 << 5)\n+#endif\n+\n@@ -141,0 +145,1 @@\n+  if (auxv2 & HWCAP2_SVESHA3) _features |= CPU_SVESHA3;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+        SVESHA3,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.aarch64\/src\/jdk\/vm\/ci\/aarch64\/AArch64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1012,1 +1012,1 @@\n-        elif not self._isPredicated and (name in [\"and\", \"eor\", \"orr\", \"bic\"]):\n+        elif not self._isPredicated and (name in [\"and\", \"eor\", \"orr\", \"bic\", \"eor3\"]):\n@@ -1015,0 +1015,2 @@\n+        elif name == \"revb\":\n+            self._width = RegVariant(1, 3)\n@@ -1039,1 +1041,4 @@\n-        formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(1, self.numRegs)])\n+        if self._name == \"eor3\":\n+            formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(0, self.numRegs)])\n+        else:\n+            formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(1, self.numRegs)])\n@@ -1049,1 +1054,4 @@\n-            restRegs = dnReg + [str(self.reg[i]) + self._width.astr() for i in range(1, self.numRegs)]\n+            if self._name == \"eor3\":\n+                restRegs = dnReg + [str(self.reg[i]) + self._width.astr() for i in range(0, self.numRegs)]\n+            else:\n+                restRegs = dnReg + [str(self.reg[i]) + self._width.astr() for i in range(1, self.numRegs)]\n@@ -1925,0 +1933,1 @@\n+                       [\"eor3\", \"ZZZ\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1213,0 +1213,1 @@\n+    __ sve_eor3(z11, z12, z28);                        \/\/       eor3    z11.d, z11.d, z12.d, z28.d\n@@ -1215,9 +1216,9 @@\n-    __ sve_andv(v11, __ S, p3, z28);                   \/\/       andv s11, p3, z28.s\n-    __ sve_orv(v5, __ H, p0, z13);                     \/\/       orv h5, p0, z13.h\n-    __ sve_eorv(v2, __ H, p1, z10);                    \/\/       eorv h2, p1, z10.h\n-    __ sve_smaxv(v19, __ H, p1, z25);                  \/\/       smaxv h19, p1, z25.h\n-    __ sve_sminv(v2, __ B, p0, z29);                   \/\/       sminv b2, p0, z29.b\n-    __ sve_fminv(v20, __ D, p1, z20);                  \/\/       fminv d20, p1, z20.d\n-    __ sve_fmaxv(v28, __ S, p3, z13);                  \/\/       fmaxv s28, p3, z13.s\n-    __ sve_fadda(v13, __ S, p7, z1);                   \/\/       fadda s13, p7, s13, z1.s\n-    __ sve_uaddv(v27, __ D, p0, z3);                   \/\/       uaddv d27, p0, z3.d\n+    __ sve_andv(v5, __ H, p0, z13);                    \/\/       andv h5, p0, z13.h\n+    __ sve_orv(v2, __ H, p1, z10);                     \/\/       orv h2, p1, z10.h\n+    __ sve_eorv(v19, __ H, p1, z25);                   \/\/       eorv h19, p1, z25.h\n+    __ sve_smaxv(v2, __ B, p0, z29);                   \/\/       smaxv b2, p0, z29.b\n+    __ sve_sminv(v20, __ D, p1, z20);                  \/\/       sminv d20, p1, z20.d\n+    __ sve_fminv(v28, __ S, p3, z13);                  \/\/       fminv s28, p3, z13.s\n+    __ sve_fmaxv(v13, __ S, p7, z1);                   \/\/       fmaxv s13, p7, z1.s\n+    __ sve_fadda(v27, __ D, p0, z3);                   \/\/       fadda d27, p0, d27, z3.d\n+    __ sve_uaddv(v8, __ B, p6, z9);                    \/\/       uaddv d8, p6, z9.b\n@@ -1242,7 +1243,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003ff,     0x94000000,\n-    0x97ffffd4,     0x940003fc,     0x3400000a,     0x34fffa2a,\n-    0x34007f2a,     0x35000008,     0x35fff9c8,     0x35007ec8,\n-    0xb400000b,     0xb4fff96b,     0xb4007e6b,     0xb500001d,\n-    0xb5fff91d,     0xb5007e1d,     0x10000013,     0x10fff8b3,\n-    0x10007db3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307d36,     0x3758000c,     0x375ff7cc,     0x37587ccc,\n+    0x14000000,     0x17ffffd7,     0x14000400,     0x94000000,\n+    0x97ffffd4,     0x940003fd,     0x3400000a,     0x34fffa2a,\n+    0x34007f4a,     0x35000008,     0x35fff9c8,     0x35007ee8,\n+    0xb400000b,     0xb4fff96b,     0xb4007e8b,     0xb500001d,\n+    0xb5fff91d,     0xb5007e3d,     0x10000013,     0x10fff8b3,\n+    0x10007dd3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307d56,     0x3758000c,     0x375ff7cc,     0x37587cec,\n@@ -1253,13 +1254,13 @@\n-    0x54007aa0,     0x54000001,     0x54fff541,     0x54007a41,\n-    0x54000002,     0x54fff4e2,     0x540079e2,     0x54000002,\n-    0x54fff482,     0x54007982,     0x54000003,     0x54fff423,\n-    0x54007923,     0x54000003,     0x54fff3c3,     0x540078c3,\n-    0x54000004,     0x54fff364,     0x54007864,     0x54000005,\n-    0x54fff305,     0x54007805,     0x54000006,     0x54fff2a6,\n-    0x540077a6,     0x54000007,     0x54fff247,     0x54007747,\n-    0x54000008,     0x54fff1e8,     0x540076e8,     0x54000009,\n-    0x54fff189,     0x54007689,     0x5400000a,     0x54fff12a,\n-    0x5400762a,     0x5400000b,     0x54fff0cb,     0x540075cb,\n-    0x5400000c,     0x54fff06c,     0x5400756c,     0x5400000d,\n-    0x54fff00d,     0x5400750d,     0x5400000e,     0x54ffefae,\n-    0x540074ae,     0x5400000f,     0x54ffef4f,     0x5400744f,\n+    0x54007ac0,     0x54000001,     0x54fff541,     0x54007a61,\n+    0x54000002,     0x54fff4e2,     0x54007a02,     0x54000002,\n+    0x54fff482,     0x540079a2,     0x54000003,     0x54fff423,\n+    0x54007943,     0x54000003,     0x54fff3c3,     0x540078e3,\n+    0x54000004,     0x54fff364,     0x54007884,     0x54000005,\n+    0x54fff305,     0x54007825,     0x54000006,     0x54fff2a6,\n+    0x540077c6,     0x54000007,     0x54fff247,     0x54007767,\n+    0x54000008,     0x54fff1e8,     0x54007708,     0x54000009,\n+    0x54fff189,     0x540076a9,     0x5400000a,     0x54fff12a,\n+    0x5400764a,     0x5400000b,     0x54fff0cb,     0x540075eb,\n+    0x5400000c,     0x54fff06c,     0x5400758c,     0x5400000d,\n+    0x54fff00d,     0x5400752d,     0x5400000e,     0x54ffefae,\n+    0x540074ce,     0x5400000f,     0x54ffef4f,     0x5400746f,\n@@ -1496,3 +1497,3 @@\n-    0x049a2f8b,     0x045821a5,     0x04592542,     0x04482733,\n-    0x040a23a2,     0x65c72694,     0x65862dbc,     0x65983c2d,\n-    0x04c1207b,\n+    0x042c3b8b,     0x045a21a5,     0x04582542,     0x04592733,\n+    0x040823a2,     0x04ca2694,     0x65872dbc,     0x65863c2d,\n+    0x65d8207b,     0x04013928,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8293488\n+ * @summary Test EOR3 Neon\/SVE2 instruction for aarch64 SHA3 extension\n+ * @library \/test\/lib \/\n+ * @requires os.arch == \"aarch64\" & vm.cpu.features ~=\".*sha3.*\"\n+ * @run driver compiler.vectorization.TestEor3AArch64\n+ *\/\n+\n+public class TestEor3AArch64 {\n+\n+    private final static int LENGTH = 2048;\n+    private final static Random RD = Utils.getRandomInstance();\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ic;\n+    private static int[] ir;\n+\n+    private static long[] la;\n+    private static long[] lb;\n+    private static long[] lc;\n+    private static long[] lr;\n+\n+    static {\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        ir = new int[LENGTH];\n+\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        lc = new long[LENGTH];\n+        lr = new long[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = RD.nextInt(30);\n+            ib[i] = RD.nextInt(30);\n+            ic[i] = RD.nextInt(30);\n+\n+            la[i] = RD.nextLong(30);\n+            lb[i] = RD.nextLong(30);\n+            lc[i] = RD.nextLong(30);\n+        }\n+    }\n+\n+    \/\/ For the IR verification of \"veor3_sve\" backend node in the below tests,\n+    \/\/ \"svesha3\" CPU feature is supposed to be checked as it is an optional\n+    \/\/ feature in SVE2 but it is enabled in all the currently available SVE2\n+    \/\/ hardware. Hence that check is omitted.\n+\n+    \/\/ Test for eor3 Neon and SVE2 instruction for integers\n+    @Test\n+    @IR(counts = {\"veor3_neon\", \"> 0\"}, applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {\"veor3_sve\", \"> 0\"}, applyIfAnd = {\"UseSVE\", \"2\", \"MaxVectorSize\", \"> 16\"})\n+    public static void testIntEor3() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ir[i] = ia[i] ^ ib[i] ^ ic[i];\n+        }\n+    }\n+\n+    @Run(test = \"testIntEor3\")\n+    public static void testIntEor3_runner() {\n+        testIntEor3();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((ia[i] ^ ib[i] ^ ic[i]), ir[i]);\n+        }\n+    }\n+\n+    \/\/ Test for eor3 Neon and SVE2 instruction for longs\n+    @Test\n+    @IR(counts = {\"veor3_neon\", \"> 0\"}, applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {\"veor3_sve\", \"> 0\"}, applyIfAnd = {\"UseSVE\", \"2\", \"MaxVectorSize\", \"> 16\"})\n+    public static void testLongEor3() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            lr[i] = la[i] ^ lb[i] ^ lc[i];\n+        }\n+    }\n+\n+    @Run(test = \"testLongEor3\")\n+    public static void testLongEor3_runner() {\n+        testLongEor3();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((la[i] ^ lb[i] ^ lc[i]), lr[i]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestEor3AArch64.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class TestEor3 {\n+    @Param({\"2048\"})\n+    private int LENGTH;\n+\n+    private int[] ia;\n+    private int[] ib;\n+    private int[] ic;\n+    private int[] id;\n+\n+    private long[] la;\n+    private long[] lb;\n+    private long[] lc;\n+    private long[] ld;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random random = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        id = new int[LENGTH];\n+\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        lc = new long[LENGTH];\n+        ld = new long[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = random.nextInt();\n+            ib[i] = random.nextInt();\n+            ic[i] = random.nextInt();\n+\n+            la[i] = random.nextLong();\n+            lb[i] = random.nextLong();\n+            lc[i] = random.nextLong();\n+        }\n+    }\n+\n+    \/\/ Test EOR3 for int arrays\n+    @Benchmark\n+    public void test1Int() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            id[i] = ia[i] ^ ib[i] ^ ic[i];\n+        }\n+    }\n+\n+    \/\/ Test EOR3 for int arrays with multiple eor operations\n+    @Benchmark\n+    public void test2Int() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            id[i] = ia[i] ^ ib[i] ^ ic[i] ^ ia[i] ^ ib[i];\n+        }\n+    }\n+\n+    \/\/ Test EOR3 for long arrays\n+    @Benchmark\n+    public void test1Long() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ld[i] = la[i] ^ lb[i] ^ lc[i];\n+        }\n+    }\n+\n+    \/\/ Test EOR3 for long arrays with multiple eor operations\n+    @Benchmark\n+    public void test2Long() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ld[i] = la[i] ^ lb[i] ^ lc[i] ^ la[i] ^ lb[i];\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TestEor3.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}