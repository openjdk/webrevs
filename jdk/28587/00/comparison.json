{"files":[{"patch":"@@ -160,5 +160,14 @@\n-    if ( error == JVMTI_ERROR_THREAD_NOT_ALIVE && node == NULL) {\n-        \/* Just return. This can happen when clearing the TLS. *\/\n-        return;\n-    } else if ( error != JVMTI_ERROR_NONE ) {\n-        \/* The jthread object must be valid, so this must be a fatal error *\/\n+    if (error == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+        if (node == NULL) {\n+            \/\/ Just return. This can happen when clearing the TLS.\n+            return;\n+        }\n+        if (isVThread(thread)) {\n+            \/\/ Just return. This can happen with a vthread that is running and we\n+            \/\/ had to create a ThreadNode for it. By the time we get here, it may\n+            \/\/ have already terminated.\n+            return;\n+        }\n+    }\n+    if (error != JVMTI_ERROR_NONE) {\n+        \/\/ The jthread object must be valid, so this must be a fatal error.\n@@ -254,1 +263,3 @@\n-            \/* The thread better not be on either list if the TLS lookup failed. *\/\n+            \/\/ The thread better not be on the runningThreads list if the TLS lookup failed.\n+            \/\/ It might be on the runningVThreads list because of how ThreadNodes for vthreads\n+            \/\/ can be recreated just before terminating, so we don't check runningVThreads.\n@@ -256,1 +267,0 @@\n-            JDI_ASSERT(!nonTlsSearch(getEnv(), &runningVThreads, thread));\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"}]}