{"files":[{"patch":"@@ -1282,4 +1282,0 @@\n-  \/\/ We should not be starting a concurrent start pause if the concurrent mark\n-  \/\/ thread is terminating.\n-  assert(!_g1h->concurrent_mark_is_terminating(), \"Should not reach here\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1015,8 +1015,0 @@\n-      \/\/ Old comment for situation that does not arise:\n-      \/\/\n-      \/\/ There is one exception: shutdown might have aborted the Concurrent Cleanup for Next\n-      \/\/ Mark phase midway, which might have also left stale marks in old generation regions.\n-      \/\/ There might actually have been scheduled multiple collections, but at that point we do\n-      \/\/ not care that much about performance and just do the work multiple times if needed.\n-      assert(!_g1h->concurrent_mark_is_terminating(), \"Should not reach here\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -142,1 +142,6 @@\n-  \/\/ Queried value of CollectedHeap::is_shutting_down while holding the Heap_lock.\n+  \/\/ This function returns the value of CollectedHeap::is_shutting_down() that\n+  \/\/ was recorded in the prologue. Unlike, CollectedHeap::is_shutting_down(),\n+  \/\/ this function can be called without acquiring the Heap_lock.\n+  \/\/\n+  \/\/ This funciton exists so that code that tries to schedule a GC operation\n+  \/\/ can check if it was refused because the JVM is about to shut down.\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  assert(!Universe::is_shutting_down(), \"Should not query during shutdown\");\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}