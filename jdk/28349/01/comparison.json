{"files":[{"patch":"@@ -481,5 +481,0 @@\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n-\n@@ -741,5 +736,0 @@\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n-\n@@ -1648,0 +1638,4 @@\n+bool G1CollectedHeap::concurrent_mark_is_terminating() const {\n+  return _cm_thread->should_terminate();\n+}\n+\n@@ -1968,2 +1962,2 @@\n-    \/\/ we're terminating, then we're done.\n-    if (is_shutting_down()) {\n+    \/\/ we're shutting down, then we're done.\n+    if (op.is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -920,0 +920,3 @@\n+  \/\/ Returns whether concurrent mark threads (and the VM) are about to terminate.\n+  bool concurrent_mark_is_terminating() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1886,1 +1886,1 @@\n-  if (!cm_thread()->in_progress() && !_g1h->is_shutting_down()) {\n+  if (!cm_thread()->in_progress() && !_g1h->concurrent_mark_is_terminating()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,1 +672,0 @@\n-  assert(!_g1h->is_shutting_down(), \"Invariant!\");\n@@ -1283,6 +1282,0 @@\n-  \/\/ We should not be starting a concurrent start pause if the concurrent mark\n-  \/\/ thread is terminating.\n-  if (_g1h->is_shutting_down()) {\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1021,8 +1021,2 @@\n-      \/\/\n-      \/\/ There is one exception: shutdown might have aborted the Concurrent Cleanup for Next\n-      \/\/ Mark phase midway, which might have also left stale marks in old generation regions.\n-      \/\/ There might actually have been scheduled multiple collections, but at that point we do\n-      \/\/ not care that much about performance and just do the work multiple times if needed.\n-      return (_g1h->collector_state()->clear_bitmap_in_progress() ||\n-              _g1h->is_shutting_down()) &&\n-              hr->is_old();\n+      return _g1h->collector_state()->clear_bitmap_in_progress() &&\n+             hr->is_old();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -347,5 +347,0 @@\n-\n-      if (is_shutting_down()) {\n-        stall_for_vm_shutdown();\n-        return nullptr;\n-      }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -340,5 +340,0 @@\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+bool CollectedHeap::_is_shutting_down = false;\n+\n@@ -389,5 +391,0 @@\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n-\n@@ -608,2 +605,3 @@\n-bool CollectedHeap::is_shutting_down() const {\n-  return Universe::is_shutting_down();\n+bool CollectedHeap::is_shutting_down() {\n+  assert(Heap_lock->owned_by_self(), \"Protected by this lock\");\n+  return _is_shutting_down;\n@@ -612,14 +610,7 @@\n-void CollectedHeap::stall_for_vm_shutdown() {\n-  assert(is_shutting_down(), \"Precondition\");\n-  \/\/ Stall the thread (2 seconds) instead of an indefinite wait to avoid deadlock\n-  \/\/ if the VM shutdown triggers a GC.\n-  \/\/ The 2-seconds sleep is:\n-  \/\/   - long enough to keep daemon threads stalled, while the shutdown\n-  \/\/     sequence completes in the common case.\n-  \/\/   - short enough to avoid excessive stall time if the shutdown itself\n-  \/\/     triggers a GC.\n-  JavaThread::current()->sleep(2 * MILLIUNITS);\n-\n-  ResourceMark rm;\n-  log_warning(gc, alloc)(\"%s: Stall for VM-Shutdown timed out; allocation may fail with OOME\", Thread::current()->name());\n-}\n+void CollectedHeap::initiate_shutdown() {\n+  {\n+    \/\/ Acquire the Heap_lock to synchronize with VM_Heap_Sync_Operations,\n+    \/\/ which may depend on the value of _is_shutting_down flag.\n+    MutexLocker hl(Heap_lock);\n+    _is_shutting_down = true;\n+  }\n@@ -627,1 +618,0 @@\n-void CollectedHeap::before_exit() {\n@@ -629,3 +619,0 @@\n-\n-  \/\/ Stop any on-going concurrent work and prepare for exit.\n-  stop();\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":12,"deletions":25,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+  static bool _is_shutting_down;\n+\n@@ -212,0 +214,1 @@\n+ public:\n@@ -215,2 +218,0 @@\n- public:\n-\n@@ -248,6 +249,1 @@\n-  bool is_shutting_down() const;\n-\n-  \/\/ If the VM is shutting down, we may have skipped VM_CollectForAllocation.\n-  \/\/ In this case, stall the allocation request briefly in the hope that\n-  \/\/ the VM shutdown completes before the allocation request returns.\n-  void stall_for_vm_shutdown();\n+  static bool is_shutting_down();\n@@ -255,1 +251,1 @@\n-  void before_exit();\n+  void initiate_shutdown();\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -95,0 +95,12 @@\n+static void block_if_java_thread() {\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    \/\/ Block here and allow the shutdown to complete\n+    while (true) {\n+      Heap_lock->wait();\n+    }\n+  } else {\n+    assert(thread->is_ConcurrentGC_thread(), \"Unexpected thread type\");\n+  }\n+}\n+\n@@ -113,0 +125,7 @@\n+  _is_shutting_down = CollectedHeap::is_shutting_down();\n+  if (_is_shutting_down) {\n+    \/\/ Block forever if a Java thread is triggering a GC after\n+    \/\/ the GC have started to shut down.\n+    block_if_java_thread();\n+  }\n+\n@@ -114,1 +133,1 @@\n-  if (skip_operation() || Universe::is_shutting_down()) {\n+  if (skip_operation() || _is_shutting_down) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+  bool           _is_shutting_down;        \/\/ whether the operation found that the GC is shutting down\n@@ -119,1 +120,1 @@\n-                  GCCause::Cause _cause,\n+                  GCCause::Cause cause,\n@@ -121,9 +122,8 @@\n-                  bool full) : VM_Heap_Sync_Operation() {\n-    _full = full;\n-    _prologue_succeeded = false;\n-    _gc_count_before    = gc_count_before;\n-\n-    _gc_cause           = _cause;\n-\n-    _full_gc_count_before = full_gc_count_before;\n-  }\n+                  bool full)\n+    : VM_Heap_Sync_Operation(),\n+      _gc_count_before(gc_count_before),\n+      _full_gc_count_before(full_gc_count_before),\n+      _full(full),\n+      _prologue_succeeded(false),\n+      _is_shutting_down(false),\n+      _gc_cause(cause) {}\n@@ -142,0 +142,8 @@\n+  \/\/ This function returns the value of CollectedHeap::is_shutting_down() that\n+  \/\/ was recorded in the prologue. Unlike, CollectedHeap::is_shutting_down(),\n+  \/\/ this function can be called without acquiring the Heap_lock.\n+  \/\/\n+  \/\/ This funciton exists so that code that tries to schedule a GC operation\n+  \/\/ can check if it was refused because the JVM is about to shut down.\n+  bool is_shutting_down() const { return _is_shutting_down; }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -185,1 +185,0 @@\n-volatile bool   Universe::_is_shutting_down = false;\n@@ -1377,7 +1376,5 @@\n-  {\n-    \/\/ Acquire the Heap_lock to synchronize with VM_Heap_Sync_Operations,\n-    \/\/ which may depend on the value of _is_shutting_down flag.\n-    MutexLocker hl(Heap_lock);\n-    log_cpu_time();\n-    AtomicAccess::release_store(&_is_shutting_down, true);\n-  }\n+  \/\/ Tell the GC that it is time to shutdown and to block requests for new GC pauses.\n+  heap()->initiate_shutdown();\n+\n+  \/\/ Log CPU time statistics before stopping the GC threads.\n+  log_cpu_time();\n@@ -1385,1 +1382,2 @@\n-  heap()->before_exit();\n+  \/\/ Stop the GC threads.\n+  heap()->stop();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -131,3 +131,0 @@\n-  \/\/ Shutdown\n-  static volatile bool _is_shutting_down;\n-\n@@ -331,2 +328,0 @@\n-  static bool is_shutting_down()                  { return  AtomicAccess::load_acquire(&_is_shutting_down); }\n-\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  assert(!Universe::is_shutting_down(), \"Should not query during shutdown\");\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}