{"files":[{"patch":"@@ -273,2 +273,2 @@\n-        \/\/ Wait a second, then recheck for timeout.\n-        os::naked_short_sleep(999);\n+        \/\/ Wait a bit, then recheck for timeout.\n+        os::naked_short_sleep(250);\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n@@ -1747,3 +1748,13 @@\n-\/\/ Timeout handling: check if a timeout happened (either a single step did\n-\/\/ timeout or the whole of error reporting hit ErrorLogTimeout). Interrupt\n-\/\/ the reporting thread if that is the case.\n+\/\/ Fatal error handling is subject to several timeouts:\n+\/\/ - a global timeout (controlled via ErrorLogTimeout)\n+\/\/ - local error reporting step timeouts.\n+\/\/\n+\/\/ The latter aims to \"give the JVM a kick\" if it gets stuck in one particular place during\n+\/\/ error reporting. This prevents one error reporting step from hogging all the time allotted\n+\/\/ to error reporting under ErrorLogTimeout.\n+\/\/\n+\/\/ VMError::check_timeout() is called from the watcher thread and checks for either global\n+\/\/ or step timeout. If a timeout happened, we interrupt the reporting thread and set either\n+\/\/ _reporting_did_timeout or _step_did_timeout to signal which timeout fired. Function returns\n+\/\/ true if the *global* timeout fired, which will cause WatcherThread to shut down the JVM\n+\/\/ immediately.\n@@ -1752,0 +1763,4 @@\n+  \/\/ This function is supposed to be called from watcher thread during fatal error handling only.\n+  assert(VMError::is_error_reported(), \"Only call during error handling\");\n+  assert(Thread::current()->is_Watcher_thread(), \"Only call from watcher thread\");\n+\n@@ -1756,7 +1771,11 @@\n-  \/\/ Do not check for timeouts if we still have a message box to show to the\n-  \/\/ user or if there are OnError handlers to be run.\n-  if (ShowMessageBoxOnError\n-      || (OnError != nullptr && OnError[0] != '\\0')\n-      || Arguments::abort_hook() != nullptr) {\n-    return false;\n-  }\n+  \/\/ There are three situations where we suppress the *global* error timeout:\n+  \/\/ - if the JVM is embedded and the launcher has its abort hook installed.\n+  \/\/   That must be allowed to run.\n+  \/\/ - if the user specified one or more OnError commands to run, and these\n+  \/\/   did not yet run. These must have finished.\n+  \/\/ - if the user (typically developer) specified ShowMessageBoxOnError,\n+  \/\/   and the error box has not yet been shown\n+  const bool ignore_global_timeout =\n+      (ShowMessageBoxOnError\n+            || (OnError != nullptr && OnError[0] != '\\0')\n+            || Arguments::abort_hook() != nullptr);\n@@ -1764,1 +1783,0 @@\n-  const jlong reporting_start_time_l = get_reporting_start_time();\n@@ -1766,9 +1784,14 @@\n-  \/\/ Timestamp is stored in nanos.\n-  if (reporting_start_time_l > 0) {\n-    const jlong end = reporting_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR;\n-    if (end <= now && !_reporting_did_timeout) {\n-      \/\/ We hit ErrorLogTimeout and we haven't interrupted the reporting\n-      \/\/ thread yet.\n-      _reporting_did_timeout = true;\n-      interrupt_reporting_thread();\n-      return true; \/\/ global timeout\n+\n+  \/\/ Global timeout hit?\n+  if (!ignore_global_timeout) {\n+    const jlong reporting_start_time_l = get_reporting_start_time();\n+    \/\/ Timestamp is stored in nanos.\n+    if (reporting_start_time_l > 0) {\n+      const jlong end = reporting_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR;\n+      if (end <= now && !_reporting_did_timeout) {\n+        \/\/ We hit ErrorLogTimeout and we haven't interrupted the reporting\n+        \/\/ thread yet.\n+        _reporting_did_timeout = true;\n+        interrupt_reporting_thread();\n+        return true; \/\/ global timeout\n+      }\n@@ -1778,0 +1801,1 @@\n+  \/\/ Reporting step timeout?\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":44,"deletions":20,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n@@ -29,0 +30,3 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n@@ -36,1 +40,1 @@\n- * @test\n+ * @test TimeoutInErrorHandlingTest-default\n@@ -46,0 +50,10 @@\n+\/*\n+ * @test TimeoutInErrorHandlingTest-with-on-error\n+ * @bug 8303861\n+ * @summary Error handling step timeouts should never be blocked by OnError etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires (vm.debug == true) & (os.family != \"windows\")\n+ * @run driver TimeoutInErrorHandlingTest with-on-error\n+ *\/\n+\n@@ -74,8 +88,22 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            \"-XX:+UnlockDiagnosticVMOptions\",\n-            \"-Xmx100M\",\n-            \"-XX:ErrorHandlerTest=14\",\n-            \"-XX:+TestUnresponsiveErrorHandler\",\n-            \"-XX:ErrorLogTimeout=\" + ERROR_LOG_TIMEOUT,\n-            \"-XX:-CreateCoredumpOnCrash\",\n-            \"-version\");\n+        boolean withOnError = false;\n+\n+        if (args.length > 0) {\n+            switch (args[0]) {\n+                case \"with-on-error\": withOnError = true; break;\n+                default: throw new RuntimeException(\"Invalid argument \" + args[1]);\n+            }\n+        }\n+\n+        List<String> arguments = new ArrayList<>();\n+        Collections.addAll(arguments,\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-Xmx100M\",\n+                \"-XX:ErrorHandlerTest=14\",\n+                \"-XX:+TestUnresponsiveErrorHandler\",\n+                \"-XX:ErrorLogTimeout=\" + ERROR_LOG_TIMEOUT,\n+                \"-XX:-CreateCoredumpOnCrash\");\n+        if (withOnError) {\n+            arguments.add(\"-XX:OnError=echo hi\");\n+        }\n+        arguments.add(\"-version\");\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(arguments);\n@@ -95,2 +123,4 @@\n-        \/\/ VM should have been aborted by WatcherThread\n-        output_detail.shouldMatch(\".*timer expired, abort.*\");\n+        \/\/ Unless we specified OnError, VM should have been aborted by WatcherThread\n+        if (!withOnError) {\n+            output_detail.shouldMatch(\".*timer expired, abort.*\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TimeoutInErrorHandlingTest.java","additions":41,"deletions":11,"binary":false,"changes":52,"status":"modified"}]}