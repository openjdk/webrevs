{"files":[{"patch":"@@ -1610,0 +1610,3 @@\n+  \/\/ NOTE: PLEASE DON'T USE IT NAKED UNTIL WE DROP SUPPORT FOR MACHINES OLDER THAN Z15!!!!\n+  inline void z_popcnt(Register r1, Register r2, int64_t m3);   \/\/ population count\n+\n@@ -3095,1 +3098,0 @@\n-  inline void z_popcnt(Register r1, Register r2);   \/\/ population count\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -744,1 +744,1 @@\n-inline void Assembler::z_popcnt(Register r1, Register r2)              { emit_32( POPCNT_ZOPC | reg(r1, 24, 32) | reg(r2, 28, 32)); }\n+inline void Assembler::z_popcnt(Register r1, Register r2, int64_t  m3) { emit_32( POPCNT_ZOPC | reg(r1, 24, 32) | reg(r2, 28, 32) | uimm4(m3, 16, 32)); }\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5806,0 +5806,89 @@\n+\n+void MacroAssembler::pop_count_int(Register r_dst, Register r_src, Register r_tmp) {\n+  BLOCK_COMMENT(\"pop_count_int {\");\n+\n+  assert(r_tmp != noreg, \"temp register required for pop_count_int, as code may run on machine older than z15\");\n+  assert_different_registers(r_dst, r_tmp); \/\/ if r_src is same as r_tmp, it should be fine\n+\n+  if (VM_Version::has_MiscInstrExt3()) {\n+    pop_count_int_post_z15(r_dst, r_src);\n+  } else {\n+    pop_count_int_pre_z15(r_dst, r_src, r_tmp);\n+  }\n+\n+  BLOCK_COMMENT(\"} pop_count_int\");\n+}\n+\n+void MacroAssembler::pop_count_long(Register r_dst, Register r_src, Register r_tmp) {\n+  BLOCK_COMMENT(\"pop_count_long {\");\n+\n+  assert(r_tmp != noreg, \"temp register required for pop_count_long, as code may run on machine older than z15\");\n+  assert_different_registers(r_dst, r_tmp); \/\/ if r_src is same as r_tmp, it should be fine\n+\n+  if (VM_Version::has_MiscInstrExt3()) {\n+    pop_count_long_post_z15(r_dst, r_src);\n+  } else {\n+    pop_count_long_pre_z15(r_dst, r_src, r_tmp);\n+  }\n+\n+  BLOCK_COMMENT(\"} pop_count_long\");\n+}\n+\n+void MacroAssembler::pop_count_int_pre_z15(Register r_dst, Register r_src, Register r_tmp) {\n+  BLOCK_COMMENT(\"pop_count_int_pre_z15 {\");\n+\n+  assert(r_tmp != noreg, \"temp register required for popcnt, for machines < z15\");\n+  assert_different_registers(r_dst, r_tmp); \/\/ if r_src is same as r_tmp, it should be fine\n+\n+  z_popcnt(r_dst, r_src, 0);\n+  z_srlg(r_tmp, r_dst, 16);\n+  z_alr(r_dst, r_tmp);\n+  z_srlg(r_tmp, r_dst, 8);\n+  z_alr(r_dst, r_tmp);\n+  \/\/ TODO: use risbgn instruction instead of srl below\n+  z_llgcr(r_dst, r_dst);\n+\n+  BLOCK_COMMENT(\"} pop_count_int_pre_z15\");\n+}\n+\n+void MacroAssembler::pop_count_long_pre_z15(Register r_dst, Register r_src, Register r_tmp) {\n+  BLOCK_COMMENT(\"pop_count_long_pre_z15 {\");\n+\n+  assert(r_tmp != noreg, \"temp register required for popcnt, for machines < z15\");\n+  assert_different_registers(r_dst, r_tmp); \/\/ if r_src is same as r_tmp, it should be fine\n+\n+  z_popcnt(r_dst, r_src, 0);\n+  z_ahhlr(r_dst, r_dst, r_dst);\n+  z_sllg(r_tmp, r_dst, 16);\n+  z_algr(r_dst, r_tmp);\n+  z_sllg(r_tmp, r_dst, 8);\n+  z_algr(r_dst, r_tmp);\n+  z_srlg(r_dst, r_dst, 56);\n+\n+  BLOCK_COMMENT(\"} pop_count_long_pre_z15\");\n+}\n+\n+void MacroAssembler::pop_count_long_post_z15(Register r_dst, Register r_src) {\n+  BLOCK_COMMENT(\"pop_count_long_post_z15 {\");\n+\n+  if (VM_Version::has_MiscInstrExt3()) {\n+    z_popcnt(r_dst, r_src, 8);\n+  } else {\n+    stop(\"this hardware doesn't support miscellaneous-instruction-extensions facility 3, still pop_count_long_post_z15 is used\");\n+  }\n+\n+  BLOCK_COMMENT(\"} pop_count_long_post_z15\");\n+}\n+\n+void MacroAssembler::pop_count_int_post_z15(Register r_dst, Register r_src) {\n+  BLOCK_COMMENT(\"pop_count_int_post_z15 {\");\n+\n+  if (VM_Version::has_MiscInstrExt3()) {\n+    z_llgfr(r_dst, r_src);\n+    z_popcnt(r_dst, r_dst, 8);\n+  } else {\n+    stop(\"this hardware doesn't support miscellaneous-instruction-extensions facility 3, still pop_count_int_post_z15 is used\");\n+  }\n+\n+  BLOCK_COMMENT(\"} pop_count_int_post_z15\");\n+}\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,2 +2,3 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n+ * Copyright (c) 2024 IBM Corporation. All rights reserved.\n@@ -1024,0 +1025,16 @@\n+\n+  \/\/ if you're unsure whether your instruction will run on older hardware or newer hardware than Z15\n+  \/\/ then please use these instruction to avoid the compatibility issues\n+  void pop_count_int(Register dst, Register src, Register tmp);\n+  void pop_count_long(Register dst, Register src, Register tmp);\n+\n+  \/\/ Up for an adventure ? use these instructions :)\n+  \/\/ Should be only used when you're sure that instruction will \"only\" run on hardware older than z15\n+  void pop_count_int_pre_z15(Register dst, Register src, Register tmp);\n+  void pop_count_long_pre_z15(Register dst, Register src, Register tmp);\n+\n+  \/\/ Should be used in a case, where you're sure that instruction will never touch a hardware older than z15\n+  \/\/ it will only run on either a z15 machine or successor of it\n+  void pop_count_int_post_z15(Register dst, Register src);\n+  void pop_count_long_post_z15(Register dst, Register src);\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -10678,0 +10678,37 @@\n+instruct popCountI_Ext3(iRegI dst, iRegI src, flagsReg cr) %{\n+  match(Set dst (PopCountI src));\n+  effect(TEMP_DEF dst, KILL cr);\n+  predicate(UsePopCountInstruction &&\n+            VM_Version::has_PopCount() &&\n+            VM_Version::has_MiscInstrExt3());\n+  ins_cost(DEFAULT_COST);\n+  size(8); \/\/ popcnt + llgfr\n+  format %{ \"POPCNT  $dst,$src\\t # pop count int\" %}\n+  ins_encode %{\n+    Register Rdst = $dst$$Register;\n+    Register Rsrc = $src$$Register;\n+\n+    __ pop_count_int_post_z15(Rdst, Rsrc);\n+\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct popCountL_Ext3(iRegI dst, iRegL src, flagsReg cr) %{\n+  match(Set dst (PopCountL src));\n+  effect(TEMP_DEF dst, KILL cr);\n+  predicate(UsePopCountInstruction &&\n+            VM_Version::has_PopCount() &&\n+            VM_Version::has_MiscInstrExt3());\n+  ins_cost(DEFAULT_COST);\n+  size(4); \/\/ popcnt\n+  format %{ \"POPCNT  $dst,$src\\t # pop count long\" %}\n+  ins_encode %{\n+    Register Rdst = $dst$$Register;\n+    Register Rsrc = $src$$Register;\n+\n+    __ pop_count_long_post_z15(Rdst, Rsrc);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -10681,1 +10718,3 @@\n-  predicate(UsePopCountInstruction && VM_Version::has_PopCount());\n+  predicate(UsePopCountInstruction &&\n+            VM_Version::has_PopCount() &&\n+            (!VM_Version::has_MiscInstrExt3()));\n@@ -10690,3 +10729,1 @@\n-    \/\/ Prefer compile-time assertion over run-time SIGILL.\n-    assert(VM_Version::has_PopCount(), \"bad predicate for countLeadingZerosI\");\n-    assert_different_registers(Rdst, Rtmp);\n+    __ pop_count_int_pre_z15(Rdst, Rsrc, Rtmp);\n@@ -10694,7 +10731,0 @@\n-    \/\/ Version 2: shows 10%(z196) improvement over original.\n-    __ z_popcnt(Rdst, Rsrc);\n-    __ z_srlg(Rtmp, Rdst, 16); \/\/ calc  byte4+byte6 and byte5+byte7\n-    __ z_alr(Rdst, Rtmp);      \/\/   into byte6 and byte7\n-    __ z_srlg(Rtmp, Rdst,  8); \/\/ calc (byte4+byte6) + (byte5+byte7)\n-    __ z_alr(Rdst, Rtmp);      \/\/   into byte7\n-    __ z_llgcr(Rdst, Rdst);    \/\/ zero-extend sum\n@@ -10708,1 +10738,3 @@\n-  predicate(UsePopCountInstruction && VM_Version::has_PopCount());\n+  predicate(UsePopCountInstruction &&\n+            VM_Version::has_PopCount() &&\n+            (!VM_Version::has_MiscInstrExt3()));\n@@ -10710,1 +10742,1 @@\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n+  size(34);\n@@ -10717,12 +10749,1 @@\n-    \/\/ Prefer compile-time assertion over run-time SIGILL.\n-    assert(VM_Version::has_PopCount(), \"bad predicate for countLeadingZerosI\");\n-    assert_different_registers(Rdst, Rtmp);\n-\n-    \/\/ Original version. Using LA instead of algr seems to be a really bad idea (-35%).\n-    __ z_popcnt(Rdst, Rsrc);\n-    __ z_ahhlr(Rdst, Rdst, Rdst);\n-    __ z_sllg(Rtmp, Rdst, 16);\n-    __ z_algr(Rdst, Rtmp);\n-    __ z_sllg(Rtmp, Rdst,  8);\n-    __ z_algr(Rdst, Rtmp);\n-    __ z_srlg(Rdst, Rdst, 56);\n+    __ pop_count_long_pre_z15(Rdst, Rsrc, Rtmp);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":46,"deletions":25,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 5)\n+public class PopCount {\n+    int numTests = 100_000;\n+\n+    @Benchmark\n+    public long test() {\n+        long l1 = 1, l2 = 2, l3 = 3, l4 = 4, l5 = 5, l6 = 6, l7 = 7, l8 = 9, l9 = 9, l10 = 10;\n+        for (long i = 0; i < numTests; i++) {\n+            l1 ^= Long.bitCount(l1) + i;\n+            l2 ^= Long.bitCount(l2) + i;\n+            l3 ^= Long.bitCount(l3) + i;\n+            l4 ^= Long.bitCount(l4) + i;\n+            l5 ^= Long.bitCount(l5) + i;\n+            l6 ^= Long.bitCount(l6) + i;\n+            l7 ^= Long.bitCount(l7) + i;\n+            l8 ^= Long.bitCount(l8) + i;\n+            l9 ^= Long.bitCount(l9) + i;\n+            l10 ^= Long.bitCount(l10) + i;\n+        }\n+        return l1 + l2 + l3 + l4 + l5 + l6 + l7 + l8 + l9 + l10;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/PopCount.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}