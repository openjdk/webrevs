{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"gc\/g1\/g1CodeRootSetTable.hpp\"\n@@ -42,31 +41,2 @@\n-size_t G1CodeRootSetTable::mem_size() {\n-  return sizeof(G1CodeRootSetTable) + (entry_size() * number_of_entries()) + (sizeof(HashtableBucket<mtGC>) * table_size());\n-}\n-\n-G1CodeRootSetTable::Entry* G1CodeRootSetTable::new_entry(nmethod* nm) {\n-  unsigned int hash = compute_hash(nm);\n-  return (Entry*)Hashtable<nmethod*, mtGC>::new_entry(hash, nm);\n-}\n-\n-void G1CodeRootSetTable::remove_entry(Entry* e, Entry* previous) {\n-  int index = hash_to_index(e->hash());\n-  assert((e == bucket(index)) == (previous == NULL), \"if e is the first entry then previous should be null\");\n-\n-  if (previous == NULL) {\n-    set_entry(index, e->next());\n-  } else {\n-    previous->set_next(e->next());\n-  }\n-  free_entry(e);\n-}\n-\n-G1CodeRootSetTable::~G1CodeRootSetTable() {\n-  for (int index = 0; index < table_size(); ++index) {\n-    for (Entry* e = bucket(index); e != NULL; ) {\n-      Entry* to_remove = e;\n-      \/\/ read next before freeing.\n-      e = e->next();\n-      BasicHashtable<mtGC>::free_entry(to_remove);\n-    }\n-  }\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n+size_t G1CodeRootSetTable::mem_size() const {\n+  return sizeof(*this) + _table.mem_size() - sizeof(_table); \/\/ do not double count _table\n@@ -77,3 +47,1 @@\n-    Entry* e = new_entry(nm);\n-    int index = hash_to_index(e->hash());\n-    add_entry(index, e);\n+    _table.put(nm, nm);\n@@ -86,7 +54,1 @@\n-  int index = hash_to_index(compute_hash(nm));\n-  for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-    if (e->literal() == nm) {\n-      return true;\n-    }\n-  }\n-  return false;\n+  return _table.contains(nm);\n@@ -96,9 +58,1 @@\n-  int index = hash_to_index(compute_hash(nm));\n-  Entry* previous = NULL;\n-  for (Entry* e = bucket(index); e != NULL; previous = e, e = e->next()) {\n-    if (e->literal() == nm) {\n-      remove_entry(e, previous);\n-      return true;\n-    }\n-  }\n-  return false;\n+  return _table.remove(nm);\n@@ -108,5 +62,3 @@\n-  for (int index = 0; index < table_size(); ++index) {\n-    for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-      new_table->add(e->literal());\n-    }\n-  }\n+  _table.iterate_all([&new_table](nmethod* nm, nmethod* _) {\n+    new_table->add(nm);\n+  });\n@@ -116,5 +68,3 @@\n-  for (int index = 0; index < table_size(); ++index) {\n-    for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-      blk->do_code_blob(e->literal());\n-    }\n-  }\n+  _table.iterate_all([&](nmethod* nm, nmethod* _) {\n+    blk->do_code_blob(nm);\n+  });\n@@ -123,18 +73,2 @@\n-template<typename CB>\n-int G1CodeRootSetTable::remove_if(CB& should_remove) {\n-  int num_removed = 0;\n-  for (int index = 0; index < table_size(); ++index) {\n-    Entry* previous = NULL;\n-    Entry* e = bucket(index);\n-    while (e != NULL) {\n-      Entry* next = e->next();\n-      if (should_remove(e->literal())) {\n-        remove_entry(e, previous);\n-        ++num_removed;\n-      } else {\n-        previous = e;\n-      }\n-      e = next;\n-    }\n-  }\n-  return num_removed;\n+void G1CodeRootSetTable::remove_if(CleanCallback& should_remove) {\n+  _table.unlink(&should_remove);\n@@ -178,0 +112,1 @@\n+  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n@@ -196,0 +131,1 @@\n+  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n@@ -202,1 +138,1 @@\n-    if (_length == Threshold) {\n+    if (length() == Threshold) {\n@@ -205,1 +141,0 @@\n-    ++_length;\n@@ -207,1 +142,0 @@\n-  assert(_length == (size_t)_table->number_of_entries(), \"sizes should match\");\n@@ -211,0 +145,1 @@\n+  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n@@ -216,2 +151,1 @@\n-    _length--;\n-    if (_length == 0) {\n+    if (length() == 0) {\n@@ -221,2 +155,0 @@\n-  assert((_length == 0 && _table == NULL) ||\n-         (_length == (size_t)_table->number_of_entries()), \"sizes should match\");\n@@ -235,0 +167,1 @@\n+  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n@@ -237,1 +170,0 @@\n-  _length = 0;\n@@ -245,0 +177,1 @@\n+  DEBUG_ONLY(_iteration_thread = Thread::current();)\n@@ -248,0 +181,1 @@\n+  DEBUG_ONLY(_iteration_thread = nullptr;)\n@@ -251,0 +185,1 @@\n+  NONCOPYABLE(CleanCallback); \/\/ can not copy, _blobs will point to old copy\n@@ -279,1 +214,1 @@\n-  bool operator() (nmethod* nm) {\n+  bool do_entry(nmethod* nm, nmethod* _) {\n@@ -287,0 +222,1 @@\n+  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n@@ -289,3 +225,1 @@\n-    int removed = _table->remove_if(should_clean);\n-    assert((size_t)removed <= _length, \"impossible\");\n-    _length -= removed;\n+    _table->remove_if(should_clean);\n@@ -293,1 +227,1 @@\n-  if (_length == 0) {\n+  if (length() == 0) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.cpp","additions":27,"deletions":93,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,6 @@\n+#include \"code\/codeCache.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class CleanCallback;\n@@ -35,0 +41,35 @@\n+class G1CodeRootSetTable : public CHeapObj<mtGC>  {\n+  friend class G1CodeRootSetTest;\n+\n+  static G1CodeRootSetTable* volatile _purge_list;\n+\n+  using Table = ResizeableResourceHashtable<nmethod*, nmethod*, AnyObj::C_HEAP, mtGC>;\n+  Table _table;\n+  G1CodeRootSetTable* _purge_next;\n+\n+ public:\n+  G1CodeRootSetTable(int size) : _table(size, size), _purge_next(NULL) {}\n+  \/\/ Needs to be protected by locks\n+  bool add(nmethod* nm);\n+  bool remove(nmethod* nm);\n+\n+  \/\/ Can be called without locking\n+  bool contains(nmethod* nm);\n+\n+  void copy_to(G1CodeRootSetTable* new_table);\n+  void nmethods_do(CodeBlobClosure* blk);\n+\n+  void remove_if(CleanCallback& should_remove);\n+  int number_of_entries() const {return _table.number_of_entries();}\n+\n+  static void purge_list_append(G1CodeRootSetTable* tbl);\n+  static void purge();\n+\n+  static size_t static_mem_size() {\n+    return sizeof(_purge_list);\n+  }\n+\n+  size_t mem_size() const;\n+};\n+\n+\n@@ -48,2 +89,0 @@\n-  size_t _length;\n-\n@@ -52,0 +91,1 @@\n+  DEBUG_ONLY(mutable Thread* _iteration_thread;)\n@@ -54,1 +94,1 @@\n-  G1CodeRootSet() : _table(NULL), _length(0) {}\n+  G1CodeRootSet() : _table(nullptr) DEBUG_ONLY(COMMA _iteration_thread(nullptr)) {}\n@@ -76,3 +116,1 @@\n-    bool empty = length() == 0;\n-    assert(empty == (_table == NULL), \"is empty only if table is deallocated\");\n-    return empty;\n+    return length() == 0;\n@@ -82,1 +120,1 @@\n-  size_t length() const { return _length; }\n+  size_t length() const { return _table == nullptr ? 0 : _table->number_of_entries(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.hpp","additions":46,"deletions":8,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1CODEROOTSETTABLE_HPP\n-#define SHARE_GC_G1_G1CODEROOTSETTABLE_HPP\n-\n-#include \"utilities\/hashtable.hpp\"\n-\n-class nmethod;\n-\n-class G1CodeRootSetTable : public Hashtable<nmethod*, mtGC> {\n-  friend class G1CodeRootSetTest;\n-  typedef HashtableEntry<nmethod*, mtGC> Entry;\n-\n-  static G1CodeRootSetTable* volatile _purge_list;\n-\n-  G1CodeRootSetTable* _purge_next;\n-\n-  unsigned int compute_hash(nmethod* nm) {\n-    uintptr_t hash = (uintptr_t)nm;\n-    return hash ^ (hash >> 7); \/\/ code heap blocks are 128byte aligned\n-  }\n-\n-  void remove_entry(Entry* e, Entry* previous);\n-  Entry* new_entry(nmethod* nm);\n-\n- public:\n-  G1CodeRootSetTable(int size) : Hashtable<nmethod*, mtGC>(size, sizeof(Entry)), _purge_next(NULL) {}\n-  ~G1CodeRootSetTable();\n-\n-  \/\/ Needs to be protected by locks\n-  bool add(nmethod* nm);\n-  bool remove(nmethod* nm);\n-\n-  \/\/ Can be called without locking\n-  bool contains(nmethod* nm);\n-\n-  int entry_size() const { return BasicHashtable<mtGC>::entry_size(); }\n-\n-  void copy_to(G1CodeRootSetTable* new_table);\n-  void nmethods_do(CodeBlobClosure* blk);\n-\n-  template<typename CB>\n-  int remove_if(CB& should_remove);\n-\n-  static void purge_list_append(G1CodeRootSetTable* tbl);\n-  static void purge();\n-\n-  static size_t static_mem_size() {\n-    return sizeof(_purge_list);\n-  }\n-\n-  size_t mem_size();\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1CODEROOTSETTABLE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSetTable.hpp","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -112,5 +112,3 @@\n-  \/\/ Optimistic unlocked contains-check\n-  if (!_code_roots.contains(nm)) {\n-    MutexLocker ml(&_m, Mutex::_no_safepoint_check_flag);\n-    add_code_root_locked(nm);\n-  }\n+\n+  MutexLocker ml(&_m, Mutex::_no_safepoint_check_flag);\n+  add_code_root_locked(nm);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+    MutexLocker ml(&_m, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -297,0 +297,6 @@\n+  \/\/ This method calculates the \"shallow\" size. If you want the recursive size, use statistics_calculate.\n+  size_t mem_size() const {\n+    return sizeof(*this) +\n+      table_size() * sizeof(Node*) +\n+      number_of_entries() * sizeof(Node);\n+  }\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"gc\/g1\/g1CodeRootSetTable.hpp\"\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CodeCacheRemSet.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}