{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import javax.naming.ServiceUnavailableException;\n@@ -442,14 +441,0 @@\n-        BerDecoder rber;\n-\n-        \/\/ If socket closed, don't even try\n-        lock.lock();\n-        try {\n-            if (sock == null) {\n-                throw new ServiceUnavailableException(host + \":\" + port +\n-                    \"; socket closed\");\n-            }\n-        } finally {\n-            lock.unlock();\n-        }\n-\n-        IOException ioException = null;\n@@ -460,1 +445,1 @@\n-            rber = ldr.getReplyBer(readTimeout);\n+            return ldr.getReplyBer(readTimeout);\n@@ -465,7 +450,1 @@\n-            \/\/ Connection is timed out OR closed\/cancelled\n-            \/\/ getReplyBer throws IOException when the requests needs to be abandoned\n-            ioException = ioe;\n-            rber = null;\n-        }\n-\n-        if (rber == null) {\n+            \/\/ getReplyBer() throws IOException when request needs to be abandoned\n@@ -473,13 +452,3 @@\n-        }\n-        \/\/ ioException can be not null in the following cases:\n-        \/\/  a) The response is timed-out\n-        \/\/  b) LDAP request connection has been closed\n-        \/\/ If the request has been cancelled - CommunicationException is\n-        \/\/ thrown directly from LdapRequest.getReplyBer, since there is no\n-        \/\/ need to abandon request.\n-        \/\/ The exception message is initialized in LdapRequest::getReplyBer\n-        if (ioException != null) {\n-            \/\/ Throw CommunicationException after all cleanups are done\n-            String message = ioException.getMessage();\n-            var ce = new CommunicationException(message);\n-            ce.initCause(ioException);\n+            \/\/ rethrow as CommunicationException (which is a NamingException)\n+            var ce = new CommunicationException(ioe.getMessage());\n+            ce.initCause(ioe);\n@@ -488,1 +457,0 @@\n-        return rber;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":6,"deletions":38,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -37,1 +36,2 @@\n-    private static final BerDecoder EOF = new BerDecoder(new byte[]{}, -1, 0);\n+    private static final BerDecoder CLOSED_MARKER = new BerDecoder(new byte[]{}, -1, 0);\n+    private static final BerDecoder CANCELLED_MARKER = new BerDecoder(new byte[]{}, -1, 0);\n@@ -39,1 +39,0 @@\n-    private static final String TIMEOUT_MSG_FMT = \"LDAP response read timed out, timeout used: %d ms.\";\n@@ -45,0 +44,2 @@\n+    private final boolean pauseAfterReceipt;\n+\n@@ -48,3 +49,0 @@\n-    private final boolean pauseAfterReceipt;\n-    \/\/ LdapRequest instance lock\n-    private final ReentrantLock lock = new ReentrantLock();\n@@ -64,1 +62,1 @@\n-        replies.offer(EOF);\n+        replies.offer(CANCELLED_MARKER);\n@@ -68,11 +66,2 @@\n-        lock.lock();\n-        try {\n-            closed = true;\n-            replies.offer(EOF);\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    private boolean isClosed() {\n-        return closed && (replies.size() == 0 || replies.peek() == EOF);\n+        closed = true;\n+        replies.offer(CLOSED_MARKER);\n@@ -82,9 +71,12 @@\n-        lock.lock();\n-        try {\n-            \/\/ check the closed boolean value here as we don't want anything\n-            \/\/ to be added to the queue after close() has been called.\n-            if (cancelled || closed) {\n-                return false;\n-            }\n-\n-            \/\/ peek at the BER buffer to check if it is a SearchResultDone PDU\n+        \/\/ check if the request is closed or cancelled, if yes then don't\n+        \/\/ add the reply since it won't be returned back later through getReplyBer().\n+        \/\/ this is merely a best effort basis check and if we do add the reply\n+        \/\/ due to a race, that's OK since the replies queue would have necessary\n+        \/\/ markers for cancelled\/closed state and those will be detected by getReplyBer().\n+        if (cancelled || closed) {\n+            return false;\n+        }\n+        \/\/ if the request is not already completed, check if the reply being added\n+        \/\/ is a LDAP_REP_RESULT, representing a SearchResultDone PDU\n+        if (!completed) {\n+            boolean isLdapResResult = false;\n@@ -94,1 +86,1 @@\n-                completed = (ber.peekByte() == LdapClient.LDAP_REP_RESULT);\n+                isLdapResResult = (ber.peekByte() == LdapClient.LDAP_REP_RESULT);\n@@ -100,5 +92,2 @@\n-            \/\/ Add a new reply to the queue of unprocessed replies.\n-            try {\n-                replies.put(ber);\n-            } catch (InterruptedException e) {\n-                \/\/ ignore\n+            if (isLdapResResult) {\n+                completed = true;\n@@ -106,0 +95,1 @@\n+        }\n@@ -107,3 +97,5 @@\n-            return pauseAfterReceipt;\n-        } finally {\n-            lock.unlock();\n+        \/\/ Add a new reply to the queue of unprocessed replies.\n+        try {\n+            replies.put(ber);\n+        } catch (InterruptedException e) {\n+            \/\/ ignore\n@@ -111,0 +103,1 @@\n+        return pauseAfterReceipt;\n@@ -117,3 +110,7 @@\n-     * @throws CommunicationException request has been canceled and request does not need to be abandoned\n-     * @throws IOException            request has been closed or timed out. Request does need to be abandoned\n-     * @throws InterruptedException   LDAP operation has been interrupted\n+     * @throws CommunicationException request has been canceled and request\n+     *                                does not need to be abandoned (i.e. a LDAP_REQ_ABANDON\n+     *                                message need not be sent across)\n+     * @throws IOException            request has been closed or timed out.\n+     *                                Request needs to be abandoned (i.e. a LDAP_REQ_ABANDON\n+     *                                message needs to be sent across)\n+     * @throws InterruptedException   the wait to read a reply has been interrupted\n@@ -121,0 +118,1 @@\n+    \/\/ more than one thread invoking this method concurrently isn't expected\n@@ -123,10 +121,0 @@\n-        if (cancelled) {\n-            throw new CommunicationException(\"Request: \" + msgId +\n-                \" cancelled\");\n-        }\n-        if (isClosed()) {\n-            throw new IOException(CLOSE_MSG);\n-        }\n-\n-        BerDecoder result = millis > 0 ?\n-                replies.poll(millis, TimeUnit.MILLISECONDS) : replies.take();\n@@ -134,3 +122,11 @@\n-        if (cancelled) {\n-            throw new CommunicationException(\"Request: \" + msgId +\n-                \" cancelled\");\n+        final boolean hasReplies = replies.peek() != null;\n+        if (!hasReplies) {\n+            \/\/ no replies have been queued, so if the request has\n+            \/\/ been cancelled or closed, then raise an exception\n+            if (cancelled) {\n+                throw new CommunicationException(\"Request: \" + msgId +\n+                        \" cancelled\");\n+            }\n+            if (closed) {\n+                throw new IOException(CLOSE_MSG);\n+            }\n@@ -138,1 +134,7 @@\n-\n+        \/\/ either there already are queued replies or the request is still\n+        \/\/ alive (i.e. not cancelled or closed). we wait for a reply to arrive\n+        \/\/ or the request to be cancelled\/closed, in which case the replies\n+        \/\/ queue will contain the relevant marker.\n+        final BerDecoder result = millis > 0\n+                ? replies.poll(millis, TimeUnit.MILLISECONDS)\n+                : replies.take();\n@@ -141,1 +143,5 @@\n-            throw new IOException(String.format(TIMEOUT_MSG_FMT, millis));\n+            throw new IOException(\"LDAP response read timed out, timeout used: \" + millis + \" ms.\");\n+        }\n+        if (result == CANCELLED_MARKER) {\n+            throw new CommunicationException(\"Request: \" + msgId +\n+                \" cancelled\");\n@@ -143,2 +149,1 @@\n-        \/\/ Unexpected EOF can be caused by connection closure or cancellation\n-        if (result == EOF) {\n+        if (result == CLOSED_MARKER) {\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapRequest.java","additions":62,"deletions":57,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,413 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8357708\n+ * @summary verify that com.sun.jndi.ldap.Connection does not ignore the LDAP replies\n+ *          that were received before the Connection was closed.\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n+ * @run junit\/othervm LdapClientConnTest\n+ *\/\n+public class LdapClientConnTest {\n+\n+    private static final byte BER_TYPE_LDAP_SEQUENCE = 0x30;\n+    private static final byte BER_TYPE_INTEGER = 0x02;\n+    private static final byte BER_TYPE_OCTET_STRING = 0x04;\n+    private static final byte BER_TYPE_ENUM = 0x0a;\n+    private static final byte BER_TYPE_LDAP_SEARCH_REQUEST_OP = 0x63;\n+    private static final byte BER_TYPE_LDAP_SEARCH_RESULT_ENTRY_OP = 0x64;\n+    private static final byte BER_TYPE_LDAP_SEARCH_RESULT_DONE_OP = 0x65;\n+    private static final byte BER_TYPE_LDAP_SEARCH_RESULT_REFERENCE_OP = 0x73;\n+    private static final byte LDAP_SEARCH_RESULT_DONE_SUCCESS = 0x00;\n+\n+    private static final String SEARCH_REQ_DN_PREFIX = \"CN=foo-\";\n+    private static final String SEARCH_REQ_DN_SUFFIX = \"-bar\";\n+\n+    private static Server server;\n+    private static final List<Throwable> serverSideFailures =\n+            Collections.synchronizedList(new ArrayList<>());\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        server = startServer();\n+        System.out.println(\"server started \" + server.getAddress());\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (server != null) {\n+            System.out.println(\"stopping server \" + server.getAddress());\n+            server.close();\n+        }\n+    }\n+\n+    \/*\n+     * Launches several concurrent tasks, all of which use a LdapClient of their own to trigger\n+     * a LDAP SEARCH request. The server side handles the LDAP SEARCH request and writes out the\n+     * response over the Socket and then after the response is written out, closes the\n+     * OutputStream of the Socket. The test then verifies that each of these tasks complete\n+     * normally without any exception being raised.\n+     *\/\n+    @Test\n+    public void testLdapRepliesNotIgnored() throws Throwable {\n+        final Map<String, Future<Void>> results = new HashMap<>();\n+        final int numTasks = 10;\n+        try (final ExecutorService executor = Executors.newCachedThreadPool()) {\n+            for (int i = 1; i <= numTasks; i++) {\n+                final String taskName = \"task-\" + i;\n+                results.put(taskName, executor.submit(new LdapRequestsTask(taskName)));\n+            }\n+            System.out.println(\"waiting for \" + numTasks + \" to complete\");\n+            for (final Map.Entry<String, Future<Void>> entry : results.entrySet()) {\n+                try {\n+                    entry.getValue().get();\n+                } catch (ExecutionException ee) {\n+                    final Throwable cause = ee.getCause();\n+                    System.out.println(\"failed for \" + entry.getKey() + \", exception: \" + cause);\n+                    throw cause;\n+                }\n+            }\n+        }\n+        \/\/ verify there weren't any server side failures\n+        if (!serverSideFailures.isEmpty()) {\n+            System.err.println(\"server side failure(s) follow:\");\n+            for (final Throwable t : serverSideFailures) {\n+                t.printStackTrace();\n+            }\n+            fail(\"unexpected server side failures\");\n+        }\n+    }\n+\n+    private static Server startServer() throws IOException {\n+        final ServerSocket serverSocket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+        final Server s = new Server(serverSocket);\n+        s.start();\n+        return s;\n+    }\n+\n+    \/\/ accepts connections on a ServerSocket and hands off the request processing\n+    \/\/ to the RequestHandler\n+    private static final class Server implements Runnable, AutoCloseable {\n+        private final ServerSocket serverSocket;\n+        private final AtomicInteger reqHandlerTid = new AtomicInteger();\n+        private volatile boolean stop;\n+\n+        private Server(final ServerSocket serverSocket) {\n+            this.serverSocket = serverSocket;\n+        }\n+\n+        @Override\n+        public void run() {\n+            System.err.println(\"Server accepting connections at \"\n+                    + serverSocket.getLocalSocketAddress());\n+            while (!stop) {\n+                try {\n+                    final Socket accepted = serverSocket.accept();\n+                    System.err.println(\"Accepted connection from \" + accepted);\n+                    dispatchRequest(accepted);\n+                } catch (Throwable t) {\n+                    if (!stop) {\n+                        System.err.println(\"Server thread ran into unexpected exception: \" + t);\n+                        t.printStackTrace();\n+                        \/\/ keep track of this failure to eventually fail the test\n+                        serverSideFailures.add(t);\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void start() {\n+            final Thread serverThread = new Thread(this);\n+            serverThread.setName(\"server\");\n+            serverThread.setDaemon(true);\n+            serverThread.start();\n+        }\n+\n+        private InetSocketAddress getAddress() {\n+            return (InetSocketAddress) this.serverSocket.getLocalSocketAddress();\n+        }\n+\n+        private void dispatchRequest(final Socket incomingConnection) {\n+            final RequestHandler handler = new RequestHandler(incomingConnection);\n+            \/\/ handle the request in a separate thread\n+            final Thread reqHandlerThread = new Thread(handler);\n+            reqHandlerThread.setName(\"request-handler-\" + reqHandlerTid.incrementAndGet());\n+            reqHandlerThread.setDaemon(true);\n+            reqHandlerThread.start();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.stop = true;\n+            try {\n+                System.err.println(\"closing server socket \" + this.serverSocket);\n+                this.serverSocket.close();\n+            } catch (IOException _) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/\/ Handles a single request over the Socket and responds back on the same Socket\n+    private static final class RequestHandler implements Runnable {\n+\n+        private record SearchRequest(byte msgId, String dn) {\n+        }\n+\n+        private final Socket clientSocket;\n+\n+        private RequestHandler(final Socket clientSocket) {\n+            this.clientSocket = clientSocket;\n+        }\n+\n+        @Override\n+        public void run() {\n+            final String threadName = Thread.currentThread().getName();\n+            System.err.println(threadName + \" - handling request on socket: \" + clientSocket);\n+            try (InputStream is = clientSocket.getInputStream();\n+                 OutputStream os = clientSocket.getOutputStream()) {\n+                final SearchRequest searchRequest = parseLDAPSearchRequest(is);\n+                \/\/ generate a LDAP response\n+                final byte[] responseBytes = makeResponse(searchRequest.msgId,\n+                        searchRequest.dn, server.getAddress());\n+                System.err.println(threadName + \" - responding to: \" + searchRequest);\n+                os.write(responseBytes);\n+            } catch (Throwable t) {\n+                System.err.println(threadName + \" - exception in request handler: \" + t);\n+                t.printStackTrace();\n+                \/\/ keep track of this failure to eventually fail the test\n+                serverSideFailures.add(t);\n+            } finally {\n+                System.err.println(threadName + \" - request handler done\");\n+            }\n+        }\n+\n+        private static SearchRequest parseLDAPSearchRequest(final InputStream is)\n+                throws IOException {\n+            final String threadName = Thread.currentThread().getName();\n+            final HexFormat hf = HexFormat.of();\n+            \/\/ read the BER elements\n+            \/\/ each BER element is 3 parts:\n+            \/\/ Type, length, value\n+            final int berType = is.read();\n+            if (berType != BER_TYPE_LDAP_SEQUENCE) {\n+                \/\/ unexpected content\n+                throw new IOException(threadName + \" - unexpected request, not a LDAP_SEQUENCE: \"\n+                        + hf.formatHex(new byte[]{(byte) berType}));\n+            }\n+            \/\/ BER element length\n+            int seqLen = is.read();\n+            \/\/ 0x81, 0x82, 0x84 (and a few others) represent length that is represented\n+            \/\/ in multiple bytes. for this test we only consider length represented in\n+            \/\/ single byte or multiple bytes through 0x81 and 0x82\n+            if (seqLen == 0x81) {\n+                seqLen = is.read() & 0xff;\n+            } else if (seqLen == 0x82) {\n+                seqLen = (is.read() & 0xff) << 8 + (is.read() & 0xff);\n+            }\n+            if (seqLen < 0) {\n+                \/\/ unexpected BER element length\n+                throw new IOException(threadName + \" - unexpected BER element length: \" + seqLen);\n+            }\n+            \/\/ read the BER element value\n+            final byte[] ldapSeq = new byte[seqLen];\n+            System.err.println(threadName + \" - reading \" + seqLen + \" bytes from request\");\n+            is.readNBytes(ldapSeq, 0, seqLen);\n+\n+            final String ldapSeqHex = HexFormat.of().formatHex(ldapSeq); \/\/ just for debug logging\n+            System.err.println(threadName + \" - request LDAP sequence: 0x\" + ldapSeqHex);\n+\n+            \/\/ read the message id BER element from the LDAP sequence\n+            final byte msgIdType = ldapSeq[0];\n+            if (msgIdType != BER_TYPE_INTEGER) {\n+                \/\/ unexpected content\n+                throw new IOException(threadName + \" - unexpected BER type for message id element: \"\n+                        + hf.formatHex(new byte[]{msgIdType}));\n+            }\n+            final byte msgIdLen = ldapSeq[1];\n+            final byte msgId = ldapSeq[2];\n+            \/\/ read LDAP operation type\n+            final byte ldapOpType = ldapSeq[3];\n+            if (ldapOpType != BER_TYPE_LDAP_SEARCH_REQUEST_OP) {\n+                \/\/ we only support LDAP search requests in this handler\n+                throw new IOException(threadName + \" - unexpected BER type for LDAP operation: \"\n+                        + hf.formatHex(new byte[]{ldapOpType}));\n+            }\n+            final byte searchReqSeqLen = ldapSeq[4];\n+            if (searchReqSeqLen < 0) {\n+                \/\/ implies the length is represented in multiple bytes. we don't\n+                \/\/ expect that big a search request payload in this test, so fail.\n+                throw new IOException(threadName + \" - unexpected length for SEARCH request: \"\n+                        + hf.formatHex(new byte[]{searchReqSeqLen}));\n+            }\n+            \/\/ not all characters will be ASCII, but that's OK, this is here merely as a check\n+            \/\/ for unexpected requests\n+            final String remainingPayload = new String(ldapSeq, 5, (ldapSeq.length - 5));\n+            final int dnPrefixIndex = remainingPayload.indexOf(SEARCH_REQ_DN_PREFIX);\n+            final int dnSuffixIndex = remainingPayload.indexOf(SEARCH_REQ_DN_SUFFIX);\n+            if (dnPrefixIndex < 0 || dnSuffixIndex < 0) {\n+                throw new IOException(threadName + \" - missing expected DN in SEARCH request: \"\n+                        + remainingPayload);\n+            }\n+            final String dn = remainingPayload.substring(dnPrefixIndex,\n+                    dnSuffixIndex + SEARCH_REQ_DN_SUFFIX.length());\n+            return new SearchRequest(msgId, dn);\n+        }\n+\n+        \/\/ constructs and returns a byte[] response containing the following (in that order):\n+        \/\/  - Search Result Reference\n+        \/\/  - Search Result Entry\n+        \/\/  - Search Result Done\n+        private static byte[] makeResponse(final byte msgId, final String origDN,\n+                                           final InetSocketAddress targetServer)\n+                throws IOException {\n+            \/\/ construct a URI with a different DN for using as referral URI\n+            final String newPrefix = SEARCH_REQ_DN_PREFIX + \"dummy-referral-\";\n+            final String newDN = origDN.replace(SEARCH_REQ_DN_PREFIX, newPrefix);\n+            final String referralURI = URIBuilder.newBuilder()\n+                    .scheme(\"ldap\")\n+                    .host(targetServer.getAddress().getHostAddress())\n+                    .port(targetServer.getPort())\n+                    .path(\"\/\" + newDN)\n+                    .buildUnchecked()\n+                    .toString();\n+            final byte msgIdLen = 1;\n+            final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+            \/\/ write the BER elements\n+            \/\/ each BER element is 3 parts:\n+            \/\/ Type, length, value\n+\n+            \/\/ Search Result Reference BER element (refer to LDAPv3 wire format for details)\n+            bout.write(BER_TYPE_LDAP_SEQUENCE);\n+            bout.write(referralURI.length() + 7);\n+            bout.write(new byte[]{BER_TYPE_INTEGER, msgIdLen, msgId});\n+            bout.write(BER_TYPE_LDAP_SEARCH_RESULT_REFERENCE_OP);\n+            bout.write(referralURI.length() + 2);\n+            bout.write(BER_TYPE_OCTET_STRING);\n+            bout.write(referralURI.length());\n+            bout.write(referralURI.getBytes(US_ASCII));\n+\n+            \/\/ Search Result Entry BER element (refer to LDAPv3 wire format for details)\n+            bout.write(BER_TYPE_LDAP_SEQUENCE);\n+            bout.write(origDN.length() + 9);\n+            bout.write(new byte[]{BER_TYPE_INTEGER, msgIdLen, msgId});\n+            bout.write(BER_TYPE_LDAP_SEARCH_RESULT_ENTRY_OP);\n+            bout.write(origDN.length() + 2);\n+            bout.write(BER_TYPE_OCTET_STRING);\n+            bout.write(origDN.length());\n+            bout.write(origDN.getBytes(US_ASCII));\n+            bout.write(BER_TYPE_LDAP_SEQUENCE);\n+            \/\/ 0 length for the LDAP sequence, implying no attributes in this Search Result Entry\n+            bout.write(0);\n+\n+            \/\/ Search Result Done BER element (refer to LDAPv3 wire format for details)\n+            bout.write(BER_TYPE_LDAP_SEQUENCE);\n+            bout.write(origDN.length() + 12);\n+            bout.write(new byte[]{BER_TYPE_INTEGER, msgIdLen, msgId});\n+            bout.write(BER_TYPE_LDAP_SEARCH_RESULT_DONE_OP);\n+            bout.write(7);\n+            bout.write(new byte[]{BER_TYPE_ENUM, 1, LDAP_SEARCH_RESULT_DONE_SUCCESS});\n+            \/\/ the matched DN\n+            bout.write(BER_TYPE_OCTET_STRING);\n+            bout.write(origDN.length());\n+            bout.write(origDN.getBytes(US_ASCII));\n+            \/\/ 0 length implies no diagnostic message\n+            bout.write(new byte[]{BER_TYPE_OCTET_STRING, 0});\n+            return bout.toByteArray();\n+        }\n+    }\n+\n+    \/\/ a task that triggers LDAP SEARCH request\n+    private static final class LdapRequestsTask implements Callable<Void> {\n+        private final String taskName;\n+\n+        private LdapRequestsTask(final String taskName) {\n+            this.taskName = taskName;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            Context ldapCtx = null;\n+            try {\n+                final InetSocketAddress serverAddr = server.getAddress();\n+                final Hashtable<String, String> envProps = new Hashtable<>();\n+                envProps.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+                final String providerUrl = URIBuilder.newBuilder()\n+                        .scheme(\"ldap\")\n+                        .host(serverAddr.getAddress())\n+                        .port(serverAddr.getPort())\n+                        .build().toString();\n+                envProps.put(Context.PROVIDER_URL, providerUrl);\n+                \/\/ explicitly set LDAP version to 3 to prevent LDAP BIND requests\n+                \/\/ during LdapCtx instantiation\n+                envProps.put(\"java.naming.ldap.version\", \"3\");\n+                ldapCtx = new InitialContext(envProps);\n+                final String name = SEARCH_REQ_DN_PREFIX + taskName + SEARCH_REQ_DN_SUFFIX;\n+                \/\/ trigger the LDAP SEARCH requests through the lookup call. we are not\n+                \/\/ interested in the returned value and are merely interested in a normal\n+                \/\/ completion of the call.\n+                final var _ = ldapCtx.lookup(name);\n+                return null;\n+            } finally {\n+                if (ldapCtx != null) {\n+                    ldapCtx.close();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapClientConnTest.java","additions":413,"deletions":0,"binary":false,"changes":413,"status":"added"}]}