{"files":[{"patch":"@@ -73,0 +73,2 @@\n+        @JEP(number=443, title=\"Unnamed Patterns and Variables\")\n+        UNNAMED,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,3 +134,4 @@\n-     * PackageElement#getSimpleName package} or unnamed {@linkplain\n-     * ModuleElement#getSimpleName module}, an {@linkplain\n-     * Name##empty_name empty name} is returned.\n+     * PackageElement#getSimpleName package}, an unnamed {@linkplain\n+     * ModuleElement#getSimpleName module} or an unnamed {@linkplain\n+     * VariableElement#getSimpleName variable}, an {@linkplain Name##empty_name empty name}\n+     * is returned.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -84,0 +86,3 @@\n+     *\n+     * <p>For variables, the name of each variable is returned, or an empty name\n+     * if the variable is unnamed.\n@@ -96,0 +101,17 @@\n+\n+    \/**\n+     * {@return {@code true} if this is an unnamed variable and {@code\n+     * false} otherwise}\n+     *\n+     * @implSpec\n+     * The default implementation of this method calls {@code\n+     * getSimpleName()} and returns {@code true} if the result is\n+     * empty and {@code false} otherwise.\n+     *\n+     * @jls 6.1 Declarations\n+     * @jls 14.4 Local Variable Declarations\n+     *\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED, reflective = true)\n+    default boolean isUnnamed() { return getSimpleName().isEmpty(); }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A tree node for a binding pattern that matches a pattern\n+ * with a variable of any name and a type of the match candidate;\n+ * an unnamed pattern.\n+ *\n+ * For example the use of underscore {@code _} below:\n+ * <pre>\n+ *   if (r instanceof R(_)) {}\n+ * <\/pre>\n+ *\n+ * @jls 14.30.1 Kinds of Patterns\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+public interface AnyPatternTree extends PatternTree {\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/AnyPatternTree.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -230,0 +230,8 @@\n+        \/**\n+         * Used for instances of {@link BindingPatternTree}.\n+         *\n+         * @since 21\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+        ANY_PATTERN(AnyPatternTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -271,0 +271,10 @@\n+    \/**\n+     * Visits a {@code AnyPatternTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+    R visitAnyPattern(AnyPatternTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-     * Returns the name of the variable being declared.\n+     * Returns the name of the variable being declared or empty name if both the variable\n+     * is unnamed and the preview features are enabled (Unnamed Patterns and Variables).\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/VariableTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -646,0 +646,16 @@\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 21\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+    public R visitAnyPattern(AnyPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -763,0 +763,15 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 21\n+     *\/\n+    @Override\n+    public R visitAnyPattern(AnyPatternTree node, P p) {\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-\n+            case UNNAMED_VARIABLES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+        UNNAMED_VARIABLES(JDK21, Fragments.FeatureUnnamedVariables, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1644,0 +1644,1 @@\n+    @SuppressWarnings(\"preview\")\n@@ -1786,0 +1787,4 @@\n+\n+        public boolean isUnnamedVariable() {\n+            return name.isEmpty();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1691,1 +1691,1 @@\n-                boolean wasUnconditionalPattern = hasUnconditionalPattern;\n+                MatchBindings guardBindings = null;\n@@ -1764,1 +1764,1 @@\n-                        if (labels.tail.isEmpty() && guard != null) {\n+                        if (guardBindings == null && guard != null) {\n@@ -1772,1 +1772,3 @@\n-                            matchBindings = matchBindingsComputer.caseGuard(c, afterPattern, matchBindings);\n+\n+                            guardBindings = matchBindings;\n+                            matchBindings = afterPattern;\n@@ -1799,0 +1801,4 @@\n+                if (guardBindings != null) {\n+                    currentBindings = matchBindingsComputer.caseGuard(c, currentBindings, guardBindings);\n+                }\n+\n@@ -4148,0 +4154,5 @@\n+    @Override\n+    public void visitAnyPattern(JCAnyPattern tree) {\n+        result = tree.type = resultInfo.pt;\n+    }\n+\n@@ -4169,1 +4180,5 @@\n-        matchBindings = new MatchBindings(List.of(v), List.nil());\n+        if (v.isUnnamedVariable()) {\n+            matchBindings = MatchBindingsComputer.EMPTY;\n+        } else {\n+            matchBindings = new MatchBindings(List.of(v), List.nil());\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -4575,2 +4575,5 @@\n-            } else {\n-                if (c.labels.tail.nonEmpty()) {\n+            } else if (c.labels.tail.nonEmpty()) {\n+                var patterCaseLabels = c.labels.stream().filter(ll -> ll instanceof JCPatternCaseLabel).map(cl -> (JCPatternCaseLabel)cl);\n+                var allUnderscore = patterCaseLabels.allMatch(pcl -> !hasBindings(pcl.getPattern()));\n+\n+                if (!allUnderscore) {\n@@ -4611,1 +4614,1 @@\n-                bindings[0] = true;\n+                bindings[0] = !tree.var.sym.isUnnamedVariable();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -745,81 +745,0 @@\n-        sealed interface PatternDescription {\n-            public static PatternDescription from(Types types, Type selectorType, JCPattern pattern) {\n-                if (pattern instanceof JCBindingPattern binding) {\n-                    Type type = types.isSubtype(selectorType, binding.type)\n-                            ? selectorType : binding.type;\n-                    return new BindingPattern(type);\n-                } else if (pattern instanceof JCRecordPattern record) {\n-                    Type[] componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n-                            .map(r -> types.memberType(record.type, r))\n-                            .toArray(s -> new Type[s]);\n-                    PatternDescription[] nestedDescriptions =\n-                            new PatternDescription[record.nested.size()];\n-                    int i = 0;\n-                    for (List<JCPattern> it = record.nested;\n-                         it.nonEmpty();\n-                         it = it.tail, i++) {\n-                        nestedDescriptions[i] = PatternDescription.from(types, componentTypes[i], it.head);\n-                    }\n-                    return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n-                } else {\n-                    throw Assert.error();\n-                }\n-            }\n-        }\n-\n-        record BindingPattern(Type type) implements PatternDescription {\n-            @Override\n-            public int hashCode() {\n-                return type.tsym.hashCode();\n-            }\n-            @Override\n-            public boolean equals(Object o) {\n-                return o instanceof BindingPattern other &&\n-                       type.tsym == other.type.tsym;\n-            }\n-            @Override\n-            public String toString() {\n-                return type.tsym + \" _\";\n-            }\n-        }\n-\n-        record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n-\n-            public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n-                this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n-            }\n-\n-            @Override\n-            public int hashCode() {\n-                return _hashCode;\n-            }\n-\n-            @Override\n-            public boolean equals(Object o) {\n-                return o instanceof RecordPattern other &&\n-                       recordType.tsym == other.recordType.tsym &&\n-                       Arrays.equals(nested, other.nested);\n-            }\n-\n-            public int hashCode(int excludeComponent) {\n-                return hashCode(excludeComponent, recordType, nested);\n-            }\n-\n-            public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n-                int hash = 5;\n-                hash =  41 * hash + recordType.tsym.hashCode();\n-                for (int  i = 0; i < nested.length; i++) {\n-                    if (i != excludeComponent) {\n-                        hash = 41 * hash + nested[i].hashCode();\n-                    }\n-                }\n-                return hash;\n-            }\n-            @Override\n-            public String toString() {\n-                return recordType.tsym + \"(\" + Arrays.stream(nested)\n-                                                     .map(pd -> pd.toString())\n-                                                     .collect(Collectors.joining(\", \")) + \")\";\n-            }\n-        }\n-\n@@ -836,1 +755,1 @@\n-                            patternSet.add(PatternDescription.from(types, component, patternLabel.pat));\n+                            patternSet.add(makePatternDescription(component, patternLabel.pat));\n@@ -2908,1 +2827,1 @@\n-                    if (unrefdResources.includes(resVar.sym)) {\n+                    if (unrefdResources.includes(resVar.sym) && !resVar.sym.isUnnamedVariable()) {\n@@ -3557,0 +3476,81 @@\n+    sealed interface PatternDescription { }\n+    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n+        if (pattern instanceof JCBindingPattern binding) {\n+            Type type = types.isSubtype(selectorType, binding.type)\n+                    ? selectorType : binding.type;\n+            return new BindingPattern(type);\n+        } else if (pattern instanceof JCRecordPattern record) {\n+            Type[] componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n+                    .map(r -> types.memberType(record.type, r))\n+                    .toArray(s -> new Type[s]);\n+            PatternDescription[] nestedDescriptions =\n+                    new PatternDescription[record.nested.size()];\n+            int i = 0;\n+            for (List<JCPattern> it = record.nested;\n+                 it.nonEmpty();\n+                 it = it.tail, i++) {\n+                nestedDescriptions[i] = makePatternDescription(types.erasure(componentTypes[i]), it.head);\n+            }\n+            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n+        } else if (pattern instanceof JCAnyPattern) {\n+            Type type = types.isSubtype(selectorType, syms.objectType)\n+                    ? selectorType : syms.objectType;\n+            return new BindingPattern(type);\n+        } else {\n+            throw Assert.error();\n+        }\n+    }\n+    record BindingPattern(Type type) implements PatternDescription {\n+        @Override\n+        public int hashCode() {\n+            return type.tsym.hashCode();\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof BindingPattern other &&\n+                    type.tsym == other.type.tsym;\n+        }\n+        @Override\n+        public String toString() {\n+            return type.tsym + \" _\";\n+        }\n+    }\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return _hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof RecordPattern other &&\n+                    recordType.tsym == other.recordType.tsym &&\n+                    Arrays.equals(nested, other.nested);\n+        }\n+\n+        public int hashCode(int excludeComponent) {\n+            return hashCode(excludeComponent, recordType, nested);\n+        }\n+\n+        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n+            int hash = 5;\n+            hash =  41 * hash + recordType.tsym.hashCode();\n+            for (int  i = 0; i < nested.length; i++) {\n+                if (i != excludeComponent) {\n+                    hash = 41 * hash + nested[i].hashCode();\n+                }\n+            }\n+            return hash;\n+        }\n+        @Override\n+        public String toString() {\n+            return recordType.tsym + \"(\" + Arrays.stream(nested)\n+                    .map(pd -> pd.toString())\n+                    .collect(Collectors.joining(\", \")) + \")\";\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -58,0 +59,2 @@\n+    \/** The Source language setting. *\/\n+    private final Source source;\n@@ -65,0 +68,1 @@\n+    private final Names names;\n@@ -84,0 +88,2 @@\n+        source = Source.instance(context);\n+        names = Names.instance(context);\n@@ -288,1 +294,2 @@\n-        VarSymbol v = new VarSymbol(0, tree.name, vartype, enclScope.owner);\n+        Name name = tree.name;\n+        VarSymbol v = new VarSymbol(0, name, vartype, enclScope.owner);\n@@ -300,6 +307,9 @@\n-        if (chk.checkUnique(tree.pos(), v, enclScope)) {\n-            chk.checkTransparentVar(tree.pos(), v, enclScope);\n-            enclScope.enter(v);\n-        } else if (v.owner.kind == MTH || (v.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0) {\n-            \/\/ if this is a parameter or a field obtained from a record component, enter it\n-            enclScope.enter(v);\n+\n+        if(!(Feature.UNNAMED_VARIABLES.allowedInSource(source) && tree.sym.isUnnamedVariable())) {\n+            if (chk.checkUnique(tree.pos(), v, enclScope)) {\n+                chk.checkTransparentVar(tree.pos(), v, enclScope);\n+                enclScope.enter(v);\n+            } else if (v.owner.kind == MTH || (v.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0) {\n+                \/\/ if this is a parameter or a field obtained from a record component, enter it\n+                enclScope.enter(v);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCAnyPattern;\n@@ -264,0 +265,5 @@\n+    @Override\n+    public void visitAnyPattern(JCTree.JCAnyPattern that) {\n+        result = make.Literal(true);\n+    }\n+\n@@ -271,1 +277,1 @@\n-        if (bindingVar != null) {\n+        if (bindingVar != null && !bindingVar.isUnnamedVariable()) {\n@@ -314,1 +320,1 @@\n-            JCBindingPattern nestedBinding;\n+            JCPattern nestedBinding;\n@@ -328,1 +334,5 @@\n-            } else {\n+            } else if (nestedPattern instanceof JCAnyPattern nestedAnyPattern) {\n+                allowNull = true;\n+                nestedBinding = nestedAnyPattern;\n+            }\n+            else {\n@@ -440,6 +450,5 @@\n-                            if (cse.guard != null) {\n-                                cse.guard = mergeConditions(guard, cse.guard);\n-                            } else {\n-                                cse.guard = guard;\n-                            }\n-                            return make.PatternCaseLabel(deconstructed.primaryPattern());\n+\n+                            JCPatternCaseLabel newPatternCaseLabel = make.PatternCaseLabel(deconstructed.primaryPattern());\n+                            newPatternCaseLabel.syntheticGuard = guard;\n+\n+                            return newPatternCaseLabel;\n@@ -527,2 +536,10 @@\n-                if (clearedPatterns.size() == 1 && clearedPatterns.head.hasTag(Tag.PATTERNCASELABEL) && !previousCompletesNormally) {\n-                    JCPatternCaseLabel label = (JCPatternCaseLabel) clearedPatterns.head;\n+\n+                boolean validCaseLabelList;\n+                if (clearedPatterns.size() > 1) {\n+                    validCaseLabelList = clearedPatterns.stream().allMatch(cP -> cP.hasTag(Tag.PATTERNCASELABEL));\n+                } else {\n+                    validCaseLabelList = clearedPatterns.head.hasTag(Tag.PATTERNCASELABEL);\n+                }\n+\n+                if (validCaseLabelList && !previousCompletesNormally) {\n+                    List<JCPatternCaseLabel> labels = clearedPatterns.stream().map(cp -> (JCPatternCaseLabel)cp).collect(List.collector());\n@@ -533,1 +550,28 @@\n-                        JCExpression test = (JCExpression) this.<JCTree>translate(label.pat);\n+                        JCExpression test = null;\n+                        JCExpression accTest = null;\n+                        boolean first = true;\n+\n+                        \/\/ if all patterns are the same we do not need an extra test for the first (it is covered by the BSM)\n+                        boolean multiplePatternsAndDifferent = labels.size() > 1 &&\n+                                !labels.stream().map(l -> l.pat.type.tsym).allMatch(labels.get(0).pat.type.tsym::equals);\n+\n+                        for (JCPatternCaseLabel label: labels) {\n+                            test = (JCExpression) this.<JCTree>translate(label.pat);\n+\n+                            if (multiplePatternsAndDifferent) {\n+                                test = makeBinary(Tag.AND, makeTypeTest(make.Ident(temp), make.Type(label.pat.type)), test);\n+                            }\n+\n+                            if (label.syntheticGuard != null) {\n+                                JCExpression guard = translate(label.syntheticGuard);\n+                                test = makeBinary(Tag.AND, test, guard);\n+                            }\n+\n+                            if (!first) {\n+                                accTest = makeBinary(Tag.OR, accTest, test);\n+                            } else {\n+                                accTest = test;\n+                                first = false;\n+                            }\n+                        }\n+\n@@ -535,2 +579,4 @@\n-                            JCExpression guard = translate(c.guard);\n-                            test = makeBinary(Tag.AND, test, guard);\n+                            test = makeBinary(Tag.AND, accTest, translate(c.guard));\n+                            c.guard = null;\n+                        } else {\n+                            test = accTest;\n@@ -538,0 +584,1 @@\n+\n@@ -543,1 +590,1 @@\n-                                                                                                       makeLit(syms.intType, i + 1))\n+                                                                                                       makeLit(syms.intType, i + labels.length()))\n@@ -559,1 +606,4 @@\n-                for (var p : c.labels) {\n+                List<JCCaseLabel> labels = c.labels;\n+                boolean defaultAdded = false;\n+                for (int j = 0; j < labels.size() && !defaultAdded; j++) {\n+                    var p = labels.get(j);\n@@ -564,1 +614,1 @@\n-                               c == lastCase && p.hasTag(Tag.PATTERNCASELABEL)) {\n+                            c == lastCase && p.hasTag(Tag.PATTERNCASELABEL)) {\n@@ -569,0 +619,1 @@\n+                        defaultAdded = true;\n@@ -701,1 +752,1 @@\n-                    JCExpression lastGuard = null;\n+                    boolean hasGuard = false;\n@@ -716,1 +767,1 @@\n-                        if (accummulated.guard instanceof JCBinary binOp) {\n+                        if (accummulatedFirstLabel.syntheticGuard instanceof JCBinary binOp) {\n@@ -721,1 +772,1 @@\n-                            instanceofCheck = (JCInstanceOf) accummulated.guard;\n+                            instanceofCheck = (JCInstanceOf) accummulatedFirstLabel.syntheticGuard;\n@@ -728,0 +779,4 @@\n+\n+                        JCPatternCaseLabel jcPatternCaseLabelWithGuard = make.PatternCaseLabel(binding);\n+                        jcPatternCaseLabelWithGuard.syntheticGuard = newGuard;\n+\n@@ -730,1 +785,1 @@\n-                                    make.PatternCaseLabel(binding));\n+                                    jcPatternCaseLabelWithGuard);\n@@ -732,1 +787,1 @@\n-                            newLabel = List.of(make.PatternCaseLabel(binding));\n+                            newLabel = List.of(jcPatternCaseLabelWithGuard);\n@@ -734,1 +789,1 @@\n-                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, newGuard,\n+                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, accummulated.guard,\n@@ -736,1 +791,1 @@\n-                        lastGuard = newGuard;\n+                        hasGuard = newGuard != null || accummulated.guard != null;\n@@ -738,1 +793,1 @@\n-                    if (lastGuard != null || !hasUnconditional) {\n+                    if (hasGuard || !hasUnconditional) {\n@@ -754,0 +809,1 @@\n+                    leadingTest.syntheticGuard = null;\n@@ -778,1 +834,1 @@\n-                if (c.head.guard instanceof JCBinary binOp &&\n+                if (patternLabel.syntheticGuard instanceof JCBinary binOp &&\n@@ -785,1 +841,1 @@\n-                } else if (c.head.guard instanceof JCInstanceOf instanceofCheck &&\n+                } else if (patternLabel.syntheticGuard instanceof JCInstanceOf instanceofCheck &&\n@@ -1376,0 +1432,6 @@\n+\n+        @Override\n+        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+            super.visitPatternCaseLabel(tree);\n+            scan(tree.syntheticGuard);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":89,"deletions":27,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -559,0 +559,5 @@\n+    @Override\n+    public void visitAnyPattern(JCAnyPattern tree) {\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import java.util.function.BiFunction;\n@@ -593,0 +592,8 @@\n+        return ident(allowClass, false);\n+    }\n+\n+    public Name identOrUnderscore() {\n+        return ident(false, true);\n+    }\n+\n+    protected Name ident(boolean allowClass, boolean asVariable) {\n@@ -618,0 +625,2 @@\n+            } else if (asVariable) {\n+                checkSourceLevel(Feature.UNNAMED_VARIABLES);\n@@ -833,1 +842,0 @@\n-\n@@ -839,5 +847,13 @@\n-        if (parsedType == null) {\n-            boolean var = token.kind == IDENTIFIER && token.name() == names.var;\n-            e = unannotatedType(allowVar, TYPE | NOLAMBDA);\n-            if (var) {\n-                e = null;\n+        if (token.kind == UNDERSCORE && parsedType == null) {\n+            nextToken();\n+            pattern = toP(F.at(token.pos).AnyPattern());\n+        }\n+        else {\n+            if (parsedType == null) {\n+                boolean var = token.kind == IDENTIFIER && token.name() == names.var;\n+                e = unannotatedType(allowVar, TYPE | NOLAMBDA);\n+                if (var) {\n+                    e = null;\n+                }\n+            } else {\n+                e = parsedType;\n@@ -845,9 +861,11 @@\n-        } else {\n-            e = parsedType;\n-        }\n-        if (token.kind == LPAREN) {\n-            \/\/deconstruction pattern:\n-            checkSourceLevel(Feature.RECORD_PATTERNS);\n-            ListBuffer<JCPattern> nested = new ListBuffer<>();\n-            if (!peekToken(RPAREN)) {\n-                do {\n+            if (token.kind == LPAREN) {\n+                \/\/deconstruction pattern:\n+                checkSourceLevel(Feature.RECORD_PATTERNS);\n+                ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                if (!peekToken(RPAREN)) {\n+                    do {\n+                        nextToken();\n+                        JCPattern nestedPattern = parsePattern(token.pos, null, null, true, false);\n+                        nested.append(nestedPattern);\n+                    } while (token.kind == COMMA);\n+                } else {\n@@ -855,3 +873,3 @@\n-                    JCPattern nestedPattern = parsePattern(token.pos, null, null, true, false);\n-                    nested.append(nestedPattern);\n-                } while (token.kind == COMMA);\n+                }\n+                accept(RPAREN);\n+                pattern = toP(F.at(pos).RecordPattern(e, nested.toList()));\n@@ -859,9 +877,10 @@\n-                nextToken();\n-            }\n-            accept(RPAREN);\n-            pattern = toP(F.at(pos).RecordPattern(e, nested.toList()));\n-        } else {\n-            \/\/type test pattern:\n-            JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n-            if (e == null) {\n-                var.startPos = pos;\n+                \/\/type test pattern:\n+                int varPos = token.pos;\n+                JCVariableDecl var = variableDeclaratorRest(varPos, mods, e, identOrUnderscore(), false, null, false, false, true);\n+                if (e == null) {\n+                    var.startPos = pos;\n+                    if (var.name == names.underscore && !allowVar) {\n+                        log.error(DiagnosticFlag.SYNTAX, varPos, Errors.UnderscoreAsIdentifier);\n+                    }\n+                }\n+                pattern = toP(F.at(pos).BindingPattern(var));\n@@ -869,1 +888,0 @@\n-            pattern = toP(F.at(pos).BindingPattern(var));\n@@ -874,1 +892,0 @@\n-\n@@ -1071,0 +1088,3 @@\n+                    } else if (token.kind == UNDERSCORE) {\n+                        checkSourceLevel(token.pos, Feature.UNNAMED_VARIABLES);\n+                        pattern = parsePattern(patternPos, mods, type, false, false);\n@@ -2046,1 +2066,0 @@\n-\n@@ -2049,1 +2068,0 @@\n-        List<JCVariableDecl> params;\n@@ -2051,0 +2069,9 @@\n+        \/**\n+         * analyzeParens() has already classified the lambda as EXPLICIT_LAMBDA, due to\n+         * two consecutive identifiers. adding an erroneous parameter (one that\n+         * introduces a mixed implicit\/explicit state) does not need to class with\n+         * either:\n+         *\n+         *  - an explicit parameter, or\n+         *  - one declared with var\n+         * *\/\n@@ -2052,9 +2079,3 @@\n-            if (param.vartype != null && param.name != names.empty) {\n-                if (restrictedTypeName(param.vartype, false) != null) {\n-                    reduce(LambdaParameterKind.VAR);\n-                } else {\n-                    reduce(LambdaParameterKind.EXPLICIT);\n-                }\n-            }\n-            if (param.vartype == null && param.name != names.empty ||\n-                param.vartype != null && param.name == names.empty) {\n+            Assert.check(param.vartype != null);\n+\n+            if (param.name == names.error) {\n@@ -2062,0 +2083,7 @@\n+                return;\n+            }\n+\n+            if (restrictedTypeName(param.vartype, false) != null) {\n+                reduce(LambdaParameterKind.VAR);\n+            } else {\n+                reduce(LambdaParameterKind.EXPLICIT);\n@@ -3068,1 +3096,1 @@\n-        JCVariableDecl formal = variableDeclaratorId(mods, paramType);\n+        JCVariableDecl formal = variableDeclaratorId(mods, paramType, true, false, false);\n@@ -3234,1 +3262,1 @@\n-                case ASSERT, ENUM, IDENTIFIER, UNDERSCORE:\n+                case ASSERT, ENUM, IDENTIFIER:\n@@ -3243,0 +3271,12 @@\n+                case UNDERSCORE:\n+                    \/\/ TODO: REFACTOR to remove the code duplication\n+                    if (typeDepth == 0 && peekToken(lookahead, tk -> tk == RPAREN || tk == COMMA)) {\n+                        return PatternResult.PATTERN;\n+                    } else if (typeDepth == 0 && peekToken(lookahead, LAX_IDENTIFIER)) {\n+                        if (parenDepth == 0) {\n+                            return PatternResult.PATTERN;\n+                        } else {\n+                            pendingResult = PatternResult.PATTERN;\n+                        }\n+                    }\n+                    break;\n@@ -3550,1 +3590,1 @@\n-        return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);\n+        return variableDeclaratorsRest(token.pos, mods, type, identOrUnderscore(), false, null, vdefs, localDecl);\n@@ -3568,1 +3608,1 @@\n-        JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);\n+        JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false, false);\n@@ -3583,1 +3623,1 @@\n-        return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);\n+        return variableDeclaratorRest(token.pos, mods, type, identOrUnderscore(), reqInit, dc, localDecl, true, false);\n@@ -3593,1 +3633,1 @@\n-                                  boolean reqInit, Comment dc, boolean localDecl, boolean compound) {\n+                                  boolean reqInit, Comment dc, boolean localDecl, boolean compound, boolean isTypePattern) {\n@@ -3597,0 +3637,8 @@\n+\n+        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.underscore) {\n+            if (!localDecl && !isTypePattern) {\n+                log.error(DiagnosticFlag.SYNTAX, pos, Errors.UnderscoreAsIdentifier);\n+            }\n+            name = names.empty;\n+        }\n+\n@@ -3602,20 +3650,31 @@\n-        JCTree elemType = TreeInfo.innermostType(type, true);\n-        int startPos = Position.NOPOS;\n-        if (elemType.hasTag(IDENT)) {\n-            Name typeName = ((JCIdent)elemType).name;\n-            if (restrictedTypeNameStartingAtSource(typeName, pos, !compound && localDecl) != null) {\n-                if (typeName != names.var) {\n-                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedHere(typeName));\n-                } else if (type.hasTag(TYPEARRAY) && !compound) {\n-                    \/\/error - 'var' and arrays\n-                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n-                } else {\n-                    declaredUsingVar = true;\n-                    if(compound)\n-                        \/\/error - 'var' in compound local var decl\n-                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n-                    startPos = TreeInfo.getStartPos(mods);\n-                    if (startPos == Position.NOPOS)\n-                        startPos = TreeInfo.getStartPos(type);\n-                    \/\/implicit type\n-                    type = null;\n+\n+        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.empty\n+                && localDecl\n+                && init == null\n+                && token.kind != COLON) { \/\/ if its unnamed local variable, it needs to have an init unless in enhanced-for\n+            syntaxError(token.pos, Errors.Expected(EQ));\n+        }\n+\n+        JCVariableDecl result;\n+        if (!isTypePattern) {\n+            int startPos = Position.NOPOS;\n+            JCTree elemType = TreeInfo.innermostType(type, true);\n+            if (elemType.hasTag(IDENT)) {\n+                Name typeName = ((JCIdent) elemType).name;\n+                if (restrictedTypeNameStartingAtSource(typeName, pos, !compound && localDecl) != null) {\n+                    if (typeName != names.var) {\n+                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedHere(typeName));\n+                    } else if (type.hasTag(TYPEARRAY) && !compound) {\n+                        \/\/error - 'var' and arrays\n+                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n+                    } else {\n+                        declaredUsingVar = true;\n+                        if (compound)\n+                            \/\/error - 'var' in compound local var decl\n+                            reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n+                        startPos = TreeInfo.getStartPos(mods);\n+                        if (startPos == Position.NOPOS)\n+                            startPos = TreeInfo.getStartPos(type);\n+                        \/\/implicit type\n+                        type = null;\n+                    }\n@@ -3624,0 +3683,5 @@\n+            result = toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n+            attach(result, dc);\n+            result.startPos = startPos;\n+        } else {\n+            result = toP(F.at(pos).VarDef(mods, name, type, null));\n@@ -3625,4 +3689,1 @@\n-        JCVariableDecl result =\n-            toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n-        attach(result, dc);\n-        result.startPos = startPos;\n+\n@@ -3684,5 +3745,1 @@\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {\n-        return variableDeclaratorId(mods, type, false, false);\n-    }\n-    \/\/where\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {\n+    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean catchParameter, boolean lambdaParameter, boolean recordComponent) {\n@@ -3691,32 +3748,8 @@\n-        if (lambdaParameter && token.kind == UNDERSCORE) {\n-            log.error(pos, Errors.UnderscoreAsIdentifierInLambda);\n-            name = token.name();\n-            nextToken();\n-        } else {\n-            if (allowThisIdent ||\n-                !lambdaParameter ||\n-                LAX_IDENTIFIER.test(token.kind) ||\n-                mods.flags != Flags.PARAMETER ||\n-                mods.annotations.nonEmpty()) {\n-                JCExpression pn = qualident(false);\n-                if (pn.hasTag(Tag.IDENT) && ((JCIdent)pn).name != names._this) {\n-                    name = ((JCIdent)pn).name;\n-                } else if (lambdaParameter && type == null) {\n-                    \/\/ we have a lambda parameter that is not an identifier this is a syntax error\n-                    type = pn;\n-                    name = names.empty;\n-                    reportSyntaxError(pos, Errors.Expected(IDENTIFIER));\n-                } else {\n-                    if (allowThisIdent) {\n-                        if ((mods.flags & Flags.VARARGS) != 0) {\n-                            log.error(token.pos, Errors.VarargsAndReceiver);\n-                        }\n-                        if (token.kind == LBRACKET) {\n-                            log.error(token.pos, Errors.ArrayAndReceiver);\n-                        }\n-                        if (pn.hasTag(Tag.SELECT) && ((JCFieldAccess)pn).name != names._this) {\n-                            log.error(token.pos, Errors.WrongReceiver);\n-                        }\n-                    }\n-                    return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n-                }\n+        if (allowThisIdent ||\n+            !lambdaParameter ||\n+            LAX_IDENTIFIER.test(token.kind) ||\n+            mods.flags != Flags.PARAMETER ||\n+            mods.annotations.nonEmpty()) {\n+            JCExpression pn;\n+            if (token.kind == UNDERSCORE && (catchParameter || lambdaParameter)) {\n+                pn = toP(F.at(token.pos).Ident(identOrUnderscore()));\n@@ -3724,7 +3757,7 @@\n-                \/** if it is a lambda parameter and the token kind is not an identifier,\n-                 *  and there are no modifiers or annotations, then this means that the compiler\n-                 *  supposed the lambda to be explicit but it can contain a mix of implicit,\n-                 *  var or explicit parameters. So we assign the error name to the parameter name\n-                 *  instead of issuing an error and analyze the lambda parameters as a whole at\n-                 *  a higher level.\n-                 *\/\n+                pn = qualident(false);\n+            }\n+            if (pn.hasTag(Tag.IDENT) && ((JCIdent)pn).name != names._this) {\n+                name = ((JCIdent)pn).name;\n+            } else if (lambdaParameter && type == null) {\n+                \/\/ we have a lambda parameter that is not an identifier this is a syntax error\n+                type = pn;\n@@ -3732,0 +3765,14 @@\n+                reportSyntaxError(pos, Errors.Expected(IDENTIFIER));\n+            } else {\n+                if (allowThisIdent) {\n+                    if ((mods.flags & Flags.VARARGS) != 0) {\n+                        log.error(token.pos, Errors.VarargsAndReceiver);\n+                    }\n+                    if (token.kind == LBRACKET) {\n+                        log.error(token.pos, Errors.ArrayAndReceiver);\n+                    }\n+                    if (pn.hasTag(Tag.SELECT) && ((JCFieldAccess)pn).name != names._this) {\n+                        log.error(token.pos, Errors.WrongReceiver);\n+                    }\n+                }\n+                return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n@@ -3733,0 +3780,9 @@\n+        } else {\n+            \/** if it is a lambda parameter and the token kind is not an identifier,\n+             *  and there are no modifiers or annotations, then this means that the compiler\n+             *  supposed the lambda to be explicit but it can contain a mix of implicit,\n+             *  var or explicit parameters. So we assign the error name to the parameter name\n+             *  instead of issuing an error and analyze the lambda parameters as a whole at\n+             *  a higher level.\n+             *\/\n+            name = names.error;\n@@ -3743,0 +3799,4 @@\n+        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.underscore) {\n+            name = names.empty;\n+        }\n+\n@@ -3773,1 +3833,1 @@\n-            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);\n+            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false, false);\n@@ -3778,1 +3838,1 @@\n-            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);\n+            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false, false);\n@@ -4930,1 +4990,1 @@\n-        return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);\n+        return variableDeclaratorId(mods, type, false, lambdaParameter, recordComponent);\n@@ -4935,1 +4995,1 @@\n-        return variableDeclaratorId(mods, null, true, false);\n+        return variableDeclaratorId(mods, null, false, true, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":179,"deletions":119,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-                writer.print(e.asType().toString() + \" \" + e.getSimpleName() );\n+                writer.print(e.asType().toString() + \" \" + (e.getSimpleName().isEmpty() ? \"_\" : e.getSimpleName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3134,0 +3134,3 @@\n+compiler.misc.feature.unnamed.variables=\\\n+    unnamed variables\n+\n@@ -3158,4 +3161,0 @@\n-compiler.err.underscore.as.identifier.in.lambda=\\\n-    ''_'' used as an identifier\\n\\\n-    (use of ''_'' as an identifier is forbidden for lambda parameters)\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+        ANYPATTERN,\n@@ -2266,0 +2267,28 @@\n+    public static class JCAnyPattern extends JCPattern\n+            implements AnyPatternTree {\n+\n+        protected JCAnyPattern() {\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitAnyPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.ANY_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitAnyPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return ANYPATTERN;\n+        }\n+    }\n+\n@@ -2371,0 +2400,1 @@\n+        public JCExpression syntheticGuard;\n@@ -3548,0 +3578,1 @@\n+        public void visitAnyPattern(JCAnyPattern that)       { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -718,1 +718,5 @@\n-                    print(tree.name);\n+                    if (tree.name.isEmpty()) {\n+                        print('_');\n+                    } else {\n+                        print(tree.name);\n+                    }\n@@ -944,0 +948,8 @@\n+    public void visitAnyPattern(JCAnyPattern patt) {\n+        try {\n+            print('_');\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -503,0 +503,6 @@\n+    public JCTree visitAnyPattern(AnyPatternTree node, P p) {\n+        JCAnyPattern t = (JCAnyPattern) node;\n+        return M.at(t.pos).AnyPattern();\n+    }\n+\n+    @DefinedBy(Api.COMPILER_TREE)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1349,0 +1349,1 @@\n+            case ANYPATTERN -> ((JCAnyPattern) pat).type;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -486,0 +486,6 @@\n+    public JCAnyPattern AnyPattern() {\n+        JCAnyPattern tree = new JCAnyPattern();\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -325,0 +326,5 @@\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+    public void visitAnyPattern(JCAnyPattern that) {\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -367,0 +367,4 @@\n+    public void visitAnyPattern(JCAnyPattern tree) {\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    public final Name underscore;\n@@ -265,0 +266,1 @@\n+        underscore = fromString(\"_\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,22 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304246\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @enablePreview\n+ * @compile\/ref=TwrLintUnderscore.out --enable-preview -source ${jdk.version} -Xlint:try -XDrawDiagnostics TwrLintUnderscore.java\n+ *\/\n+class TwrLintUnderscore implements AutoCloseable {\n+    private static void test1() {\n+        try(TwrLintUnderscore _ = new TwrLintUnderscore()) {\n+            \/\/ _ cannot be referenced so no lint warning for an unused resource should be emitted\n+        }\n+    }\n+\n+    \/**\n+     * The AutoCloseable method of a resource.\n+     *\/\n+    @Override\n+    public void close () {\n+        return;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrLintUnderscore.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+- compiler.note.preview.filename: TwrLintUnderscore.java, DEFAULT\n+- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrLintUnderscore.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -151,1 +151,1 @@\n-            \":t\",\n+            \"<error>:t\",\n@@ -162,1 +162,1 @@\n-            \":t\",\n+            \"<error>:t\",\n@@ -172,1 +172,1 @@\n-            \":t\",\n+            \"<error>:t\",\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetScopeResult.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,4 @@\n-\/\/ key: compiler.err.underscore.as.identifier.in.lambda\n+\/\/ key: compiler.misc.feature.unnamed.variables\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnderscoreInLambdaExpression.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-IdentifierTest.java:45:20: compiler.err.underscore.as.identifier\n+IdentifierTest.java:45:20: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.unnamed.variables)\n@@ -6,1 +6,0 @@\n-IdentifierTest.java:51:15: compiler.err.underscore.as.identifier\n@@ -10,2 +9,0 @@\n-IdentifierTest.java:61:21: compiler.err.underscore.as.identifier\n-IdentifierTest.java:62:42: compiler.err.underscore.as.identifier\n@@ -16,1 +13,0 @@\n-IdentifierTest.java:77:22: compiler.err.underscore.as.identifier\n@@ -30,1 +26,0 @@\n-IdentifierTest.java:138:17: compiler.err.underscore.as.identifier\n@@ -34,1 +29,0 @@\n-IdentifierTest.java:143:13: compiler.err.underscore.as.identifier\n@@ -39,1 +33,0 @@\n-IdentifierTest.java:157:16: compiler.err.underscore.as.identifier\n@@ -45,1 +38,1 @@\n-44 errors\n+37 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest9.out","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -9,2 +9,1 @@\n-UnderscoreAsIdent.java:15:16: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:18:18: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:15:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.unnamed.variables)\n@@ -13,1 +12,0 @@\n-UnderscoreAsIdent.java:21:34: compiler.err.underscore.as.identifier\n@@ -18,1 +16,1 @@\n-17 errors\n+15 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/UnderscoreAsIdent9.out","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -15,1 +15,0 @@\n-        if (p instanceof P(_));\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,11 +1,10 @@\n-DeconstructionPatternErrors.java:15:28: compiler.err.underscore.as.identifier\n-DeconstructionPatternErrors.java:15:29: compiler.err.expected: token.identifier\n-DeconstructionPatternErrors.java:43:37: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:45:28: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:47:42: compiler.err.expected: ';'\n-DeconstructionPatternErrors.java:47:43: compiler.err.not.stmt\n-DeconstructionPatternErrors.java:16:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<java.lang.String>, java.util.ArrayList<java.lang.Integer>)\n-DeconstructionPatternErrors.java:17:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, java.util.ArrayList<java.lang.Integer>\n-DeconstructionPatternErrors.java:18:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-DeconstructionPatternErrors.java:19:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\n-DeconstructionPatternErrors.java:20:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, DeconstructionPatternErrors.P)\n+DeconstructionPatternErrors.java:42:37: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:44:28: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:46:42: compiler.err.expected: ';'\n+DeconstructionPatternErrors.java:46:43: compiler.err.not.stmt\n+DeconstructionPatternErrors.java:15:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<java.lang.String>, java.util.ArrayList<java.lang.Integer>)\n+DeconstructionPatternErrors.java:16:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, java.util.ArrayList<java.lang.Integer>\n+DeconstructionPatternErrors.java:17:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+DeconstructionPatternErrors.java:18:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\n+DeconstructionPatternErrors.java:19:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, DeconstructionPatternErrors.P)\n+DeconstructionPatternErrors.java:20:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n@@ -13,17 +12,16 @@\n-DeconstructionPatternErrors.java:22:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n-DeconstructionPatternErrors.java:23:26: compiler.err.incorrect.number.of.nested.patterns: int, int,compiler.misc.type.none\n-DeconstructionPatternErrors.java:24:26: compiler.err.incorrect.number.of.nested.patterns: int, int,int\n-DeconstructionPatternErrors.java:25:36: compiler.err.cant.resolve.location: kindname.class, Unresolvable, , , (compiler.misc.location: kindname.class, DeconstructionPatternErrors, null)\n-DeconstructionPatternErrors.java:25:26: compiler.err.incorrect.number.of.nested.patterns: int, int,Unresolvable\n-DeconstructionPatternErrors.java:26:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n-DeconstructionPatternErrors.java:27:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n-DeconstructionPatternErrors.java:28:44: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n-DeconstructionPatternErrors.java:28:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n-DeconstructionPatternErrors.java:29:40: compiler.err.match.binding.exists\n-DeconstructionPatternErrors.java:30:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, meth()\n-DeconstructionPatternErrors.java:30:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, meth()\n-DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:32:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:35:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-28 errors\n+DeconstructionPatternErrors.java:22:26: compiler.err.incorrect.number.of.nested.patterns: int, int,compiler.misc.type.none\n+DeconstructionPatternErrors.java:23:26: compiler.err.incorrect.number.of.nested.patterns: int, int,int\n+DeconstructionPatternErrors.java:24:36: compiler.err.cant.resolve.location: kindname.class, Unresolvable, , , (compiler.misc.location: kindname.class, DeconstructionPatternErrors, null)\n+DeconstructionPatternErrors.java:24:26: compiler.err.incorrect.number.of.nested.patterns: int, int,Unresolvable\n+DeconstructionPatternErrors.java:25:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:26:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:27:44: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+DeconstructionPatternErrors.java:27:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:28:40: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:29:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, meth()\n+DeconstructionPatternErrors.java:29:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, meth()\n+DeconstructionPatternErrors.java:30:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n+DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n+DeconstructionPatternErrors.java:33:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n+DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n+26 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":26,"deletions":28,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -51,0 +52,1 @@\n+                      \"         boolean _ = true;\\n\" +\n@@ -56,0 +58,3 @@\n+                      \"         b = o instanceof R(String _);\\n\" +\n+                      \"         b = o instanceof R2(R(var _), var _);\\n\" +\n+                      \"         b = o instanceof R2(R(_), var t);\\n\" +\n@@ -62,21 +67,25 @@\n-                          \\n\\\n-                          class Test {\n-                              \\n\\\n-                              boolean t(Object o) {\n-                                  boolean b;\n-                                  b = o instanceof String s;\n-                                  b = o instanceof R(String s);\n-                                  b = o instanceof R(\/*missing*\/ s);\n-                                  b = o instanceof R2(R(\/*missing*\/ s), String t);\n-                                  b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n-                              }\n-                              \\n\\\n-                              class R {\n-                                  private final String s;\n-                              }\n-                              \\n\\\n-                              class R2 {\n-                                  private final R r;\n-                                  private final String s;\n-                              }\n-                          }\"\"\";\n+                \\n\\\n+                class Test {\n+                    \\n\\\n+                    boolean t(Object o) {\n+                        boolean b;\n+                        boolean _ = true;\n+                        b = o instanceof String s;\n+                        b = o instanceof R(String s);\n+                        b = o instanceof R(\/*missing*\/ s);\n+                        b = o instanceof R2(R(\/*missing*\/ s), String t);\n+                        b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n+                        b = o instanceof R(String _);\n+                        b = o instanceof R2(R(\/*missing*\/ _), \/*missing*\/ _);\n+                        b = o instanceof R2(R(_), \/*missing*\/ t);\n+                    }\n+                    \\n\\\n+                    class R {\n+                        private final String s;\n+                    }\n+                    \\n\\\n+                    class R2 {\n+                        private final R r;\n+                        private final String s;\n+                    }\n+                }\"\"\";\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8304246\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @enablePreview\n+ * @compile Unnamed.java\n+ * @run main Unnamed\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class Unnamed {\n+    public static void main(String[] args) throws Throwable {\n+        new Unnamed().run();\n+    }\n+\n+    public void run() {\n+        assertEquals(1, testMultiValuesTopLevel(new R1()));\n+        assertEquals(2, testMultiValuesTopLevel(new R3()));\n+        assertEquals(1, testMultiValuesTopLevel2(new R1()));\n+        assertEquals(2, testMultiValuesTopLevel2(new R2()));\n+        assertEquals(2, testMultiValuesTopLevel2(new R4()));\n+        assertEquals(1, testMultiValuesNested(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesNested(new Box<>(new R2())));\n+        assertEquals(2, testMultiValuesNested(new Box<>(new R3())));\n+        assertEquals(3, testMultiValuesNested(new Box<>(new R4())));\n+        assertEquals(1, testMultiValuesNestedUnnamedVarAndPattern(new Box<>(new R1())));\n+        assertEquals(2, testMultiValuesNestedUnnamedVarAndPattern(new Box<>(new R4())));\n+        assertEquals(1, testMultiValuesNestedMix(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesNestedMix(new Box2<>(new R1())));\n+        assertEquals(1, testMultiValuesNestedMix2(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesNestedMix2(\"BOX\"));\n+        assertEquals(2, testMultiValuesNestedMix2(new Box2<>(new R1())));\n+        assertEquals(1, testMultiValuesStatementBlock(42));\n+        assertEquals(1, testMultiValuesStatementBlock(42.0f));\n+        assertEquals(2, testMultiValuesStatementBlock(\"BOX\"));\n+        assertEquals(1, testMultiValuesStatementBlock2(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesStatementBlock2(\"BOX\"));\n+        assertEquals(2, testMultiValuesStatementBlock2(new Box2<>(new R1())));\n+        assertEquals(2, testMultiValuesGuards(new R3(), 1));\n+        assertEquals(3, testMultiValuesGuards(new R4(), 42));\n+        assertEquals(3, testMultiValuesGuards(new R3(), 42));\n+        assertEquals(1, testMultiValuesNestedGuards(new Box(new R2()), 42));\n+        assertEquals(2, testMultiValuesNestedGuards(new Box(new R3()), 1));\n+        assertEquals(1, testMixUnconditionalAndConditional(new R1()));\n+        assertEquals(2, testMixUnconditionalAndConditional(new R2()));\n+        assertEquals(2, testMixUnconditionalAndConditional(new R3()));\n+        assertEquals(1, testMultipleExpr(new Box<>(new R1())));\n+        assertEquals(1, testUnrolledExpr(new Box<>(new R1())));\n+        assertEquals(1, testMultipleStat(new Box<>(new R1())));\n+        assertEquals(1, testUnrolledStat(new Box<>(new R1())));\n+        assertEquals(2, testMixVarWithExplicit(new Box<>(new R2())));\n+        assertEquals(\"binding\", unnamedGuardAddsBindings(\"match1\", \"binding\"));\n+        assertEquals(\"any\", unnamedGuardAddsBindings(42, 42));\n+\n+        unnamedTest();\n+    }\n+\n+    private void unnamedTest() {\n+        int _ = 0;\n+        int _ = 1;\n+        try (Lock _ = null) {\n+            try (Lock _ = null) {\n+            } catch (Exception _) {\n+                try {\n+                } catch (Exception _) {}\n+            }\n+        }\n+        String[] strs = new String[] { \"str1\", \"str2\" };\n+        for (var _ : strs) {\n+            for (var _ : strs) {\n+            }\n+        }\n+        TwoParams p1 = (_, _) -> {};\n+        TwoParams p2 = (var _, var _) -> {};\n+        TwoIntParams p3 = (int _, int b) -> {};\n+        TwoIntParams p4 = (int _, int _) -> {};\n+        TwoIntParamsIntRet p5 = (int _, int _) -> { return 1; };\n+\n+        p1.run(1, 2);\n+        p2.run(1, 2);\n+        p3.run(1, 2);\n+        p4.run(1, 2);\n+        p5.run(1, 2);\n+\n+        R r = new R(null);\n+        if (r instanceof R _) {}\n+        if (r instanceof R(_)) {}\n+        for (int _ = 0, _ = 1, x = 1; x <= 1 ; x++) {}\n+    }\n+\n+    int testMultiValuesTopLevel(Object o) {\n+        return switch (o) {\n+            case R1 _, R2 _ -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesTopLevel2(Base o) {\n+        return switch (o) {\n+            case R1 r -> 1;\n+            case R2 _, R3 _, R4 _ -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesNested(Box<?> b) {\n+        return switch (b) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            case Box(R3 _) -> 2;\n+            case Box(_)  -> 3;\n+        };\n+    }\n+\n+    int testMultiValuesNestedUnnamedVarAndPattern(Box<?> b) {\n+        return switch (b) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            case Box(R3 _), Box(_) -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesNestedMix(Object b) {\n+        return switch (b) {\n+            case Box(_), Box2(_) -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesNestedMix2(Object b) {\n+        return switch (b) {\n+            case Box(_), String _ -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesStatementBlock(Object o) {\n+        switch (o) {\n+            case Integer _:\n+            case Number _:\n+                return 1;\n+            default:\n+                return 2;\n+        }\n+    }\n+\n+    int testMultiValuesStatementBlock2(Object o) {\n+        switch (o) {\n+            case Box(_):\n+            case String _:\n+                return 1;\n+            default:\n+                return 2;\n+        }\n+    }\n+\n+    int testMultiValuesGuards(Base b, int x) {\n+        return switch (b) {\n+            case R1 r -> 1;\n+            case R2 _, R3 _, R4 _ when x == 1 -> 2;\n+            case R2 _, R3 _, R4 _ -> 3;\n+        };\n+    }\n+\n+    int testMultiValuesNestedGuards(Box<?> b, int x) {\n+        return switch (b) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            case Box(R3 _), Box(_) when x == 1 -> 2;\n+            case Box(_) -> 3;\n+        };\n+    }\n+\n+    int testMixUnconditionalAndConditional(Base t) {\n+        return switch(t) {\n+            case R1 _ -> 1;\n+            case R2 _, Base _-> 2;\n+        };\n+    }\n+\n+    int testMultipleExpr(Box<?> t) {\n+        return switch(t) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            default -> -2;\n+        };\n+    }\n+\n+    int testUnrolledExpr(Box<?> t) {\n+        return switch(t) {\n+            case Box(R1 _) -> 1;\n+            case Box(R2 _) -> 0;\n+            default -> -2;\n+        };\n+    }\n+\n+    int testMultipleStat(Box<?> t) {\n+        int ret = -1;\n+        switch(t) {\n+            case Box(R1 _), Box(R2 _):\n+                ret = 1;\n+                break;\n+            default:\n+                ret = -2;\n+        }\n+        return ret;\n+    }\n+\n+    int testUnrolledStat(Box<?> t) {\n+        int ret = -1;\n+        switch(t) {\n+            case Box(R1 _):\n+                ret = 1;\n+                break;\n+            case Box(R2 _):\n+                ret = 0;\n+                break;\n+            default:\n+                ret = -2;\n+        }\n+        return ret;\n+    }\n+\n+    int testMixVarWithExplicit(Box<?> t) {\n+        int success = -1;\n+        success = switch(t) {\n+            case Box(R1 _) : {\n+                yield 1;\n+            }\n+            case Box(R2 _), Box(var _) : {\n+                yield 2;\n+            }\n+            default : {\n+                yield -2;\n+            }\n+        };\n+        return success;\n+    }\n+\n+    String unnamedGuardAddsBindings(Object o1, Object o2) {\n+        return switch (o1) {\n+            case String _, Object _ when o2 instanceof String s: yield s;\n+            case Object _: yield \"any\";\n+        };\n+    }\n+\n+    \/\/ JEP 443 examples\n+    record Point(int x, int y) { }\n+    enum Color { RED, GREEN, BLUE }\n+    record ColoredPoint(Point p, Color c) { }\n+\n+    void jep443examples(ColoredPoint r) {\n+        if (r instanceof ColoredPoint(Point(int x, int y), _)) { }\n+        if (r instanceof ColoredPoint(_, Color c)) { }\n+        if (r instanceof ColoredPoint(Point(int x, _), _)) { }\n+        if (r instanceof ColoredPoint(Point(int x, int _), Color _)) { }\n+        if (r instanceof ColoredPoint _) { }\n+    }\n+\n+    class Lock implements AutoCloseable {\n+        @Override\n+        public void close() {}\n+    }\n+    interface TwoParams {\n+        public void run(Object o1, Object o2);\n+    }\n+    interface TwoIntParams {\n+        public void run(int o1, int o2);\n+    }\n+    interface TwoIntParamsIntRet {\n+        public int run(int a, int b);\n+    }\n+    record R(Object o) {}\n+\n+    sealed abstract class Base permits R1, R2, R3, R4 { }\n+    final  class R1  extends Base { }\n+    final  class R2  extends Base { }\n+    final  class R3  extends Base { }\n+    final  class R4  extends Base { }\n+    record Box<T extends Base>(T content) { }\n+    record Box2<T extends Base>(T content) { }\n+    void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Unnamed.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304246\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @enablePreview\n+ * @compile\/fail\/ref=UnnamedErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW UnnamedErrors.java\n+ *\/\n+public class UnnamedErrors {\n+    private int _; \/\/ error\n+    private int _, x;  \/\/ error\n+    private int x, _, y, _, z, _;  \/\/ error\n+    private int _ = 0, _ = 1; \/\/ error\n+    private int a = 0, _ = 1; \/\/ error\n+\n+    record R(int _) {} \/\/no record components\n+    UnnamedErrors(int _) {} \/\/no constructor parameters\n+    void test(int _) {} \/\/no method parameters\n+\n+    record RR(int x) {}\n+    void test2() {\n+        Object o = Integer.valueOf(42);\n+        if (o instanceof _) {} \/\/no top level\n+\n+        if (o instanceof _(int x)) {} \/\/no record pattern head\n+\n+        switch (o) {\n+            case _:\n+                System.out.println(\"no underscore top level\");\n+            default:\n+                System.out.println(\"\");\n+        }\n+\n+        switch (o) {\n+            case var _:\n+                System.out.println(\"no var _ top level\");\n+            default:\n+                System.out.println(\"\");\n+        }\n+    }\n+\n+    void dominanceError(Object o) {\n+        switch (o) {\n+            case Number _ ->\n+                    System.out.println(\"A Number\");\n+            case Integer _, String _ ->             \/\/ Error - dominated case pattern: `Integer _`\n+                    System.out.println(\"An Integer or a String\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+    }\n+\n+    void mixedNamedUnnamedError(Object o) {\n+        switch (o) {\n+            case Integer i, String _ ->\n+                    System.out.println(\"named\/unnamed\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+\n+        switch (o) {\n+            case Integer _, String s ->\n+                    System.out.println(\"unnamed\/named\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+\n+        switch (o) {\n+            case PairIS(_, _), String s ->\n+                    System.out.println(\"unnamed patterns\/named\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+    }\n+\n+    private void test1() {\n+        try (Lock _ = null) {\n+        } catch (_) { }\n+    }\n+\n+    int guardErrors(Object o, int x1, int x2) {\n+        return switch (o) {\n+            case Integer _ when x1 == 2, String _ when x2 == 1 -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMixVarWithExplicitDominanceError(Box<?> t) {\n+        int success = -1;\n+        success = switch(t) {\n+            case Box(var _), Box(R2 _) : {\n+                yield 1;\n+            }\n+            default : {\n+                yield -2;\n+            }\n+        };\n+        return success;\n+    }\n+\n+    void testUnderscoreWithoutInitializer() {\n+        int _;\n+        int x1 = 1, _, x2;\n+\n+        for (int x = 1, _; x<=1; x++) {\n+\n+        }\n+    }\n+\n+    class Lock implements AutoCloseable {\n+        @Override\n+        public void close() {}\n+    }\n+    record PairIS(int i, String s) {}\n+    sealed abstract class Base permits R1, R2 { }\n+    final  class R1  extends Base { }\n+    final  class R2  extends Base { }\n+    record Box<T extends Base>(T content) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/UnnamedErrors.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+UnnamedErrors.java:9:17: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:10:17: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:11:20: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:11:26: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:11:32: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:12:17: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:12:24: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:13:24: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:15:18: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:16:23: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:17:19: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:22:26: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:24:26: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:27:18: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:34:18: compiler.err.restricted.type.not.allowed.here: var\n+UnnamedErrors.java:77:18: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:77:19: compiler.err.expected: token.identifier\n+UnnamedErrors.java:82:40: compiler.err.expected2: :, ->\n+UnnamedErrors.java:82:51: compiler.err.expected: =\n+UnnamedErrors.java:82:58: compiler.err.expected: ';'\n+UnnamedErrors.java:101:14: compiler.err.expected: =\n+UnnamedErrors.java:102:22: compiler.err.expected: =\n+UnnamedErrors.java:104:26: compiler.err.expected: =\n+UnnamedErrors.java:11:17: compiler.err.already.defined: kindname.variable, x, kindname.class, UnnamedErrors\n+UnnamedErrors.java:36:13: compiler.err.unconditional.pattern.and.default\n+UnnamedErrors.java:45:18: compiler.err.pattern.dominated\n+UnnamedErrors.java:54:29: compiler.err.flows.through.from.pattern\n+UnnamedErrors.java:61:29: compiler.err.flows.through.from.pattern\n+UnnamedErrors.java:68:32: compiler.err.flows.through.from.pattern\n+UnnamedErrors.java:82:56: compiler.err.already.defined: kindname.variable, x2, kindname.method, guardErrors(java.lang.Object,int,int)\n+UnnamedErrors.java:83:13: compiler.err.switch.mixing.case.types\n+UnnamedErrors.java:90:30: compiler.err.pattern.dominated\n+- compiler.note.preview.filename: UnnamedErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+32 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/UnnamedErrors.out","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -38,2 +38,0 @@\n-import javax.lang.model.SourceVersion;\n-import static javax.lang.model.SourceVersion.*;\n@@ -41,4 +39,0 @@\n-import javax.lang.model.util.*;\n-import static javax.lang.model.util.ElementFilter.*;\n-import static javax.tools.Diagnostic.Kind.*;\n-import static javax.tools.StandardLocation.*;\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestNames.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302344 8307007\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\n+ * @build   JavacTestingAbstractProcessor\n+ * @enablePreview\n+ * @compile TestUnnamedVariableElement.java\n+ * @compile --enable-preview -source ${jdk.version} -processor TestUnnamedVariableElement -proc:only TestUnnamedVariableElementData.java\n+ *\/\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+import java.util.*;\n+import com.sun.source.tree.*;\n+import com.sun.source.util.*;\n+import java.io.StringWriter;\n+\n+public class TestUnnamedVariableElement extends JavacTestingAbstractProcessor implements AutoCloseable {\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            Trees trees = Trees.instance(processingEnv);\n+\n+            for(Element rootElement : roundEnv.getRootElements()) {\n+                TreePath treePath = trees.getPath(rootElement);\n+\n+                (new UnnamedVariableScanner(processingEnv.getElementUtils(), trees)).\n+                        scan(treePath.getCompilationUnit(), null);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void close() {}\n+\n+    class UnnamedVariableScanner extends TreePathScanner<Void, Void> {\n+\n+        private final Elements elements;\n+        private Trees trees;\n+\n+        public UnnamedVariableScanner(Elements elements, Trees trees) {\n+            super();\n+            this.elements = elements;\n+            this.trees = trees;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Void unused) {\n+            handleTreeAsLocalVar(getCurrentPath());\n+\n+            if(!node.getName().isEmpty()) {\n+                throw new RuntimeException(\"Expected empty name as the name of the Tree API but got: \" + node.getName());\n+            }\n+\n+            return super.visitVariable(node, unused);\n+        }\n+\n+        private void handleTreeAsLocalVar(TreePath tp) {\n+            VariableElement element = (VariableElement) trees.getElement(tp);\n+\n+            System.out.println(\"Name: \" + element.getSimpleName() +\n+                    \"\\tKind: \" + element.getKind());\n+            if (element.getKind() != ElementKind.LOCAL_VARIABLE) {\n+                throw new RuntimeException(\"Expected a local variable, but got: \" +\n+                        element.getKind());\n+            }\n+            StringWriter out = new StringWriter();\n+            String expected = \"int _;\";\n+            elements.printElements(out, element);\n+            if (!expected.equals(out.toString().trim())) {\n+                throw new RuntimeException(\"Expected: \" + expected + \", but got: \" + out.toString());\n+            }\n+            testUnnamedVariable(element);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a local variable modeled as an element behaves\n+     * as expected under 6 and latest specific visitors.\n+     *\/\n+    private static void testUnnamedVariable(Element element) {\n+        ElementKindVisitor visitorLatest =\n+                new ElementKindVisitor<Object, Void>() {\n+                    @Override\n+                    public Object visitVariableAsLocalVariable(VariableElement e,\n+                                                               Void p) {\n+                        return e;\n+                    }\n+                };\n+\n+        if (visitorLatest.visit(element) == null) {\n+            throw new RuntimeException(\"Null result of a resource variable visitation.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElement.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302344 8307007\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\n+ * @build   JavacTestingAbstractProcessor\n+ * @compile TestUnnamedVariableElement8.java\n+ * @compile -source 8 -processor TestUnnamedVariableElement8 -proc:only TestUnnamedVariableElementData.java\n+ *\/\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import java.util.Set;\n+\n+public class TestUnnamedVariableElement8 extends JavacTestingAbstractProcessor implements AutoCloseable {\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            Trees trees = Trees.instance(processingEnv);\n+\n+            for(Element rootElement : roundEnv.getRootElements()) {\n+                TreePath treePath = trees.getPath(rootElement);\n+\n+                (new UnnamedVariableScanner(trees)).\n+                        scan(treePath.getCompilationUnit(), null);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void close() {}\n+\n+    class UnnamedVariableScanner extends TreePathScanner<Void, Void> {\n+        private Trees trees;\n+\n+        public UnnamedVariableScanner(Trees trees) {\n+            super();\n+            this.trees = trees;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Void unused) {\n+            handleTreeAsLocalVar(getCurrentPath());\n+            return super.visitVariable(node, unused);\n+        }\n+\n+        private void handleTreeAsLocalVar(TreePath tp) {\n+            Element element = trees.getElement(tp);\n+\n+            System.out.println(\"Name: \" + element.getSimpleName() +\n+                    \"\\tKind: \" + element.getKind());\n+            if (element.getKind() != ElementKind.LOCAL_VARIABLE) {\n+                throw new RuntimeException(\"Expected a local variable, but got: \" +\n+                        element.getKind());\n+            }\n+            if (!element.getSimpleName().toString().equals(\"_\")) {\n+                throw new RuntimeException(\"Expected _ for simple name of an unnamed variable, but got: \" +\n+                        element.getSimpleName());\n+            }\n+            testUnnamedVariable(element);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a local variable modeled as an element behaves\n+     * as expected under 6 and latest specific visitors.\n+     *\/\n+    private static void testUnnamedVariable(Element element) {\n+        ElementKindVisitor visitorLatest =\n+                new ElementKindVisitor<Object, Void>() {\n+                    @Override\n+                    public Object visitVariableAsLocalVariable(VariableElement e,\n+                                                               Void p) {\n+                        return e;\n+                    }\n+                };\n+\n+        if (visitorLatest.visit(element) == null) {\n+            throw new RuntimeException(\"Null result of a resource variable visitation.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElement8.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -23,3 +23,4 @@\n-public class A {\n-    public static void main(String[] args) throws Exception {\n-        B.go();\n+\n+public class TestUnnamedVariableElementData {\n+    private void test() {\n+        int _ = 0;\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElementData.java","additions":4,"deletions":3,"binary":false,"changes":7,"previous_filename":"test\/lib-test\/jdk\/test\/lib\/process\/proc\/A.java","status":"copied"},{"patch":"@@ -70,2 +70,0 @@\n-        test.run(\"java.util.function.IntBinaryOperator c = (var x, |testType|) -> 1;\",\n-                 \"testType \");\n","filename":"test\/langtools\/tools\/javac\/tree\/VarTree.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}