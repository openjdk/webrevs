{"files":[{"patch":"@@ -100,7 +100,12 @@\n-    \/\/ Get buffer size needed to read all processes\n-    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};\n-    if (sysctl(mib, 4, NULL, &bufSize, NULL, 0) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError(env,\n-            \"java\/lang\/RuntimeException\", \"sysctl failed\");\n-        return -1;\n-    }\n+    int errsysctl;\n+    int maxRetries = 100;\n+    void *buffer = NULL;\n+    do {\n+        int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};\n+        if (buffer != NULL) free(buffer);\n+        \/\/ Get buffer size needed to read all processes\n+        if (sysctl(mib, 4, NULL, &bufSize, NULL, 0) < 0) {\n+            JNU_ThrowByNameWithMessageAndLastError(env,\n+                \"java\/lang\/RuntimeException\", \"sysctl failed\");\n+            return -1;\n+        }\n@@ -108,6 +113,12 @@\n-    \/\/ Allocate buffer big enough for all processes\n-    void *buffer = malloc(bufSize);\n-    if (buffer == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"malloc failed\");\n-        return -1;\n-    }\n+        \/\/ Allocate buffer big enough for all processes; add a little\n+        \/\/ bit of space to be able to hold a few more proc infos\n+        \/\/ for processes started rigth after the first sysctl call\n+        buffer = malloc(bufSize + 4 * sizeof(struct kinfo_proc));\n+        if (buffer == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, \"malloc failed\");\n+            return -1;\n+        }\n+\n+        \/\/ Read process info for all processes\n+        errsysctl = sysctl(mib, 4, buffer, &bufSize, NULL, 0);\n+    } while (errsysctl < 0 && maxRetries-- > 0);\n@@ -115,2 +126,1 @@\n-    \/\/ Read process info for all processes\n-    if (sysctl(mib, 4, buffer, &bufSize, NULL, 0) < 0) {\n+    if (errsysctl < 0) {\n","filename":"src\/java.base\/macosx\/native\/libjava\/ProcessHandleImpl_macosx.c","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"}]}