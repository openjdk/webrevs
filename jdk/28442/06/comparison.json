{"files":[{"patch":"@@ -5624,2 +5624,2 @@\n-    jccb(Assembler::equal, L_end);\n-    fill64_masked(3, base, 0, xtmp, mask, cnt, rtmp, true);\n+    jcc(Assembler::equal, L_end);\n+    fill64_tail(3, base, 0, xtmp, cnt, rtmp);\n@@ -5642,1 +5642,1 @@\n-  jccb(Assembler::lessEqual, L_end);\n+  jcc(Assembler::lessEqual, L_end);\n@@ -5644,1 +5644,1 @@\n-    fill32_masked(3, base, 0, xtmp, mask, cnt, rtmp);\n+    fill32_tail(3, base, 0, xtmp, cnt, rtmp);\n@@ -5768,1 +5768,1 @@\n-    jccb(Assembler::negative, DONE); \/\/ Zero length\n+    jcc(Assembler::negative, DONE); \/\/ Zero length\n@@ -5775,1 +5775,1 @@\n-    jmpb(DONE);\n+    jmp(DONE);\n@@ -9187,35 +9187,0 @@\n-void MacroAssembler::fill_masked(BasicType bt, Address dst, XMMRegister xmm, KRegister mask,\n-                                 Register length, Register temp, int vec_enc) {\n-  \/\/ Computing mask for predicated vector store.\n-  movptr(temp, -1);\n-  bzhiq(temp, temp, length);\n-  kmov(mask, temp);\n-  evmovdqu(bt, mask, dst, xmm, true, vec_enc);\n-}\n-\n-\/\/ Set memory operation for length \"less than\" 64 bytes.\n-void MacroAssembler::fill64_masked(uint shift, Register dst, int disp,\n-                                       XMMRegister xmm, KRegister mask, Register length,\n-                                       Register temp, bool use64byteVector) {\n-  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n-  const BasicType type[] = { T_BYTE, T_SHORT, T_INT, T_LONG};\n-  if (!use64byteVector) {\n-    fill32(dst, disp, xmm);\n-    subptr(length, 32 >> shift);\n-    fill32_masked(shift, dst, disp + 32, xmm, mask, length, temp);\n-  } else {\n-    assert(MaxVectorSize == 64, \"vector length != 64\");\n-    fill_masked(type[shift], Address(dst, disp), xmm, mask, length, temp, Assembler::AVX_512bit);\n-  }\n-}\n-\n-\n-void MacroAssembler::fill32_masked(uint shift, Register dst, int disp,\n-                                       XMMRegister xmm, KRegister mask, Register length,\n-                                       Register temp) {\n-  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n-  const BasicType type[] = { T_BYTE, T_SHORT, T_INT, T_LONG};\n-  fill_masked(type[shift], Address(dst, disp), xmm, mask, length, temp, Assembler::AVX_256bit);\n-}\n-\n-\n@@ -9245,0 +9210,78 @@\n+void MacroAssembler::fill32_tail(uint shift, Register dst, int disp, XMMRegister xmm,\n+                                      Register length, Register temp) {\n+  \/\/ This stub assumes that fill size <= 32 bytes (i.e. length <= (32 >> shift))\n+  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n+  Label L16, L8, L4, L2, L1, L_done;\n+  \/\/ Fastpath for fill size <= 4 bytes\n+  cmpq(length, 4 >> shift);\n+  jcc(Assembler::lessEqual, L4);\n+\n+  \/\/ 32-byte store\n+  cmpq(length, 32 >> shift);\n+  jcc(Assembler::less, L16);\n+  vmovdqu(Address(dst, disp), xmm);\n+  addq(dst, 32);\n+  subq(length, 32 >> shift);\n+  jcc(Assembler::equal, L_done);\n+\n+  \/\/ 16-byte store\n+  bind(L16);\n+  cmpq(length, 16 >> shift);\n+  jcc(Assembler::less, L8);\n+  movdqu(Address(dst, disp), xmm);\n+  addq(dst, 16);\n+  subq(length, 16 >> shift);\n+\n+  \/\/ 8-byte store\n+  bind(L8);\n+  cmpq(length, 8 >> shift);\n+  jcc(Assembler::less, L4);\n+  movq(Address(dst, disp), xmm);\n+  addq(dst, 8);\n+  subq(length, 8 >> shift);\n+\n+  \/\/ 4-byte store\n+  bind(L4);\n+  \/\/ temp holds low 8 bytes of xmm for 4\/2\/1B stores\n+  movq(temp, xmm);\n+  cmpq(length, 4 >> shift);\n+  jcc(Assembler::less, L2);\n+  movl(Address(dst, disp), temp);\n+  addq(dst, 4);\n+  subq(length, 4 >> shift);\n+\n+  \/\/ 2-byte store\n+  bind(L2);\n+  cmpq(length, 2 >> shift);\n+  jcc(Assembler::less, L1);\n+  movw(Address(dst, disp), temp);\n+  addq(dst, 2);\n+  subq(length, 2 >> shift);\n+\n+  \/\/ 1-byte store\n+  bind(L1);\n+  testq(length, length);\n+  jcc(Assembler::zero, L_done);\n+  movb(Address(dst, disp), temp);\n+\n+  bind(L_done);\n+}\n+\n+void MacroAssembler::fill64_tail(uint shift, Register dst, int disp,\n+                                     XMMRegister xmm, Register length,\n+                                     Register temp) {\n+  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n+  Label L32, L_exit;\n+  \/\/ Check if size > 32B\n+  cmpq(length, 32 >> shift);\n+  jcc(Assembler::lessEqual, L32);\n+  fill32(dst, disp, xmm);\n+  subq(length, 32 >> shift);\n+  fill32_tail(shift, dst, disp + 32, xmm, length, temp);\n+  jmp(L_exit);\n+  \/\/ Size <= 32B\n+  bind(L32);\n+  fill32_tail(shift, dst, disp, xmm, length, temp);\n+  bind(L_exit);\n+}\n+\n@@ -9249,0 +9292,2 @@\n+  Label L_fill_32_tail;\n+  Label L_fill_64_tail;\n@@ -9275,1 +9320,18 @@\n-  if ((avx3threshold != 0)  || (MaxVectorSize == 32)) {\n+  \/\/ Fastpath for fill count <= 4 bytes.\n+  if (type == T_BYTE) {\n+    Label L_done;\n+    cmpq(count, 4);\n+    jccb(Assembler::greater, L_done);\n+    movb(Address(to, 0), value);\n+    cmpq(count, 1);\n+    jcc(Assembler::equal, L_exit);\n+    movb(Address(to, 1), value);\n+    cmpq(count, 2);\n+    jcc(Assembler::equal, L_exit);\n+    movb(Address(to, 2), value);\n+    cmpq(count, 3);\n+    jcc(Assembler::equal, L_exit);\n+    movb(Address(to, 3), value);\n+    jmp(L_exit);\n+    bind(L_done);\n+  }\n@@ -9277,4 +9339,1 @@\n-    if (MaxVectorSize == 64) {\n-      cmpq(count, avx3threshold >> shift);\n-      jcc(Assembler::greater, L_fill_zmm_sequence);\n-    }\n+  if ((avx3threshold != 0)  || (MaxVectorSize == 32)) {\n@@ -9287,3 +9346,1 @@\n-    jccb(Assembler::greater, L_fill_64_bytes);\n-    fill32_masked(shift, to, 0, xtmp, k2, count, rtmp);\n-    jmp(L_exit);\n+    jcc(Assembler::lessEqual, L_fill_32_tail);\n@@ -9292,0 +9349,6 @@\n+\n+    if (MaxVectorSize == 64) {\n+      cmpq(count, avx3threshold >> shift);\n+      jcc(Assembler::greater, L_fill_zmm_sequence);\n+    }\n+\n@@ -9294,2 +9357,4 @@\n-    fill64_masked(shift, to, 0, xtmp, k2, count, rtmp);\n-    jmp(L_exit);\n+    fill32(to, 0, xtmp);\n+    addptr(to, 32);\n+    subq(count, 32 >> shift);\n+    jmp(L_fill_32_tail);\n@@ -9301,0 +9366,1 @@\n+    addptr(to, 64);\n@@ -9302,2 +9368,1 @@\n-    fill32_masked(shift, to, 64, xtmp, k2, count, rtmp);\n-    jmp(L_exit);\n+    jmp(L_fill_32_tail);\n@@ -9310,0 +9375,1 @@\n+    addptr(to, 96);\n@@ -9311,2 +9377,1 @@\n-    fill32_masked(shift, to, 96, xtmp, k2, count, rtmp);\n-    jmp(L_exit);\n+    jmp(L_fill_32_tail);\n@@ -9364,2 +9429,1 @@\n-    fill64_masked(shift, to, 0, xtmp, k2, count, rtmp, true);\n-    jmp(L_exit);\n+    jmp(L_fill_64_tail);\n@@ -9371,0 +9435,1 @@\n+    addptr(to, 64);\n@@ -9372,2 +9437,1 @@\n-    fill64_masked(shift, to, 64, xtmp, k2, count, rtmp, true);\n-    jmp(L_exit);\n+    jmp(L_fill_64_tail);\n@@ -9380,0 +9444,1 @@\n+    addptr(to, 128);\n@@ -9381,2 +9446,1 @@\n-    fill64_masked(shift, to, 128, xtmp, k2, count, rtmp, true);\n-    jmp(L_exit);\n+    jmp(L_fill_64_tail);\n@@ -9418,0 +9482,8 @@\n+\n+    bind(L_fill_64_tail);\n+    cmpq(count, 32 >> shift);\n+    jcc(Assembler::less, L_fill_32_tail);\n+    fill32(to, 0, xtmp);\n+    jcc(Assembler::equal, L_exit);\n+    subq(count, 32 >> shift);\n+    addptr(to, 32);\n@@ -9419,0 +9491,4 @@\n+\n+  bind(L_fill_32_tail);\n+  fill32_tail(shift, to, 0, xtmp, count, rtmp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":137,"deletions":61,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -2019,2 +2019,2 @@\n-  void fill_masked(BasicType bt, Address dst, XMMRegister xmm, KRegister mask,\n-                   Register length, Register temp, int vec_enc);\n+  void fill64_tail(uint shift, Register dst, int disp,\n+                         XMMRegister xmm, Register length, Register temp);\n@@ -2022,7 +2022,2 @@\n-  void fill64_masked(uint shift, Register dst, int disp,\n-                         XMMRegister xmm, KRegister mask, Register length,\n-                         Register temp, bool use64byteVector = false);\n-\n-  void fill32_masked(uint shift, Register dst, int disp,\n-                         XMMRegister xmm, KRegister mask, Register length,\n-                         Register temp);\n+  void fill32_tail(uint shift, Register dst, int disp,\n+                         XMMRegister xmm, Register length, Register temp);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"}]}