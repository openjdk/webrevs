{"files":[{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8364305\n+* @summary Test scalar float\/double to integral cast\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run main\/othervm\/native compiler.floatingpoint.ScalarFPtoIntCastTest\n+*\/\n+\n+package compiler.floatingpoint;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+\n+public class ScalarFPtoIntCastTest {\n+    private static final int COUNT = 16;\n+    private float[] float_arr;\n+    private double[] double_arr;\n+    private long[] long_arr;\n+    private int[] int_arr;\n+    private short[] short_arr;\n+    private byte[] byte_arr;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000).start();\n+    }\n+\n+    public ScalarFPtoIntCastTest() {\n+        float_arr = new float[COUNT];\n+        double_arr = new double[COUNT];\n+        long_arr = new long[COUNT];\n+        int_arr = new int[COUNT];\n+        short_arr = new short[COUNT];\n+        byte_arr = new byte[COUNT];\n+\n+        Random ran = new Random(0);\n+        for (int i = 0; i < COUNT; i++) {\n+            int floor_val = ran.nextInt(Byte.MAX_VALUE);\n+            int ceil_val = floor_val + 1;\n+            long_arr[i] = (long) floor_val;\n+            int_arr[i] = floor_val;\n+            short_arr[i] = (short) floor_val;\n+            byte_arr[i] = (byte) floor_val;\n+            float_arr[i] = ran.nextFloat(floor_val, ceil_val);\n+            double_arr[i] = ran.nextDouble(floor_val, ceil_val);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2int() {\n+        checkf2int();\n+    }\n+\n+    public void checkf2int() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            int expected = (int) float_val;\n+            if (int_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: int_arr[\" + i + \"] = \" + int_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2L, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2L, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2L_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2long() {\n+        checkf2long();\n+    }\n+\n+    public void checkf2long() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            long expected = (long) float_val;\n+            if (long_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: long_arr[\" + i + \"] = \" + long_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2short() {\n+        checkf2short();\n+    }\n+\n+    public void checkf2short() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            short expected = (short) float_val;\n+            if (short_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: short_arr[\" + i + \"] = \" + short_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2byte() {\n+        checkf2byte();\n+    }\n+\n+    public void checkf2byte() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            byte expected = (byte) float_val;\n+            if (byte_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: byte_arr[\" + i + \"] = \" + byte_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2int() {\n+        checkd2int();\n+    }\n+\n+    public void checkd2int() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            int expected = (int) double_val;\n+            if (int_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: int_arr[\" + i + \"] = \" + int_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2L, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2L, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2L_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2long() {\n+        checkd2long();\n+    }\n+\n+    public void checkd2long() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            long expected = (long) double_val;\n+            if (long_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: long_arr[\" + i + \"] = \" + long_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2short() {\n+        checkd2short();\n+    }\n+\n+    public void checkd2short() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            short expected = (short) double_val;\n+            if (short_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: short_arr[\" + i + \"] = \" + short_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2byte() {\n+        checkd2byte();\n+    }\n+\n+    public void checkd2byte() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            byte expected = (byte) double_val;\n+            if (byte_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: byte_arr[\" + i + \"] = \" + byte_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/ScalarFPtoIntCastTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -613,0 +613,10 @@\n+    public static final String CONV_D2I = PREFIX + \"CONV_D2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_D2I, \"ConvD2I\");\n+    }\n+\n+    public static final String CONV_D2L = PREFIX + \"CONV_D2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_D2L, \"ConvD2L\");\n+    }\n+\n@@ -618,0 +628,10 @@\n+    public static final String CONV_F2I = PREFIX + \"CONV_F2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2I, \"ConvF2I\");\n+    }\n+\n+    public static final String CONV_F2L = PREFIX + \"CONV_F2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2L, \"ConvF2L\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-* @summary Test float\/double to integral cast\n+* @summary Test vector float\/double to integral cast\n@@ -103,1 +103,1 @@\n-            int expected = (int)float_arr[i];\n+            int expected = (int) float_arr[i];\n@@ -125,1 +125,1 @@\n-            long expected = (long)float_arr[i];\n+            long expected = (long) float_arr[i];\n@@ -147,1 +147,1 @@\n-            short expected = (short)float_arr[i];\n+            short expected = (short) float_arr[i];\n@@ -169,1 +169,1 @@\n-            byte expected = (byte)float_arr[i];\n+            byte expected = (byte) float_arr[i];\n@@ -191,1 +191,1 @@\n-            int expected = (int)double_arr[i];\n+            int expected = (int) double_arr[i];\n@@ -213,1 +213,1 @@\n-            long expected = (long)double_arr[i];\n+            long expected = (long) double_arr[i];\n@@ -235,1 +235,1 @@\n-            short expected = (short)double_arr[i];\n+            short expected = (short) double_arr[i];\n@@ -257,1 +257,1 @@\n-            byte expected = (byte)double_arr[i];\n+            byte expected = (byte) double_arr[i];\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFPtoIntCastTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}