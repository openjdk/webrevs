{"files":[{"patch":"@@ -2235,0 +2235,38 @@\n+void Assembler::evcvttss2sisl(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttss2sisl(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evcvttss2sisq(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttss2sisq(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2320,0 +2358,19 @@\n+void Assembler::evcvttps2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttps2dqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2327,0 +2384,19 @@\n+void Assembler::evcvttpd2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttpd2dqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2342,0 +2418,19 @@\n+void Assembler::evcvttps2qqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttps2qqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HV, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2366,0 +2461,19 @@\n+void Assembler::evcvttpd2qqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttpd2qqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -14996,0 +15110,38 @@\n+void Assembler::evcvttsd2sisl(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttsd2sisl(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evcvttsd2sisq(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttsd2sisq(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -1312,0 +1312,4 @@\n+  void evcvttsd2sisl(Register dst, XMMRegister src);\n+  void evcvttsd2sisl(Register dst, Address src);\n+  void evcvttsd2sisq(Register dst, XMMRegister src);\n+  void evcvttsd2sisq(Register dst, Address src);\n@@ -1317,0 +1321,4 @@\n+  void evcvttss2sisl(Register dst, XMMRegister src);\n+  void evcvttss2sisl(Register dst, Address src);\n+  void evcvttss2sisq(Register dst, XMMRegister src);\n+  void evcvttss2sisq(Register dst, Address src);\n@@ -1328,0 +1336,2 @@\n+  void evcvttps2dqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttps2dqs(XMMRegister dst, Address src, int vector_len);\n@@ -1329,0 +1339,2 @@\n+  void evcvttps2qqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttps2qqs(XMMRegister dst, Address src, int vector_len);\n@@ -1337,0 +1349,2 @@\n+  void evcvttpd2qqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttpd2qqs(XMMRegister dst, Address src, int vector_len);\n@@ -1340,0 +1354,2 @@\n+  void evcvttpd2dqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttpd2dqs(XMMRegister dst, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5061,1 +5061,1 @@\n- * Algorithm for vector D2L and F2I conversions:-\n+ * Algorithm for vector D2L and F2I conversions (AVX 10.2 unsupported):-\n@@ -5166,0 +5166,80 @@\n+void C2_MacroAssembler::vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttps2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttps2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttpd2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttpd2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -350,0 +350,7 @@\n+  void vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n+\n+  void vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n+\n+  void vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n+\n+  void vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7667,2 +7667,5 @@\n-  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 4);\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            !VM_Version::supports_avx512vl() &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 4 &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7690,1 +7693,2 @@\n-  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n@@ -7712,0 +7716,27 @@\n+instruct castFtoX_reg_avx10(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"vector_cast_f2x_avx10 $dst, $src\\t!\" %}\n+  ins_encode %{\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = (to_elem_bt == T_LONG) ? vector_length_encoding(this) : vector_length_encoding(this, $src);\n+    __ vector_castF2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct castFtoX_mem_avx10(vec dst, memory src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastF2X (LoadVector src)));\n+  format %{ \"vector_cast_f2x_avx10 $dst, $src\\t!\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = (to_elem_bt == T_LONG) ? vector_length_encoding(this) : vector_length_encoding(vlen * sizeof(jfloat));\n+    __ vector_castF2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7724,1 +7755,3 @@\n-  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            !VM_Version::supports_avx512vl() &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n@@ -7740,1 +7773,2 @@\n-  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n@@ -7756,0 +7790,27 @@\n+instruct castDtoX_reg_avx10(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vector_cast_d2x_avx10 $dst, $src\\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_castD2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct castDtoX_mem_avx10(vec dst, memory src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastD2X (LoadVector src)));\n+  format %{ \"vector_cast_d2x_avx10 $dst, $src\\t!\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    int vlen_enc = vector_length_encoding(vlen * sizeof(jdouble));\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_castD2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":66,"deletions":5,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -11718,0 +11718,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11727,0 +11728,22 @@\n+instruct convF2I_reg_reg_avx10(rRegI dst, regF src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2I src));\n+  format %{ \"evcvttss2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisl($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2I_reg_mem_avx10(rRegI dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2I (LoadF src)));\n+  format %{ \"evcvttss2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -11729,0 +11752,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11738,0 +11762,22 @@\n+instruct convF2L_reg_reg_avx10(rRegL dst, regF src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2L src));\n+  format %{ \"evcvttss2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisq($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2L_reg_mem_avx10(rRegL dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2L (LoadF src)));\n+  format %{ \"evcvttss2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -11740,0 +11786,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11749,0 +11796,22 @@\n+instruct convD2I_reg_reg_avx10(rRegI dst, regD src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2I src));\n+  format %{ \"evcvttsd2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisl($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2I_reg_mem_avx10(rRegI dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2I (LoadD src)));\n+  format %{ \"evcvttsd2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -11751,0 +11820,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11760,0 +11830,22 @@\n+instruct convD2L_reg_reg_avx10(rRegL dst, regD src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2L src));\n+  format %{ \"evcvttsd2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisq($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2L_reg_mem_avx10(rRegL dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2L (LoadD src)));\n+  format %{ \"evcvttsd2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8364305\n+* @summary Test scalar float\/double to integral cast\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run main\/othervm\/native compiler.floatingpoint.ScalarFPtoIntCastTest\n+*\/\n+\n+package compiler.floatingpoint;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+\n+public class ScalarFPtoIntCastTest {\n+    private static final int COUNT = 16;\n+    private float[] float_arr;\n+    private double[] double_arr;\n+    private long[] long_arr;\n+    private int[] int_arr;\n+    private short[] short_arr;\n+    private byte[] byte_arr;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000).start();\n+    }\n+\n+    public ScalarFPtoIntCastTest() {\n+        float_arr = new float[COUNT];\n+        double_arr = new double[COUNT];\n+        long_arr = new long[COUNT];\n+        int_arr = new int[COUNT];\n+        short_arr = new short[COUNT];\n+        byte_arr = new byte[COUNT];\n+\n+        Random ran = new Random(0);\n+        for (int i = 0; i < COUNT; i++) {\n+            int floor_val = ran.nextInt(Byte.MAX_VALUE);\n+            int ceil_val = floor_val + 1;\n+            long_arr[i] = (long) floor_val;\n+            int_arr[i] = floor_val;\n+            short_arr[i] = (short) floor_val;\n+            byte_arr[i] = (byte) floor_val;\n+            float_arr[i] = ran.nextFloat(floor_val, ceil_val);\n+            double_arr[i] = ran.nextDouble(floor_val, ceil_val);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2int() {\n+        checkf2int();\n+    }\n+\n+    public void checkf2int() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            int expected = (int) float_val;\n+            if (int_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: int_arr[\" + i + \"] = \" + int_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2L, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2L, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2L_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2long() {\n+        checkf2long();\n+    }\n+\n+    public void checkf2long() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            long expected = (long) float_val;\n+            if (long_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: long_arr[\" + i + \"] = \" + long_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2short() {\n+        checkf2short();\n+    }\n+\n+    public void checkf2short() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            short expected = (short) float_val;\n+            if (short_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: short_arr[\" + i + \"] = \" + short_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2byte() {\n+        checkf2byte();\n+    }\n+\n+    public void checkf2byte() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            byte expected = (byte) float_val;\n+            if (byte_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: byte_arr[\" + i + \"] = \" + byte_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2int() {\n+        checkd2int();\n+    }\n+\n+    public void checkd2int() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            int expected = (int) double_val;\n+            if (int_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: int_arr[\" + i + \"] = \" + int_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2L, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2L, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2L_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2long() {\n+        checkd2long();\n+    }\n+\n+    public void checkd2long() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            long expected = (long) double_val;\n+            if (long_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: long_arr[\" + i + \"] = \" + long_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2short() {\n+        checkd2short();\n+    }\n+\n+    public void checkd2short() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            short expected = (short) double_val;\n+            if (short_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: short_arr[\" + i + \"] = \" + short_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2byte() {\n+        checkd2byte();\n+    }\n+\n+    public void checkd2byte() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            byte expected = (byte) double_val;\n+            if (byte_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: byte_arr[\" + i + \"] = \" + byte_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/ScalarFPtoIntCastTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -613,0 +613,10 @@\n+    public static final String CONV_D2I = PREFIX + \"CONV_D2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_D2I, \"ConvD2I\");\n+    }\n+\n+    public static final String CONV_D2L = PREFIX + \"CONV_D2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_D2L, \"ConvD2L\");\n+    }\n+\n@@ -618,0 +628,10 @@\n+    public static final String CONV_F2I = PREFIX + \"CONV_F2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2I, \"ConvF2I\");\n+    }\n+\n+    public static final String CONV_F2L = PREFIX + \"CONV_F2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2L, \"ConvF2L\");\n+    }\n+\n@@ -2668,0 +2688,60 @@\n+    public static final String X86_SCONV_D2I = PREFIX + \"X86_SCONV_D2I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_D2I, \"convD2I_reg_reg\");\n+    }\n+\n+    public static final String X86_SCONV_D2L = PREFIX + \"X86_SCONV_D2L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_D2L, \"convD2L_reg_reg\");\n+    }\n+\n+    public static final String X86_SCONV_F2I = PREFIX + \"X86_SCONV_F2I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_F2I, \"convF2I_reg_reg\");\n+    }\n+\n+    public static final String X86_SCONV_F2L = PREFIX + \"X86_SCONV_F2L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_F2L, \"convF2L_reg_reg\");\n+    }\n+\n+    public static final String X86_SCONV_D2I_AVX10 = PREFIX + \"X86_SCONV2_D2I_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_D2I_AVX10, \"convD2I_(reg_reg|reg_mem)_avx10\");\n+    }\n+\n+    public static final String X86_SCONV_D2L_AVX10 = PREFIX + \"X86_SCONV_D2L_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_D2L_AVX10, \"convD2L_(reg_reg|reg_mem)_avx10\");\n+    }\n+\n+    public static final String X86_SCONV_F2I_AVX10 = PREFIX + \"X86_SCONV_F2I_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_F2I_AVX10, \"convF2I_(reg_reg|reg_mem)_avx10\");\n+    }\n+\n+    public static final String X86_SCONV_F2L_AVX10 = PREFIX + \"X86_SCONV_F2L_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_F2L_AVX10, \"convF2L_(reg_reg|reg_mem)_avx10\");\n+    }\n+\n+    public static final String X86_VCAST_F2X = PREFIX + \"X86_VCAST_F2X\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_VCAST_F2X, \"castFtoX_reg_(av|eve)x\");\n+    }\n+\n+    public static final String X86_VCAST_D2X = PREFIX + \"X86_VCAST_D2X\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_VCAST_D2X, \"castDtoX_reg_(av|eve)x\");\n+    }\n+\n+    public static final String X86_VCAST_F2X_AVX10 = PREFIX + \"X86_VCAST_F2X_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_VCAST_F2X_AVX10, \"castFtoX_(reg|mem)_avx10\");\n+    }\n+\n+    public static final String X86_VCAST_D2X_AVX10 = PREFIX + \"X86_VCAST_D2X_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_VCAST_D2X_AVX10, \"castDtoX_(reg|mem)_avx10\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        \"avx10_2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n-* @bug 8287835\n-* @summary Test float\/double to integral cast\n+* @bug 8287835 8364305\n+* @summary Test vector float\/double to integral cast\n@@ -90,1 +90,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -99,1 +103,1 @@\n-            int expected = (int)float_arr[i];\n+            int expected = (int) float_arr[i];\n@@ -108,1 +112,5 @@\n-        applyIfCPUFeature = {\"avx512dq\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512dq\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -117,1 +125,1 @@\n-            long expected = (long)float_arr[i];\n+            long expected = (long) float_arr[i];\n@@ -126,1 +134,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -135,1 +147,1 @@\n-            short expected = (short)float_arr[i];\n+            short expected = (short) float_arr[i];\n@@ -144,1 +156,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -153,1 +169,1 @@\n-            byte expected = (byte)float_arr[i];\n+            byte expected = (byte) float_arr[i];\n@@ -162,1 +178,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -171,1 +191,1 @@\n-            int expected = (int)double_arr[i];\n+            int expected = (int) double_arr[i];\n@@ -180,1 +200,5 @@\n-        applyIfCPUFeature = {\"avx512dq\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512dq\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -189,1 +213,1 @@\n-            long expected = (long)double_arr[i];\n+            long expected = (long) double_arr[i];\n@@ -198,1 +222,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -207,1 +235,1 @@\n-            short expected = (short)double_arr[i];\n+            short expected = (short) double_arr[i];\n@@ -216,1 +244,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -225,1 +257,1 @@\n-            byte expected = (byte)double_arr[i];\n+            byte expected = (byte) double_arr[i];\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFPtoIntCastTest.java","additions":51,"deletions":19,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -297,2 +297,6 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n-        counts = {IRNode.VECTOR_CAST_F2I, IRNode.VECTOR_SIZE + \"min(max_float, max_int)\", \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_F2I, IRNode.VECTOR_SIZE + \"min(max_float, max_int)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -308,2 +312,6 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"rvv\", \"true\"},\n-        counts = {IRNode.VECTOR_CAST_F2L, IRNode.VECTOR_SIZE + \"min(max_float, max_long)\", \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_F2L, IRNode.VECTOR_SIZE + \"min(max_float, max_long)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -319,2 +327,6 @@\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n-        counts = {IRNode.VECTOR_CAST_D2I, IRNode.VECTOR_SIZE + \"min(max_double, max_int)\", \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_D2I, IRNode.VECTOR_SIZE + \"min(max_double, max_int)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -330,2 +342,6 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"rvv\", \"true\"},\n-        counts = {IRNode.VECTOR_CAST_D2L, IRNode.VECTOR_SIZE + \"min(max_double, max_long)\", \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_D2L, IRNode.VECTOR_SIZE + \"min(max_double, max_long)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -342,1 +358,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n@@ -344,1 +360,7 @@\n-        counts = {IRNode.VECTOR_CAST_F2S, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \">0\"})\n+        counts = {IRNode.VECTOR_CAST_F2S, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -361,1 +383,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n@@ -363,1 +385,7 @@\n-        counts = {IRNode.VECTOR_CAST_F2S, IRNode.VECTOR_SIZE + \"min(max_float, max_char)\", \">0\"})\n+        counts = {IRNode.VECTOR_CAST_F2S, IRNode.VECTOR_SIZE + \"min(max_float, max_char)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -382,2 +410,5 @@\n-        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_short)\", \">0\"})\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_short)\", \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"avx10_2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_short)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n@@ -385,1 +416,4 @@\n-        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_short)\", \">0\"})\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -396,3 +430,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n-        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_char)\", \">0\"})\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">= 32\"},\n+        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_char)\", \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"avx10_2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_char)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n@@ -400,1 +440,1 @@\n-        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_char)\", \">0\"})\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":59,"deletions":19,"binary":false,"changes":78,"status":"modified"}]}