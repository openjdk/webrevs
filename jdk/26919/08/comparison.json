{"files":[{"patch":"@@ -2235,0 +2235,38 @@\n+void Assembler::evcvttss2sisl(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttss2sisl(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evcvttss2sisq(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttss2sisq(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2320,0 +2358,19 @@\n+void Assembler::evcvttps2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttps2dqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2327,0 +2384,19 @@\n+void Assembler::evcvttpd2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttpd2dqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2342,0 +2418,19 @@\n+void Assembler::evcvttps2qqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttps2qqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HV, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2366,0 +2461,19 @@\n+void Assembler::evcvttpd2qqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttpd2qqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -14996,0 +15110,38 @@\n+void Assembler::evcvttsd2sisl(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttsd2sisl(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evcvttsd2sisq(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttsd2sisq(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -1312,0 +1312,4 @@\n+  void evcvttsd2sisl(Register dst, XMMRegister src);\n+  void evcvttsd2sisl(Register dst, Address src);\n+  void evcvttsd2sisq(Register dst, XMMRegister src);\n+  void evcvttsd2sisq(Register dst, Address src);\n@@ -1317,0 +1321,4 @@\n+  void evcvttss2sisl(Register dst, XMMRegister src);\n+  void evcvttss2sisl(Register dst, Address src);\n+  void evcvttss2sisq(Register dst, XMMRegister src);\n+  void evcvttss2sisq(Register dst, Address src);\n@@ -1328,0 +1336,2 @@\n+  void evcvttps2dqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttps2dqs(XMMRegister dst, Address src, int vector_len);\n@@ -1329,0 +1339,2 @@\n+  void evcvttps2qqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttps2qqs(XMMRegister dst, Address src, int vector_len);\n@@ -1337,0 +1349,2 @@\n+  void evcvttpd2qqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttpd2qqs(XMMRegister dst, Address src, int vector_len);\n@@ -1340,0 +1354,2 @@\n+  void evcvttpd2dqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttpd2dqs(XMMRegister dst, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5061,1 +5061,1 @@\n- * Algorithm for vector D2L and F2I conversions:-\n+ * Algorithm for vector D2L and F2I conversions (AVX 10.2 unsupported):-\n@@ -5166,0 +5166,80 @@\n+void C2_MacroAssembler::vector_cast2F2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttps2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_cast2F2X_evex(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttps2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_cast2D2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttpd2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_cast2D2X_evex(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttpd2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -350,0 +350,7 @@\n+  void vector_cast2F2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n+\n+  void vector_cast2F2X_evex(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n+\n+  void vector_cast2D2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n+\n+  void vector_cast2D2X_evex(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7667,1 +7667,3 @@\n-  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            !VM_Version::supports_avx512vl() &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n@@ -7690,1 +7692,2 @@\n-  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n@@ -7712,0 +7715,26 @@\n+instruct cast2FtoX_reg_evex(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"vector_cast2r_f2x $dst, $src\\t!\" %}\n+  ins_encode %{\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = (to_elem_bt == T_LONG) ? vector_length_encoding(this) : vector_length_encoding(this, $src);\n+    __ vector_cast2F2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct cast2FtoX_mem_evex(vec dst, memory src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastF2X (VectorReinterpret (LoadVector src))));\n+  format %{ \"vector_cast2m_f2x $dst, $src\\t!\" %}\n+  ins_encode %{\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = (to_elem_bt == T_LONG) ? vector_length_encoding(this) : vector_length_encoding(this, $src);\n+    __ vector_cast2F2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7724,1 +7753,3 @@\n-  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            !VM_Version::supports_avx512vl() &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n@@ -7740,1 +7771,2 @@\n-  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n@@ -7756,0 +7788,26 @@\n+instruct cast2DtoX_reg_evex(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vector_cast2r_d2x $dst, $src\\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_cast2D2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct cast2DtoX_mem_evex(vec dst, memory src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastD2X (VectorReinterpret (LoadVector src))));\n+  format %{ \"vector_cast2m_d2x $dst, $src\\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_cast2D2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":62,"deletions":4,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -11718,0 +11718,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11727,0 +11728,22 @@\n+instruct conv2F2I_reg_reg(rRegI dst, regF src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2I src));\n+  format %{ \"evcvttss2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisl($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct conv2F2I_reg_mem(rRegI dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2I (LoadF src)));\n+  format %{ \"evcvttss2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -11729,0 +11752,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11738,0 +11762,22 @@\n+instruct conv2F2L_reg_reg(rRegL dst, regF src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2L src));\n+  format %{ \"evcvttss2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisq($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct conv2F2L_reg_mem(rRegL dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2L (LoadF src)));\n+  format %{ \"evcvttss2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -11740,0 +11786,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11749,0 +11796,22 @@\n+instruct conv2D2I_reg_reg(rRegI dst, regD src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2I src));\n+  format %{ \"evcvttsd2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisl($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct conv2D2I_reg_mem(rRegI dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2I (LoadD src)));\n+  format %{ \"evcvttsd2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -11751,0 +11820,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11760,0 +11830,22 @@\n+instruct conv2D2L_reg_reg(rRegL dst, regD src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2L src));\n+  format %{ \"evcvttsd2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisq($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct conv2D2L_reg_mem(rRegL dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2L (LoadD src)));\n+  format %{ \"evcvttsd2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        \"avx10_2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    @IR(counts = {\"castFtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2FtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -109,0 +113,4 @@\n+    @IR(counts = {\"castFtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2FtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -127,0 +135,4 @@\n+    @IR(counts = {\"castFtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2FtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -145,0 +157,4 @@\n+    @IR(counts = {\"castFtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2FtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -163,0 +179,4 @@\n+    @IR(counts = {\"castDtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2DtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -181,0 +201,4 @@\n+    @IR(counts = {\"castDtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2DtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -199,0 +223,4 @@\n+    @IR(counts = {\"castDtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2DtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -217,0 +245,4 @@\n+    @IR(counts = {\"castDtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2DtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFPtoIntCastTest.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -299,0 +299,4 @@\n+    @IR(counts = {\"castFtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2FtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -310,0 +314,4 @@\n+    @IR(counts = {\"castFtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2FtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -321,0 +329,4 @@\n+    @IR(counts = {\"castDtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2DtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -332,0 +344,4 @@\n+    @IR(counts = {\"castDtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2DtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -345,0 +361,4 @@\n+    @IR(counts = {\"convF2I\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"conv2F2I\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -364,0 +384,4 @@\n+    @IR(counts = {\"convF2I\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"conv2F2I\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -386,0 +410,4 @@\n+    @IR(counts = {\"castDtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2DtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -401,0 +429,4 @@\n+    @IR(counts = {\"castDtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {\"cast2DtoX\", \" >0 \"}, phase = CompilePhase.FINAL_CODE,\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"}]}