{"files":[{"patch":"@@ -1459,0 +1459,4 @@\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != nullptr) {\n+    return n;\n+  }\n@@ -1492,0 +1496,4 @@\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != nullptr) {\n+    return n;\n+  }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8373396\n+ * @summary Verify that min\/max add ideal optimizations get applied correctly\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestMinMaxIdeal\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.scope;\n+\n+public class TestMinMaxIdeal {\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        String templatedPackage =\"compiler.c2.templated\";\n+        String templatedClassName =\"MinMaxIdeal\";\n+        String templatedFQN = \"%s.%s\".formatted(templatedPackage, templatedClassName);\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(templatedFQN, generate(templatedClassName, templatedPackage, comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        comp.invoke(templatedFQN, \"main\", new Object[] {new String[] {}});\n+    }\n+\n+    private static String generate(String templatedClassName, String templatedPackage, CompileFramework comp) {\n+        \/\/ Create a list to collect all tests.\n+        List<TemplateToken> testTemplateTokens = new ArrayList<>();\n+\n+        testTemplateTokens.add(new TestGenerator(Op.MIN_I).generate());\n+        testTemplateTokens.add(new TestGenerator(Op.MAX_I).generate());\n+        testTemplateTokens.add(new TestGenerator(Op.MIN_L).generate());\n+        testTemplateTokens.add(new TestGenerator(Op.MAX_L).generate());\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            templatedPackage, templatedClassName,\n+            \/\/ List of imports.\n+            Collections.emptySet(),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+\n+    enum Op {\n+        MIN_I(\"min\", CodeGenerationDataNameType.ints()),\n+        MAX_I(\"max\", CodeGenerationDataNameType.ints()),\n+        MIN_L(\"min\", CodeGenerationDataNameType.longs()),\n+        MAX_L(\"max\", CodeGenerationDataNameType.longs());\n+\n+        final String functionName;\n+        final PrimitiveType type;\n+\n+        Op(String functionName, PrimitiveType type) {\n+            this.functionName = functionName;\n+            this.type = type;\n+        }\n+    }\n+\n+    record TestGenerator(Op op) {\n+        TemplateToken generate() {\n+            var template = Template.make(() -> scope(\n+                let(\"irNodeName\", op.name()),\n+                let(\"boxedTypeName\", op.type.boxedTypeName()),\n+                let(\"op\", op.name()),\n+                let(\"type\", op.type.name()),\n+                let(\"functionName\", op.functionName),\n+                \"\"\"\n+                @Test\n+                @IR(counts = {IRNode.#irNodeName, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42, Argument.NUMBER_42})\n+                public #type test_commute_#op(#type a, #type b) {\n+                    return #boxedTypeName.#functionName(a, b) + #boxedTypeName.#functionName(b, a);\n+                }\n+\n+                @Test\n+                @IR(counts = {IRNode.#irNodeName, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42})\n+                public #type test_flatten_#op(#type a) {\n+                    return #boxedTypeName.#functionName(#boxedTypeName.#functionName(a, 1), 2);\n+                }\n+\n+                @Test\n+                @IR(counts = {IRNode.#irNodeName, \"= 2\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42, Argument.NUMBER_42})\n+                public #type test_push_constant_left_#op(#type a, #type b) {\n+                    return #boxedTypeName.#functionName(#boxedTypeName.#functionName(a, 1), b) + #boxedTypeName.#functionName(b, a);\n+                }\n+\n+                @Test\n+                @IR(counts = {IRNode.#irNodeName, \"= 2\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42, Argument.NUMBER_42})\n+                public #type test_push_constant_right_#op(#type a, #type b) {\n+                    return #boxedTypeName.#functionName(a, #boxedTypeName.#functionName(b, 1)) + #boxedTypeName.#functionName(b, a);\n+                }\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestMinMaxIdeal.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"}]}