{"files":[{"patch":"@@ -1404,0 +1404,4 @@\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != nullptr) {\n+    return n;\n+  }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1711,7 +1711,0 @@\n-\n-    \/\/ MinINode::Ideal\n-    \/\/ Did not investigate, but there are some patterns that might\n-    \/\/ need more notification.\n-    case Op_MinI:\n-    case Op_MaxI: \/\/ preemptively removed it as well.\n-      return false;\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8373396\n+ * @summary Verify that min\/max add ideal optimizations get applied correctly\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+package compiler.igvn;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.scope;\n+\n+public class TestMinMaxIdeal {\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"compiler.igvn.templated.MinMaxIdeal\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        comp.invoke(\"compiler.igvn.templated.MinMaxIdeal\", \"main\", new Object[] {new String[] {}});\n+    }\n+\n+    private static String generate(CompileFramework comp) {\n+        \/\/ Create a list to collect all tests.\n+        List<TemplateToken> testTemplateTokens = Stream.of(Op.values())\n+            .map(op -> new TestGenerator(op).generate())\n+            .toList();\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"compiler.igvn.templated\", \"MinMaxIdeal\",\n+            \/\/ List of imports.\n+            Collections.emptySet(),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+\n+    enum Op {\n+        MIN_I(\"min\", CodeGenerationDataNameType.ints()),\n+        MAX_I(\"max\", CodeGenerationDataNameType.ints()),\n+        MIN_L(\"min\", CodeGenerationDataNameType.longs()),\n+        MAX_L(\"max\", CodeGenerationDataNameType.longs());\n+\n+        final String functionName;\n+        final PrimitiveType type;\n+\n+        Op(String functionName, PrimitiveType type) {\n+            this.functionName = functionName;\n+            this.type = type;\n+        }\n+    }\n+\n+    record TestGenerator(Op op) {\n+        TemplateToken generate() {\n+            var template = Template.make(() -> scope(\n+                let(\"irNodeName\", op.name()),\n+                let(\"boxedTypeName\", op.type.boxedTypeName()),\n+                let(\"op\", op.name()),\n+                let(\"type\", op.type.name()),\n+                let(\"functionName\", op.functionName),\n+                \"\"\"\n+                @Test\n+                @IR(counts = {IRNode.#irNodeName, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42, Argument.NUMBER_42})\n+                public #type test_commute_#op(#type a, #type b) {\n+                    return #boxedTypeName.#functionName(a, b) + #boxedTypeName.#functionName(b, a);\n+                }\n+\n+                @Test\n+                @IR(counts = {IRNode.#irNodeName, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42})\n+                public #type test_flatten_#op(#type a) {\n+                    return #boxedTypeName.#functionName(#boxedTypeName.#functionName(a, 1), 2);\n+                }\n+\n+                @Test\n+                @IR(counts = {IRNode.#irNodeName, \"= 2\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42, Argument.NUMBER_42})\n+                public #type test_push_constant_left_#op(#type a, #type b) {\n+                    return #boxedTypeName.#functionName(#boxedTypeName.#functionName(a, 1), b) + #boxedTypeName.#functionName(b, a);\n+                }\n+\n+                @Test\n+                @IR(counts = {IRNode.#irNodeName, \"= 2\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42, Argument.NUMBER_42})\n+                public #type test_push_constant_right_#op(#type a, #type b) {\n+                    return #boxedTypeName.#functionName(a, #boxedTypeName.#functionName(b, 1)) + #boxedTypeName.#functionName(b, a);\n+                }\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/TestMinMaxIdeal.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}