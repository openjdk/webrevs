{"files":[{"patch":"@@ -235,31 +235,40 @@\n-  ThreadsListHandle tlh;\n-  \/\/ Resolve a sample session relative start position index into the thread list array.\n-  \/\/ In cases where the last sampled thread is null or not-null but stale, find_index() returns -1.\n-  _cur_index = tlh.list()->find_index_of_JavaThread(*last_thread);\n-  JavaThread* current = _cur_index != -1 ? *last_thread : nullptr;\n-\n-  while (num_samples < sample_limit) {\n-    current = next_thread(tlh.list(), start, current);\n-    if (current == nullptr) {\n-      break;\n-    }\n-    if (is_excluded(current)) {\n-      continue;\n-    }\n-    if (start == nullptr) {\n-      start = current; \/\/ remember the thread where we started to attempt sampling\n-    }\n-    bool success;\n-    if (JAVA_SAMPLE == type) {\n-      success = sample_java_thread(current);\n-    } else {\n-      assert(type == NATIVE_SAMPLE, \"invariant\");\n-      success = sample_native_thread(current);\n-    }\n-    if (success) {\n-      num_samples++;\n-    }\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      \/\/ For _thread_in_native, we cannot get the Threads_lock.\n-      \/\/ For _thread_in_Java, well, there are none.\n-      break;\n+  {\n+    \/*\n+     * Take the Threads_lock for three purposes:\n+     *\n+     * 1) Avoid sampling right through a safepoint,\n+     *    which could result in touching oops in case of virtual threads.\n+     * 2) Prevent JFR from issuing an epoch rotation while the sampler thread\n+     *    is actively processing a thread in state native, as both threads are outside the safepoint protocol.\n+     * 3) Some operating systems (BSD \/ Mac) require a process lock when sending a signal with pthread_kill.\n+     *    Holding the Threads_lock prevents a JavaThread from calling os::create_thread(), which also takes the process lock.\n+     *    In a sense, we provide a coarse signal mask, so we can always send the resume signal.\n+     *\/\n+    MutexLocker tlock(Threads_lock);\n+    ThreadsListHandle tlh;\n+    \/\/ Resolve a sample session relative start position index into the thread list array.\n+    \/\/ In cases where the last sampled thread is null or not-null but stale, find_index() returns -1.\n+    _cur_index = tlh.list()->find_index_of_JavaThread(*last_thread);\n+    JavaThread* current = _cur_index != -1 ? *last_thread : nullptr;\n+\n+    while (num_samples < sample_limit) {\n+      current = next_thread(tlh.list(), start, current);\n+      if (current == nullptr) {\n+        break;\n+      }\n+      if (is_excluded(current)) {\n+        continue;\n+      }\n+      if (start == nullptr) {\n+        start = current; \/\/ remember the thread where we started to attempt sampling\n+      }\n+      bool success;\n+      if (JAVA_SAMPLE == type) {\n+        success = sample_java_thread(current);\n+      } else {\n+        assert(type == NATIVE_SAMPLE, \"invariant\");\n+        success = sample_native_thread(current);\n+      }\n+      if (success) {\n+        num_samples++;\n+      }\n@@ -267,1 +276,0 @@\n-  }\n@@ -269,1 +277,2 @@\n-  *last_thread = current; \/\/ remember the thread we last attempted to sample\n+    *last_thread = current; \/\/ remember the thread we last attempted to sample\n+  }\n@@ -300,0 +309,1 @@\n+  assert_lock_strong(Threads_lock);\n@@ -331,0 +341,1 @@\n+  assert_lock_strong(Threads_lock);\n@@ -346,16 +357,0 @@\n-  \/\/ Take the Threads_lock for two purposes:\n-  \/\/ 1) Avoid sampling through a safepoint which could result\n-  \/\/    in touching oops in case of virtual threads.\n-  \/\/ 2) Prevent JFR from issuing an epoch rotation while the sampler thread\n-  \/\/    is actively processing a thread in native, as both threads are now\n-  \/\/    outside the safepoint protocol.\n-\n-  \/\/ OrderAccess::fence() as part of acquiring the lock prevents loads from floating up.\n-  JfrMutexTryLock threads_lock(Threads_lock);\n-\n-  if (!threads_lock.acquired() || !jt->has_last_Java_frame()) {\n-    \/\/ Remove the native sample request and release the potentially waiting thread.\n-    JfrSampleMonitor jsm(tl);\n-    return false;\n-  }\n-\n@@ -363,1 +358,0 @@\n-    assert_lock_strong(Threads_lock);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":44,"deletions":50,"binary":false,"changes":94,"status":"modified"}]}