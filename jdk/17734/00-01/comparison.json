{"files":[{"patch":"@@ -580,1 +580,1 @@\n-    public static final String readUTF(DataInput in) throws IOException {\n+    public static String readUTF(DataInput in) throws IOException {\n@@ -583,3 +583,1 @@\n-        DataInputStream dis = null;\n-        if (in instanceof DataInputStream) {\n-            dis = (DataInputStream)in;\n+        if (in instanceof DataInputStream dis) {\n@@ -595,2 +593,1 @@\n-        int count;\n-        char[] chararr;\n+        int asciiCount = 0;\n@@ -598,4 +595,2 @@\n-            \/\/ When there's a chunk of ASCII 0-127, the modified UTF-8 stream can use a similar\n-            \/\/ fast-path as regular UTF-8.\n-            count = JLA.countPositives(bytearr, 0, utflen);\n-            if (count == utflen) {\n+            asciiCount = JLA.countPositives(bytearr, 0, utflen);\n+            if (asciiCount == utflen) {\n@@ -606,2 +601,7 @@\n-            chararr = getCharBuf(utflen, dis);\n-            JLA.inflateBytesToChars(bytearr, 0, chararr, 0, count);\n+        }\n+        char[] chararr;\n+        if (in instanceof DataInputStream dis) {\n+            if (dis.chararr.length < utflen) {\n+                dis.chararr = new char[utflen << 1];\n+            }\n+            chararr = dis.chararr;\n@@ -609,2 +609,1 @@\n-            chararr = getCharBuf(utflen, dis);\n-            count = 0;\n+            chararr = new char[utflen];\n@@ -612,0 +611,6 @@\n+        int chars = decodeUTF(bytearr, 0, chararr, utflen, asciiCount);\n+        return new String(chararr, 0, chars);\n+    }\n+\n+    static int decodeUTF(byte[] src, int srcOff, char[] dst, int utflen, int asciiCount) throws UTFDataFormatException {\n+        JLA.inflateBytesToChars(src, srcOff, dst, 0, asciiCount);\n@@ -613,3 +618,5 @@\n-        int chararr_count = count;\n-        while (count < utflen) {\n-            c = (int) bytearr[count] & 0xff;\n+        int srcPos = asciiCount + srcOff;\n+        int end = utflen + srcOff;\n+        int dstPos = asciiCount;\n+        while (srcPos < end) {\n+            c = (int) src[srcPos] & 0xff;\n@@ -619,2 +626,2 @@\n-                    count++;\n-                    chararr[chararr_count++]=(char)c;\n+                    srcPos++;\n+                    dst[dstPos++] = (char)c;\n@@ -624,2 +631,2 @@\n-                    count += 2;\n-                    if (count > utflen)\n+                    srcPos += 2;\n+                    if (srcPos > end)\n@@ -628,1 +635,1 @@\n-                    char2 = bytearr[count-1];\n+                    char2 = src[srcPos - 1];\n@@ -631,3 +638,3 @@\n-                            \"malformed input around byte \" + count);\n-                    chararr[chararr_count++]=(char)(((c & 0x1F) << 6) |\n-                                                    (char2 & 0x3F));\n+                            \"malformed input around byte \" + srcPos);\n+                    dst[dstPos++]=(char)(((c     & 0x1F) << 6) |\n+                                          (char2 & 0x3F));\n@@ -637,2 +644,2 @@\n-                    count += 3;\n-                    if (count > utflen)\n+                    srcPos += 3;\n+                    if (srcPos > end)\n@@ -641,2 +648,2 @@\n-                    char2 = bytearr[count-2];\n-                    char3 = bytearr[count-1];\n+                    char2 = src[srcPos - 2];\n+                    char3 = src[srcPos - 1];\n@@ -645,4 +652,4 @@\n-                            \"malformed input around byte \" + (count-1));\n-                    chararr[chararr_count++]=(char)(((c     & 0x0F) << 12) |\n-                                                    ((char2 & 0x3F) << 6)  |\n-                                                    ((char3 & 0x3F) << 0));\n+                            \"malformed input around byte \" + (srcPos-1));\n+                    dst[dstPos++] = (char)(((c     & 0x0F) << 12) |\n+                                           ((char2 & 0x3F) << 6)  |\n+                                           ((char3 & 0x3F) << 0));\n@@ -653,1 +660,1 @@\n-                        \"malformed input around byte \" + count);\n+                        \"malformed input around byte \" + srcPos);\n@@ -657,13 +664,1 @@\n-        return new String(chararr, 0, chararr_count);\n-    }\n-\n-    private static char[] getCharBuf(int utflen, DataInputStream dis) {\n-        if (dis != null) {\n-            char[] chararr = dis.chararr;\n-            if (chararr.length < utflen) {\n-                dis.chararr = chararr = new char[utflen << 1];\n-            }\n-            return chararr;\n-        } else {\n-            return new char[utflen];\n-        }\n+        return dstPos;\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":42,"deletions":47,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -3699,3 +3699,1 @@\n-                    JLA.inflateBytesToChars(buf, pos, cbuf, 0, ascii);\n-                    pos += ascii;\n-                    int cbufPos = readUTFSpan(ascii, utflen - ascii);\n+                    int cbufPos = readUTFSpan(ascii, utflen);\n@@ -3744,1 +3742,1 @@\n-        private int readUTFSpan(int cpos, long utflen)\n+        private int readUTFSpan(int asciiCount, long utflen)\n@@ -3750,1 +3748,1 @@\n-            int stop = start + ((utflen > avail) ? avail - 2 : (int) utflen);\n+            avail = (utflen > avail) ? avail - 2 : (int)utflen;\n@@ -3752,1 +3750,1 @@\n-\n+            int cpos = 0;\n@@ -3754,28 +3752,2 @@\n-                while (pos < stop) {\n-                    int b1, b2, b3;\n-                    b1 = buf[pos++] & 0xFF;\n-                    switch (b1 >> 4) {\n-                        case 0, 1, 2, 3, 4, 5, 6, 7 -> \/\/ 1 byte format: 0xxxxxxx\n-                            cbuf[cpos++] = (char) b1;\n-                        case 12, 13 -> {  \/\/ 2 byte format: 110xxxxx 10xxxxxx\n-                            b2 = buf[pos++];\n-                            if ((b2 & 0xC0) != 0x80) {\n-                                throw new UTFDataFormatException();\n-                            }\n-                            cbuf[cpos++] = (char) (((b1 & 0x1F) << 6) |\n-                                                   ((b2 & 0x3F) << 0));\n-                        }\n-                        case 14 -> {  \/\/ 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx\n-                            b3 = buf[pos + 1];\n-                            b2 = buf[pos + 0];\n-                            pos += 2;\n-                            if ((b2 & 0xC0) != 0x80 || (b3 & 0xC0) != 0x80) {\n-                                throw new UTFDataFormatException();\n-                            }\n-                            cbuf[cpos++] = (char) (((b1 & 0x0F) << 12) |\n-                                                   ((b2 & 0x3F) << 6) |\n-                                                   ((b3 & 0x3F) << 0));\n-                        }\n-                        default ->  throw new UTFDataFormatException(); \/\/ 10xx xxxx, 1111 xxxx\n-                    }\n-                }\n+                cpos = DataInputStream.decodeUTF(buf, start, cbuf, avail, asciiCount);\n+                pos += avail;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":6,"deletions":34,"binary":false,"changes":40,"status":"modified"}]}