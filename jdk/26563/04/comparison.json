{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -533,2 +533,17 @@\n-    throws NoSuchAlgorithmException, SignatureException {\n-        return info.verify(this, bytes);\n+            throws NoSuchAlgorithmException, SignatureException {\n+        return info.verify(this, bytes, null);\n+    }\n+\n+    \/**\n+     * This verifies a given SignerInfo.\n+     *\n+     * @param info the signer information.\n+     * @param bytes the DER encoded content information.\n+     * @param cert certificate used to verify; find one inside the block if null\n+     *\n+     * @exception NoSuchAlgorithmException on unrecognized algorithms.\n+     * @exception SignatureException on signature handling errors.\n+     *\/\n+    public SignerInfo verify(SignerInfo info, byte[] bytes, X509Certificate cert)\n+            throws NoSuchAlgorithmException, SignatureException {\n+        return info.verify(this, bytes, cert);\n@@ -718,0 +733,13 @@\n+    \/\/ Generate signed data without a specified digAlgID.\n+    public static byte[] generateSignedData(\n+            String sigalg, Provider sigProvider,\n+            PrivateKey privateKey, X509Certificate[] signerChain,\n+            byte[] content, boolean internalsf, boolean directsign,\n+            Function<byte[], PKCS9Attributes> ts)\n+            throws SignatureException, InvalidKeyException, IOException,\n+            NoSuchAlgorithmException {\n+        return generateSignedData(sigalg, sigProvider, privateKey, signerChain,\n+                content, internalsf, directsign,\n+                null, ts);\n+    }\n+\n@@ -728,0 +756,1 @@\n+     * @param digAlgID digest alg to use; derive from other arguments if null\n@@ -739,0 +768,1 @@\n+            AlgorithmId digAlgID,\n@@ -745,2 +775,4 @@\n-        AlgorithmId digAlgID = SignatureUtil.getDigestAlgInPkcs7SignerInfo(\n-                signer, sigalg, privateKey, signerChain[0].getPublicKey(), directsign);\n+        if (digAlgID == null) {\n+            digAlgID = SignatureUtil.getDigestAlgInPkcs7SignerInfo(\n+                    signer, sigalg, privateKey, signerChain[0].getPublicKey(), directsign);\n+        }\n@@ -754,2 +786,3 @@\n-            if (digAlgName.equals(\"SHAKE256\") || digAlgName.equals(\"SHAKE256-LEN\")) {\n-                \/\/ No MessageDigest impl for SHAKE256 yet\n+            if (digAlgName.equals(\"SHAKE256-LEN\")) {\n+                \/\/ We don't check the LEN here. Usually it is returned\n+                \/\/ by SignatureUtil.getDigestAlgInPkcs7SignerInfo\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS7.java","additions":40,"deletions":7,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,4 +306,10 @@\n-    \/* Returns null if verify fails, this signerInfo if\n-       verify succeeds. *\/\n-    SignerInfo verify(PKCS7 block, byte[] data)\n-    throws NoSuchAlgorithmException, SignatureException {\n+    \/**\n+     * Verify this signerInfo in a PKCS7 block.\n+     *\n+     * @param block the PKCS7 object\n+     * @param data the content to verify against; read from block if null\n+     * @param cert certificate to verify with; read from block if null\n+     * @return null if verify fails, this signerInfo if verify succeeds.\n+     *\/\n+    SignerInfo verify(PKCS7 block, byte[] data, X509Certificate cert)\n+            throws NoSuchAlgorithmException, SignatureException {\n@@ -312,1 +318,0 @@\n-            Timestamp timestamp = null;\n@@ -314,1 +319,1 @@\n-                timestamp = getTimestamp();\n+                getTimestamp();\n@@ -359,16 +364,13 @@\n-                if (digestAlgName.equals(\"SHAKE256\")\n-                        || digestAlgName.equals(\"SHAKE256-LEN\")) {\n-                    if (digestAlgName.equals(\"SHAKE256-LEN\")) {\n-                        \/\/ RFC8419: for EdDSA in CMS, the id-shake256-len\n-                        \/\/ algorithm id must contain parameter value 512\n-                        \/\/ encoded as a positive integer value\n-                        byte[] params = digestAlgorithmId.getEncodedParams();\n-                        if (params == null) {\n-                            throw new SignatureException(\n-                                    \"id-shake256-len oid missing length\");\n-                        }\n-                        int v = new DerValue(params).getInteger();\n-                        if (v != 512) {\n-                            throw new SignatureException(\n-                                    \"Unsupported id-shake256-\" + v);\n-                        }\n+                if (digestAlgName.equals(\"SHAKE256-LEN\")) {\n+                    \/\/ RFC8419: for EdDSA in CMS, the id-shake256-len\n+                    \/\/ algorithm id must contain parameter value 512\n+                    \/\/ encoded as a positive integer value\n+                    byte[] params = digestAlgorithmId.getEncodedParams();\n+                    if (params == null) {\n+                        throw new SignatureException(\n+                                \"id-shake256-len oid missing length\");\n+                    }\n+                    int v = new DerValue(params).getInteger();\n+                    if (v != 512) {\n+                        throw new SignatureException(\n+                                \"Unsupported id-shake256-\" + v);\n@@ -413,1 +415,0 @@\n-            X509Certificate cert = getCertificate(block);\n@@ -415,1 +416,4 @@\n-                return null;\n+                cert = getCertificate(block);\n+                if (cert == null) {\n+                    return null;\n+                }\n@@ -510,1 +514,1 @@\n-                if (!digAlgId.equals(SignatureUtil.EdDSADigestAlgHolder.sha512)) {\n+                if (!digAlgId.equalsOID(AlgorithmId.SHA512_oid)) {\n@@ -516,1 +520,1 @@\n-                    if (!digAlgId.equals(SignatureUtil.EdDSADigestAlgHolder.shake256)) {\n+                    if (!digAlgId.equalsOID(AlgorithmId.SHAKE256_512_oid)) {\n@@ -520,1 +524,1 @@\n-                    if (!digAlgId.equals(SignatureUtil.EdDSADigestAlgHolder.shake256$512)) {\n+                    if (!digAlgId.equals(SignatureUtil.DigestAlgHolder.shake256lenWith512)) {\n@@ -527,1 +531,31 @@\n-                if (!digAlgId.equals(AlgorithmId.get(KeyUtil.hashAlgFromHSS(key)))) {\n+                if (!digAlgId.equalsOID(KeyUtil.hashAlgFromHSS(key))) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                }\n+                break;\n+            case \"ML-DSA-44\":\n+                \/\/ Following 3 from Table 1 inside\n+                \/\/ https:\/\/datatracker.ietf.org\/doc\/html\/rfc9882#name-signerinfo-content\n+                if (!digAlgId.equalsOID(AlgorithmId.SHA256_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA384_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_256_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_384_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHAKE128_256_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHAKE256_512_oid)) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\" + digAlgId);\n+                }\n+                break;\n+            case \"ML-DSA-65\":\n+                if (!digAlgId.equalsOID(AlgorithmId.SHA384_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_384_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHAKE256_512_oid)) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                }\n+                break;\n+            case \"ML-DSA-87\":\n+                if (!digAlgId.equalsOID(AlgorithmId.SHA512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHAKE256_512_oid)) {\n@@ -541,1 +575,1 @@\n-     * 1. Old style key algorithm like RSA, DSA, EC, this method returns\n+     * 1. Simply key algorithm like RSA, DSA, EC, this method returns\n@@ -543,1 +577,1 @@\n-     * 2. New style signature algorithm in the form of HASHwithKEY, this\n+     * 2. Traditional signature algorithm in the form of HASHwithKEY, this\n@@ -553,27 +587,11 @@\n-        switch (encAlg) {\n-            case \"RSASSA-PSS\":\n-            case \"Ed25519\":\n-            case \"Ed448\":\n-            case \"HSS\/LMS\":\n-                return encAlg;\n-            default:\n-                String digAlg = digAlgId.getName();\n-                String keyAlg = SignatureUtil.extractKeyAlgFromDwithE(encAlg);\n-                if (keyAlg == null) {\n-                    \/\/ The encAlg used to be only the key alg\n-                    keyAlg = encAlg;\n-                }\n-                if (digAlg.startsWith(\"SHA-\")) {\n-                    digAlg = \"SHA\" + digAlg.substring(4);\n-                }\n-                if (keyAlg.equals(\"EC\")) keyAlg = \"ECDSA\";\n-                String sigAlg = digAlg + \"with\" + keyAlg;\n-                try {\n-                    Signature.getInstance(sigAlg);\n-                    return sigAlg;\n-                } catch (NoSuchAlgorithmException e) {\n-                    \/\/ Possibly an unknown modern signature algorithm,\n-                    \/\/ in this case, encAlg should already be a signature\n-                    \/\/ algorithm.\n-                    return encAlg;\n-                }\n+        String keyAlg = SignatureUtil.extractKeyAlgFromDwithE(encAlg);\n+        if (keyAlg == null) { \/\/ No \"WITH\" inside\n+            if (encAlg.equals(\"RSA\") || encAlg.equals(\"DSA\") || encAlg.equals(\"EC\")) {\n+                keyAlg = encAlg; \/\/ Sometimes encAlgId is just the enc alg\n+            } else {\n+                return encAlg; \/\/ Must be a modern algorithm like EdDSA or ML-DSA\n+            }\n+        }\n+        String digAlg = digAlgId.getName();\n+        if (digAlg.startsWith(\"SHA-\")) {\n+            digAlg = \"SHA\" + digAlg.substring(4);\n@@ -581,0 +599,2 @@\n+        if (keyAlg.equals(\"EC\")) keyAlg = \"ECDSA\";\n+        return digAlg + \"with\" + keyAlg;\n@@ -586,1 +606,1 @@\n-        return verify(block, null);\n+        return verify(block, null, null);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":79,"deletions":59,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -433,1 +433,1 @@\n-    public static String hashAlgFromHSS(PublicKey publicKey)\n+    public static ObjectIdentifier hashAlgFromHSS(PublicKey publicKey)\n@@ -452,1 +452,1 @@\n-                case 5, 6, 7, 8, 9 -> \"SHA-256\";\n+                case 5, 6, 7, 8, 9 -> AlgorithmId.SHA256_oid;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,1 @@\n-    public static class EdDSADigestAlgHolder {\n+    public static class DigestAlgHolder {\n@@ -195,2 +195,2 @@\n-        public static final AlgorithmId shake256;\n-        public static final AlgorithmId shake256$512;\n+        public static final AlgorithmId shake256_512;\n+        public static final AlgorithmId shake256lenWith512;\n@@ -200,3 +200,3 @@\n-                sha512 = new AlgorithmId(ObjectIdentifier.of(KnownOIDs.SHA_512));\n-                shake256 = new AlgorithmId(ObjectIdentifier.of(KnownOIDs.SHAKE256_512));\n-                shake256$512 = new AlgorithmId(\n+                sha512 = new AlgorithmId(AlgorithmId.SHA512_oid);\n+                shake256_512 = new AlgorithmId(AlgorithmId.SHAKE256_512_oid);\n+                shake256lenWith512 = new AlgorithmId(\n@@ -236,1 +236,1 @@\n-                    digAlgID = EdDSADigestAlgHolder.sha512;\n+                    digAlgID = DigestAlgHolder.sha512;\n@@ -240,1 +240,1 @@\n-                        digAlgID = EdDSADigestAlgHolder.shake256;\n+                        digAlgID = DigestAlgHolder.shake256_512;\n@@ -242,1 +242,1 @@\n-                        digAlgID = EdDSADigestAlgHolder.shake256$512;\n+                        digAlgID = DigestAlgHolder.shake256lenWith512;\n@@ -248,0 +248,4 @@\n+        } else if (kAlg.toUpperCase(Locale.ENGLISH).startsWith(\"ML-DSA\")) {\n+            \/\/ https:\/\/datatracker.ietf.org\/doc\/html\/rfc9882#name-signerinfo-content\n+            \/\/ Just use SHA-512\n+            digAlgID = DigestAlgHolder.sha512;\n@@ -257,1 +261,1 @@\n-            digAlgID = AlgorithmId.get(KeyUtil.hashAlgFromHSS(publicKey));\n+            digAlgID = new AlgorithmId(KeyUtil.hashAlgFromHSS(publicKey));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -310,0 +310,8 @@\n+    \/**\n+     * Returns true if this AlgorithmID only has the specified ObjectIdentifier\n+     * and a NULL params. Note the encoded params might be ASN.1 NULL or absent.\n+     *\/\n+    public boolean equalsOID(ObjectIdentifier oid) {\n+        return algid.equals(oid) && encodedParams == null;\n+    }\n+\n@@ -631,0 +639,6 @@\n+    public static final ObjectIdentifier SHAKE128_256_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHAKE128_256);\n+\n+    public static final ObjectIdentifier SHAKE256_512_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHAKE256_512);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -282,0 +282,5 @@\n+* Modern digital signature algorithms such as HSS\/LMS and ML-DSA use the same\n+name for both the key and signature algorithms. Only the signature algorithm\n+with the same name can be used with a given key algorithm. The `.DSA`\n+block file extension is always used.\n+\n","filename":"src\/jdk.jartool\/share\/man\/jarsigner.md","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349732\n+ * @summary ML-DSA digest alg conformance check\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.pkcs.PKCS7;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.AlgorithmId;\n+import sun.security.x509.X500Name;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DigestConformance {\n+\n+    static String[] ALL_KEY_ALGS = {\"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\"};\n+    static String[] ALL_DIGEST_ALGS = {\n+            \"SHA-1\", \"SHA-224\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\n+            \"SHA3-224\", \"SHA3-256\", \"SHA3-384\", \"SHA3-512\",\n+            \"SHAKE128-256\", \"SHAKE256-512\"};\n+    static Map<String, List<String>> SUPPORTED = Map.of(\n+            \"ML-DSA-44\", List.of(\"SHA-256\", \"SHA-384\", \"SHA-512\",\n+                    \"SHA3-256\", \"SHA3-384\", \"SHA3-512\",\n+                    \"SHAKE128-256\", \"SHAKE256-512\"),\n+            \"ML-DSA-65\", List.of(\"SHA-384\", \"SHA-512\",\n+                    \"SHA3-384\", \"SHA3-512\", \"SHAKE256-512\"),\n+            \"ML-DSA-87\", List.of(\"SHA-512\", \"SHA3-512\", \"SHAKE256-512\")\n+    );\n+\n+    public static void main(String[] args) throws Exception {\n+        testSig(\"ML-DSA-44\");\n+        testSig(\"ML-DSA-65\");\n+        testSig(\"ML-DSA-87\");\n+    }\n+\n+    static void testSig(String keyAlg) throws Exception {\n+        System.out.println(\"Testing \" + keyAlg);\n+        var cag = new CertAndKeyGen(keyAlg, keyAlg);\n+        cag.generate(keyAlg);\n+        var sk = cag.getPrivateKey();\n+        var certs = new X509Certificate[] {\n+                cag.getSelfCertificate(new X500Name(\"CN=Me\"), 1000)\n+        };\n+        var count = testDigest(keyAlg, sk, certs, null);\n+        System.out.println(\"   digestAlg default: \" + count);\n+        Asserts.assertEQ(count, 1);\n+        for (var da : ALL_DIGEST_ALGS) {\n+            count = testDigest(keyAlg, sk, certs, da);\n+            System.out.println(\"   digestAlg \" + da + \": \" + count);\n+            if (SUPPORTED.get(keyAlg).contains(da)) {\n+                Asserts.assertEQ(count, 1);\n+            } else {\n+                Asserts.assertEQ(count, 0);\n+            }\n+        }\n+    }\n+\n+    static int testDigest(String keyAlg, PrivateKey sk,\n+            X509Certificate[] certs, String digestAlg) throws Exception {\n+        var content = \"hello\".getBytes(StandardCharsets.UTF_8);\n+        var p7 = PKCS7.generateSignedData(keyAlg, null,\n+                sk, certs,\n+                content, true, false,\n+                digestAlg == null ? null : AlgorithmId.get(digestAlg),\n+                null);\n+        try {\n+            return new PKCS7(p7).verify(null).length;\n+        } catch (NoSuchAlgorithmException e) {\n+            return 0;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs7\/DigestConformance.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349732\n+ * @library \/test\/lib\n+ * @summary Add support for JARs signed with ML-DSA\n+ * @modules java.base\/sun.security.pkcs\n+ *\/\n+import jdk.test.lib.Asserts;\n+import sun.security.pkcs.PKCS7;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+import static jdk.test.lib.security.DataFetcher.*;\n+\n+public class ML_DSA_CMS {\n+    public static void main(String[] args) throws Exception {\n+        test(readCMS(\"mldsa44-signed-attrs.pem\"), readCert(\"ML-DSA-44.crt\"));\n+        test(readCMS(\"mldsa65-signed-attrs.pem\"), readCert(\"ML-DSA-65.crt\"));\n+        test(readCMS(\"mldsa87-signed-attrs.pem\"), readCert(\"ML-DSA-87.crt\"));\n+    }\n+\n+    \/\/\/ Verifies a signed file.\n+    \/\/\/ @param data the signed data in PKCS #7 format\n+    \/\/\/ @param cert the certificate used to verify\n+    static void test(byte[] data, X509Certificate cert) throws Exception {\n+        var p7 = new PKCS7(data);\n+        for (var si : p7.getSignerInfos()) {\n+            Asserts.assertTrue(p7.verify(si, null, cert).getIssuerName() != null);\n+        }\n+    }\n+\n+    static byte[] readCMS(String entry) throws IOException  {\n+        var data = fetchData(CMS_ML_DSA.class,\n+                \"cms-ml-dsa-draft-ietf-lamps-cms-ml-dsa-07\/\",\n+                \"examples\/\" + entry);\n+        var pem = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(data)))\n+                .lines()\n+                .filter(s -> !s.contains(\"-----\"))\n+                .collect(Collectors.joining());\n+        return Base64.getMimeDecoder().decode(pem);\n+    }\n+\n+    static X509Certificate readCert(String entry) throws Exception {\n+        var data = fetchData(DILITHIUM_CERTIFICATES.class,\n+                \"dilithium-certificates-draft-ietf-lamps-dilithium-certificates-13\/\",\n+                \"examples\/\" + entry);\n+        var cf = CertificateFactory.getInstance(\"X.509\");\n+        return (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data));\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/pqc\/ML_DSA_CMS.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298387\n+ * @summary signing with ML-DSA\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.security.DerUtils;\n+import jdk.test.lib.util.JarUtils;\n+import sun.security.util.KnownOIDs;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.JarFile;\n+\n+public class ML_DSA {\n+    public static void main(String[] args) throws Exception {\n+\n+        JarUtils.createJarFile(Path.of(\"a.jar\"), Path.of(\".\"),\n+                Files.write(Path.of(\"a\"), new byte[10]));\n+\n+        genKeyAndSign(\"ML-DSA-44\", \"M4\");\n+        genKeyAndSign(\"ML-DSA-65\", \"M6\");\n+        genKeyAndSign(\"ML-DSA-87\", \"M8\");\n+\n+        SecurityTools.jarsigner(\"-verify a.jar -verbose -certs\")\n+                .shouldHaveExitValue(0)\n+                .shouldContain(\"jar verified\");\n+\n+        try (var jf = new JarFile(\"a.jar\")) {\n+\n+            var je = jf.getJarEntry(\"a\");\n+            jf.getInputStream(je).readAllBytes();\n+            Asserts.assertEquals(3, je.getCertificates().length);\n+\n+            checkDigestAlgorithm(jf, \"M4\", KnownOIDs.SHA_512);\n+            checkDigestAlgorithm(jf, \"M6\", KnownOIDs.SHA_512);\n+            checkDigestAlgorithm(jf, \"M8\", KnownOIDs.SHA_512);\n+        }\n+    }\n+\n+    static void genKeyAndSign(String alg, String alias) throws Exception {\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit -genkeypair -alias \"\n+                        + alias + \" -keyalg \" + alg + \" -dname CN=\" + alias)\n+                .shouldHaveExitValue(0);\n+        SecurityTools.jarsigner(\"-keystore ks -storepass changeit a.jar \" + alias)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    static void checkDigestAlgorithm(JarFile jf, String alias, KnownOIDs expectAlg)\n+            throws Exception {\n+        var p7 = jf.getInputStream(jf.getEntry(\"META-INF\/\" + alias + \".DSA\"))\n+                .readAllBytes();\n+        \/\/ SignedData - digestAlgorithms\n+        DerUtils.checkAlg(p7, \"10100\", expectAlg);\n+        \/\/ SignedData - signerInfos - digestAlgorithm\n+        DerUtils.checkAlg(p7, \"104020\", expectAlg);\n+        \/\/ SignedData - signerInfos - signedAttrs - CMSAlgorithmProtection - digestAlgorithm\n+        DerUtils.checkAlg(p7, \"1040321000\", expectAlg);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/ML_DSA.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.security;\n+\n+import jdk.test.lib.artifacts.Artifact;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.artifacts.ArtifactResolverException;\n+import jtreg.SkippedException;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+public class DataFetcher {\n+    \/\/\/ Fetches data.\n+    \/\/\/\n+    \/\/\/ By default, this method fetches a ZIP from an artifact server,\n+    \/\/\/ extracts an entry inside, and returns its content.\n+    \/\/\/\n+    \/\/\/ Users can also specify the \"jdk.tests.repos.pattern\" system property\n+    \/\/\/ to fetch the extracted file in an alternative location. The value of\n+    \/\/\/ this system property is a [format][java.util.Formatter] string that\n+    \/\/\/ takes the last part of [organization name][Artifact#organization()],\n+    \/\/\/ the [name][Artifact#name()], the [version][Artifact#revision()],\n+    \/\/\/ and `entry` as arguments. For example:\n+    \/\/\/\n+    \/\/\/ With the [CMS_ML_DSA] class inside this test, the pattern\n+    \/\/\/ `file:\/\/\/Users\/tester\/repos\/external\/%s\/%s\/%4$s` will be resolved to\n+    \/\/\/ a local file like `\/Users\/tester\/repos\/external\/lamps-wg\/cms-ml-dsa\/entry`;\n+    \/\/\/ and a pattern `https:\/\/raw.repos.com\/%s\/%s\/%s\/%s` will be resolved to\n+    \/\/\/ a URL like `https:\/\/raw.repos.com\/lamps-wg\/cms-ml-dsa\/c8f0cf7\/entry`.\n+    \/\/\/\n+    \/\/\/ @param klass the `Artifact` class\n+    \/\/\/ @param zipPrefix the common prefix for each entry in the ZIP file\n+    \/\/\/ @param entry the entry name without `zipPrefix`\n+    public static byte[] fetchData(Class<?> klass, String zipPrefix, String entry)\n+            throws IOException {\n+        Artifact artifact = klass.getAnnotation(Artifact.class);\n+        var org = artifact.organization();\n+        var prop = System.getProperty(\"jdk.tests.repos.pattern\");\n+        if (prop != null && org.startsWith(\"jpg.tests.jdk.repos.\")) {\n+            var url = String.format(prop,\n+                    org.substring(org.lastIndexOf('.') + 1),\n+                    artifact.name(),\n+                    artifact.revision(),\n+                    entry);\n+            System.out.println(\"fetching \" + url + \"...\");\n+            try (var is = new URI(url).toURL().openStream()) {\n+                return is.readAllBytes();\n+            } catch (URISyntaxException e) {\n+                throw new IOException(\"Invalid URL: \" + url);\n+            }\n+        } else {\n+            try {\n+                Path p = ArtifactResolver.resolve(klass).entrySet().stream()\n+                        .findAny().get().getValue();\n+                System.out.println(\"fetching \" + zipPrefix + entry + \" in \" + p + \"...\");\n+                try (ZipFile zf = new ZipFile(p.toFile())) {\n+                    ZipEntry ze = zf.getEntry(zipPrefix + entry);\n+                    if (ze != null) {\n+                        return zf.getInputStream(ze).readAllBytes();\n+                    } else {\n+                        throw new RuntimeException(\"Entry not found: \" + entry);\n+                    }\n+                }\n+            } catch (ArtifactResolverException e) {\n+                throw new SkippedException(\"Cannot find the artifact \" + artifact.name(), e);\n+            }\n+        }\n+    }\n+\n+    @Artifact(\n+            organization = \"jpg.tests.jdk.repos.lamps-wg\",\n+            name = \"dilithium-certificates\",\n+            revision = \"785a549\",\n+            extension = \"zip\",\n+            unpack = false)\n+    public static class DILITHIUM_CERTIFICATES {\n+    }\n+\n+    @Artifact(\n+            organization = \"jpg.tests.jdk.repos.lamps-wg\",\n+            name = \"cms-ml-dsa\",\n+            revision = \"c8f0cf7\",\n+            extension = \"zip\",\n+            unpack = false)\n+    public static class CMS_ML_DSA {\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/DataFetcher.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"}]}