{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -533,2 +533,17 @@\n-    throws NoSuchAlgorithmException, SignatureException {\n-        return info.verify(this, bytes);\n+            throws NoSuchAlgorithmException, SignatureException {\n+        return info.verify(this, bytes, null);\n+    }\n+\n+    \/**\n+     * This verifies a given SignerInfo.\n+     *\n+     * @param info the signer information.\n+     * @param bytes the DER encoded content information.\n+     * @param cert certificate used to verify; find one inside the block if null\n+     *\n+     * @exception NoSuchAlgorithmException on unrecognized algorithms.\n+     * @exception SignatureException on signature handling errors.\n+     *\/\n+    public SignerInfo verify(SignerInfo info, byte[] bytes, X509Certificate cert)\n+            throws NoSuchAlgorithmException, SignatureException {\n+        return info.verify(this, bytes, cert);\n@@ -718,0 +733,13 @@\n+    \/\/ Generate signed data without a specified digAlgID.\n+    public static byte[] generateSignedData(\n+            String sigalg, Provider sigProvider,\n+            PrivateKey privateKey, X509Certificate[] signerChain,\n+            byte[] content, boolean internalsf, boolean directsign,\n+            Function<byte[], PKCS9Attributes> ts)\n+            throws SignatureException, InvalidKeyException, IOException,\n+            NoSuchAlgorithmException {\n+        return generateSignedData(sigalg, sigProvider, privateKey, signerChain,\n+                content, internalsf, directsign,\n+                null, ts);\n+    }\n+\n@@ -728,0 +756,1 @@\n+     * @param digAlgID digest alg to use; derive from other arguments if null\n@@ -739,0 +768,1 @@\n+            AlgorithmId digAlgID,\n@@ -745,2 +775,4 @@\n-        AlgorithmId digAlgID = SignatureUtil.getDigestAlgInPkcs7SignerInfo(\n-                signer, sigalg, privateKey, signerChain[0].getPublicKey(), directsign);\n+        if (digAlgID == null) {\n+            digAlgID = SignatureUtil.getDigestAlgInPkcs7SignerInfo(\n+                    signer, sigalg, privateKey, signerChain[0].getPublicKey(), directsign);\n+        }\n@@ -754,2 +786,3 @@\n-            if (digAlgName.equals(\"SHAKE256\") || digAlgName.equals(\"SHAKE256-LEN\")) {\n-                \/\/ No MessageDigest impl for SHAKE256 yet\n+            if (digAlgName.equals(\"SHAKE256-LEN\")) {\n+                \/\/ We don't check the LEN here. Usually it is returned\n+                \/\/ by SignatureUtil.getDigestAlgInPkcs7SignerInfo\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS7.java","additions":40,"deletions":7,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,4 +306,10 @@\n-    \/* Returns null if verify fails, this signerInfo if\n-       verify succeeds. *\/\n-    SignerInfo verify(PKCS7 block, byte[] data)\n-    throws NoSuchAlgorithmException, SignatureException {\n+    \/**\n+     * Verify this signerInfo in a PKCS7 block.\n+     *\n+     * @param block the PKCS7 object\n+     * @param data the content to verify against; read from block if null\n+     * @param cert certificate to verify with; read from block if null\n+     * @return null if verify fails, this signerInfo if verify succeeds.\n+     *\/\n+    SignerInfo verify(PKCS7 block, byte[] data, X509Certificate cert)\n+            throws NoSuchAlgorithmException, SignatureException {\n@@ -312,1 +318,0 @@\n-            Timestamp timestamp = null;\n@@ -314,1 +319,1 @@\n-                timestamp = getTimestamp();\n+                getTimestamp();\n@@ -359,16 +364,13 @@\n-                if (digestAlgName.equals(\"SHAKE256\")\n-                        || digestAlgName.equals(\"SHAKE256-LEN\")) {\n-                    if (digestAlgName.equals(\"SHAKE256-LEN\")) {\n-                        \/\/ RFC8419: for EdDSA in CMS, the id-shake256-len\n-                        \/\/ algorithm id must contain parameter value 512\n-                        \/\/ encoded as a positive integer value\n-                        byte[] params = digestAlgorithmId.getEncodedParams();\n-                        if (params == null) {\n-                            throw new SignatureException(\n-                                    \"id-shake256-len oid missing length\");\n-                        }\n-                        int v = new DerValue(params).getInteger();\n-                        if (v != 512) {\n-                            throw new SignatureException(\n-                                    \"Unsupported id-shake256-\" + v);\n-                        }\n+                if (digestAlgName.equals(\"SHAKE256-LEN\")) {\n+                    \/\/ RFC8419: for EdDSA in CMS, the id-shake256-len\n+                    \/\/ algorithm id must contain parameter value 512\n+                    \/\/ encoded as a positive integer value\n+                    byte[] params = digestAlgorithmId.getEncodedParams();\n+                    if (params == null) {\n+                        throw new SignatureException(\n+                                \"id-shake256-len oid missing length\");\n+                    }\n+                    int v = new DerValue(params).getInteger();\n+                    if (v != 512) {\n+                        throw new SignatureException(\n+                                \"Unsupported id-shake256-\" + v);\n@@ -413,1 +415,0 @@\n-            X509Certificate cert = getCertificate(block);\n@@ -415,1 +416,4 @@\n-                return null;\n+                cert = getCertificate(block);\n+                if (cert == null) {\n+                    return null;\n+                }\n@@ -506,1 +510,1 @@\n-                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm \" + digAlgId);\n@@ -510,2 +514,2 @@\n-                if (!digAlgId.equals(SignatureUtil.EdDSADigestAlgHolder.sha512)) {\n-                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                if (!digAlgId.equalsOID(AlgorithmId.SHA512_oid)) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm \" + digAlgId);\n@@ -516,2 +520,2 @@\n-                    if (!digAlgId.equals(SignatureUtil.EdDSADigestAlgHolder.shake256)) {\n-                        throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                    if (!digAlgId.equalsOID(AlgorithmId.SHAKE256_512_oid)) {\n+                        throw new NoSuchAlgorithmException(\"Incompatible digest algorithm \" + digAlgId);\n@@ -520,2 +524,2 @@\n-                    if (!digAlgId.equals(SignatureUtil.EdDSADigestAlgHolder.shake256$512)) {\n-                        throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                    if (!digAlgId.equals(SignatureUtil.DigestAlgHolder.shake256lenWith512)) {\n+                        throw new NoSuchAlgorithmException(\"Incompatible digest algorithm \" + digAlgId);\n@@ -527,2 +531,32 @@\n-                if (!digAlgId.equals(AlgorithmId.get(KeyUtil.hashAlgFromHSS(key)))) {\n-                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                if (!digAlgId.equalsOID(KeyUtil.hashAlgFromHSS(key))) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm \" + digAlgId);\n+                }\n+                break;\n+            case \"ML-DSA-44\":\n+                \/\/ Following 3 from Table 1 inside\n+                \/\/ https:\/\/datatracker.ietf.org\/doc\/html\/rfc9882#name-signerinfo-content\n+                if (!digAlgId.equalsOID(AlgorithmId.SHA256_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA384_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_256_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_384_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHAKE128_256_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHAKE256_512_oid)) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm \" + digAlgId);\n+                }\n+                break;\n+            case \"ML-DSA-65\":\n+                if (!digAlgId.equalsOID(AlgorithmId.SHA384_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_384_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHAKE256_512_oid)) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm \" + digAlgId);\n+                }\n+                break;\n+            case \"ML-DSA-87\":\n+                if (!digAlgId.equalsOID(AlgorithmId.SHA512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHA3_512_oid)\n+                        && !digAlgId.equalsOID(AlgorithmId.SHAKE256_512_oid)) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm \" + digAlgId);\n@@ -541,1 +575,1 @@\n-     * 1. Old style key algorithm like RSA, DSA, EC, this method returns\n+     * 1. Simple key algorithm like RSA, DSA, EC, this method returns\n@@ -543,1 +577,1 @@\n-     * 2. New style signature algorithm in the form of HASHwithKEY, this\n+     * 2. Traditional signature algorithm in the form of HASHwithKEY, this\n@@ -553,27 +587,11 @@\n-        switch (encAlg) {\n-            case \"RSASSA-PSS\":\n-            case \"Ed25519\":\n-            case \"Ed448\":\n-            case \"HSS\/LMS\":\n-                return encAlg;\n-            default:\n-                String digAlg = digAlgId.getName();\n-                String keyAlg = SignatureUtil.extractKeyAlgFromDwithE(encAlg);\n-                if (keyAlg == null) {\n-                    \/\/ The encAlg used to be only the key alg\n-                    keyAlg = encAlg;\n-                }\n-                if (digAlg.startsWith(\"SHA-\")) {\n-                    digAlg = \"SHA\" + digAlg.substring(4);\n-                }\n-                if (keyAlg.equals(\"EC\")) keyAlg = \"ECDSA\";\n-                String sigAlg = digAlg + \"with\" + keyAlg;\n-                try {\n-                    Signature.getInstance(sigAlg);\n-                    return sigAlg;\n-                } catch (NoSuchAlgorithmException e) {\n-                    \/\/ Possibly an unknown modern signature algorithm,\n-                    \/\/ in this case, encAlg should already be a signature\n-                    \/\/ algorithm.\n-                    return encAlg;\n-                }\n+        String keyAlg = SignatureUtil.extractKeyAlgFromDwithE(encAlg);\n+        if (keyAlg == null) { \/\/ No \"WITH\" inside\n+            if (encAlg.equals(\"RSA\") || encAlg.equals(\"DSA\") || encAlg.equals(\"EC\")) {\n+                keyAlg = encAlg; \/\/ Sometimes encAlgId is just the enc alg\n+            } else {\n+                return encAlg; \/\/ Must be a modern algorithm like EdDSA or ML-DSA\n+            }\n+        }\n+        String digAlg = digAlgId.getName();\n+        if (digAlg.startsWith(\"SHA-\")) {\n+            digAlg = \"SHA\" + digAlg.substring(4);\n@@ -581,0 +599,2 @@\n+        if (keyAlg.equals(\"EC\")) keyAlg = \"ECDSA\";\n+        return digAlg + \"with\" + keyAlg;\n@@ -586,1 +606,1 @@\n-        return verify(block, null);\n+        return verify(block, null, null);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":84,"deletions":64,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -433,1 +433,1 @@\n-    public static String hashAlgFromHSS(PublicKey publicKey)\n+    public static ObjectIdentifier hashAlgFromHSS(PublicKey publicKey)\n@@ -452,1 +452,1 @@\n-                case 5, 6, 7, 8, 9 -> \"SHA-256\";\n+                case 5, 6, 7, 8, 9 -> AlgorithmId.SHA256_oid;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,1 @@\n-    public static class EdDSADigestAlgHolder {\n+    public static class DigestAlgHolder {\n@@ -195,2 +195,2 @@\n-        public static final AlgorithmId shake256;\n-        public static final AlgorithmId shake256$512;\n+        public static final AlgorithmId shake256_512;\n+        public static final AlgorithmId shake256lenWith512;\n@@ -200,3 +200,3 @@\n-                sha512 = new AlgorithmId(ObjectIdentifier.of(KnownOIDs.SHA_512));\n-                shake256 = new AlgorithmId(ObjectIdentifier.of(KnownOIDs.SHAKE256_512));\n-                shake256$512 = new AlgorithmId(\n+                sha512 = new AlgorithmId(AlgorithmId.SHA512_oid);\n+                shake256_512 = new AlgorithmId(AlgorithmId.SHAKE256_512_oid);\n+                shake256lenWith512 = new AlgorithmId(\n@@ -236,1 +236,1 @@\n-                    digAlgID = EdDSADigestAlgHolder.sha512;\n+                    digAlgID = DigestAlgHolder.sha512;\n@@ -240,1 +240,1 @@\n-                        digAlgID = EdDSADigestAlgHolder.shake256;\n+                        digAlgID = DigestAlgHolder.shake256_512;\n@@ -242,1 +242,1 @@\n-                        digAlgID = EdDSADigestAlgHolder.shake256$512;\n+                        digAlgID = DigestAlgHolder.shake256lenWith512;\n@@ -248,0 +248,4 @@\n+        } else if (kAlg.toUpperCase(Locale.ENGLISH).startsWith(\"ML-DSA\")) {\n+            \/\/ https:\/\/datatracker.ietf.org\/doc\/html\/rfc9882#name-signerinfo-content\n+            \/\/ Just use SHA-512\n+            digAlgID = DigestAlgHolder.sha512;\n@@ -257,1 +261,1 @@\n-            digAlgID = AlgorithmId.get(KeyUtil.hashAlgFromHSS(publicKey));\n+            digAlgID = new AlgorithmId(KeyUtil.hashAlgFromHSS(publicKey));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -310,0 +310,8 @@\n+    \/**\n+     * Returns true if this AlgorithmID only has the specified ObjectIdentifier\n+     * and a NULL params. Note the encoded params might be ASN.1 NULL or absent.\n+     *\/\n+    public boolean equalsOID(ObjectIdentifier oid) {\n+        return algid.equals(oid) && encodedParams == null;\n+    }\n+\n@@ -631,0 +639,6 @@\n+    public static final ObjectIdentifier SHAKE128_256_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHAKE128_256);\n+\n+    public static final ObjectIdentifier SHAKE256_512_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHAKE256_512);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -258,16 +258,16 @@\n-keyalg      key size    default sigalg              block file extension\n--------     --------    --------------              --------------------\n-DSA         any size    SHA256withDSA               .DSA\n-RSA         \\< 624      SHA256withRSA               .RSA\n-            \\<= 7680    SHA384withRSA\n-            \\> 7680     SHA512withRSA\n-EC          \\< 512      SHA384withECDSA             .EC\n-            \\>= 512     SHA512withECDSA\n-RSASSA-PSS  \\< 624      RSASSA-PSS (with SHA-256)   .RSA\n-            \\<= 7680    RSASSA-PSS (with SHA-384)\n-            \\> 7680     RSASSA-PSS (with SHA-512)\n-EdDSA       255         Ed25519                     .EC\n-            448         Ed448\n--------     --------    --------------              ------\n-\n-* If an RSASSA-PSS key is encoded with parameters, then jarsigner will use the\n+keyalg          key size    default sigalg              block file extension\n+-------         --------    --------------              --------------------\n+DSA             any size    SHA256withDSA               .DSA\n+RSA             \\< 624      SHA256withRSA               .RSA\n+                \\<= 7680    SHA384withRSA\n+                \\> 7680     SHA512withRSA\n+EC              \\< 512      SHA384withECDSA             .EC\n+                \\>= 512     SHA512withECDSA\n+RSASSA-PSS^1^   \\< 624      RSASSA-PSS (with SHA-256)   .RSA\n+                \\<= 7680    RSASSA-PSS (with SHA-384)\n+                \\> 7680     RSASSA-PSS (with SHA-512)\n+EdDSA^2^                    EdDSA                       .EC\n+ML-DSA^2^                   ML-DSA                      .DSA\n+-------         --------    --------------              ------\n+\n+1. If an RSASSA-PSS key is encoded with parameters, then jarsigner will use the\n@@ -279,2 +279,8 @@\n-* If a key algorithm is not listed in this table, the `.DSA` extension\n-is used when signing a JAR file.\n+2. Modern digital signature algorithms such as EdDSA and ML-DSA use the same\n+name for both the key and signature algorithms. Only the signature algorithm\n+with the same name can be used with a given key algorithm. The specific\n+signature parameter set (for example, Ed25519 or Ed448 for EdDSA) is the\n+same as that of the key.\n+\n+If a key algorithm is not listed in this table, the `.DSA` block file extension\n+is always used.\n","filename":"src\/jdk.jartool\/share\/man\/jarsigner.md","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349732\n+ * @summary ML-DSA digest alg conformance check\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.pkcs.PKCS7;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.AlgorithmId;\n+import sun.security.x509.X500Name;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class MLDSADigestConformance {\n+\n+    static String[] ALL_KEY_ALGS = {\"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\"};\n+    static String[] ALL_DIGEST_ALGS = {\n+            \"SHA-1\", \"SHA-224\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\n+            \"SHA3-224\", \"SHA3-256\", \"SHA3-384\", \"SHA3-512\",\n+            \"SHAKE128-256\", \"SHAKE256-512\"};\n+    static Map<String, List<String>> SUPPORTED = Map.of(\n+            \"ML-DSA-44\", List.of(\"SHA-256\", \"SHA-384\", \"SHA-512\",\n+                    \"SHA3-256\", \"SHA3-384\", \"SHA3-512\",\n+                    \"SHAKE128-256\", \"SHAKE256-512\"),\n+            \"ML-DSA-65\", List.of(\"SHA-384\", \"SHA-512\",\n+                    \"SHA3-384\", \"SHA3-512\", \"SHAKE256-512\"),\n+            \"ML-DSA-87\", List.of(\"SHA-512\", \"SHA3-512\", \"SHAKE256-512\")\n+    );\n+\n+    public static void main(String[] args) throws Exception {\n+        testSig(\"ML-DSA-44\");\n+        testSig(\"ML-DSA-65\");\n+        testSig(\"ML-DSA-87\");\n+    }\n+\n+    static void testSig(String keyAlg) throws Exception {\n+        System.out.println(\"Testing \" + keyAlg);\n+        var cag = new CertAndKeyGen(keyAlg, keyAlg);\n+        cag.generate(keyAlg);\n+        var sk = cag.getPrivateKey();\n+        var certs = new X509Certificate[] {\n+                cag.getSelfCertificate(new X500Name(\"CN=Me\"), 1000)\n+        };\n+        var count = testDigest(keyAlg, sk, certs, null);\n+        System.out.println(\"   digestAlg default: \" + count);\n+        Asserts.assertEQ(count, 1);\n+        for (var da : ALL_DIGEST_ALGS) {\n+            count = testDigest(keyAlg, sk, certs, da);\n+            System.out.println(\"   digestAlg \" + da + \": \" + count);\n+            if (SUPPORTED.get(keyAlg).contains(da)) {\n+                Asserts.assertEQ(count, 1);\n+            } else {\n+                Asserts.assertEQ(count, 0);\n+            }\n+        }\n+    }\n+\n+    static int testDigest(String keyAlg, PrivateKey sk,\n+            X509Certificate[] certs, String digestAlg) throws Exception {\n+        var content = \"hello\".getBytes(StandardCharsets.UTF_8);\n+        var p7 = PKCS7.generateSignedData(keyAlg, null,\n+                sk, certs,\n+                content, true, false,\n+                digestAlg == null ? null : AlgorithmId.get(digestAlg),\n+                null);\n+        try {\n+            return new PKCS7(p7).verify(null).length;\n+        } catch (NoSuchAlgorithmException e) {\n+            return 0;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs7\/MLDSADigestConformance.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349732\n+ * @library \/test\/lib\n+ * @summary Add support for JARs signed with ML-DSA\n+ * @modules java.base\/sun.security.pkcs\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.RepositoryFileReader;\n+import sun.security.pkcs.PKCS7;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+import static jdk.test.lib.security.RepositoryFileReader.*;\n+\n+public class ML_DSA_CMS {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ See RFC 9882, Section \"Examples\": https:\/\/datatracker.ietf.org\/doc\/html\/rfc9882#name-examples\n+        \/\/ The test vectors originate from the following GitHub releases:\n+        \/\/   https:\/\/github.com\/lamps-wg\/cms-ml-dsa\/releases\/tag\/draft-ietf-lamps-cms-ml-dsa-07\n+        \/\/   https:\/\/github.com\/lamps-wg\/dilithium-certificates\/releases\/tag\/draft-ietf-lamps-dilithium-certificates-13\n+        \/\/ Although the release tags include \"draft\", these values are the same as those in the final RFC 9882.\n+        try (var cmsReader = RepositoryFileReader.of(CMS_ML_DSA.class,\n+                    \"cms-ml-dsa-draft-ietf-lamps-cms-ml-dsa-07\/\");\n+            var dsaReader = RepositoryFileReader.of(DILITHIUM_CERTIFICATES.class,\n+                    \"dilithium-certificates-draft-ietf-lamps-dilithium-certificates-13\/\")) {\n+            test(readCMS(cmsReader, \"mldsa44-signed-attrs.pem\"),\n+                    readCert(dsaReader, \"ML-DSA-44.crt\"));\n+            test(readCMS(cmsReader, \"mldsa65-signed-attrs.pem\"),\n+                    readCert(dsaReader, \"ML-DSA-65.crt\"));\n+            test(readCMS(cmsReader, \"mldsa87-signed-attrs.pem\"),\n+                    readCert(dsaReader, \"ML-DSA-87.crt\"));\n+        }\n+    }\n+\n+    \/\/\/ Verifies a signed file.\n+    \/\/\/ @param data the signed data in PKCS #7 format\n+    \/\/\/ @param cert the certificate used to verify\n+    static void test(byte[] data, X509Certificate cert) throws Exception {\n+        var p7 = new PKCS7(data);\n+        for (var si : p7.getSignerInfos()) {\n+            Asserts.assertTrue(p7.verify(si, null, cert).getIssuerName() != null);\n+        }\n+    }\n+\n+    \/\/ Read data in https:\/\/datatracker.ietf.org\/doc\/html\/rfc9882#name-examples\n+    static byte[] readCMS(RepositoryFileReader f, String entry) throws IOException  {\n+        var data = f.read(\"examples\/\" + entry);\n+        var pem = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(data)))\n+                .lines()\n+                .filter(s -> !s.contains(\"-----\"))\n+                .collect(Collectors.joining());\n+        return Base64.getMimeDecoder().decode(pem);\n+    }\n+\n+    \/\/ Read data in https:\/\/datatracker.ietf.org\/doc\/html\/rfc9881#name-example-certificates\n+    static X509Certificate readCert(RepositoryFileReader f, String entry) throws Exception {\n+        var data = f.read(\"examples\/\" + entry);\n+        var cf = CertificateFactory.getInstance(\"X.509\");\n+        return (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data));\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/pqc\/ML_DSA_CMS.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298387\n+ * @summary signing with ML-DSA\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ *\/\n+\n+import jdk.security.jarsigner.JarSigner;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.process.Proc;\n+import jdk.test.lib.security.DerUtils;\n+import jdk.test.lib.util.JarUtils;\n+import sun.security.util.KnownOIDs;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.KeyStore;\n+import java.util.List;\n+import java.util.jar.JarFile;\n+import java.util.zip.ZipFile;\n+\n+public class ML_DSA {\n+\n+    static List<String> SIGNERS = List.of(\"44\", \"65\", \"87\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0) {\n+            \/\/ Launched by testDisabled() in a sub-process to count signers\n+            var expectedCount = Integer.parseInt(args[0]);\n+            try (var jf = new JarFile(\"a.jar\")) {\n+                var je = jf.getJarEntry(\"a\");\n+                jf.getInputStream(je).readAllBytes();\n+                var signers = je.getCodeSigners();\n+                var count = signers == null ? 0 : signers.length;\n+                if (expectedCount != count) {\n+                    throw new RuntimeException(\"Expected: \" + expectedCount\n+                            + \", actual \" + count);\n+                }\n+            }\n+        } else {\n+            prepare();\n+            testAPI();\n+            testTool(); \/\/ call this last, it modified a.jar.\n+            testDisabled();\n+        }\n+    }\n+\n+    private static void prepare() throws Exception {\n+        for (var signer : SIGNERS) {\n+            SecurityTools.keytool(\"-keystore ks -storepass changeit -genkeypair -alias \"\n+                            + signer + \" -keyalg ML-DSA-\" + signer + \" -dname CN=\" + signer)\n+                    .shouldHaveExitValue(0);\n+        }\n+        JarUtils.createJarFile(Path.of(\"a.jar\"), Path.of(\".\"),\n+                Files.write(Path.of(\"a\"), new byte[10]));\n+    }\n+\n+    static void testAPI() throws Exception {\n+        var pass = \"changeit\".toCharArray();\n+        var ks = KeyStore.getInstance(new File(\"ks\"), pass);\n+        for (var signer : SIGNERS) {\n+            var jsb = new JarSigner.Builder((KeyStore.PrivateKeyEntry)\n+                    ks.getEntry(signer, new KeyStore.PasswordProtection(pass)));\n+            try (var zf = new ZipFile(\"a.jar\");\n+                 var of = Files.newOutputStream(Path.of(signer + \".jar\"))) {\n+                jsb.signerName(signer).build().sign(zf, of);\n+            }\n+            try (var jf = new JarFile(signer + \".jar\")) {\n+                var je = jf.getJarEntry(\"a\");\n+                jf.getInputStream(je).readAllBytes();\n+                Asserts.assertEquals(1, je.getCodeSigners().length);\n+                checkDigestAlgorithm(jf, signer, KnownOIDs.SHA_512);\n+            }\n+        }\n+    }\n+\n+    static void testTool() throws Exception {\n+        for (var signer : SIGNERS) {\n+            SecurityTools.jarsigner(\"-keystore ks -storepass changeit a.jar \" + signer)\n+                    .shouldHaveExitValue(0);\n+        }\n+        SecurityTools.jarsigner(\"-verify a.jar -verbose -certs\")\n+                .shouldHaveExitValue(0)\n+                .shouldContain(\"jar verified\");\n+\n+        try (var jf = new JarFile(\"a.jar\")) {\n+            var je = jf.getJarEntry(\"a\");\n+            jf.getInputStream(je).readAllBytes();\n+            Asserts.assertEquals(3, je.getCodeSigners().length);\n+            for (var signer : SIGNERS) {\n+                checkDigestAlgorithm(jf, signer, KnownOIDs.SHA_512);\n+            }\n+        }\n+    }\n+\n+    static void testDisabled() throws Exception {\n+\n+        \/\/ All disabled\n+        Files.writeString(Paths.get(\"my.security\"),\n+                \"jdk.jar.disabledAlgorithms=ML-DSA\");\n+        SecurityTools.jarsigner(\"-J-Djava.security.properties=my.security\" +\n+                        \" -keystore ks -storepass changeit\" +\n+                        \" -verify a.jar -verbose -certs -strict\")\n+                .shouldHaveExitValue(16)\n+                .shouldContain(\"ML-DSA-44 key (disabled)\")\n+                .shouldContain(\"ML-DSA-65 key (disabled)\")\n+                .shouldContain(\"ML-DSA-87 key (disabled)\")\n+                .shouldContain(\"The jar will be treated as unsigned\");\n+        \/\/ Need to launch in a new process because security property is\n+        \/\/ read at the beginning\n+        Proc.create(\"ML_DSA\")\n+                .secprop(\"jdk.jar.disabledAlgorithms\", \"ML-DSA\")\n+                .args(\"0\")\n+                .start()\n+                .waitFor(0);\n+\n+        \/\/ One disabled, one made weak\n+        Files.writeString(Paths.get(\"my.security\"), \"\"\"\n+                        jdk.jar.disabledAlgorithms=ML-DSA-44\n+                        jdk.security.legacyAlgorithms=ML-DSA-65\n+                        \"\"\");\n+        SecurityTools.jarsigner(\"-J-Djava.security.properties=my.security\" +\n+                        \" -keystore ks -storepass changeit\" +\n+                        \" -verify a.jar -verbose -certs -strict\")\n+                .shouldHaveExitValue(0)\n+                .shouldContain(\"ML-DSA-44 key (disabled)\")\n+                .shouldContain(\"ML-DSA-65 key (weak)\")\n+                .shouldContain(\"ML-DSA-87 key\")\n+                .shouldNotContain(\"ML-DSA-87 key (disabled)\")\n+                .shouldContain(\"jar verified.\");\n+        Proc.create(\"ML_DSA\")\n+                .secprop(\"jdk.jar.disabledAlgorithms\", \"ML-DSA-44\")\n+                .secprop(\"jdk.security.legacyAlgorithms\", \"ML-DSA-65\")\n+                .args(\"2\") \/\/ weak still considered signer, disabled not\n+                .start()\n+                .waitFor(0);\n+    }\n+\n+    static void checkDigestAlgorithm(JarFile jf, String alias, KnownOIDs digAlg)\n+            throws Exception {\n+        var p7 = jf.getInputStream(jf.getEntry(\"META-INF\/\" + alias + \".DSA\"))\n+                .readAllBytes();\n+        \/\/ SignedData - digestAlgorithms\n+        DerUtils.checkAlg(p7, \"10100\", digAlg);\n+        \/\/ SignedData - signerInfos - digestAlgorithm\n+        DerUtils.checkAlg(p7, \"104020\", digAlg);\n+        \/\/ SignedData - signerInfos - signatureAlgorithm\n+        DerUtils.checkAlg(p7, \"104040\", KnownOIDs.valueOf(\"ML_DSA_\" + alias));\n+        \/\/ SignedData - signerInfos - signedAttrs - CMSAlgorithmProtection - digestAlgorithm\n+        DerUtils.checkAlg(p7, \"1040321000\", digAlg);\n+        \/\/ SignedData - signerInfos - signedAttrs - CMSAlgorithmProtection - signatureAlgorithm\n+        DerUtils.checkAlg(p7, \"1040321010\", KnownOIDs.valueOf(\"ML_DSA_\" + alias));\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/ML_DSA.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.security;\n+\n+import jdk.test.lib.artifacts.Artifact;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.artifacts.ArtifactResolverException;\n+import jtreg.SkippedException;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+\/\/\/ A helper class to read files from a code repository.\n+\/\/\/\n+\/\/\/ By default, the code repository is stored on the artifact server\n+\/\/\/ as a ZIP file.\n+\/\/\/\n+\/\/\/ Users can specify the \"jdk.tests.repos.pattern\" system property to read\n+\/\/\/ the files from an alternative location. The value of this system property\n+\/\/\/ represents the URL for each file entry where:\n+\/\/\/ - \"%o\" maps to the last part of [organization name][Artifact#organization()],\n+\/\/\/ - \"%n\" maps to [name][Artifact#name()],\n+\/\/\/ - \"%r\" maps to [version][Artifact#revision()],\n+\/\/\/ - \"%e\" maps to the name of the file entry to read.\n+\/\/\/\n+\/\/\/ For example, with the [CMS_ML_DSA] class inside this test:\n+\/\/\/ - The pattern `file:\/\/\/Users\/tester\/repos\/external\/%o\/%n\/%e` resolves to\n+\/\/\/   a local file like `\/Users\/tester\/repos\/external\/lamps-wg\/cms-ml-dsa\/entry`.\n+\/\/\/ - The pattern `https:\/\/raw.repos.com\/%o\/%n\/%r\/%e` resolves to\n+\/\/\/   `https:\/\/raw.repos.com\/lamps-wg\/cms-ml-dsa\/c8f0cf7\/entry`.\n+\/\/\/\n+public sealed interface RepositoryFileReader extends AutoCloseable {\n+\n+    \/\/\/ Reads the content of `entry` as a byte array.\n+    byte[] read(String entry) throws IOException;\n+\n+    \/\/\/ Overrides the method with a different exception type\n+    \/\/\/ to avoid compiler warnings about `InterruptedException`.\n+    @Override\n+    void close() throws IOException;\n+\n+    \/\/\/ Returns a `RepositoryFileReader`.\n+    \/\/\/ @param klass the `Artifact` class\n+    \/\/\/ @param zipPrefix the prefix used in the ZIP file. See\n+    \/\/\/         [ZipReader#ZipReader(ZipFile, String)].\n+    static RepositoryFileReader of(Class<?> klass, String zipPrefix) {\n+        Artifact artifact = klass.getAnnotation(Artifact.class);\n+        var org = artifact.organization();\n+        var prop = System.getProperty(\"jdk.tests.repos.pattern\");\n+        if (prop != null && org.startsWith(\"jpg.tests.jdk.repos.\")) {\n+            prop = prop.replace(\"%o\", org.substring(org.lastIndexOf('.') + 1));\n+            prop = prop.replace(\"%n\", artifact.name());\n+            prop = prop.replace(\"%r\", artifact.revision());\n+            System.out.println(\"Creating URLReader on \" + prop);\n+            return new URLReader(prop);\n+        } else {\n+            try {\n+                Path p = ArtifactResolver.resolve(klass).entrySet().stream()\n+                        .findAny().get().getValue();\n+                System.out.println(\"Creating ZipReader on \" + p);\n+                return new ZipReader(new ZipFile(p.toFile()), zipPrefix);\n+            } catch (ArtifactResolverException | IOException e) {\n+                throw new SkippedException(\"Cannot find \" + artifact.name(), e);\n+            }\n+        }\n+    }\n+\n+    \/\/\/ A `RepositoryFileReader` to read file from a URL.\n+    \/\/\/ @param base the base URL string, contains \"%e\" mapping to entry name\n+    record URLReader(String base) implements RepositoryFileReader {\n+        @Override\n+        public void close() {\n+            \/\/ nothing to do\n+        }\n+\n+        @Override\n+        public byte[] read(String entry) throws IOException {\n+            System.out.println(\"Reading \" + entry + \"...\");\n+            try (var is = new URI(base.replace(\"%e\", entry)).toURL().openStream()) {\n+                return is.readAllBytes();\n+            } catch (URISyntaxException e) {\n+                throw new IOException(\"Cannot create URI\", e);\n+            }\n+        }\n+    }\n+\n+    \/\/\/ A `RepositoryFileReader` to read file from a ZIP file.\n+    \/\/\/ @param zf the `ZipFile`\n+    \/\/\/ @param zipPrefix optional prefix string inside the ZIP file. For example,\n+    \/\/\/     if an entry \"folder\/file\" is represented as \"archive\/folder\/file\"\n+    \/\/\/     inside the ZIP, \"archive\/\" should be provided as `zipPrefix`.\n+    record ZipReader(ZipFile zf, String zipPrefix) implements RepositoryFileReader {\n+        @Override\n+        public void close() throws IOException {\n+            zf.close();\n+        }\n+\n+        @Override\n+        public byte[] read(String entry) throws IOException {\n+            System.out.println(\"Reading \" + entry + \"...\");\n+            ZipEntry ze = zf.getEntry(zipPrefix + entry);\n+            if (ze != null) {\n+                return zf.getInputStream(ze).readAllBytes();\n+            } else {\n+                throw new RuntimeException(\"Entry not found: \" + entry);\n+            }\n+        }\n+    }\n+\n+    @Artifact(\n+            organization = \"jpg.tests.jdk.repos.lamps-wg\",\n+            name = \"dilithium-certificates\",\n+            revision = \"785a549\",\n+            extension = \"zip\",\n+            unpack = false)\n+    public static class DILITHIUM_CERTIFICATES {\n+    }\n+\n+    @Artifact(\n+            organization = \"jpg.tests.jdk.repos.lamps-wg\",\n+            name = \"cms-ml-dsa\",\n+            revision = \"c8f0cf7\",\n+            extension = \"zip\",\n+            unpack = false)\n+    public static class CMS_ML_DSA {\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/RepositoryFileReader.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}