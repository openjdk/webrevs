{"files":[{"patch":"@@ -128,8 +128,4 @@\n-    if (thread != nullptr) {\n-      _outer = thread->is_in_internal_oome_mark();\n-      thread->set_is_in_internal_oome_mark(true);\n-      _thread = thread;\n-    } else {\n-      _outer = false;\n-      _thread = nullptr;\n-    }\n+    assert(thread != nullptr, \"nullptr is not supported\");\n+    _outer = thread->is_in_internal_oome_mark();\n+    thread->set_is_in_internal_oome_mark(true);\n+    _thread = thread;\n@@ -139,6 +135,4 @@\n-    if (_thread != nullptr) {\n-      \/\/ Check that only InternalOOMEMark sets\n-      \/\/ JavaThread::_is_in_internal_oome_mark\n-      assert(_thread->is_in_internal_oome_mark(), \"must be\");\n-      _thread->set_is_in_internal_oome_mark(_outer);\n-    }\n+    \/\/ Check that only InternalOOMEMark sets\n+    \/\/ JavaThread::_is_in_internal_oome_mark\n+    assert(_thread->is_in_internal_oome_mark(), \"must be\");\n+    _thread->set_is_in_internal_oome_mark(_outer);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  RetryableAllocationMark(JavaThread* thread, bool activate) : _iom(activate ? thread : nullptr) {}\n+  RetryableAllocationMark(JavaThread* thread) : _iom(thread) {}\n@@ -120,1 +120,1 @@\n-JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* current, Klass* klass, bool null_on_fail))\n+JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_or_null(JavaThread* current, Klass* klass))\n@@ -126,1 +126,1 @@\n-    RetryableAllocationMark ram(current, null_on_fail);\n+    RetryableAllocationMark ram(current);\n@@ -128,10 +128,5 @@\n-    oop obj;\n-    if (null_on_fail) {\n-      if (!h->is_initialized()) {\n-        \/\/ Cannot re-execute class initialization without side effects\n-        \/\/ so return without attempting the initialization\n-        return;\n-      }\n-    } else {\n-      \/\/ make sure klass is initialized\n-      h->initialize(CHECK);\n+    if (!h->is_initialized()) {\n+      \/\/ Cannot re-execute class initialization without side effects\n+      \/\/ so return without attempting the initialization\n+      current->set_vm_result(nullptr);\n+      return;\n@@ -140,1 +135,1 @@\n-    obj = h->allocate_instance(CHECK);\n+    oop obj = h->allocate_instance(CHECK);\n@@ -147,1 +142,1 @@\n-JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* current, Klass* array_klass, jint length, bool null_on_fail))\n+JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_or_null(JavaThread* current, Klass* array_klass, jint length))\n@@ -156,1 +151,1 @@\n-    RetryableAllocationMark ram(current, null_on_fail);\n+    RetryableAllocationMark ram(current);\n@@ -161,1 +156,1 @@\n-    RetryableAllocationMark ram(current, null_on_fail);\n+    RetryableAllocationMark ram(current);\n@@ -168,1 +163,0 @@\n-    \/\/ Alternate between deoptimizing and raising an error (which will also cause a deopt)\n@@ -170,7 +164,2 @@\n-      if (null_on_fail) {\n-        \/\/ Drop the allocation\n-        obj = nullptr;\n-      } else {\n-        ResourceMark rm(current);\n-        THROW(vmSymbols::java_lang_OutOfMemoryError());\n-      }\n+      \/\/ Drop the allocation\n+      obj = nullptr;\n@@ -186,1 +175,1 @@\n-JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* current, Klass* klass, int rank, jint* dims, bool null_on_fail))\n+JRT_ENTRY(void, JVMCIRuntime::new_multi_array_or_null(JavaThread* current, Klass* klass, int rank, jint* dims))\n@@ -190,1 +179,1 @@\n-  RetryableAllocationMark ram(current, null_on_fail);\n+  RetryableAllocationMark ram(current);\n@@ -195,2 +184,2 @@\n-JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* current, oopDesc* element_mirror, jint length, bool null_on_fail))\n-  RetryableAllocationMark ram(current, null_on_fail);\n+JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_or_null(JavaThread* current, oopDesc* element_mirror, jint length))\n+  RetryableAllocationMark ram(current);\n@@ -201,1 +190,1 @@\n-JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* current, oopDesc* type_mirror, bool null_on_fail))\n+JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_or_null(JavaThread* current, oopDesc* type_mirror))\n@@ -208,1 +197,1 @@\n-  RetryableAllocationMark ram(current, null_on_fail);\n+  RetryableAllocationMark ram(current);\n@@ -213,9 +202,5 @@\n-  if (null_on_fail) {\n-    if (!klass->is_initialized()) {\n-      \/\/ Cannot re-execute class initialization without side effects\n-      \/\/ so return without attempting the initialization\n-      return;\n-    }\n-  } else {\n-    \/\/ Make sure klass gets initialized\n-    klass->initialize(CHECK);\n+  if (!klass->is_initialized()) {\n+    \/\/ Cannot re-execute class initialization without side effects\n+    \/\/ so return without attempting the initialization\n+    current->set_vm_result(nullptr);\n+    return;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":25,"deletions":40,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -507,6 +507,0 @@\n-  static void new_instance_common(JavaThread* current, Klass* klass, bool null_on_fail);\n-  static void new_array_common(JavaThread* current, Klass* klass, jint length, bool null_on_fail);\n-  static void new_multi_array_common(JavaThread* current, Klass* klass, int rank, jint* dims, bool null_on_fail);\n-  static void dynamic_new_array_common(JavaThread* current, oopDesc* element_mirror, jint length, bool null_on_fail);\n-  static void dynamic_new_instance_common(JavaThread* current, oopDesc* type_mirror, bool null_on_fail);\n-\n@@ -515,20 +509,8 @@\n-  \/\/ When allocation fails, these stubs:\n-  \/\/ 1. Exercise -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError handling and also\n-  \/\/    post a JVMTI_EVENT_RESOURCE_EXHAUSTED event if the failure is an OutOfMemroyError\n-  \/\/ 2. Return null with a pending exception.\n-  \/\/ Compiled code must ensure these stubs are not called twice for the same allocation\n-  \/\/ site due to the non-repeatable side effects in the case of OOME.\n-  static void new_instance(JavaThread* current, Klass* klass) { new_instance_common(current, klass, false); }\n-  static void new_array(JavaThread* current, Klass* klass, jint length) { new_array_common(current, klass, length, false); }\n-  static void new_multi_array(JavaThread* current, Klass* klass, int rank, jint* dims) { new_multi_array_common(current, klass, rank, dims, false); }\n-  static void dynamic_new_array(JavaThread* current, oopDesc* element_mirror, jint length) { dynamic_new_array_common(current, element_mirror, length, false); }\n-  static void dynamic_new_instance(JavaThread* current, oopDesc* type_mirror) { dynamic_new_instance_common(current, type_mirror, false); }\n-\n-  \/\/ When allocation fails, these stubs return null and have no pending exception. Compiled code\n-  \/\/ can use these stubs if a failed allocation will be retried (e.g., by deoptimizing and\n-  \/\/ re-executing in the interpreter).\n-  static void new_instance_or_null(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, true); }\n-  static void new_array_or_null(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, true); }\n-  static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, true); }\n-  static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, true); }\n-  static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, true); }\n+  \/\/ When allocation fails, these stubs return null and have no pending OutOfMemoryError exception. \n+  \/\/ Compiled code can use these stubs if a failed allocation will be retried (e.g., by deoptimizing \n+  \/\/ and re-executing in the interpreter).\n+  static void new_instance_or_null(JavaThread* thread, Klass* klass);\n+  static void new_array_or_null(JavaThread* thread, Klass* klass, jint length);\n+  static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims);\n+  static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length);\n+  static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+  nonstatic_field(Klass,                       _bitmap,                                       uintx)                                 \\\n+  nonstatic_field(Klass,                       _hash_slot,                                    uint8_t)                               \\\n@@ -384,0 +386,1 @@\n+  static_field(StubRoutines,                _lookup_secondary_supers_table_slow_path_stub,    address)                               \\\n@@ -803,33 +806,27 @@\n-  declare_function(JVMCIRuntime::new_instance) \\\n-  declare_function(JVMCIRuntime::new_array) \\\n-  declare_function(JVMCIRuntime::new_multi_array) \\\n-  declare_function(JVMCIRuntime::dynamic_new_array) \\\n-  declare_function(JVMCIRuntime::dynamic_new_instance) \\\n-  \\\n-  declare_function(JVMCIRuntime::new_instance_or_null) \\\n-  declare_function(JVMCIRuntime::new_array_or_null) \\\n-  declare_function(JVMCIRuntime::new_multi_array_or_null) \\\n-  declare_function(JVMCIRuntime::dynamic_new_array_or_null) \\\n-  declare_function(JVMCIRuntime::dynamic_new_instance_or_null) \\\n-  \\\n-  declare_function(JVMCIRuntime::invoke_static_method_one_arg) \\\n-  \\\n-  declare_function(JVMCIRuntime::vm_message) \\\n-  declare_function(JVMCIRuntime::identity_hash_code) \\\n-  declare_function(JVMCIRuntime::exception_handler_for_pc) \\\n-  declare_function(JVMCIRuntime::monitorenter) \\\n-  declare_function(JVMCIRuntime::monitorexit) \\\n-  declare_function(JVMCIRuntime::object_notify) \\\n-  declare_function(JVMCIRuntime::object_notifyAll) \\\n-  declare_function(JVMCIRuntime::throw_and_post_jvmti_exception) \\\n-  declare_function(JVMCIRuntime::throw_klass_external_name_exception) \\\n-  declare_function(JVMCIRuntime::throw_class_cast_exception) \\\n-  declare_function(JVMCIRuntime::log_primitive) \\\n-  declare_function(JVMCIRuntime::log_object) \\\n-  declare_function(JVMCIRuntime::log_printf) \\\n-  declare_function(JVMCIRuntime::vm_error) \\\n-  declare_function(JVMCIRuntime::load_and_clear_exception) \\\n-  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_pre)) \\\n-  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_post)) \\\n-  declare_function(JVMCIRuntime::validate_object) \\\n-  \\\n+  declare_function(JVMCIRuntime::new_instance_or_null)                    \\\n+  declare_function(JVMCIRuntime::new_array_or_null)                       \\\n+  declare_function(JVMCIRuntime::new_multi_array_or_null)                 \\\n+  declare_function(JVMCIRuntime::dynamic_new_array_or_null)               \\\n+  declare_function(JVMCIRuntime::dynamic_new_instance_or_null)            \\\n+                                                                          \\\n+  declare_function(JVMCIRuntime::invoke_static_method_one_arg)            \\\n+                                                                          \\\n+  declare_function(JVMCIRuntime::vm_message)                              \\\n+  declare_function(JVMCIRuntime::identity_hash_code)                      \\\n+  declare_function(JVMCIRuntime::exception_handler_for_pc)                \\\n+  declare_function(JVMCIRuntime::monitorenter)                            \\\n+  declare_function(JVMCIRuntime::monitorexit)                             \\\n+  declare_function(JVMCIRuntime::object_notify)                           \\\n+  declare_function(JVMCIRuntime::object_notifyAll)                        \\\n+  declare_function(JVMCIRuntime::throw_and_post_jvmti_exception)          \\\n+  declare_function(JVMCIRuntime::throw_klass_external_name_exception)     \\\n+  declare_function(JVMCIRuntime::throw_class_cast_exception)              \\\n+  declare_function(JVMCIRuntime::log_primitive)                           \\\n+  declare_function(JVMCIRuntime::log_object)                              \\\n+  declare_function(JVMCIRuntime::log_printf)                              \\\n+  declare_function(JVMCIRuntime::vm_error)                                \\\n+  declare_function(JVMCIRuntime::load_and_clear_exception)                \\\n+  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_pre))            \\\n+  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_post))           \\\n+  declare_function(JVMCIRuntime::validate_object)                         \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":30,"deletions":33,"binary":false,"changes":63,"status":"modified"}]}