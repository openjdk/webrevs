{"files":[{"patch":"@@ -1387,4 +1387,2 @@\n-        return AccessFlag.maskToAccessFlags((location == AccessFlag.Location.CLASS) ?\n-                                            getClassAccessFlagsRaw() :\n-                                            getModifiers(),\n-                                            location);\n+        return getReflectionFactory().parseAccessFlags((location == AccessFlag.Location.CLASS) ?\n+                        getClassAccessFlagsRaw() : getModifiers(), location, this);\n@@ -4128,1 +4126,1 @@\n-    private int getClassFileVersion() {\n+    int getClassFileVersion() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2020,0 +2020,3 @@\n+            public int classFileVersion(Class<?> clazz) {\n+                return clazz.getClassFileVersion();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-     * appropriate for the location in question}\n+     * appropriate for the location in the current class file format version}\n@@ -372,1 +372,2 @@\n-     * positions not support for the location in question\n+     * positions not defined for the location in the current class file format\n+     * @throws NullPointerException if {@code location} is {@code null}\n@@ -376,3 +377,1 @@\n-        int flagsMask = location.flagsMask();\n-        int parsingMask = location == Location.METHOD ? flagsMask | ACC_STRICT : flagsMask; \/\/ flagMask lacks strictfp\n-        int unmatchedMask = mask & (~parsingMask);\n+        int unmatchedMask = mask & (~location.flagsMask());\n@@ -387,0 +386,24 @@\n+    \/**\n+     * {@return an unmodifiable set of access flags for the given mask value\n+     * appropriate for the location for the given {@code cffv}}\n+     *\n+     * @param mask bit mask of access flags\n+     * @param location context to interpret mask value\n+     * @param cffv the class file format to interpret mask value\n+     * @throws IllegalArgumentException if the mask contains bit\n+     * positions not defined for the location for {@code cffv}\n+     * @throws NullPointerException if {@code location} or {@code cffv} is {@code null}\n+     * @since 25\n+     *\/\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location, ClassFileFormatVersion cffv) {\n+        var definition = findDefinition(location);\n+        int unmatchedMask = mask & (~location.flagsMask(cffv)); \/\/ implicit null check\n+        if (unmatchedMask != 0) {\n+            throw new IllegalArgumentException(\"Unmatched bit position 0x\" +\n+                    Integer.toHexString(unmatchedMask) +\n+                    \" for location \" + location +\n+                    \" for class file format \" + cffv);\n+        }\n+        return new AccessFlagSet(definition, mask);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,2 +224,3 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(),\n-                                            AccessFlag.Location.METHOD);\n+        return reflectionFactory.parseAccessFlags(getModifiers(),\n+                                                  AccessFlag.Location.METHOD,\n+                                                  getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,1 +221,1 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD);\n+        return reflectionFactory.parseAccessFlags(getModifiers(), AccessFlag.Location.FIELD, getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,2 +175,2 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(),\n-                                            AccessFlag.Location.METHOD_PARAMETER);\n+        return AccessibleObject.reflectionFactory.parseAccessFlags(getModifiers(),\n+                AccessFlag.Location.METHOD_PARAMETER, getDeclaringExecutable().getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Parameter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,0 +122,6 @@\n+    \/**\n+     * Returns the big-endian packed minor-major version of the class file\n+     * of this class.\n+     *\/\n+    int classFileVersion(Class<?> clazz);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -37,7 +38,1 @@\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Executable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Proxy;\n+import java.lang.reflect.*;\n@@ -521,0 +516,25 @@\n+    public final Set<AccessFlag> parseAccessFlags(int mask, AccessFlag.Location location, Class<?> classFile) {\n+        var cffv = classFileFormatVersion(classFile);\n+        return cffv == null ?\n+                AccessFlag.maskToAccessFlags(mask, location) :\n+                AccessFlag.maskToAccessFlags(mask, location, cffv);\n+    }\n+\n+    private final ClassFileFormatVersion classFileFormatVersion(Class<?> cl) {\n+        int raw = SharedSecrets.getJavaLangAccess().classFileVersion(cl);\n+\n+        int major = raw & 0xFFFF;\n+        int minor = raw >>> Character.SIZE;\n+\n+        assert VM.isSupportedClassFileVersion(major, minor) : major + \".\" + minor;\n+\n+        if (major >= ClassFile.JAVA_12_VERSION) {\n+            if (minor == 0)\n+                return ClassFileFormatVersion.fromMajor(raw);\n+            return null; \/\/ preview or old preview, fallback to default handling\n+        } else if (major == ClassFile.JAVA_1_VERSION) {\n+            return minor < 3 ? ClassFileFormatVersion.RELEASE_0 : ClassFileFormatVersion.RELEASE_1;\n+        }\n+        return ClassFileFormatVersion.fromMajor(major);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -66,2 +67,2 @@\n-    public void write(List<Attribute<?>> attrs) {\n-        write(attrs, null);\n+    public void write(List<Attribute<?>> attrs, ClassFileFormatVersion cffv) {\n+        write(attrs, null, cffv);\n@@ -70,1 +71,1 @@\n-    public void write(List<Attribute<?>> attrs, CodeAttribute lr) {\n+    public void write(List<Attribute<?>> attrs, CodeAttribute lr, ClassFileFormatVersion cffv) {\n@@ -73,1 +74,1 @@\n-                write(attr, lr);\n+                write(attr, lr, cffv);\n@@ -80,1 +81,1 @@\n-    public void write(Attribute<?> a, CodeAttribute lr) {\n+    public void write(Attribute<?> a, CodeAttribute lr, ClassFileFormatVersion cffv) {\n@@ -212,1 +213,1 @@\n-                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n+                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS, cffv)) {\n@@ -497,1 +498,1 @@\n-                        write(componentInfo.attributes());\n+                        write(componentInfo.attributes(), cffv);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -47,19 +48,0 @@\n-    private static final Map<AccessFlag.Location, Integer> LOCATION_MASKS;\n-\n-    static {\n-        var map = new EnumMap<AccessFlag.Location, Integer>(AccessFlag.Location.class);\n-        for (var loc : AccessFlag.Location.values()) {\n-            map.put(loc, 0);\n-        }\n-\n-        for (var flag : AccessFlag.values()) {\n-            for (var loc : flag.locations()) {\n-                map.compute(loc, (_, v) -> v | flag.mask());\n-            }\n-        }\n-\n-        \/\/ Peculiarities from AccessFlag.maskToAccessFlag\n-        map.compute(AccessFlag.Location.METHOD, (_, v) -> v | Modifier.STRICT);\n-\n-        LOCATION_MASKS = map;\n-    }\n@@ -75,2 +57,2 @@\n-    protected Set<AccessFlag> flagsReportUnknown(AccessFlags flags) {\n-        return maskToAccessFlagsReportUnknown(flags.flagsMask(), flags.location());\n+    protected Set<AccessFlag> flagsReportUnknown(AccessFlags flags, ClassFileFormatVersion cffv) {\n+        return maskToAccessFlagsReportUnknown(flags.flagsMask(), flags.location(), cffv);\n@@ -79,7 +61,8 @@\n-    protected Set<AccessFlag> maskToAccessFlagsReportUnknown(int mask, AccessFlag.Location location) {\n-        try {\n-            return AccessFlag.maskToAccessFlags(mask, location);\n-        } catch (IllegalArgumentException ex) {\n-            mask &= LOCATION_MASKS.get(location);\n-            report(\"Access Flags: \" + ex.getMessage());\n-            return AccessFlag.maskToAccessFlags(mask, location);\n+    protected Set<AccessFlag> maskToAccessFlagsReportUnknown(int mask, AccessFlag.Location location, ClassFileFormatVersion cffv) {\n+        if (cffv == null)\n+            cffv = ClassFileFormatVersion.latest();\n+        int valid = location.flagsMask(cffv);\n+        int unknown = mask & ~(valid);\n+        if (unknown != 0) {\n+            report(\"Access Flags: Unmatched bits \" + Integer.toHexString(unknown));\n+            mask &= valid;\n@@ -87,0 +70,1 @@\n+        return AccessFlag.maskToAccessFlags(mask, location, cffv);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/BasicWriter.java","additions":13,"deletions":29,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -115,0 +116,10 @@\n+    protected ClassFileFormatVersion cffv() {\n+        var major = classModel.majorVersion();\n+        if (major < JAVA_1_VERSION || major > ClassFile.latestMajorVersion())\n+            return null;\n+        if (major >= JAVA_12_VERSION && classModel.minorVersion() != 0) {\n+            return null;\n+        }\n+        return ClassFileFormatVersion.fromMajor(major);\n+    }\n+\n@@ -252,1 +263,1 @@\n-            attrWriter.write(classModel.attributes());\n+            attrWriter.write(classModel.attributes(), cffv());\n@@ -422,1 +433,1 @@\n-        writeModifiers(flagsReportUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsReportUnknown(flags, cffv()).stream().filter(fl -> fl.sourceModifier())\n@@ -451,1 +462,1 @@\n-                    flagsReportUnknown(flags).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    flagsReportUnknown(flags, cffv()).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n@@ -455,1 +466,1 @@\n-            attrWriter.write(f.attributes());\n+            attrWriter.write(f.attributes(), cffv());\n@@ -483,1 +494,1 @@\n-        for (var f : flagsReportUnknown(m.flags()))\n+        for (var f : flagsReportUnknown(m.flags(), cffv()))\n@@ -566,1 +577,1 @@\n-            for (var f : flagsReportUnknown(m.flags())) {\n+            for (var f : flagsReportUnknown(m.flags(), cffv())) {\n@@ -576,1 +587,1 @@\n-            attrWriter.write(m.attributes());\n+            attrWriter.write(m.attributes(), cffv());\n@@ -789,1 +800,1 @@\n-        var flagSet = flagsReportUnknown(flags);\n+        var flagSet = flagsReportUnknown(flags, cffv());\n@@ -808,1 +819,1 @@\n-        return getFlags(flags.flagsMask(), flagsReportUnknown(flags));\n+        return getFlags(flags.flagsMask(), flagsReportUnknown(flags, cffv()));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,1 +280,1 @@\n-        attrWriter.write(attr.attributes(), attr);\n+        attrWriter.write(attr.attributes(), attr, classWriter.cffv());\n@@ -285,1 +285,1 @@\n-            .ifPresent(a -> attrWriter.write(a, attr));\n+            .ifPresent(a -> attrWriter.write(a, attr, classWriter.cffv()));\n@@ -287,1 +287,1 @@\n-            .ifPresent(a -> attrWriter.write(a, attr));\n+            .ifPresent(a -> attrWriter.write(a, attr, classWriter.cffv()));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8266670 8293626\n+ * @bug 8266670 8293626 8297271\n@@ -28,0 +28,1 @@\n+ * @run junit BasicAccessFlagTest\n@@ -30,0 +31,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -31,0 +33,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -39,0 +42,5 @@\n+import org.junit.Test;\n+import org.junit.jupiter.api.Assertions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -40,7 +48,0 @@\n-    public static void main(String... args) throws Exception {\n-        testSourceModifiers();\n-        testMaskOrdering();\n-        testDisjoint();\n-        testMaskToAccessFlagsPositive();\n-        testLocationsNullHandling();\n-    }\n@@ -52,1 +53,2 @@\n-    private static void testSourceModifiers() throws Exception {\n+    @Test\n+    public void testSourceModifiers() throws Exception {\n@@ -59,4 +61,1 @@\n-                if (accessFlag.mask() != f.getInt(null) ) {\n-                    throw new RuntimeException(\"Unexpected mask for \" +\n-                                               accessFlag);\n-                }\n+                assertEquals(f.getInt(null), accessFlag.mask(), accessFlag + \" mask\");\n@@ -70,1 +69,2 @@\n-    private static void testMaskOrdering() {\n+    @Test\n+    public void testMaskOrdering() {\n@@ -75,5 +75,3 @@\n-            if (left.mask() > right.mask()) {\n-                throw new RuntimeException(left\n-                                           + \"has a greater mask than \"\n-                                           + right);\n-            }\n+            assertTrue(left.mask() <= right.mask(), () -> left\n+                    + \"has a greater mask than \"\n+                    + right);\n@@ -85,1 +83,2 @@\n-    private static void testDisjoint() {\n+    @Test\n+    public void testDisjoint() {\n@@ -93,1 +92,1 @@\n-            if (flags == null ) {\n+            if (flags == null) {\n@@ -138,1 +137,2 @@\n-    private static void testMaskToAccessFlagsPositive() {\n+    @Test\n+    public void testMaskToAccessFlagsPositive() {\n@@ -149,0 +149,10 @@\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                for (var location : accessFlag.locations(cffv)) {\n+                    Set<AccessFlag> computedSet =\n+                            AccessFlag.maskToAccessFlags(accessFlag.mask(), location, cffv);\n+                    if (!expectedSet.equals(computedSet)) {\n+                        throw new RuntimeException(\"Bad set computation on \" +\n+                                accessFlag + \", \" + location);\n+                    }\n+                }\n+            }\n@@ -150,0 +160,1 @@\n+        assertEquals(Set.of(AccessFlag.STRICT), AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD, ClassFileFormatVersion.RELEASE_8));\n@@ -152,8 +163,19 @@\n-    private static void testLocationsNullHandling() {\n-        for (var flag : AccessFlag.values() ) {\n-            try {\n-                flag.locations(null);\n-                throw new RuntimeException(\"Did not get NPE on \" + flag + \".location(null)\");\n-            } catch (NullPointerException npe ) {\n-                ; \/\/ Expected\n-            }\n+    @Test\n+    public void testMaskToAccessFlagsNegative() {\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD, ClassFileFormatVersion.RELEASE_17));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD, ClassFileFormatVersion.RELEASE_1));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.PRIVATE, AccessFlag.Location.CLASS));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_MODULE, AccessFlag.Location.CLASS, ClassFileFormatVersion.RELEASE_8));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_ANNOTATION, AccessFlag.Location.CLASS, ClassFileFormatVersion.RELEASE_4));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_ENUM, AccessFlag.Location.FIELD, ClassFileFormatVersion.RELEASE_4));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_SYNTHETIC, AccessFlag.Location.INNER_CLASS, ClassFileFormatVersion.RELEASE_4));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_PUBLIC, AccessFlag.Location.INNER_CLASS, ClassFileFormatVersion.RELEASE_0));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_MANDATED, AccessFlag.Location.METHOD_PARAMETER, ClassFileFormatVersion.RELEASE_7));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_MANDATED, AccessFlag.Location.MODULE, ClassFileFormatVersion.RELEASE_7));\n+    }\n+\n+    @Test\n+    public void testLocationsNullHandling() {\n+        for (var flag : AccessFlag.values()) {\n+            assertThrows(NullPointerException.class, () -> flag.locations(null));\n@@ -163,12 +185,1 @@\n-            try {\n-                location.flags(null);\n-                throw new RuntimeException(\"Did not get NPE on \" + location + \".flags(null)\");\n-            } catch (NullPointerException npe ) {\n-                ; \/\/ Expected\n-            }\n-            try {\n-                location.flagsMask(null);\n-                throw new RuntimeException(\"Did not get NPE on \" + location + \".flagsMask(null)\");\n-            } catch (NullPointerException npe ) {\n-                ; \/\/ Expected\n-            }\n+            assertThrows(NullPointerException.class, () -> location.flags(null));\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":53,"deletions":42,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,2 @@\n- * @test 8333748\n+ * @test\n+ * @bug 8297271 8333748\n@@ -94,1 +95,1 @@\n-                        .map(ic -> InnerClassInfo.of(ic.innerClass(), ic.outerClass(), ic.innerName(), ic.flagsMask() | 0x0020))\n+                        .map(ic -> InnerClassInfo.of(ic.innerClass(), ic.outerClass(), ic.innerName(), ic.flagsMask() | ACC_SUPER))\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}