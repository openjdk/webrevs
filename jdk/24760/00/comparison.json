{"files":[{"patch":"@@ -1387,4 +1387,2 @@\n-        return AccessFlag.maskToAccessFlags((location == AccessFlag.Location.CLASS) ?\n-                                            getClassAccessFlagsRaw() :\n-                                            getModifiers(),\n-                                            location);\n+        return getReflectionFactory().parseAccessFlags((location == AccessFlag.Location.CLASS) ?\n+                        getClassAccessFlagsRaw() : getModifiers(), location, this);\n@@ -4128,1 +4126,1 @@\n-    private int getClassFileVersion() {\n+    int getClassFileVersion() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2007,0 +2007,3 @@\n+            public int classFileVersion(Class<?> clazz) {\n+                return clazz.getClassFileVersion();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-     * positions not support for the location in question\n+     * positions not defined for the location\n@@ -371,1 +371,1 @@\n-        int unmatchedMask = mask & (~location.parsingMask()); \/\/ flagMask rejects strictfp\n+        int unmatchedMask = mask & (~location.flagsMask());\n@@ -380,0 +380,23 @@\n+    \/**\n+     * {@return an unmodifiable set of access flags for the given mask value\n+     * appropriate for the location for the class file format}\n+     *\n+     * @param mask bit mask of access flags\n+     * @param location context to interpret mask value\n+     * @param cffv the class file format to interpret mask value\n+     * @throws IllegalArgumentException if the mask contains bit\n+     * positions not defined for the location for the class file format\n+     * @throws NullPointerException if {@code location} or {@code cffv} is {@code null}\n+     *\/\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location, ClassFileFormatVersion cffv) {\n+        var definition = findDefinition(location);\n+        int unmatchedMask = mask & (~location.flagsMask(cffv)); \/\/ implicit null check\n+        if (unmatchedMask != 0) {\n+            throw new IllegalArgumentException(\"Unmatched bit position 0x\" +\n+                    Integer.toHexString(unmatchedMask) +\n+                    \" for location \" + location +\n+                    \" for class file format \" + cffv);\n+        }\n+        return new AccessFlagSet(definition, mask);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,2 +224,3 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(),\n-                                            AccessFlag.Location.METHOD);\n+        return reflectionFactory.parseAccessFlags(getModifiers(),\n+                                                  AccessFlag.Location.METHOD,\n+                                                  getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,1 +221,1 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD);\n+        return reflectionFactory.parseAccessFlags(getModifiers(), AccessFlag.Location.FIELD, getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,2 +175,2 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(),\n-                                            AccessFlag.Location.METHOD_PARAMETER);\n+        return AccessibleObject.reflectionFactory.parseAccessFlags(getModifiers(),\n+                AccessFlag.Location.METHOD_PARAMETER, getDeclaringExecutable().getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Parameter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,0 +122,6 @@\n+    \/**\n+     * Returns the big-endian packed minor-major version of the class file\n+     * of this class.\n+     *\/\n+    int classFileVersion(Class<?> clazz);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -37,7 +38,1 @@\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Executable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Proxy;\n+import java.lang.reflect.*;\n@@ -521,0 +516,25 @@\n+    public final Set<AccessFlag> parseAccessFlags(int mask, AccessFlag.Location location, Class<?> classFile) {\n+        var cffv = classFileFormatVersion(classFile);\n+        return cffv == null ?\n+                AccessFlag.maskToAccessFlags(mask, location) :\n+                AccessFlag.maskToAccessFlags(mask, location, cffv);\n+    }\n+\n+    private final ClassFileFormatVersion classFileFormatVersion(Class<?> cl) {\n+        int raw = SharedSecrets.getJavaLangAccess().classFileVersion(cl);\n+\n+        int major = raw & 0xFFFF;\n+        int minor = raw >>> Character.SIZE;\n+\n+        assert VM.isSupportedClassFileVersion(major, minor) : major + \".\" + minor;\n+\n+        if (major >= ClassFile.JAVA_12_VERSION) {\n+            if (minor == 0)\n+                return ClassFileFormatVersion.fromMajor(raw);\n+            return null; \/\/ preview or old preview, fallback to default handling\n+        } else if (major == ClassFile.JAVA_1_VERSION) {\n+            return minor < 3 ? ClassFileFormatVersion.RELEASE_0 : ClassFileFormatVersion.RELEASE_1;\n+        }\n+        return ClassFileFormatVersion.fromMajor(major);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @run junit BasicAccessFlagTest\n@@ -30,0 +31,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -31,0 +33,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -39,0 +42,5 @@\n+import org.junit.Test;\n+import org.junit.jupiter.api.Assertions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -40,7 +48,0 @@\n-    public static void main(String... args) throws Exception {\n-        testSourceModifiers();\n-        testMaskOrdering();\n-        testDisjoint();\n-        testMaskToAccessFlagsPositive();\n-        testLocationsNullHandling();\n-    }\n@@ -52,1 +53,2 @@\n-    private static void testSourceModifiers() throws Exception {\n+    @Test\n+    public void testSourceModifiers() throws Exception {\n@@ -59,4 +61,1 @@\n-                if (accessFlag.mask() != f.getInt(null) ) {\n-                    throw new RuntimeException(\"Unexpected mask for \" +\n-                                               accessFlag);\n-                }\n+                assertEquals(f.getInt(null), accessFlag.mask(), accessFlag + \" mask\");\n@@ -70,1 +69,2 @@\n-    private static void testMaskOrdering() {\n+    @Test\n+    public void testMaskOrdering() {\n@@ -75,5 +75,3 @@\n-            if (left.mask() > right.mask()) {\n-                throw new RuntimeException(left\n-                                           + \"has a greater mask than \"\n-                                           + right);\n-            }\n+            assertTrue(left.mask() <= right.mask(), () -> left\n+                    + \"has a greater mask than \"\n+                    + right);\n@@ -85,1 +83,2 @@\n-    private static void testDisjoint() {\n+    @Test\n+    public void testDisjoint() {\n@@ -93,1 +92,1 @@\n-            if (flags == null ) {\n+            if (flags == null) {\n@@ -138,1 +137,2 @@\n-    private static void testMaskToAccessFlagsPositive() {\n+    @Test\n+    public void testMaskToAccessFlagsPositive() {\n@@ -149,0 +149,10 @@\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                for (var location : accessFlag.locations(cffv)) {\n+                    Set<AccessFlag> computedSet =\n+                            AccessFlag.maskToAccessFlags(accessFlag.mask(), location, cffv);\n+                    if (!expectedSet.equals(computedSet)) {\n+                        throw new RuntimeException(\"Bad set computation on \" +\n+                                accessFlag + \", \" + location);\n+                    }\n+                }\n+            }\n@@ -150,0 +160,1 @@\n+        assertEquals(Set.of(AccessFlag.STRICT), AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD, ClassFileFormatVersion.RELEASE_8));\n@@ -152,8 +163,19 @@\n-    private static void testLocationsNullHandling() {\n-        for (var flag : AccessFlag.values() ) {\n-            try {\n-                flag.locations(null);\n-                throw new RuntimeException(\"Did not get NPE on \" + flag + \".location(null)\");\n-            } catch (NullPointerException npe ) {\n-                ; \/\/ Expected\n-            }\n+    @Test\n+    public void testMaskToAccessFlagsNegative() {\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD, ClassFileFormatVersion.RELEASE_17));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD, ClassFileFormatVersion.RELEASE_1));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.PRIVATE, AccessFlag.Location.CLASS));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_MODULE, AccessFlag.Location.CLASS, ClassFileFormatVersion.RELEASE_8));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_ANNOTATION, AccessFlag.Location.CLASS, ClassFileFormatVersion.RELEASE_4));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_ENUM, AccessFlag.Location.FIELD, ClassFileFormatVersion.RELEASE_4));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_SYNTHETIC, AccessFlag.Location.INNER_CLASS, ClassFileFormatVersion.RELEASE_4));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_PUBLIC, AccessFlag.Location.INNER_CLASS, ClassFileFormatVersion.RELEASE_0));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_MANDATED, AccessFlag.Location.METHOD_PARAMETER, ClassFileFormatVersion.RELEASE_7));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_MANDATED, AccessFlag.Location.MODULE, ClassFileFormatVersion.RELEASE_7));\n+    }\n+\n+    @Test\n+    public void testLocationsNullHandling() {\n+        for (var flag : AccessFlag.values()) {\n+            assertThrows(NullPointerException.class, () -> flag.locations(null));\n@@ -163,12 +185,1 @@\n-            try {\n-                location.flags(null);\n-                throw new RuntimeException(\"Did not get NPE on \" + location + \".flags(null)\");\n-            } catch (NullPointerException npe ) {\n-                ; \/\/ Expected\n-            }\n-            try {\n-                location.flagsMask(null);\n-                throw new RuntimeException(\"Did not get NPE on \" + location + \".flagsMask(null)\");\n-            } catch (NullPointerException npe ) {\n-                ; \/\/ Expected\n-            }\n+            assertThrows(NullPointerException.class, () -> location.flags(null));\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":52,"deletions":41,"binary":false,"changes":93,"status":"modified"}]}