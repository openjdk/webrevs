{"files":[{"patch":"@@ -1907,3 +1907,1 @@\n-\/\/ Obtain stack trace for platform or mounted virtual thread.\n-\/\/ If jthread is a virtual thread and it has been unmounted (or remounted to different carrier) the method returns null.\n-\/\/ The caller (java.lang.VirtualThread) handles returned nulls via retry.\n+\/\/ Obtain stack trace for a platform or virtual thread.\n@@ -1916,1 +1914,3 @@\n-  if (!has_java_thread) {\n+  assert((has_java_thread && thread_oop != nullptr) || !has_java_thread, \"Missing Thread oop\");\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+  if (!has_java_thread && !is_virtual) {\n@@ -1924,1 +1924,0 @@\n-    bool _retry_handshake;\n@@ -1929,1 +1928,1 @@\n-        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _thread_h(thread_h), _depth(0), _retry_handshake(false),\n+        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _thread_h(thread_h), _depth(0),\n@@ -1937,8 +1936,0 @@\n-    bool read_reset_retry() {\n-      bool ret = _retry_handshake;\n-      \/\/ If we re-execute the handshake this method need to return false\n-      \/\/ when the handshake cannot be performed. (E.g. thread terminating)\n-      _retry_handshake = false;\n-      return ret;\n-    }\n-\n@@ -1946,2 +1937,3 @@\n-      if (!Thread::current()->is_Java_thread()) {\n-        _retry_handshake = true;\n+      JavaThread* java_thread = th != nullptr ? JavaThread::cast(th) : nullptr;\n+      if (java_thread != nullptr && !java_thread->has_last_Java_frame()) {\n+        \/\/ stack trace is empty\n@@ -1951,17 +1943,2 @@\n-      JavaThread* java_thread = JavaThread::cast(th);\n-\n-      if (!java_thread->has_last_Java_frame()) {\n-        return;\n-      }\n-\n-      bool carrier = false;\n-      if (java_lang_VirtualThread::is_instance(_thread_h())) {\n-        \/\/ Ensure _thread_h is still mounted to java_thread.\n-        const ContinuationEntry* ce = java_thread->vthread_continuation();\n-        if (ce == nullptr || ce->cont_oop(java_thread) != java_lang_VirtualThread::continuation(_thread_h())) {\n-          \/\/ Target thread has been unmounted.\n-          return;\n-        }\n-      } else {\n-        carrier = (java_thread->vthread_continuation() != nullptr);\n-      }\n+      bool is_virtual = java_lang_VirtualThread::is_instance(_thread_h());\n+      bool vthread_carrier = !is_virtual && (java_thread != nullptr) && (java_thread->vthread_continuation() != nullptr);\n@@ -1978,1 +1955,4 @@\n-      for (vframeStream vfst(java_thread, false, false, carrier); \/\/ we don't process frames as we don't care about oops\n+      vframeStream vfst(java_thread != nullptr\n+        ? vframeStream(java_thread, false, false, vthread_carrier)  \/\/ we don't process frames as we don't care about oops\n+        : vframeStream(java_lang_VirtualThread::continuation(_thread_h())));\n+      for (;\n@@ -2000,3 +1980,5 @@\n-  do {\n-   Handshake::execute(&gsthc, &tlh, java_thread);\n-  } while (gsthc.read_reset_retry());\n+  if (is_virtual) {\n+    Handshake::execute(&gsthc, thread_oop);\n+  } else {\n+    Handshake::execute(&gsthc, &tlh, java_thread);\n+  }\n@@ -2199,1 +2181,1 @@\n-  switch (state & ~SUSPENDED) {\n+  switch (state) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":20,"deletions":38,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -595,3 +595,0 @@\n-\n-    \/\/ additional state bits\n-    SUSPENDED    = 1 << 8,   \/\/ suspended when unmounted\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -751,2 +751,0 @@\n-  template(java_lang_StackTraceElement_of_name,    \"of\")                                                          \\\n-  template(java_lang_StackTraceElement_of_signature, \"([Ljava\/lang\/StackTraceElement;)[Ljava\/lang\/StackTraceElement;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2919,1 +2919,0 @@\n-#if INCLUDE_JVMTI\n@@ -2922,3 +2921,0 @@\n-#else\n-  THROW_NULL(vmSymbols::java_lang_UnsupportedOperationException());\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-#include \"runtime\/javaCalls.hpp\"\n@@ -1125,2 +1124,0 @@\n-#if INCLUDE_JVMTI\n-\n@@ -1479,0 +1476,5 @@\n+  \/\/ thread not alive\n+  if (cl._thread_status == JavaThreadStatus::NEW || cl._thread_status == JavaThreadStatus::TERMINATED) {\n+    return nullptr;\n+  }\n+\n@@ -1508,11 +1510,0 @@\n-  \/\/ call static StackTraceElement[] StackTraceElement.of(StackTraceElement[] stackTrace)\n-  \/\/ to properly initialize STEs.\n-  JavaValue result(T_OBJECT);\n-  JavaCalls::call_static(&result,\n-    ste_klass,\n-    vmSymbols::java_lang_StackTraceElement_of_name(),\n-    vmSymbols::java_lang_StackTraceElement_of_signature(),\n-    trace,\n-    CHECK_NULL);\n-  \/\/ the method return the same trace array\n-\n@@ -1537,2 +1528,0 @@\n-\n-#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -638,1 +638,1 @@\n-  JVMTI_ONLY(static oop get_thread_snapshot(jobject jthread, TRAPS);)\n+  static oop get_thread_snapshot(jobject jthread, TRAPS);\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -564,1 +564,1 @@\n-        return of(stackTrace);\n+        return finishInit(stackTrace);\n@@ -578,1 +578,1 @@\n-    static StackTraceElement[] of(StackTraceElement[] stackTrace) {\n+    static StackTraceElement[] finishInit(StackTraceElement[] stackTrace) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackTraceElement.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -2342,0 +2341,5 @@\n+\n+            @Override\n+            public void finishInit(StackTraceElement[] stackTrace) {\n+                StackTraceElement.finishInit(stackTrace);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2211,1 +2211,1 @@\n-        if (this != Thread.currentThread()) {\n+        if (Thread.currentThread() != this) {\n@@ -2217,2 +2217,5 @@\n-            StackTraceElement[] stackTrace = asyncGetStackTrace();\n-            return (stackTrace != null) ? stackTrace : EMPTY_STACK_TRACE;\n+            Object trace = getStackTrace0();\n+            if (trace instanceof StackTraceElement[] stackTrace) {\n+                return StackTraceElement.finishInit(stackTrace);\n+            }\n+            return EMPTY_STACK_TRACE;\n@@ -2224,20 +2227,0 @@\n-    \/**\n-     * Returns an array of stack trace elements representing the stack dump of\n-     * this thread. Returns null if the stack trace cannot be obtained. In\n-     * the default implementation, null is returned if the thread is a virtual\n-     * thread that is not mounted or the thread is a platform thread that has\n-     * terminated.\n-     *\/\n-    StackTraceElement[] asyncGetStackTrace() {\n-        Object stackTrace = getStackTrace0();\n-        if (stackTrace == null) {\n-            return null;\n-        }\n-        StackTraceElement[] stes = (StackTraceElement[]) stackTrace;\n-        if (stes.length == 0) {\n-            return null;\n-        } else {\n-            return StackTraceElement.of(stes);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -157,3 +157,0 @@\n-    \/\/ can be suspended from scheduling when unmounted\n-    private static final int SUSPENDED = 1 << 8;\n-\n@@ -498,1 +495,1 @@\n-        startTransition(\/*is_mount*\/true);\n+        startTransition(\/*mount*\/true);\n@@ -543,1 +540,1 @@\n-        endTransition(\/*is_mount*\/false);\n+        endTransition(\/*mount*\/false);\n@@ -552,1 +549,1 @@\n-        startTransition(\/*is_mount*\/false);\n+        startTransition(\/*mount*\/false);\n@@ -556,1 +553,1 @@\n-            endTransition(\/*is_mount*\/true);\n+            endTransition(\/*mount*\/true);\n@@ -934,14 +931,5 @@\n-        for (;;) {\n-            boolean unblocked = false;\n-            synchronized (timedWaitLock()) {\n-                if (seqNo != timedWaitSeqNo) {\n-                    \/\/ this timeout task is for a past timed-wait\n-                    return;\n-                }\n-                int s = state();\n-                if (s == TIMED_WAIT) {\n-                    unblocked = compareAndSetState(TIMED_WAIT, UNBLOCKED);\n-                } else if (s != (TIMED_WAIT | SUSPENDED)) {\n-                    \/\/ notified or interrupted, no longer waiting\n-                    return;\n-                }\n+\n+        synchronized (timedWaitLock()) {\n+            if (seqNo != timedWaitSeqNo) {\n+                \/\/ this timeout task is for a past timed-wait\n+                return;\n@@ -949,2 +937,2 @@\n-            if (unblocked) {\n-                lazySubmitRunContinuation();\n+            if (!compareAndSetState(TIMED_WAIT, UNBLOCKED)) {\n+                \/\/ already notified (or interrupted)\n@@ -953,2 +941,0 @@\n-            \/\/ need to retry when thread is suspended in time-wait\n-            Thread.yield();\n@@ -956,0 +942,2 @@\n+\n+        lazySubmitRunContinuation();\n@@ -1123,2 +1111,1 @@\n-        int s = state();\n-        switch (s & ~SUSPENDED) {\n+        switch (state()) {\n@@ -1192,79 +1179,0 @@\n-    @Override\n-    StackTraceElement[] asyncGetStackTrace() {\n-        StackTraceElement[] stackTrace;\n-        do {\n-            stackTrace = (carrierThread != null)\n-                    ? super.asyncGetStackTrace()  \/\/ mounted\n-                    : tryGetStackTrace();         \/\/ unmounted\n-            if (stackTrace == null) {\n-                Thread.yield();\n-            }\n-        } while (stackTrace == null);\n-        return stackTrace;\n-    }\n-\n-    \/**\n-     * Returns the stack trace for this virtual thread if it is unmounted.\n-     * Returns null if the thread is mounted or in transition.\n-     *\/\n-    private StackTraceElement[] tryGetStackTrace() {\n-        int initialState = state() & ~SUSPENDED;\n-        switch (initialState) {\n-            case NEW, STARTED, TERMINATED -> {\n-                return new StackTraceElement[0];  \/\/ unmounted, empty stack\n-            }\n-            case RUNNING, PINNED, TIMED_PINNED -> {\n-                return null;   \/\/ mounted\n-            }\n-            case PARKED, TIMED_PARKED, BLOCKED, WAIT, TIMED_WAIT -> {\n-                \/\/ unmounted, not runnable\n-            }\n-            case UNPARKED, UNBLOCKED, YIELDED -> {\n-                \/\/ unmounted, runnable\n-            }\n-            case PARKING, TIMED_PARKING, BLOCKING, YIELDING, WAITING, TIMED_WAITING -> {\n-                return null;  \/\/ in transition\n-            }\n-            default -> throw new InternalError(\"\" + initialState);\n-        }\n-\n-        \/\/ thread is unmounted, prevent it from continuing\n-        int suspendedState = initialState | SUSPENDED;\n-        if (!compareAndSetState(initialState, suspendedState)) {\n-            return null;\n-        }\n-\n-        \/\/ get stack trace and restore state\n-        StackTraceElement[] stack;\n-        try {\n-            stack = cont.getStackTrace();\n-        } finally {\n-            assert state == suspendedState;\n-            setState(initialState);\n-        }\n-        boolean resubmit = switch (initialState) {\n-            case UNPARKED, UNBLOCKED, YIELDED -> {\n-                \/\/ resubmit as task may have run while suspended\n-                yield true;\n-            }\n-            case PARKED, TIMED_PARKED -> {\n-                \/\/ resubmit if unparked while suspended\n-                yield parkPermit && compareAndSetState(initialState, UNPARKED);\n-            }\n-            case BLOCKED -> {\n-                \/\/ resubmit if unblocked while suspended\n-                yield blockPermit && compareAndSetState(BLOCKED, UNBLOCKED);\n-            }\n-            case WAIT, TIMED_WAIT -> {\n-                \/\/ resubmit if notified or interrupted while waiting (Object.wait)\n-                \/\/ waitTimeoutExpired will retry if the timed expired when suspended\n-                yield (notified || interrupted) && compareAndSetState(initialState, UNBLOCKED);\n-            }\n-            default -> throw new InternalError();\n-        };\n-        if (resubmit) {\n-            submitRunContinuation();\n-        }\n-        return stack;\n-    }\n-\n@@ -1441,1 +1349,1 @@\n-    private native void startTransition(boolean is_mount);\n+    private native void startTransition(boolean mount);\n@@ -1445,1 +1353,1 @@\n-    private native void endTransition(boolean is_mount);\n+    private native void endTransition(boolean mount);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":16,"deletions":108,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -643,0 +643,5 @@\n+\n+    \/**\n+     * Finish initialization of the StackTraceElement objects in a stack trace.\n+     *\/\n+    void finishInit(StackTraceElement[] stackTrace);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -34,0 +36,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -57,3 +60,1 @@\n-     * Return null if a ThreadSnapshot is not created, for example if the\n-     * thread has terminated.\n-     * @throws UnsupportedOperationException if not supported by VM\n+     * @return the snapshot or {@code null} if the thread is not alive\n@@ -64,1 +65,1 @@\n-            return null; \/\/ thread terminated\n+            return null; \/\/ thread not alive\n@@ -66,1 +67,3 @@\n-        if (snapshot.stackTrace == null) {\n+        if (snapshot.stackTrace != null) {\n+            JLA.finishInit(snapshot.stackTrace);\n+        } else {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test jdk.internal.vm.ThreadSnapshot.of(Thread) when thread is not alive\n+ * @modules java.base\/jdk.internal.vm\n+ * @compile\/module=java.base jdk\/internal\/vm\/Helper.java\n+ * @run junit ThreadNotAlive\n+ *\/\n+\n+import jdk.internal.vm.Helper;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ThreadNotAlive {\n+\n+    @Test\n+    void unstartedPlatformThread() {\n+        Thread t = Thread.ofPlatform().unstarted(() -> { });\n+        assertFalse(Helper.isAlive(t));\n+    }\n+\n+    @Test\n+    void terminatedPlatformThread() throws InterruptedException {\n+        Thread t = Thread.ofPlatform().start(() -> { });\n+        t.join();\n+        assertFalse(Helper.isAlive(t));\n+    }\n+\n+    @Test\n+    void unstartedVirtualhread() {\n+        Thread t = Thread.ofVirtual().unstarted(() -> { });\n+        assertFalse(Helper.isAlive(t));\n+    }\n+\n+    @Test\n+    void terminatedVirtualThread() throws InterruptedException {\n+        Thread t = Thread.ofVirtual().start(() -> { });\n+        t.join();\n+        assertFalse(Helper.isAlive(t));\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/ThreadSnapshot\/ThreadNotAlive.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm;\n+\n+\/**\n+ * Defines methods that use package-private methods on ThreadSnapshot.\n+ *\/\n+public class Helper {\n+\n+    \/**\n+     * Uses ThreadSnapshot.of(Thread) to take a snapshot of the given thread, returning\n+     * {@code true} if the thread is alive.\n+     *\/\n+    public static boolean isAlive(Thread thread) {\n+        return ThreadSnapshot.of(thread) != null;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/ThreadSnapshot\/java.base\/jdk\/internal\/vm\/Helper.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 3)\n+public class ThreadGetStackTraceWhenParked {\n+    private volatile boolean done;\n+    private Thread thread;\n+\n+    @Setup\n+    public void setup() throws InterruptedException {\n+        var started = new CountDownLatch(1);\n+        thread = Thread.ofPlatform().start(() -> {\n+            started.countDown();\n+            while (!done) {\n+                LockSupport.park();\n+            }\n+        });\n+        started.await();\n+    }\n+\n+    @TearDown\n+    public void shutdown() throws InterruptedException {\n+        done = true;\n+        LockSupport.unpark(thread);\n+        thread.join();\n+    }\n+\n+    @Benchmark\n+    public StackTraceElement[] testGetStackTrace() {\n+        return thread.getStackTrace();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ThreadGetStackTraceWhenParked.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 3)\n+public class ThreadGetStackTraceWhenSpinning {\n+    private volatile boolean done;\n+    private Thread thread;\n+\n+    @Setup\n+    public void setup() throws InterruptedException {\n+        var started = new CountDownLatch(1);\n+        thread = Thread.ofPlatform().start(() -> {\n+            started.countDown();\n+            while (!done) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        started.await();\n+    }\n+\n+    @TearDown\n+    public void shutdown() throws InterruptedException {\n+        done = true;\n+        thread.join();\n+    }\n+\n+    @Benchmark\n+    public StackTraceElement[] testGetStackTrace() {\n+        return thread.getStackTrace();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ThreadGetStackTraceWhenSpinning.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 3)\n+public class VirtualThreadGetStackTraceWhenSpinning {\n+    private volatile boolean done;\n+    private Thread thread;\n+\n+    @Setup\n+    public void setup() throws InterruptedException {\n+        var started = new CountDownLatch(1);\n+        thread = Thread.startVirtualThread(() -> {\n+            started.countDown();\n+            while (!done) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        started.await();\n+    }\n+\n+    @TearDown\n+    public void shutdown() throws InterruptedException {\n+        done = true;\n+        thread.join();\n+    }\n+\n+    @Benchmark\n+    public StackTraceElement[] testGetStackTrace() {\n+        return thread.getStackTrace();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/VirtualThreadGetStackTraceWhenSpinning.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 3)\n+public class VirtualThreadGetStackTraceWhenUnmounted {\n+    private volatile boolean done;\n+    private Thread thread;\n+\n+    @Setup\n+    public void setup() throws InterruptedException {\n+        var started = new CountDownLatch(1);\n+        thread = Thread.startVirtualThread(() -> {\n+            started.countDown();\n+            while (!done) {\n+                LockSupport.park();\n+            }\n+        });\n+        started.await();\n+    }\n+\n+    @TearDown\n+    public void shutdown() throws InterruptedException {\n+        done = true;\n+        LockSupport.unpark(thread);\n+        thread.join();\n+    }\n+\n+    @Benchmark\n+    public StackTraceElement[] testGetStackTrace() {\n+        return thread.getStackTrace();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/VirtualThreadGetStackTraceWhenUnmounted.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 3)\n+public class VirtualThreadGetStackTraceWhenYielding {\n+    private volatile boolean done;\n+    private Thread thread;\n+\n+    @Setup\n+    public void setup() throws InterruptedException {\n+        var started = new CountDownLatch(1);\n+        thread = Thread.startVirtualThread(() -> {\n+            started.countDown();\n+            while (!done) {\n+                Thread.yield();\n+            }\n+        });\n+        started.await();\n+    }\n+\n+    @TearDown\n+    public void shutdown() throws InterruptedException {\n+        done = true;\n+        thread.join();\n+    }\n+\n+    @Benchmark\n+    public StackTraceElement[] testGetStackTrace() {\n+        return thread.getStackTrace();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/VirtualThreadGetStackTraceWhenYielding.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}