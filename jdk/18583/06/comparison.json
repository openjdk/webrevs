{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -781,1 +781,1 @@\n-        result.appendLine(\"protected void mult(long[] a, long[] b, long[] r) {\");\n+        result.appendLine(\"protected int mult(long[] a, long[] b, long[] r) {\");\n@@ -807,0 +807,3 @@\n+        result.appendIndent();\n+        result.append(\"return 0;\");\n+        result.appendLine();\n@@ -836,1 +839,1 @@\n-        result.appendLine(\"protected void square(long[] a, long[] r) {\");\n+        result.appendLine(\"protected int square(long[] a, long[] r) {\");\n@@ -877,0 +880,3 @@\n+        result.appendIndent();\n+        result.append(\"return 0;\");\n+        result.appendLine();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,0 +109,2 @@\n+        --add-exports java.base\/sun.security.util.math=ALL-UNNAMED \\\n+        --add-exports java.base\/sun.security.util.math.intpoly=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1442,0 +1442,2 @@\n+\n+  using Assembler::evpsrlq;\n@@ -1463,0 +1465,1 @@\n+  using Assembler::evpsraq;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4210,0 +4210,5 @@\n+  if (UseIntPolyIntrinsics) {\n+    StubRoutines::_intpoly_montgomeryMult_P256 = generate_intpoly_montgomeryMult_P256();\n+    StubRoutines::_intpoly_assign = generate_intpoly_assign();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -478,0 +478,4 @@\n+  address generate_intpoly_montgomeryMult_P256();\n+  void montgomeryMultiply(const Register aLimbs, const Register bLimbs, const Register rLimbs);\n+  address generate_intpoly_assign();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly1305.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,429 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+#define __ _masm->\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t MODULUS_P256[] = {\n+  0x000fffffffffffffULL, 0x00000fffffffffffULL,\n+  0x0000000000000000ULL, 0x0000001000000000ULL,\n+  0x0000ffffffff0000ULL, 0x0000000000000000ULL,\n+  0x0000000000000000ULL, 0x0000000000000000ULL\n+};\n+static address modulus_p256() {\n+  return (address)MODULUS_P256;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t P256_MASK52[] = {\n+  0x000fffffffffffffULL, 0x000fffffffffffffULL,\n+  0x000fffffffffffffULL, 0x000fffffffffffffULL,\n+  0xffffffffffffffffULL, 0xffffffffffffffffULL,\n+  0xffffffffffffffffULL, 0xffffffffffffffffULL,\n+};\n+static address p256_mask52() {\n+  return (address)P256_MASK52;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t BROADCAST5[] = {\n+  0x0000000000000004ULL, 0x0000000000000004ULL,\n+  0x0000000000000004ULL, 0x0000000000000004ULL,\n+  0x0000000000000004ULL, 0x0000000000000004ULL,\n+  0x0000000000000004ULL, 0x0000000000000004ULL,\n+};\n+static address broadcast_5() {\n+  return (address)BROADCAST5;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t SHIFT1R[] = {\n+  0x0000000000000001ULL, 0x0000000000000002ULL,\n+  0x0000000000000003ULL, 0x0000000000000004ULL,\n+  0x0000000000000005ULL, 0x0000000000000006ULL,\n+  0x0000000000000007ULL, 0x0000000000000000ULL,\n+};\n+static address shift_1R() {\n+  return (address)SHIFT1R;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t SHIFT1L[] = {\n+  0x0000000000000007ULL, 0x0000000000000000ULL,\n+  0x0000000000000001ULL, 0x0000000000000002ULL,\n+  0x0000000000000003ULL, 0x0000000000000004ULL,\n+  0x0000000000000005ULL, 0x0000000000000006ULL,\n+};\n+static address shift_1L() {\n+  return (address)SHIFT1L;\n+}\n+\n+\/**\n+ * Unrolled Word-by-Word Montgomery Multiplication\n+ * r = a * b * 2^-260 (mod P)\n+ *\n+ * Reference: Shay Gueron and Vlad Krasnov \"Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes\"\n+ *    See Figure 5. \"Algorithm 2: Word-by-Word Montgomery Multiplication for a Montgomery\n+ *    Friendly modulus p\". Note: Step 6. Skipped; Instead use numAdds to reuse existing overflow\n+ *    logic.\n+ *\n+ * Pseudocode:\n+ *\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *   M = load(*modulus_p256)                           | 0| 0| 0|m5|m4|m3|m2|m1|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *   A = load(*aLimbs)                                 | 0| 0| 0|a5|a4|a3|a2|a1|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *   Acc1 = 0                                          | 0| 0| 0| 0| 0| 0| 0| 0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *      ---- for i = 0 to 4\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc2 = 0                                   | 0| 0| 0| 0| 0| 0| 0| 0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          B = replicate(bLimbs[i])                   |bi|bi|bi|bi|bi|bi|bi|bi|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc1+=| 0| 0| 0|c5|c4|c3|c2|c1|\n+ *                                                    *| 0| 0| 0|a5|a4|a3|a2|a1|\n+ *          Acc1 += A *  B                             |bi|bi|bi|bi|bi|bi|bi|bi|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc2+=| 0| 0| 0| 0| 0| 0| 0| 0|\n+ *                                                   *h| 0| 0| 0|a5|a4|a3|a2|a1|\n+ *          Acc2 += A *h B                             |bi|bi|bi|bi|bi|bi|bi|bi|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          N = replicate(Acc1[0])                     |n0|n0|n0|n0|n0|n0|n0|n0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc1+=| 0| 0| 0|c5|c4|c3|c2|c1|\n+ *                                                    *| 0| 0| 0|m5|m4|m3|m2|m1|\n+ *          Acc1 += M *  N                             |n0|n0|n0|n0|n0|n0|n0|n0| Note: 52 low bits of Acc1[0] == 0 due to Montgomery!\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc2+=| 0| 0| 0|d5|d4|d3|d2|d1|\n+ *                                                   *h| 0| 0| 0|m5|m4|m3|m2|m1|\n+ *          Acc2 += M *h N                             |n0|n0|n0|n0|n0|n0|n0|n0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          if (i == 4) break;\n+ *          \/\/ Combine high\/low partial sums Acc1 + Acc2\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          carry = Acc1[0] >> 52                      | 0| 0| 0| 0| 0| 0| 0|c1|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc2[0] += carry\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc1 = Acc1 shift one q element>>          | 0| 0| 0| 0|c5|c4|c3|c2|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc1 = Acc1 + Acc2\n+ *      ---- done\n+ *   \/\/ Last Carry round: Combine high\/low partial sums Acc1<high_bits> + Acc1 + Acc2\n+ *   carry = Acc1 >> 52\n+ *   Acc1 = Acc1 shift one q element >>\n+ *   Acc1  = mask52(Acc1)\n+ *   Acc2  += carry\n+ *   Acc1 = Acc1 + Acc2\n+ *   output to rLimbs\n+ *\/\n+void StubGenerator::montgomeryMultiply(const Register aLimbs, const Register bLimbs, const Register rLimbs) {\n+  Register t0 = r13;\n+  Register rscratch = r13;\n+\n+  \/\/ Inputs\n+  XMMRegister A = xmm0;\n+  XMMRegister B = xmm1;\n+  XMMRegister T = xmm2;\n+\n+  \/\/ Intermediates\n+  XMMRegister Acc1 = xmm10;\n+  XMMRegister Acc2 = xmm11;\n+  XMMRegister N = xmm12;\n+  XMMRegister select = xmm13;\n+  XMMRegister carry = xmm14;\n+\n+  \/\/ Constants\n+  XMMRegister modulus = xmm20;\n+  XMMRegister shift1L = xmm21;\n+  XMMRegister shift1R = xmm22;\n+  XMMRegister mask52 = xmm23;\n+  XMMRegister broadcast5 = xmm24;\n+  KRegister limb0 = k1;\n+  KRegister limb5 = k2;\n+  KRegister allLimbs = k3;\n+\n+  __ mov64(t0, 0x1);\n+  __ kmovql(limb0, t0);\n+  __ mov64(t0, 0x10);\n+  __ kmovql(limb5, t0);\n+  __ mov64(t0, 0x1f);\n+  __ kmovql(allLimbs, t0);\n+  __ evmovdquq(shift1L, allLimbs, ExternalAddress(shift_1L()), false, Assembler::AVX_512bit, rscratch);\n+  __ evmovdquq(shift1R, allLimbs, ExternalAddress(shift_1R()), false, Assembler::AVX_512bit, rscratch);\n+  __ evmovdquq(broadcast5, allLimbs, ExternalAddress(broadcast_5()), false, Assembler::AVX_512bit, rscratch);\n+  __ evmovdquq(mask52, allLimbs, ExternalAddress(p256_mask52()), false, Assembler::AVX_512bit, rscratch);\n+\n+  \/\/ M = load(*modulus_p256)\n+  __ evmovdquq(modulus, allLimbs, ExternalAddress(modulus_p256()), false, Assembler::AVX_512bit, rscratch);\n+\n+  \/\/ A = load(*aLimbs)\n+  __ evmovdquq(A, Address(aLimbs, 8), Assembler::AVX_256bit);                          \/\/ Acc1 = load(*a)\n+  __ evpermq(A, allLimbs, shift1L, A, false, Assembler::AVX_512bit);\n+  __ movq(T, Address(aLimbs, 0));\n+  __ evporq(A, A, T, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1 = 0\n+  __ vpxorq(Acc1, Acc1, Acc1, Assembler::AVX_512bit);\n+  for (int i = 0; i< 5; i++) {\n+      \/\/ Acc2 = 0\n+      __ vpxorq(Acc2, Acc2, Acc2, Assembler::AVX_512bit);\n+\n+      \/\/ B = replicate(bLimbs[i])\n+      __ vpbroadcastq(B, Address(bLimbs, i*8), Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 += A * B\n+      __ evpmadd52luq(Acc1, A, B, Assembler::AVX_512bit);\n+\n+      \/\/ Acc2 += A *h B\n+      __ evpmadd52huq(Acc2, A, B, Assembler::AVX_512bit);\n+\n+      \/\/ N = replicate(Acc1[0])\n+      __ vpbroadcastq(N, Acc1, Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 += M *  N\n+      __ evpmadd52luq(Acc1, modulus, N, Assembler::AVX_512bit);\n+\n+      \/\/ Acc2 += M *h N\n+      __ evpmadd52huq(Acc2, modulus, N, Assembler::AVX_512bit);\n+\n+      if (i == 4) break;\n+\n+      \/\/ Combine high\/low partial sums Acc1 + Acc2\n+\n+      \/\/ carry = Acc1[0] >> 52\n+      __ evpsrlq(carry, limb0, Acc1, 52, true, Assembler::AVX_512bit);\n+\n+      \/\/ Acc2[0] += carry\n+      __ evpaddq(Acc2, limb0, carry, Acc2, true, Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 = Acc1 shift one q element >>\n+      __ evpermq(Acc1, allLimbs, shift1R, Acc1, false, Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 = Acc1 + Acc2\n+      __ vpaddq(Acc1, Acc1, Acc2, Assembler::AVX_512bit);\n+  }\n+\n+  \/\/ Last Carry round: Combine high\/low partial sums Acc1<high_bits> + Acc1 + Acc2\n+  \/\/ carry = Acc1 >> 52\n+  __ evpsrlq(carry, allLimbs, Acc1, 52, true, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1 = Acc1 shift one q element >>\n+  __ evpermq(Acc1, allLimbs, shift1R, Acc1, false, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1  = mask52(Acc1)\n+  __ evpandq(Acc1, Acc1, mask52, Assembler::AVX_512bit); \/\/ Clear top 12 bits\n+\n+  \/\/ Acc2 += carry\n+  __ evpaddq(Acc2, allLimbs, carry, Acc2, true, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1 = Acc1 + Acc2\n+  __ vpaddq(Acc1, Acc1, Acc2, Assembler::AVX_512bit);\n+\n+  \/\/ output to rLimbs (1 + 4 limbs)\n+  __ movq(Address(rLimbs, 0), Acc1);\n+  __ evpermq(Acc1, k0, shift1R, Acc1, true, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(rLimbs, 8), k0, Acc1, true, Assembler::AVX_256bit);\n+}\n+\n+address StubGenerator::generate_intpoly_montgomeryMult_P256() {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_montgomeryMult_P256\");\n+  address start = __ pc();\n+  __ enter();\n+\n+  \/\/ Save all 'SOE' registers\n+  __ push(rbx);\n+  #ifdef _WIN64\n+  __ push(rsi);\n+  __ push(rdi);\n+  #endif\n+  __ push(r12);\n+  __ push(r13);\n+  __ push(r14);\n+  __ push(r15);\n+\n+  \/\/ Register Map\n+  const Register aLimbs  = rdi;\n+  const Register bLimbs  = rsi;\n+  const Register rLimbs  = rdx;\n+\n+  \/\/ Normalize input\n+  \/\/ pseudo-signature: void poly1305_processBlocks(byte[] input, int length, int[5] accumulator, int[5] R)\n+  \/\/ a, b, r pointers point at first array element\n+  \/\/ java headers bypassed in LibraryCallKit::inline_poly1305_processBlocks\n+  #ifdef _WIN64\n+  \/\/ c_rarg0 - rcx\n+  \/\/ c_rarg1 - rdx\n+  \/\/ c_rarg2 - r8\n+  __ mov(aLimbs, c_rarg0);\n+  __ mov(bLimbs, c_rarg1);\n+  __ mov(rLimbs, c_rarg2);\n+  #else\n+  \/\/ Already in place\n+  \/\/ c_rarg0 - rdi\n+  \/\/ c_rarg1 - rsi\n+  \/\/ c_rarg2 - rdx\n+  #endif\n+\n+  montgomeryMultiply(aLimbs, bLimbs, rLimbs);\n+\n+  __ pop(r15);\n+  __ pop(r14);\n+  __ pop(r13);\n+  __ pop(r12);\n+  #ifdef _WIN64\n+  __ pop(rdi);\n+  __ pop(rsi);\n+  #endif\n+  __ pop(rbx);\n+  __ mov64(rax, 0x1); \/\/ Return 1 (Step 6 skipped in montgomeryMultiply)\n+\n+  __ leave();\n+  __ ret(0);\n+  return start;\n+}\n+\n+\/\/ A = B if select\n+\/\/ Must be:\n+\/\/  - constant time (i.e. no branches)\n+\/\/  - no-side channel (i.e. all memory must always be accessed, and in same order)\n+void assign_avx(XMMRegister A, Address aAddr, XMMRegister B, Address bAddr, KRegister select, int vector_len, MacroAssembler* _masm) {\n+  __ evmovdquq(A, aAddr, vector_len);\n+  __ evmovdquq(B, bAddr, vector_len);\n+  __ evmovdquq(A, select, B, true, vector_len);\n+  __ evmovdquq(aAddr, A, vector_len);\n+}\n+\n+void assign_scalar(Address aAddr, Address bAddr, Register select, Register tmp, MacroAssembler* _masm) {\n+  \/\/ Original java:\n+  \/\/ long dummyLimbs = maskValue & (a[i] ^ b[i]);\n+  \/\/ a[i] = dummyLimbs ^ a[i];\n+\n+  __ movq(tmp, aAddr);\n+  __ xorq(tmp, bAddr);\n+  __ andq(tmp, select);\n+  __ xorq(aAddr, tmp);\n+}\n+\n+address StubGenerator::generate_intpoly_assign() {\n+  \/\/ KNOWN Lengths:\n+  \/\/   MontgomeryIntPolynP256:  5 = 4 + 1\n+  \/\/   IntegerPolynomial1305:   5 = 4 + 1\n+  \/\/   IntegerPolynomial25519: 10 = 8 + 2\n+  \/\/   IntegerPolynomialP256:  10 = 8 + 2\n+  \/\/   Curve25519OrderField:   10 = 8 + 2\n+  \/\/   Curve25519OrderField:   10 = 8 + 2\n+  \/\/   P256OrderField:         10 = 8 + 2\n+  \/\/   IntegerPolynomialP384:  14 = 8 + 4 + 2\n+  \/\/   P384OrderField:         14 = 8 + 4 + 2\n+  \/\/   IntegerPolynomial448:   16 = 8 + 8\n+  \/\/   Curve448OrderField:     16 = 8 + 8\n+  \/\/   Curve448OrderField:     16 = 8 + 8\n+  \/\/   IntegerPolynomialP521:  19 = 8 + 8 + 2 + 1\n+  \/\/   P521OrderField:         19 = 8 + 8 + 2 + 1\n+  \/\/ Special Cases 5, 10, 14, 16, 19\n+\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_assign\");\n+  address start = __ pc();\n+  __ enter();\n+\n+  \/\/ Inputs\n+  const Register set     = c_rarg0;\n+  const Register aLimbs  = c_rarg1;\n+  const Register bLimbs  = c_rarg2;\n+  const Register length  = c_rarg3;\n+  XMMRegister A = xmm0;\n+  XMMRegister B = xmm1;\n+\n+  Register tmp = r9;\n+  KRegister select = k1;\n+  Label L_Length5, L_Length10, L_Length14, L_Length16, L_Length19, L_DefaultLoop, L_Done;\n+\n+  __ negq(set);\n+  __ kmovql(select, set);\n+\n+  \/\/ NOTE! Crypto code cannot branch on user input. However; allowed to branch on number of limbs;\n+  \/\/ Number of limbs is a constant in each IntegerPolynomial (i.e. this side-channel branch leaks\n+  \/\/   number of limbs which is not a secret)\n+  __ cmpl(length, 5);\n+  __ jcc(Assembler::equal, L_Length5);\n+  __ cmpl(length, 10);\n+  __ jcc(Assembler::equal, L_Length10);\n+  __ cmpl(length, 14);\n+  __ jcc(Assembler::equal, L_Length14);\n+  __ cmpl(length, 16);\n+  __ jcc(Assembler::equal, L_Length16);\n+  __ cmpl(length, 19);\n+  __ jcc(Assembler::equal, L_Length19);\n+\n+  \/\/ Default copy loop (UNLIKELY)\n+  __ cmpl(length, 0);\n+  __ jcc(Assembler::lessEqual, L_Done);\n+  __ bind(L_DefaultLoop);\n+  assign_scalar(Address(aLimbs, 0), Address(bLimbs, 0), set, tmp, _masm);\n+  __ subl(length, 1);\n+  __ lea(aLimbs, Address(aLimbs,8));\n+  __ lea(bLimbs, Address(bLimbs,8));\n+  __ cmpl(length, 0);\n+  __ jcc(Assembler::greater, L_DefaultLoop);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length5); \/\/ 1 + 4\n+  assign_scalar(Address(aLimbs, 0), Address(bLimbs, 0), set, tmp, _masm);\n+  assign_avx(A, Address(aLimbs, 8), B, Address(bLimbs, 8), select, Assembler::AVX_256bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length10); \/\/ 2 + 8\n+  assign_avx(A, Address(aLimbs, 0),  B, Address(bLimbs, 0),  select, Assembler::AVX_128bit, _masm);\n+  assign_avx(A, Address(aLimbs, 16), B, Address(bLimbs, 16), select, Assembler::AVX_512bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length14); \/\/ 2 + 4 + 8\n+  assign_avx(A, Address(aLimbs, 0),  B, Address(bLimbs, 0),  select, Assembler::AVX_128bit, _masm);\n+  assign_avx(A, Address(aLimbs, 16), B, Address(bLimbs, 16), select, Assembler::AVX_256bit, _masm);\n+  assign_avx(A, Address(aLimbs, 48), B, Address(bLimbs, 48), select, Assembler::AVX_512bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length16); \/\/ 8 + 8\n+  assign_avx(A, Address(aLimbs, 0),  B, Address(bLimbs, 0),  select, Assembler::AVX_512bit, _masm);\n+  assign_avx(A, Address(aLimbs, 64), B, Address(bLimbs, 64), select, Assembler::AVX_512bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length19); \/\/ 1 + 2 + 8 + 8\n+  assign_scalar(Address(aLimbs, 0), Address(bLimbs, 0), set, tmp, _masm);\n+  assign_avx(A, Address(aLimbs, 8),  B, Address(bLimbs, 8),  select, Assembler::AVX_128bit, _masm);\n+  assign_avx(A, Address(aLimbs, 24), B, Address(bLimbs, 24), select, Assembler::AVX_512bit, _masm);\n+  assign_avx(A, Address(aLimbs, 88), B, Address(bLimbs, 88), select, Assembler::AVX_512bit, _masm);\n+\n+  __ bind(L_Done);\n+  __ leave();\n+  __ ret(0);\n+  return start;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":429,"deletions":0,"binary":false,"changes":429,"status":"added"},{"patch":"@@ -1369,0 +1369,12 @@\n+#ifdef _LP64\n+  if (supports_avx512ifma() && supports_avx512vlbw() && MaxVectorSize >= 64) {\n+    if (FLAG_IS_DEFAULT(UseIntPolyIntrinsics)) {\n+      FLAG_SET_DEFAULT(UseIntPolyIntrinsics, true);\n+    }\n+  } else\n+#endif\n+  if (UseIntPolyIntrinsics) {\n+    warning(\"Intrinsics for Polynomial crypto functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseIntPolyIntrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -495,0 +495,4 @@\n+  case vmIntrinsics::_intpoly_montgomeryMult_P256:\n+  case vmIntrinsics::_intpoly_assign:\n+    if (!UseIntPolyIntrinsics) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -529,1 +529,12 @@\n-   \/* support for java.util.Base64.Encoder*\/                                                                            \\\n+  \/* support for sun.security.util.math.intpoly.MontgomeryIntegerPolynomialP256 *\/                                      \\\n+  do_class(sun_security_util_math_intpoly_MontgomeryIntegerPolynomialP256, \"sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256\")  \\\n+  do_intrinsic(_intpoly_montgomeryMult_P256, sun_security_util_math_intpoly_MontgomeryIntegerPolynomialP256, intPolyMult_name, intPolyMult_signature, F_R) \\\n+  do_name(intPolyMult_name, \"mult\")                                                                                     \\\n+  do_signature(intPolyMult_signature, \"([J[J[J)I\")                                                                      \\\n+                                                                                                                        \\\n+  do_class(sun_security_util_math_intpoly_IntegerPolynomial, \"sun\/security\/util\/math\/intpoly\/IntegerPolynomial\")        \\\n+  do_intrinsic(_intpoly_assign, sun_security_util_math_intpoly_IntegerPolynomial, intPolyAssign_name, intPolyAssign_signature, F_S) \\\n+   do_name(intPolyAssign_name, \"conditionalAssign\")                                                                     \\\n+   do_signature(intPolyAssign_signature, \"(I[J[J)V\")                                                                    \\\n+                                                                                                                        \\\n+  \/* support for java.util.Base64.Encoder*\/                                                                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -361,0 +361,2 @@\n+  static_field(StubRoutines,                _intpoly_montgomeryMult_P256,                     address)                               \\\n+  static_field(StubRoutines,                _intpoly_assign,                                  address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -786,0 +786,2 @@\n+  case vmIntrinsics::_intpoly_montgomeryMult_P256:\n+  case vmIntrinsics::_intpoly_assign:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1587,0 +1587,2 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"intpoly_montgomeryMult_P256\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"intpoly_assign\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -640,1 +640,4 @@\n-\n+  case vmIntrinsics::_intpoly_montgomeryMult_P256:\n+    return inline_intpoly_montgomeryMult_P256();\n+  case vmIntrinsics::_intpoly_assign:\n+    return inline_intpoly_assign();\n@@ -7516,0 +7519,67 @@\n+bool LibraryCallKit::inline_intpoly_montgomeryMult_P256() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseIntPolyIntrinsics, \"need intpoly intrinsics support\");\n+  assert(callee()->signature()->size() == 3, \"intpoly_montgomeryMult_P256 has %d parameters\", callee()->signature()->size());\n+  stubAddr = StubRoutines::intpoly_montgomeryMult_P256();\n+  stubName = \"intpoly_montgomeryMult_P256\";\n+\n+  if (!stubAddr) return false;\n+  null_check_receiver();  \/\/ null-check receiver\n+  if (stopped())  return true;\n+\n+  Node* a = argument(1);\n+  Node* b = argument(2);\n+  Node* r = argument(3);\n+\n+  a = must_be_not_null(a, true);\n+  b = must_be_not_null(b, true);\n+  r = must_be_not_null(r, true);\n+\n+  Node* a_start = array_element_address(a, intcon(0), T_LONG);\n+  assert(a_start, \"a array is NULL\");\n+  Node* b_start = array_element_address(b, intcon(0), T_LONG);\n+  assert(b_start, \"b array is NULL\");\n+  Node* r_start = array_element_address(r, intcon(0), T_LONG);\n+  assert(r_start, \"r array is NULL\");\n+\n+  Node* call = make_runtime_call(RC_LEAF | RC_NO_FP,\n+                                 OptoRuntime::intpoly_montgomeryMult_P256_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 a_start, b_start, r_start);\n+  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  set_result(result);\n+  return true;\n+}\n+\n+bool LibraryCallKit::inline_intpoly_assign() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseIntPolyIntrinsics, \"need intpoly intrinsics support\");\n+  assert(callee()->signature()->size() == 3, \"intpoly_assign has %d parameters\", callee()->signature()->size());\n+  stubAddr = StubRoutines::intpoly_assign();\n+  stubName = \"intpoly_assign\";\n+\n+  if (!stubAddr) return false;\n+  if (stopped())  return true;\n+\n+  Node* set = argument(0);\n+  Node* a = argument(1);\n+  Node* b = argument(2);\n+  Node* arr_length = load_array_length(a);\n+\n+  a = must_be_not_null(a, true);\n+  b = must_be_not_null(b, true);\n+\n+  Node* a_start = array_element_address(a, intcon(0), T_LONG);\n+  assert(a_start, \"a array is NULL\");\n+  Node* b_start = array_element_address(b, intcon(0), T_LONG);\n+  assert(b_start, \"b array is NULL\");\n+\n+  Node* call = make_runtime_call(RC_LEAF | RC_NO_FP,\n+                                 OptoRuntime::intpoly_assign_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 set, a_start, b_start, arr_length);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,0 +309,2 @@\n+  bool inline_intpoly_montgomeryMult_P256();\n+  bool inline_intpoly_assign();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1382,0 +1382,39 @@\n+\/\/ MontgomeryIntegerPolynomialP256 multiply function\n+const TypeFunc* OptoRuntime::intpoly_montgomeryMult_P256_Type() {\n+  int argcnt = 3;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ a array\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ b array\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ r(esult) array\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ carry bits in output\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ IntegerPolynomial constant time assignment function\n+const TypeFunc* OptoRuntime::intpoly_assign_Type() {\n+  int argcnt = 4;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypeInt::INT;        \/\/ set flag\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ a array (result)\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ b array (if set is set)\n+  fields[argp++] = TypeInt::INT;        \/\/ array length\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -299,0 +299,2 @@\n+  static const TypeFunc* intpoly_montgomeryMult_P256_Type();\n+  static const TypeFunc* intpoly_assign_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -240,0 +240,2 @@\n+  product(bool, UseIntPolyIntrinsics, false, DIAGNOSTIC,                   \\\n+          \"Use intrinsics for sun.security.util.math.intpoly.MontgomeryIntegerPolynomialP256\") \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,0 +132,2 @@\n+address StubRoutines::_intpoly_montgomeryMult_P256         = nullptr;\n+address StubRoutines::_intpoly_assign                      = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,0 +216,2 @@\n+  static address _intpoly_montgomeryMult_P256;\n+  static address _intpoly_assign;\n@@ -402,0 +404,2 @@\n+  static address intpoly_montgomeryMult_P256()          { return _intpoly_montgomeryMult_P256; }\n+  static address intpoly_assign()        { return _intpoly_assign; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n@@ -268,0 +269,5 @@\n+        if (field instanceof IntegerMontgomeryFieldModuloP) {\n+            \/\/ No point of doing a single SmallValue operation in Montgomery domain\n+            field = ((IntegerMontgomeryFieldModuloP)field).residueField();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,1 @@\n-        ecOps.setSum(p1, p2.asAffine());\n+        ecOps.setSum(p1, p2);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDSAOperations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-\n@@ -51,4 +50,0 @@\n-    private static final ECOperations secp256r1Ops =\n-        new ECOperations(IntegerPolynomialP256.ONE.getElement(\n-                CurveDB.lookup(KnownOIDs.secp256r1.value()).getCurve().getB()),\n-                P256OrderField.ONE);\n@@ -67,1 +62,1 @@\n-        IntegerPolynomialP256.MODULUS, IntegerPolynomialP256.ONE,\n+        IntegerPolynomialP256.MODULUS, MontgomeryIntegerPolynomialP256.ONE,\n@@ -210,1 +205,10 @@\n-        return PointMultiplier.of(this, affineP).pointMultiply(s);\n+        PointMultiplier multiplier = null;\n+        if (getField() instanceof IntegerMontgomeryFieldModuloP\n+                && affineP.equals(Secp256R1GeneratorMontgomeryMultiplier.generator)) {\n+            \/\/ Lazy class loading here\n+            multiplier = Secp256R1GeneratorMontgomeryMultiplier.multiplier;\n+        } else {\n+            multiplier = new DefaultMultiplier(this, affineP);\n+        }\n+\n+        return multiplier.pointMultiply(s);\n@@ -213,0 +217,8 @@\n+    \/**\n+     * Multiply an affine ecpoint point by a scalar and return the result as a\n+     * mutable point.\n+     *\n+     * @param ecPoint the point\n+     * @param s the scalar as a little-endian array\n+     * @return the product\n+     *\/\n@@ -214,1 +226,1 @@\n-        return PointMultiplier.of(this, ecPoint).pointMultiply(s);\n+        return multiply(AffinePoint.fromECPoint(ecPoint, getField()), s);\n@@ -267,4 +279,9 @@\n-    \/*\n-     * Mixed point addition. This method constructs new temporaries each time\n-     * it is called. For better efficiency, the method that reuses temporaries\n-     * should be used if more than one sum will be computed.\n+    \/**\n+     * Adds second Mutable (Projective) point to first.\n+     *\n+     * Used by ECDSAOperations. This method constructs new temporaries each time\n+     * it is called. For better efficiency, the (private) method that reuses\n+     * temporaries should be used if more than one sum will be computed.\n+     *\n+     * @param p first point and result\n+     * @param p2 second point to add\n@@ -272,2 +289,1 @@\n-    public void setSum(MutablePoint p, AffinePoint p2) {\n-\n+    public void setSum(MutablePoint p, MutablePoint p2) {\n@@ -280,1 +296,0 @@\n-        setSum((ProjectivePoint.Mutable) p, p2, t0, t1, t2, t3, t4);\n@@ -282,0 +297,2 @@\n+        setSum((ProjectivePoint.Mutable) p, (ProjectivePoint.Mutable) p2,\n+            t0, t1, t2, t3, t4);\n@@ -292,3 +309,3 @@\n-        t0.setValue(p.getX()).setProduct(p2.getX());\n-        t1.setValue(p.getY()).setProduct(p2.getY());\n-        t3.setValue(p2.getX()).setSum(p2.getY());\n+        t0.setValue(p.getX()).setProduct(p2.getX(false));\n+        t1.setValue(p.getY()).setProduct(p2.getY(false));\n+        t3.setValue(p2.getX(false)).setSum(p2.getY(false));\n@@ -300,1 +317,1 @@\n-        t4.setValue(p2.getY()).setProduct(p.getZ());\n+        t4.setValue(p2.getY(false)).setProduct(p.getZ());\n@@ -303,1 +320,1 @@\n-        p.getY().setValue(p2.getX()).setProduct(p.getZ());\n+        p.getY().setValue(p2.getX(false)).setProduct(p.getZ());\n@@ -415,5 +432,2 @@\n-    sealed interface PointMultiplier {\n-        Map<ECPoint, PointMultiplier> multipliers = Map.of(\n-                Secp256R1GeneratorMultiplier.generator,\n-                Secp256R1GeneratorMultiplier.multiplier);\n-\n+    sealed interface PointMultiplier\n+        permits DefaultMultiplier, Secp256R1GeneratorMontgomeryMultiplier {\n@@ -432,20 +446,0 @@\n-        static PointMultiplier of(ECOperations ecOps, AffinePoint affPoint) {\n-            PointMultiplier multiplier = multipliers.get(affPoint.toECPoint());\n-            if (multiplier == null) {\n-                multiplier = new Default(ecOps, affPoint);\n-            }\n-\n-            return multiplier;\n-        }\n-\n-        static PointMultiplier of(ECOperations ecOps, ECPoint ecPoint) {\n-            PointMultiplier multiplier = multipliers.get(ecPoint);\n-            if (multiplier == null) {\n-                AffinePoint affPoint =\n-                        AffinePoint.fromECPoint(ecPoint, ecOps.getField());\n-                multiplier = new Default(ecOps, affPoint);\n-            }\n-\n-            return multiplier;\n-        }\n-\n@@ -468,0 +462,1 @@\n+    }\n@@ -469,3 +464,3 @@\n-        final class Default implements PointMultiplier {\n-            private final AffinePoint affineP;\n-            private final ECOperations ecOps;\n+    final static class DefaultMultiplier implements PointMultiplier {\n+        private final ECOperations ecOps;\n+        private final ProjectivePoint.Immutable[] pointMultiples;\n@@ -473,4 +468,2 @@\n-            private Default(ECOperations ecOps, AffinePoint affineP) {\n-                this.ecOps = ecOps;\n-                this.affineP = affineP;\n-            }\n+        DefaultMultiplier(ECOperations ecOps, AffinePoint affineP) {\n+            this.ecOps = ecOps;\n@@ -478,34 +471,2 @@\n-            @Override\n-            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n-                \/\/ 4-bit windowed multiply with branchless lookup.\n-                \/\/ The mixed addition is faster, so it is used to construct\n-                \/\/ the array at the beginning of the operation.\n-\n-                IntegerFieldModuloP field = affineP.getX().getField();\n-                ImmutableIntegerModuloP zero = field.get0();\n-                \/\/ temporaries\n-                MutableIntegerModuloP t0 = zero.mutable();\n-                MutableIntegerModuloP t1 = zero.mutable();\n-                MutableIntegerModuloP t2 = zero.mutable();\n-                MutableIntegerModuloP t3 = zero.mutable();\n-                MutableIntegerModuloP t4 = zero.mutable();\n-\n-                ProjectivePoint.Mutable result =\n-                        new ProjectivePoint.Mutable(field);\n-                result.getY().setValue(field.get1().mutable());\n-\n-                ProjectivePoint.Immutable[] pointMultiples =\n-                        new ProjectivePoint.Immutable[16];\n-                \/\/ 0P is neutral---same as initial result value\n-                pointMultiples[0] = result.fixed();\n-\n-                ProjectivePoint.Mutable ps = new ProjectivePoint.Mutable(field);\n-                ps.setValue(affineP);\n-                \/\/ 1P = P\n-                pointMultiples[1] = ps.fixed();\n-\n-                \/\/ the rest are calculated using mixed point addition\n-                for (int i = 2; i < 16; i++) {\n-                    ecOps.setSum(ps, affineP, t0, t1, t2, t3, t4);\n-                    pointMultiples[i] = ps.fixed();\n-                }\n+            \/\/ Precompute and cache point multiples\n+            this.pointMultiples = new ProjectivePoint.Immutable[16];\n@@ -513,1 +474,8 @@\n-                ProjectivePoint.Mutable lookupResult = ps.mutable();\n+            IntegerFieldModuloP field = ecOps.getField();\n+            ImmutableIntegerModuloP zero = field.get0();\n+            \/\/ temporaries\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n@@ -515,2 +483,3 @@\n-                for (int i = s.length - 1; i >= 0; i--) {\n-                    double4(result, t0, t1, t2, t3, t4);\n+            ProjectivePoint.Mutable ps =\n+                new ProjectivePoint.Mutable(field);\n+            ps.getY().setValue(field.get1().mutable());\n@@ -518,3 +487,2 @@\n-                    int high = (0xFF & s[i]) >>> 4;\n-                    lookup(pointMultiples, high, lookupResult);\n-                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+            \/\/ 0P is neutral---same as initial result value\n+            pointMultiples[0] = ps.fixed();\n@@ -522,1 +490,3 @@\n-                    double4(result, t0, t1, t2, t3, t4);\n+            ps.setValue(affineP);\n+            \/\/ 1P = P\n+            pointMultiples[1] = ps.fixed();\n@@ -524,4 +494,6 @@\n-                    int low = 0xF & s[i];\n-                    lookup(pointMultiples, low, lookupResult);\n-                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n-                }\n+            \/\/ the rest are calculated using mixed point addition\n+            for (int i = 2; i < 16; i++) {\n+                ecOps.setSum(ps, affineP, t0, t1, t2, t3, t4);\n+                pointMultiples[i] = ps.fixed();\n+            }\n+        }\n@@ -529,1 +501,31 @@\n-                return result;\n+        @Override\n+        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+            \/\/ 4-bit windowed multiply with branchless lookup.\n+            \/\/ The mixed addition is faster, so it is used to construct\n+            \/\/ the array at the beginning of the operation.\n+\n+            IntegerFieldModuloP field = ecOps.getField();\n+            ImmutableIntegerModuloP zero = field.get0();\n+            \/\/ temporaries\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n+\n+            ProjectivePoint.Mutable result = new ProjectivePoint.Mutable(field);\n+            result.getY().setValue(field.get1().mutable());\n+            ProjectivePoint.Mutable lookupResult = new ProjectivePoint.Mutable(field);\n+\n+            for (int i = s.length - 1; i >= 0; i--) {\n+                double4(result, t0, t1, t2, t3, t4);\n+\n+                int high = (0xFF & s[i]) >>> 4;\n+                PointMultiplier.lookup(pointMultiples, high, lookupResult);\n+                ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+\n+                double4(result, t0, t1, t2, t3, t4);\n+\n+                int low = 0xF & s[i];\n+                PointMultiplier.lookup(pointMultiples, low, lookupResult);\n+                ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n@@ -532,7 +534,37 @@\n-            private void double4(ProjectivePoint.Mutable p,\n-                    MutableIntegerModuloP t0, MutableIntegerModuloP t1,\n-                    MutableIntegerModuloP t2, MutableIntegerModuloP t3,\n-                    MutableIntegerModuloP t4) {\n-                for (int i = 0; i < 4; i++) {\n-                    ecOps.setDouble(p, t0, t1, t2, t3, t4);\n-                }\n+            return result;\n+        }\n+\n+        private void double4(ProjectivePoint.Mutable p,\n+                MutableIntegerModuloP t0, MutableIntegerModuloP t1,\n+                MutableIntegerModuloP t2, MutableIntegerModuloP t3,\n+                MutableIntegerModuloP t4) {\n+            for (int i = 0; i < 4; i++) {\n+                ecOps.setDouble(p, t0, t1, t2, t3, t4);\n+            }\n+        }\n+    }\n+\n+    \/\/ Represents a multiplier with a larger precomputed table. Intended to be\n+    \/\/ used for Basepoint multiplication\n+    final static class Secp256R1GeneratorMontgomeryMultiplier\n+        implements PointMultiplier {\n+        private static final ECOperations secp256r1Ops = new ECOperations(\n+            MontgomeryIntegerPolynomialP256.ONE.getElement(\n+                    CurveDB.P_256.getCurve().getB()), P256OrderField.ONE);\n+        public static final AffinePoint generator = AffinePoint.fromECPoint(\n+            CurveDB.P_256.getGenerator(), secp256r1Ops.getField());\n+        public static final PointMultiplier multiplier =\n+            new Secp256R1GeneratorMontgomeryMultiplier();\n+\n+        private final ImmutableIntegerModuloP zero;\n+        private final ImmutableIntegerModuloP one;\n+        private final ProjectivePoint.Immutable[][] points;\n+        private final BigInteger[] base;\n+\n+        private Secp256R1GeneratorMontgomeryMultiplier() {\n+            this(MontgomeryIntegerPolynomialP256.ONE,\n+                new DefaultMultiplier(secp256r1Ops, generator));\n+\n+            \/\/ Check that the tables are correctly generated.\n+            if (ECOperations.class.desiredAssertionStatus()) {\n+                verifyTables(this);\n@@ -542,35 +574,52 @@\n-        final class Secp256R1GeneratorMultiplier implements PointMultiplier {\n-            private static final ECPoint generator =\n-                    CurveDB.P_256.getGenerator();\n-            private static final PointMultiplier multiplier =\n-                    new Secp256R1GeneratorMultiplier();\n-\n-            private static final ImmutableIntegerModuloP zero =\n-                    IntegerPolynomialP256.ONE.get0();\n-            private static final ImmutableIntegerModuloP one =\n-                    IntegerPolynomialP256.ONE.get1();\n-\n-            @Override\n-            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n-                MutableIntegerModuloP t0 = zero.mutable();\n-                MutableIntegerModuloP t1 = zero.mutable();\n-                MutableIntegerModuloP t2 = zero.mutable();\n-                MutableIntegerModuloP t3 = zero.mutable();\n-                MutableIntegerModuloP t4 = zero.mutable();\n-\n-                ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n-                        zero.mutable(),\n-                        one.mutable(),\n-                        zero.mutable());\n-                ProjectivePoint.Mutable r = d.mutable();\n-                for (int i = 15; i >= 0; i--) {\n-                    secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n-                    for (int j = 3; j >= 0; j--) {\n-                        int pos = i + j * 16;\n-                        int index = (bit(s, pos + 192) << 3) |\n-                                    (bit(s, pos + 128) << 2) |\n-                                    (bit(s, pos +  64) << 1) |\n-                                     bit(s, pos);\n-\n-                        lookup(P256.points[j], index, r);\n-                        secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n+        private Secp256R1GeneratorMontgomeryMultiplier(\n+            IntegerFieldModuloP field, PointMultiplier smallTableMultiplier) {\n+            zero = field.get0();\n+            one = field.get1();\n+\n+            \/\/ Pre-computed table to speed up the point multiplication.\n+            \/\/\n+            \/\/ This is a 4x16 array of ProjectivePoint.Immutable elements.\n+            \/\/ The first row contains the following multiples of the\n+            \/\/ generator.\n+            \/\/\n+            \/\/ index   |    point\n+            \/\/ --------+----------------\n+            \/\/ 0x0000  | 0G\n+            \/\/ 0x0001  | 1G\n+            \/\/ 0x0002  | (2^64)G\n+            \/\/ 0x0003  | (2^64 + 1)G\n+            \/\/ 0x0004  | 2^128G\n+            \/\/ 0x0005  | (2^128 + 1)G\n+            \/\/ 0x0006  | (2^128 + 2^64)G\n+            \/\/ 0x0007  | (2^128 + 2^64 + 1)G\n+            \/\/ 0x0008  | 2^192G\n+            \/\/ 0x0009  | (2^192 + 1)G\n+            \/\/ 0x000A  | (2^192 + 2^64)G\n+            \/\/ 0x000B  | (2^192 + 2^64 + 1)G\n+            \/\/ 0x000C  | (2^192 + 2^128)G\n+            \/\/ 0x000D  | (2^192 + 2^128 + 1)G\n+            \/\/ 0x000E  | (2^192 + 2^128 + 2^64)G\n+            \/\/ 0x000F  | (2^192 + 2^128 + 2^64 + 1)G\n+            \/\/\n+            \/\/ For the other 3 rows, points[i][j] = 2^16 * (points[i-1][j].\n+\n+            \/\/ Generate the pre-computed tables.  This block may be\n+            \/\/ replaced with hard-coded tables in order to speed up\n+            \/\/ the class loading.\n+            points = new ProjectivePoint.Immutable[4][16];\n+            BigInteger[] factors = new BigInteger[] {\n+                    BigInteger.ONE,\n+                    BigInteger.TWO.pow(64),\n+                    BigInteger.TWO.pow(128),\n+                    BigInteger.TWO.pow(192)\n+            };\n+\n+            base = new BigInteger[16];\n+            base[0] = BigInteger.ZERO;\n+            base[1] = BigInteger.ONE;\n+            base[2] = factors[1];\n+            for (int i = 3; i < 16; i++) {\n+                base[i] = BigInteger.ZERO;\n+                for (int k = 0; k < 4; k++) {\n+                    if (((i >>> k) & 0x01) != 0) {\n+                        base[i] = base[i].add(factors[k]);\n@@ -579,0 +628,1 @@\n+            }\n@@ -580,1 +630,16 @@\n-                return d;\n+            for (int d = 0; d < 4; d++) {\n+                for (int w = 0; w < 16; w++) {\n+                    BigInteger bi = base[w];\n+                    if (d != 0) {\n+                        bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                    }\n+                    if (w == 0) {\n+                        points[d][0] = new ProjectivePoint.Immutable(\n+                            zero.fixed(), one.fixed(), zero.fixed());\n+                    } else {\n+                        byte[] s = bi.toByteArray();\n+                        ArrayUtil.reverse(s);\n+                        ProjectivePoint.Mutable m = smallTableMultiplier.pointMultiply(s);\n+                        points[d][w] = m.fixed();\n+                    }\n+                }\n@@ -582,0 +647,1 @@\n+        }\n@@ -583,2 +649,24 @@\n-            private static int bit(byte[] k, int i) {\n-                return (k[i >> 3] >> (i & 0x07)) & 0x01;\n+        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n+\n+            ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n+                    zero.mutable(),\n+                    one.mutable(),\n+                    zero.mutable());\n+            ProjectivePoint.Mutable r = d.mutable();\n+            for (int i = 15; i >= 0; i--) {\n+                secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n+                for (int j = 3; j >= 0; j--) {\n+                    int pos = i + j * 16;\n+                    int index = (bit(s, pos + 192) << 3) |\n+                                (bit(s, pos + 128) << 2) |\n+                                (bit(s, pos +  64) << 1) |\n+                                    bit(s, pos);\n+\n+                    PointMultiplier.lookup(points[j], index, r);\n+                    secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n+                }\n@@ -587,54 +675,2 @@\n-            \/\/ Lazy loading of the tables.\n-            private static final class P256 {\n-                \/\/ Pre-computed table to speed up the point multiplication.\n-                \/\/\n-                \/\/ This is a 4x16 array of ProjectivePoint.Immutable elements.\n-                \/\/ The first row contains the following multiples of the\n-                \/\/ generator.\n-                \/\/\n-                \/\/ index   |    point\n-                \/\/ --------+----------------\n-                \/\/ 0x0000  | 0G\n-                \/\/ 0x0001  | 1G\n-                \/\/ 0x0002  | (2^64)G\n-                \/\/ 0x0003  | (2^64 + 1)G\n-                \/\/ 0x0004  | 2^128G\n-                \/\/ 0x0005  | (2^128 + 1)G\n-                \/\/ 0x0006  | (2^128 + 2^64)G\n-                \/\/ 0x0007  | (2^128 + 2^64 + 1)G\n-                \/\/ 0x0008  | 2^192G\n-                \/\/ 0x0009  | (2^192 + 1)G\n-                \/\/ 0x000A  | (2^192 + 2^64)G\n-                \/\/ 0x000B  | (2^192 + 2^64 + 1)G\n-                \/\/ 0x000C  | (2^192 + 2^128)G\n-                \/\/ 0x000D  | (2^192 + 2^128 + 1)G\n-                \/\/ 0x000E  | (2^192 + 2^128 + 2^64)G\n-                \/\/ 0x000F  | (2^192 + 2^128 + 2^64 + 1)G\n-                \/\/\n-                \/\/ For the other 3 rows, points[i][j] = 2^16 * (points[i-1][j].\n-                private static final ProjectivePoint.Immutable[][] points;\n-\n-                \/\/ Generate the pre-computed tables.  This block may be\n-                \/\/ replaced with hard-coded tables in order to speed up\n-                \/\/ the class loading.\n-                static {\n-                    points = new ProjectivePoint.Immutable[4][16];\n-                    BigInteger[] factors = new BigInteger[] {\n-                            BigInteger.ONE,\n-                            BigInteger.TWO.pow(64),\n-                            BigInteger.TWO.pow(128),\n-                            BigInteger.TWO.pow(192)\n-                    };\n-\n-                    BigInteger[] base = new BigInteger[16];\n-                    base[0] = BigInteger.ZERO;\n-                    base[1] = BigInteger.ONE;\n-                    base[2] = factors[1];\n-                    for (int i = 3; i < 16; i++) {\n-                        base[i] = BigInteger.ZERO;\n-                        for (int k = 0; k < 4; k++) {\n-                            if (((i >>> k) & 0x01) != 0) {\n-                                base[i] = base[i].add(factors[k]);\n-                            }\n-                        }\n-                    }\n+            return d;\n+        }\n@@ -642,21 +678,3 @@\n-                    for (int d = 0; d < 4; d++) {\n-                        for (int w = 0; w < 16; w++) {\n-                            BigInteger bi = base[w];\n-                            if (d != 0) {\n-                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n-                            }\n-                            if (w == 0) {\n-                                points[d][0] = new ProjectivePoint.Immutable(\n-                                    zero.fixed(), one.fixed(), zero.fixed());\n-                            } else {\n-                                PointMultiplier multiplier = new Default(\n-                                    secp256r1Ops, AffinePoint.fromECPoint(\n-                                        generator, zero.getField()));\n-                                byte[] s = bi.toByteArray();\n-                                ArrayUtil.reverse(s);\n-                                ProjectivePoint.Mutable m =\n-                                        multiplier.pointMultiply(s);\n-                                points[d][w] = m.setValue(m.asAffine()).fixed();\n-                            }\n-                        }\n-                    }\n+        private static int bit(byte[] k, int i) {\n+            return (k[i >> 3] >> (i & 0x07)) & 0x01;\n+        }\n@@ -664,3 +682,6 @@\n-                    \/\/ Check that the tables are correctly generated.\n-                    if (ECOperations.class.desiredAssertionStatus()) {\n-                        verifyTables(base);\n+        protected void verifyTables(PointMultiplier multiplier) {\n+            for (int d = 0; d < 4; d++) {\n+                for (int w = 0; w < 16; w++) {\n+                    BigInteger bi = base[w];\n+                    if (d != 0) {\n+                        bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n@@ -668,26 +689,13 @@\n-                }\n-\n-                private static void verifyTables(BigInteger[] base) {\n-                    for (int d = 0; d < 4; d++) {\n-                        for (int w = 0; w < 16; w++) {\n-                            BigInteger bi = base[w];\n-                            if (d != 0) {\n-                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n-                            }\n-                            if (w != 0) {\n-                                byte[] s = new byte[32];\n-                                byte[] b = bi.toByteArray();\n-                                ArrayUtil.reverse(b);\n-                                System.arraycopy(b, 0, s, 0, b.length);\n-\n-                                ProjectivePoint.Mutable m =\n-                                        multiplier.pointMultiply(s);\n-                                ProjectivePoint.Immutable v =\n-                                        m.setValue(m.asAffine()).fixed();\n-                                if (!v.getX().asBigInteger().equals(\n-                                        points[d][w].getX().asBigInteger()) ||\n-                                    !v.getY().asBigInteger().equals(\n-                                        points[d][w].getY().asBigInteger())) {\n-                                    throw new RuntimeException();\n-                                }\n-                            }\n+                    if (w != 0) {\n+                        byte[] s = new byte[32];\n+                        byte[] b = bi.toByteArray();\n+                        ArrayUtil.reverse(b);\n+                        System.arraycopy(b, 0, s, 0, b.length);\n+\n+                        \/\/ Compare this multiplier to the table\n+                        \/\/ (generated by Default multiplier)\n+                        AffinePoint m = multiplier.pointMultiply(s).asAffine();\n+                        AffinePoint v = points[d][w].asAffine();\n+                        if (!m.equals(v)) {\n+                            java.util.HexFormat hex = java.util.HexFormat.of();\n+                            throw new RuntimeException();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":256,"deletions":248,"binary":false,"changes":504,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n@@ -57,1 +58,1 @@\n-        return new ECPoint(x.asBigInteger(), y.asBigInteger());\n+        return new ECPoint(getX().asBigInteger(), getY().asBigInteger());\n@@ -61,0 +62,8 @@\n+        return getX(true);\n+    }\n+\n+    public ImmutableIntegerModuloP getX(boolean fieldCheck) {\n+        IntegerFieldModuloP field = x.getField();\n+        if (fieldCheck && field instanceof IntegerMontgomeryFieldModuloP) {\n+            return ((IntegerMontgomeryFieldModuloP)field).fromMontgomery(x);\n+        }\n@@ -65,0 +74,8 @@\n+        return getY(true);\n+    }\n+\n+    public ImmutableIntegerModuloP getY(boolean fieldCheck) {\n+        IntegerFieldModuloP field = y.getField();\n+        if (fieldCheck && field instanceof IntegerMontgomeryFieldModuloP) {\n+            return ((IntegerMontgomeryFieldModuloP)field).fromMontgomery(y);\n+        }\n@@ -74,2 +91,24 @@\n-        boolean xEquals = x.asBigInteger().equals(p.x.asBigInteger());\n-        boolean yEquals = y.asBigInteger().equals(p.y.asBigInteger());\n+        boolean xEquals, yEquals;\n+        boolean thisMont = x.getField() instanceof IntegerMontgomeryFieldModuloP;\n+        boolean objMont = p.x.getField() instanceof IntegerMontgomeryFieldModuloP;\n+        if (thisMont ^ objMont == false) {\n+            \/\/ both fields same\n+            xEquals = x.asBigInteger().equals(p.x.asBigInteger());\n+            yEquals = y.asBigInteger().equals(p.y.asBigInteger());\n+        } else if (thisMont) {\n+            \/\/ mismatched fields should not happen in production, but useful in\n+            \/\/ testing\n+            IntegerMontgomeryFieldModuloP field =\n+                (IntegerMontgomeryFieldModuloP)x.getField();\n+            xEquals = x.asBigInteger().equals(\n+                field.getElement(p.x.asBigInteger()).asBigInteger());\n+            yEquals = y.asBigInteger().equals(\n+                field.getElement(p.y.asBigInteger()).asBigInteger());\n+        } else {\n+            IntegerMontgomeryFieldModuloP field =\n+                (IntegerMontgomeryFieldModuloP)p.x.getField();\n+            xEquals = field.getElement(\n+                x.asBigInteger()).asBigInteger().equals(p.x.asBigInteger());\n+            yEquals = field.getElement(\n+                y.asBigInteger()).asBigInteger().equals(p.y.asBigInteger());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/AffinePoint.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -148,0 +149,1 @@\n+        @ForceInline\n@@ -160,3 +162,3 @@\n-            x.setValue(p.getX());\n-            y.setValue(p.getY());\n-            z.setValue(p.getX().getField().get1());\n+            x.setValue(p.getX(false));\n+            y.setValue(p.getY(false));\n+            z.setValue(p.getX(false).getField().get1());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/ProjectivePoint.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util.math;\n+\n+import java.math.BigInteger;\n+\n+\/**\n+ * An interface for the field of integers modulo a prime number. An\n+ * implementation of this interface can be used to get properties of the\n+ * field and to produce field elements of type ImmutableIntegerModuloP from\n+ * other objects and representations of field elements.\n+ *\/\n+\n+public interface IntegerMontgomeryFieldModuloP extends IntegerFieldModuloP {\n+    ImmutableIntegerModuloP fromMontgomery(ImmutableIntegerModuloP m);\n+    IntegerFieldModuloP residueField();\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/IntegerMontgomeryFieldModuloP.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n@@ -65,4 +68,3 @@\n-            IntegerPolynomialP384, IntegerPolynomialP521,\n-            IntegerPolynomialModBinP, P256OrderField,\n-            P384OrderField, P521OrderField,\n-            Curve25519OrderField,\n+            MontgomeryIntegerPolynomialP256, IntegerPolynomialP384,\n+            IntegerPolynomialP521, IntegerPolynomialModBinP, P256OrderField,\n+            P384OrderField, P521OrderField, Curve25519OrderField,\n@@ -77,1 +79,2 @@\n-    private final int maxAdds;\n+    private final int maxAddsMul; \/\/ max additions before a multiplication\n+    private final int maxAddsAdd; \/\/ max additions before an addition\n@@ -90,1 +93,1 @@\n-    protected void multByInt(long[] a, long b) {\n+    protected int multByInt(long[] a, long b) {\n@@ -95,0 +98,1 @@\n+        return 0;\n@@ -103,1 +107,1 @@\n-    protected abstract void mult(long[] a, long[] b, long[] r);\n+    protected abstract int mult(long[] a, long[] b, long[] r);\n@@ -111,1 +115,1 @@\n-    protected abstract void square(long[] a, long[] r);\n+    protected abstract int square(long[] a, long[] r);\n@@ -115,1 +119,1 @@\n-                      int maxAdds,\n+                      int maxAddsMul,\n@@ -122,2 +126,6 @@\n-        this.maxAdds = maxAdds;\n-\n+        this.maxAddsMul = maxAddsMul;\n+        if (bitsPerLimb>32) {\n+            this.maxAddsAdd = 64 - bitsPerLimb;\n+        } else {\n+            this.maxAddsAdd = 32 - bitsPerLimb;\n+        }\n@@ -138,1 +146,1 @@\n-        return maxAdds;\n+        return maxAddsMul;\n@@ -330,1 +338,0 @@\n-        assert bitsPerLimb < 32;\n@@ -333,1 +340,1 @@\n-            limbs[i] = v.intValue() & limbMask;\n+            limbs[i] = v.longValue() & limbMask;\n@@ -452,0 +459,2 @@\n+    @ForceInline\n+    @IntrinsicCandidate\n@@ -560,2 +569,1 @@\n-            \/\/ if (numAdds >= maxAdds) {\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -566,2 +574,1 @@\n-            \/\/ if (b.numAdds >= maxAdds) {\n-            if (b.numAdds > 32 - bitsPerLimb) {\n+            if (b.numAdds > maxAddsAdd) {\n@@ -589,1 +596,1 @@\n-            return new ImmutableElement(newLimbs, numAdds);\n+            return new ImmutableElement(newLimbs, numAdds+1);\n@@ -607,1 +614,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -612,1 +619,1 @@\n-            if (b.numAdds > maxAdds) {\n+            if (b.numAdds > maxAddsMul) {\n@@ -618,2 +625,2 @@\n-            mult(limbs, b.limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, 0);\n+            int numAdds = mult(limbs, b.limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, numAdds);\n@@ -625,1 +632,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -631,2 +638,2 @@\n-            IntegerPolynomial.this.square(limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, 0);\n+            int numAdds = IntegerPolynomial.this.square(limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, numAdds);\n@@ -640,1 +647,1 @@\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -645,1 +652,1 @@\n-            if (other.numAdds > 32 - bitsPerLimb) {\n+            if (other.numAdds > maxAddsAdd) {\n@@ -737,1 +744,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -742,1 +749,1 @@\n-            if (b.numAdds > maxAdds) {\n+            if (b.numAdds > maxAddsMul) {\n@@ -747,2 +754,1 @@\n-            mult(limbs, b.limbs, limbs);\n-            numAdds = 0;\n+            numAdds = mult(limbs, b.limbs, limbs);\n@@ -755,1 +761,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -761,2 +767,1 @@\n-            multByInt(limbs, value);\n-            numAdds = 0;\n+            numAdds += multByInt(limbs, value);\n@@ -772,2 +777,1 @@\n-            \/\/ if (numAdds >= maxAdds) {\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -778,2 +782,1 @@\n-            \/\/ if (b.numAdds >= maxAdds) {\n-            if (b.numAdds > 32 - bitsPerLimb) {\n+            if (b.numAdds > maxAddsAdd) {\n@@ -798,2 +801,1 @@\n-            \/\/ if (numAdds >= maxAdds) {\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -804,2 +806,1 @@\n-            \/\/ if (b.numAdds >= maxAdds) {\n-            if (b.numAdds > 32 - bitsPerLimb) {\n+            if (b.numAdds > maxAddsAdd) {\n@@ -821,1 +822,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -826,2 +827,1 @@\n-            IntegerPolynomial.this.square(limbs, limbs);\n-            numAdds = 0;\n+            numAdds = IntegerPolynomial.this.square(limbs, limbs);;\n@@ -836,0 +836,1 @@\n+            numAdds++;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":48,"deletions":47,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    protected void mult(long[] a, long[] b, long[] r) {\n+    protected int mult(long[] a, long[] b, long[] r) {\n@@ -76,0 +76,1 @@\n+        return 0;\n@@ -102,1 +103,1 @@\n-    protected void square(long[] a, long[] r) {\n+    protected int square(long[] a, long[] r) {\n@@ -125,0 +126,1 @@\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial1305.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,1 @@\n-    protected void mult(long[] a, long[] b, long[] r) {\n+    protected int mult(long[] a, long[] b, long[] r) {\n@@ -139,0 +139,1 @@\n+        return 0;\n@@ -191,1 +192,1 @@\n-    protected void square(long[] a, long[] r) {\n+    protected int square(long[] a, long[] r) {\n@@ -202,1 +203,1 @@\n-\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialModBinP.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,560 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util.math.intpoly;\n+\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.SmallValue;\n+import sun.security.util.math.IntegerFieldModuloP;\n+import java.lang.Math;\n+import java.math.BigInteger;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/\/ Reference:\n+\/\/ - [1] Shay Gueron and Vlad Krasnov \"Fast Prime Field Elliptic Curve\n+\/\/       Cryptography with 256 Bit Primes\"\n+\/\/\n+public final class MontgomeryIntegerPolynomialP256 extends IntegerPolynomial\n+        implements IntegerMontgomeryFieldModuloP {\n+    private static final int BITS_PER_LIMB = 52;\n+    private static final int NUM_LIMBS = 5;\n+    private static final int MAX_ADDS = 0;\n+    public static final BigInteger MODULUS = evaluateModulus();\n+    private static final long LIMB_MASK = -1L >>> (64 - BITS_PER_LIMB);\n+\n+    public static final MontgomeryIntegerPolynomialP256 ONE = new MontgomeryIntegerPolynomialP256();\n+\n+    \/\/ h = 2^(2*260)%p = 0x4fffffffdfffffffffffffffefffffffbffffffff000000000000000300\n+    \/\/ oneActual = 1\n+    \/\/ oneMont = (1*2^260) mod p\n+    \/\/ modulus = p\n+    private static final long[] h = new long[] {\n+        0x0000000000000300L, 0x000ffffffff00000L, 0x000ffffefffffffbL,\n+        0x000fdfffffffffffL, 0x0000000004ffffffL };\n+    private static final long[] oneActual = new long[] {\n+        0x0000000000000001L, 0x0000000000000000L, 0x0000000000000000L,\n+        0x0000000000000000L, 0x0000000000000000L };\n+    private static final long[] oneMont = new long[] {\n+        0x0000000000000010L, 0x000f000000000000L, 0x000fffffffffffffL,\n+        0x000ffeffffffffffL, 0x00000000000fffffL };\n+    private static final long[] zero = new long[] {\n+        0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,\n+        0x0000000000000000L, 0x0000000000000000L };\n+    private static final long[] modulus = new long[] {\n+        0x000fffffffffffffL, 0x00000fffffffffffL, 0x0000000000000000L,\n+        0x0000001000000000L, 0x0000ffffffff0000L };\n+\n+    private MontgomeryIntegerPolynomialP256() {\n+        super(BITS_PER_LIMB, NUM_LIMBS, MAX_ADDS, MODULUS);\n+    }\n+\n+    public IntegerFieldModuloP residueField() {\n+        return IntegerPolynomialP256.ONE;\n+    }\n+\n+    \/\/ (224%nat,-1)::(192%nat,1)::(96%nat,1)::(0%nat,-1)::nil.\n+    private static BigInteger evaluateModulus() {\n+        BigInteger result = BigInteger.valueOf(2).pow(256);\n+        result = result.subtract(BigInteger.valueOf(1).shiftLeft(224));\n+        result = result.add(BigInteger.valueOf(1).shiftLeft(192));\n+        result = result.add(BigInteger.valueOf(1).shiftLeft(96));\n+        result = result.subtract(BigInteger.valueOf(1));\n+        return result;\n+    }\n+\n+    @Override\n+    public ImmutableElement get0() {\n+        return new ImmutableElement(zero, 0);\n+    }\n+\n+    \/\/ One in montgomery domain: (1*2^260) mod p\n+    @Override\n+    public ImmutableElement get1() {\n+        return new ImmutableElement(oneMont, 0);\n+    }\n+\n+    \/\/ Convert v to Montgomery domain\n+    @Override\n+    public ImmutableElement getElement(BigInteger v) {\n+        long[] vLimbs = new long[NUM_LIMBS];\n+        long[] montLimbs = new long[NUM_LIMBS];\n+        setLimbsValuePositive(v, vLimbs);\n+\n+        \/\/ Convert to Montgomery domain\n+        int numAdds = mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, numAdds);\n+    }\n+\n+    @Override\n+    public SmallValue getSmallValue(int value) {\n+        \/\/ Explicitely here as reminder that SmallValue stays in residue domain\n+        \/\/ See multByInt below for how this is used\n+        return super.getSmallValue(value);\n+    }\n+\n+    \/*\n+     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to\n+     * multiply by a small constant (i.e. (int) 1,2,3,4). Instead of doing a\n+     * montgomery conversion followed by a montgomery multiplication, just use\n+     * the spare top (64-BITS_PER_LIMB) bits to multiply by a constant. (See [1]\n+     * Section 4 )\n+     *\n+     * Will return an unreduced value\n+     *\/\n+    @Override\n+    protected int multByInt(long[] a, long b) {\n+        assert (b < (1 << BITS_PER_LIMB));\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] *= b;\n+        }\n+        return (int) (b - 1);\n+    }\n+\n+    @Override\n+    public ImmutableIntegerModuloP fromMontgomery(ImmutableIntegerModuloP n) {\n+        assert n.getField() == MontgomeryIntegerPolynomialP256.ONE;\n+\n+        ImmutableElement nn = (ImmutableElement) n;\n+        long[] r1 = new long[NUM_LIMBS];\n+        long[] r2 = new long[2 * NUM_LIMBS];\n+        long[] limbs = nn.getLimbs();\n+        reduce(limbs);\n+        MontgomeryIntegerPolynomialP256.ONE.mult(limbs, oneActual, r1);\n+        reduce(r1);\n+        halfLimbs(r1, r2);\n+        return IntegerPolynomialP256.ONE.new ImmutableElement(r2, 0);\n+    }\n+\n+    private void halfLimbs(long[] a, long[] r) {\n+        final long HALF_BITS_LIMB = BITS_PER_LIMB \/ 2;\n+        final long HALF_LIMB_MASK = -1L >>> (64 - HALF_BITS_LIMB);\n+        r[0] = a[0] & HALF_LIMB_MASK;\n+        r[1] = a[0] >> HALF_BITS_LIMB;\n+        r[2] = a[1] & HALF_LIMB_MASK;\n+        r[3] = a[1] >> HALF_BITS_LIMB;\n+        r[4] = a[2] & HALF_LIMB_MASK;\n+        r[5] = a[2] >> HALF_BITS_LIMB;\n+        r[6] = a[3] & HALF_LIMB_MASK;\n+        r[7] = a[3] >> HALF_BITS_LIMB;\n+        r[8] = a[4] & HALF_LIMB_MASK;\n+        r[9] = a[4] >> HALF_BITS_LIMB;\n+    }\n+\n+    @Override\n+    protected int square(long[] a, long[] r) {\n+        return mult(a, a, r);\n+    }\n+\n+    \/**\n+     * Unrolled Word-by-Word Montgomery Multiplication r = a * b * 2^-260 (mod P)\n+     *\n+     * See [1] Figure 5. \"Algorithm 2: Word-by-Word Montgomery Multiplication\n+     * for a Montgomery Friendly modulus p\". Note: Step 6. Skipped; Instead use\n+     * numAdds to reuse existing overflow logic.\n+     *\/\n+    @IntrinsicCandidate\n+    protected int mult(long[] a, long[] b, long[] r) {\n+        long aa0 = a[0];\n+        long aa1 = a[1];\n+        long aa2 = a[2];\n+        long aa3 = a[3];\n+        long aa4 = a[4];\n+\n+        long bb0 = b[0];\n+        long bb1 = b[1];\n+        long bb2 = b[2];\n+        long bb3 = b[3];\n+        long bb4 = b[4];\n+\n+        final long shift1 = 64 - BITS_PER_LIMB; \/\/ 12\n+        final long shift2 = BITS_PER_LIMB; \/\/ 40\n+\n+        long d0, d1, d2, d3, d4;      \/\/ low digits from multiplication\n+        long dd0, dd1, dd2, dd3, dd4; \/\/ high digits from multiplication\n+        long n, n0, n1, n2, n3, n4,\n+            nn0, nn1, nn2, nn3, nn4; \/\/ modulus multiple digits\n+        long c0, c1, c2, c3, c4, c5, c6, c7, c8, c9; \/\/ multiplication result\n+                                                     \/\/ digits for each column\n+\n+        \/\/ Row 0 - multiply by aa0 and reduce out c0\n+        d0 = aa0 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa0, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        n = d0;\n+        d1 = aa0 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa0, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa0 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa0, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa0 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa0, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa0 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa0, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        nn0 = Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        n0 &= LIMB_MASK;\n+        n1 = n * modulus[1];\n+        nn1 = Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        n1 &= LIMB_MASK;\n+        n2 = n * modulus[2];\n+        nn2 = Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        n2 &= LIMB_MASK;\n+        n3 = n * modulus[3];\n+        nn3 = Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        n3 &= LIMB_MASK;\n+        n4 = n * modulus[4];\n+        nn4 = Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        n4 &= LIMB_MASK;\n+\n+        dd0 += nn0;\n+        d0 += n0;\n+        dd1 += nn1;\n+        d1 += n1;\n+        dd2 += nn2;\n+        d2 += n2;\n+        dd3 += nn3;\n+        d3 += n3;\n+        dd4 += nn4;\n+        d4 += n4;\n+\n+        c1 = d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c2 = d2 + dd1;\n+        c3 = d3 + dd2;\n+        c4 = d4 + dd3;\n+        c5 = dd4;\n+\n+        \/\/ Row 1 - multiply by aa1 and reduce out c1\n+        d0 = aa1 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa1, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c1;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa1 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa1, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa1 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa1, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa1 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa1, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa1 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa1, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n+\n+        c2 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c3 += d2 + dd1;\n+        c4 += d3 + dd2;\n+        c5 += d4 + dd3;\n+        c6 = dd4;\n+\n+        \/\/ Row 2 - multiply by aa2 and reduce out c2\n+        d0 = aa2 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa2, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c2;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa2 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa2, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa2 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa2, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa2 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa2, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa2 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa2, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n+\n+        c3 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c4 += d2 + dd1;\n+        c5 += d3 + dd2;\n+        c6 += d4 + dd3;\n+        c7 = dd4;\n+\n+        \/\/ Row 3 - multiply by aa3 and reduce out c3\n+        d0 = aa3 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa3, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c3;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa3 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa3, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa3 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa3, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa3 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa3, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa3 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa3, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n+\n+        c4 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c5 += d2 + dd1;\n+        c6 += d3 + dd2;\n+        c7 += d4 + dd3;\n+        c8 = dd4;\n+\n+        \/\/ Row 4 - multiply by aa3 and reduce out c4\n+        d0 = aa4 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa4, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c4;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa4 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa4, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa4 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa4, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa4 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa4, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa4 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa4, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n+\n+        c5 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c6 += d2 + dd1 + (c5 >>> BITS_PER_LIMB);\n+        c7 += d3 + dd2 + (c6 >>> BITS_PER_LIMB);\n+        c8 += d4 + dd3 + (c7 >>> BITS_PER_LIMB);\n+        c9 = dd4 + (c8 >>> BITS_PER_LIMB);\n+\n+        c5 &= LIMB_MASK;\n+        c6 &= LIMB_MASK;\n+        c7 &= LIMB_MASK;\n+        c8 &= LIMB_MASK;\n+\n+        \/\/ At this point, the result could overflow by one modulus.\n+        c0 = c5 - modulus[0];\n+        c1 = c6 - modulus[1] + (c0 >> BITS_PER_LIMB);\n+        c0 &= LIMB_MASK;\n+        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        c1 &= LIMB_MASK;\n+        c3 = c8 - modulus[3] + (c2 >> BITS_PER_LIMB);\n+        c2 &= LIMB_MASK;\n+        c4 = c9 - modulus[4] + (c3 >> BITS_PER_LIMB);\n+        c3 &= LIMB_MASK;\n+\n+        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        r[0] = ((c5 & mask) | (c0 & ~mask));\n+        r[1] = ((c6 & mask) | (c1 & ~mask));\n+        r[2] = ((c7 & mask) | (c2 & ~mask));\n+        r[3] = ((c8 & mask) | (c3 & ~mask));\n+        r[4] = ((c9 & mask) | (c4 & ~mask));\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    protected void finalCarryReduceLast(long[] limbs) {\n+        reduce(limbs);\n+    }\n+\n+    @Override\n+    protected long carryValue(long x) {\n+        return x >> BITS_PER_LIMB;\n+    }\n+\n+    @Override\n+    protected void postEncodeCarry(long[] v) {\n+        \/\/ not needed because carry is unsigned\n+    }\n+\n+    \/\/ Proof:\n+    \/\/ carry * 2^256 (mod p) ==  carry * [2^256 - p] (mod p)\n+    \/\/                       ==  carry * [2^256 - (2^256 -2^224 +2^192 +2^96 -1)] (mod p)\n+    \/\/                       ==  carry * [2^224 -2^192 -2^96 +1] (mod p)\n+    @Override\n+    protected void reduce(long[] limbs) {\n+        long b0 = limbs[0];\n+        long b1 = limbs[1];\n+        long b2 = limbs[2];\n+        long b3 = limbs[3];\n+        long b4 = limbs[4];\n+        long carry = b4 >> 48; \/\/ max 16-bits\n+        b4 -= carry << 48;\n+\n+        \/\/ 2^0 position\n+        b0 += carry;\n+        \/\/ -2^96\n+        b1 -= carry << 44;\n+        \/\/ -2^192\n+        b3 -= carry << 36;\n+        \/\/ 2^224\n+        b4 += carry << 16;\n+\n+        b1 += b0 >> BITS_PER_LIMB;\n+        b2 += b1 >> BITS_PER_LIMB;\n+        b3 += b2 >> BITS_PER_LIMB;\n+        b4 += b3 >> BITS_PER_LIMB;\n+\n+        b0 &= LIMB_MASK;\n+        b1 &= LIMB_MASK;\n+        b2 &= LIMB_MASK;\n+        b3 &= LIMB_MASK;\n+\n+        long c0, c1, c2, c3, c4;\n+        c0 = modulus[0] + b0;\n+        c1 = modulus[1] + b1 + (c0 >> BITS_PER_LIMB);\n+        c0 &= LIMB_MASK;\n+        c2 = modulus[2] + b2 + (c1 >> BITS_PER_LIMB);\n+        c1 &= LIMB_MASK;\n+        c3 = modulus[3] + b3 + (c2 >> BITS_PER_LIMB);\n+        c2 &= LIMB_MASK;\n+        c4 = modulus[4] + b4 + (c3 >> BITS_PER_LIMB);\n+        c3 &= LIMB_MASK;\n+\n+        long mask = b4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        limbs[0] = (b0 & ~mask) | (c0 & mask);\n+        limbs[1] = (b1 & ~mask) | (c1 & mask);\n+        limbs[2] = (b2 & ~mask) | (c2 & mask);\n+        limbs[3] = (b3 & ~mask) | (c3 & mask);\n+        limbs[4] = (b4 & ~mask) | (c4 & mask);\n+    }\n+\n+    public ImmutableElement getElement(byte[] v, int offset, int length,\n+            byte highByte) {\n+\n+        long[] vLimbs = new long[NUM_LIMBS];\n+        long[] montLimbs = new long[NUM_LIMBS];\n+        super.encode(v, offset, length, highByte, vLimbs);\n+\n+        \/\/ Convert to Montgomery domain\n+        int numAdds = mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, numAdds);\n+    }\n+\n+    \/*\n+     * This function 'moves\/reduces' digit 'v' to the 'lower' limbs\n+     *\n+     * The result is not reduced further. Carry propagation is not performed\n+     * (see IntegerPolynomial.reduceHigh() for how this method is used)\n+     *\n+     * Proof:\n+     *   v * 2^(i*52) (mod p) ==  v * 2^(52i) - v * 2^(52i-256) * p                               (mod p)\n+     *                        ==  v * 2^(52i) - v * 2^(52i-256) * (2^256 -2^224 +2^192 +2^96 -1)  (mod p)\n+     *                        ==  v * 2^(52i) - v * [2^(52i-256+256) -2^(52i-256+224) +2^(52i-256+192) +2^(52i-256+96) -2^(52i-256)] (mod p)\n+     *                        ==  v * 2^(52i) - v * [2^(52i) -2^(52i-32) +2^(52i-64) +2^(52i-160) -2^(52i-256)]                      (mod p)\n+     *\n+     *                        ==  v * [2^(52i-32) +2^(52i-52-12) +2^(52i-3*52-4) -2^(52i-4*52-48)] (mod p)\n+     *\/\n+    @Override\n+    protected void reduceIn(long[] limbs, long v, int i) {\n+        \/\/ Since top term (2^(52i-32)) will leave top 20 bits back in the same\n+        \/\/ position i,\n+        \/\/ \"repeat same reduction on top 20 bits\"\n+        v += v >> 32;\n+\n+        \/\/ 2^(52i-32)\n+        limbs[i - 1] += (v << 20) & LIMB_MASK;\n+\n+        \/\/ 2^(52i-52-12)\n+        limbs[i - 2] -= (v << 40) & LIMB_MASK;\n+        limbs[i - 1] -= v >> 12;\n+\n+        \/\/ 2^(52i-3*52-4)\n+        limbs[i - 4] -= (v << 48) & LIMB_MASK;\n+        limbs[i - 3] -= v >> 4;\n+\n+        \/\/ 2^(52i-4*52-48)\n+        limbs[i - 5] += (v << 4) & LIMB_MASK;\n+        limbs[i - 4] += v >> 48;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":560,"deletions":0,"binary":false,"changes":560,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import java.math.BigInteger;\n+import java.lang.reflect.Field;\n+import java.security.spec.ECParameterSpec;\n+import sun.security.ec.ECOperations;\n+import sun.security.util.ECUtil;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.CurveDB;\n+import sun.security.ec.point.*;\n+import java.security.spec.ECPoint;\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm\/timeout=1200 --add-opens\n+ *      java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:-UseIntPolyIntrinsics ECOperationsFuzzTest\n+ * @summary Unit test ECOperationsFuzzTest.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm\/timeout=1200 --add-opens\n+ *      java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseIntPolyIntrinsics ECOperationsFuzzTest\n+ * @summary Unit test ECOperationsFuzzTest.\n+ *\/\n+\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for\n+\/\/ pseudo-random number generator. If a failure occurs, hardcode the seed to\n+\/\/ make the test case deterministic\n+public class ECOperationsFuzzTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Note: it might be useful to increase this number during development\n+        final int repeat = 10000;\n+        test(repeat);\n+        System.out.println(\"Fuzz Success\");\n+    }\n+\n+    private static void check(MutablePoint reference, MutablePoint testValue,\n+            long seed, int iter) {\n+        AffinePoint affineRef = reference.asAffine();\n+        AffinePoint affine = testValue.asAffine();\n+        if (!affineRef.equals(affine)) {\n+            throw new RuntimeException(\n+                    \"Found error with seed \" + seed + \"at iteration \" + iter);\n+        }\n+    }\n+\n+    public static void test(int repeat) throws Exception {\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n+\n+        int keySize = 256;\n+        ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n+        NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n+        ECPoint generator = curve.getGenerator();\n+        BigInteger b = curve.getCurve().getB();\n+        if (params == null || generator == null) {\n+            throw new RuntimeException(\n+                    \"No EC parameters available for key size \" + keySize + \" bits\");\n+        }\n+\n+        ECOperations ops = ECOperations.forParameters(params).get();\n+        ECOperations opsReference = new ECOperations(\n+                IntegerPolynomialP256.ONE.getElement(b), P256OrderField.ONE);\n+\n+        boolean instanceTest1 = ops\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        boolean instanceTest2 = opsReference\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        if (instanceTest1 == false || instanceTest2 == true) {\n+            throw new RuntimeException(\"Bad Initialization: [\"\n+                + instanceTest1 + \",\" + instanceTest2 + \"]\");\n+        }\n+\n+        byte[] multiple = new byte[keySize \/ 8];\n+        rnd.nextBytes(multiple);\n+        multiple[keySize\/8 - 1] &= 0x7f; \/\/ from opsReference.seedToScalar(multiple);\n+\n+        MutablePoint referencePoint = opsReference.multiply(generator, multiple);\n+        MutablePoint point = ops.multiply(generator, multiple);\n+        check(referencePoint, point, seed, -1);\n+\n+        AffinePoint refAffineGenerator = AffinePoint.fromECPoint(generator,\n+                referencePoint.getField());\n+        AffinePoint montAffineGenerator = AffinePoint.fromECPoint(generator,\n+                point.getField());\n+\n+        MutablePoint refProjGenerator = new ProjectivePoint.Mutable(\n+                refAffineGenerator.getX(false).mutable(),\n+                refAffineGenerator.getY(false).mutable(),\n+                referencePoint.getField().get1().mutable());\n+\n+        MutablePoint projGenerator = new ProjectivePoint.Mutable(\n+                montAffineGenerator.getX(false).mutable(),\n+                montAffineGenerator.getY(false).mutable(),\n+                point.getField().get1().mutable());\n+\n+        for (int i = 0; i < repeat; i++) {\n+            rnd.nextBytes(multiple);\n+            multiple[keySize\/8 - 1] &= 0x7f; \/\/ opsReference.seedToScalar(multiple);\n+\n+            MutablePoint nextReferencePoint = opsReference\n+                    .multiply(referencePoint.asAffine(), multiple);\n+            MutablePoint nextPoint = ops.multiply(point.asAffine().toECPoint(),\n+                    multiple);\n+            check(nextReferencePoint, nextPoint, seed, i);\n+\n+            if (rnd.nextBoolean()) {\n+                opsReference.setSum(nextReferencePoint, referencePoint);\n+                ops.setSum(nextPoint, point);\n+                check(nextReferencePoint, nextPoint, seed, i);\n+            }\n+\n+            if (rnd.nextBoolean()) {\n+                opsReference.setSum(nextReferencePoint, refProjGenerator);\n+                ops.setSum(nextPoint, projGenerator);\n+                check(nextReferencePoint, nextPoint, seed, i);\n+            }\n+\n+            if (rnd.nextInt(100) < 10) { \/\/ 10% Reset point to generator, test\n+                                         \/\/ generator multiplier\n+                referencePoint = opsReference.multiply(generator, multiple);\n+                point = ops.multiply(generator, multiple);\n+                check(referencePoint, point, seed, i);\n+            } else {\n+                referencePoint = nextReferencePoint;\n+                point = nextPoint;\n+            }\n+        }\n+    }\n+\n+}\n+\n+\/\/ make test TEST=\"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import java.util.List;\n+import java.util.LinkedList;\n+import java.math.BigInteger;\n+import java.lang.reflect.Field;\n+import java.security.spec.ECParameterSpec;\n+import sun.security.ec.ECOperations;\n+import sun.security.util.ECUtil;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.CurveDB;\n+import sun.security.ec.point.*;\n+import java.security.spec.ECPoint;\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm --add-opens java.base\/sun.security.ec=ALL-UNNAMED\n+ *      ECOperationsKATTest\n+ * @summary Unit test ECOperationsKATTest.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp\n+ *      -XX:-TieredCompilation --add-opens java.base\/sun.security.ec=ALL-UNNAMED\n+ *      -XX:+UnlockDiagnosticVMOptions ECOperationsKATTest\n+ * @summary Unit test ECOperationsKATTest.\n+ *\/\n+\n+ public class ECOperationsKATTest {\n+    final private static java.util.HexFormat hex = java.util.HexFormat.of();\n+\n+    public static void main(String args[]) throws Exception {\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNumber + \": \" + test.testName);\n+            if (runSingleTest(test)) {\n+                testsPassed++;\n+            }\n+        }\n+        System.out.println();\n+\n+        if (testsPassed != testNumber) {\n+            throw new RuntimeException(\n+                    \"One or more tests failed. Check output for details\");\n+        }\n+    }\n+\n+    private static boolean check(MutablePoint testValue, ECPoint reference) {\n+        AffinePoint affine = testValue.asAffine();\n+        BigInteger x = affine.getX().asBigInteger();\n+        BigInteger y = affine.getY().asBigInteger();\n+        BigInteger refX = reference.getAffineX();\n+        BigInteger refY = reference.getAffineY();\n+\n+        if (!refX.equals(x) || !refY.equals(y)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected: X: \" + refX.toString(16) + \" Y: \"\n+                    + refY.toString(16));\n+            System.out.println(\n+                    \"Result:   X: \" + x.toString(16) + \" Y: \" + y.toString(16));\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static class TestData {\n+        public TestData(String name, String keyStr, String xStr1, String yStr1,\n+                String xStr2, String yStr2) {\n+            testName = name;\n+            \/\/ multiplier = (new BigInteger(keyStr, 16)).toByteArray();\n+            multiplier = hex.parseHex(keyStr);\n+            sun.security.util.ArrayUtil.reverse(multiplier);\n+            reference1 = new ECPoint(new BigInteger(xStr1, 16),\n+                    new BigInteger(yStr1, 16));\n+            reference2 = new ECPoint(new BigInteger(xStr2, 16),\n+                    new BigInteger(yStr2, 16));\n+        }\n+\n+        String testName;\n+        byte[] multiplier;\n+        ECPoint reference1; \/\/ For generator multiplier test\n+        ECPoint reference2; \/\/ For non-generator multiplier test\n+    }\n+\n+    public static final List<TestData> testList = new LinkedList<TestData>() {{\n+    \/\/ (x1,y1) = mult*generator\n+    \/\/ (x2,y2) = mult*mult*generator\n+    add(new TestData(\"Test Vector #1\",\n+        \"0000000000000000000000000000000000000000000000000000000000000012\", \/\/ mult\n+        \"1057E0AB5780F470DEFC9378D1C7C87437BB4C6F9EA55C63D936266DBD781FDA\", \/\/ x1\n+        \"F6F1645A15CBE5DC9FA9B7DFD96EE5A7DCC11B5C5EF4F1F78D83B3393C6A45A2\", \/\/ y1\n+        \"4954047A366A91E3FD94E574DB6F2B04F3A8465883DBC55A816EA563BF54A324\", \/\/ x2\n+        \"B5A54786FD9EA48C9FC38A0557B0C4D54F285908A7291B630D06BEE970F530D3\") \/\/ y2\n+    );\n+    add(new TestData(\"Test Vector #2\",\n+        \"1200000000000000000000000000000000000000000000000000000000000000\", \/\/ mult\n+        \"DF684E6D0D57AF8B89DA11E8F7436C3D360F531D62BDCE42C5A8B72D73D5C717\", \/\/ x\n+        \"9D3576BD03C09B8F416EE9C27D70AD4A425119271ACF549312CA48758F4E1FEC\", \/\/ y\n+        \"57C8257EEAABF5446DCFACB99DEE104367B6C9950C76797C372EB177D5FA23B3\", \/\/ x\n+        \"1CD3E8A34521C1C8E574EB4B99343CAA57E00725D8618F0231C7C79AA6837725\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #3\",\n+        \"0000000000000000000000000000000120000000000000000000000000000012\", \/\/ mult\n+        \"A69DFD47B24485E5F523BDA5FBACF03F5A7C3D22E0C2BC6705594B7B051A06D0\", \/\/ x\n+        \"ECF19629416BE5C9AF1E30988F3AA8B803809CF4D12944EB49C5E9892723798A\", \/\/ y\n+        \"1E28559F5B681C308632EE11A007B9891B3FD592C982C4926153795794295E58\", \/\/ x\n+        \"3C373046C27BB34609A43C91DF6D4B9AB9EB08F3B69A8F8FAE944211D8297F30\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #4\",\n+        \"0000000000000000000000000000000000000000000000000000000000000001\", \/\/ mult\n+        \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n+        \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", \/\/ y\n+        \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n+        \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #5\",\n+        \"EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \/\/ mult\n+        \"66B71D0BD47344197CCFB0C9578EAF0ADB609E05BB4E8F87D56BD34F24EE7C47\", \/\/ x\n+        \"14A0ECB7F708C02B2BAE238D2C4607BB9D04FCE64E10A428C911D6FA25B2F0FD\", \/\/ y\n+        \"D25AAFD0FCC5B5E95C84C0702C138BC4D7FEB4E5F9C2DFB4301E313507EFDF44\", \/\/ x\n+        \"F3F04EBC7D308511B0392BB7171CF92688D6484A95A8100EDFC933613A359133\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #6\",\n+        \"1111111111111111111111111111111111111111111111111111111111111111\", \/\/ mult\n+        \"0217E617F0B6443928278F96999E69A23A4F2C152BDF6D6CDF66E5B80282D4ED\", \/\/ x\n+        \"194A7DEBCB97712D2DDA3CA85AA8765A56F45FC758599652F2897C65306E5794\", \/\/ y\n+        \"A83A07D6AE918359DEBCC385DA1E416EB83417435079CA8DB06005E107C309A0\", \/\/ x\n+        \"5AACDF816850C33EB3E54F3D0DD759B97B5E7065B2060016F73735E4A6AADE23\") \/\/ y\n+    );\n+    }};\n+\n+    private static boolean runSingleTest(TestData testData) {\n+        int keySize = 256;\n+        ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n+        NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n+        ECPoint generator = curve.getGenerator();\n+        BigInteger b = curve.getCurve().getB();\n+        if (params == null || generator == null) {\n+            throw new RuntimeException(\n+                    \"No EC parameters available for key size \" + keySize + \" bits\");\n+        }\n+\n+        ECOperations ops = ECOperations.forParameters(params).get();\n+        ECOperations opsReference = new ECOperations(\n+                IntegerPolynomialP256.ONE.getElement(b), P256OrderField.ONE);\n+\n+        boolean instanceTest1 = ops\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        boolean instanceTest2 = opsReference\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        if (instanceTest1 == false || instanceTest2 == true) {\n+            throw new RuntimeException(\"Bad Initialization: [\" + instanceTest1 + \",\"\n+                    + instanceTest2 + \"]\");\n+        }\n+\n+        MutablePoint nextPoint = ops.multiply(generator, testData.multiplier);\n+        MutablePoint nextReferencePoint = opsReference.multiply(generator,\n+                testData.multiplier);\n+        if (!check(nextReferencePoint, testData.reference1)\n+                || !check(nextPoint, testData.reference1)) {\n+            return false;\n+        }\n+\n+        nextPoint = ops.multiply(nextPoint.asAffine(), testData.multiplier);\n+        nextReferencePoint = opsReference.multiply(nextReferencePoint.asAffine(),\n+                testData.multiplier);\n+        if (!check(nextReferencePoint, testData.reference2)\n+                || !check(nextPoint, testData.reference2)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/ec\/ECOperationsKATTest.java\"\n+\n+\/*\n+ * KAT generator using OpenSSL for reference vectors\n+ * g++ ecpoint.cpp -g -lcrypto -Wno-deprecated-declarations && .\/a.out\n+ * (Some OpenSSL EC operations are marked internal i.e. deprecated)\n+ *\n+\n+#include <openssl\/obj_mac.h>\n+#include <openssl\/ec.h>\n+\n+void check(int rc, const char* locator) {\n+  if (rc != 1) {\n+    printf(\"Failed at %s\\n\", locator);\n+    exit(55);\n+  }\n+}\n+\n+int main(){\n+  BN_CTX* ctx = BN_CTX_new();\n+  BIGNUM* k = BN_CTX_get(ctx);\n+  BIGNUM* x1 = BN_CTX_get(ctx);\n+  BIGNUM* y1 = BN_CTX_get(ctx);\n+  BIGNUM* x2 = BN_CTX_get(ctx);\n+  BIGNUM* y2 = BN_CTX_get(ctx);\n+  EC_GROUP *ec_group = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);\n+  EC_POINT* pubkey = EC_POINT_new(ec_group);\n+  EC_POINT* pubkey2 = EC_POINT_new(ec_group);\n+  int rc;\n+\n+  rc = BN_hex2bn(&k, \"1111111111111111111111111111111111111111111111111111111111111111\"); \/\/check(rc, \"set raw key\");\n+  rc = EC_POINT_mul(ec_group, pubkey, k, NULL, NULL, ctx);  check(rc, \"mult public key\");\n+  rc = EC_POINT_get_affine_coordinates(ec_group, pubkey, x1, y1, ctx);   check(rc, \"get affine coordinates\");\n+  rc = EC_POINT_mul(ec_group, pubkey2, NULL, pubkey, k, ctx);  check(rc, \"mult public key\");\n+  rc = EC_POINT_get_affine_coordinates(ec_group, pubkey2, x2, y2, ctx);   check(rc, \"get affine coordinates\");\n+  printf(\"k: %s\\n\", BN_bn2hex(k));\n+  printf(\"x: %s\\ny: %s\\n\", BN_bn2hex(x1), BN_bn2hex(y1));\n+  printf(\"x: %s\\ny: %s\\n\", BN_bn2hex(x2), BN_bn2hex(y2));\n+\n+  BN_CTX_free(ctx);\n+  return 0;\n+}\n+ *\/\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/ec\/ECOperationsKATTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import sun.security.util.math.*;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ * java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics\n+ * IntegerPolynomialTest\n+ * @summary Unit test\n+ * IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ * java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp\n+ * -XX:-TieredCompilation -XX:+UseIntPolyIntrinsics IntegerPolynomialTest\n+ * @summary Unit test\n+ * IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n+ *\/\n+\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for\n+\/\/ pseudo-random number generator. If a failure occurs, hardcode the seed to\n+\/\/ make the test case deterministic\n+public class IntegerPolynomialTest {\n+    public static void main(String[] args) throws Exception {\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n+\n+        IntegerPolynomial testFields[] = new IntegerPolynomial[] {\n+                IntegerPolynomial1305.ONE, IntegerPolynomial25519.ONE,\n+                IntegerPolynomial448.ONE, IntegerPolynomialP256.ONE,\n+                MontgomeryIntegerPolynomialP256.ONE, IntegerPolynomialP384.ONE,\n+                IntegerPolynomialP521.ONE,\n+                new IntegerPolynomialModBinP.Curve25519OrderField(),\n+                new IntegerPolynomialModBinP.Curve448OrderField(),\n+                P256OrderField.ONE, P384OrderField.ONE, P521OrderField.ONE,\n+                Curve25519OrderField.ONE, Curve448OrderField.ONE };\n+\n+        for (IntegerPolynomial field : testFields) {\n+            ImmutableIntegerModuloP aRef = field\n+                    .getElement(new BigInteger(32 * 64, rnd));\n+            MutableIntegerModuloP a = aRef.mutable();\n+            ImmutableIntegerModuloP bRef = field\n+                    .getElement(new BigInteger(32 * 64, rnd));\n+            MutableIntegerModuloP b = bRef.mutable();\n+\n+            a.conditionalSet(b, 0); \/\/ Don't assign\n+            if (Arrays.equals(a.getLimbs(), b.getLimbs())) {\n+                throw new RuntimeException(\n+                        \"[SEED \" + seed + \"]: Incorrect assign for \" + field);\n+            }\n+            a.conditionalSet(b, 1); \/\/ Assign\n+            if (!Arrays.equals(a.getLimbs(), b.getLimbs())) {\n+                throw new RuntimeException(\n+                        \"[SEED \" + seed + \"]: Incorrect assign for \" + field);\n+            }\n+        }\n+        System.out.println(\"Test Success\");\n+    }\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+import java.math.BigInteger;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics\n+ *      MontgomeryPolynomialFuzzTest\n+ * @summary Unit test MontgomeryPolynomialFuzzTest.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseIntPolyIntrinsics\n+ *      MontgomeryPolynomialFuzzTest\n+ * @summary Unit test MontgomeryPolynomialFuzzTest.\n+ *\/\n+\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for pseudo-random number generator\n+\/\/ If a failure occurs, hardcode the seed to make the test case deterministic\n+public class MontgomeryPolynomialFuzzTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Note: it might be useful to increase this number during development\n+        final int repeat = 1000000;\n+        for (int i = 0; i < repeat; i++) {\n+            run();\n+        }\n+        System.out.println(\"Fuzz Success\");\n+    }\n+\n+    private static void check(BigInteger reference,\n+            ImmutableIntegerModuloP testValue, long seed) {\n+        if (!reference.equals(testValue.asBigInteger())) {\n+            throw new RuntimeException(\"SEED: \" + seed);\n+        }\n+    }\n+\n+    public static void run() throws Exception {\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n+\n+        IntegerMontgomeryFieldModuloP montField = MontgomeryIntegerPolynomialP256.ONE;\n+        BigInteger P = MontgomeryIntegerPolynomialP256.ONE.MODULUS;\n+        BigInteger r = BigInteger.ONE.shiftLeft(260).mod(P);\n+        BigInteger rInv = r.modInverse(P);\n+        BigInteger aRef = (new BigInteger(P.bitLength(), rnd)).mod(P);\n+\n+        \/\/ Test conversion to montgomery domain\n+        ImmutableIntegerModuloP a = montField.getElement(aRef);\n+        aRef = aRef.multiply(r).mod(P);\n+        check(aRef, a, seed);\n+\n+        if (rnd.nextBoolean()) {\n+            aRef = aRef.multiply(aRef).multiply(rInv).mod(P);\n+            a = a.multiply(a);\n+            check(aRef, a, seed);\n+        }\n+\n+        if (rnd.nextBoolean()) {\n+            aRef = aRef.add(aRef).mod(P);\n+            a = a.add(a);\n+            check(aRef, a, seed);\n+        }\n+    }\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/MontgomeryPolynomialFuzzTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/MontgomeryPolynomialFuzzTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import sun.security.util.math.intpoly.MontgomeryIntegerPolynomialP256;\n+import sun.security.util.math.intpoly.IntegerPolynomialP256;\n+import sun.security.util.math.MutableIntegerModuloP;\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+\n+@Fork(jvmArgsAppend = {\"-XX:+AlwaysPreTouch\",\n+    \"--add-exports\", \"java.base\/sun.security.util.math.intpoly=ALL-UNNAMED\",\n+    \"--add-exports\", \"java.base\/sun.security.util.math=ALL-UNNAMED\"}, value = 1)\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.Throughput)\n+public class PolynomialP256Bench {\n+    final MontgomeryIntegerPolynomialP256 montField = MontgomeryIntegerPolynomialP256.ONE;\n+    final IntegerPolynomialP256 residueField = IntegerPolynomialP256.ONE;\n+    final BigInteger refx =\n+        new BigInteger(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16);\n+    final ImmutableIntegerModuloP x = residueField.getElement(refx);\n+    final ImmutableIntegerModuloP X = montField.getElement(refx);\n+    final ImmutableIntegerModuloP one = montField.get1();\n+\n+    @Param({\"true\", \"false\"})\n+    private boolean isMontBench;\n+\n+    @Benchmark\n+    public MutableIntegerModuloP benchMultiply() {\n+        MutableIntegerModuloP test;\n+        if (isMontBench) {\n+            test = X.mutable();\n+        } else {\n+            test = x.mutable();\n+        }\n+\n+        for (int i = 0; i< 10000; i++) {\n+            test = test.setProduct(test);\n+        }\n+        return test;\n+    }\n+\n+    @Benchmark\n+    public MutableIntegerModuloP benchSquare() {\n+        MutableIntegerModuloP test;\n+        if (isMontBench) {\n+            test = X.mutable();\n+        } else {\n+            test = x.mutable();\n+        }\n+\n+        for (int i = 0; i< 10000; i++) {\n+            test = test.setSquare();\n+        }\n+        return test;\n+    }\n+\n+    @Benchmark\n+    public MutableIntegerModuloP benchAssign() {\n+        MutableIntegerModuloP test1 = X.mutable();\n+        MutableIntegerModuloP test2 = one.mutable();\n+        for (int i = 0; i< 10000; i++) {\n+            test1.conditionalSet(test2, 0);\n+            test1.conditionalSet(test2, 1);\n+            test2.conditionalSet(test1, 0);\n+            test2.conditionalSet(test1, 1);\n+        }\n+        return test2;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/PolynomialP256Bench.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}