{"files":[{"patch":"@@ -781,1 +781,1 @@\n-        result.appendLine(\"protected void mult(long[] a, long[] b, long[] r) {\");\n+        result.appendLine(\"protected int mult(long[] a, long[] b, long[] r) {\");\n@@ -807,0 +807,3 @@\n+        result.appendIndent();\n+        result.append(\"return 0;\");\n+        result.appendLine();\n@@ -836,1 +839,1 @@\n-        result.appendLine(\"protected void square(long[] a, long[] r) {\");\n+        result.appendLine(\"protected int square(long[] a, long[] r) {\");\n@@ -877,0 +880,3 @@\n+        result.appendIndent();\n+        result.append(\"return 0;\");\n+        result.appendLine();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -109,0 +109,2 @@\n+        --add-exports java.base\/sun.security.util.math=ALL-UNNAMED \\\n+        --add-exports java.base\/sun.security.util.math.intpoly=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1442,0 +1442,2 @@\n+\n+  using Assembler::evpsrlq;\n@@ -1463,0 +1465,1 @@\n+  using Assembler::evpsraq;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4210,0 +4210,5 @@\n+  if (UseIntPolyIntrinsics) {\n+    StubRoutines::_intpoly_montgomeryMult_P256 = generate_intpoly_montgomeryMult_P256();\n+    StubRoutines::_intpoly_assign = generate_intpoly_assign();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -478,0 +478,4 @@\n+  address generate_intpoly_montgomeryMult_P256();\n+  void montgomeryMultiply(const Register aLimbs, const Register bLimbs, const Register rLimbs);\n+  address generate_intpoly_assign();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly1305.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,427 @@\n+\/*\n+ * Copyright (c) 2022, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+#define __ _masm->\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t MODULUS_P256[] = {\n+  0x000fffffffffffff, 0x00000fffffffffff,\n+  0x0000000000000000, 0x0000001000000000,\n+  0x0000ffffffff0000, 0x0000000000000000,\n+  0x0000000000000000, 0x0000000000000000\n+};\n+static address modulus_p256() {\n+  return (address)MODULUS_P256;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t P256_MASK52[] = {\n+  0x000fffffffffffff, 0x000fffffffffffff,\n+  0x000fffffffffffff, 0x000fffffffffffff,\n+  0xffffffffffffffff, 0xffffffffffffffff,\n+  0xffffffffffffffff, 0xffffffffffffffff,\n+};\n+static address p256_mask52() {\n+  return (address)P256_MASK52;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t BROADCAST5[] = {\n+  0x0000000000000004, 0x0000000000000004,\n+  0x0000000000000004, 0x0000000000000004,\n+  0x0000000000000004, 0x0000000000000004,\n+  0x0000000000000004, 0x0000000000000004,\n+};\n+static address broadcast_5() {\n+  return (address)BROADCAST5;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t SHIFT1R[] = {\n+  0x0000000000000001, 0x0000000000000002,\n+  0x0000000000000003, 0x0000000000000004,\n+  0x0000000000000005, 0x0000000000000006,\n+  0x0000000000000007, 0x0000000000000000,\n+};\n+static address shift_1R() {\n+  return (address)SHIFT1R;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t SHIFT1L[] = {\n+  0x0000000000000007, 0x0000000000000000,\n+  0x0000000000000001, 0x0000000000000002,\n+  0x0000000000000003, 0x0000000000000004,\n+  0x0000000000000005, 0x0000000000000006,\n+};\n+static address shift_1L() {\n+  return (address)SHIFT1L;\n+}\n+\n+\/**\n+ * Unrolled Word-by-Word Montgomery Multiplication\n+ * r = a * b * 2^-260 (mod P)\n+ *\n+ * Reference: Shay Gueron and Vlad Krasnov \"Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes\"\n+ *    See Figure 5. \"Algorithm 2: Word-by-Word Montgomery Multiplication for a Montgomery\n+ *    Friendly modulus p\". Note: Step 6. Skipped; Instead use numAdds to reuse existing overflow\n+ *    logic.\n+ *\n+ * Pseudocode:\n+ *\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *   M = load(*modulus_p256)                           | 0| 0| 0|m5|m4|m3|m2|m1|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *   A = load(*aLimbs)                                 | 0| 0| 0|a5|a4|a3|a2|a1|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *   Acc1 = 0                                          | 0| 0| 0| 0| 0| 0| 0| 0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *      ---- for i = 0 to 4\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc2 = 0                                   | 0| 0| 0| 0| 0| 0| 0| 0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          B = replicate(bLimbs[i])                   |bi|bi|bi|bi|bi|bi|bi|bi|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc1+=| 0| 0| 0|c5|c4|c3|c2|c1|\n+ *                                                    *| 0| 0| 0|a5|a4|a3|a2|a1|\n+ *          Acc1 += A *  B                             |bi|bi|bi|bi|bi|bi|bi|bi|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc2+=| 0| 0| 0| 0| 0| 0| 0| 0|\n+ *                                                   *h| 0| 0| 0|a5|a4|a3|a2|a1|\n+ *          Acc2 += A *h B                             |bi|bi|bi|bi|bi|bi|bi|bi|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          N = replicate(Acc1[0])                     |n0|n0|n0|n0|n0|n0|n0|n0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc1+=| 0| 0| 0|c5|c4|c3|c2|c1|\n+ *                                                    *| 0| 0| 0|m5|m4|m3|m2|m1|\n+ *          Acc1 += M *  N                             |n0|n0|n0|n0|n0|n0|n0|n0| Note: 52 low bits of Acc1[0] == 0 due to Montgomery!\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc2+=| 0| 0| 0|d5|d4|d3|d2|d1|\n+ *                                                   *h| 0| 0| 0|m5|m4|m3|m2|m1|\n+ *          Acc2 += M *h N                             |n0|n0|n0|n0|n0|n0|n0|n0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          if (i == 4) break;\n+ *          \/\/ Combine high\/low partial sums Acc1 + Acc2\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          carry = Acc1[0] >> 52                      | 0| 0| 0| 0| 0| 0| 0|c1|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc2[0] += carry\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc1 = Acc1 shift one q element>>          | 0| 0| 0| 0|c5|c4|c3|c2|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc1 = Acc1 + Acc2\n+ *      ---- done\n+ *   \/\/ Last Carry round: Combine high\/low partial sums Acc1<high_bits> + Acc1 + Acc2\n+ *   carry = Acc1 >> 52\n+ *   Acc1 = Acc1 shift one q element >>\n+ *   Acc1  = mask52(Acc1)\n+ *   Acc2  += carry\n+ *   Acc1 = Acc1 + Acc2\n+ *   output to rLimbs\n+ *\/\n+void StubGenerator::montgomeryMultiply(const Register aLimbs, const Register bLimbs, const Register rLimbs) {\n+  Register t0 = r13;\n+  Register rscratch = r13;\n+\n+  \/\/ Inputs\n+  XMMRegister A = xmm0;\n+  XMMRegister B = xmm1;\n+  XMMRegister T = xmm2;\n+\n+  \/\/ Intermediates\n+  XMMRegister Acc1 = xmm10;\n+  XMMRegister Acc2 = xmm11;\n+  XMMRegister N = xmm12;\n+  XMMRegister select = xmm13;\n+  XMMRegister carry = xmm14;\n+\n+  \/\/ Constants\n+  XMMRegister modulus = xmm20;\n+  XMMRegister shift1L = xmm21;\n+  XMMRegister shift1R = xmm22;\n+  XMMRegister mask52 = xmm23;\n+  XMMRegister broadcast5 = xmm24;\n+  KRegister limb0 = k1;\n+  KRegister limb5 = k2;\n+  KRegister allLimbs = k3;\n+\n+  __ mov64(t0, 0x1);\n+  __ kmovql(limb0, t0);\n+  __ mov64(t0, 0x10);\n+  __ kmovql(limb5, t0);\n+  __ mov64(t0, 0x1f);\n+  __ kmovql(allLimbs, t0);\n+  __ evmovdquq(shift1L, allLimbs, ExternalAddress(shift_1L()), false, Assembler::AVX_512bit, rscratch);\n+  __ evmovdquq(shift1R, allLimbs, ExternalAddress(shift_1R()), false, Assembler::AVX_512bit, rscratch);\n+  __ evmovdquq(broadcast5, allLimbs, ExternalAddress(broadcast_5()), false, Assembler::AVX_512bit, rscratch);\n+  __ evmovdquq(mask52, allLimbs, ExternalAddress(p256_mask52()), false, Assembler::AVX_512bit, rscratch);\n+\n+  \/\/ M = load(*modulus_p256)\n+  __ evmovdquq(modulus, allLimbs, ExternalAddress(modulus_p256()), false, Assembler::AVX_512bit, rscratch);\n+\n+  \/\/ A = load(*aLimbs)\n+  __ evmovdquq(A, Address(aLimbs, 8), Assembler::AVX_256bit);                          \/\/ Acc1 = load(*a)\n+  __ evpermq(A, allLimbs, shift1L, A, false, Assembler::AVX_512bit);\n+  __ movq(T, Address(aLimbs, 0));\n+  __ evporq(A, A, T, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1 = 0\n+  __ vpxorq(Acc1, Acc1, Acc1, Assembler::AVX_512bit);\n+  for (int i = 0; i< 5; i++) {\n+      \/\/ Acc2 = 0\n+      __ vpxorq(Acc2, Acc2, Acc2, Assembler::AVX_512bit);\n+\n+      \/\/ B = replicate(bLimbs[i])\n+      __ vpbroadcastq(B, Address(bLimbs, i*8), Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 += A * B\n+      __ evpmadd52luq(Acc1, A, B, Assembler::AVX_512bit);\n+\n+      \/\/ Acc2 += A *h B\n+      __ evpmadd52huq(Acc2, A, B, Assembler::AVX_512bit);\n+\n+      \/\/ N = replicate(Acc1[0])\n+      __ vpbroadcastq(N, Acc1, Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 += M *  N\n+      __ evpmadd52luq(Acc1, modulus, N, Assembler::AVX_512bit);\n+\n+      \/\/ Acc2 += M *h N\n+      __ evpmadd52huq(Acc2, modulus, N, Assembler::AVX_512bit);\n+\n+      if (i == 4) break;\n+\n+      \/\/ Combine high\/low partial sums Acc1 + Acc2\n+\n+      \/\/ carry = Acc1[0] >> 52\n+      __ evpsrlq(carry, limb0, Acc1, 52, true, Assembler::AVX_512bit);\n+\n+      \/\/ Acc2[0] += carry\n+      __ evpaddq(Acc2, limb0, carry, Acc2, true, Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 = Acc1 shift one q element >>\n+      __ evpermq(Acc1, allLimbs, shift1R, Acc1, false, Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 = Acc1 + Acc2\n+      __ vpaddq(Acc1, Acc1, Acc2, Assembler::AVX_512bit);\n+  }\n+\n+  \/\/ Last Carry round: Combine high\/low partial sums Acc1<high_bits> + Acc1 + Acc2\n+  \/\/ carry = Acc1 >> 52\n+  __ evpsrlq(carry, allLimbs, Acc1, 52, true, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1 = Acc1 shift one q element >>\n+  __ evpermq(Acc1, allLimbs, shift1R, Acc1, false, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1  = mask52(Acc1)\n+  __ evpandq(Acc1, Acc1, mask52, Assembler::AVX_512bit); \/\/ Clear top 12 bits\n+\n+  \/\/ Acc2 += carry\n+  __ evpaddq(Acc2, allLimbs, carry, Acc2, true, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1 = Acc1 + Acc2\n+  __ vpaddq(Acc1, Acc1, Acc2, Assembler::AVX_512bit);\n+\n+  \/\/ output to rLimbs (1 + 4 limbs)\n+  __ movq(Address(rLimbs, 0), Acc1);\n+  __ evpermq(Acc1, k0, shift1R, Acc1, true, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(rLimbs, 8), k0, Acc1, true, Assembler::AVX_256bit);\n+}\n+\n+address StubGenerator::generate_intpoly_montgomeryMult_P256() {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_montgomeryMult_P256\");\n+  address start = __ pc();\n+  __ enter();\n+\n+  \/\/ Save all 'SOE' registers\n+  __ push(rbx);\n+  #ifdef _WIN64\n+  __ push(rsi);\n+  __ push(rdi);\n+  #endif\n+  __ push(r12);\n+  __ push(r13);\n+  __ push(r14);\n+  __ push(r15);\n+\n+  \/\/ Register Map\n+  const Register aLimbs  = rdi;\n+  const Register bLimbs  = rsi;\n+  const Register rLimbs  = rdx;\n+\n+  \/\/ Normalize input\n+  \/\/ pseudo-signature: void poly1305_processBlocks(byte[] input, int length, int[5] accumulator, int[5] R)\n+  \/\/ a, b, r pointers point at first array element\n+  \/\/ java headers bypassed in LibraryCallKit::inline_poly1305_processBlocks\n+  #ifdef _WIN64\n+  \/\/ c_rarg0 - rcx\n+  \/\/ c_rarg1 - rdx\n+  \/\/ c_rarg2 - r8\n+  __ mov(aLimbs, c_rarg0);\n+  __ mov(bLimbs, c_rarg1);\n+  __ mov(rLimbs, c_rarg2);\n+  #else\n+  \/\/ Already in place\n+  \/\/ c_rarg0 - rdi\n+  \/\/ c_rarg1 - rsi\n+  \/\/ c_rarg2 - rdx\n+  #endif\n+\n+  montgomeryMultiply(aLimbs, bLimbs, rLimbs);\n+\n+  __ pop(r15);\n+  __ pop(r14);\n+  __ pop(r13);\n+  __ pop(r12);\n+  #ifdef _WIN64\n+  __ pop(rdi);\n+  __ pop(rsi);\n+  #endif\n+  __ pop(rbx);\n+  __ mov64(rax, 0x1); \/\/ Return 1 (Step 6 skipped in montgomeryMultiply)\n+\n+  __ leave();\n+  __ ret(0);\n+  return start;\n+}\n+\n+\/\/ A = B if select\n+\/\/ Must be:\n+\/\/  - constant time (i.e. no branches)\n+\/\/  - no-side channel (i.e. all memory must always be accessed, and in same order)\n+void assign_avx(XMMRegister A, Address aAddr, XMMRegister B, Address bAddr, KRegister select, int vector_len, MacroAssembler* _masm) {\n+  __ evmovdquq(A, aAddr, vector_len);\n+  __ evmovdquq(B, bAddr, vector_len);\n+  __ evmovdquq(A, select, B, true, vector_len);\n+  __ evmovdquq(aAddr, A, vector_len);\n+}\n+\n+void assign_scalar(Address aAddr, Address bAddr, Register select, Register tmp, MacroAssembler* _masm) {\n+  \/\/ Original java:\n+  \/\/ long dummyLimbs = maskValue & (a[i] ^ b[i]);\n+  \/\/ a[i] = dummyLimbs ^ a[i];\n+\n+  __ movq(tmp, aAddr);\n+  __ xorq(tmp, bAddr);\n+  __ andq(tmp, select);\n+  __ xorq(aAddr, tmp);\n+}\n+\n+address StubGenerator::generate_intpoly_assign() {\n+  \/\/ KNOWN Lengths:\n+  \/\/   MontgomeryIntPolynP256:  5 = 4 + 1\n+  \/\/   IntegerPolynomial1305:   5 = 4 + 1\n+  \/\/   IntegerPolynomial25519: 10 = 8 + 2\n+  \/\/   IntegerPolynomialP256:  10 = 8 + 2\n+  \/\/   Curve25519OrderField:   10 = 8 + 2\n+  \/\/   Curve25519OrderField:   10 = 8 + 2\n+  \/\/   P256OrderField:         10 = 8 + 2\n+  \/\/   IntegerPolynomialP384:  14 = 8 + 4 + 2\n+  \/\/   P384OrderField:         14 = 8 + 4 + 2\n+  \/\/   IntegerPolynomial448:   16 = 8 + 8\n+  \/\/   Curve448OrderField:     16 = 8 + 8\n+  \/\/   Curve448OrderField:     16 = 8 + 8\n+  \/\/   IntegerPolynomialP521:  19 = 8 + 8 + 2 + 1\n+  \/\/   P521OrderField:         19 = 8 + 8 + 2 + 1\n+  \/\/ Special Cases 5, 10, 14, 16, 19\n+\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_assign\");\n+  address start = __ pc();\n+  __ enter();\n+\n+  \/\/ Inputs\n+  const Register set     = c_rarg0;\n+  const Register aLimbs  = c_rarg1;\n+  const Register bLimbs  = c_rarg2;\n+  const Register length  = c_rarg3;\n+  XMMRegister A = xmm0;\n+  XMMRegister B = xmm1;\n+\n+  Register tmp = r9;\n+  KRegister select = k1;\n+  Label L_Length5, L_Length10, L_Length14, L_Length16, L_Length19, L_DefaultLoop, L_Done;\n+\n+  __ negq(set);\n+  __ kmovql(select, set);\n+\n+  \/\/ NOTE!! Allowed to branch on number of limbs;\n+  \/\/ Number of limbs is a constant in each IntegerPolynomial (i.e. this side-channel branch leaks\n+  \/\/   number of limbs which is not a secret)\n+  __ cmpl(length, 5);\n+  __ jcc(Assembler::equal, L_Length5);\n+  __ cmpl(length, 10);\n+  __ jcc(Assembler::equal, L_Length10);\n+  __ cmpl(length, 14);\n+  __ jcc(Assembler::equal, L_Length14);\n+  __ cmpl(length, 16);\n+  __ jcc(Assembler::equal, L_Length16);\n+  __ cmpl(length, 19);\n+  __ jcc(Assembler::equal, L_Length19);\n+\n+  \/\/ Default copy loop\n+  __ bind(L_DefaultLoop);\n+  __ cmpl(length, 0);\n+  __ jcc(Assembler::less, L_Done);\n+  assign_scalar(Address(aLimbs, 0), Address(bLimbs, 0), set, tmp, _masm);\n+  __ subl(length, 16);\n+  __ lea(aLimbs, Address(aLimbs,8));\n+  __ lea(bLimbs, Address(bLimbs,8));\n+  __ jmp(L_DefaultLoop);\n+\n+  __ bind(L_Length5); \/\/ 1 + 4\n+  assign_scalar(Address(aLimbs, 0), Address(bLimbs, 0), set, tmp, _masm);\n+  assign_avx(A, Address(aLimbs, 8), B, Address(bLimbs, 8), select, Assembler::AVX_256bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length10); \/\/ 2 + 8\n+  assign_avx(A, Address(aLimbs, 0),  B, Address(bLimbs, 0),  select, Assembler::AVX_128bit, _masm);\n+  assign_avx(A, Address(aLimbs, 16), B, Address(bLimbs, 16), select, Assembler::AVX_512bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length14); \/\/ 2 + 4 + 8\n+  assign_avx(A, Address(aLimbs, 0),  B, Address(bLimbs, 0),  select, Assembler::AVX_128bit, _masm);\n+  assign_avx(A, Address(aLimbs, 16), B, Address(bLimbs, 16), select, Assembler::AVX_256bit, _masm);\n+  assign_avx(A, Address(aLimbs, 48), B, Address(bLimbs, 48), select, Assembler::AVX_512bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length16); \/\/ 8 + 8\n+  assign_avx(A, Address(aLimbs, 0),  B, Address(bLimbs, 0),  select, Assembler::AVX_512bit, _masm);\n+  assign_avx(A, Address(aLimbs, 64), B, Address(bLimbs, 64), select, Assembler::AVX_512bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length19); \/\/ 1 + 2 + 8 + 8\n+  assign_scalar(Address(aLimbs, 0), Address(bLimbs, 0), set, tmp, _masm);\n+  assign_avx(A, Address(aLimbs, 8),  B, Address(bLimbs, 8),  select, Assembler::AVX_128bit, _masm);\n+  assign_avx(A, Address(aLimbs, 24), B, Address(bLimbs, 24), select, Assembler::AVX_512bit, _masm);\n+  assign_avx(A, Address(aLimbs, 88), B, Address(bLimbs, 88), select, Assembler::AVX_512bit, _masm);\n+\n+  __ bind(L_Done);\n+  __ leave();\n+  __ ret(0);\n+  return start;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":427,"deletions":0,"binary":false,"changes":427,"status":"added"},{"patch":"@@ -1369,0 +1369,12 @@\n+#ifdef _LP64\n+  if (supports_avx512ifma() && supports_avx512vlbw() && MaxVectorSize >= 64) {\n+    if (FLAG_IS_DEFAULT(UseIntPolyIntrinsics)) {\n+      FLAG_SET_DEFAULT(UseIntPolyIntrinsics, true);\n+    }\n+  } else\n+#endif\n+  if (UseIntPolyIntrinsics) {\n+    warning(\"Intrinsics for Polynomial crypto functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseIntPolyIntrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -495,0 +495,4 @@\n+  case vmIntrinsics::_intpoly_montgomeryMult_P256:\n+  case vmIntrinsics::_intpoly_assign:\n+    if (!UseIntPolyIntrinsics) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -529,1 +529,12 @@\n-   \/* support for java.util.Base64.Encoder*\/                                                                            \\\n+  \/* support for sun.security.util.math.intpoly.MontgomeryIntegerPolynomialP256 *\/                                      \\\n+  do_class(sun_security_util_math_intpoly_MontgomeryIntegerPolynomialP256, \"sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256\")  \\\n+  do_intrinsic(_intpoly_montgomeryMult_P256, sun_security_util_math_intpoly_MontgomeryIntegerPolynomialP256, intPolyMult_name, intPolyMult_signature, F_R) \\\n+  do_name(intPolyMult_name, \"mult\")                                                                                     \\\n+  do_signature(intPolyMult_signature, \"([J[J[J)I\")                                                                      \\\n+                                                                                                                        \\\n+  do_class(sun_security_util_math_intpoly_IntegerPolynomial, \"sun\/security\/util\/math\/intpoly\/IntegerPolynomial\")        \\\n+  do_intrinsic(_intpoly_assign, sun_security_util_math_intpoly_IntegerPolynomial, intPolyAssign_name, intPolyAssign_signature, F_S) \\\n+   do_name(intPolyAssign_name, \"conditionalAssign\")                                                                     \\\n+   do_signature(intPolyAssign_signature, \"(I[J[J)V\")                                                                    \\\n+                                                                                                                        \\\n+  \/* support for java.util.Base64.Encoder*\/                                                                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -361,0 +361,2 @@\n+  static_field(StubRoutines,                _intpoly_montgomeryMult_P256,                     address)                               \\\n+  static_field(StubRoutines,                _intpoly_assign,                                  address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -786,0 +786,2 @@\n+  case vmIntrinsics::_intpoly_montgomeryMult_P256:\n+  case vmIntrinsics::_intpoly_assign:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1587,0 +1587,2 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"intpoly_montgomeryMult_P256\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"intpoly_assign\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -640,1 +640,4 @@\n-\n+  case vmIntrinsics::_intpoly_montgomeryMult_P256:\n+    return inline_intpoly_montgomeryMult_P256();\n+  case vmIntrinsics::_intpoly_assign:\n+    return inline_intpoly_assign();\n@@ -7516,0 +7519,67 @@\n+bool LibraryCallKit::inline_intpoly_montgomeryMult_P256() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseIntPolyIntrinsics, \"need intpoly intrinsics support\");\n+  assert(callee()->signature()->size() == 3, \"intpoly_montgomeryMult_P256 has %d parameters\", callee()->signature()->size());\n+  stubAddr = StubRoutines::intpoly_montgomeryMult_P256();\n+  stubName = \"intpoly_montgomeryMult_P256\";\n+\n+  if (!stubAddr) return false;\n+  null_check_receiver();  \/\/ null-check receiver\n+  if (stopped())  return true;\n+\n+  Node* a = argument(1);\n+  Node* b = argument(2);\n+  Node* r = argument(3);\n+\n+  a = must_be_not_null(a, true);\n+  b = must_be_not_null(b, true);\n+  r = must_be_not_null(r, true);\n+\n+  Node* a_start = array_element_address(a, intcon(0), T_LONG);\n+  assert(a_start, \"a array is NULL\");\n+  Node* b_start = array_element_address(b, intcon(0), T_LONG);\n+  assert(b_start, \"b array is NULL\");\n+  Node* r_start = array_element_address(r, intcon(0), T_LONG);\n+  assert(r_start, \"r array is NULL\");\n+\n+  Node* call = make_runtime_call(RC_LEAF | RC_NO_FP,\n+                                 OptoRuntime::intpoly_montgomeryMult_P256_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 a_start, b_start, r_start);\n+  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  set_result(result);\n+  return true;\n+}\n+\n+bool LibraryCallKit::inline_intpoly_assign() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseIntPolyIntrinsics, \"need intpoly intrinsics support\");\n+  assert(callee()->signature()->size() == 3, \"intpoly_assign has %d parameters\", callee()->signature()->size());\n+  stubAddr = StubRoutines::intpoly_assign();\n+  stubName = \"intpoly_assign\";\n+\n+  if (!stubAddr) return false;\n+  if (stopped())  return true;\n+\n+  Node* set = argument(0);\n+  Node* a = argument(1);\n+  Node* b = argument(2);\n+  Node* arr_length = load_array_length(a);\n+\n+  a = must_be_not_null(a, true);\n+  b = must_be_not_null(b, true);\n+\n+  Node* a_start = array_element_address(a, intcon(0), T_LONG);\n+  assert(a_start, \"a array is NULL\");\n+  Node* b_start = array_element_address(b, intcon(0), T_LONG);\n+  assert(b_start, \"b array is NULL\");\n+\n+  Node* call = make_runtime_call(RC_LEAF | RC_NO_FP,\n+                                 OptoRuntime::intpoly_assign_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 set, a_start, b_start, arr_length);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -309,0 +309,2 @@\n+  bool inline_intpoly_montgomeryMult_P256();\n+  bool inline_intpoly_assign();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1382,0 +1382,39 @@\n+\/\/ MontgomeryIntegerPolynomialP256 multiply function\n+const TypeFunc* OptoRuntime::intpoly_montgomeryMult_P256_Type() {\n+  int argcnt = 3;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ a array\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ b array\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ r(esult) array\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ carry bits in output\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ IntegerPolynomial constant time assignment function\n+const TypeFunc* OptoRuntime::intpoly_assign_Type() {\n+  int argcnt = 4;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypeInt::INT;        \/\/ set flag\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ a array (result)\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ b array (if set is set)\n+  fields[argp++] = TypeInt::INT;        \/\/ array length\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -299,0 +299,2 @@\n+  static const TypeFunc* intpoly_montgomeryMult_P256_Type();\n+  static const TypeFunc* intpoly_assign_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,0 +240,2 @@\n+  product(bool, UseIntPolyIntrinsics, false, DIAGNOSTIC,                   \\\n+          \"Use intrinsics for sun.security.util.math.intpoly.MontgomeryIntegerPolynomialP256\") \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,0 +132,2 @@\n+address StubRoutines::_intpoly_montgomeryMult_P256         = nullptr;\n+address StubRoutines::_intpoly_assign                      = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,0 +216,2 @@\n+  static address _intpoly_montgomeryMult_P256;\n+  static address _intpoly_assign;\n@@ -402,0 +404,2 @@\n+  static address intpoly_montgomeryMult_P256()          { return _intpoly_montgomeryMult_P256; }\n+  static address intpoly_assign()        { return _intpoly_assign; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-        ecOps.setSum(p1, p2.asAffine());\n+        ecOps.setSum(p1, p2);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDSAOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\n@@ -51,4 +50,0 @@\n-    private static final ECOperations secp256r1Ops =\n-        new ECOperations(IntegerPolynomialP256.ONE.getElement(\n-                CurveDB.lookup(KnownOIDs.secp256r1.value()).getCurve().getB()),\n-                P256OrderField.ONE);\n@@ -78,0 +73,8 @@\n+    \/\/ This field is optional.\n+    \/\/ It is set, when the operations are also available in Montgomery domain.\n+    private ECOperations montgomeryOps;\n+\n+    static final Map<BigInteger, IntegerMontgomeryFieldModuloP> montgomeryFields = Map.of(\n+        IntegerPolynomialP256.MODULUS, MontgomeryIntegerPolynomialP256.ONE\n+    );\n+\n@@ -99,0 +102,6 @@\n+        ECOperations montOps = null;\n+        IntegerMontgomeryFieldModuloP montField = montgomeryFields.get(primeField.getP());\n+        if (montField != null) {\n+            montOps = new ECOperations(montField.getElement(curve.getB()), orderField);\n+        }\n+\n@@ -100,1 +109,1 @@\n-        ECOperations ecOps = new ECOperations(b, orderField);\n+        ECOperations ecOps = new ECOperations(b, orderField, montOps);\n@@ -113,0 +122,5 @@\n+        this(b, orderField, null);\n+    }\n+\n+    private ECOperations(IntegerModuloP b, IntegerFieldModuloP orderField, ECOperations montgomeryOps) {\n+        this.montgomeryOps = montgomeryOps;\n@@ -210,1 +224,15 @@\n-        return PointMultiplier.of(this, affineP).pointMultiply(s);\n+        \/\/ Route to Basepoint and\/or Montgomery pointMultiply as appropriate\n+\n+        ECPoint ecPoint = affineP.toECPoint();\n+        PointMultiplier multiplier = null;\n+        if (montgomeryOps == null) {\n+            multiplier = new DefaultMultiplier(this, affineP);\n+        } else if (ecPoint.equals(Secp256R1GeneratorMontgomeryMultiplier.generator)) {\n+            \/\/ Lazy class loading upon function call (large static constant table)\n+            multiplier = Secp256R1GeneratorMontgomeryMultiplier.multiplier;\n+        } else {\n+            \/\/ affineP is in residue domain, use ecPoint to get domain conversion\n+            multiplier = new DefaultMontgomeryMultiplier(montgomeryOps, ecPoint);\n+        }\n+\n+        return multiplier.pointMultiply(s);\n@@ -214,1 +242,13 @@\n-        return PointMultiplier.of(this, ecPoint).pointMultiply(s);\n+        \/\/ Route to Basepoint and\/or Montgomery pointMultiply as appropriate\n+\n+        PointMultiplier multiplier = null;\n+        if (montgomeryOps == null) {\n+            multiplier = new DefaultMultiplier(this, ecPoint);\n+        } else if (ecPoint.equals(Secp256R1GeneratorMontgomeryMultiplier.generator)) {\n+            \/\/ Lazy class loading upon function call (large static constant table)\n+            multiplier = Secp256R1GeneratorMontgomeryMultiplier.multiplier;\n+        } else {\n+            multiplier = new DefaultMontgomeryMultiplier(montgomeryOps, ecPoint);\n+        }\n+\n+        return multiplier.pointMultiply(s);\n@@ -268,3 +308,1 @@\n-     * Mixed point addition. This method constructs new temporaries each time\n-     * it is called. For better efficiency, the method that reuses temporaries\n-     * should be used if more than one sum will be computed.\n+     * public Point addition. Used by ECDSAOperations\n@@ -272,2 +310,1 @@\n-    public void setSum(MutablePoint p, AffinePoint p2) {\n-\n+    public void setSum(MutablePoint p, MutablePoint p2) {\n@@ -280,1 +317,0 @@\n-        setSum((ProjectivePoint.Mutable) p, p2, t0, t1, t2, t3, t4);\n@@ -282,0 +318,8 @@\n+        \/\/ Route to Montgomery setSum, if field implemented\n+        ECOperations ops = this;\n+        if (this.montgomeryOps != null) {\n+            assert p.getField() instanceof IntegerMontgomeryFieldModuloP;\n+            assert p2.getField() instanceof IntegerMontgomeryFieldModuloP;\n+            ops = this.montgomeryOps;\n+        }\n+        ops.setSum((ProjectivePoint.Mutable) p, (ProjectivePoint.Mutable) p2, t0, t1, t2, t3, t4);\n@@ -415,5 +459,2 @@\n-    sealed interface PointMultiplier {\n-        Map<ECPoint, PointMultiplier> multipliers = Map.of(\n-                Secp256R1GeneratorMultiplier.generator,\n-                Secp256R1GeneratorMultiplier.multiplier);\n-\n+    sealed interface PointMultiplier\n+        permits SmallWindowMultiplier, P256LargeTableMultiplier {\n@@ -432,20 +473,0 @@\n-        static PointMultiplier of(ECOperations ecOps, AffinePoint affPoint) {\n-            PointMultiplier multiplier = multipliers.get(affPoint.toECPoint());\n-            if (multiplier == null) {\n-                multiplier = new Default(ecOps, affPoint);\n-            }\n-\n-            return multiplier;\n-        }\n-\n-        static PointMultiplier of(ECOperations ecOps, ECPoint ecPoint) {\n-            PointMultiplier multiplier = multipliers.get(ecPoint);\n-            if (multiplier == null) {\n-                AffinePoint affPoint =\n-                        AffinePoint.fromECPoint(ecPoint, ecOps.getField());\n-                multiplier = new Default(ecOps, affPoint);\n-            }\n-\n-            return multiplier;\n-        }\n-\n@@ -468,0 +489,1 @@\n+    }\n@@ -469,3 +491,39 @@\n-        final class Default implements PointMultiplier {\n-            private final AffinePoint affineP;\n-            private final ECOperations ecOps;\n+    sealed static abstract class SmallWindowMultiplier implements PointMultiplier\n+        permits DefaultMultiplier, DefaultMontgomeryMultiplier {\n+        private final AffinePoint affineP;\n+        private final ECOperations ecOps;\n+        private final ProjectivePoint.Immutable[] pointMultiples;\n+\n+        protected SmallWindowMultiplier(ECOperations ecOps, AffinePoint affineP) {\n+            this.ecOps = ecOps;\n+            this.affineP = affineP;\n+\n+            \/\/ Precompute and cache point multiples\n+            this.pointMultiples = new ProjectivePoint.Immutable[16];\n+\n+            IntegerFieldModuloP field = ecOps.getField();\n+            ImmutableIntegerModuloP zero = field.get0();\n+            \/\/ temporaries\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n+\n+            ProjectivePoint.Mutable ps =\n+                new ProjectivePoint.Mutable(field);\n+            ps.getY().setValue(field.get1().mutable());\n+\n+            \/\/ 0P is neutral---same as initial result value\n+            pointMultiples[0] = ps.fixed();\n+\n+            ps.setValue(affineP);\n+            \/\/ 1P = P\n+            pointMultiples[1] = ps.fixed();\n+\n+            \/\/ the rest are calculated using mixed point addition\n+            for (int i = 2; i < 16; i++) {\n+                ecOps.setSum(ps, affineP, t0, t1, t2, t3, t4);\n+                pointMultiples[i] = ps.fixed();\n+            }\n+        }\n@@ -473,3 +531,31 @@\n-            private Default(ECOperations ecOps, AffinePoint affineP) {\n-                this.ecOps = ecOps;\n-                this.affineP = affineP;\n+        @Override\n+        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+            \/\/ 4-bit windowed multiply with branchless lookup.\n+            \/\/ The mixed addition is faster, so it is used to construct\n+            \/\/ the array at the beginning of the operation.\n+\n+            IntegerFieldModuloP field = ecOps.getField();\n+            ImmutableIntegerModuloP zero = field.get0();\n+            \/\/ temporaries\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n+\n+            ProjectivePoint.Mutable result = new ProjectivePoint.Mutable(field);\n+            result.getY().setValue(field.get1().mutable());\n+            ProjectivePoint.Mutable lookupResult = new ProjectivePoint.Mutable(field);\n+\n+            for (int i = s.length - 1; i >= 0; i--) {\n+                double4(result, t0, t1, t2, t3, t4);\n+\n+                int high = (0xFF & s[i]) >>> 4;\n+                PointMultiplier.lookup(pointMultiples, high, lookupResult);\n+                ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+\n+                double4(result, t0, t1, t2, t3, t4);\n+\n+                int low = 0xF & s[i];\n+                PointMultiplier.lookup(pointMultiples, low, lookupResult);\n+                ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n@@ -478,34 +564,2 @@\n-            @Override\n-            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n-                \/\/ 4-bit windowed multiply with branchless lookup.\n-                \/\/ The mixed addition is faster, so it is used to construct\n-                \/\/ the array at the beginning of the operation.\n-\n-                IntegerFieldModuloP field = affineP.getX().getField();\n-                ImmutableIntegerModuloP zero = field.get0();\n-                \/\/ temporaries\n-                MutableIntegerModuloP t0 = zero.mutable();\n-                MutableIntegerModuloP t1 = zero.mutable();\n-                MutableIntegerModuloP t2 = zero.mutable();\n-                MutableIntegerModuloP t3 = zero.mutable();\n-                MutableIntegerModuloP t4 = zero.mutable();\n-\n-                ProjectivePoint.Mutable result =\n-                        new ProjectivePoint.Mutable(field);\n-                result.getY().setValue(field.get1().mutable());\n-\n-                ProjectivePoint.Immutable[] pointMultiples =\n-                        new ProjectivePoint.Immutable[16];\n-                \/\/ 0P is neutral---same as initial result value\n-                pointMultiples[0] = result.fixed();\n-\n-                ProjectivePoint.Mutable ps = new ProjectivePoint.Mutable(field);\n-                ps.setValue(affineP);\n-                \/\/ 1P = P\n-                pointMultiples[1] = ps.fixed();\n-\n-                \/\/ the rest are calculated using mixed point addition\n-                for (int i = 2; i < 16; i++) {\n-                    ecOps.setSum(ps, affineP, t0, t1, t2, t3, t4);\n-                    pointMultiples[i] = ps.fixed();\n-                }\n+            return result;\n+        }\n@@ -513,1 +567,9 @@\n-                ProjectivePoint.Mutable lookupResult = ps.mutable();\n+        private void double4(ProjectivePoint.Mutable p,\n+                MutableIntegerModuloP t0, MutableIntegerModuloP t1,\n+                MutableIntegerModuloP t2, MutableIntegerModuloP t3,\n+                MutableIntegerModuloP t4) {\n+            for (int i = 0; i < 4; i++) {\n+                ecOps.setDouble(p, t0, t1, t2, t3, t4);\n+            }\n+        }\n+    }\n@@ -515,2 +577,33 @@\n-                for (int i = s.length - 1; i >= 0; i--) {\n-                    double4(result, t0, t1, t2, t3, t4);\n+    \/\/ Represents a multiplier with a larger precomputed table. Intended to be used for Basepoint multiplication\n+    sealed static abstract class P256LargeTableMultiplier implements PointMultiplier\n+        permits Secp256R1GeneratorMontgomeryMultiplier {\n+\n+        private final ImmutableIntegerModuloP zero;\n+        private final ImmutableIntegerModuloP one;\n+        private final ECOperations secp256r1Ops;\n+\n+        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n+\n+            ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n+                    zero.mutable(),\n+                    one.mutable(),\n+                    zero.mutable());\n+            ProjectivePoint.Mutable r = d.mutable();\n+            for (int i = 15; i >= 0; i--) {\n+                secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n+                for (int j = 3; j >= 0; j--) {\n+                    int pos = i + j * 16;\n+                    int index = (bit(s, pos + 192) << 3) |\n+                                (bit(s, pos + 128) << 2) |\n+                                (bit(s, pos +  64) << 1) |\n+                                    bit(s, pos);\n+\n+                    PointMultiplier.lookup(points[j], index, r);\n+                    secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n+                }\n+            }\n@@ -518,3 +611,2 @@\n-                    int high = (0xFF & s[i]) >>> 4;\n-                    lookup(pointMultiples, high, lookupResult);\n-                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+            return d;\n+        }\n@@ -522,1 +614,3 @@\n-                    double4(result, t0, t1, t2, t3, t4);\n+        private static int bit(byte[] k, int i) {\n+            return (k[i >> 3] >> (i & 0x07)) & 0x01;\n+        }\n@@ -524,3 +618,55 @@\n-                    int low = 0xF & s[i];\n-                    lookup(pointMultiples, low, lookupResult);\n-                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+        private final ProjectivePoint.Immutable[][] points;\n+\n+        protected P256LargeTableMultiplier(ECOperations secp256r1Ops, IntegerFieldModuloP field, PointMultiplier smallTableMultiplier) {\n+            zero = field.get0();\n+            one = field.get1();\n+            this.secp256r1Ops = secp256r1Ops;\n+\n+            \/\/ Pre-computed table to speed up the point multiplication.\n+            \/\/\n+            \/\/ This is a 4x16 array of ProjectivePoint.Immutable elements.\n+            \/\/ The first row contains the following multiples of the\n+            \/\/ generator.\n+            \/\/\n+            \/\/ index   |    point\n+            \/\/ --------+----------------\n+            \/\/ 0x0000  | 0G\n+            \/\/ 0x0001  | 1G\n+            \/\/ 0x0002  | (2^64)G\n+            \/\/ 0x0003  | (2^64 + 1)G\n+            \/\/ 0x0004  | 2^128G\n+            \/\/ 0x0005  | (2^128 + 1)G\n+            \/\/ 0x0006  | (2^128 + 2^64)G\n+            \/\/ 0x0007  | (2^128 + 2^64 + 1)G\n+            \/\/ 0x0008  | 2^192G\n+            \/\/ 0x0009  | (2^192 + 1)G\n+            \/\/ 0x000A  | (2^192 + 2^64)G\n+            \/\/ 0x000B  | (2^192 + 2^64 + 1)G\n+            \/\/ 0x000C  | (2^192 + 2^128)G\n+            \/\/ 0x000D  | (2^192 + 2^128 + 1)G\n+            \/\/ 0x000E  | (2^192 + 2^128 + 2^64)G\n+            \/\/ 0x000F  | (2^192 + 2^128 + 2^64 + 1)G\n+            \/\/\n+            \/\/ For the other 3 rows, points[i][j] = 2^16 * (points[i-1][j].\n+\n+            \/\/ Generate the pre-computed tables.  This block may be\n+            \/\/ replaced with hard-coded tables in order to speed up\n+            \/\/ the class loading.\n+            points = new ProjectivePoint.Immutable[4][16];\n+            BigInteger[] factors = new BigInteger[] {\n+                    BigInteger.ONE,\n+                    BigInteger.TWO.pow(64),\n+                    BigInteger.TWO.pow(128),\n+                    BigInteger.TWO.pow(192)\n+            };\n+\n+            base = new BigInteger[16];\n+            base[0] = BigInteger.ZERO;\n+            base[1] = BigInteger.ONE;\n+            base[2] = factors[1];\n+            for (int i = 3; i < 16; i++) {\n+                base[i] = BigInteger.ZERO;\n+                for (int k = 0; k < 4; k++) {\n+                    if (((i >>> k) & 0x01) != 0) {\n+                        base[i] = base[i].add(factors[k]);\n+                    }\n@@ -528,2 +674,0 @@\n-\n-                return result;\n@@ -532,6 +676,14 @@\n-            private void double4(ProjectivePoint.Mutable p,\n-                    MutableIntegerModuloP t0, MutableIntegerModuloP t1,\n-                    MutableIntegerModuloP t2, MutableIntegerModuloP t3,\n-                    MutableIntegerModuloP t4) {\n-                for (int i = 0; i < 4; i++) {\n-                    ecOps.setDouble(p, t0, t1, t2, t3, t4);\n+            for (int d = 0; d < 4; d++) {\n+                for (int w = 0; w < 16; w++) {\n+                    BigInteger bi = base[w];\n+                    if (d != 0) {\n+                        bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                    }\n+                    if (w == 0) {\n+                        points[d][0] = new ProjectivePoint.Immutable(zero.fixed(), one.fixed(), zero.fixed());\n+                    } else {\n+                        byte[] s = bi.toByteArray();\n+                        ArrayUtil.reverse(s);\n+                        ProjectivePoint.Mutable m = smallTableMultiplier.pointMultiply(s);\n+                        points[d][w] = m.fixed();\n+                    }\n@@ -542,35 +694,22 @@\n-        final class Secp256R1GeneratorMultiplier implements PointMultiplier {\n-            private static final ECPoint generator =\n-                    CurveDB.P_256.getGenerator();\n-            private static final PointMultiplier multiplier =\n-                    new Secp256R1GeneratorMultiplier();\n-\n-            private static final ImmutableIntegerModuloP zero =\n-                    IntegerPolynomialP256.ONE.get0();\n-            private static final ImmutableIntegerModuloP one =\n-                    IntegerPolynomialP256.ONE.get1();\n-\n-            @Override\n-            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n-                MutableIntegerModuloP t0 = zero.mutable();\n-                MutableIntegerModuloP t1 = zero.mutable();\n-                MutableIntegerModuloP t2 = zero.mutable();\n-                MutableIntegerModuloP t3 = zero.mutable();\n-                MutableIntegerModuloP t4 = zero.mutable();\n-\n-                ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n-                        zero.mutable(),\n-                        one.mutable(),\n-                        zero.mutable());\n-                ProjectivePoint.Mutable r = d.mutable();\n-                for (int i = 15; i >= 0; i--) {\n-                    secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n-                    for (int j = 3; j >= 0; j--) {\n-                        int pos = i + j * 16;\n-                        int index = (bit(s, pos + 192) << 3) |\n-                                    (bit(s, pos + 128) << 2) |\n-                                    (bit(s, pos +  64) << 1) |\n-                                     bit(s, pos);\n-\n-                        lookup(P256.points[j], index, r);\n-                        secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n+        private final BigInteger[] base;\n+        protected void verifyTables(PointMultiplier multiplier) {\n+            for (int d = 0; d < 4; d++) {\n+                for (int w = 0; w < 16; w++) {\n+                    BigInteger bi = base[w];\n+                    if (d != 0) {\n+                        bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                    }\n+                    if (w != 0) {\n+                        byte[] s = new byte[32];\n+                        byte[] b = bi.toByteArray();\n+                        ArrayUtil.reverse(b);\n+                        System.arraycopy(b, 0, s, 0, b.length);\n+\n+                        \/\/ Compare this multiplier to the table (generated by Default multiplier)\n+                        AffinePoint m = multiplier.pointMultiply(s).asAffine();\n+                        AffinePoint v = points[d][w].asAffine();\n+                        if (!v.getX().asBigInteger().equals(m.getX().asBigInteger()) ||\n+                            !v.getY().asBigInteger().equals(m.getY().asBigInteger())) {\n+                            java.util.HexFormat hex = java.util.HexFormat.of();\n+                            throw new RuntimeException(\"Bad multiple found at [\"+d+\"][\"+w+\"]\" + hex.formatHex(s) + \" \" + m.getX().asBigInteger());\n+                        }\n@@ -579,2 +718,0 @@\n-\n-                return d;\n@@ -582,0 +719,2 @@\n+        }\n+    }\n@@ -583,3 +722,4 @@\n-            private static int bit(byte[] k, int i) {\n-                return (k[i >> 3] >> (i & 0x07)) & 0x01;\n-            }\n+    final static class DefaultMultiplier extends SmallWindowMultiplier {\n+        public DefaultMultiplier(ECOperations ecOps, AffinePoint affineP) {\n+            super(ecOps, affineP);\n+        }\n@@ -587,54 +727,4 @@\n-            \/\/ Lazy loading of the tables.\n-            private static final class P256 {\n-                \/\/ Pre-computed table to speed up the point multiplication.\n-                \/\/\n-                \/\/ This is a 4x16 array of ProjectivePoint.Immutable elements.\n-                \/\/ The first row contains the following multiples of the\n-                \/\/ generator.\n-                \/\/\n-                \/\/ index   |    point\n-                \/\/ --------+----------------\n-                \/\/ 0x0000  | 0G\n-                \/\/ 0x0001  | 1G\n-                \/\/ 0x0002  | (2^64)G\n-                \/\/ 0x0003  | (2^64 + 1)G\n-                \/\/ 0x0004  | 2^128G\n-                \/\/ 0x0005  | (2^128 + 1)G\n-                \/\/ 0x0006  | (2^128 + 2^64)G\n-                \/\/ 0x0007  | (2^128 + 2^64 + 1)G\n-                \/\/ 0x0008  | 2^192G\n-                \/\/ 0x0009  | (2^192 + 1)G\n-                \/\/ 0x000A  | (2^192 + 2^64)G\n-                \/\/ 0x000B  | (2^192 + 2^64 + 1)G\n-                \/\/ 0x000C  | (2^192 + 2^128)G\n-                \/\/ 0x000D  | (2^192 + 2^128 + 1)G\n-                \/\/ 0x000E  | (2^192 + 2^128 + 2^64)G\n-                \/\/ 0x000F  | (2^192 + 2^128 + 2^64 + 1)G\n-                \/\/\n-                \/\/ For the other 3 rows, points[i][j] = 2^16 * (points[i-1][j].\n-                private static final ProjectivePoint.Immutable[][] points;\n-\n-                \/\/ Generate the pre-computed tables.  This block may be\n-                \/\/ replaced with hard-coded tables in order to speed up\n-                \/\/ the class loading.\n-                static {\n-                    points = new ProjectivePoint.Immutable[4][16];\n-                    BigInteger[] factors = new BigInteger[] {\n-                            BigInteger.ONE,\n-                            BigInteger.TWO.pow(64),\n-                            BigInteger.TWO.pow(128),\n-                            BigInteger.TWO.pow(192)\n-                    };\n-\n-                    BigInteger[] base = new BigInteger[16];\n-                    base[0] = BigInteger.ZERO;\n-                    base[1] = BigInteger.ONE;\n-                    base[2] = factors[1];\n-                    for (int i = 3; i < 16; i++) {\n-                        base[i] = BigInteger.ZERO;\n-                        for (int k = 0; k < 4; k++) {\n-                            if (((i >>> k) & 0x01) != 0) {\n-                                base[i] = base[i].add(factors[k]);\n-                            }\n-                        }\n-                    }\n+        public DefaultMultiplier(ECOperations ecOps, ECPoint ecPoint) {\n+            super(ecOps, AffinePoint.fromECPoint(ecPoint, ecOps.getField()));\n+        }\n+    }\n@@ -642,21 +732,2 @@\n-                    for (int d = 0; d < 4; d++) {\n-                        for (int w = 0; w < 16; w++) {\n-                            BigInteger bi = base[w];\n-                            if (d != 0) {\n-                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n-                            }\n-                            if (w == 0) {\n-                                points[d][0] = new ProjectivePoint.Immutable(\n-                                    zero.fixed(), one.fixed(), zero.fixed());\n-                            } else {\n-                                PointMultiplier multiplier = new Default(\n-                                    secp256r1Ops, AffinePoint.fromECPoint(\n-                                        generator, zero.getField()));\n-                                byte[] s = bi.toByteArray();\n-                                ArrayUtil.reverse(s);\n-                                ProjectivePoint.Mutable m =\n-                                        multiplier.pointMultiply(s);\n-                                points[d][w] = m.setValue(m.asAffine()).fixed();\n-                            }\n-                        }\n-                    }\n+    final static class DefaultMontgomeryMultiplier extends SmallWindowMultiplier {\n+        private final IntegerMontgomeryFieldModuloP montField;\n@@ -664,5 +735,4 @@\n-                    \/\/ Check that the tables are correctly generated.\n-                    if (ECOperations.class.desiredAssertionStatus()) {\n-                        verifyTables(base);\n-                    }\n-                }\n+        public DefaultMontgomeryMultiplier(ECOperations ecOps, ECPoint ecPoint) {\n+            super(ecOps, AffinePoint.fromECPoint(ecPoint, ecOps.getField()));\n+            this.montField = (IntegerMontgomeryFieldModuloP)ecOps.getField();\n+        }\n@@ -670,27 +740,30 @@\n-                private static void verifyTables(BigInteger[] base) {\n-                    for (int d = 0; d < 4; d++) {\n-                        for (int w = 0; w < 16; w++) {\n-                            BigInteger bi = base[w];\n-                            if (d != 0) {\n-                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n-                            }\n-                            if (w != 0) {\n-                                byte[] s = new byte[32];\n-                                byte[] b = bi.toByteArray();\n-                                ArrayUtil.reverse(b);\n-                                System.arraycopy(b, 0, s, 0, b.length);\n-\n-                                ProjectivePoint.Mutable m =\n-                                        multiplier.pointMultiply(s);\n-                                ProjectivePoint.Immutable v =\n-                                        m.setValue(m.asAffine()).fixed();\n-                                if (!v.getX().asBigInteger().equals(\n-                                        points[d][w].getX().asBigInteger()) ||\n-                                    !v.getY().asBigInteger().equals(\n-                                        points[d][w].getY().asBigInteger())) {\n-                                    throw new RuntimeException();\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+        \/**\n+         * Returns result ProjectivePoint in Montgomery domain, so that subsequent operations can also be done in Montgomery domain\n+         * Conversion to residue domain is implicit when this ProjectivePoint is converted to asAffine().\n+         *\/\n+        @Override\n+        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+            ProjectivePoint.Mutable result = super.pointMultiply(s);\n+            return new ProjectivePoint.MontgomeryMutable(montField,\n+                result.getX(),\n+                result.getY(),\n+                result.getZ());\n+        }\n+    }\n+\n+    final static class Secp256R1GeneratorMontgomeryMultiplier extends P256LargeTableMultiplier {\n+        private static final ECOperations secp256r1Ops = new ECOperations(\n+                MontgomeryIntegerPolynomialP256.ONE.getElement(CurveDB.P_256.getCurve().getB()),\n+                P256OrderField.ONE);\n+        public static final ECPoint generator = CurveDB.P_256.getGenerator();\n+        public static final PointMultiplier multiplier = new Secp256R1GeneratorMontgomeryMultiplier();\n+\n+        private Secp256R1GeneratorMontgomeryMultiplier() {\n+            super(\n+                secp256r1Ops,\n+                MontgomeryIntegerPolynomialP256.ONE,\n+                new DefaultMontgomeryMultiplier(secp256r1Ops, generator));\n+\n+            \/\/ Check that the tables are correctly generated.\n+            if (ECOperations.class.desiredAssertionStatus()) {\n+                verifyTables(this);\n@@ -699,0 +772,13 @@\n+\n+        \/**\n+         * Returns result ProjectivePoint in Montgomery domain, so that subsequent operations can also be done in Montgomery domain\n+         * Conversion to residue domain is implicit when this ProjectivePoint is converted to asAffine().\n+         *\/\n+        @Override\n+        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+            ProjectivePoint.Mutable result = super.pointMultiply\/*Base*\/(s);\n+            return new ProjectivePoint.MontgomeryMutable(MontgomeryIntegerPolynomialP256.ONE,\n+                result.getX(),\n+                result.getY(),\n+                result.getZ());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":330,"deletions":244,"binary":false,"changes":574,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -148,0 +149,1 @@\n+        @ForceInline\n@@ -190,0 +192,42 @@\n+    public static class MontgomeryImmutable extends Immutable {\n+        private final IntegerMontgomeryFieldModuloP montField;\n+\n+        public MontgomeryImmutable(IntegerMontgomeryFieldModuloP montField,\n+                ImmutableIntegerModuloP x,\n+                ImmutableIntegerModuloP y,\n+                ImmutableIntegerModuloP z) {\n+            super(x, y, z);\n+            this.montField = montField;\n+        }\n+\n+        public AffinePoint asAffine() {\n+            IntegerModuloP zInv = z.multiplicativeInverse();\n+            ImmutableIntegerModuloP xResidue = montField.fromMontgomery(x.multiply(zInv));\n+            ImmutableIntegerModuloP yResidue = montField.fromMontgomery(y.multiply(zInv));\n+            return new AffinePoint(xResidue, yResidue);\n+        }\n+    }\n+\n+    public static class MontgomeryMutable extends Mutable {\n+        private final IntegerMontgomeryFieldModuloP montField;\n+\n+        public MontgomeryMutable(IntegerMontgomeryFieldModuloP montField,\n+                MutableIntegerModuloP x,\n+                MutableIntegerModuloP y,\n+                MutableIntegerModuloP z) {\n+            super(x, y, z);\n+            this.montField = montField;\n+        }\n+\n+        public AffinePoint asAffine() {\n+            IntegerModuloP zInv = z.multiplicativeInverse();\n+            ImmutableIntegerModuloP xResidue = montField.fromMontgomery(x.multiply(zInv));\n+            ImmutableIntegerModuloP yResidue = montField.fromMontgomery(y.multiply(zInv));\n+            return new AffinePoint(xResidue, yResidue);\n+        }\n+\n+        @Override\n+        public Immutable fixed() {\n+            return new MontgomeryImmutable(montField, x.fixed(), y.fixed(), z.fixed());\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/ProjectivePoint.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util.math;\n+\n+import java.math.BigInteger;\n+\n+\/**\n+ * An interface for the field of integers modulo a prime number. An\n+ * implementation of this interface can be used to get properties of the\n+ * field and to produce field elements of type ImmutableIntegerModuloP from\n+ * other objects and representations of field elements.\n+ *\/\n+\n+public interface IntegerMontgomeryFieldModuloP extends IntegerFieldModuloP {\n+    ImmutableIntegerModuloP fromMontgomery(ImmutableIntegerModuloP m);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/IntegerMontgomeryFieldModuloP.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n@@ -64,1 +67,1 @@\n-            IntegerPolynomial448, IntegerPolynomialP256,\n+            IntegerPolynomial448, IntegerPolynomialP256, MontgomeryIntegerPolynomialP256,\n@@ -77,1 +80,2 @@\n-    private final int maxAdds;\n+    private final int maxAddsMul; \/\/ max additions before a multiplication\n+    private final int maxAddsAdd; \/\/ max additions before an addition\n@@ -90,1 +94,1 @@\n-    protected void multByInt(long[] a, long b) {\n+    protected int multByInt(long[] a, long b) {\n@@ -95,0 +99,1 @@\n+        return 0;\n@@ -103,1 +108,1 @@\n-    protected abstract void mult(long[] a, long[] b, long[] r);\n+    protected abstract int mult(long[] a, long[] b, long[] r);\n@@ -111,1 +116,1 @@\n-    protected abstract void square(long[] a, long[] r);\n+    protected abstract int square(long[] a, long[] r);\n@@ -115,1 +120,1 @@\n-                      int maxAdds,\n+                      int maxAddsMul,\n@@ -122,2 +127,6 @@\n-        this.maxAdds = maxAdds;\n-\n+        this.maxAddsMul = maxAddsMul;\n+        if (bitsPerLimb>32) {\n+            this.maxAddsAdd = 64 - bitsPerLimb;\n+        } else {\n+            this.maxAddsAdd = 32 - bitsPerLimb;\n+        }\n@@ -138,1 +147,1 @@\n-        return maxAdds;\n+        return maxAddsMul;\n@@ -330,1 +339,0 @@\n-        assert bitsPerLimb < 32;\n@@ -333,1 +341,1 @@\n-            limbs[i] = v.intValue() & limbMask;\n+            limbs[i] = v.longValue() & limbMask;\n@@ -452,0 +460,2 @@\n+    @ForceInline\n+    @IntrinsicCandidate\n@@ -560,2 +570,1 @@\n-            \/\/ if (numAdds >= maxAdds) {\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -566,2 +575,1 @@\n-            \/\/ if (b.numAdds >= maxAdds) {\n-            if (b.numAdds > 32 - bitsPerLimb) {\n+            if (b.numAdds > maxAddsAdd) {\n@@ -589,1 +597,1 @@\n-            return new ImmutableElement(newLimbs, numAdds);\n+            return new ImmutableElement(newLimbs, numAdds+1);\n@@ -607,1 +615,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -612,1 +620,1 @@\n-            if (b.numAdds > maxAdds) {\n+            if (b.numAdds > maxAddsMul) {\n@@ -618,2 +626,2 @@\n-            mult(limbs, b.limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, 0);\n+            int numAdds = mult(limbs, b.limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, numAdds);\n@@ -625,1 +633,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -631,2 +639,2 @@\n-            IntegerPolynomial.this.square(limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, 0);\n+            int numAdds = IntegerPolynomial.this.square(limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, numAdds);\n@@ -640,1 +648,1 @@\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -645,1 +653,1 @@\n-            if (other.numAdds > 32 - bitsPerLimb) {\n+            if (other.numAdds > maxAddsAdd) {\n@@ -737,1 +745,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -742,1 +750,1 @@\n-            if (b.numAdds > maxAdds) {\n+            if (b.numAdds > maxAddsMul) {\n@@ -747,2 +755,1 @@\n-            mult(limbs, b.limbs, limbs);\n-            numAdds = 0;\n+            numAdds = mult(limbs, b.limbs, limbs);\n@@ -755,1 +762,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -761,2 +768,1 @@\n-            multByInt(limbs, value);\n-            numAdds = 0;\n+            numAdds += multByInt(limbs, value);\n@@ -772,2 +778,1 @@\n-            \/\/ if (numAdds >= maxAdds) {\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -778,2 +783,1 @@\n-            \/\/ if (b.numAdds >= maxAdds) {\n-            if (b.numAdds > 32 - bitsPerLimb) {\n+            if (b.numAdds > maxAddsAdd) {\n@@ -798,2 +802,1 @@\n-            \/\/ if (numAdds >= maxAdds) {\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -804,2 +807,1 @@\n-            \/\/ if (b.numAdds >= maxAdds) {\n-            if (b.numAdds > 32 - bitsPerLimb) {\n+            if (b.numAdds > maxAddsAdd) {\n@@ -821,1 +823,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -826,2 +828,1 @@\n-            IntegerPolynomial.this.square(limbs, limbs);\n-            numAdds = 0;\n+            numAdds = IntegerPolynomial.this.square(limbs, limbs);;\n@@ -836,0 +837,1 @@\n+            numAdds++;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":45,"deletions":43,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    protected void mult(long[] a, long[] b, long[] r) {\n+    protected int mult(long[] a, long[] b, long[] r) {\n@@ -76,0 +76,1 @@\n+        return 0;\n@@ -102,1 +103,1 @@\n-    protected void square(long[] a, long[] r) {\n+    protected int square(long[] a, long[] r) {\n@@ -125,0 +126,1 @@\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial1305.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    protected void mult(long[] a, long[] b, long[] r) {\n+    protected int mult(long[] a, long[] b, long[] r) {\n@@ -139,0 +139,1 @@\n+        return 0;\n@@ -191,1 +192,1 @@\n-    protected void square(long[] a, long[] r) {\n+    protected int square(long[] a, long[] r) {\n@@ -202,1 +203,1 @@\n-\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialModBinP.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,418 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util.math.intpoly;\n+\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.SmallValue;\n+import java.lang.Math;\n+import java.math.BigInteger;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/\/ Reference:\n+\/\/ - [1] Shay Gueron and Vlad Krasnov \"Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes\"\n+\/\/\n+public final class MontgomeryIntegerPolynomialP256 extends IntegerPolynomial implements IntegerMontgomeryFieldModuloP {\n+    private static final int BITS_PER_LIMB = 52;\n+    private static final int NUM_LIMBS = 5;\n+    private static final int MAX_ADDS = 0;\n+    public static final BigInteger MODULUS = evaluateModulus();\n+    private static final long LIMB_MASK = -1L >>> (64 - BITS_PER_LIMB);\n+\n+    public static final MontgomeryIntegerPolynomialP256 ONE = new MontgomeryIntegerPolynomialP256();\n+\n+    \/\/ h = 2^(2*260)%p = 0x4fffffffdfffffffffffffffefffffffbffffffff000000000000000300\n+    \/\/ oneActual = 1\n+    \/\/ oneMont = (1*2^260) mod p\n+    \/\/ modulus = p\n+    private static final long[] h         = new long[]{ 0x0000000000000300L, 0x000ffffffff00000L, 0x000ffffefffffffbL, 0x000fdfffffffffffL, 0x0000000004ffffffL};\n+    private static final long[] oneActual = new long[]{ 0x0000000000000001L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L};\n+    private static final long[] oneMont   = new long[]{ 0x0000000000000010L, 0x000f000000000000L, 0x000fffffffffffffL, 0x000ffeffffffffffL, 0x00000000000fffffL};\n+    private static final long[] zero      = new long[]{ 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L};\n+    private static final long[] modulus   = new long[]{ 0x000fffffffffffffL, 0x00000fffffffffffL, 0x0000000000000000L, 0x0000001000000000L, 0x0000ffffffff0000L};\n+\n+    private MontgomeryIntegerPolynomialP256() {\n+        super(BITS_PER_LIMB, NUM_LIMBS, MAX_ADDS, MODULUS);\n+    }\n+\n+    \/\/(224%nat,-1)::(192%nat,1)::(96%nat,1)::(0%nat,-1)::nil.\n+    private static BigInteger evaluateModulus() {\n+        BigInteger result = BigInteger.valueOf(2).pow(256);\n+        result = result.subtract(BigInteger.valueOf(1).shiftLeft(224));\n+        result = result.add(BigInteger.valueOf(1).shiftLeft(192));\n+        result = result.add(BigInteger.valueOf(1).shiftLeft(96));\n+        result = result.subtract(BigInteger.valueOf(1));\n+        return result;\n+    }\n+\n+    @Override\n+    public ImmutableElement get0() {\n+        return new ImmutableElement(zero, 0);\n+    }\n+\n+    \/\/ One in montgomery domain: (1*2^260) mod p\n+    @Override\n+    public ImmutableElement get1() {\n+        return new ImmutableElement(oneMont, 0);\n+    }\n+\n+    \/\/ Convert v to Montgomery domain\n+    @Override\n+    public ImmutableElement getElement(BigInteger v) {\n+        long[] vLimbs = new long[NUM_LIMBS];\n+        long[] montLimbs = new long[NUM_LIMBS];\n+        setLimbsValuePositive(v, vLimbs);\n+\n+        \/\/ Convert to Montgomery domain\n+        int numAdds = mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, numAdds);\n+    }\n+\n+    @Override\n+    public SmallValue getSmallValue(int value) {\n+        \/\/ Explicitely here as reminder that SmallValue stays in residue domain\n+        \/\/ See multByInt below for how this is used\n+        return super.getSmallValue(value);\n+    }\n+\n+    \/*\n+     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to multiply\n+     * by a small constant (i.e. (int) 1,2,3,4). Instead of doing a montgomery conversion\n+     * followed by a montgomery multiplication, just use the spare top (64-BITS_PER_LIMB) bits\n+     * to multiply by a constant. (See [1] Section 4 )\n+     *\n+     * Will return an unreduced value\n+     *\/\n+    @Override\n+    protected int multByInt(long[] a, long b) {\n+        assert(b< (1<<BITS_PER_LIMB));\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] *= b;\n+        }\n+        return (int)(b-1);\n+    }\n+\n+    @Override\n+    public ImmutableIntegerModuloP fromMontgomery(ImmutableIntegerModuloP n) {\n+        assert n.getField() == MontgomeryIntegerPolynomialP256.ONE;\n+\n+        ImmutableElement nn = (ImmutableElement)n;\n+        long[] r1 = new long[NUM_LIMBS];\n+        long[] r2 = new long[2*NUM_LIMBS];\n+        long[] limbs = nn.getLimbs();\n+        reduce(limbs);\n+        MontgomeryIntegerPolynomialP256.ONE.mult(limbs, oneActual, r1);\n+        reduce(r1);\n+        halfLimbs(r1, r2);\n+        return IntegerPolynomialP256.ONE.new ImmutableElement(r2, 0);\n+    }\n+\n+    private void halfLimbs(long[] a, long[] r) {\n+        final long HALF_BITS_LIMB = BITS_PER_LIMB\/2;\n+        final long HALF_LIMB_MASK = -1L >>> (64 - HALF_BITS_LIMB);\n+        r[0] = a[0] & HALF_LIMB_MASK;\n+        r[1] = a[0] >> HALF_BITS_LIMB;\n+        r[2] = a[1] & HALF_LIMB_MASK;\n+        r[3] = a[1] >> HALF_BITS_LIMB;\n+        r[4] = a[2] & HALF_LIMB_MASK;\n+        r[5] = a[2] >> HALF_BITS_LIMB;\n+        r[6] = a[3] & HALF_LIMB_MASK;\n+        r[7] = a[3] >> HALF_BITS_LIMB;\n+        r[8] = a[4] & HALF_LIMB_MASK;\n+        r[9] = a[4] >> HALF_BITS_LIMB;\n+    }\n+\n+    @Override\n+    protected int square(long[] a, long[] r) {\n+        return mult(a, a, r);\n+    }\n+\n+    \/**\n+     * Unrolled Word-by-Word Montgomery Multiplication\n+     * r = a * b * 2^-260 (mod P)\n+     *\n+     * See [1] Figure 5. \"Algorithm 2: Word-by-Word Montgomery Multiplication for a Montgomery\n+     * Friendly modulus p\". Note: Step 6. Skipped; Instead use numAdds to reuse existing overflow\n+     * logic.\n+     *\/\n+    @IntrinsicCandidate\n+    protected int mult(long[] a, long[] b, long[] r) {\n+        long aa0 = a[0];\n+        long aa1 = a[1];\n+        long aa2 = a[2];\n+        long aa3 = a[3];\n+        long aa4 = a[4];\n+\n+        long bb0 = b[0];\n+        long bb1 = b[1];\n+        long bb2 = b[2];\n+        long bb3 = b[3];\n+        long bb4 = b[4];\n+\n+        final long shift1 = 64 - BITS_PER_LIMB; \/\/ 12\n+        final long shift2 = BITS_PER_LIMB;      \/\/ 40\n+\n+        long d0, d1, d2, d3, d4;       \/\/ low digits from multiplication\n+        long dd0, dd1, dd2, dd3, dd4;  \/\/ high digits from multiplication\n+        long n, n0, n1, n2, n3, n4, nn0, nn1, nn2, nn3, nn4; \/\/ modulus multiple digits\n+        long c0, c1, c2, c3, c4, c5, c6, c7, c8, c9;         \/\/ multiplication result digits for each column\n+\n+        \/\/ Row 0 - multiply by aa0 and reduce out c0\n+        d0 = aa0 * bb0; dd0 = Math.unsignedMultiplyHigh(aa0, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; n = d0;\n+        d1 = aa0 * bb1; dd1 = Math.unsignedMultiplyHigh(aa0, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n+        d2 = aa0 * bb2; dd2 = Math.unsignedMultiplyHigh(aa0, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n+        d3 = aa0 * bb3; dd3 = Math.unsignedMultiplyHigh(aa0, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n+        d4 = aa0 * bb4; dd4 = Math.unsignedMultiplyHigh(aa0, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0]; nn0 = Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); n0 &= LIMB_MASK;\n+        n1 = n * modulus[1]; nn1 = Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); n1 &= LIMB_MASK;\n+        n2 = n * modulus[2]; nn2 = Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); n2 &= LIMB_MASK;\n+        n3 = n * modulus[3]; nn3 = Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); n3 &= LIMB_MASK;\n+        n4 = n * modulus[4]; nn4 = Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); n4 &= LIMB_MASK;\n+\n+        dd0 += nn0; d0 += n0;\n+        dd1 += nn1; d1 += n1;\n+        dd2 += nn2; d2 += n2;\n+        dd3 += nn3; d3 += n3;\n+        dd4 += nn4; d4 += n4;\n+\n+        c1 = d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c2 = d2 + dd1;\n+        c3 = d3 + dd2;\n+        c4 = d4 + dd3;\n+        c5 = dd4;\n+\n+        \/\/ Row 1 - multiply by aa1 and reduce out c1\n+        d0 = aa1 * bb0; dd0 = Math.unsignedMultiplyHigh(aa1, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; d0 += c1; n = d0 & LIMB_MASK;\n+        d1 = aa1 * bb1; dd1 = Math.unsignedMultiplyHigh(aa1, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n+        d2 = aa1 * bb2; dd2 = Math.unsignedMultiplyHigh(aa1, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n+        d3 = aa1 * bb3; dd3 = Math.unsignedMultiplyHigh(aa1, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n+        d4 = aa1 * bb4; dd4 = Math.unsignedMultiplyHigh(aa1, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0]; dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1]; dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2]; dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3]; dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4]; dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); d4 += n4 & LIMB_MASK;\n+\n+        c2 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c3 += d2 + dd1;\n+        c4 += d3 + dd2;\n+        c5 += d4 + dd3;\n+        c6 = dd4;\n+\n+        \/\/ Row 2 - multiply by aa2 and reduce out c2\n+        d0 = aa2 * bb0; dd0 = Math.unsignedMultiplyHigh(aa2, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; d0 += c2; n = d0 & LIMB_MASK;\n+        d1 = aa2 * bb1; dd1 = Math.unsignedMultiplyHigh(aa2, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n+        d2 = aa2 * bb2; dd2 = Math.unsignedMultiplyHigh(aa2, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n+        d3 = aa2 * bb3; dd3 = Math.unsignedMultiplyHigh(aa2, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n+        d4 = aa2 * bb4; dd4 = Math.unsignedMultiplyHigh(aa2, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0]; dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1]; dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2]; dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3]; dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4]; dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); d4 += n4 & LIMB_MASK;\n+\n+        c3 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c4 += d2 + dd1;\n+        c5 += d3 + dd2;\n+        c6 += d4 + dd3;\n+        c7 = dd4;\n+\n+        \/\/ Row 3 - multiply by aa3 and reduce out c3\n+        d0 = aa3 * bb0; dd0 = Math.unsignedMultiplyHigh(aa3, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; d0 += c3; n = d0 & LIMB_MASK;\n+        d1 = aa3 * bb1; dd1 = Math.unsignedMultiplyHigh(aa3, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n+        d2 = aa3 * bb2; dd2 = Math.unsignedMultiplyHigh(aa3, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n+        d3 = aa3 * bb3; dd3 = Math.unsignedMultiplyHigh(aa3, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n+        d4 = aa3 * bb4; dd4 = Math.unsignedMultiplyHigh(aa3, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0]; dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1]; dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2]; dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3]; dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4]; dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); d4 += n4 & LIMB_MASK;\n+\n+        c4 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c5 += d2 + dd1;\n+        c6 += d3 + dd2;\n+        c7 += d4 + dd3;\n+        c8 = dd4;\n+\n+        \/\/ Row 4 - multiply by aa3 and reduce out c4\n+        d0 = aa4 * bb0; dd0 = Math.unsignedMultiplyHigh(aa4, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; d0 += c4; n = d0 & LIMB_MASK;\n+        d1 = aa4 * bb1; dd1 = Math.unsignedMultiplyHigh(aa4, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n+        d2 = aa4 * bb2; dd2 = Math.unsignedMultiplyHigh(aa4, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n+        d3 = aa4 * bb3; dd3 = Math.unsignedMultiplyHigh(aa4, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n+        d4 = aa4 * bb4; dd4 = Math.unsignedMultiplyHigh(aa4, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0]; dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1]; dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2]; dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3]; dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4]; dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); d4 += n4 & LIMB_MASK;\n+\n+        c5 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c6 += d2 + dd1 + (c5 >>> BITS_PER_LIMB);\n+        c7 += d3 + dd2 + (c6 >>> BITS_PER_LIMB);\n+        c8 += d4 + dd3 + (c7 >>> BITS_PER_LIMB);\n+        c9 =       dd4 + (c8 >>> BITS_PER_LIMB);\n+\n+        c5 &= LIMB_MASK;\n+        c6 &= LIMB_MASK;\n+        c7 &= LIMB_MASK;\n+        c8 &= LIMB_MASK;\n+\n+        \/\/ At this point, the result could overflow by one modulus.\n+        c0 = c5 - modulus[0];\n+        c1 = c6 - modulus[1] + (c0 >> BITS_PER_LIMB); c0 &= LIMB_MASK;\n+        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB); c1 &= LIMB_MASK;\n+        c3 = c8 - modulus[3] + (c2 >> BITS_PER_LIMB); c2 &= LIMB_MASK;\n+        c4 = c9 - modulus[4] + (c3 >> BITS_PER_LIMB); c3 &= LIMB_MASK;\n+\n+        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        r[0] =  ((c5 & mask) | (c0 & ~mask));\n+        r[1] =  ((c6 & mask) | (c1 & ~mask));\n+        r[2] =  ((c7 & mask) | (c2 & ~mask));\n+        r[3] =  ((c8 & mask) | (c3 & ~mask));\n+        r[4] =  ((c9 & mask) | (c4 & ~mask));\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    protected void finalCarryReduceLast(long[] limbs) {\n+        reduce(limbs);\n+    }\n+\n+    @Override\n+    protected long carryValue(long x) {\n+        return x >> BITS_PER_LIMB;\n+    }\n+\n+    @Override\n+    protected void postEncodeCarry(long[] v) {\n+        \/\/ not needed because carry is unsigned\n+    }\n+\n+    \/\/ Proof:\n+    \/\/ carry * 2^256 (mod p) ==  carry * [2^256 - p] (mod p)\n+    \/\/                       ==  carry * [2^256 - (2^256 -2^224 +2^192 +2^96 -1)] (mod p)\n+    \/\/                       ==  carry * [2^224 -2^192 -2^96 +1] (mod p)\n+    @Override\n+    protected void reduce(long[] limbs) {\n+        long b0 = limbs[0];\n+        long b1 = limbs[1];\n+        long b2 = limbs[2];\n+        long b3 = limbs[3];\n+        long b4 = limbs[4];\n+        long carry = b4>>48; \/\/max 16-bits\n+        b4 -= carry<<48;\n+\n+        \/\/ 2^0 position\n+        b0 += carry;\n+        \/\/ -2^96\n+        b1 -= carry<<44;\n+        \/\/ -2^192\n+        b3 -= carry<<36;\n+        \/\/ 2^224\n+        b4 += carry<<16;\n+\n+        b1 += b0 >> BITS_PER_LIMB;\n+        b2 += b1 >> BITS_PER_LIMB;\n+        b3 += b2 >> BITS_PER_LIMB;\n+        b4 += b3 >> BITS_PER_LIMB;\n+\n+        b0 &= LIMB_MASK;\n+        b1 &= LIMB_MASK;\n+        b2 &= LIMB_MASK;\n+        b3 &= LIMB_MASK;\n+\n+        long c0, c1, c2, c3, c4;\n+        c0 = modulus[0] + b0;\n+        c1 = modulus[1] + b1 + (c0 >> BITS_PER_LIMB); c0 &= LIMB_MASK;\n+        c2 = modulus[2] + b2 + (c1 >> BITS_PER_LIMB); c1 &= LIMB_MASK;\n+        c3 = modulus[3] + b3 + (c2 >> BITS_PER_LIMB); c2 &= LIMB_MASK;\n+        c4 = modulus[4] + b4 + (c3 >> BITS_PER_LIMB); c3 &= LIMB_MASK;\n+\n+        long mask = b4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        limbs[0] = (b0 & ~mask) | (c0 & mask);\n+        limbs[1] = (b1 & ~mask) | (c1 & mask);\n+        limbs[2] = (b2 & ~mask) | (c2 & mask);\n+        limbs[3] = (b3 & ~mask) | (c3 & mask);\n+        limbs[4] = (b4 & ~mask) | (c4 & mask);\n+    }\n+\n+    public ImmutableElement getElement(byte[] v, int offset, int length,\n+                                       byte highByte) {\n+\n+        long[] vLimbs = new long[NUM_LIMBS];\n+        long[] montLimbs = new long[NUM_LIMBS];\n+        super.encode(v, offset, length, highByte, vLimbs);\n+\n+        \/\/ Convert to Montgomery domain\n+        int numAdds = mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, numAdds);\n+    }\n+\n+    \/*\n+     * This function 'moves\/reduces' digit 'v' to the 'lower' limbs\n+     *\n+     * The result is not reduced further. Carry propagation is not performed\n+     * (see IntegerPolynomial.reduceHigh() for how this method is used)\n+     *\n+     * Proof:\n+     *   v * 2^(i*52) (mod p) ==  v * 2^(52i) - v * 2^(52i-256) * p                               (mod p)\n+     *                        ==  v * 2^(52i) - v * 2^(52i-256) * (2^256 -2^224 +2^192 +2^96 -1)  (mod p)\n+     *                        ==  v * 2^(52i) - v * [2^(52i-256+256) -2^(52i-256+224) +2^(52i-256+192) +2^(52i-256+96) -2^(52i-256)] (mod p)\n+     *                        ==  v * 2^(52i) - v * [2^(52i) -2^(52i-32) +2^(52i-64) +2^(52i-160) -2^(52i-256)]                      (mod p)\n+     *\n+     *                        ==  v * [2^(52i-32) +2^(52i-52-12) +2^(52i-3*52-4) -2^(52i-4*52-48)] (mod p)\n+     *\/\n+    @Override\n+    protected void reduceIn(long[] limbs, long v, int i) {\n+        \/\/ Since top term (2^(52i-32)) will leave top 20 bits back in the same position i,\n+        \/\/ \"repeat same reduction on top 20 bits\"\n+        v += v>>32;\n+\n+        \/\/ 2^(52i-32)\n+        limbs[i-1] += (v << 20) & LIMB_MASK;\n+\n+        \/\/ 2^(52i-52-12)\n+        limbs[i-2] -= (v<<40) & LIMB_MASK;\n+        limbs[i-1] -= v>>12;\n+\n+        \/\/ 2^(52i-3*52-4)\n+        limbs[i-4] -= (v<<48) & LIMB_MASK;\n+        limbs[i-3] -= v>>4;\n+\n+        \/\/ 2^(52i-4*52-48)\n+        limbs[i-5] += (v<<4) & LIMB_MASK;\n+        limbs[i-4] += v>>48;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":418,"deletions":0,"binary":false,"changes":418,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2023, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import java.math.BigInteger;\n+import java.lang.reflect.Field;\n+import java.security.spec.ECParameterSpec;\n+import sun.security.ec.ECOperations;\n+import sun.security.util.ECUtil;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.CurveDB;\n+import sun.security.ec.point.*;\n+import java.security.spec.ECPoint;\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm\/timeout=1200 --add-opens java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics ECOperationsFuzzTest\n+ * @summary Unit test ECOperationsFuzzTest.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm\/timeout=1200 --add-opens java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions -XX:+UseIntPolyIntrinsics ECOperationsFuzzTest\n+ * @summary Unit test ECOperationsFuzzTest.\n+ *\/\n+\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for pseudo-random number generator\n+\/\/ If a failure occurs, hardcode the seed to make the test case deterministic\n+public class ECOperationsFuzzTest {\n+        public static void main(String[] args) throws Exception {\n+                \/\/Note: it might be useful to increase this number during development\n+                final int repeat = 10000;\n+                test(repeat);\n+                System.out.println(\"Fuzz Success\");\n+        }\n+\n+        private static void check(MutablePoint reference, MutablePoint testValue, long seed, int iter) {\n+                AffinePoint affineRef = reference.asAffine();\n+                AffinePoint affine = testValue.asAffine();\n+                if (!affineRef.getX().asBigInteger().equals(affine.getX().asBigInteger()) ||\n+                    !affineRef.getY().asBigInteger().equals(affine.getY().asBigInteger())) {\n+                        throw new RuntimeException(\"Found error with seed \"+seed +\"at iteration \"+ iter);\n+                }\n+        }\n+\n+        public static void test(int repeat) throws Exception {\n+                Random rnd = new Random();\n+                long seed = rnd.nextLong();\n+                rnd.setSeed(seed);\n+\n+                int keySize = 256;\n+                ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n+                NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n+                ECPoint generator = curve.getGenerator();\n+                if (params == null || generator == null) {\n+                        throw new RuntimeException(\"No EC parameters available for key size \" + keySize + \" bits\");\n+                }\n+\n+                ECOperations ops = ECOperations.forParameters(params).get();\n+                ECOperations opsReference = ECOperations.forParameters(params).get();\n+\n+                try {\n+                        Field montgomeryOps = ECOperations.class.getDeclaredField(\"montgomeryOps\");\n+                        montgomeryOps.setAccessible(true);\n+                        if (montgomeryOps.get(ops) == null) {\n+                                throw new RuntimeException(\"Expected to find montgomery field for P256\");\n+                        }\n+                        montgomeryOps.set(opsReference, null); \/\/ Disable Montgomery field operations\n+                } catch (NoSuchFieldException | IllegalAccessException ex) {\n+                        throw new RuntimeException(ex);\n+                }\n+\n+                byte[] multiple = new byte[keySize\/8];\n+                rnd.nextBytes(multiple);\n+                multiple[keySize\/8-1] &= 0x7f; \/\/copied from opsReference.seedToScalar(multiple);\n+\n+                MutablePoint referencePoint = opsReference.multiply(generator, multiple);\n+                MutablePoint point = ops.multiply(generator, multiple);\n+                check(referencePoint, point, seed, -1);\n+\n+                AffinePoint refAffineGenerator = AffinePoint.fromECPoint(generator, referencePoint.getField());\n+                AffinePoint montAffineGenerator = AffinePoint.fromECPoint(generator, point.getField());\n+\n+                MutablePoint refProjGenerator = new ProjectivePoint.Mutable(\n+                        refAffineGenerator.getX().mutable(),\n+                        refAffineGenerator.getY().mutable(),\n+                        referencePoint.getField().get1().mutable());\n+\n+                MutablePoint projGenerator = new ProjectivePoint.Mutable(\n+                        montAffineGenerator.getX().mutable(),\n+                        montAffineGenerator.getY().mutable(),\n+                        point.getField().get1().mutable());\n+\n+                for (int i = 0; i < repeat; i++) {\n+                        rnd.nextBytes(multiple);\n+                        multiple[keySize\/8-1] &= 0x7f; \/\/copied from opsReference.seedToScalar(multiple);\n+\n+                        MutablePoint nextReferencePoint = opsReference.multiply(referencePoint.asAffine(), multiple);\n+                        MutablePoint nextPoint = ops.multiply(point.asAffine().toECPoint(), multiple);\n+                        check(nextReferencePoint, nextPoint, seed, i);\n+\n+                        if (rnd.nextBoolean()) {\n+                                opsReference.setSum(nextReferencePoint, referencePoint);\n+                                ops.setSum(nextPoint, point);\n+                                check(nextReferencePoint, nextPoint, seed, i);\n+                        }\n+\n+                        if (rnd.nextBoolean()) {\n+                                opsReference.setSum(nextReferencePoint, refProjGenerator);\n+                                ops.setSum(nextPoint, projGenerator);\n+                                check(nextReferencePoint, nextPoint, seed, i);\n+                        }\n+\n+                        if (rnd.nextInt(100)<10) { \/\/ 10% Reset point to generator, test generator multiplier\n+                                referencePoint = opsReference.multiply(generator, multiple);\n+                                point = ops.multiply(generator, multiple);\n+                                check(referencePoint, point, seed, i);\n+                        } else {\n+                                referencePoint = nextReferencePoint;\n+                                point = nextPoint;\n+                        }\n+                }\n+        }\n+\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2023, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import java.util.List;\n+import java.util.LinkedList;\n+import java.math.BigInteger;\n+import java.lang.reflect.Field;\n+import java.security.spec.ECParameterSpec;\n+import sun.security.ec.ECOperations;\n+import sun.security.util.ECUtil;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.CurveDB;\n+import sun.security.ec.point.*;\n+import java.security.spec.ECPoint;\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm --add-opens java.base\/sun.security.ec=ALL-UNNAMED ECOperationsKATTest\n+ * @summary Unit test ECOperationsKATTest.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:-TieredCompilation --add-opens java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions ECOperationsKATTest\n+ * @summary Unit test ECOperationsKATTest.\n+ *\/\n+\n+public class ECOperationsKATTest {\n+        final private static java.util.HexFormat hex = java.util.HexFormat.of();\n+\n+        public static void main(String args[]) throws Exception {\n+                int testsPassed = 0;\n+                int testNumber = 0;\n+\n+                for (TestData test : testList) {\n+                        System.out.println(\"*** Test \" + ++testNumber + \": \" + test.testName);\n+                        if (runSingleTest(test)) {\n+                                testsPassed++;\n+                        }\n+                }\n+                System.out.println();\n+\n+                System.out.println(\"*** Test Infinity point operations\");\n+                if (neutralTest()) {\n+                        System.out.println(\"*** Test \" + ++testNumber + \": neutralTest\");\n+                        testsPassed++;\n+                }\n+\n+                if (testsPassed != testNumber) {\n+                        throw new RuntimeException(\"One or more tests failed. Check output for details\");\n+                }\n+        }\n+\n+        private static boolean check(MutablePoint testValue, ECPoint reference) {\n+                AffinePoint affine = testValue.asAffine();\n+                BigInteger x = affine.getX().asBigInteger();\n+                BigInteger y = affine.getY().asBigInteger();\n+                BigInteger refX = reference.getAffineX();\n+                BigInteger refY = reference.getAffineY();\n+\n+                if (!refX.equals(x) || !refY.equals(y)) {\n+                        System.out.println(\"ERROR - Output Mismatch!\");\n+                        System.out.println(\"Expected: X: \" + refX.toString(16) + \" Y: \" + refY.toString(16));\n+                        System.out.println(\"Result:   X: \" + x.toString(16)    + \" Y: \" + y.toString(16));\n+                        return false;\n+                }\n+                return true;\n+        }\n+\n+        private static class TestData {\n+                public TestData(String name, String keyStr, String xStr1, String yStr1, String xStr2, String yStr2) {\n+                        testName = name;\n+                        \/\/multiplier = (new BigInteger(keyStr, 16)).toByteArray();\n+                        multiplier = hex.parseHex(keyStr);\n+                        sun.security.util.ArrayUtil.reverse(multiplier);\n+                        reference1 = new ECPoint(new BigInteger(xStr1, 16), new BigInteger(yStr1, 16));\n+                        reference2 = new ECPoint(new BigInteger(xStr2, 16), new BigInteger(yStr2, 16));\n+                }\n+\n+                String testName;\n+                byte[] multiplier;\n+                ECPoint reference1; \/\/For generator multiplier test\n+                ECPoint reference2; \/\/For non-generator multiplier test\n+        }\n+\n+        public static final List<TestData> testList = new LinkedList<TestData>() {{\n+                \/\/ (x1,y1) = mult*generator\n+                \/\/ (x2,y2) = mult*mult*generator\n+                add(new TestData(\"Test Vector #1\",\n+                \"0000000000000000000000000000000000000000000000000000000000000012\", \/\/ mult\n+                \"1057E0AB5780F470DEFC9378D1C7C87437BB4C6F9EA55C63D936266DBD781FDA\", \/\/ x1\n+                \"F6F1645A15CBE5DC9FA9B7DFD96EE5A7DCC11B5C5EF4F1F78D83B3393C6A45A2\", \/\/ y1\n+                \"4954047A366A91E3FD94E574DB6F2B04F3A8465883DBC55A816EA563BF54A324\", \/\/ x2\n+                \"B5A54786FD9EA48C9FC38A0557B0C4D54F285908A7291B630D06BEE970F530D3\") \/\/ y2\n+                );\n+                add(new TestData(\"Test Vector #2\",\n+                \"1200000000000000000000000000000000000000000000000000000000000000\", \/\/ mult\n+                \"DF684E6D0D57AF8B89DA11E8F7436C3D360F531D62BDCE42C5A8B72D73D5C717\", \/\/ x\n+                \"9D3576BD03C09B8F416EE9C27D70AD4A425119271ACF549312CA48758F4E1FEC\", \/\/ y\n+                \"57C8257EEAABF5446DCFACB99DEE104367B6C9950C76797C372EB177D5FA23B3\", \/\/ x\n+                \"1CD3E8A34521C1C8E574EB4B99343CAA57E00725D8618F0231C7C79AA6837725\") \/\/ y\n+                );\n+                add(new TestData(\"Test Vector #3\",\n+                \"0000000000000000000000000000000120000000000000000000000000000012\", \/\/ mult\n+                \"A69DFD47B24485E5F523BDA5FBACF03F5A7C3D22E0C2BC6705594B7B051A06D0\", \/\/ x\n+                \"ECF19629416BE5C9AF1E30988F3AA8B803809CF4D12944EB49C5E9892723798A\", \/\/ y\n+                \"1E28559F5B681C308632EE11A007B9891B3FD592C982C4926153795794295E58\", \/\/ x\n+                \"3C373046C27BB34609A43C91DF6D4B9AB9EB08F3B69A8F8FAE944211D8297F30\") \/\/ y\n+                );\n+                add(new TestData(\"Test Vector #4\",\n+                \"0000000000000000000000000000000000000000000000000000000000000001\", \/\/ mult\n+                \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n+                \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", \/\/ y\n+                \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n+                \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\") \/\/ y\n+                );\n+                add(new TestData(\"Test Vector #5\",\n+                \"EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \/\/ mult\n+                \"66B71D0BD47344197CCFB0C9578EAF0ADB609E05BB4E8F87D56BD34F24EE7C47\", \/\/ x\n+                \"14A0ECB7F708C02B2BAE238D2C4607BB9D04FCE64E10A428C911D6FA25B2F0FD\", \/\/ y\n+                \"D25AAFD0FCC5B5E95C84C0702C138BC4D7FEB4E5F9C2DFB4301E313507EFDF44\", \/\/ x\n+                \"F3F04EBC7D308511B0392BB7171CF92688D6484A95A8100EDFC933613A359133\") \/\/ y\n+                );\n+                add(new TestData(\"Test Vector #6\",\n+                \"1111111111111111111111111111111111111111111111111111111111111111\", \/\/ mult\n+                \"0217E617F0B6443928278F96999E69A23A4F2C152BDF6D6CDF66E5B80282D4ED\", \/\/ x\n+                \"194A7DEBCB97712D2DDA3CA85AA8765A56F45FC758599652F2897C65306E5794\", \/\/ y\n+                \"A83A07D6AE918359DEBCC385DA1E416EB83417435079CA8DB06005E107C309A0\", \/\/ x\n+                \"5AACDF816850C33EB3E54F3D0DD759B97B5E7065B2060016F73735E4A6AADE23\") \/\/ y\n+                );\n+        }};\n+\n+        private static boolean runSingleTest(TestData testData) {\n+                int keySize = 256;\n+                ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n+                NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n+                ECPoint generator = curve.getGenerator();\n+                if (params == null || generator == null) {\n+                        throw new RuntimeException(\"No EC parameters available for key size \" + keySize + \" bits\");\n+                }\n+\n+                ECOperations ops = ECOperations.forParameters(params).get();\n+                ECOperations opsReference = ECOperations.forParameters(params).get();\n+\n+                try {\n+                        Field montgomeryOps = ECOperations.class.getDeclaredField(\"montgomeryOps\");\n+                        montgomeryOps.setAccessible(true);\n+                        if (montgomeryOps.get(ops) == null) {\n+                                throw new RuntimeException(\"Expected to find montgomery field for P256\");\n+                        }\n+                        montgomeryOps.set(opsReference, null); \/\/ Disable Montgomery field operations\n+                } catch (NoSuchFieldException | IllegalAccessException ex) {\n+                        throw new RuntimeException(ex);\n+                }\n+\n+                MutablePoint nextPoint = ops.multiply(generator, testData.multiplier);\n+                MutablePoint nextReferencePoint = opsReference.multiply(generator, testData.multiplier);\n+                if (!check(nextReferencePoint, testData.reference1) || !check(nextPoint, testData.reference1)){\n+                        return false;\n+                }\n+\n+                nextPoint = ops.multiply(nextPoint.asAffine(), testData.multiplier);\n+                nextReferencePoint = opsReference.multiply(nextReferencePoint.asAffine(), testData.multiplier);\n+                if (!check(nextReferencePoint, testData.reference2) || !check(nextPoint, testData.reference2)){\n+                        return false;\n+                }\n+\n+                return true;\n+        }\n+\n+        private static boolean neutralTest() {\n+                return true;\n+        }\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/ec\/ECOperationsKATTest.java\"\n+\n+\/*\n+ * KAT generator using OpenSSL for reference vectors\n+ * g++ ecpoint.cpp -g -lcrypto -Wno-deprecated-declarations && .\/a.out\n+ * (Some OpenSSL EC operations are marked internal i.e. deprecated)\n+ *\n+\n+#include <openssl\/obj_mac.h>\n+#include <openssl\/ec.h>\n+\n+void check(int rc, const char* locator) {\n+  if (rc != 1) {\n+    printf(\"Failed at %s\\n\", locator);\n+    exit(55);\n+  }\n+}\n+\n+int main(){\n+  BN_CTX* ctx = BN_CTX_new();\n+  BIGNUM* k = BN_CTX_get(ctx);\n+  BIGNUM* x1 = BN_CTX_get(ctx);\n+  BIGNUM* y1 = BN_CTX_get(ctx);\n+  BIGNUM* x2 = BN_CTX_get(ctx);\n+  BIGNUM* y2 = BN_CTX_get(ctx);\n+  EC_GROUP *ec_group = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);\n+  EC_POINT* pubkey = EC_POINT_new(ec_group);\n+  EC_POINT* pubkey2 = EC_POINT_new(ec_group);\n+  int rc;\n+\n+  rc = BN_hex2bn(&k, \"1111111111111111111111111111111111111111111111111111111111111111\"); \/\/check(rc, \"set raw key\");\n+  rc = EC_POINT_mul(ec_group, pubkey, k, NULL, NULL, ctx);  check(rc, \"mult public key\");\n+  rc = EC_POINT_get_affine_coordinates(ec_group, pubkey, x1, y1, ctx);   check(rc, \"get affine coordinates\");\n+  rc = EC_POINT_mul(ec_group, pubkey2, NULL, pubkey, k, ctx);  check(rc, \"mult public key\");\n+  rc = EC_POINT_get_affine_coordinates(ec_group, pubkey2, x2, y2, ctx);   check(rc, \"get affine coordinates\");\n+  printf(\"k: %s\\n\", BN_bn2hex(k));\n+  printf(\"x: %s\\ny: %s\\n\", BN_bn2hex(x1), BN_bn2hex(y1));\n+  printf(\"x: %s\\ny: %s\\n\", BN_bn2hex(x2), BN_bn2hex(y2));\n+\n+  BN_CTX_free(ctx);\n+  return 0;\n+}\n+\n+ *\/\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/ec\/ECOperationsKATTest.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import sun.security.util.math.*;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics IntegerPolynomialTest\n+ * @summary Unit test IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:-TieredCompilation -XX:+UseIntPolyIntrinsics IntegerPolynomialTest\n+ * @summary Unit test IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n+ *\/\n+\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for pseudo-random number generator\n+\/\/ If a failure occurs, hardcode the seed to make the test case deterministic\n+public class IntegerPolynomialTest {\n+        public static void main(String[] args) throws Exception {\n+                Random rnd = new Random();\n+                long seed = rnd.nextLong();\n+                rnd.setSeed(seed);\n+\n+                IntegerPolynomial testFields[] = new IntegerPolynomial[]{\n+                        IntegerPolynomial1305.ONE, IntegerPolynomial25519.ONE,\n+                        IntegerPolynomial448.ONE, IntegerPolynomialP256.ONE, MontgomeryIntegerPolynomialP256.ONE,\n+                        IntegerPolynomialP384.ONE, IntegerPolynomialP521.ONE,\n+                        new IntegerPolynomialModBinP.Curve25519OrderField(), new IntegerPolynomialModBinP.Curve448OrderField(),\n+                        P256OrderField.ONE, P384OrderField.ONE, P521OrderField.ONE,\n+                        Curve25519OrderField.ONE, Curve448OrderField.ONE\n+                };\n+\n+                for (IntegerPolynomial field:testFields) {\n+                        ImmutableIntegerModuloP aRef = field.getElement(new BigInteger(32*64, rnd));\n+                        MutableIntegerModuloP a = aRef.mutable();\n+                        ImmutableIntegerModuloP bRef = field.getElement(new BigInteger(32*64, rnd));\n+                        MutableIntegerModuloP b = bRef.mutable();\n+\n+                        a.conditionalSet(b, 0); \/\/ Don't assign\n+                        if (Arrays.equals(a.getLimbs(), b.getLimbs())) {\n+                                throw new RuntimeException(\"[SEED \"+seed + \"]: Incorrect assign for \" + field);\n+                        }\n+                        a.conditionalSet(b, 1); \/\/ Assign\n+                        if (!Arrays.equals(a.getLimbs(), b.getLimbs())) {\n+                                throw new RuntimeException(\"[SEED \"+seed + \"]: Incorrect assign for \" + field);\n+                        }\n+                }\n+                System.out.println(\"Test Success\");\n+        }\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+import java.math.BigInteger;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions  -XX:-UseIntPolyIntrinsics MontgomeryPolynomialFuzzTest\n+ * @summary Unit test MontgomeryPolynomialFuzzTest.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions  -XX:+UseIntPolyIntrinsics MontgomeryPolynomialFuzzTest\n+ * @summary Unit test MontgomeryPolynomialFuzzTest.\n+ *\/\n+\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for pseudo-random number generator\n+\/\/ If a failure occurs, hardcode the seed to make the test case deterministic\n+public class MontgomeryPolynomialFuzzTest {\n+        public static void main(String[] args) throws Exception {\n+                \/\/Note: it might be useful to increase this number during development of new Poly1305 intrinsics\n+                final int repeat = 1000000;\n+                for (int i = 0; i < repeat; i++) {\n+                        run();\n+                }\n+                System.out.println(\"Fuzz Success\");\n+        }\n+\n+        private static void check(BigInteger reference, ImmutableIntegerModuloP testValue, long seed) {\n+                if (!reference.equals(testValue.asBigInteger())) {\n+                        throw new RuntimeException(\"SEED: \"+seed);\n+                }\n+        }\n+\n+        public static void run() throws Exception {\n+                Random rnd = new Random();\n+                long seed = rnd.nextLong();\n+                rnd.setSeed(seed);\n+\n+                IntegerMontgomeryFieldModuloP montField = MontgomeryIntegerPolynomialP256.ONE;\n+                BigInteger P = MontgomeryIntegerPolynomialP256.ONE.MODULUS;\n+                BigInteger r = BigInteger.ONE.shiftLeft(260).mod(P);\n+                BigInteger rInv = r.modInverse(P);\n+                BigInteger aRef = (new BigInteger(P.bitLength(), rnd)).mod(P);\n+\n+                \/\/ Test conversion to montgomery domain\n+                ImmutableIntegerModuloP a = montField.getElement(aRef);\n+                aRef = aRef.multiply(r).mod(P);\n+                check(aRef, a, seed);\n+\n+                if (rnd.nextBoolean()) {\n+                        aRef = aRef.multiply(aRef).multiply(rInv).mod(P);\n+                        a = a.multiply(a);\n+                        check(aRef, a, seed);\n+                }\n+\n+                if (rnd.nextBoolean()) {\n+                        aRef = aRef.add(aRef).mod(P);\n+                        a = a.add(a);\n+                        check(aRef, a, seed);\n+                }\n+        }\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/MontgomeryPolynomialFuzzTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/MontgomeryPolynomialFuzzTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import sun.security.util.math.intpoly.MontgomeryIntegerPolynomialP256;\n+import sun.security.util.math.intpoly.IntegerPolynomialP256;\n+import sun.security.util.math.MutableIntegerModuloP;\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+\n+@Fork(jvmArgsAppend = {\"-XX:+AlwaysPreTouch\",\n+    \"--add-exports\", \"java.base\/sun.security.util.math.intpoly=ALL-UNNAMED\",\n+    \"--add-exports\", \"java.base\/sun.security.util.math=ALL-UNNAMED\"}, value = 1)\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.Throughput)\n+public class PolynomialP256Bench {\n+    final MontgomeryIntegerPolynomialP256 montField = MontgomeryIntegerPolynomialP256.ONE;\n+    final IntegerPolynomialP256 residueField = IntegerPolynomialP256.ONE;\n+    final BigInteger refx = new BigInteger(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16);\n+    final ImmutableIntegerModuloP x = residueField.getElement(refx);\n+    final ImmutableIntegerModuloP X = montField.getElement(refx);\n+    final ImmutableIntegerModuloP one = montField.get1();\n+\n+    @Param({\"true\", \"false\"})\n+    private boolean isMontBench;\n+\n+    @Benchmark\n+    public MutableIntegerModuloP benchMultiply() {\n+        MutableIntegerModuloP test;\n+        if (isMontBench) {\n+            test = X.mutable();\n+        } else {\n+            test = x.mutable();\n+        }\n+\n+        for (int i = 0; i< 10000; i++) {\n+            test = test.setProduct(test);\n+        }\n+        return test;\n+    }\n+\n+    @Benchmark\n+    public MutableIntegerModuloP benchSquare() {\n+        MutableIntegerModuloP test;\n+        if (isMontBench) {\n+            test = X.mutable();\n+        } else {\n+            test = x.mutable();\n+        }\n+\n+        for (int i = 0; i< 10000; i++) {\n+            test = test.setSquare();\n+        }\n+        return test;\n+    }\n+\n+    @Benchmark\n+    public MutableIntegerModuloP benchAssign() {\n+        MutableIntegerModuloP test1 = X.mutable();\n+        MutableIntegerModuloP test2 = one.mutable();\n+        for (int i = 0; i< 10000; i++) {\n+            test1.conditionalSet(test2, 0);\n+            test1.conditionalSet(test2, 1);\n+            test2.conditionalSet(test1, 0);\n+            test2.conditionalSet(test1, 1);\n+        }\n+        return test2;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/PolynomialP256Bench.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}