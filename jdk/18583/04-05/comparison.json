{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n@@ -268,0 +269,5 @@\n+        if (field instanceof IntegerMontgomeryFieldModuloP) {\n+            \/\/ No point of doing a single SmallValue operation in Montgomery domain\n+            field = ((IntegerMontgomeryFieldModuloP)field).residueField();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -205,1 +205,10 @@\n-        return multiply(affineP.toECPoint(), s);\n+        PointMultiplier multiplier = null;\n+        if (getField() instanceof IntegerMontgomeryFieldModuloP\n+                && affineP.equals(Secp256R1GeneratorMontgomeryMultiplier.generator)) {\n+            \/\/ Lazy class loading when this function is called (large static constant table)\n+            multiplier = Secp256R1GeneratorMontgomeryMultiplier.multiplier;\n+        } else {\n+            multiplier = new DefaultMultiplier(this, affineP);\n+        }\n+\n+        return multiplier.pointMultiply(s);\n@@ -212,1 +221,1 @@\n-     * @param affineP the point\n+     * @param ecPoint the point\n@@ -217,13 +226,1 @@\n-        \/\/ Route to Basepoint and\/or Montgomery pointMultiply as appropriate\n-\n-        PointMultiplier multiplier = null;\n-        if (!(b.getField() instanceof IntegerMontgomeryFieldModuloP)) {\n-            multiplier = new DefaultMultiplier(this, ecPoint);\n-        } else if (ecPoint.equals(Secp256R1GeneratorMontgomeryMultiplier.generator)) {\n-            \/\/ Lazy class loading upon function call (large static constant table)\n-            multiplier = Secp256R1GeneratorMontgomeryMultiplier.multiplier;\n-        } else {\n-            multiplier = new DefaultMontgomeryMultiplier(this, ecPoint);\n-        }\n-\n-        return multiplier.pointMultiply(s);\n+        return multiply(AffinePoint.fromECPoint(ecPoint, getField()), s);\n@@ -311,3 +308,3 @@\n-        t0.setValue(p.getX()).setProduct(p2.getX());\n-        t1.setValue(p.getY()).setProduct(p2.getY());\n-        t3.setValue(p2.getX()).setSum(p2.getY());\n+        t0.setValue(p.getX()).setProduct(p2.getX(false));\n+        t1.setValue(p.getY()).setProduct(p2.getY(false));\n+        t3.setValue(p2.getX(false)).setSum(p2.getY(false));\n@@ -319,1 +316,1 @@\n-        t4.setValue(p2.getY()).setProduct(p.getZ());\n+        t4.setValue(p2.getY(false)).setProduct(p.getZ());\n@@ -322,1 +319,1 @@\n-        p.getY().setValue(p2.getX()).setProduct(p.getZ());\n+        p.getY().setValue(p2.getX(false)).setProduct(p.getZ());\n@@ -435,1 +432,1 @@\n-        permits SmallWindowMultiplier, P256LargeTableMultiplier {\n+        permits DefaultMultiplier, Secp256R1GeneratorMontgomeryMultiplier {\n@@ -466,2 +463,1 @@\n-    sealed static abstract class SmallWindowMultiplier implements PointMultiplier\n-        permits DefaultMultiplier, DefaultMontgomeryMultiplier {\n+    final static class DefaultMultiplier implements PointMultiplier {\n@@ -471,1 +467,1 @@\n-        protected SmallWindowMultiplier(ECOperations ecOps, AffinePoint affineP) {\n+        DefaultMultiplier(ECOperations ecOps, AffinePoint affineP) {\n@@ -551,2 +547,6 @@\n-    sealed static abstract class P256LargeTableMultiplier implements PointMultiplier\n-        permits Secp256R1GeneratorMontgomeryMultiplier {\n+    final static class Secp256R1GeneratorMontgomeryMultiplier implements PointMultiplier {\n+        private static final ECOperations secp256r1Ops = new ECOperations(\n+                MontgomeryIntegerPolynomialP256.ONE.getElement(CurveDB.P_256.getCurve().getB()),\n+                P256OrderField.ONE);\n+        public static final AffinePoint generator = AffinePoint.fromECPoint(CurveDB.P_256.getGenerator(), secp256r1Ops.getField());\n+        public static final PointMultiplier multiplier = new Secp256R1GeneratorMontgomeryMultiplier();\n@@ -556,1 +556,0 @@\n-        private final ECOperations secp256r1Ops;\n@@ -560,20 +559,3 @@\n-        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n-            MutableIntegerModuloP t0 = zero.mutable();\n-            MutableIntegerModuloP t1 = zero.mutable();\n-            MutableIntegerModuloP t2 = zero.mutable();\n-            MutableIntegerModuloP t3 = zero.mutable();\n-            MutableIntegerModuloP t4 = zero.mutable();\n-\n-            ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n-                    zero.mutable(),\n-                    one.mutable(),\n-                    zero.mutable());\n-            ProjectivePoint.Mutable r = d.mutable();\n-            for (int i = 15; i >= 0; i--) {\n-                secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n-                for (int j = 3; j >= 0; j--) {\n-                    int pos = i + j * 16;\n-                    int index = (bit(s, pos + 192) << 3) |\n-                                (bit(s, pos + 128) << 2) |\n-                                (bit(s, pos +  64) << 1) |\n-                                    bit(s, pos);\n+        private Secp256R1GeneratorMontgomeryMultiplier() {\n+            this(MontgomeryIntegerPolynomialP256.ONE,\n+                new DefaultMultiplier(secp256r1Ops, generator));\n@@ -581,3 +563,3 @@\n-                    PointMultiplier.lookup(points[j], index, r);\n-                    secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n-                }\n+            \/\/ Check that the tables are correctly generated.\n+            if (ECOperations.class.desiredAssertionStatus()) {\n+                verifyTables(this);\n@@ -585,6 +567,0 @@\n-\n-            return d;\n-        }\n-\n-        private static int bit(byte[] k, int i) {\n-            return (k[i >> 3] >> (i & 0x07)) & 0x01;\n@@ -593,1 +569,1 @@\n-        protected P256LargeTableMultiplier(ECOperations secp256r1Ops, IntegerFieldModuloP field, PointMultiplier smallTableMultiplier) {\n+        private Secp256R1GeneratorMontgomeryMultiplier(IntegerFieldModuloP field, PointMultiplier smallTableMultiplier) {\n@@ -596,1 +572,0 @@\n-            this.secp256r1Ops = secp256r1Ops;\n@@ -667,0 +642,33 @@\n+        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n+\n+            ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n+                    zero.mutable(),\n+                    one.mutable(),\n+                    zero.mutable());\n+            ProjectivePoint.Mutable r = d.mutable();\n+            for (int i = 15; i >= 0; i--) {\n+                secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n+                for (int j = 3; j >= 0; j--) {\n+                    int pos = i + j * 16;\n+                    int index = (bit(s, pos + 192) << 3) |\n+                                (bit(s, pos + 128) << 2) |\n+                                (bit(s, pos +  64) << 1) |\n+                                    bit(s, pos);\n+\n+                    PointMultiplier.lookup(points[j], index, r);\n+                    secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n+                }\n+            }\n+\n+            return d;\n+        }\n+\n+        private static int bit(byte[] k, int i) {\n+            return (k[i >> 3] >> (i & 0x07)) & 0x01;\n+        }\n+\n@@ -683,2 +691,1 @@\n-                        if (!v.getX().asBigInteger().equals(m.getX().asBigInteger()) ||\n-                            !v.getY().asBigInteger().equals(m.getY().asBigInteger())) {\n+                        if (!m.equals(v)) {\n@@ -693,65 +700,0 @@\n-\n-    final static class DefaultMultiplier extends SmallWindowMultiplier {\n-        public DefaultMultiplier(ECOperations ecOps, AffinePoint affineP) {\n-            super(ecOps, affineP);\n-        }\n-\n-        public DefaultMultiplier(ECOperations ecOps, ECPoint ecPoint) {\n-            super(ecOps, AffinePoint.fromECPoint(ecPoint, ecOps.getField()));\n-        }\n-    }\n-\n-    final static class DefaultMontgomeryMultiplier extends SmallWindowMultiplier {\n-        private final IntegerMontgomeryFieldModuloP montField;\n-\n-        public DefaultMontgomeryMultiplier(ECOperations ecOps, ECPoint ecPoint) {\n-            super(ecOps, AffinePoint.fromECPoint(ecPoint, ecOps.getField()));\n-            this.montField = (IntegerMontgomeryFieldModuloP)ecOps.getField();\n-        }\n-\n-        \/**\n-         * Returns result ProjectivePoint in Montgomery domain, so that subsequent operations can also be done in Montgomery domain\n-         * Conversion to residue domain is implicit when this ProjectivePoint is converted to asAffine().\n-         *\/\n-        @Override\n-        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n-            ProjectivePoint.Mutable result = super.pointMultiply(s);\n-            return new ProjectivePoint.MontgomeryMutable(montField,\n-                result.getX(),\n-                result.getY(),\n-                result.getZ());\n-        }\n-    }\n-\n-    final static class Secp256R1GeneratorMontgomeryMultiplier extends P256LargeTableMultiplier {\n-        private static final ECOperations secp256r1Ops = new ECOperations(\n-                MontgomeryIntegerPolynomialP256.ONE.getElement(CurveDB.P_256.getCurve().getB()),\n-                P256OrderField.ONE);\n-        public static final ECPoint generator = CurveDB.P_256.getGenerator();\n-        public static final PointMultiplier multiplier = new Secp256R1GeneratorMontgomeryMultiplier();\n-\n-        private Secp256R1GeneratorMontgomeryMultiplier() {\n-            super(\n-                secp256r1Ops,\n-                MontgomeryIntegerPolynomialP256.ONE,\n-                new DefaultMontgomeryMultiplier(secp256r1Ops, generator));\n-\n-            \/\/ Check that the tables are correctly generated.\n-            if (ECOperations.class.desiredAssertionStatus()) {\n-                verifyTables(this);\n-            }\n-        }\n-\n-        \/**\n-         * Returns result ProjectivePoint in Montgomery domain, so that subsequent operations can also be done in Montgomery domain\n-         * Conversion to residue domain is implicit when this ProjectivePoint is converted to asAffine().\n-         *\/\n-        @Override\n-        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n-            ProjectivePoint.Mutable result = super.pointMultiply\/*Base*\/(s);\n-            return new ProjectivePoint.MontgomeryMutable(MontgomeryIntegerPolynomialP256.ONE,\n-                result.getX(),\n-                result.getY(),\n-                result.getZ());\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":67,"deletions":125,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n@@ -57,1 +58,1 @@\n-        return new ECPoint(x.asBigInteger(), y.asBigInteger());\n+        return new ECPoint(getX().asBigInteger(), getY().asBigInteger());\n@@ -61,0 +62,8 @@\n+        return getX(true);\n+    }\n+\n+    public ImmutableIntegerModuloP getX(boolean fieldCheck) {\n+        IntegerFieldModuloP field = x.getField();\n+        if (fieldCheck && field instanceof IntegerMontgomeryFieldModuloP) {\n+            return ((IntegerMontgomeryFieldModuloP)field).fromMontgomery(x);\n+        }\n@@ -65,0 +74,8 @@\n+        return getY(true);\n+    }\n+\n+    public ImmutableIntegerModuloP getY(boolean fieldCheck) {\n+        IntegerFieldModuloP field = y.getField();\n+        if (fieldCheck && field instanceof IntegerMontgomeryFieldModuloP) {\n+            return ((IntegerMontgomeryFieldModuloP)field).fromMontgomery(y);\n+        }\n@@ -74,2 +91,16 @@\n-        boolean xEquals = x.asBigInteger().equals(p.x.asBigInteger());\n-        boolean yEquals = y.asBigInteger().equals(p.y.asBigInteger());\n+        boolean xEquals, yEquals;\n+        boolean thisMont = x.getField() instanceof IntegerMontgomeryFieldModuloP;\n+        boolean objMont = p.x.getField() instanceof IntegerMontgomeryFieldModuloP;\n+        if (thisMont ^ objMont == false) {\n+            \/\/ both fields same\n+            xEquals = x.asBigInteger().equals(p.x.asBigInteger());\n+            yEquals = y.asBigInteger().equals(p.y.asBigInteger());\n+        } else if (thisMont) { \/\/ mismatched fields should not happen in production, but useful in testing\n+            IntegerMontgomeryFieldModuloP field = (IntegerMontgomeryFieldModuloP)x.getField();\n+            xEquals = x.asBigInteger().equals(field.getElement(p.x.asBigInteger()).asBigInteger());\n+            yEquals = y.asBigInteger().equals(field.getElement(p.y.asBigInteger()).asBigInteger());\n+        } else {\n+            IntegerMontgomeryFieldModuloP field = (IntegerMontgomeryFieldModuloP)p.x.getField();\n+            xEquals = field.getElement(x.asBigInteger()).asBigInteger().equals(p.x.asBigInteger());\n+            yEquals = field.getElement(y.asBigInteger()).asBigInteger().equals(p.y.asBigInteger());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/AffinePoint.java","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -162,3 +162,3 @@\n-            x.setValue(p.getX());\n-            y.setValue(p.getY());\n-            z.setValue(p.getX().getField().get1());\n+            x.setValue(p.getX(false));\n+            y.setValue(p.getY(false));\n+            z.setValue(p.getX(false).getField().get1());\n@@ -192,42 +192,0 @@\n-    public static class MontgomeryImmutable extends Immutable {\n-        private final IntegerMontgomeryFieldModuloP montField;\n-\n-        public MontgomeryImmutable(IntegerMontgomeryFieldModuloP montField,\n-                ImmutableIntegerModuloP x,\n-                ImmutableIntegerModuloP y,\n-                ImmutableIntegerModuloP z) {\n-            super(x, y, z);\n-            this.montField = montField;\n-        }\n-\n-        public AffinePoint asAffine() {\n-            IntegerModuloP zInv = z.multiplicativeInverse();\n-            ImmutableIntegerModuloP xResidue = montField.fromMontgomery(x.multiply(zInv));\n-            ImmutableIntegerModuloP yResidue = montField.fromMontgomery(y.multiply(zInv));\n-            return new AffinePoint(xResidue, yResidue);\n-        }\n-    }\n-\n-    public static class MontgomeryMutable extends Mutable {\n-        private final IntegerMontgomeryFieldModuloP montField;\n-\n-        public MontgomeryMutable(IntegerMontgomeryFieldModuloP montField,\n-                MutableIntegerModuloP x,\n-                MutableIntegerModuloP y,\n-                MutableIntegerModuloP z) {\n-            super(x, y, z);\n-            this.montField = montField;\n-        }\n-\n-        public AffinePoint asAffine() {\n-            IntegerModuloP zInv = z.multiplicativeInverse();\n-            ImmutableIntegerModuloP xResidue = montField.fromMontgomery(x.multiply(zInv));\n-            ImmutableIntegerModuloP yResidue = montField.fromMontgomery(y.multiply(zInv));\n-            return new AffinePoint(xResidue, yResidue);\n-        }\n-\n-        @Override\n-        public Immutable fixed() {\n-            return new MontgomeryImmutable(montField, x.fixed(), y.fixed(), z.fixed());\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/ProjectivePoint.java","additions":3,"deletions":45,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    IntegerFieldModuloP residueField();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/IntegerMontgomeryFieldModuloP.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import sun.security.util.math.IntegerFieldModuloP;\n@@ -61,0 +62,4 @@\n+    public IntegerFieldModuloP residueField() {\n+        return IntegerPolynomialP256.ONE;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,2 +68,1 @@\n-                if (!affineRef.getX().asBigInteger().equals(affine.getX().asBigInteger()) ||\n-                    !affineRef.getY().asBigInteger().equals(affine.getY().asBigInteger())) {\n+                if (!affineRef.equals(affine)) {\n@@ -109,2 +108,2 @@\n-                        refAffineGenerator.getX().mutable(),\n-                        refAffineGenerator.getY().mutable(),\n+                        refAffineGenerator.getX(false).mutable(),\n+                        refAffineGenerator.getY(false).mutable(),\n@@ -114,2 +113,2 @@\n-                        montAffineGenerator.getX().mutable(),\n-                        montAffineGenerator.getY().mutable(),\n+                        montAffineGenerator.getX(false).mutable(),\n+                        montAffineGenerator.getY(false).mutable(),\n","filename":"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"}]}