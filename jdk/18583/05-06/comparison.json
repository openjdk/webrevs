{"files":[{"patch":"@@ -208,1 +208,1 @@\n-            \/\/ Lazy class loading when this function is called (large static constant table)\n+            \/\/ Lazy class loading here\n@@ -218,2 +218,2 @@\n-     * Multiply an affine ecpoint point by a scalar and return the result as a mutable\n-     * point.\n+     * Multiply an affine ecpoint point by a scalar and return the result as a\n+     * mutable point.\n@@ -283,2 +283,2 @@\n-     * it is called. For better efficiency, the (private) method that reuses temporaries\n-     * should be used if more than one sum will be computed.\n+     * it is called. For better efficiency, the (private) method that reuses\n+     * temporaries should be used if more than one sum will be computed.\n@@ -297,1 +297,2 @@\n-        setSum((ProjectivePoint.Mutable) p, (ProjectivePoint.Mutable) p2, t0, t1, t2, t3, t4);\n+        setSum((ProjectivePoint.Mutable) p, (ProjectivePoint.Mutable) p2,\n+            t0, t1, t2, t3, t4);\n@@ -546,2 +547,4 @@\n-    \/\/ Represents a multiplier with a larger precomputed table. Intended to be used for Basepoint multiplication\n-    final static class Secp256R1GeneratorMontgomeryMultiplier implements PointMultiplier {\n+    \/\/ Represents a multiplier with a larger precomputed table. Intended to be\n+    \/\/ used for Basepoint multiplication\n+    final static class Secp256R1GeneratorMontgomeryMultiplier\n+        implements PointMultiplier {\n@@ -549,4 +552,6 @@\n-                MontgomeryIntegerPolynomialP256.ONE.getElement(CurveDB.P_256.getCurve().getB()),\n-                P256OrderField.ONE);\n-        public static final AffinePoint generator = AffinePoint.fromECPoint(CurveDB.P_256.getGenerator(), secp256r1Ops.getField());\n-        public static final PointMultiplier multiplier = new Secp256R1GeneratorMontgomeryMultiplier();\n+            MontgomeryIntegerPolynomialP256.ONE.getElement(\n+                    CurveDB.P_256.getCurve().getB()), P256OrderField.ONE);\n+        public static final AffinePoint generator = AffinePoint.fromECPoint(\n+            CurveDB.P_256.getGenerator(), secp256r1Ops.getField());\n+        public static final PointMultiplier multiplier =\n+            new Secp256R1GeneratorMontgomeryMultiplier();\n@@ -569,1 +574,2 @@\n-        private Secp256R1GeneratorMontgomeryMultiplier(IntegerFieldModuloP field, PointMultiplier smallTableMultiplier) {\n+        private Secp256R1GeneratorMontgomeryMultiplier(\n+            IntegerFieldModuloP field, PointMultiplier smallTableMultiplier) {\n@@ -631,1 +637,2 @@\n-                        points[d][0] = new ProjectivePoint.Immutable(zero.fixed(), one.fixed(), zero.fixed());\n+                        points[d][0] = new ProjectivePoint.Immutable(\n+                            zero.fixed(), one.fixed(), zero.fixed());\n@@ -688,1 +695,2 @@\n-                        \/\/ Compare this multiplier to the table (generated by Default multiplier)\n+                        \/\/ Compare this multiplier to the table\n+                        \/\/ (generated by Default multiplier)\n@@ -693,1 +701,1 @@\n-                            throw new RuntimeException(\"Bad multiple found at [\"+d+\"][\"+w+\"]\" + hex.formatHex(s) + \" \" + m.getX().asBigInteger());\n+                            throw new RuntimeException();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":24,"deletions":16,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -98,4 +98,9 @@\n-        } else if (thisMont) { \/\/ mismatched fields should not happen in production, but useful in testing\n-            IntegerMontgomeryFieldModuloP field = (IntegerMontgomeryFieldModuloP)x.getField();\n-            xEquals = x.asBigInteger().equals(field.getElement(p.x.asBigInteger()).asBigInteger());\n-            yEquals = y.asBigInteger().equals(field.getElement(p.y.asBigInteger()).asBigInteger());\n+        } else if (thisMont) {\n+            \/\/ mismatched fields should not happen in production, but useful in\n+            \/\/ testing\n+            IntegerMontgomeryFieldModuloP field =\n+                (IntegerMontgomeryFieldModuloP)x.getField();\n+            xEquals = x.asBigInteger().equals(\n+                field.getElement(p.x.asBigInteger()).asBigInteger());\n+            yEquals = y.asBigInteger().equals(\n+                field.getElement(p.y.asBigInteger()).asBigInteger());\n@@ -103,3 +108,6 @@\n-            IntegerMontgomeryFieldModuloP field = (IntegerMontgomeryFieldModuloP)p.x.getField();\n-            xEquals = field.getElement(x.asBigInteger()).asBigInteger().equals(p.x.asBigInteger());\n-            yEquals = field.getElement(y.asBigInteger()).asBigInteger().equals(p.y.asBigInteger());\n+            IntegerMontgomeryFieldModuloP field =\n+                (IntegerMontgomeryFieldModuloP)p.x.getField();\n+            xEquals = field.getElement(\n+                x.asBigInteger()).asBigInteger().equals(p.x.asBigInteger());\n+            yEquals = field.getElement(\n+                y.asBigInteger()).asBigInteger().equals(p.y.asBigInteger());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/AffinePoint.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -67,5 +67,4 @@\n-            IntegerPolynomial448, IntegerPolynomialP256, MontgomeryIntegerPolynomialP256,\n-            IntegerPolynomialP384, IntegerPolynomialP521,\n-            IntegerPolynomialModBinP, P256OrderField,\n-            P384OrderField, P521OrderField,\n-            Curve25519OrderField,\n+            IntegerPolynomial448, IntegerPolynomialP256,\n+            MontgomeryIntegerPolynomialP256, IntegerPolynomialP384,\n+            IntegerPolynomialP521, IntegerPolynomialModBinP, P256OrderField,\n+            P384OrderField, P521OrderField, Curve25519OrderField,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-\/\/ - [1] Shay Gueron and Vlad Krasnov \"Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes\"\n+\/\/ - [1] Shay Gueron and Vlad Krasnov \"Fast Prime Field Elliptic Curve\n+\/\/       Cryptography with 256 Bit Primes\"\n@@ -39,1 +40,2 @@\n-public final class MontgomeryIntegerPolynomialP256 extends IntegerPolynomial implements IntegerMontgomeryFieldModuloP {\n+public final class MontgomeryIntegerPolynomialP256 extends IntegerPolynomial\n+        implements IntegerMontgomeryFieldModuloP {\n@@ -52,5 +54,15 @@\n-    private static final long[] h         = new long[]{ 0x0000000000000300L, 0x000ffffffff00000L, 0x000ffffefffffffbL, 0x000fdfffffffffffL, 0x0000000004ffffffL};\n-    private static final long[] oneActual = new long[]{ 0x0000000000000001L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L};\n-    private static final long[] oneMont   = new long[]{ 0x0000000000000010L, 0x000f000000000000L, 0x000fffffffffffffL, 0x000ffeffffffffffL, 0x00000000000fffffL};\n-    private static final long[] zero      = new long[]{ 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L};\n-    private static final long[] modulus   = new long[]{ 0x000fffffffffffffL, 0x00000fffffffffffL, 0x0000000000000000L, 0x0000001000000000L, 0x0000ffffffff0000L};\n+    private static final long[] h = new long[] {\n+        0x0000000000000300L, 0x000ffffffff00000L, 0x000ffffefffffffbL,\n+        0x000fdfffffffffffL, 0x0000000004ffffffL };\n+    private static final long[] oneActual = new long[] {\n+        0x0000000000000001L, 0x0000000000000000L, 0x0000000000000000L,\n+        0x0000000000000000L, 0x0000000000000000L };\n+    private static final long[] oneMont = new long[] {\n+        0x0000000000000010L, 0x000f000000000000L, 0x000fffffffffffffL,\n+        0x000ffeffffffffffL, 0x00000000000fffffL };\n+    private static final long[] zero = new long[] {\n+        0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,\n+        0x0000000000000000L, 0x0000000000000000L };\n+    private static final long[] modulus = new long[] {\n+        0x000fffffffffffffL, 0x00000fffffffffffL, 0x0000000000000000L,\n+        0x0000001000000000L, 0x0000ffffffff0000L };\n@@ -66,1 +78,1 @@\n-    \/\/(224%nat,-1)::(192%nat,1)::(96%nat,1)::(0%nat,-1)::nil.\n+    \/\/ (224%nat,-1)::(192%nat,1)::(96%nat,1)::(0%nat,-1)::nil.\n@@ -107,4 +119,5 @@\n-     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to multiply\n-     * by a small constant (i.e. (int) 1,2,3,4). Instead of doing a montgomery conversion\n-     * followed by a montgomery multiplication, just use the spare top (64-BITS_PER_LIMB) bits\n-     * to multiply by a constant. (See [1] Section 4 )\n+     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to\n+     * multiply by a small constant (i.e. (int) 1,2,3,4). Instead of doing a\n+     * montgomery conversion followed by a montgomery multiplication, just use\n+     * the spare top (64-BITS_PER_LIMB) bits to multiply by a constant. (See [1]\n+     * Section 4 )\n@@ -116,1 +129,1 @@\n-        assert(b< (1<<BITS_PER_LIMB));\n+        assert (b < (1 << BITS_PER_LIMB));\n@@ -120,1 +133,1 @@\n-        return (int)(b-1);\n+        return (int) (b - 1);\n@@ -127,1 +140,1 @@\n-        ImmutableElement nn = (ImmutableElement)n;\n+        ImmutableElement nn = (ImmutableElement) n;\n@@ -129,1 +142,1 @@\n-        long[] r2 = new long[2*NUM_LIMBS];\n+        long[] r2 = new long[2 * NUM_LIMBS];\n@@ -139,1 +152,1 @@\n-        final long HALF_BITS_LIMB = BITS_PER_LIMB\/2;\n+        final long HALF_BITS_LIMB = BITS_PER_LIMB \/ 2;\n@@ -159,2 +172,1 @@\n-     * Unrolled Word-by-Word Montgomery Multiplication\n-     * r = a * b * 2^-260 (mod P)\n+     * Unrolled Word-by-Word Montgomery Multiplication r = a * b * 2^-260 (mod P)\n@@ -162,3 +174,3 @@\n-     * See [1] Figure 5. \"Algorithm 2: Word-by-Word Montgomery Multiplication for a Montgomery\n-     * Friendly modulus p\". Note: Step 6. Skipped; Instead use numAdds to reuse existing overflow\n-     * logic.\n+     * See [1] Figure 5. \"Algorithm 2: Word-by-Word Montgomery Multiplication\n+     * for a Montgomery Friendly modulus p\". Note: Step 6. Skipped; Instead use\n+     * numAdds to reuse existing overflow logic.\n@@ -181,1 +193,1 @@\n-        final long shift2 = BITS_PER_LIMB;      \/\/ 40\n+        final long shift2 = BITS_PER_LIMB; \/\/ 40\n@@ -183,4 +195,6 @@\n-        long d0, d1, d2, d3, d4;       \/\/ low digits from multiplication\n-        long dd0, dd1, dd2, dd3, dd4;  \/\/ high digits from multiplication\n-        long n, n0, n1, n2, n3, n4, nn0, nn1, nn2, nn3, nn4; \/\/ modulus multiple digits\n-        long c0, c1, c2, c3, c4, c5, c6, c7, c8, c9;         \/\/ multiplication result digits for each column\n+        long d0, d1, d2, d3, d4;      \/\/ low digits from multiplication\n+        long dd0, dd1, dd2, dd3, dd4; \/\/ high digits from multiplication\n+        long n, n0, n1, n2, n3, n4,\n+            nn0, nn1, nn2, nn3, nn4; \/\/ modulus multiple digits\n+        long c0, c1, c2, c3, c4, c5, c6, c7, c8, c9; \/\/ multiplication result\n+                                                     \/\/ digits for each column\n@@ -189,17 +203,43 @@\n-        d0 = aa0 * bb0; dd0 = Math.unsignedMultiplyHigh(aa0, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; n = d0;\n-        d1 = aa0 * bb1; dd1 = Math.unsignedMultiplyHigh(aa0, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n-        d2 = aa0 * bb2; dd2 = Math.unsignedMultiplyHigh(aa0, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n-        d3 = aa0 * bb3; dd3 = Math.unsignedMultiplyHigh(aa0, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n-        d4 = aa0 * bb4; dd4 = Math.unsignedMultiplyHigh(aa0, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n-\n-        n0 = n * modulus[0]; nn0 = Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); n0 &= LIMB_MASK;\n-        n1 = n * modulus[1]; nn1 = Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); n1 &= LIMB_MASK;\n-        n2 = n * modulus[2]; nn2 = Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); n2 &= LIMB_MASK;\n-        n3 = n * modulus[3]; nn3 = Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); n3 &= LIMB_MASK;\n-        n4 = n * modulus[4]; nn4 = Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); n4 &= LIMB_MASK;\n-\n-        dd0 += nn0; d0 += n0;\n-        dd1 += nn1; d1 += n1;\n-        dd2 += nn2; d2 += n2;\n-        dd3 += nn3; d3 += n3;\n-        dd4 += nn4; d4 += n4;\n+        d0 = aa0 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa0, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        n = d0;\n+        d1 = aa0 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa0, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa0 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa0, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa0 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa0, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa0 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa0, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        nn0 = Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        n0 &= LIMB_MASK;\n+        n1 = n * modulus[1];\n+        nn1 = Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        n1 &= LIMB_MASK;\n+        n2 = n * modulus[2];\n+        nn2 = Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        n2 &= LIMB_MASK;\n+        n3 = n * modulus[3];\n+        nn3 = Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        n3 &= LIMB_MASK;\n+        n4 = n * modulus[4];\n+        nn4 = Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        n4 &= LIMB_MASK;\n+\n+        dd0 += nn0;\n+        d0 += n0;\n+        dd1 += nn1;\n+        d1 += n1;\n+        dd2 += nn2;\n+        d2 += n2;\n+        dd3 += nn3;\n+        d3 += n3;\n+        dd4 += nn4;\n+        d4 += n4;\n@@ -214,11 +254,33 @@\n-        d0 = aa1 * bb0; dd0 = Math.unsignedMultiplyHigh(aa1, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; d0 += c1; n = d0 & LIMB_MASK;\n-        d1 = aa1 * bb1; dd1 = Math.unsignedMultiplyHigh(aa1, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n-        d2 = aa1 * bb2; dd2 = Math.unsignedMultiplyHigh(aa1, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n-        d3 = aa1 * bb3; dd3 = Math.unsignedMultiplyHigh(aa1, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n-        d4 = aa1 * bb4; dd4 = Math.unsignedMultiplyHigh(aa1, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n-\n-        n0 = n * modulus[0]; dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); d0 += n0 & LIMB_MASK;\n-        n1 = n * modulus[1]; dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); d1 += n1 & LIMB_MASK;\n-        n2 = n * modulus[2]; dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); d2 += n2 & LIMB_MASK;\n-        n3 = n * modulus[3]; dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); d3 += n3 & LIMB_MASK;\n-        n4 = n * modulus[4]; dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); d4 += n4 & LIMB_MASK;\n+        d0 = aa1 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa1, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c1;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa1 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa1, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa1 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa1, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa1 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa1, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa1 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa1, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n@@ -233,11 +295,33 @@\n-        d0 = aa2 * bb0; dd0 = Math.unsignedMultiplyHigh(aa2, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; d0 += c2; n = d0 & LIMB_MASK;\n-        d1 = aa2 * bb1; dd1 = Math.unsignedMultiplyHigh(aa2, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n-        d2 = aa2 * bb2; dd2 = Math.unsignedMultiplyHigh(aa2, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n-        d3 = aa2 * bb3; dd3 = Math.unsignedMultiplyHigh(aa2, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n-        d4 = aa2 * bb4; dd4 = Math.unsignedMultiplyHigh(aa2, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n-\n-        n0 = n * modulus[0]; dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); d0 += n0 & LIMB_MASK;\n-        n1 = n * modulus[1]; dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); d1 += n1 & LIMB_MASK;\n-        n2 = n * modulus[2]; dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); d2 += n2 & LIMB_MASK;\n-        n3 = n * modulus[3]; dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); d3 += n3 & LIMB_MASK;\n-        n4 = n * modulus[4]; dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); d4 += n4 & LIMB_MASK;\n+        d0 = aa2 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa2, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c2;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa2 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa2, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa2 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa2, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa2 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa2, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa2 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa2, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n@@ -252,11 +336,33 @@\n-        d0 = aa3 * bb0; dd0 = Math.unsignedMultiplyHigh(aa3, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; d0 += c3; n = d0 & LIMB_MASK;\n-        d1 = aa3 * bb1; dd1 = Math.unsignedMultiplyHigh(aa3, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n-        d2 = aa3 * bb2; dd2 = Math.unsignedMultiplyHigh(aa3, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n-        d3 = aa3 * bb3; dd3 = Math.unsignedMultiplyHigh(aa3, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n-        d4 = aa3 * bb4; dd4 = Math.unsignedMultiplyHigh(aa3, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n-\n-        n0 = n * modulus[0]; dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); d0 += n0 & LIMB_MASK;\n-        n1 = n * modulus[1]; dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); d1 += n1 & LIMB_MASK;\n-        n2 = n * modulus[2]; dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); d2 += n2 & LIMB_MASK;\n-        n3 = n * modulus[3]; dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); d3 += n3 & LIMB_MASK;\n-        n4 = n * modulus[4]; dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); d4 += n4 & LIMB_MASK;\n+        d0 = aa3 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa3, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c3;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa3 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa3, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa3 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa3, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa3 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa3, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa3 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa3, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n@@ -271,11 +377,33 @@\n-        d0 = aa4 * bb0; dd0 = Math.unsignedMultiplyHigh(aa4, bb0) << shift1 | (d0 >>> shift2); d0 &= LIMB_MASK; d0 += c4; n = d0 & LIMB_MASK;\n-        d1 = aa4 * bb1; dd1 = Math.unsignedMultiplyHigh(aa4, bb1) << shift1 | (d1 >>> shift2); d1 &= LIMB_MASK;\n-        d2 = aa4 * bb2; dd2 = Math.unsignedMultiplyHigh(aa4, bb2) << shift1 | (d2 >>> shift2); d2 &= LIMB_MASK;\n-        d3 = aa4 * bb3; dd3 = Math.unsignedMultiplyHigh(aa4, bb3) << shift1 | (d3 >>> shift2); d3 &= LIMB_MASK;\n-        d4 = aa4 * bb4; dd4 = Math.unsignedMultiplyHigh(aa4, bb4) << shift1 | (d4 >>> shift2); d4 &= LIMB_MASK;\n-\n-        n0 = n * modulus[0]; dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2); d0 += n0 & LIMB_MASK;\n-        n1 = n * modulus[1]; dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2); d1 += n1 & LIMB_MASK;\n-        n2 = n * modulus[2]; dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2); d2 += n2 & LIMB_MASK;\n-        n3 = n * modulus[3]; dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2); d3 += n3 & LIMB_MASK;\n-        n4 = n * modulus[4]; dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2); d4 += n4 & LIMB_MASK;\n+        d0 = aa4 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa4, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c4;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa4 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa4, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa4 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa4, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa4 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa4, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa4 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa4, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n@@ -287,1 +415,1 @@\n-        c9 =       dd4 + (c8 >>> BITS_PER_LIMB);\n+        c9 = dd4 + (c8 >>> BITS_PER_LIMB);\n@@ -296,4 +424,8 @@\n-        c1 = c6 - modulus[1] + (c0 >> BITS_PER_LIMB); c0 &= LIMB_MASK;\n-        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB); c1 &= LIMB_MASK;\n-        c3 = c8 - modulus[3] + (c2 >> BITS_PER_LIMB); c2 &= LIMB_MASK;\n-        c4 = c9 - modulus[4] + (c3 >> BITS_PER_LIMB); c3 &= LIMB_MASK;\n+        c1 = c6 - modulus[1] + (c0 >> BITS_PER_LIMB);\n+        c0 &= LIMB_MASK;\n+        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        c1 &= LIMB_MASK;\n+        c3 = c8 - modulus[3] + (c2 >> BITS_PER_LIMB);\n+        c2 &= LIMB_MASK;\n+        c4 = c9 - modulus[4] + (c3 >> BITS_PER_LIMB);\n+        c3 &= LIMB_MASK;\n@@ -303,5 +435,5 @@\n-        r[0] =  ((c5 & mask) | (c0 & ~mask));\n-        r[1] =  ((c6 & mask) | (c1 & ~mask));\n-        r[2] =  ((c7 & mask) | (c2 & ~mask));\n-        r[3] =  ((c8 & mask) | (c3 & ~mask));\n-        r[4] =  ((c9 & mask) | (c4 & ~mask));\n+        r[0] = ((c5 & mask) | (c0 & ~mask));\n+        r[1] = ((c6 & mask) | (c1 & ~mask));\n+        r[2] = ((c7 & mask) | (c2 & ~mask));\n+        r[3] = ((c8 & mask) | (c3 & ~mask));\n+        r[4] = ((c9 & mask) | (c4 & ~mask));\n@@ -338,2 +470,2 @@\n-        long carry = b4>>48; \/\/max 16-bits\n-        b4 -= carry<<48;\n+        long carry = b4 >> 48; \/\/ max 16-bits\n+        b4 -= carry << 48;\n@@ -344,1 +476,1 @@\n-        b1 -= carry<<44;\n+        b1 -= carry << 44;\n@@ -346,1 +478,1 @@\n-        b3 -= carry<<36;\n+        b3 -= carry << 36;\n@@ -348,1 +480,1 @@\n-        b4 += carry<<16;\n+        b4 += carry << 16;\n@@ -362,4 +494,8 @@\n-        c1 = modulus[1] + b1 + (c0 >> BITS_PER_LIMB); c0 &= LIMB_MASK;\n-        c2 = modulus[2] + b2 + (c1 >> BITS_PER_LIMB); c1 &= LIMB_MASK;\n-        c3 = modulus[3] + b3 + (c2 >> BITS_PER_LIMB); c2 &= LIMB_MASK;\n-        c4 = modulus[4] + b4 + (c3 >> BITS_PER_LIMB); c3 &= LIMB_MASK;\n+        c1 = modulus[1] + b1 + (c0 >> BITS_PER_LIMB);\n+        c0 &= LIMB_MASK;\n+        c2 = modulus[2] + b2 + (c1 >> BITS_PER_LIMB);\n+        c1 &= LIMB_MASK;\n+        c3 = modulus[3] + b3 + (c2 >> BITS_PER_LIMB);\n+        c2 &= LIMB_MASK;\n+        c4 = modulus[4] + b4 + (c3 >> BITS_PER_LIMB);\n+        c3 &= LIMB_MASK;\n@@ -377,1 +513,1 @@\n-                                       byte highByte) {\n+            byte highByte) {\n@@ -404,1 +540,2 @@\n-        \/\/ Since top term (2^(52i-32)) will leave top 20 bits back in the same position i,\n+        \/\/ Since top term (2^(52i-32)) will leave top 20 bits back in the same\n+        \/\/ position i,\n@@ -406,1 +543,1 @@\n-        v += v>>32;\n+        v += v >> 32;\n@@ -409,1 +546,1 @@\n-        limbs[i-1] += (v << 20) & LIMB_MASK;\n+        limbs[i - 1] += (v << 20) & LIMB_MASK;\n@@ -412,2 +549,2 @@\n-        limbs[i-2] -= (v<<40) & LIMB_MASK;\n-        limbs[i-1] -= v>>12;\n+        limbs[i - 2] -= (v << 40) & LIMB_MASK;\n+        limbs[i - 1] -= v >> 12;\n@@ -416,2 +553,2 @@\n-        limbs[i-4] -= (v<<48) & LIMB_MASK;\n-        limbs[i-3] -= v>>4;\n+        limbs[i - 4] -= (v << 48) & LIMB_MASK;\n+        limbs[i - 3] -= v >> 4;\n@@ -420,2 +557,2 @@\n-        limbs[i-5] += (v<<4) & LIMB_MASK;\n-        limbs[i-4] += v>>48;\n+        limbs[i - 5] += (v << 4) & LIMB_MASK;\n+        limbs[i - 4] += v >> 48;\n@@ -423,1 +560,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":255,"deletions":118,"binary":false,"changes":373,"status":"modified"},{"patch":"@@ -42,2 +42,6 @@\n- * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n- * @run main\/othervm\/timeout=1200 --add-opens java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics ECOperationsFuzzTest\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm\/timeout=1200 --add-opens\n+ *      java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:-UseIntPolyIntrinsics ECOperationsFuzzTest\n@@ -47,1 +51,1 @@\n- \/*\n+\/*\n@@ -50,2 +54,6 @@\n- * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n- * @run main\/othervm\/timeout=1200 --add-opens java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions -XX:+UseIntPolyIntrinsics ECOperationsFuzzTest\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm\/timeout=1200 --add-opens\n+ *      java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseIntPolyIntrinsics ECOperationsFuzzTest\n@@ -55,2 +63,3 @@\n-\/\/ This test case is NOT entirely deterministic, it uses a random seed for pseudo-random number generator\n-\/\/ If a failure occurs, hardcode the seed to make the test case deterministic\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for\n+\/\/ pseudo-random number generator. If a failure occurs, hardcode the seed to\n+\/\/ make the test case deterministic\n@@ -58,5 +67,30 @@\n-        public static void main(String[] args) throws Exception {\n-                \/\/Note: it might be useful to increase this number during development\n-                final int repeat = 10000;\n-                test(repeat);\n-                System.out.println(\"Fuzz Success\");\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Note: it might be useful to increase this number during development\n+        final int repeat = 10000;\n+        test(repeat);\n+        System.out.println(\"Fuzz Success\");\n+    }\n+\n+    private static void check(MutablePoint reference, MutablePoint testValue,\n+            long seed, int iter) {\n+        AffinePoint affineRef = reference.asAffine();\n+        AffinePoint affine = testValue.asAffine();\n+        if (!affineRef.equals(affine)) {\n+            throw new RuntimeException(\n+                    \"Found error with seed \" + seed + \"at iteration \" + iter);\n+        }\n+    }\n+\n+    public static void test(int repeat) throws Exception {\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n+\n+        int keySize = 256;\n+        ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n+        NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n+        ECPoint generator = curve.getGenerator();\n+        BigInteger b = curve.getCurve().getB();\n+        if (params == null || generator == null) {\n+            throw new RuntimeException(\n+                    \"No EC parameters available for key size \" + keySize + \" bits\");\n@@ -65,6 +99,11 @@\n-        private static void check(MutablePoint reference, MutablePoint testValue, long seed, int iter) {\n-                AffinePoint affineRef = reference.asAffine();\n-                AffinePoint affine = testValue.asAffine();\n-                if (!affineRef.equals(affine)) {\n-                        throw new RuntimeException(\"Found error with seed \"+seed +\"at iteration \"+ iter);\n-                }\n+        ECOperations ops = ECOperations.forParameters(params).get();\n+        ECOperations opsReference = new ECOperations(\n+                IntegerPolynomialP256.ONE.getElement(b), P256OrderField.ONE);\n+\n+        boolean instanceTest1 = ops\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        boolean instanceTest2 = opsReference\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        if (instanceTest1 == false || instanceTest2 == true) {\n+            throw new RuntimeException(\"Bad Initialization: [\"\n+                + instanceTest1 + \",\" + instanceTest2 + \"]\");\n@@ -73,73 +112,54 @@\n-        public static void test(int repeat) throws Exception {\n-                Random rnd = new Random();\n-                long seed = rnd.nextLong();\n-                rnd.setSeed(seed);\n-\n-                int keySize = 256;\n-                ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n-                NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n-                ECPoint generator = curve.getGenerator();\n-                BigInteger b = curve.getCurve().getB();\n-                if (params == null || generator == null) {\n-                        throw new RuntimeException(\"No EC parameters available for key size \" + keySize + \" bits\");\n-                }\n-\n-                ECOperations ops = ECOperations.forParameters(params).get();\n-                ECOperations opsReference = new ECOperations(IntegerPolynomialP256.ONE.getElement(b), P256OrderField.ONE);\n-\n-                boolean instanceTest1 = ops.getField() instanceof IntegerMontgomeryFieldModuloP;\n-                boolean instanceTest2 = opsReference.getField() instanceof IntegerMontgomeryFieldModuloP;\n-                if (instanceTest1 == false || instanceTest2 == true) {\n-                        throw new RuntimeException(\"Bad Initialization: [\"+instanceTest1+\",\"+instanceTest2+\"]\");\n-                }\n-\n-                byte[] multiple = new byte[keySize\/8];\n-                rnd.nextBytes(multiple);\n-                multiple[keySize\/8-1] &= 0x7f; \/\/copied from opsReference.seedToScalar(multiple);\n-\n-                MutablePoint referencePoint = opsReference.multiply(generator, multiple);\n-                MutablePoint point = ops.multiply(generator, multiple);\n-                check(referencePoint, point, seed, -1);\n-\n-                AffinePoint refAffineGenerator = AffinePoint.fromECPoint(generator, referencePoint.getField());\n-                AffinePoint montAffineGenerator = AffinePoint.fromECPoint(generator, point.getField());\n-\n-                MutablePoint refProjGenerator = new ProjectivePoint.Mutable(\n-                        refAffineGenerator.getX(false).mutable(),\n-                        refAffineGenerator.getY(false).mutable(),\n-                        referencePoint.getField().get1().mutable());\n-\n-                MutablePoint projGenerator = new ProjectivePoint.Mutable(\n-                        montAffineGenerator.getX(false).mutable(),\n-                        montAffineGenerator.getY(false).mutable(),\n-                        point.getField().get1().mutable());\n-\n-                for (int i = 0; i < repeat; i++) {\n-                        rnd.nextBytes(multiple);\n-                        multiple[keySize\/8-1] &= 0x7f; \/\/copied from opsReference.seedToScalar(multiple);\n-\n-                        MutablePoint nextReferencePoint = opsReference.multiply(referencePoint.asAffine(), multiple);\n-                        MutablePoint nextPoint = ops.multiply(point.asAffine().toECPoint(), multiple);\n-                        check(nextReferencePoint, nextPoint, seed, i);\n-\n-                        if (rnd.nextBoolean()) {\n-                                opsReference.setSum(nextReferencePoint, referencePoint);\n-                                ops.setSum(nextPoint, point);\n-                                check(nextReferencePoint, nextPoint, seed, i);\n-                        }\n-\n-                        if (rnd.nextBoolean()) {\n-                                opsReference.setSum(nextReferencePoint, refProjGenerator);\n-                                ops.setSum(nextPoint, projGenerator);\n-                                check(nextReferencePoint, nextPoint, seed, i);\n-                        }\n-\n-                        if (rnd.nextInt(100)<10) { \/\/ 10% Reset point to generator, test generator multiplier\n-                                referencePoint = opsReference.multiply(generator, multiple);\n-                                point = ops.multiply(generator, multiple);\n-                                check(referencePoint, point, seed, i);\n-                        } else {\n-                                referencePoint = nextReferencePoint;\n-                                point = nextPoint;\n-                        }\n-                }\n+        byte[] multiple = new byte[keySize \/ 8];\n+        rnd.nextBytes(multiple);\n+        multiple[keySize\/8 - 1] &= 0x7f; \/\/ from opsReference.seedToScalar(multiple);\n+\n+        MutablePoint referencePoint = opsReference.multiply(generator, multiple);\n+        MutablePoint point = ops.multiply(generator, multiple);\n+        check(referencePoint, point, seed, -1);\n+\n+        AffinePoint refAffineGenerator = AffinePoint.fromECPoint(generator,\n+                referencePoint.getField());\n+        AffinePoint montAffineGenerator = AffinePoint.fromECPoint(generator,\n+                point.getField());\n+\n+        MutablePoint refProjGenerator = new ProjectivePoint.Mutable(\n+                refAffineGenerator.getX(false).mutable(),\n+                refAffineGenerator.getY(false).mutable(),\n+                referencePoint.getField().get1().mutable());\n+\n+        MutablePoint projGenerator = new ProjectivePoint.Mutable(\n+                montAffineGenerator.getX(false).mutable(),\n+                montAffineGenerator.getY(false).mutable(),\n+                point.getField().get1().mutable());\n+\n+        for (int i = 0; i < repeat; i++) {\n+            rnd.nextBytes(multiple);\n+            multiple[keySize\/8 - 1] &= 0x7f; \/\/ opsReference.seedToScalar(multiple);\n+\n+            MutablePoint nextReferencePoint = opsReference\n+                    .multiply(referencePoint.asAffine(), multiple);\n+            MutablePoint nextPoint = ops.multiply(point.asAffine().toECPoint(),\n+                    multiple);\n+            check(nextReferencePoint, nextPoint, seed, i);\n+\n+            if (rnd.nextBoolean()) {\n+                opsReference.setSum(nextReferencePoint, referencePoint);\n+                ops.setSum(nextPoint, point);\n+                check(nextReferencePoint, nextPoint, seed, i);\n+            }\n+\n+            if (rnd.nextBoolean()) {\n+                opsReference.setSum(nextReferencePoint, refProjGenerator);\n+                ops.setSum(nextPoint, projGenerator);\n+                check(nextReferencePoint, nextPoint, seed, i);\n+            }\n+\n+            if (rnd.nextInt(100) < 10) { \/\/ 10% Reset point to generator, test\n+                                         \/\/ generator multiplier\n+                referencePoint = opsReference.multiply(generator, multiple);\n+                point = ops.multiply(generator, multiple);\n+                check(referencePoint, point, seed, i);\n+            } else {\n+                referencePoint = nextReferencePoint;\n+                point = nextPoint;\n+            }\n@@ -147,0 +167,1 @@\n+    }\n@@ -150,1 +171,1 @@\n-\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java\"\n\\ No newline at end of file\n+\/\/ make test TEST=\"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java","additions":113,"deletions":92,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -43,2 +43,5 @@\n- * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n- * @run main\/othervm --add-opens java.base\/sun.security.ec=ALL-UNNAMED ECOperationsKATTest\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm --add-opens java.base\/sun.security.ec=ALL-UNNAMED\n+ *      ECOperationsKATTest\n@@ -50,2 +53,6 @@\n- * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:-TieredCompilation --add-opens java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions ECOperationsKATTest\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp\n+ *      -XX:-TieredCompilation --add-opens java.base\/sun.security.ec=ALL-UNNAMED\n+ *      -XX:+UnlockDiagnosticVMOptions ECOperationsKATTest\n@@ -55,24 +62,50 @@\n-public class ECOperationsKATTest {\n-        final private static java.util.HexFormat hex = java.util.HexFormat.of();\n-\n-        public static void main(String args[]) throws Exception {\n-                int testsPassed = 0;\n-                int testNumber = 0;\n-\n-                for (TestData test : testList) {\n-                        System.out.println(\"*** Test \" + ++testNumber + \": \" + test.testName);\n-                        if (runSingleTest(test)) {\n-                                testsPassed++;\n-                        }\n-                }\n-                System.out.println();\n-\n-                System.out.println(\"*** Test Infinity point operations\");\n-                if (neutralTest()) {\n-                        System.out.println(\"*** Test \" + ++testNumber + \": neutralTest\");\n-                        testsPassed++;\n-                }\n-\n-                if (testsPassed != testNumber) {\n-                        throw new RuntimeException(\"One or more tests failed. Check output for details\");\n-                }\n+ public class ECOperationsKATTest {\n+    final private static java.util.HexFormat hex = java.util.HexFormat.of();\n+\n+    public static void main(String args[]) throws Exception {\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNumber + \": \" + test.testName);\n+            if (runSingleTest(test)) {\n+                testsPassed++;\n+            }\n+        }\n+        System.out.println();\n+\n+        if (testsPassed != testNumber) {\n+            throw new RuntimeException(\n+                    \"One or more tests failed. Check output for details\");\n+        }\n+    }\n+\n+    private static boolean check(MutablePoint testValue, ECPoint reference) {\n+        AffinePoint affine = testValue.asAffine();\n+        BigInteger x = affine.getX().asBigInteger();\n+        BigInteger y = affine.getY().asBigInteger();\n+        BigInteger refX = reference.getAffineX();\n+        BigInteger refY = reference.getAffineY();\n+\n+        if (!refX.equals(x) || !refY.equals(y)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected: X: \" + refX.toString(16) + \" Y: \"\n+                    + refY.toString(16));\n+            System.out.println(\n+                    \"Result:   X: \" + x.toString(16) + \" Y: \" + y.toString(16));\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static class TestData {\n+        public TestData(String name, String keyStr, String xStr1, String yStr1,\n+                String xStr2, String yStr2) {\n+            testName = name;\n+            \/\/ multiplier = (new BigInteger(keyStr, 16)).toByteArray();\n+            multiplier = hex.parseHex(keyStr);\n+            sun.security.util.ArrayUtil.reverse(multiplier);\n+            reference1 = new ECPoint(new BigInteger(xStr1, 16),\n+                    new BigInteger(yStr1, 16));\n+            reference2 = new ECPoint(new BigInteger(xStr2, 16),\n+                    new BigInteger(yStr2, 16));\n@@ -81,14 +114,62 @@\n-        private static boolean check(MutablePoint testValue, ECPoint reference) {\n-                AffinePoint affine = testValue.asAffine();\n-                BigInteger x = affine.getX().asBigInteger();\n-                BigInteger y = affine.getY().asBigInteger();\n-                BigInteger refX = reference.getAffineX();\n-                BigInteger refY = reference.getAffineY();\n-\n-                if (!refX.equals(x) || !refY.equals(y)) {\n-                        System.out.println(\"ERROR - Output Mismatch!\");\n-                        System.out.println(\"Expected: X: \" + refX.toString(16) + \" Y: \" + refY.toString(16));\n-                        System.out.println(\"Result:   X: \" + x.toString(16)    + \" Y: \" + y.toString(16));\n-                        return false;\n-                }\n-                return true;\n+        String testName;\n+        byte[] multiplier;\n+        ECPoint reference1; \/\/ For generator multiplier test\n+        ECPoint reference2; \/\/ For non-generator multiplier test\n+    }\n+\n+    public static final List<TestData> testList = new LinkedList<TestData>() {{\n+    \/\/ (x1,y1) = mult*generator\n+    \/\/ (x2,y2) = mult*mult*generator\n+    add(new TestData(\"Test Vector #1\",\n+        \"0000000000000000000000000000000000000000000000000000000000000012\", \/\/ mult\n+        \"1057E0AB5780F470DEFC9378D1C7C87437BB4C6F9EA55C63D936266DBD781FDA\", \/\/ x1\n+        \"F6F1645A15CBE5DC9FA9B7DFD96EE5A7DCC11B5C5EF4F1F78D83B3393C6A45A2\", \/\/ y1\n+        \"4954047A366A91E3FD94E574DB6F2B04F3A8465883DBC55A816EA563BF54A324\", \/\/ x2\n+        \"B5A54786FD9EA48C9FC38A0557B0C4D54F285908A7291B630D06BEE970F530D3\") \/\/ y2\n+    );\n+    add(new TestData(\"Test Vector #2\",\n+        \"1200000000000000000000000000000000000000000000000000000000000000\", \/\/ mult\n+        \"DF684E6D0D57AF8B89DA11E8F7436C3D360F531D62BDCE42C5A8B72D73D5C717\", \/\/ x\n+        \"9D3576BD03C09B8F416EE9C27D70AD4A425119271ACF549312CA48758F4E1FEC\", \/\/ y\n+        \"57C8257EEAABF5446DCFACB99DEE104367B6C9950C76797C372EB177D5FA23B3\", \/\/ x\n+        \"1CD3E8A34521C1C8E574EB4B99343CAA57E00725D8618F0231C7C79AA6837725\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #3\",\n+        \"0000000000000000000000000000000120000000000000000000000000000012\", \/\/ mult\n+        \"A69DFD47B24485E5F523BDA5FBACF03F5A7C3D22E0C2BC6705594B7B051A06D0\", \/\/ x\n+        \"ECF19629416BE5C9AF1E30988F3AA8B803809CF4D12944EB49C5E9892723798A\", \/\/ y\n+        \"1E28559F5B681C308632EE11A007B9891B3FD592C982C4926153795794295E58\", \/\/ x\n+        \"3C373046C27BB34609A43C91DF6D4B9AB9EB08F3B69A8F8FAE944211D8297F30\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #4\",\n+        \"0000000000000000000000000000000000000000000000000000000000000001\", \/\/ mult\n+        \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n+        \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", \/\/ y\n+        \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n+        \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #5\",\n+        \"EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \/\/ mult\n+        \"66B71D0BD47344197CCFB0C9578EAF0ADB609E05BB4E8F87D56BD34F24EE7C47\", \/\/ x\n+        \"14A0ECB7F708C02B2BAE238D2C4607BB9D04FCE64E10A428C911D6FA25B2F0FD\", \/\/ y\n+        \"D25AAFD0FCC5B5E95C84C0702C138BC4D7FEB4E5F9C2DFB4301E313507EFDF44\", \/\/ x\n+        \"F3F04EBC7D308511B0392BB7171CF92688D6484A95A8100EDFC933613A359133\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #6\",\n+        \"1111111111111111111111111111111111111111111111111111111111111111\", \/\/ mult\n+        \"0217E617F0B6443928278F96999E69A23A4F2C152BDF6D6CDF66E5B80282D4ED\", \/\/ x\n+        \"194A7DEBCB97712D2DDA3CA85AA8765A56F45FC758599652F2897C65306E5794\", \/\/ y\n+        \"A83A07D6AE918359DEBCC385DA1E416EB83417435079CA8DB06005E107C309A0\", \/\/ x\n+        \"5AACDF816850C33EB3E54F3D0DD759B97B5E7065B2060016F73735E4A6AADE23\") \/\/ y\n+    );\n+    }};\n+\n+    private static boolean runSingleTest(TestData testData) {\n+        int keySize = 256;\n+        ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n+        NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n+        ECPoint generator = curve.getGenerator();\n+        BigInteger b = curve.getCurve().getB();\n+        if (params == null || generator == null) {\n+            throw new RuntimeException(\n+                    \"No EC parameters available for key size \" + keySize + \" bits\");\n@@ -97,14 +178,11 @@\n-        private static class TestData {\n-                public TestData(String name, String keyStr, String xStr1, String yStr1, String xStr2, String yStr2) {\n-                        testName = name;\n-                        \/\/multiplier = (new BigInteger(keyStr, 16)).toByteArray();\n-                        multiplier = hex.parseHex(keyStr);\n-                        sun.security.util.ArrayUtil.reverse(multiplier);\n-                        reference1 = new ECPoint(new BigInteger(xStr1, 16), new BigInteger(yStr1, 16));\n-                        reference2 = new ECPoint(new BigInteger(xStr2, 16), new BigInteger(yStr2, 16));\n-                }\n-\n-                String testName;\n-                byte[] multiplier;\n-                ECPoint reference1; \/\/For generator multiplier test\n-                ECPoint reference2; \/\/For non-generator multiplier test\n+        ECOperations ops = ECOperations.forParameters(params).get();\n+        ECOperations opsReference = new ECOperations(\n+                IntegerPolynomialP256.ONE.getElement(b), P256OrderField.ONE);\n+\n+        boolean instanceTest1 = ops\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        boolean instanceTest2 = opsReference\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        if (instanceTest1 == false || instanceTest2 == true) {\n+            throw new RuntimeException(\"Bad Initialization: [\" + instanceTest1 + \",\"\n+                    + instanceTest2 + \"]\");\n@@ -113,79 +191,6 @@\n-        public static final List<TestData> testList = new LinkedList<TestData>() {{\n-                \/\/ (x1,y1) = mult*generator\n-                \/\/ (x2,y2) = mult*mult*generator\n-                add(new TestData(\"Test Vector #1\",\n-                \"0000000000000000000000000000000000000000000000000000000000000012\", \/\/ mult\n-                \"1057E0AB5780F470DEFC9378D1C7C87437BB4C6F9EA55C63D936266DBD781FDA\", \/\/ x1\n-                \"F6F1645A15CBE5DC9FA9B7DFD96EE5A7DCC11B5C5EF4F1F78D83B3393C6A45A2\", \/\/ y1\n-                \"4954047A366A91E3FD94E574DB6F2B04F3A8465883DBC55A816EA563BF54A324\", \/\/ x2\n-                \"B5A54786FD9EA48C9FC38A0557B0C4D54F285908A7291B630D06BEE970F530D3\") \/\/ y2\n-                );\n-                add(new TestData(\"Test Vector #2\",\n-                \"1200000000000000000000000000000000000000000000000000000000000000\", \/\/ mult\n-                \"DF684E6D0D57AF8B89DA11E8F7436C3D360F531D62BDCE42C5A8B72D73D5C717\", \/\/ x\n-                \"9D3576BD03C09B8F416EE9C27D70AD4A425119271ACF549312CA48758F4E1FEC\", \/\/ y\n-                \"57C8257EEAABF5446DCFACB99DEE104367B6C9950C76797C372EB177D5FA23B3\", \/\/ x\n-                \"1CD3E8A34521C1C8E574EB4B99343CAA57E00725D8618F0231C7C79AA6837725\") \/\/ y\n-                );\n-                add(new TestData(\"Test Vector #3\",\n-                \"0000000000000000000000000000000120000000000000000000000000000012\", \/\/ mult\n-                \"A69DFD47B24485E5F523BDA5FBACF03F5A7C3D22E0C2BC6705594B7B051A06D0\", \/\/ x\n-                \"ECF19629416BE5C9AF1E30988F3AA8B803809CF4D12944EB49C5E9892723798A\", \/\/ y\n-                \"1E28559F5B681C308632EE11A007B9891B3FD592C982C4926153795794295E58\", \/\/ x\n-                \"3C373046C27BB34609A43C91DF6D4B9AB9EB08F3B69A8F8FAE944211D8297F30\") \/\/ y\n-                );\n-                add(new TestData(\"Test Vector #4\",\n-                \"0000000000000000000000000000000000000000000000000000000000000001\", \/\/ mult\n-                \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n-                \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", \/\/ y\n-                \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n-                \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\") \/\/ y\n-                );\n-                add(new TestData(\"Test Vector #5\",\n-                \"EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \/\/ mult\n-                \"66B71D0BD47344197CCFB0C9578EAF0ADB609E05BB4E8F87D56BD34F24EE7C47\", \/\/ x\n-                \"14A0ECB7F708C02B2BAE238D2C4607BB9D04FCE64E10A428C911D6FA25B2F0FD\", \/\/ y\n-                \"D25AAFD0FCC5B5E95C84C0702C138BC4D7FEB4E5F9C2DFB4301E313507EFDF44\", \/\/ x\n-                \"F3F04EBC7D308511B0392BB7171CF92688D6484A95A8100EDFC933613A359133\") \/\/ y\n-                );\n-                add(new TestData(\"Test Vector #6\",\n-                \"1111111111111111111111111111111111111111111111111111111111111111\", \/\/ mult\n-                \"0217E617F0B6443928278F96999E69A23A4F2C152BDF6D6CDF66E5B80282D4ED\", \/\/ x\n-                \"194A7DEBCB97712D2DDA3CA85AA8765A56F45FC758599652F2897C65306E5794\", \/\/ y\n-                \"A83A07D6AE918359DEBCC385DA1E416EB83417435079CA8DB06005E107C309A0\", \/\/ x\n-                \"5AACDF816850C33EB3E54F3D0DD759B97B5E7065B2060016F73735E4A6AADE23\") \/\/ y\n-                );\n-        }};\n-\n-        private static boolean runSingleTest(TestData testData) {\n-                int keySize = 256;\n-                ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n-                NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n-                ECPoint generator = curve.getGenerator();\n-                BigInteger b = curve.getCurve().getB();\n-                if (params == null || generator == null) {\n-                        throw new RuntimeException(\"No EC parameters available for key size \" + keySize + \" bits\");\n-                }\n-\n-                ECOperations ops = ECOperations.forParameters(params).get();\n-                ECOperations opsReference = new ECOperations(IntegerPolynomialP256.ONE.getElement(b), P256OrderField.ONE);\n-\n-                boolean instanceTest1 = ops.getField() instanceof IntegerMontgomeryFieldModuloP;\n-                boolean instanceTest2 = opsReference.getField() instanceof IntegerMontgomeryFieldModuloP;\n-                if (instanceTest1 == false || instanceTest2 == true) {\n-                        throw new RuntimeException(\"Bad Initialization: [\"+instanceTest1+\",\"+instanceTest2+\"]\");\n-                }\n-\n-                MutablePoint nextPoint = ops.multiply(generator, testData.multiplier);\n-                MutablePoint nextReferencePoint = opsReference.multiply(generator, testData.multiplier);\n-                if (!check(nextReferencePoint, testData.reference1) || !check(nextPoint, testData.reference1)){\n-                        return false;\n-                }\n-\n-                nextPoint = ops.multiply(nextPoint.asAffine(), testData.multiplier);\n-                nextReferencePoint = opsReference.multiply(nextReferencePoint.asAffine(), testData.multiplier);\n-                if (!check(nextReferencePoint, testData.reference2) || !check(nextPoint, testData.reference2)){\n-                        return false;\n-                }\n-\n-                return true;\n+        MutablePoint nextPoint = ops.multiply(generator, testData.multiplier);\n+        MutablePoint nextReferencePoint = opsReference.multiply(generator,\n+                testData.multiplier);\n+        if (!check(nextReferencePoint, testData.reference1)\n+                || !check(nextPoint, testData.reference1)) {\n+            return false;\n@@ -194,2 +199,6 @@\n-        private static boolean neutralTest() {\n-                return true;\n+        nextPoint = ops.multiply(nextPoint.asAffine(), testData.multiplier);\n+        nextReferencePoint = opsReference.multiply(nextReferencePoint.asAffine(),\n+                testData.multiplier);\n+        if (!check(nextReferencePoint, testData.reference2)\n+                || !check(nextPoint, testData.reference2)) {\n+            return false;\n@@ -197,0 +206,3 @@\n+\n+        return true;\n+    }\n@@ -241,1 +253,0 @@\n-\n","filename":"test\/jdk\/com\/sun\/security\/ec\/ECOperationsKATTest.java","additions":149,"deletions":138,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -34,3 +34,6 @@\n- * @modules java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics IntegerPolynomialTest\n- * @summary Unit test IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ * java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics\n+ * IntegerPolynomialTest\n+ * @summary Unit test\n+ * IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n@@ -42,3 +45,6 @@\n- * @modules java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:-TieredCompilation -XX:+UseIntPolyIntrinsics IntegerPolynomialTest\n- * @summary Unit test IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ * java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp\n+ * -XX:-TieredCompilation -XX:+UseIntPolyIntrinsics IntegerPolynomialTest\n+ * @summary Unit test\n+ * IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n@@ -47,2 +53,3 @@\n-\/\/ This test case is NOT entirely deterministic, it uses a random seed for pseudo-random number generator\n-\/\/ If a failure occurs, hardcode the seed to make the test case deterministic\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for\n+\/\/ pseudo-random number generator. If a failure occurs, hardcode the seed to\n+\/\/ make the test case deterministic\n@@ -50,4 +57,4 @@\n-        public static void main(String[] args) throws Exception {\n-                Random rnd = new Random();\n-                long seed = rnd.nextLong();\n-                rnd.setSeed(seed);\n+    public static void main(String[] args) throws Exception {\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n@@ -55,8 +62,9 @@\n-                IntegerPolynomial testFields[] = new IntegerPolynomial[]{\n-                        IntegerPolynomial1305.ONE, IntegerPolynomial25519.ONE,\n-                        IntegerPolynomial448.ONE, IntegerPolynomialP256.ONE, MontgomeryIntegerPolynomialP256.ONE,\n-                        IntegerPolynomialP384.ONE, IntegerPolynomialP521.ONE,\n-                        new IntegerPolynomialModBinP.Curve25519OrderField(), new IntegerPolynomialModBinP.Curve448OrderField(),\n-                        P256OrderField.ONE, P384OrderField.ONE, P521OrderField.ONE,\n-                        Curve25519OrderField.ONE, Curve448OrderField.ONE\n-                };\n+        IntegerPolynomial testFields[] = new IntegerPolynomial[] {\n+                IntegerPolynomial1305.ONE, IntegerPolynomial25519.ONE,\n+                IntegerPolynomial448.ONE, IntegerPolynomialP256.ONE,\n+                MontgomeryIntegerPolynomialP256.ONE, IntegerPolynomialP384.ONE,\n+                IntegerPolynomialP521.ONE,\n+                new IntegerPolynomialModBinP.Curve25519OrderField(),\n+                new IntegerPolynomialModBinP.Curve448OrderField(),\n+                P256OrderField.ONE, P384OrderField.ONE, P521OrderField.ONE,\n+                Curve25519OrderField.ONE, Curve448OrderField.ONE };\n@@ -64,5 +72,7 @@\n-                for (IntegerPolynomial field:testFields) {\n-                        ImmutableIntegerModuloP aRef = field.getElement(new BigInteger(32*64, rnd));\n-                        MutableIntegerModuloP a = aRef.mutable();\n-                        ImmutableIntegerModuloP bRef = field.getElement(new BigInteger(32*64, rnd));\n-                        MutableIntegerModuloP b = bRef.mutable();\n+        for (IntegerPolynomial field : testFields) {\n+            ImmutableIntegerModuloP aRef = field\n+                    .getElement(new BigInteger(32 * 64, rnd));\n+            MutableIntegerModuloP a = aRef.mutable();\n+            ImmutableIntegerModuloP bRef = field\n+                    .getElement(new BigInteger(32 * 64, rnd));\n+            MutableIntegerModuloP b = bRef.mutable();\n@@ -70,10 +80,10 @@\n-                        a.conditionalSet(b, 0); \/\/ Don't assign\n-                        if (Arrays.equals(a.getLimbs(), b.getLimbs())) {\n-                                throw new RuntimeException(\"[SEED \"+seed + \"]: Incorrect assign for \" + field);\n-                        }\n-                        a.conditionalSet(b, 1); \/\/ Assign\n-                        if (!Arrays.equals(a.getLimbs(), b.getLimbs())) {\n-                                throw new RuntimeException(\"[SEED \"+seed + \"]: Incorrect assign for \" + field);\n-                        }\n-                }\n-                System.out.println(\"Test Success\");\n+            a.conditionalSet(b, 0); \/\/ Don't assign\n+            if (Arrays.equals(a.getLimbs(), b.getLimbs())) {\n+                throw new RuntimeException(\n+                        \"[SEED \" + seed + \"]: Incorrect assign for \" + field);\n+            }\n+            a.conditionalSet(b, 1); \/\/ Assign\n+            if (!Arrays.equals(a.getLimbs(), b.getLimbs())) {\n+                throw new RuntimeException(\n+                        \"[SEED \" + seed + \"]: Incorrect assign for \" + field);\n+            }\n@@ -81,0 +91,2 @@\n+        System.out.println(\"Test Success\");\n+    }\n","filename":"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialTest.java","additions":47,"deletions":35,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -34,2 +34,4 @@\n- * @modules java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions  -XX:-UseIntPolyIntrinsics MontgomeryPolynomialFuzzTest\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics\n+ *      MontgomeryPolynomialFuzzTest\n@@ -42,2 +44,4 @@\n- * @modules java.base\/sun.security.util java.base\/sun.security.util.math java.base\/sun.security.util.math.intpoly\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions  -XX:+UseIntPolyIntrinsics MontgomeryPolynomialFuzzTest\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseIntPolyIntrinsics\n+ *      MontgomeryPolynomialFuzzTest\n@@ -50,7 +54,5 @@\n-        public static void main(String[] args) throws Exception {\n-                \/\/Note: it might be useful to increase this number during development of new Poly1305 intrinsics\n-                final int repeat = 1000000;\n-                for (int i = 0; i < repeat; i++) {\n-                        run();\n-                }\n-                System.out.println(\"Fuzz Success\");\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Note: it might be useful to increase this number during development\n+        final int repeat = 1000000;\n+        for (int i = 0; i < repeat; i++) {\n+            run();\n@@ -58,0 +60,2 @@\n+        System.out.println(\"Fuzz Success\");\n+    }\n@@ -59,4 +63,4 @@\n-        private static void check(BigInteger reference, ImmutableIntegerModuloP testValue, long seed) {\n-                if (!reference.equals(testValue.asBigInteger())) {\n-                        throw new RuntimeException(\"SEED: \"+seed);\n-                }\n+    private static void check(BigInteger reference,\n+            ImmutableIntegerModuloP testValue, long seed) {\n+        if (!reference.equals(testValue.asBigInteger())) {\n+            throw new RuntimeException(\"SEED: \" + seed);\n@@ -64,0 +68,1 @@\n+    }\n@@ -65,4 +70,4 @@\n-        public static void run() throws Exception {\n-                Random rnd = new Random();\n-                long seed = rnd.nextLong();\n-                rnd.setSeed(seed);\n+    public static void run() throws Exception {\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n@@ -70,5 +75,5 @@\n-                IntegerMontgomeryFieldModuloP montField = MontgomeryIntegerPolynomialP256.ONE;\n-                BigInteger P = MontgomeryIntegerPolynomialP256.ONE.MODULUS;\n-                BigInteger r = BigInteger.ONE.shiftLeft(260).mod(P);\n-                BigInteger rInv = r.modInverse(P);\n-                BigInteger aRef = (new BigInteger(P.bitLength(), rnd)).mod(P);\n+        IntegerMontgomeryFieldModuloP montField = MontgomeryIntegerPolynomialP256.ONE;\n+        BigInteger P = MontgomeryIntegerPolynomialP256.ONE.MODULUS;\n+        BigInteger r = BigInteger.ONE.shiftLeft(260).mod(P);\n+        BigInteger rInv = r.modInverse(P);\n+        BigInteger aRef = (new BigInteger(P.bitLength(), rnd)).mod(P);\n@@ -76,4 +81,4 @@\n-                \/\/ Test conversion to montgomery domain\n-                ImmutableIntegerModuloP a = montField.getElement(aRef);\n-                aRef = aRef.multiply(r).mod(P);\n-                check(aRef, a, seed);\n+        \/\/ Test conversion to montgomery domain\n+        ImmutableIntegerModuloP a = montField.getElement(aRef);\n+        aRef = aRef.multiply(r).mod(P);\n+        check(aRef, a, seed);\n@@ -81,5 +86,5 @@\n-                if (rnd.nextBoolean()) {\n-                        aRef = aRef.multiply(aRef).multiply(rInv).mod(P);\n-                        a = a.multiply(a);\n-                        check(aRef, a, seed);\n-                }\n+        if (rnd.nextBoolean()) {\n+            aRef = aRef.multiply(aRef).multiply(rInv).mod(P);\n+            a = a.multiply(a);\n+            check(aRef, a, seed);\n+        }\n@@ -87,5 +92,4 @@\n-                if (rnd.nextBoolean()) {\n-                        aRef = aRef.add(aRef).mod(P);\n-                        a = a.add(a);\n-                        check(aRef, a, seed);\n-                }\n+        if (rnd.nextBoolean()) {\n+            aRef = aRef.add(aRef).mod(P);\n+            a = a.add(a);\n+            check(aRef, a, seed);\n@@ -93,0 +97,1 @@\n+    }\n","filename":"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/MontgomeryPolynomialFuzzTest.java","additions":43,"deletions":38,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-    final BigInteger refx = new BigInteger(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16);\n+    final BigInteger refx =\n+        new BigInteger(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16);\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/PolynomialP256Bench.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}