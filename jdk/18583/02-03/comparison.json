{"files":[{"patch":"@@ -372,1 +372,1 @@\n-  \/\/ NOTE!! Allowed to branch on number of limbs;\n+  \/\/ NOTE! Crypto code cannot branch on user input. However; allowed to branch on number of limbs; \n@@ -386,2 +386,1 @@\n-  \/\/ Default copy loop\n-  __ bind(L_DefaultLoop);\n+  \/\/ Default copy loop (UNLIKELY)\n@@ -389,1 +388,2 @@\n-  __ jcc(Assembler::less, L_Done);\n+  __ jcc(Assembler::lessEqual, L_Done);\n+  __ bind(L_DefaultLoop);\n@@ -391,1 +391,1 @@\n-  __ subl(length, 16);\n+  __ subl(length, 1);\n@@ -394,1 +394,3 @@\n-  __ jmp(L_DefaultLoop);\n+  __ cmpl(length, 0);\n+  __ jcc(Assembler::greater, L_DefaultLoop);\n+  __ jmp(L_Done);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -205,15 +205,1 @@\n-        \/\/ Route to Basepoint and\/or Montgomery pointMultiply as appropriate\n-\n-        ECPoint ecPoint = affineP.toECPoint();\n-        PointMultiplier multiplier = null;\n-        if (!(b.getField() instanceof IntegerMontgomeryFieldModuloP)) {\n-            multiplier = new DefaultMultiplier(this, affineP);\n-        } else if (ecPoint.equals(Secp256R1GeneratorMontgomeryMultiplier.generator)) {\n-            \/\/ Lazy class loading upon function call (large static constant table)\n-            multiplier = Secp256R1GeneratorMontgomeryMultiplier.multiplier;\n-        } else {\n-            \/\/ affineP is in residue domain, use ecPoint to get domain conversion\n-            multiplier = new DefaultMontgomeryMultiplier(this, ecPoint);\n-        }\n-\n-        return multiplier.pointMultiply(s);\n+        return multiply(affineP.toECPoint(), s);\n@@ -222,0 +208,8 @@\n+    \/**\n+     * Multiply an affine ecpoint point by a scalar and return the result as a mutable\n+     * point.\n+     *\n+     * @param affineP the point\n+     * @param s the scalar as a little-endian array\n+     * @return the product\n+     *\/\n@@ -288,2 +282,9 @@\n-    \/*\n-     * public Point addition. Used by ECDSAOperations\n+    \/**\n+     * Adds second Mutable (Projective) point to first.\n+     * \n+     * Used by ECDSAOperations. This method constructs new temporaries each time\n+     * it is called. For better efficiency, the (private) method that reuses temporaries\n+     * should be used if more than one sum will be computed.\n+     * \n+     * @param p first point and result\n+     * @param p2 second point to add\n@@ -467,1 +468,0 @@\n-        private final AffinePoint affineP;\n@@ -473,1 +473,0 @@\n-            this.affineP = affineP;\n@@ -558,0 +557,2 @@\n+        private final ProjectivePoint.Immutable[][] points;\n+        private final BigInteger[] base;\n@@ -592,2 +593,0 @@\n-        private final ProjectivePoint.Immutable[][] points;\n-\n@@ -668,1 +667,0 @@\n-        private final BigInteger[] base;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"}]}