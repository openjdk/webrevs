{"files":[{"patch":"@@ -528,0 +528,27 @@\n+static Symbol** allocate_symbol_array(bool c_heap, int length, Thread* thread) {\n+  return c_heap ?\n+           NEW_C_HEAP_ARRAY(Symbol*, length, mtTracing) :\n+           NEW_RESOURCE_ARRAY_IN_THREAD(thread, Symbol*, length);\n+}\n+\n+Symbol** JfrJavaSupport::symbol_array(jobjectArray string_array, JavaThread* thread, intptr_t* result_array_size, bool c_heap \/* false *\/) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));\n+  assert(string_array != nullptr, \"invariant\");\n+  assert(result_array_size != nullptr, \"invariant\");\n+  objArrayOop arrayOop = objArrayOop(resolve_non_null(string_array));\n+  const int length = arrayOop->length();\n+  *result_array_size = length;\n+  Symbol** result_array = allocate_symbol_array(c_heap, length, thread);\n+  assert(result_array != nullptr, \"invariant\");\n+  for (int i = 0; i < length; i++) {\n+    oop object = arrayOop->obj_at(i);\n+    Symbol* symbol = nullptr;\n+    if (object != nullptr) {\n+      const char* text = c_str(arrayOop->obj_at(i), thread, c_heap);\n+      symbol = SymbolTable::new_symbol(text);\n+    }\n+    result_array[i] = symbol;\n+  }\n+  return result_array;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+  static Symbol** symbol_array(jobjectArray string_array, JavaThread* thread, intptr_t* result_size, bool c_heap = false);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilter.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.hpp\"\n@@ -242,2 +244,2 @@\n-JVM_ENTRY_NO_ENV(jlong, jfr_stacktrace_id(JNIEnv* env, jclass jvm, jint skip))\n-  return JfrStackTraceRepository::record(thread, skip);\n+JVM_ENTRY_NO_ENV(jlong, jfr_stacktrace_id(JNIEnv* env, jclass jvm, jint skip, jlong stack_filter_id))\n+  return JfrStackTraceRepository::record(thread, skip, stack_filter_id);\n@@ -400,0 +402,8 @@\n+\n+JVM_ENTRY_NO_ENV(jlong, jfr_register_stack_filter(JNIEnv* env,  jclass jvm, jobjectArray classes, jobjectArray methods))\n+  return JfrStackFilterRegistry::add(classes, methods, thread);\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(void, jfr_unregister_stack_filter(JNIEnv* env,  jclass jvm, jlong id))\n+  JfrStackFilterRegistry::remove(id);\n+JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-jlong JNICALL jfr_stacktrace_id(JNIEnv* env, jclass jvm, jint skip);\n+jlong JNICALL jfr_stacktrace_id(JNIEnv* env, jclass jvm, jint skip, jlong stack_filter_id);\n@@ -162,0 +162,4 @@\n+jlong JNICALL jfr_register_stack_filter(JNIEnv* env, jobject classes, jobject methods);\n+\n+jlong JNICALL jfr_unregister_stack_filter(JNIEnv* env, jlong start_filter_id);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-      (char*)\"getStackTraceId\", (char*)\"(I)J\", (void*)jfr_stacktrace_id,\n+      (char*)\"getStackTraceId\", (char*)\"(IJ)J\", (void*)jfr_stacktrace_id,\n@@ -100,1 +100,3 @@\n-      (char*)\"emitDataLoss\", (char*)\"(J)V\", (void*)jfr_emit_data_loss\n+      (char*)\"emitDataLoss\", (char*)\"(J)V\", (void*)jfr_emit_data_loss,\n+      (char*)\"registerStackFilter\", (char*)\"([Ljava\/lang\/String;[Ljava\/lang\/String;)J\", (void*)jfr_register_stack_filter,\n+      (char*)\"unregisterStackFilter\", (char*)\"(J)V\", (void*)jfr_unregister_stack_filter\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilter.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+JfrStackFilter::JfrStackFilter(Symbol** class_names, Symbol** method_names, size_t count)\n+  : _count(count),\n+    _class_names(class_names),\n+    _method_names(method_names) {\n+  assert(_class_names != nullptr, \"invariant\");\n+  assert(_method_names != nullptr, \"invariant\");\n+}\n+\n+bool JfrStackFilter::match(const Method* method) const {\n+  assert(method != nullptr, \"Invariant\");\n+  const Symbol* const method_name = method->name();\n+  const Symbol* const klass_name = method->klass_name();\n+  for (size_t i = 0; i < _count; i++) {\n+    const Symbol* m = _method_names[i];\n+    if (m == nullptr || m == method_name) {\n+      const Symbol* c = _class_names[i];\n+      if (c == nullptr || c == klass_name) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+JfrStackFilter::~JfrStackFilter() {\n+  for (size_t i = 0; i < _count; i++) {\n+    Symbol::maybe_decrement_refcount(_method_names[i]);\n+    Symbol::maybe_decrement_refcount(_class_names[i]);\n+  }\n+  FREE_C_HEAP_ARRAY(Symbol*, _method_names);\n+  FREE_C_HEAP_ARRAY(Symbol*, _class_names);\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilter.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKFILTER_HPP\n+#define SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKFILTER_HPP\n+\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+\n+class Mathod;\n+class Symbol;\n+\n+class JfrStackFilter : public JfrCHeapObj {\n+ private:\n+  size_t _count;\n+  Symbol** _class_names;\n+  Symbol** _method_names;\n+\n+ public:\n+  JfrStackFilter(Symbol** class_names, Symbol** method_names, size_t count);\n+  ~JfrStackFilter();\n+  bool match(const Method* method) const;\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKFILTER_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilter.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilter.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+static const intptr_t STACK_FILTER_ELEMENTS_SIZE = 4096;\n+static const intptr_t STACK_FILTER_ERROR_CODE = -1;\n+static const JfrStackFilter* _elements[STACK_FILTER_ELEMENTS_SIZE];\n+static intptr_t _free_list[STACK_FILTER_ELEMENTS_SIZE];\n+static intptr_t _index = 0;\n+static intptr_t _free_list_index = 0;\n+\n+int64_t JfrStackFilterRegistry::add(jobjectArray classes, jobjectArray methods, JavaThread* jt) {\n+  intptr_t c_size = 0;\n+  Symbol** class_names = JfrJavaSupport::symbol_array(classes, jt, &c_size, true);\n+  assert(class_names != nullptr, \"invariant\");\n+  intptr_t m_size = 0;\n+  Symbol** method_names = JfrJavaSupport::symbol_array(methods, jt, &m_size, true);\n+  assert(method_names != nullptr, \"invariant\");\n+  if (c_size != m_size) {\n+    FREE_C_HEAP_ARRAY(Symbol*, class_names);\n+    FREE_C_HEAP_ARRAY(Symbol*, method_names);\n+    JfrJavaSupport::throw_internal_error(\"Method array size doesn't match class array size\", jt);\n+    return STACK_FILTER_ERROR_CODE;\n+  }\n+  assert(c_size >= 0, \"invariant\");\n+  const JfrStackFilter* filter = new JfrStackFilter(class_names, method_names, static_cast<size_t>(c_size));\n+  return JfrStackFilterRegistry::add(filter);\n+}\n+\n+#ifdef ASSERT\n+static bool range_check(int64_t idx) {\n+  return idx < STACK_FILTER_ELEMENTS_SIZE && idx >= 0;\n+}\n+#endif\n+\n+int64_t JfrStackFilterRegistry::add(const JfrStackFilter* filter) {\n+  if (_free_list_index > 0) {\n+    assert(range_check(_free_list_index), \"invariant\");\n+    const intptr_t free_index = _free_list[_free_list_index - 1];\n+    _elements[free_index] = filter;\n+    _free_list_index--;\n+    return free_index;\n+  }\n+  if (_index >= STACK_FILTER_ELEMENTS_SIZE - 1) {\n+    log_warning(jfr)(\"Maximum number of @StackFrame in use has been reached.\");\n+    return STACK_FILTER_ERROR_CODE;\n+  }\n+  assert(range_check(_index), \"invariant\");\n+  _elements[_index] = filter;\n+  return _index++;\n+}\n+\n+const JfrStackFilter* JfrStackFilterRegistry::lookup(int64_t id) {\n+  if (id < 0) {\n+    return nullptr;\n+  }\n+  assert(range_check(id), \"invariant\");\n+  return _elements[id];\n+}\n+\n+void JfrStackFilterRegistry::remove(int64_t index) {\n+  assert(range_check(index), \"invariant\");\n+  delete _elements[index];\n+  if (_free_list_index < STACK_FILTER_ELEMENTS_SIZE - 1) {\n+    assert(range_check(_free_list_index), \"invariant\");\n+    _free_list[_free_list_index++] = index;\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.cpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STACKTRACE_JFRSTCKFILTERREGISTRY_HPP\n+#define SHARE_JFR_RECORDER_STACKTRACE_JFRSTCKFILTERREGISTRY_HPP\n+\n+#include \"jni.h\"\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+\n+class JavaThread;\n+class JfrStackFilter;\n+\n+class JfrStackFilterRegistry : AllStatic {\n+ private:\n+  static int64_t add(const JfrStackFilter* frame);\n+ public:\n+  static int64_t add(jobjectArray classes, jobjectArray methods, JavaThread* jt);\n+  static void remove(int64_t id);\n+  static const JfrStackFilter* lookup(int64_t id);\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STACKTRACE_JFRSTCKFILTERREGISTRY_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+#include \"jfrStackFilter.hpp\"\n+#include \"jfrStackFilterRegistry.hpp\"\n@@ -287,1 +289,1 @@\n-bool JfrStackTrace::record(JavaThread* jt, const frame& frame, int skip) {\n+bool JfrStackTrace::record(JavaThread* jt, const frame& frame, int skip, int64_t stack_filter_id) {\n@@ -305,0 +307,1 @@\n+  const JfrStackFilter* stack_filter = JfrStackFilterRegistry::lookup(stack_filter_id);\n@@ -312,0 +315,6 @@\n+    if (stack_filter != nullptr) {\n+      if (stack_filter->match(method)) {\n+        vfs.next_vframe();\n+        continue;\n+      }\n+    }\n@@ -338,1 +347,1 @@\n-bool JfrStackTrace::record(JavaThread* current_thread, int skip) {\n+bool JfrStackTrace::record(JavaThread* current_thread, int skip, int64_t stack_filter_id) {\n@@ -344,1 +353,1 @@\n-  return record(current_thread, current_thread->last_frame(), skip);\n+  return record(current_thread, current_thread->last_frame(), skip, stack_filter_id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -96,2 +96,2 @@\n-  bool record(JavaThread* current_thread, int skip);\n-  bool record(JavaThread* current_thread, const frame& frame, int skip);\n+  bool record(JavaThread* current_thread, int skip, int64_t stack_frame_id);\n+  bool record(JavaThread* current_thread, const frame& frame, int skip, int64_t stack_frame_id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-traceid JfrStackTraceRepository::record(Thread* current_thread, int skip \/* 0 *\/) {\n+traceid JfrStackTraceRepository::record(Thread* current_thread, int skip \/* 0 *\/, int64_t stack_filter_id \/* -1 *\/) {\n@@ -166,1 +166,1 @@\n-  return instance().record(JavaThread::cast(current_thread), skip, frames, tl->stackdepth());\n+  return instance().record(JavaThread::cast(current_thread), skip, stack_filter_id, frames, tl->stackdepth());\n@@ -169,1 +169,1 @@\n-traceid JfrStackTraceRepository::record(JavaThread* current_thread, int skip, JfrStackFrame *frames, u4 max_frames) {\n+traceid JfrStackTraceRepository::record(JavaThread* current_thread, int skip, int64_t stack_filter_id, JfrStackFrame *frames, u4 max_frames) {\n@@ -171,1 +171,1 @@\n-  return stacktrace.record(current_thread, skip) ? add(instance(), stacktrace) : 0;\n+  return stacktrace.record(current_thread, skip, stack_filter_id) ? add(instance(), stacktrace) : 0;\n@@ -173,0 +173,1 @@\n+\n@@ -194,1 +195,1 @@\n-  stacktrace.record(current_thread, skip);\n+  stacktrace.record(current_thread, skip, -1);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  traceid record(JavaThread* current_thread, int skip, JfrStackFrame* frames, u4 max_frames);\n+  traceid record(JavaThread* current_thread, int skip, int64_t stack_filter_id, JfrStackFrame* frames, u4 max_frames);\n@@ -73,1 +73,1 @@\n-  static traceid record(Thread* current_thread, int skip = 0);\n+  static traceid record(Thread* current_thread, int skip = 0, int64_t stack_filter_id = -1);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+@StackFilter({\"java.lang.ProcessBuilder\", \"java.lang.Runtime::exec\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ProcessStartEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+@StackFilter({\"java.security.Security::setProperty\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SecurityPropertyModificationEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+@StackFilter({\"java.security.Provider::getService\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SecurityProviderServiceEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+package jdk.jfr.events;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import jdk.jfr.MetadataDefinition;\n+\n+\/**\n+* Event annotation, specifies method names or classes to exclude in a stack\n+* trace.\n+* <p>\n+* The following example illustrates how the {@code StackFilter} annotation can\n+* be used to remove the {@code Logger::log} method in a stack trace:\n+*\n+* {@snippet :\n+* package com.example;\n+*\n+* @Name(\"example.LogMessage\")\n+* @Label(\"Log Message\")\n+* @StackFilter(\"com.example.Logger::log\")\n+* class LogMessage extends Event {\n+*     @Label(\"Message\")\n+*     String message;\n+* }\n+*\n+* public class Logger {\n+*\n+*     public static void log(String message) {\n+*         System.out.print(Instant.now() + \" : \" + message);\n+*         LogMessage event = new LogMessage();\n+*         event.message = message;\n+*         event.commit();\n+*     }\n+* }\n+* }\n+*\n+* @since 22\n+*\/\n+@Target({ ElementType.TYPE })\n+@Inherited\n+@Retention(RetentionPolicy.RUNTIME)\n+@MetadataDefinition\n+public @interface StackFilter {\n+    \/**\n+     * The methods or classes that should not be part of an event stack trace.\n+     * <p>\n+     * A filter is formed by using the fully qualified class name concatenated with\n+     * the method name using {@code \"::\"} as separator, for example\n+     * {@code \"java.lang.String::toString\"}\n+     * <p>\n+     * If only the name of a class is specified, for example {@code\n+     * \"java.lang.String\"}, all methods in that class are filtered out.\n+     * <p>\n+     * Methods can't be qualified using method parameters or return types.\n+     * <p>\n+     * Instance methods belonging to an interface can't be filtered out.\n+     * <p>\n+     * Wilcards are not permitted.\n+     *\n+     * @return the method names, not {@code null}\n+     *\/\n+     String[] value();\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/StackFilter.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+@StackFilter(\"sun.security.ssl.Finished::recordEvent\")\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/TLSHandshakeEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+@StackFilter({\"java.lang.Thread::afterSleep\",\n+              \"java.lang.Thread::sleepNanos\",\n+              \"java.lang.Thread::sleep\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ThreadSleepEvent.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.module.Checks;\n@@ -47,0 +48,2 @@\n+import jdk.jfr.events.StackFilter;\n+import jdk.jfr.internal.JVM;\n@@ -68,0 +71,1 @@\n+    private static final long STACK_FILTER_ID = Type.getTypeId(StackFilter.class);\n@@ -92,0 +96,1 @@\n+        addStackFilters(eventType);\n@@ -99,0 +104,1 @@\n+        remove(eventType, aes, StackFilter.class);\n@@ -104,0 +110,72 @@\n+    private void addStackFilters(PlatformEventType eventType) {\n+        String[] filter = getStackFilter(eventType);\n+        if (filter != null) {\n+            int size = filter.length;\n+            List<String> types = new ArrayList<>(size);\n+            List<String> methods = new ArrayList<>(size);\n+            for (String frame : filter) {\n+                int index = frame.indexOf(\"::\");\n+                String clazz = null;\n+                String method = null;\n+                boolean valid = false;\n+                if (index != -1) {\n+                    clazz = frame.substring(0, index);\n+                    method = frame.substring(index + 2);\n+                    if (clazz.isEmpty()) {\n+                        clazz = null;\n+                        valid = isValidMethod(method);\n+                    } else {\n+                        valid = isValidType(clazz) && isValidMethod(method);\n+                    }\n+                } else {\n+                    clazz = frame;\n+                    valid = isValidType(frame);\n+                }\n+                if (valid) {\n+                    if (clazz == null) {\n+                        types.add(null);\n+                    } else {\n+                        types.add(clazz.replace(\".\", \"\/\"));\n+                    }\n+                    \/\/ If unqualified class name equals method name, it's a constructor\n+                    String className = clazz.substring(clazz.lastIndexOf(\".\") + 1);\n+                    if (className.equals(method)) {\n+                        method = \"<init>\";\n+                    }\n+                    methods.add(method);\n+                } else {\n+                    Logger.log(LogTag.JFR, LogLevel.WARN, \"@StackFrameFilter element ignored, not a valid Java identifier.\");\n+                }\n+            }\n+            if (!types.isEmpty()) {\n+                String[] typeArray = types.toArray(new String[0]);\n+                String[] methodArray = methods.toArray(new String[0]);\n+                long id = MetadataRepository.getInstance().registerStackFilter(typeArray, methodArray);\n+                eventType.setStackFilterId(id);\n+            }\n+        }\n+    }\n+\n+    private String[] getStackFilter(PlatformEventType eventType) {\n+        for (var a : eventType.getAnnotationElements()) {\n+            if (a.getTypeId() == STACK_FILTER_ID) {\n+                return (String[])a.getValue(\"value\");\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean isValidType(String className) {\n+        if (className.length() < 1 || className.length() > 65535) {\n+            return false;\n+        }\n+        return Checks.isClassName(className);\n+    }\n+\n+    private boolean isValidMethod(String method) {\n+        if (method.length() < 1 || method.length() > 65535) {\n+            return false;\n+        }\n+        return Checks.isJavaIdentifier(method);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -152,1 +152,6 @@\n-     * @param skipCount number of frames to skip\n+     * @param skipCount number of frames to skip, or 0 if no frames should be\n+     *                  skipped\n+     *\n+     * @param ID        ID of the filter that should be used, or -1 if no filter should\n+     *                  be used\n+     *\n@@ -155,1 +160,1 @@\n-    public static native long getStackTraceId(int skipCount);\n+    public static native long getStackTraceId(int skipCount, long stackFilerId);\n@@ -631,0 +636,26 @@\n+\n+    \/**\n+     * Registers stack filters that should be used with getStackTrace(int, long)\n+     * <p>\n+     * Method name at an array index is for class at the same array index.\n+     * <p>\n+     * This method should be called holding the MetadataRepository lock and before\n+     * bytecode for the associated event class has been added.\n+     *\n+     * @param classes, name of classes, for example {\"java\/lang\/String\"}, not\n+     *                 {@code null}\n+     * @param methods, name of method, for example {\"toString\"}, not {@code null}\n+     *\n+     * @return an ID that can be used to unregister the start frames, or -1 if it could not be registered\n+     *\/\n+    public static native long registerStackFilter(String[] classes, String[] methods);\n+\n+    \/**\n+     * Unregisters a set of stack filters.\n+     * <p>\n+     * This method should be called holding the MetadataRepository lock and after\n+     * the associated event class has been unloaded.\n+     *\n+     * @param stackFilterId the stack filter ID to unregister\n+     *\/\n+    public static native void unregisterStackFilter(long stackFilterId);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -324,0 +324,3 @@\n+                            if (pe.hasStackFilters()) {\n+                                JVM.unregisterStackFilter(pe.getStackFilterId());\n+                            }\n@@ -358,0 +361,4 @@\n+\n+    public synchronized long registerStackFilter(String[] typeArray, String[] methodArray) {\n+        return JVM.registerStackFilter(typeArray, methodArray);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+    private long startFilterId = -1;\n@@ -342,0 +343,12 @@\n+\n+    public void setStackFilterId(long id) {\n+        startFilterId = id;\n+    }\n+\n+    public boolean hasStackFilters() {\n+        return startFilterId >= 0;\n+    }\n+\n+    public long getStackFilterId() {\n+        return startFilterId;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.internal.module.Modules;\n@@ -168,1 +169,0 @@\n-\n@@ -181,0 +181,9 @@\n+        \/\/ Add export from JDK proxy module\n+        if (annotation.getClass().getClassLoader() == null) {\n+            if (annotation.getClass().getName().contains(\"Proxy\")) {\n+                Module proxyModule = annotation.getClass().getModule();\n+                String proxyPackage = annotation.getClass().getPackageName();\n+                Module jfrModule = TypeLibrary.class.getModule();\n+                Modules.addExports(proxyModule, proxyPackage, jfrModule);\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-            putLong(JVM.getStackTraceId(eventType.getStackTraceOffset()));\n+            putLong(JVM.getStackTraceId(eventType.getStackTraceOffset(), eventType.getStackFilterId()));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.metadata.annotations;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.api.metadata.annotations.UnloadableClass;\n+import jdk.jfr.Event;\n+import jdk.jfr.AnnotationElement;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.events.StackFilter;\n+import jdk.jfr.Recording;\n+import jdk.jfr.Name;\n+import jdk.jfr.EventType;\n+import jdk.jfr.EventFactory;\n+import jdk.jfr.FlightRecorder;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.TestClassLoader;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @modules jdk.jfr\/jdk.jfr.events\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -Xlog:jfr=warning jdk.jfr.api.metadata.annotations.TestStackFilter\n+ *\/\n+public class TestStackFilter {\n+    private static class Quux {\n+        private static void one() throws Exception {\n+            two();\n+        }\n+        private static void two() throws Exception {\n+            three();\n+        }\n+\n+        private static void three() throws Exception {\n+            TestStackFilter.qux();\n+        }\n+    }\n+    private final static String PACKAGE = \"jdk.jfr.api.metadata.annotations.TestStackFilter\";\n+    private final static String M1 = PACKAGE + \"::foo\";\n+    private final static String M2 = PACKAGE + \"::baz\";\n+    private final static String C1 = PACKAGE + \"$Quux\";\n+\n+    @StackFilter({ M1, M2 })\n+    @Name(\"MethodFilter\")\n+    public static class MethodFilterEvent extends Event {\n+    }\n+\n+    @StackFilter(C1)\n+    @Name(\"ClassFilter\")\n+    public static class ClassFilterEvent extends Event {\n+    }\n+\n+    @StackFilter({})\n+    @Name(\"Empty\")\n+    public static class EmptyEvent extends Event {\n+    }\n+\n+    @StackFilter(PACKAGE + \"::testUnload\")\n+    @Name(\"Unload\")\n+    public static class UnloadEvent extends Event {\n+    }\n+\n+    @StackFilter(PACKAGE + \"::emitCommitter\")\n+    @Name(\"Reuse\")\n+    public static class ReuseEvent extends Event {\n+    }\n+\n+    @StackFilter(PACKAGE + \"::emitCommitter\")\n+    @Name(\"Max\")\n+    public static class ExceedMaxEvent extends Event {\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testMethodFilter();\n+        testClassFilter();\n+        testUnload();\n+        testReuse();\n+        testExceedMax();\n+    }\n+\n+    \/\/ Use more stack filters than there is capacity for\n+    private static void testExceedMax() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            \/\/ Maximum number of simultaneous event classes that can\n+            \/\/ use a filter is 4096. Additional filters will be ignored.\n+            var classes = new ArrayList<>();\n+            for (int i = 0; i < 4200; i++) {\n+                Class<ExceedMaxEvent> eventClass = UnloadableClass.load(ExceedMaxEvent.class);\n+                emitCommitter(eventClass);\n+                classes.add(eventClass);\n+            }\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            if (events.size() != 4200) {\n+                throw new Exception(\"Expected 4200 'Max' events\");\n+            }\n+            int emitCommitterCount = 0;\n+            int textExceedMaxCount = 0;\n+            for (RecordedEvent event : events) {\n+                RecordedStackTrace s = event.getStackTrace();\n+                if (s == null) {\n+                    System.out.println(event);\n+                    throw new Exception(\"Expected stack trace for 'Max' event\");\n+                }\n+\n+                RecordedFrame f = s.getFrames().get(0);\n+                if (!f.isJavaFrame()) {\n+                    throw new Exception(\"Expected Java frame for 'Max' event\");\n+                }\n+                String methodName = f.getMethod().getName();\n+                switch (methodName) {\n+                    case \"emitCommitter\":\n+                        emitCommitterCount++;\n+                        break;\n+                    case \"testExceedMax\":\n+                        textExceedMaxCount++;\n+                        break;\n+                    default:\n+                        System.out.println(event);\n+                        throw new Exception(\"Unexpected top frame \" + methodName + \" for 'Max' event\");\n+                }\n+            }\n+            \/\/ Can't match exact because filters from previous tests may be in use\n+            \/\/ or because filters added by JDK events filters\n+            if (emitCommitterCount == 0) {\n+                throw new Exception(\"Expected at least some events with emitCommitter() as top frame, found \" + emitCommitterCount);\n+            }\n+            if (textExceedMaxCount < 500) {\n+                throw new Exception(\"Expected at least 500 events with testExceedMax() as top frame, found \" + textExceedMaxCount);\n+            }\n+        }\n+    }\n+\n+    \/\/ Tests that event classes with @StackFilter that are unloaded\n+    \/\/ reuses the memory slot used to bookkeep things in native\n+    private static void testReuse() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"Reuse\");\n+            r.start();\n+            for (int i = 0; i < 48; i++) {\n+                Class<ReuseEvent> eventClass = UnloadableClass.load(ReuseEvent.class);\n+                emitCommitter(eventClass);\n+                if (i % 16 == 0) {\n+                    System.gc();\n+                    rotate();\n+                }\n+            }\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            if (events.size() != 48) {\n+                throw new Exception(\"Expected 48 'Reuse' events\");\n+            }\n+            for (RecordedEvent event : events) {\n+                assertTopFrame(event, \"testReuse\");\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ This test registers a stack filter, emits an event with the filter\n+    \/\/ and unregisters it. While this is happening, another\n+    \/\/ filter is being used.\n+    private static void testUnload() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            Class<UnloadEvent> eventClass = UnloadableClass.load(UnloadEvent.class);\n+            emitCommitter(eventClass);\n+            EventType type = getType(\"Unload\");\n+            if (type == null) {\n+                throw new Exception(\"Expected event type named 'Unload'\");\n+            }\n+            eventClass = null;\n+            while (true) {\n+                System.gc();\n+                rotate();\n+                type = getType(\"Unload\");\n+                if (type == null) {\n+                    return;\n+                }\n+                System.out.println(\"Unload class not unloaded. Retrying ...\");\n+            }\n+        }\n+    }\n+\n+    private static void testMethodFilter() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(MethodFilterEvent.class);\n+            r.start();\n+            foo();\n+            bar();\n+            empty();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            if (events.isEmpty()) {\n+                throw new Exception(\"Excected events\");\n+            }\n+\n+            RecordedEvent e1 = events.get(0);\n+            assertTopFrame(e1, \"testMethodFilter\");\n+\n+            RecordedEvent e2 = events.get(1);\n+            assertTopFrame(e2, \"bar\");\n+\n+            RecordedEvent e3 = events.get(2);\n+            assertTopFrame(e3, \"empty\");\n+        }\n+    }\n+\n+    private static void testClassFilter() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(MethodFilterEvent.class);\n+            r.start();\n+            Quux.one();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            if (events.isEmpty()) {\n+                throw new Exception(\"Excected events\");\n+            }\n+\n+            RecordedEvent e = events.get(0);\n+            assertTopFrame(e, \"qux\");\n+            for (RecordedFrame f : e.getStackTrace().getFrames()) {\n+                if (f.getMethod().getType().getName().contains(\"Quux\")) {\n+                    System.out.println(e);\n+                    throw new Exception(\"Didn't expect Quux class in stack trace\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void empty() {\n+        EmptyEvent event = new EmptyEvent();\n+        event.commit();\n+    }\n+\n+    static void foo() {\n+        baz();\n+    }\n+\n+    static void bar() {\n+        baz();\n+    }\n+\n+    static void baz() {\n+        MethodFilterEvent event = new MethodFilterEvent();\n+        event.commit();\n+    }\n+\n+    static void qux() {\n+        ClassFilterEvent event = new ClassFilterEvent();\n+        event.commit();\n+    }\n+\n+    private static void rotate() {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+        }\n+    }\n+\n+    private static EventType getType(String name) {\n+        for (EventType et : FlightRecorder.getFlightRecorder().getEventTypes()) {\n+            if (et.getName().equals(name)) {\n+                return et;\n+            }\n+\n+        }\n+        return null;\n+    }\n+\n+    private static void emitCommitter(Class<? extends Event> eventClass) throws Exception {\n+        Event event = eventClass.getConstructor().newInstance();\n+        event.commit();\n+    }\n+\n+    private static void assertTopFrame(RecordedEvent event, String methodName) throws Exception {\n+        RecordedStackTrace stackTrace = event.getStackTrace();\n+        if (stackTrace == null) {\n+            System.out.println(event);\n+            throw new Exception(\"No stack trace found when looking for top frame '\" + methodName + \"'\");\n+        }\n+        RecordedFrame frame = stackTrace.getFrames().get(0);\n+        RecordedMethod method = frame.getMethod();\n+        if (!methodName.equals(method.getName())) {\n+            System.out.println(event);\n+            throw new Exception(\"Expected top frame '\" + methodName + \"'\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/TestStackFilter.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.metadata.annotations;\n+\n+import java.io.DataInputStream;\n+import java.security.CodeSource;\n+import java.security.ProtectionDomain;\n+import java.security.cert.Certificate;\n+\n+\/* Purpose of this class is to load a specified class in its\n+ * own class loader, but delegate every other class.\n+ *\/\n+public final class UnloadableClass<T> extends ClassLoader {\n+    private final String className;\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <T> Class<T> load(Class<T> clazz) throws ClassNotFoundException {\n+        UnloadableClass cl = new UnloadableClass(clazz.getName());\n+        return cl.loadClass(cl.className);\n+    }\n+\n+    private UnloadableClass(String className) {\n+        super(\"Class loader for class \" + className, ClassLoader.getSystemClassLoader());\n+        this.className = className;\n+    }\n+\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        if (!className.equals(name)) {\n+            return super.loadClass(name);\n+        }\n+        String resourceName = name.replace('.', '\/') + \".class\";\n+        try (var is = getResourceAsStream(resourceName); var dis = new DataInputStream(is)) {\n+            int size = is.available();\n+            byte buffer[] = new byte[size];\n+            dis.readFully(buffer);\n+            CodeSource cs = new CodeSource(getResource(resourceName), (Certificate[]) null);\n+            ProtectionDomain pd = new ProtectionDomain(cs, null);\n+            return defineClass(name, buffer, 0, buffer.length, pd);\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/UnloadableClass.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-            recording.enable(EVENT_NAME);\n+            recording.enable(EVENT_NAME).withStackTrace();\n@@ -77,0 +77,1 @@\n+                Events.assertTopFrame(event, TestProcessStart.class, \"main\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/os\/TestProcessStart.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,7 +59,1 @@\n-            Thread virtualThread  = Thread.ofVirtual().start(() -> {\n-                try {\n-                    Thread.sleep(SLEEP_TIME_MS);\n-                } catch (InterruptedException ie) {\n-                    throw new RuntimeException(ie);\n-                }\n-            });\n+            Thread virtualThread = Thread.ofVirtual().start(TestThreadSleepEvent::virtualSleep);\n@@ -77,0 +71,1 @@\n+                    Events.assertTopFrame(event, TestThreadSleepEvent.class, \"main\");\n@@ -81,0 +76,1 @@\n+                    Events.assertTopFrame(event, TestThreadSleepEvent.class, \"virtualSleep\");\n@@ -87,0 +83,8 @@\n+\n+    private static void virtualSleep() {\n+        try {\n+            Thread.sleep(SLEEP_TIME_MS);\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadSleepEvent.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            recording.enable(EventNames.SecurityProperty);\n+            recording.enable(EventNames.SecurityProperty).withStackTrace();\n@@ -81,0 +81,1 @@\n+                Events.assertTopFrame(e, TestSecurityPropertyModificationEvent.class, \"main\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestSecurityPropertyModificationEvent.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-                \"SunEC\", \"Cipher\", 1, Collections.emptyList());\n+                \"SunEC\", \"Cipher\", 1, Collections.emptyList(),\n+                javax.crypto.Cipher.class.getName(), \"getInstance\");\n@@ -57,1 +58,2 @@\n-                \"SunEC\", \"Signature\", 2, List.of(\"MessageDigest\"));\n+                \"SunEC\", \"Signature\", 2, List.of(\"MessageDigest\"),\n+                \"sun.security.jca.GetInstance\", \"getService\");\n@@ -59,1 +61,2 @@\n-                \"SunEC\", \"MessageDigest\", 1, Collections.emptyList());\n+                \"SunEC\", \"MessageDigest\", 1, Collections.emptyList(),\n+                \"sun.security.jca.GetInstance\", \"getService\");\n@@ -61,1 +64,2 @@\n-                \"SunEC\", \"KeyStore\", 1, Collections.emptyList());\n+                \"SunEC\", \"KeyStore\", 1, Collections.emptyList(),\n+                \"sun.security.jca.GetInstance\", \"getService\");\n@@ -63,1 +67,2 @@\n-                \"SunEC\", \"CertPathBuilder\", 2, List.of(\"CertificateFactory\"));\n+                \"SunEC\", \"CertPathBuilder\", 2, List.of(\"CertificateFactory\"),\n+                \"sun.security.jca.GetInstance\", \"getService\");\n@@ -68,1 +73,2 @@\n-                                int expected, List<String> other) throws Exception {\n+                                int expected, List<String> other,\n+                                String clazz, String method) throws Exception {\n@@ -73,1 +79,1 @@\n-            recording.enable(EventNames.SecurityProviderService);\n+            recording.enable(EventNames.SecurityProviderService).withStackTrace();\n@@ -80,1 +86,1 @@\n-            assertEvent(events, algType, alg, p.getName(), other);\n+            assertEvent(events, algType, alg, p.getName(), other, clazz, method);\n@@ -140,1 +146,2 @@\n-            String alg, String workingProv, List<String> other) {\n+            String alg, String workingProv, List<String> other, String clazz,\n+            String method) {\n@@ -151,0 +158,2 @@\n+            System.out.println(e);\n+            Events.assertTopFrame(e, clazz, method);\n@@ -155,1 +164,0 @@\n-\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestSecurityProviderServiceEvent.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-            recording.enable(EventNames.TLSHandshake);\n+            recording.enable(EventNames.TLSHandshake).withStackTrace();\n@@ -66,0 +66,4 @@\n+                var method = e.getStackTrace().getFrames().get(0).getMethod();\n+                if (method.getName().equals(\"recordEvent\")) {\n+                    throw new Exception(\"Didn't expected recordEvent as top frame\");\n+                }\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestTLSHandshakeEvent.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        Asserts.assertEquals(JVM.getStackTraceId(Integer.MAX_VALUE), 0L, \"Insane skip level \"\n+        Asserts.assertEquals(JVM.getStackTraceId(Integer.MAX_VALUE, -1), 0L, \"Insane skip level \"\n@@ -67,1 +67,1 @@\n-        return JVM.getStackTraceId(0);\n+        return JVM.getStackTraceId(0, -1);\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetStackTraceId.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -368,0 +368,15 @@\n+    public static void assertTopFrame(RecordedEvent event, Class<?> expectedClass, String expectedMethodName) {\n+        assertTopFrame(event, expectedClass.getName(), expectedMethodName);\n+    }\n+\n+    public static void assertTopFrame(RecordedEvent event, String expectedClass, String expectedMethodName) {\n+        RecordedStackTrace stackTrace = event.getStackTrace();\n+        Asserts.assertNotNull(stackTrace, \"Missing stack trace\");\n+        RecordedFrame topFrame =  stackTrace.getFrames().get(0);\n+        if (isFrame(topFrame, expectedClass, expectedMethodName)) {\n+            return;\n+        }\n+        String expected = expectedClass + \"::\" + expectedMethodName;\n+        Asserts.fail(\"Expected top frame \" + expected + \". Found \" + topFrame);\n+    }\n+\n@@ -372,8 +387,2 @@\n-            if (frame.isJavaFrame()) {\n-                RecordedMethod method = frame.getMethod();\n-                RecordedClass type = method.getType();\n-                if (expectedClass.getName().equals(type.getName())) {\n-                    if (expectedMethodName.equals(method.getName())) {\n-                        return;\n-                    }\n-                }\n+            if (isFrame(frame, expectedClass.getName(), expectedMethodName)) {\n+                return;\n@@ -384,0 +393,13 @@\n+\n+    private static boolean isFrame(RecordedFrame frame, String expectedClass, String expectedMethodName) {\n+        if (frame.isJavaFrame()) {\n+            RecordedMethod method = frame.getMethod();\n+            RecordedClass type = method.getType();\n+            if (expectedClass.equals(type.getName())) {\n+                if (expectedMethodName.equals(method.getName())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/Events.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"}]}