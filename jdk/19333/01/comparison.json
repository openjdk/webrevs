{"files":[{"patch":"@@ -182,0 +182,10 @@\n+  \/\/ Total peak malloc\n+  size_t total_peak() const {\n+    return _all_mallocs.peak_size();\n+  }\n+\n+  \/\/ Total peak count\n+  size_t total_peak_count() const {\n+    return _all_mallocs.peak_count();\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  out->print_cr(\"       malloc: \" SIZE_FORMAT \"%s #\" SIZE_FORMAT,\n+  out->print_cr(\"       malloc: \" SIZE_FORMAT \"%s #\" SIZE_FORMAT \", peak=\" SIZE_FORMAT \"%s #\" SIZE_FORMAT,\n@@ -170,1 +170,3 @@\n-                _malloc_snapshot->total_count());\n+                _malloc_snapshot->total_count(),\n+                amount_in_current_scale(_malloc_snapshot->total_peak()),\n+                current_scale(), _malloc_snapshot->total_peak_count());\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332122\n+ * @summary Test to verify correctness of peak malloc tracking\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=summary -Xms32m -Xmx32m -Xint PeakMallocTest\n+ *\n+ *\/\n+\n+\/\/ Note we run the test with -Xint to keep compilers from running and reduce malloc noise.\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class PeakMallocTest {\n+\n+    private static WhiteBox wb = WhiteBox.getWhiteBox();\n+    private static final double FUDGE_FACTOR = 0.2;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Measure early malloc total and peak\n+        OutputAnalyzer output = NMTTestUtils.startJcmdVMNativeMemory(\"scale=1\");\n+        long earlyTotal = getMallocTotal(output);\n+        long earlyPeak = getMallocPeak(output);\n+        System.out.println(\"Early malloc total: \" + earlyTotal);\n+        System.out.println(\"Early malloc peak: \" + earlyPeak);\n+\n+        \/\/ Allocate a large amount of memory and then free\n+        long allocSize = Math.max(8 * earlyPeak, 250 * 1024 * 1024); \/\/ MAX(earlyPeak * 8, 250MB)\n+        long addr = wb.NMTMalloc(allocSize);\n+        System.out.println(\"Allocation size: \" + allocSize);\n+        wb.NMTFree(addr);\n+\n+        \/\/ Measure again\n+        output = NMTTestUtils.startJcmdVMNativeMemory(\"scale=1\");\n+        long currTotal = getMallocTotal(output);\n+        long currPeak = getMallocPeak(output);\n+        System.out.println(\"Current malloc total: \" + currTotal);\n+        System.out.println(\"Current malloc peak: \" + currPeak);\n+\n+        \/\/ Verify total global malloc is similar with a fudge factor\n+        double mallocLowerBound = earlyTotal * (1 - FUDGE_FACTOR);\n+        double mallocUpperBound = earlyTotal * (1 + FUDGE_FACTOR);\n+        if (currTotal < mallocLowerBound || currTotal > mallocUpperBound) {\n+            throw new Exception(\"Global malloc measurement is incorrect. \" +\n+                    \"Expected range: [\" + mallocLowerBound + \" - \" + mallocUpperBound + \"]. \" +\n+                    \"Actual malloc total: \" + currTotal);\n+        }\n+\n+        \/\/ Verify global malloc peak reflects large allocation with a fudge factor\n+        long peakDiff = currPeak - earlyPeak;\n+        double peakLowerBound = allocSize * (1 - FUDGE_FACTOR);\n+        double peakUpperBound = allocSize * (1 + FUDGE_FACTOR);\n+        if (peakDiff < peakLowerBound || peakDiff > peakUpperBound) {\n+            throw new Exception(\"Global malloc peak measurement is incorrect. \" +\n+                    \"Expected peak diff range: [\" + peakLowerBound + \" - \" + peakUpperBound + \"]. \" +\n+                    \"Actual peak diff: \" + peakDiff);\n+        }\n+    }\n+\n+    private static long getMallocPeak(OutputAnalyzer output) {\n+        \/\/ First match should correspond to global malloc peak\n+        String global = output.firstMatch(\"peak=\\\\d*\");\n+        return Long.parseLong(global.substring(global.indexOf(\"=\") + 1));\n+    }\n+\n+    private static long getMallocTotal(OutputAnalyzer output) {\n+        \/\/ First match should correspond to global malloc total\n+        String global = output.firstMatch(\"malloc: \\\\d*\");\n+        return Long.parseLong(global.substring(global.indexOf(\" \") + 1));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/PeakMallocTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"}]}