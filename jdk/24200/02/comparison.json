{"files":[{"patch":"@@ -2256,0 +2256,10 @@\n+  if (obj->is_array()) {\n+    \/\/ Disallow reading after the last element of an array\n+    size_t array_length = arrayOop(obj())->length();\n+    int lh = obj->klass()->layout_helper();\n+    size_t size_in_bytes = array_length << Klass::layout_helper_log2_element_size(lh);\n+    size_in_bytes += Klass::layout_helper_header_size(lh);\n+    if ((size_t) displacement + basic_type_elemsize > size_in_bytes) {\n+      JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"reading after last array element\");\n+    }\n+  }\n@@ -2261,3 +2271,0 @@\n-      if (displacement + heapOopSize > arrayOopDesc::base_offset_in_bytes(T_OBJECT) + arrayOop(obj())->length() * heapOopSize) {\n-        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"reading after last array element\");\n-      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,5 +44,1 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.*;\n@@ -141,0 +137,38 @@\n+\n+    static class ArrayConstants {\n+        static final byte[] BYTE_ARRAY_CONST = new byte[]{0};\n+        static final Object[] OBJECT_ARRAY_CONST = new Object[]{null};\n+    }\n+\n+    @Test\n+    public void readOnePastLastArrayElementTest() {\n+        for (ConstantValue cv : readConstants(ArrayConstants.class)) {\n+            if (cv.boxed != null && cv.boxed.getClass().isArray()) {\n+                JavaKind kind = metaAccess.lookupJavaType(cv.value).getComponentType().getJavaKind();\n+                long offset = metaAccess.getArrayBaseOffset(kind) + (long) metaAccess.getArrayIndexScale(kind) * Array.getLength(cv.boxed);\n+                \/\/ read array[array.length]\n+                assertThrows(IllegalArgumentException.class, () -> {\n+                    if (kind == JavaKind.Object) {\n+                        constantReflection.getMemoryAccessProvider().readObjectConstant(cv.value, offset);\n+                    } else {\n+                        constantReflection.getMemoryAccessProvider().readPrimitiveConstant(kind, cv.value, offset, kind.getBitCount());\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    static class IntArrayConstants {\n+        static final int[] INT_ARRAY_CONST = new int[]{0};\n+    }\n+\n+    @Test\n+    public void readPartiallyOutOfBoundsTest() {\n+        for (ConstantValue cv : readConstants(IntArrayConstants.class)) {\n+            JavaKind kind = metaAccess.lookupJavaType(cv.value).getComponentType().getJavaKind();\n+            long offset = metaAccess.getArrayBaseOffset(kind) + (long) metaAccess.getArrayIndexScale(kind) * (Array.getLength(cv.boxed) - 1);\n+            \/\/ read a long from array[array.length - 1], which is partially out of bounds\n+            JavaKind accessKind = JavaKind.Long;\n+            assertThrows(IllegalArgumentException.class, () -> constantReflection.getMemoryAccessProvider().readPrimitiveConstant(accessKind, cv.value, offset, accessKind.getBitCount()));\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestConstantReflectionProvider.java","additions":40,"deletions":6,"binary":false,"changes":46,"status":"modified"}]}