{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,5 +44,1 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.*;\n@@ -141,0 +137,22 @@\n+\n+    static class ArrayConstants {\n+        static final byte[] BYTE_ARRAY_CONST = new byte[]{0};\n+        static final Object[] OBJECT_ARRAY_CONST = new Object[]{null};\n+    }\n+\n+    @Test\n+    public void readAfterLastArrayElementTest() {\n+        for (ConstantValue cv : readConstants(ArrayConstants.class)) {\n+            if (cv.boxed != null && cv.boxed.getClass().isArray()) {\n+                JavaKind kind = metaAccess.lookupJavaType(cv.value).getComponentType().getJavaKind();\n+                long offset = metaAccess.getArrayBaseOffset(kind) + (long) metaAccess.getArrayIndexScale(kind) * Array.getLength(cv.boxed);\n+                assertThrows(IllegalArgumentException.class, () -> {\n+                    if (kind == JavaKind.Object) {\n+                        constantReflection.getMemoryAccessProvider().readObjectConstant(cv.value, offset);\n+                    } else {\n+                        constantReflection.getMemoryAccessProvider().readPrimitiveConstant(kind, cv.value, offset, kind.getBitCount());\n+                    }\n+                });\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestConstantReflectionProvider.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"}]}