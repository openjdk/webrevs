{"files":[{"patch":"@@ -43,0 +43,6 @@\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n@@ -132,1 +138,1 @@\n-          sudo qemu-debootstrap\n+          sudo debootstrap\n@@ -168,1 +174,1 @@\n-          ${{ inputs.extra-conf-options }} || (\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n@@ -177,1 +183,1 @@\n-          make-target: 'hotspot'\n+          make-target: 'hotspot ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-cross-compile.yml","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,0 +61,6 @@\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n@@ -126,1 +132,1 @@\n-          ${{ inputs.extra-conf-options }} || (\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n@@ -135,1 +141,1 @@\n-          make-target: '${{ inputs.make-target }}'\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-linux.yml","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,0 +48,6 @@\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n@@ -101,1 +107,1 @@\n-          ${{ inputs.extra-conf-options }} || (\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n@@ -110,1 +116,1 @@\n-          make-target: '${{ inputs.make-target }}'\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-macos.yml","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,0 +51,6 @@\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n@@ -114,1 +120,1 @@\n-          ${{ inputs.extra-conf-options }} || (\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n@@ -127,1 +133,1 @@\n-          make-target: '${{ inputs.make-target }}'\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-windows.yml","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+      configure-arguments:\n+        description: 'Additional configure arguments'\n+        required: false\n+      make-arguments:\n+        description: 'Additional make arguments'\n+        required: false\n@@ -128,0 +134,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -145,0 +153,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -158,0 +168,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -171,0 +183,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -184,0 +198,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -198,0 +214,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -210,0 +228,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -219,0 +239,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -229,0 +251,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -239,0 +263,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -251,0 +277,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n","filename":".github\/workflows\/main.yml","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.md|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,2 +5,2 @@\n-openjdk.java.net (\"OpenJDK Code\") is distributed under the terms of the GNU\n-General Public License <http:\/\/www.gnu.org\/copyleft\/gpl.html> version 2\n+openjdk.org (\"OpenJDK Code\") is distributed under the terms of the GNU\n+General Public License <https:\/\/www.gnu.org\/copyleft\/gpl.html> version 2\n@@ -15,1 +15,1 @@\n-    http:\/\/openjdk.java.net\/legal\/exception-modules-2007-05-08.html\n+    https:\/\/openjdk.org\/legal\/exception-modules-2007-05-08.html\n","filename":"ASSEMBLY_EXCEPTION","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-Please see <https:\/\/openjdk.java.net\/contribute\/> for how to contribute.\n+Please see <https:\/\/openjdk.org\/contribute> for how to contribute.\n","filename":"CONTRIBUTING.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-<p>Too verbose tests which print all information even if they pass are very bad practice. They just pollute output, so it becomes harder to find useful information. In order not print information till it is really needed, one should consider saving it to a temporary buffer and pass to an assert. <a href=\"https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp\" class=\"uri\">https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp<\/a> has a good example how to do that.<\/p>\n+<p>Too verbose tests which print all information even if they pass are very bad practice. They just pollute output, so it becomes harder to find useful information. In order not print information till it is really needed, one should consider saving it to a temporary buffer and pass to an assert. <a href=\"https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp\" class=\"uri\">https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp<\/a> has a good example how to do that.<\/p>\n@@ -174,1 +174,1 @@\n-<p>For now, if a test depends on flags values, it should have <code>if (!&lt;flag&gt;) { return }<\/code> guards in the very beginning and <code>@requires<\/code> comment similar to jtreg <code>@requires<\/code> directive right before test macros. <a href=\"https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp\" class=\"uri\">https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp<\/a> ha an example of this temporary workaround. It is important to follow that pattern as it allows us to easily find all such tests and update them as soon as there is an implementation of flag passing facility.<\/p>\n+<p>For now, if a test depends on flags values, it should have <code>if (!&lt;flag&gt;) { return }<\/code> guards in the very beginning and <code>@requires<\/code> comment similar to jtreg <code>@requires<\/code> directive right before test macros. <a href=\"https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp\" class=\"uri\">https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp<\/a> ha an example of this temporary workaround. It is important to follow that pattern as it allows us to easily find all such tests and update them as soon as there is an implementation of flag passing facility.<\/p>\n","filename":"doc\/hotspot-unit-tests.html","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-### Nearness \n+### Nearness\n@@ -159,1 +159,1 @@\n-### C string comparison \n+### C string comparison\n@@ -197,1 +197,1 @@\n-<https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp>\n+<https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp>\n@@ -232,1 +232,1 @@\n-### Filename \n+### Filename\n@@ -286,1 +286,1 @@\n-### Friend classes \n+### Friend classes\n@@ -306,1 +306,1 @@\n-### Hotspot style \n+### Hotspot style\n@@ -386,1 +386,1 @@\n-<https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp>\n+<https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp>\n@@ -395,1 +395,1 @@\n-### Flag restoring \n+### Flag restoring\n@@ -407,1 +407,1 @@\n-Caveats: \n+Caveats:\n","filename":"doc\/hotspot-unit-tests.md","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+<p><strong>Note:<\/strong> To be able to run the Gtest suite, you need to configure your build to be able to find a proper version of the gtest source. For details, see the section <a href=\"building.html#running-tests\">&quot;Running Tests&quot; in the build documentation<\/a>.<\/p>\n","filename":"doc\/testing.html","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-of files or directories containing JTReg tests. Documentation can be found at \n+of files or directories containing JTReg tests. Documentation can be found at\n@@ -172,0 +172,5 @@\n+**Note:** To be able to run the Gtest suite, you need to configure your build to\n+be able to find a proper version of the gtest source. For details, see the\n+section [\"Running Tests\" in the build\n+documentation](building.html#running-tests).\n+\n@@ -610,2 +615,2 @@\n-If you want to contribute changes to this document, edit `doc\/testing.md` and \n-then run `make update-build-docs` to generate the same changes in \n+If you want to contribute changes to this document, edit `doc\/testing.md` and\n+then run `make update-build-docs` to generate the same changes in\n","filename":"doc\/testing.md","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -178,1 +178,5 @@\n-      binutils_target=\"\"\n+      if test \"x$COMPILE_TYPE\" = xcross; then\n+        binutils_target=\"--host=$OPENJDK_TARGET_AUTOCONF_NAME\"\n+      else\n+        binutils_target=\"\"\n+      fi\n","filename":"make\/autoconf\/lib-hsdis.m4","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        GTEST_FRAMEWORK_SRC=${with_gtest}\n+        GTEST_FRAMEWORK_SRC=$with_gtest\n@@ -60,0 +60,16 @@\n+\n+        # Try to verify version. We require 1.8.1, but this can not be directly\n+        # determined. :-( Instead, there are different, incorrect version\n+        # numbers we can look for.\n+        GTEST_VERSION_1=\"`$GREP GOOGLETEST_VERSION $GTEST_FRAMEWORK_SRC\/CMakeLists.txt | $SED -E -e 's\/set\\(GOOGLETEST_VERSION (.*)\\)\/\\1\/'`\"\n+        if test \"x$GTEST_VERSION_1\" != \"x1.9.0\"; then\n+          AC_MSG_ERROR([gtest at $GTEST_FRAMEWORK_SRC does not seem to be version 1.8.1])\n+        fi\n+\n+        # We cannot grep for \"AC_IN*T\" as a literal since then m4 will treat it as a macro\n+        # and expand it.\n+        # Additional [] needed to keep m4 from mangling shell constructs.\n+        [ GTEST_VERSION_2=\"`$GREP -A1 ^.C_INIT $GTEST_FRAMEWORK_SRC\/configure.ac | $TAIL -n 1 | $SED -E -e 's\/ +\\[(.*)],\/\\1\/'`\" ]\n+        if test \"x$GTEST_VERSION_2\" != \"x1.8.0\"; then\n+          AC_MSG_ERROR([gtest at $GTEST_FRAMEWORK_SRC does not seem to be version 1.8.1 B])\n+        fi\n","filename":"make\/autoconf\/lib-tests.m4","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,0 @@\n-    HEADERS_TO_CHECK=\"X11\/extensions\/shape.h X11\/extensions\/Xrender.h X11\/extensions\/XTest.h X11\/Intrinsic.h\"\n-    # There is no Xrandr extension on AIX\n@@ -102,0 +100,2 @@\n+      # There is no Xrandr extension on AIX. Code is duplicated to avoid autoconf\n+      # 2.71+ warning \"AC_CHECK_HEADERS: you should use literals\"\n@@ -103,0 +103,8 @@\n+      AC_CHECK_HEADERS([X11\/extensions\/shape.h X11\/extensions\/Xrender.h X11\/extensions\/XTest.h X11\/Intrinsic.h],\n+          [X11_HEADERS_OK=yes],\n+          [X11_HEADERS_OK=no; break],\n+          [\n+            # include <X11\/Xlib.h>\n+            # include <X11\/Xutil.h>\n+          ]\n+      )\n@@ -104,1 +112,8 @@\n-      HEADERS_TO_CHECK=\"$HEADERS_TO_CHECK X11\/extensions\/Xrandr.h\"\n+      AC_CHECK_HEADERS([X11\/extensions\/shape.h X11\/extensions\/Xrender.h X11\/extensions\/XTest.h X11\/Intrinsic.h X11\/extensions\/Xrandr.h],\n+          [X11_HEADERS_OK=yes],\n+          [X11_HEADERS_OK=no; break],\n+          [\n+            # include <X11\/Xlib.h>\n+            # include <X11\/Xutil.h>\n+          ]\n+      )\n@@ -107,10 +122,0 @@\n-    # Need to include Xlib.h and Xutil.h to avoid \"present but cannot be compiled\" warnings on Solaris 10\n-    AC_CHECK_HEADERS([$HEADERS_TO_CHECK],\n-        [X11_HEADERS_OK=yes],\n-        [X11_HEADERS_OK=no; break],\n-        [\n-          # include <X11\/Xlib.h>\n-          # include <X11\/Xutil.h>\n-        ]\n-    )\n-\n","filename":"make\/autoconf\/lib-x11.m4","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    ifneq ($$(findstring http:\/, $$($1_CSS)), )\n+    ifneq ($$(findstring https:\/, $$($1_CSS)), )\n","filename":"make\/common\/ProcessMarkdown.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -249,2 +249,1 @@\n-            return BigInteger.valueOf(2).pow(power)\n-                    .multiply(BigInteger.valueOf(coefficient));\n+            return BigInteger.valueOf(coefficient).shiftLeft(power);\n@@ -666,1 +665,1 @@\n-            String powExpr = \"BigInteger.valueOf(2).pow(\" + t.getPower() + \")\";\n+            String powExpr = \".shiftLeft(\" + t.getPower() + \")\";\n@@ -670,2 +669,0 @@\n-            } else if (coefValue == 1) {\n-                termExpr = powExpr;\n@@ -673,1 +670,1 @@\n-                termExpr = powExpr + \".multiply(\" + coefExpr + \")\";\n+                termExpr = coefExpr + powExpr;\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+    \/\/ Governing predicates for load\/store and arithmetic\n@@ -470,1 +471,0 @@\n-    P7,\n@@ -472,0 +472,1 @@\n+    \/\/ Extra predicates\n@@ -480,0 +481,3 @@\n+\n+    \/\/ Preserved for all-true predicate\n+    P7,\n@@ -5541,0 +5545,1 @@\n+  match(pReg);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4662,1 +4662,1 @@\n-instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+instruct vloadmaskB_sve(pReg dst, vReg src, rFlagsReg cr) %{\n@@ -4674,1 +4674,1 @@\n-instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_sve(pReg dst, vReg src, vReg tmp, rFlagsReg cr) %{\n@@ -4688,1 +4688,1 @@\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+instruct vloadmaskB_masked(pReg dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n@@ -4700,1 +4700,1 @@\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_masked(pReg dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -4754,1 +4754,1 @@\n-instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+instruct vstoremaskB_sve(vReg dst, pReg src, immI_1 size) %{\n@@ -4764,1 +4764,1 @@\n-instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+instruct vstoremask_narrow_sve(vReg dst, pReg src, immI_gt_1 size, vReg tmp) %{\n@@ -4781,1 +4781,1 @@\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadV(pReg dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n@@ -4803,1 +4803,1 @@\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+instruct vloadmask_loadV_masked(pReg dst, indirect mem, pRegGov pg,\n@@ -4824,1 +4824,1 @@\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadVMasked(pReg dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -4851,1 +4851,1 @@\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+instruct vloadmask_loadVMasked_masked(pReg dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n@@ -4881,1 +4881,1 @@\n-instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+instruct storeV_vstoremask(indirect mem, pReg src, immI_gt_1 esize, vReg tmp) %{\n@@ -4902,1 +4902,1 @@\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+instruct storeV_vstoremask_masked(indirect mem, pReg src, immI_gt_1 esize,\n@@ -4924,1 +4924,1 @@\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+instruct storeVMasked_vstoremask(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n@@ -4950,1 +4950,1 @@\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize,\n@@ -4980,1 +4980,1 @@\n-instruct vmask_and(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_and(pReg pd, pReg pn, pReg pm) %{\n@@ -4990,1 +4990,1 @@\n-instruct vmask_or(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_or(pReg pd, pReg pn, pReg pm) %{\n@@ -5000,1 +5000,1 @@\n-instruct vmask_xor(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_xor(pReg pd, pReg pn, pReg pm) %{\n@@ -5010,1 +5010,1 @@\n-instruct vmask_and_notI(pRegGov pd, pRegGov pn, pRegGov pm, immI_M1 m1) %{\n+instruct vmask_and_notI(pReg pd, pReg pn, pReg pm, immI_M1 m1) %{\n@@ -5020,1 +5020,1 @@\n-instruct vmask_and_notL(pRegGov pd, pRegGov pn, pRegGov pm, immL_M1 m1) %{\n+instruct vmask_and_notL(pReg pd, pReg pn, pReg pm, immL_M1 m1) %{\n@@ -5048,1 +5048,1 @@\n-instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+instruct vmaskcmp_sve(pReg dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n@@ -5063,1 +5063,1 @@\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+instruct vmaskcmp_masked(pReg dst, vReg src1, vReg src2, immI cond,\n@@ -5090,1 +5090,43 @@\n-instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_same_esize_sve(pReg dst_src) %{\n@@ -5100,1 +5142,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pReg dst, pReg src) %{\n@@ -5104,1 +5146,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -5117,1 +5159,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pReg dst, pReg src) %{\n@@ -5121,1 +5163,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n@@ -5136,1 +5178,1 @@\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+instruct vmask_reinterpret_same_esize(pReg dst_src) %{\n@@ -5147,1 +5189,1 @@\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+instruct vmask_reinterpret_diff_esize(pReg dst, pReg src, vReg tmp, rFlagsReg cr) %{\n@@ -5293,1 +5335,1 @@\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pReg pg, pReg ptmp) %{\n@@ -5405,1 +5447,1 @@\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+instruct vmask_fromlong(pReg dst, iRegL src, vReg tmp1, vReg tmp2) %{\n@@ -5422,1 +5464,1 @@\n-instruct vmaskAll_immI(pRegGov dst, immI src, rFlagsReg cr) %{\n+instruct vmaskAll_immI(pReg dst, immI src, rFlagsReg cr) %{\n@@ -5440,1 +5482,1 @@\n-instruct vmaskAllI(pRegGov dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllI(pReg dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n@@ -5456,1 +5498,1 @@\n-instruct vmaskAllI_masked(pRegGov dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllI_masked(pReg dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -5471,1 +5513,1 @@\n-instruct vmaskAll_immL(pRegGov dst, immL src, rFlagsReg cr) %{\n+instruct vmaskAll_immL(pReg dst, immL src, rFlagsReg cr) %{\n@@ -5489,1 +5531,1 @@\n-instruct vmaskAllL(pRegGov dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllL(pReg dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n@@ -5505,1 +5547,1 @@\n-instruct vmaskAllL_masked(pRegGov dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllL_masked(pReg dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -5522,1 +5564,1 @@\n-instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+instruct vmask_gen_I(pReg pd, iRegIorL2I src, rFlagsReg cr) %{\n@@ -5534,1 +5576,1 @@\n-instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+instruct vmask_gen_L(pReg pd, iRegL src, rFlagsReg cr) %{\n@@ -5546,1 +5588,1 @@\n-instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+instruct vmask_gen_imm(pReg pd, immL con, rFlagsReg cr) %{\n@@ -5840,1 +5882,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n@@ -5874,1 +5916,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":83,"deletions":41,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -3096,1 +3096,1 @@\n-instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+instruct vloadmaskB_sve(pReg dst, vReg src, rFlagsReg cr) %{\n@@ -3108,1 +3108,1 @@\n-instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_sve(pReg dst, vReg src, vReg tmp, rFlagsReg cr) %{\n@@ -3122,1 +3122,1 @@\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+instruct vloadmaskB_masked(pReg dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n@@ -3134,1 +3134,1 @@\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_masked(pReg dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -3188,1 +3188,1 @@\n-instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+instruct vstoremaskB_sve(vReg dst, pReg src, immI_1 size) %{\n@@ -3198,1 +3198,1 @@\n-instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+instruct vstoremask_narrow_sve(vReg dst, pReg src, immI_gt_1 size, vReg tmp) %{\n@@ -3215,1 +3215,1 @@\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadV(pReg dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n@@ -3237,1 +3237,1 @@\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+instruct vloadmask_loadV_masked(pReg dst, indirect mem, pRegGov pg,\n@@ -3258,1 +3258,1 @@\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadVMasked(pReg dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -3285,1 +3285,1 @@\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+instruct vloadmask_loadVMasked_masked(pReg dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n@@ -3315,1 +3315,1 @@\n-instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+instruct storeV_vstoremask(indirect mem, pReg src, immI_gt_1 esize, vReg tmp) %{\n@@ -3336,1 +3336,1 @@\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+instruct storeV_vstoremask_masked(indirect mem, pReg src, immI_gt_1 esize,\n@@ -3358,1 +3358,1 @@\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+instruct storeVMasked_vstoremask(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n@@ -3384,1 +3384,1 @@\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize,\n@@ -3416,1 +3416,1 @@\n-instruct vmask_$1(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_$1(pReg pd, pReg pn, pReg pm) %{\n@@ -3429,1 +3429,1 @@\n-instruct vmask_and_not$1(pRegGov pd, pRegGov pn, pRegGov pm, imm$1_M1 m1) %{\n+instruct vmask_and_not$1(pReg pd, pReg pn, pReg pm, imm$1_M1 m1) %{\n@@ -3464,1 +3464,1 @@\n-instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+instruct vmaskcmp_sve(pReg dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n@@ -3479,1 +3479,1 @@\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+instruct vmaskcmp_masked(pReg dst, vReg src1, vReg src2, immI cond,\n@@ -3506,1 +3506,43 @@\n-instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_same_esize_sve(pReg dst_src) %{\n@@ -3516,1 +3558,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pReg dst, pReg src) %{\n@@ -3520,1 +3562,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -3533,1 +3575,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pReg dst, pReg src) %{\n@@ -3537,1 +3579,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n@@ -3552,1 +3594,1 @@\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+instruct vmask_reinterpret_same_esize(pReg dst_src) %{\n@@ -3563,1 +3605,1 @@\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+instruct vmask_reinterpret_diff_esize(pReg dst, pReg src, vReg tmp, rFlagsReg cr) %{\n@@ -3709,1 +3751,1 @@\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pReg pg, pReg ptmp) %{\n@@ -3821,1 +3863,1 @@\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+instruct vmask_fromlong(pReg dst, iRegL src, vReg tmp1, vReg tmp2) %{\n@@ -3841,1 +3883,1 @@\n-instruct vmaskAll_imm$1(pRegGov dst, imm$1 src, rFlagsReg cr) %{\n+instruct vmaskAll_imm$1(pReg dst, imm$1 src, rFlagsReg cr) %{\n@@ -3862,1 +3904,1 @@\n-instruct vmaskAll$1(pRegGov dst, $2 src, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAll$1(pReg dst, $2 src, vReg tmp, rFlagsReg cr) %{\n@@ -3881,1 +3923,1 @@\n-instruct vmaskAll$1_masked(pRegGov dst, $2 src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAll$1_masked(pReg dst, $2 src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -3905,1 +3947,1 @@\n-instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+instruct vmask_gen_I(pReg pd, iRegIorL2I src, rFlagsReg cr) %{\n@@ -3917,1 +3959,1 @@\n-instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+instruct vmask_gen_L(pReg pd, iRegL src, rFlagsReg cr) %{\n@@ -3929,1 +3971,1 @@\n-instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+instruct vmask_gen_imm(pReg pd, immL con, rFlagsReg cr) %{\n@@ -4212,1 +4254,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n@@ -4246,1 +4288,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":77,"deletions":35,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2397,1 +2397,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2399,1 +2399,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -2434,1 +2434,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2436,1 +2436,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -2940,1 +2940,1 @@\n-    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n+    for (int i = 0; i < PRegister::number_of_registers; i++) {\n@@ -2949,1 +2949,1 @@\n-    for (int i = PRegister::number_of_saved_registers - 1; i >= 0; i--) {\n+    for (int i = PRegister::number_of_registers - 1; i >= 0; i--) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -299,5 +299,0 @@\n-    \/\/ p0-p7 are governing predicates for load\/store and arithmetic, but p7 is\n-    \/\/ preserved as an all-true predicate in OpenJDK. And since we don't support\n-    \/\/ non-governing predicate registers allocation for non-temp register, the\n-    \/\/ predicate registers to be saved are p0-p6.\n-    number_of_saved_registers = number_of_governing_registers - 1,\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,5 +164,2 @@\n-    \/\/ The number of total predicate bytes is unlikely to be a multiple\n-    \/\/ of 16 bytes so we manually align it up.\n-    return align_up(Matcher::scalable_predicate_reg_slots() *\n-                    VMRegImpl::stack_slot_size *\n-                    PRegister::number_of_saved_registers, 16);\n+    return (Matcher::scalable_vector_reg_size(T_BYTE) >> LogBitsPerByte) *\n+           PRegister::number_of_registers;\n@@ -254,8 +251,0 @@\n-  if (_save_vectors && use_sve) {\n-    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n-      PRegister r = as_PRegister(i);\n-      int sp_offset = sve_predicate_size_in_slots * i;\n-      oop_map->set_callee_saved(VMRegImpl::stack2reg(sp_offset), r->as_VMReg());\n-    }\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 SAP SE. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"nativeInst_ppc.hpp\"\n@@ -166,1 +165,2 @@\n-  __ lwz(R0, in_bytes(bs_nm->thread_disarmed_offset()), R16_thread);\n+  \/\/ Low order half of 64 bit value is currently used.\n+  __ ld(R0, in_bytes(bs_nm->thread_disarmed_offset()), R16_thread);\n@@ -171,2 +171,6 @@\n-  \/\/ Oops may have been changed; exploiting isync semantics (used as acquire) to make those updates observable.\n-  __ isync();\n+  \/\/ Oops may have been changed. Make those updates observable.\n+  \/\/ \"isync\" can serve both, data and instruction patching.\n+  \/\/ But, many GCs don't modify nmethods during a concurrent phase.\n+  if (nmethod_patching_type() != NMethodPatchingType::stw_instruction_and_data_patch) {\n+    __ isync();\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 SAP SE. All rights reserved.\n@@ -33,1 +33,5 @@\n-class InterpreterMacroAssembler;\n+enum class NMethodPatchingType {\n+  stw_instruction_and_data_patch,\n+  conc_instruction_and_data_patch,\n+  conc_data_patch\n+};\n@@ -61,0 +65,2 @@\n+  virtual NMethodPatchingType nmethod_patching_type() { return NMethodPatchingType::stw_instruction_and_data_patch; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -77,1 +79,1 @@\n-    verify_op_code(current_instruction, Assembler::LWZ_OPCODE);\n+    verify_op_code(current_instruction, Assembler::LD_OPCODE);\n@@ -85,1 +87,1 @@\n-    verify_op_code(current_instruction, Assembler::ISYNC_OPCODE);\n+    \/\/ isync is optional\n@@ -103,1 +105,5 @@\n-  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + (-9 * 4);\n+  BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + (-8 * 4);\n+  if (bs_asm->nmethod_patching_type() != NMethodPatchingType::stw_instruction_and_data_patch) {\n+    barrier_address -= 4; \/\/ isync (see nmethod_entry_barrier)\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetNMethod_ppc.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n@@ -64,0 +64,1 @@\n+  virtual NMethodPatchingType nmethod_patching_type() { return NMethodPatchingType::conc_data_patch; }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n@@ -67,0 +67,2 @@\n+  virtual NMethodPatchingType nmethod_patching_type() { return NMethodPatchingType::conc_data_patch; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,262 +43,0 @@\n-void Assembler::add(Register Rd, Register Rn, int64_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addi(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    add(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addiw(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    addw(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::sub(Register Rd, Register Rn, int64_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addi(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    sub(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addiw(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    subw(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::zext_w(Register Rd, Register Rs) {\n-  add_uw(Rd, Rs, zr);\n-}\n-\n-void Assembler::_li(Register Rd, int64_t imm) {\n-  \/\/ int64_t is in range 0x8000 0000 0000 0000 ~ 0x7fff ffff ffff ffff\n-  int shift = 12;\n-  int64_t upper = imm, lower = imm;\n-  \/\/ Split imm to a lower 12-bit sign-extended part and the remainder,\n-  \/\/ because addi will sign-extend the lower imm.\n-  lower = ((int32_t)imm << 20) >> 20;\n-  upper -= lower;\n-\n-  \/\/ Test whether imm is a 32-bit integer.\n-  if (!(((imm) & ~(int64_t)0x7fffffff) == 0 ||\n-        (((imm) & ~(int64_t)0x7fffffff) == ~(int64_t)0x7fffffff))) {\n-    while (((upper >> shift) & 1) == 0) { shift++; }\n-    upper >>= shift;\n-    li(Rd, upper);\n-    slli(Rd, Rd, shift);\n-    if (lower != 0) {\n-      addi(Rd, Rd, lower);\n-    }\n-  } else {\n-    \/\/ 32-bit integer\n-    Register hi_Rd = zr;\n-    if (upper != 0) {\n-      lui(Rd, (int32_t)upper);\n-      hi_Rd = Rd;\n-    }\n-    if (lower != 0 || hi_Rd == zr) {\n-      addiw(Rd, hi_Rd, lower);\n-    }\n-  }\n-}\n-\n-void Assembler::li64(Register Rd, int64_t imm) {\n-  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n-  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n-  int64_t lower = imm & 0xffffffff;\n-  lower -= ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n-\n-  \/\/ Load upper 32 bits\n-  int64_t up = upper, lo = upper;\n-  lo = (lo << 52) >> 52;\n-  up -= lo;\n-  up = (int32_t)up;\n-  lui(Rd, up);\n-  addi(Rd, Rd, lo);\n-\n-  \/\/ Load the rest 32 bits.\n-  slli(Rd, Rd, 12);\n-  addi(Rd, Rd, (int32_t)lower >> 20);\n-  slli(Rd, Rd, 12);\n-  lower = ((int32_t)imm << 12) >> 20;\n-  addi(Rd, Rd, lower);\n-  slli(Rd, Rd, 8);\n-  lower = imm & 0xff;\n-  addi(Rd, Rd, lower);\n-}\n-\n-void Assembler::li32(Register Rd, int32_t imm) {\n-  \/\/ int32_t is in range 0x8000 0000 ~ 0x7fff ffff, and imm[31] is the sign bit\n-  int64_t upper = imm, lower = imm;\n-  lower = (imm << 20) >> 20;\n-  upper -= lower;\n-  upper = (int32_t)upper;\n-  \/\/ lui Rd, imm[31:12] + imm[11]\n-  lui(Rd, upper);\n-  \/\/ use addiw to distinguish li32 to li64\n-  addiw(Rd, Rd, lower);\n-}\n-\n-#define INSN(NAME, REGISTER)                                       \\\n-  void Assembler::NAME(const address &dest, Register temp) {       \\\n-    assert_cond(dest != NULL);                                     \\\n-    int64_t distance = dest - pc();                                \\\n-    if (is_imm_in_range(distance, 20, 1)) {                        \\\n-      jal(REGISTER, distance);                                     \\\n-    } else {                                                       \\\n-      assert(temp != noreg, \"temp must not be empty register!\");   \\\n-      int32_t offset = 0;                                          \\\n-      movptr(temp, dest, offset);                                  \\\n-      jalr(REGISTER, temp, offset);                                \\\n-    }                                                              \\\n-  }                                                                \\\n-  void Assembler::NAME(Label &l, Register temp) {                  \\\n-    jal(REGISTER, l, temp);                                        \\\n-  }                                                                \\\n-\n-  INSN(j,   x0);\n-  INSN(jal, x1);\n-\n-#undef INSN\n-\n-#define INSN(NAME, REGISTER)                                       \\\n-  void Assembler::NAME(Register Rs) {                              \\\n-    jalr(REGISTER, Rs, 0);                                         \\\n-  }\n-\n-  INSN(jr,   x0);\n-  INSN(jalr, x1);\n-\n-#undef INSN\n-\n-#define INSN(NAME, REGISTER)                                   \\\n-  void Assembler::NAME(const Address &adr, Register temp) {    \\\n-    switch (adr.getMode()) {                                   \\\n-      case Address::literal: {                                 \\\n-        relocate(adr.rspec(), [&] {                            \\\n-          NAME(adr.target(), temp);                            \\\n-        });                                                    \\\n-        break;                                                 \\\n-      }                                                        \\\n-      case Address::base_plus_offset: {                        \\\n-        int32_t offset = 0;                                    \\\n-        baseOffset(temp, adr, offset);                         \\\n-        jalr(REGISTER, temp, offset);                          \\\n-        break;                                                 \\\n-      }                                                        \\\n-      default:                                                 \\\n-        ShouldNotReachHere();                                  \\\n-    }                                                          \\\n-  }\n-\n-  INSN(j,    x0);\n-  INSN(jal,  x1);\n-\n-#undef INSN\n-\n-void Assembler::wrap_label(Register r1, Register r2, Label &L, compare_and_branch_insn insn,\n-                           compare_and_branch_label_insn neg_insn, bool is_far) {\n-  if (is_far) {\n-    Label done;\n-    (this->*neg_insn)(r1, r2, done, \/* is_far *\/ false);\n-    j(L);\n-    bind(done);\n-  } else {\n-    if (L.is_bound()) {\n-      (this->*insn)(r1, r2, target(L));\n-    } else {\n-      L.add_patch_at(code(), locator());\n-      (this->*insn)(r1, r2, pc());\n-    }\n-  }\n-}\n-\n-void Assembler::wrap_label(Register Rt, Label &L, Register tmp, load_insn_by_temp insn) {\n-  if (L.is_bound()) {\n-    (this->*insn)(Rt, target(L), tmp);\n-  } else {\n-    L.add_patch_at(code(), locator());\n-    (this->*insn)(Rt, pc(), tmp);\n-  }\n-}\n-\n-void Assembler::wrap_label(Register Rt, Label &L, jal_jalr_insn insn) {\n-  if (L.is_bound()) {\n-    (this->*insn)(Rt, target(L));\n-  } else {\n-    L.add_patch_at(code(), locator());\n-    (this->*insn)(Rt, pc());\n-  }\n-}\n-\n-void Assembler::movptr(Register Rd, address addr, int32_t &offset) {\n-  int64_t imm64 = (int64_t)addr;\n-#ifndef PRODUCT\n-  {\n-    char buffer[64];\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, imm64);\n-    block_comment(buffer);\n-  }\n-#endif\n-  assert(is_unsigned_imm_in_range(imm64, 47, 0) || (imm64 == (int64_t)-1),\n-         \"bit 47 overflows in address constant\");\n-  \/\/ Load upper 31 bits\n-  int64_t imm = imm64 >> 17;\n-  int64_t upper = imm, lower = imm;\n-  lower = (lower << 52) >> 52;\n-  upper -= lower;\n-  upper = (int32_t)upper;\n-  lui(Rd, upper);\n-  addi(Rd, Rd, lower);\n-\n-  \/\/ Load the rest 17 bits.\n-  slli(Rd, Rd, 11);\n-  addi(Rd, Rd, (imm64 >> 6) & 0x7ff);\n-  slli(Rd, Rd, 6);\n-\n-  \/\/ This offset will be used by following jalr\/ld.\n-  offset = imm64 & 0x3f;\n-}\n-\n-void Assembler::movptr(Register Rd, uintptr_t imm64) {\n-  movptr(Rd, (address)imm64);\n-}\n-\n-void Assembler::movptr(Register Rd, address addr) {\n-  int offset = 0;\n-  movptr(Rd, addr, offset);\n-  addi(Rd, Rd, offset);\n-}\n-\n-#define INSN(NAME, NEG_INSN)                                                         \\\n-  void Assembler::NAME(Register Rs, Register Rt, const address &dest) {              \\\n-    NEG_INSN(Rt, Rs, dest);                                                          \\\n-  }                                                                                  \\\n-  void Assembler::NAME(Register Rs, Register Rt, Label &l, bool is_far) {            \\\n-    NEG_INSN(Rt, Rs, l, is_far);                                                     \\\n-  }\n-\n-  INSN(bgt,  blt);\n-  INSN(ble,  bge);\n-  INSN(bgtu, bltu);\n-  INSN(bleu, bgeu);\n-#undef INSN\n-\n-#undef __\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":0,"deletions":262,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+\n@@ -183,0 +184,1 @@\n+\n@@ -190,0 +192,1 @@\n+\n@@ -294,42 +297,0 @@\n-  void baseOffset32(Register Rd, const Address &adr, int32_t &offset) {\n-    assert(Rd != noreg, \"Rd must not be empty register!\");\n-    guarantee(Rd != adr.base(), \"should use different registers!\");\n-    if (is_offset_in_range(adr.offset(), 32)) {\n-      int32_t imm = adr.offset();\n-      int32_t upper = imm, lower = imm;\n-      lower = (imm << 20) >> 20;\n-      upper -= lower;\n-      lui(Rd, upper);\n-      offset = lower;\n-    } else {\n-      offset = ((int32_t)adr.offset() << 20) >> 20;\n-      li(Rd, adr.offset() - offset);\n-    }\n-    add(Rd, Rd, adr.base());\n-  }\n-\n-  void baseOffset(Register Rd, const Address &adr, int32_t &offset) {\n-    if (is_offset_in_range(adr.offset(), 12)) {\n-      assert(Rd != noreg, \"Rd must not be empty register!\");\n-      addi(Rd, adr.base(), adr.offset());\n-      offset = 0;\n-    } else {\n-      baseOffset32(Rd, adr, offset);\n-    }\n-  }\n-\n-  void _li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n-  void li32(Register Rd, int32_t imm);\n-  void li64(Register Rd, int64_t imm);\n-  void movptr(Register Rd, address addr);\n-  void movptr(Register Rd, address addr, int32_t &offset);\n-  void movptr(Register Rd, uintptr_t imm64);\n-  void j(const address &dest, Register temp = t0);\n-  void j(const Address &adr, Register temp = t0);\n-  void j(Label &l, Register temp = t0);\n-  void jal(Label &l, Register temp = t0);\n-  void jal(const address &dest, Register temp = t0);\n-  void jal(const Address &adr, Register temp = t0);\n-  void jr(Register Rs);\n-  void jalr(Register Rs);\n-\n@@ -477,8 +438,1 @@\n-#define INSN_ENTRY_RELOC(result_type, header)                               \\\n-  result_type header {                                                      \\\n-    guarantee(rtype == relocInfo::internal_word_type,                       \\\n-              \"only internal_word_type relocs make sense here\");            \\\n-    relocate(InternalAddress(dest).rspec());                                \\\n-    IncompressibleRegion ir(this);  \/* relocations *\/\n-\n-  \/\/ Load\/store register (all modes)\n+\/\/ Load\/store register (all modes)\n@@ -508,57 +462,0 @@\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(Register Rd, address dest) {                                                           \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(Rd, (int32_t)distance + 0x800);                                                        \\\n-      NAME(Rd, Rd, ((int32_t)distance << 20) >> 20);                                               \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(Rd, dest, offset);                                                                    \\\n-      NAME(Rd, Rd, offset);                                                                        \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  INSN_ENTRY_RELOC(void, NAME(Register Rd, address dest, relocInfo::relocType rtype))              \\\n-    NAME(Rd, dest);                                                                                \\\n-  }                                                                                                \\\n-  void NAME(Register Rd, const Address &adr, Register temp = t0) {                                 \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        relocate(adr.rspec(), [&] {                                                                \\\n-          NAME(Rd, adr.target());                                                                  \\\n-        });                                                                                        \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rd, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset = 0;                                                                      \\\n-          if (Rd == adr.base()) {                                                                  \\\n-            baseOffset32(temp, adr, offset);                                                       \\\n-            NAME(Rd, temp, offset);                                                                \\\n-          } else {                                                                                 \\\n-            baseOffset32(Rd, adr, offset);                                                         \\\n-            NAME(Rd, Rd, offset);                                                                  \\\n-          }                                                                                        \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  void NAME(Register Rd, Label &L) {                                                               \\\n-    wrap_label(Rd, L, &Assembler::NAME);                                                           \\\n-  }\n-\n-  INSN(lb);\n-  INSN(lbu);\n-  INSN(lh);\n-  INSN(lhu);\n-  INSN(lw);\n-  INSN(lwu);\n-  INSN(ld);\n-\n-#undef INSN\n-\n@@ -583,43 +480,0 @@\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(FloatRegister Rd, address dest, Register temp = t0) {                                  \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n-      NAME(Rd, temp, ((int32_t)distance << 20) >> 20);                                             \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(temp, dest, offset);                                                                  \\\n-      NAME(Rd, temp, offset);                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  INSN_ENTRY_RELOC(void, NAME(FloatRegister Rd, address dest, relocInfo::relocType rtype, Register temp = t0)) \\\n-    NAME(Rd, dest, temp);                                                                          \\\n-  }                                                                                                \\\n-  void NAME(FloatRegister Rd, const Address &adr, Register temp = t0) {                            \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        relocate(adr.rspec(), [&] {                                                                \\\n-          NAME(Rd, adr.target(), temp);                                                            \\\n-        });                                                                                        \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rd, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset = 0;                                                                      \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n-          NAME(Rd, temp, offset);                                                                  \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }\n-\n-  INSN(flw);\n-  INSN(fld);\n-#undef INSN\n-\n@@ -646,2 +500,2 @@\n-  INSN(beq, 0b1100011, 0b000);\n-  INSN(bne, 0b1100011, 0b001);\n+  INSN(beq,  0b1100011, 0b000);\n+  INSN(bne,  0b1100011, 0b001);\n@@ -655,34 +509,0 @@\n-#define INSN(NAME)                                                                                       \\\n-  void NAME(Register Rs1, Register Rs2, const address dest) {                                            \\\n-    assert_cond(dest != NULL);                                                                           \\\n-    int64_t offset = (dest - pc());                                                                      \\\n-    guarantee(is_imm_in_range(offset, 12, 1), \"offset is invalid.\");                                     \\\n-    NAME(Rs1, Rs2, offset);                                                                              \\\n-  }                                                                                                      \\\n-  INSN_ENTRY_RELOC(void, NAME(Register Rs1, Register Rs2, address dest, relocInfo::relocType rtype))     \\\n-    NAME(Rs1, Rs2, dest);                                                                                \\\n-  }\n-\n-  INSN(beq);\n-  INSN(bne);\n-  INSN(bge);\n-  INSN(bgeu);\n-  INSN(blt);\n-  INSN(bltu);\n-\n-#undef INSN\n-\n-#define INSN(NAME, NEG_INSN)                                                                \\\n-  void NAME(Register Rs1, Register Rs2, Label &L, bool is_far = false) {                    \\\n-    wrap_label(Rs1, Rs2, L, &Assembler::NAME, &Assembler::NEG_INSN, is_far);                \\\n-  }\n-\n-  INSN(beq,  bne);\n-  INSN(bne,  beq);\n-  INSN(blt,  bge);\n-  INSN(bge,  blt);\n-  INSN(bltu, bgeu);\n-  INSN(bgeu, bltu);\n-\n-#undef INSN\n-\n@@ -714,101 +534,0 @@\n-#define INSN(NAME, REGISTER)                                                                                \\\n-  INSN_ENTRY_RELOC(void, NAME(REGISTER Rs, address dest, relocInfo::relocType rtype, Register temp = t0))   \\\n-    NAME(Rs, dest, temp);                                                                                   \\\n-  }\n-\n-  INSN(sb,  Register);\n-  INSN(sh,  Register);\n-  INSN(sw,  Register);\n-  INSN(sd,  Register);\n-  INSN(fsw, FloatRegister);\n-  INSN(fsd, FloatRegister);\n-\n-#undef INSN\n-\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(Register Rs, address dest, Register temp = t0) {                                       \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    assert_different_registers(Rs, temp);                                                          \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n-      NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                             \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(temp, dest, offset);                                                                  \\\n-      NAME(Rs, temp, offset);                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  void NAME(Register Rs, const Address &adr, Register temp = t0) {                                 \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        assert_different_registers(Rs, temp);                                                      \\\n-        relocate(adr.rspec(), [&] {                                                                \\\n-          NAME(Rs, adr.target(), temp);                                                            \\\n-        });                                                                                        \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rs, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset= 0;                                                                       \\\n-          assert_different_registers(Rs, temp);                                                    \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n-          NAME(Rs, temp, offset);                                                                  \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }\n-\n-  INSN(sb);\n-  INSN(sh);\n-  INSN(sw);\n-  INSN(sd);\n-\n-#undef INSN\n-\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(FloatRegister Rs, address dest, Register temp = t0) {                                  \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n-      NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                             \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(temp, dest, offset);                                                                  \\\n-      NAME(Rs, temp, offset);                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  void NAME(FloatRegister Rs, const Address &adr, Register temp = t0) {                            \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        relocate(adr.rspec(), [&] {                                                                \\\n-          NAME(Rs, adr.target(), temp);                                                            \\\n-        });                                                                                        \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rs, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset = 0;                                                                      \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n-          NAME(Rs, temp, offset);                                                                  \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }\n-\n-  INSN(fsw);\n-  INSN(fsd);\n-\n-#undef INSN\n-\n@@ -853,11 +572,11 @@\n-#define INSN(NAME, op)                                                                        \\\n-  void NAME(Register Rd, const int32_t offset) {                                              \\\n-    guarantee(is_imm_in_range(offset, 20, 1), \"offset is invalid.\");                          \\\n-    unsigned insn = 0;                                                                        \\\n-    patch((address)&insn, 6, 0, op);                                                          \\\n-    patch_reg((address)&insn, 7, Rd);                                                         \\\n-    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));                         \\\n-    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));                              \\\n-    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));                         \\\n-    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));                              \\\n-    emit(insn);                                                                               \\\n+#define INSN(NAME, op)                                                                \\\n+  void NAME(Register Rd, const int32_t offset) {                                      \\\n+    guarantee(is_imm_in_range(offset, 20, 1), \"offset is invalid.\");                  \\\n+    unsigned insn = 0;                                                                \\\n+    patch((address)&insn, 6, 0, op);                                                  \\\n+    patch_reg((address)&insn, 7, Rd);                                                 \\\n+    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));                 \\\n+    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));                      \\\n+    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));                 \\\n+    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));                      \\\n+    emit(insn);                                                                       \\\n@@ -870,35 +589,11 @@\n-#define INSN(NAME)                                                                            \\\n-  void NAME(Register Rd, const address dest, Register temp = t0) {                            \\\n-    assert_cond(dest != NULL);                                                                \\\n-    int64_t offset = dest - pc();                                                             \\\n-    if (is_imm_in_range(offset, 20, 1)) {                                                     \\\n-      NAME(Rd, offset);                                                                       \\\n-    } else {                                                                                  \\\n-      assert_different_registers(Rd, temp);                                                   \\\n-      int32_t off = 0;                                                                        \\\n-      movptr(temp, dest, off);                                                                \\\n-      jalr(Rd, temp, off);                                                                    \\\n-    }                                                                                         \\\n-  }                                                                                           \\\n-  void NAME(Register Rd, Label &L, Register temp = t0) {                                      \\\n-    assert_different_registers(Rd, temp);                                                     \\\n-    wrap_label(Rd, L, temp, &Assembler::NAME);                                                \\\n-  }\n-\n-  INSN(jal);\n-\n-#undef INSN\n-\n-#undef INSN_ENTRY_RELOC\n-\n-#define INSN(NAME, op, funct)                                                              \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                              \\\n-    guarantee(is_offset_in_range(offset, 12), \"offset is invalid.\");                       \\\n-    unsigned insn = 0;                                                                     \\\n-    patch((address)&insn, 6, 0, op);                                                       \\\n-    patch_reg((address)&insn, 7, Rd);                                                      \\\n-    patch((address)&insn, 14, 12, funct);                                                  \\\n-    patch_reg((address)&insn, 15, Rs);                                                     \\\n-    int32_t val = offset & 0xfff;                                                          \\\n-    patch((address)&insn, 31, 20, val);                                                    \\\n-    emit(insn);                                                                            \\\n+#define INSN(NAME, op, funct)                                                         \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                         \\\n+    guarantee(is_offset_in_range(offset, 12), \"offset is invalid.\");                  \\\n+    unsigned insn = 0;                                                                \\\n+    patch((address)&insn, 6, 0, op);                                                  \\\n+    patch_reg((address)&insn, 7, Rd);                                                 \\\n+    patch((address)&insn, 14, 12, funct);                                             \\\n+    patch_reg((address)&insn, 15, Rs);                                                \\\n+    int32_t val = offset & 0xfff;                                                     \\\n+    patch((address)&insn, 31, 20, val);                                               \\\n+    emit(insn);                                                                       \\\n@@ -1032,4 +727,4 @@\n-  INSN(fsqrt_s,   0b1010011, 0b00000, 0b0101100);\n-  INSN(fsqrt_d,   0b1010011, 0b00000, 0b0101101);\n-  INSN(fcvt_s_d,  0b1010011, 0b00001, 0b0100000);\n-  INSN(fcvt_d_s,  0b1010011, 0b00000, 0b0100001);\n+  INSN(fsqrt_s,  0b1010011, 0b00000, 0b0101100);\n+  INSN(fsqrt_d,  0b1010011, 0b00000, 0b0101101);\n+  INSN(fcvt_s_d, 0b1010011, 0b00001, 0b0100000);\n+  INSN(fcvt_d_s, 0b1010011, 0b00000, 0b0100001);\n@@ -2705,4 +2400,0 @@\n-  bool do_compress() const {\n-    return UseRVC && in_compressible_region();\n-  }\n-\n@@ -2748,0 +2439,4 @@\n+  bool do_compress() const {\n+    return UseRVC && in_compressible_region();\n+  }\n+\n@@ -2911,15 +2606,0 @@\n-\/\/ --------------------------\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, int64_t imm) {                                                      \\\n-    \/* li -> c.li *\/                                                                         \\\n-    if (do_compress() && (is_imm_in_range(imm, 6, 0) && Rd != x0)) {                         \\\n-      c_li(Rd, imm);                                                                         \\\n-      return;                                                                                \\\n-    }                                                                                        \\\n-    _li(Rd, imm);                                                                            \\\n-  }\n-\n-  INSN(li);\n-\n-#undef INSN\n-\n@@ -3037,18 +2717,4 @@\n-  void bgt(Register Rs, Register Rt, const address &dest);\n-  void ble(Register Rs, Register Rt, const address &dest);\n-  void bgtu(Register Rs, Register Rt, const address &dest);\n-  void bleu(Register Rs, Register Rt, const address &dest);\n-  void bgt(Register Rs, Register Rt, Label &l, bool is_far = false);\n-  void ble(Register Rs, Register Rt, Label &l, bool is_far = false);\n-  void bgtu(Register Rs, Register Rt, Label &l, bool is_far = false);\n-  void bleu(Register Rs, Register Rt, Label &l, bool is_far = false);\n-\n-  typedef void (Assembler::* jal_jalr_insn)(Register Rt, address dest);\n-  typedef void (Assembler::* load_insn_by_temp)(Register Rt, address dest, Register temp);\n-  typedef void (Assembler::* compare_and_branch_insn)(Register Rs1, Register Rs2, const address dest);\n-  typedef void (Assembler::* compare_and_branch_label_insn)(Register Rs1, Register Rs2, Label &L, bool is_far);\n-\n-  void wrap_label(Register r1, Register r2, Label &L, compare_and_branch_insn insn,\n-                  compare_and_branch_label_insn neg_insn, bool is_far);\n-  void wrap_label(Register r, Label &L, Register t, load_insn_by_temp insn);\n-  void wrap_label(Register r, Label &L, jal_jalr_insn insn);\n+#define INSN(NAME, REGISTER)                       \\\n+  void NAME(Register Rs) {                         \\\n+    jalr(REGISTER, Rs, 0);                         \\\n+  }\n@@ -3056,3 +2722,2 @@\n-  \/\/ Computational pseudo instructions\n-  void add(Register Rd, Register Rn, int64_t increment, Register temp = t0);\n-  void addw(Register Rd, Register Rn, int32_t increment, Register temp = t0);\n+  INSN(jr,   x0);\n+  INSN(jalr, x1);\n@@ -3060,2 +2725,1 @@\n-  void sub(Register Rd, Register Rn, int64_t decrement, Register temp = t0);\n-  void subw(Register Rd, Register Rn, int32_t decrement, Register temp = t0);\n+#undef INSN\n@@ -3065,3 +2729,2 @@\n-  void zext_w(Register Rd, Register Rs);\n-\n-  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(true) {\n+  void zext_w(Register Rd, Register Rs) {\n+    add_uw(Rd, Rs, zr);\n@@ -3084,0 +2747,2 @@\n+  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(true) {}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":47,"deletions":382,"binary":false,"changes":429,"status":"modified"},{"patch":"@@ -546,1 +546,1 @@\n-  void (Assembler::* insn)(Register Rt, const Address &adr, Register temp);\n+  void (MacroAssembler::* insn)(Register Rt, const Address &adr, Register temp);\n@@ -550,1 +550,1 @@\n-      insn = &Assembler::sd; break;\n+      insn = &MacroAssembler::sd; break;\n@@ -553,1 +553,1 @@\n-      insn = &Assembler::sd; break;\n+      insn = &MacroAssembler::sd; break;\n@@ -556,1 +556,1 @@\n-      insn = &Assembler::sd; break;\n+      insn = &MacroAssembler::sd; break;\n@@ -559,1 +559,1 @@\n-      insn = &Assembler::sw; break;\n+      insn = &MacroAssembler::sw; break;\n@@ -562,1 +562,1 @@\n-      insn = &Assembler::sw; break;\n+      insn = &MacroAssembler::sw; break;\n@@ -567,1 +567,1 @@\n-        insn = &Assembler::sw;\n+        insn = &MacroAssembler::sw;\n@@ -569,1 +569,1 @@\n-        insn = &Assembler::sd;\n+        insn = &MacroAssembler::sd;\n@@ -575,1 +575,1 @@\n-      insn = &Assembler::sh;\n+      insn = &MacroAssembler::sh;\n@@ -580,1 +580,1 @@\n-      insn = &Assembler::sb; break;\n+      insn = &MacroAssembler::sb; break;\n@@ -583,1 +583,1 @@\n-      insn = &Assembler::sd;  \/\/ unreachable\n+      insn = &MacroAssembler::sd;  \/\/ unreachable\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-                                  Register result)\n-{\n+                                  Register result) {\n@@ -378,8 +377,8 @@\n-  (c1_cond_branch_insn)&Assembler::beq,\n-  (c1_cond_branch_insn)&Assembler::bne,\n-  (c1_cond_branch_insn)&Assembler::blt,\n-  (c1_cond_branch_insn)&Assembler::ble,\n-  (c1_cond_branch_insn)&Assembler::bge,\n-  (c1_cond_branch_insn)&Assembler::bgt,\n-  (c1_cond_branch_insn)&Assembler::bleu, \/\/ lir_cond_belowEqual\n-  (c1_cond_branch_insn)&Assembler::bgeu  \/\/ lir_cond_aboveEqual\n+  (c1_cond_branch_insn)&MacroAssembler::beq,\n+  (c1_cond_branch_insn)&MacroAssembler::bne,\n+  (c1_cond_branch_insn)&MacroAssembler::blt,\n+  (c1_cond_branch_insn)&MacroAssembler::ble,\n+  (c1_cond_branch_insn)&MacroAssembler::bge,\n+  (c1_cond_branch_insn)&MacroAssembler::bgt,\n+  (c1_cond_branch_insn)&MacroAssembler::bleu, \/\/ lir_cond_belowEqual\n+  (c1_cond_branch_insn)&MacroAssembler::bgeu  \/\/ lir_cond_aboveEqual\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1210,2 +1210,2 @@\n-      lbu(tmp1, a1, 0);\n-      lbu(tmp2, a2, 0);\n+      lbu(tmp1, Address(a1, 0));\n+      lbu(tmp2, Address(a2, 0));\n@@ -1232,2 +1232,2 @@\n-  (conditional_branch_insn)&Assembler::beq,\n-  (conditional_branch_insn)&Assembler::bgt,\n+  (conditional_branch_insn)&MacroAssembler::beq,\n+  (conditional_branch_insn)&MacroAssembler::bgt,\n@@ -1235,3 +1235,3 @@\n-  (conditional_branch_insn)&Assembler::blt,\n-  (conditional_branch_insn)&Assembler::bne,\n-  (conditional_branch_insn)&Assembler::ble,\n+  (conditional_branch_insn)&MacroAssembler::blt,\n+  (conditional_branch_insn)&MacroAssembler::bne,\n+  (conditional_branch_insn)&MacroAssembler::ble,\n@@ -1239,1 +1239,1 @@\n-  (conditional_branch_insn)&Assembler::bge,\n+  (conditional_branch_insn)&MacroAssembler::bge,\n@@ -1242,2 +1242,2 @@\n-  (conditional_branch_insn)&Assembler::beq,\n-  (conditional_branch_insn)&Assembler::bgtu,\n+  (conditional_branch_insn)&MacroAssembler::beq,\n+  (conditional_branch_insn)&MacroAssembler::bgtu,\n@@ -1245,3 +1245,3 @@\n-  (conditional_branch_insn)&Assembler::bltu,\n-  (conditional_branch_insn)&Assembler::bne,\n-  (conditional_branch_insn)&Assembler::bleu,\n+  (conditional_branch_insn)&MacroAssembler::bltu,\n+  (conditional_branch_insn)&MacroAssembler::bne,\n+  (conditional_branch_insn)&MacroAssembler::bleu,\n@@ -1249,1 +1249,1 @@\n-  (conditional_branch_insn)&Assembler::bgeu\n+  (conditional_branch_insn)&MacroAssembler::bgeu\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-  flw(r, esp, 0);\n+  flw(r, Address(esp, 0));\n@@ -379,1 +379,1 @@\n-  fld(r, esp, 0);\n+  fld(r, Address(esp, 0));\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -731,1 +731,28 @@\n-void MacroAssembler::la(Register Rd, const address &dest) {\n+void MacroAssembler::baseOffset32(Register Rd, const Address &adr, int32_t &offset) {\n+  assert(Rd != noreg, \"Rd must not be empty register!\");\n+  guarantee(Rd != adr.base(), \"should use different registers!\");\n+  if (is_offset_in_range(adr.offset(), 32)) {\n+    int32_t imm = adr.offset();\n+    int32_t upper = imm, lower = imm;\n+    lower = (imm << 20) >> 20;\n+    upper -= lower;\n+    lui(Rd, upper);\n+    offset = lower;\n+  } else {\n+    offset = ((int32_t)adr.offset() << 20) >> 20;\n+    li(Rd, adr.offset() - offset);\n+  }\n+  add(Rd, Rd, adr.base());\n+}\n+\n+void MacroAssembler::baseOffset(Register Rd, const Address &adr, int32_t &offset) {\n+  if (is_offset_in_range(adr.offset(), 12)) {\n+    assert(Rd != noreg, \"Rd must not be empty register!\");\n+    addi(Rd, adr.base(), adr.offset());\n+    offset = 0;\n+  } else {\n+    baseOffset32(Rd, adr, offset);\n+  }\n+}\n+\n+void MacroAssembler::la(Register Rd, const address dest) {\n@@ -770,0 +797,203 @@\n+void MacroAssembler::li32(Register Rd, int32_t imm) {\n+  \/\/ int32_t is in range 0x8000 0000 ~ 0x7fff ffff, and imm[31] is the sign bit\n+  int64_t upper = imm, lower = imm;\n+  lower = (imm << 20) >> 20;\n+  upper -= lower;\n+  upper = (int32_t)upper;\n+  \/\/ lui Rd, imm[31:12] + imm[11]\n+  lui(Rd, upper);\n+  \/\/ use addiw to distinguish li32 to li64\n+  addiw(Rd, Rd, lower);\n+}\n+\n+void MacroAssembler::li64(Register Rd, int64_t imm) {\n+  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n+  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n+  int64_t lower = imm & 0xffffffff;\n+  lower -= ((lower << 44) >> 44);\n+  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n+  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n+\n+  \/\/ Load upper 32 bits\n+  int64_t up = upper, lo = upper;\n+  lo = (lo << 52) >> 52;\n+  up -= lo;\n+  up = (int32_t)up;\n+  lui(Rd, up);\n+  addi(Rd, Rd, lo);\n+\n+  \/\/ Load the rest 32 bits.\n+  slli(Rd, Rd, 12);\n+  addi(Rd, Rd, (int32_t)lower >> 20);\n+  slli(Rd, Rd, 12);\n+  lower = ((int32_t)imm << 12) >> 20;\n+  addi(Rd, Rd, lower);\n+  slli(Rd, Rd, 8);\n+  lower = imm & 0xff;\n+  addi(Rd, Rd, lower);\n+}\n+\n+void MacroAssembler::li(Register Rd, int64_t imm) {\n+  \/\/ int64_t is in range 0x8000 0000 0000 0000 ~ 0x7fff ffff ffff ffff\n+  \/\/ li -> c.li\n+  if (do_compress() && (is_imm_in_range(imm, 6, 0) && Rd != x0)) {\n+    c_li(Rd, imm);\n+    return;\n+  }\n+\n+  int shift = 12;\n+  int64_t upper = imm, lower = imm;\n+  \/\/ Split imm to a lower 12-bit sign-extended part and the remainder,\n+  \/\/ because addi will sign-extend the lower imm.\n+  lower = ((int32_t)imm << 20) >> 20;\n+  upper -= lower;\n+\n+  \/\/ Test whether imm is a 32-bit integer.\n+  if (!(((imm) & ~(int64_t)0x7fffffff) == 0 ||\n+        (((imm) & ~(int64_t)0x7fffffff) == ~(int64_t)0x7fffffff))) {\n+    while (((upper >> shift) & 1) == 0) { shift++; }\n+    upper >>= shift;\n+    li(Rd, upper);\n+    slli(Rd, Rd, shift);\n+    if (lower != 0) {\n+      addi(Rd, Rd, lower);\n+    }\n+  } else {\n+    \/\/ 32-bit integer\n+    Register hi_Rd = zr;\n+    if (upper != 0) {\n+      lui(Rd, (int32_t)upper);\n+      hi_Rd = Rd;\n+    }\n+    if (lower != 0 || hi_Rd == zr) {\n+      addiw(Rd, hi_Rd, lower);\n+    }\n+  }\n+}\n+\n+#define INSN(NAME, REGISTER)                                       \\\n+  void MacroAssembler::NAME(const address dest, Register temp) {   \\\n+    assert_cond(dest != NULL);                                     \\\n+    int64_t distance = dest - pc();                                \\\n+    if (is_imm_in_range(distance, 20, 1)) {                        \\\n+      Assembler::jal(REGISTER, distance);                          \\\n+    } else {                                                       \\\n+      assert(temp != noreg, \"temp must not be empty register!\");   \\\n+      int32_t offset = 0;                                          \\\n+      movptr(temp, dest, offset);                                  \\\n+      Assembler::jalr(REGISTER, temp, offset);                     \\\n+    }                                                              \\\n+  }                                                                \\\n+\n+  INSN(j,   x0);\n+  INSN(jal, x1);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                       \\\n+  void MacroAssembler::NAME(const Address &adr, Register temp) {   \\\n+    switch (adr.getMode()) {                                       \\\n+      case Address::literal: {                                     \\\n+        relocate(adr.rspec(), [&] {                                \\\n+          NAME(adr.target(), temp);                                \\\n+        });                                                        \\\n+        break;                                                     \\\n+      }                                                            \\\n+      case Address::base_plus_offset: {                            \\\n+        int32_t offset = 0;                                        \\\n+        baseOffset(temp, adr, offset);                             \\\n+        Assembler::jalr(REGISTER, temp, offset);                   \\\n+        break;                                                     \\\n+      }                                                            \\\n+      default:                                                     \\\n+        ShouldNotReachHere();                                      \\\n+    }                                                              \\\n+  }\n+\n+  INSN(j,   x0);\n+  INSN(jal, x1);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                    \\\n+  void MacroAssembler::NAME(Register Rd, const address dest, Register temp) {         \\\n+    assert_cond(dest != NULL);                                                        \\\n+    int64_t distance = dest - pc();                                                   \\\n+    if (is_imm_in_range(distance, 20, 1)) {                                           \\\n+      Assembler::NAME(Rd, distance);                                                  \\\n+    } else {                                                                          \\\n+      assert_different_registers(Rd, temp);                                           \\\n+      int32_t offset = 0;                                                             \\\n+      movptr(temp, dest, offset);                                                     \\\n+      jalr(Rd, temp, offset);                                                         \\\n+    }                                                                                 \\\n+  }                                                                                   \\\n+  void MacroAssembler::NAME(Register Rd, Label &L, Register temp) {                   \\\n+    assert_different_registers(Rd, temp);                                             \\\n+    wrap_label(Rd, L, temp, &MacroAssembler::NAME);                                   \\\n+  }\n+\n+  INSN(jal);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                       \\\n+  void MacroAssembler::NAME(Label &l, Register temp) {             \\\n+    jal(REGISTER, l, temp);                                        \\\n+  }                                                                \\\n+\n+  INSN(j,   x0);\n+  INSN(jal, x1);\n+\n+#undef INSN\n+\n+void MacroAssembler::wrap_label(Register Rt, Label &L, Register tmp, load_insn_by_temp insn) {\n+  if (L.is_bound()) {\n+    (this->*insn)(Rt, target(L), tmp);\n+  } else {\n+    L.add_patch_at(code(), locator());\n+    (this->*insn)(Rt, pc(), tmp);\n+  }\n+}\n+\n+void MacroAssembler::wrap_label(Register Rt, Label &L, jal_jalr_insn insn) {\n+  if (L.is_bound()) {\n+    (this->*insn)(Rt, target(L));\n+  } else {\n+    L.add_patch_at(code(), locator());\n+    (this->*insn)(Rt, pc());\n+  }\n+}\n+\n+void MacroAssembler::wrap_label(Register r1, Register r2, Label &L,\n+                                compare_and_branch_insn insn,\n+                                compare_and_branch_label_insn neg_insn, bool is_far) {\n+  if (is_far) {\n+    Label done;\n+    (this->*neg_insn)(r1, r2, done, \/* is_far *\/ false);\n+    j(L);\n+    bind(done);\n+  } else {\n+    if (L.is_bound()) {\n+      (this->*insn)(r1, r2, target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(r1, r2, pc());\n+    }\n+  }\n+}\n+\n+#define INSN(NAME, NEG_INSN)                                                              \\\n+  void MacroAssembler::NAME(Register Rs1, Register Rs2, Label &L, bool is_far) {          \\\n+    wrap_label(Rs1, Rs2, L, &MacroAssembler::NAME, &MacroAssembler::NEG_INSN, is_far);    \\\n+  }\n+\n+  INSN(beq,  bne);\n+  INSN(bne,  beq);\n+  INSN(blt,  bge);\n+  INSN(bge,  blt);\n+  INSN(bltu, bgeu);\n+  INSN(bgeu, bltu);\n+\n+#undef INSN\n+\n@@ -771,1 +1001,1 @@\n-  void MacroAssembler::NAME##z(Register Rs, const address &dest) {                \\\n+  void MacroAssembler::NAME##z(Register Rs, const address dest) {                 \\\n@@ -787,0 +1017,15 @@\n+#define INSN(NAME, NEG_INSN)                                                      \\\n+  void MacroAssembler::NAME(Register Rs, Register Rt, const address dest) {       \\\n+    NEG_INSN(Rt, Rs, dest);                                                       \\\n+  }                                                                               \\\n+  void MacroAssembler::NAME(Register Rs, Register Rt, Label &l, bool is_far) {    \\\n+    NEG_INSN(Rt, Rs, l, is_far);                                                  \\\n+  }\n+\n+  INSN(bgt,  blt);\n+  INSN(ble,  bge);\n+  INSN(bgtu, bltu);\n+  INSN(bleu, bgeu);\n+\n+#undef INSN\n+\n@@ -789,8 +1034,8 @@\n-#define INSN(NAME, FLOATCMP, BRANCH)                                                                                   \\\n-  void MacroAssembler::float_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) {  \\\n-    FLOATCMP##_s(t0, Rs1, Rs2);                                                                                        \\\n-    BRANCH(t0, l, is_far);                                                                                             \\\n-  }                                                                                                                    \\\n-  void MacroAssembler::double_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) { \\\n-    FLOATCMP##_d(t0, Rs1, Rs2);                                                                                        \\\n-    BRANCH(t0, l, is_far);                                                                                             \\\n+#define INSN(NAME, FLOATCMP, BRANCH)                                                                                    \\\n+  void MacroAssembler::float_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) {   \\\n+    FLOATCMP##_s(t0, Rs1, Rs2);                                                                                         \\\n+    BRANCH(t0, l, is_far);                                                                                              \\\n+  }                                                                                                                     \\\n+  void MacroAssembler::double_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) {  \\\n+    FLOATCMP##_d(t0, Rs1, Rs2);                                                                                         \\\n+    BRANCH(t0, l, is_far);                                                                                              \\\n@@ -941,1 +1186,1 @@\n-  ld(Rd, esp, 0);\n+  ld(Rd, Address(esp, 0));\n@@ -1378,0 +1623,79 @@\n+void MacroAssembler::movptr(Register Rd, address addr, int32_t &offset) {\n+  int64_t imm64 = (int64_t)addr;\n+#ifndef PRODUCT\n+  {\n+    char buffer[64];\n+    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, imm64);\n+    block_comment(buffer);\n+  }\n+#endif\n+  assert(is_unsigned_imm_in_range(imm64, 47, 0) || (imm64 == (int64_t)-1),\n+         \"bit 47 overflows in address constant\");\n+  \/\/ Load upper 31 bits\n+  int64_t imm = imm64 >> 17;\n+  int64_t upper = imm, lower = imm;\n+  lower = (lower << 52) >> 52;\n+  upper -= lower;\n+  upper = (int32_t)upper;\n+  lui(Rd, upper);\n+  addi(Rd, Rd, lower);\n+\n+  \/\/ Load the rest 17 bits.\n+  slli(Rd, Rd, 11);\n+  addi(Rd, Rd, (imm64 >> 6) & 0x7ff);\n+  slli(Rd, Rd, 6);\n+\n+  \/\/ This offset will be used by following jalr\/ld.\n+  offset = imm64 & 0x3f;\n+}\n+\n+void MacroAssembler::movptr(Register Rd, uintptr_t imm64) {\n+  movptr(Rd, (address)imm64);\n+}\n+\n+void MacroAssembler::movptr(Register Rd, address addr) {\n+  int offset = 0;\n+  movptr(Rd, addr, offset);\n+  addi(Rd, Rd, offset);\n+}\n+\n+void MacroAssembler::add(Register Rd, Register Rn, int64_t increment, Register temp) {\n+  if (is_imm_in_range(increment, 12, 0)) {\n+    addi(Rd, Rn, increment);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, increment);\n+    add(Rd, Rn, temp);\n+  }\n+}\n+\n+void MacroAssembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\n+  if (is_imm_in_range(increment, 12, 0)) {\n+    addiw(Rd, Rn, increment);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, increment);\n+    addw(Rd, Rn, temp);\n+  }\n+}\n+\n+void MacroAssembler::sub(Register Rd, Register Rn, int64_t decrement, Register temp) {\n+  if (is_imm_in_range(-decrement, 12, 0)) {\n+    addi(Rd, Rn, -decrement);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, decrement);\n+    sub(Rd, Rn, temp);\n+  }\n+}\n+\n+void MacroAssembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n+  if (is_imm_in_range(-decrement, 12, 0)) {\n+    addiw(Rd, Rn, -decrement);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, decrement);\n+    subw(Rd, Rn, temp);\n+  }\n+}\n+\n@@ -3896,1 +4220,1 @@\n-    Assembler::sd(zr, Address(tmp, i * wordSize));\n+    sd(zr, Address(tmp, i * wordSize));\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":336,"deletions":12,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-  MacroAssembler(CodeBuffer* code) : Assembler(code) {\n-  }\n+  MacroAssembler(CodeBuffer* code) : Assembler(code) {}\n+\n@@ -53,0 +53,1 @@\n+\n@@ -274,1 +275,1 @@\n-    bool is_far = false\n+    bool     is_far = false\n@@ -404,1 +405,1 @@\n-  \/\/ Standard pseudoinstruction\n+  \/\/ Standard pseudo instructions\n@@ -417,1 +418,1 @@\n-  \/\/ Float pseudoinstruction\n+  \/\/ Floating-point data-processing pseudo instructions\n@@ -419,1 +420,1 @@\n-  void fabs_s(FloatRegister Rd, FloatRegister Rs);    \/\/ single-precision absolute value\n+  void fabs_s(FloatRegister Rd, FloatRegister Rs);\n@@ -421,2 +422,0 @@\n-\n-  \/\/ Double pseudoinstruction\n@@ -427,1 +426,1 @@\n-  \/\/ Pseudoinstruction for control and status register\n+  \/\/ Control and status pseudo instructions\n@@ -452,9 +451,17 @@\n-  void beqz(Register Rs, const address &dest);\n-  void bnez(Register Rs, const address &dest);\n-  void blez(Register Rs, const address &dest);\n-  void bgez(Register Rs, const address &dest);\n-  void bltz(Register Rs, const address &dest);\n-  void bgtz(Register Rs, const address &dest);\n-  void la(Register Rd, Label &label);\n-  void la(Register Rd, const address &dest);\n-  void la(Register Rd, const Address &adr);\n+  \/\/ Control transfer pseudo instructions\n+  void beqz(Register Rs, const address dest);\n+  void bnez(Register Rs, const address dest);\n+  void blez(Register Rs, const address dest);\n+  void bgez(Register Rs, const address dest);\n+  void bltz(Register Rs, const address dest);\n+  void bgtz(Register Rs, const address dest);\n+\n+  void j(Label &l, Register temp = t0);\n+  void j(const address dest, Register temp = t0);\n+  void j(const Address &adr, Register temp = t0);\n+  void jal(Label &l, Register temp = t0);\n+  void jal(const address dest, Register temp = t0);\n+  void jal(const Address &adr, Register temp = t0);\n+  void jal(Register Rd, Label &L, Register temp = t0);\n+  void jal(Register Rd, const address dest, Register temp = t0);\n+\n@@ -468,0 +475,47 @@\n+\n+  void beq (Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bne (Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void blt (Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bge (Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bltu(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bgeu(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+\n+  void bgt (Register Rs, Register Rt, const address dest);\n+  void ble (Register Rs, Register Rt, const address dest);\n+  void bgtu(Register Rs, Register Rt, const address dest);\n+  void bleu(Register Rs, Register Rt, const address dest);\n+\n+  void bgt (Register Rs, Register Rt, Label &l, bool is_far = false);\n+  void ble (Register Rs, Register Rt, Label &l, bool is_far = false);\n+  void bgtu(Register Rs, Register Rt, Label &l, bool is_far = false);\n+  void bleu(Register Rs, Register Rt, Label &l, bool is_far = false);\n+\n+#define INSN_ENTRY_RELOC(result_type, header)                               \\\n+  result_type header {                                                      \\\n+    guarantee(rtype == relocInfo::internal_word_type,                       \\\n+              \"only internal_word_type relocs make sense here\");            \\\n+    relocate(InternalAddress(dest).rspec());                                \\\n+    IncompressibleRegion ir(this);  \/* relocations *\/\n+\n+#define INSN(NAME)                                                                                       \\\n+  void NAME(Register Rs1, Register Rs2, const address dest) {                                            \\\n+    assert_cond(dest != NULL);                                                                           \\\n+    int64_t offset = dest - pc();                                                                        \\\n+    guarantee(is_imm_in_range(offset, 12, 1), \"offset is invalid.\");                                     \\\n+    Assembler::NAME(Rs1, Rs2, offset);                                                                   \\\n+  }                                                                                                      \\\n+  INSN_ENTRY_RELOC(void, NAME(Register Rs1, Register Rs2, address dest, relocInfo::relocType rtype))     \\\n+    NAME(Rs1, Rs2, dest);                                                                                \\\n+  }\n+\n+  INSN(beq);\n+  INSN(bne);\n+  INSN(bge);\n+  INSN(bgeu);\n+  INSN(blt);\n+  INSN(bltu);\n+\n+#undef INSN\n+\n+#undef INSN_ENTRY_RELOC\n+\n@@ -474,0 +528,1 @@\n+\n@@ -529,0 +584,22 @@\n+  typedef void (MacroAssembler::* compare_and_branch_insn)(Register Rs1, Register Rs2, const address dest);\n+  typedef void (MacroAssembler::* compare_and_branch_label_insn)(Register Rs1, Register Rs2, Label &L, bool is_far);\n+  typedef void (MacroAssembler::* jal_jalr_insn)(Register Rt, address dest);\n+  typedef void (MacroAssembler::* load_insn_by_temp)(Register Rt, address dest, Register temp);\n+\n+  void wrap_label(Register r, Label &L, Register t, load_insn_by_temp insn);\n+  void wrap_label(Register r, Label &L, jal_jalr_insn insn);\n+  void wrap_label(Register r1, Register r2, Label &L,\n+                  compare_and_branch_insn insn,\n+                  compare_and_branch_label_insn neg_insn, bool is_far = false);\n+\n+  void baseOffset(Register Rd, const Address &adr, int32_t &offset);\n+  void baseOffset32(Register Rd, const Address &adr, int32_t &offset);\n+\n+  void la(Register Rd, Label &label);\n+  void la(Register Rd, const address dest);\n+  void la(Register Rd, const Address &adr);\n+\n+  void li32(Register Rd, int32_t imm);\n+  void li64(Register Rd, int64_t imm);\n+  void li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n+\n@@ -546,0 +623,22 @@\n+  void movptr(Register Rd, address addr);\n+  void movptr(Register Rd, address addr, int32_t &offset);\n+  void movptr(Register Rd, uintptr_t imm64);\n+\n+  \/\/ arith\n+  void add (Register Rd, Register Rn, int64_t increment, Register temp = t0);\n+  void addw(Register Rd, Register Rn, int32_t increment, Register temp = t0);\n+  void sub (Register Rd, Register Rn, int64_t decrement, Register temp = t0);\n+  void subw(Register Rd, Register Rn, int32_t decrement, Register temp = t0);\n+\n+#define INSN(NAME)                                               \\\n+  inline void NAME(Register Rd, Register Rs1, Register Rs2) {    \\\n+    Assembler::NAME(Rd, Rs1, Rs2);                               \\\n+  }\n+\n+  INSN(add);\n+  INSN(addw);\n+  INSN(sub);\n+  INSN(subw);\n+\n+#undef INSN\n+\n@@ -565,0 +664,214 @@\n+\/\/ Load and Store Instructions\n+#define INSN_ENTRY_RELOC(result_type, header)                               \\\n+  result_type header {                                                      \\\n+    guarantee(rtype == relocInfo::internal_word_type,                       \\\n+              \"only internal_word_type relocs make sense here\");            \\\n+    relocate(InternalAddress(dest).rspec());                                \\\n+    IncompressibleRegion ir(this);  \/* relocations *\/\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(Register Rd, address dest) {                                                           \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    int64_t distance = dest - pc();                                                                \\\n+    if (is_offset_in_range(distance, 32)) {                                                        \\\n+      auipc(Rd, (int32_t)distance + 0x800);                                                        \\\n+      Assembler::NAME(Rd, Rd, ((int32_t)distance << 20) >> 20);                                    \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(Rd, dest, offset);                                                                    \\\n+      Assembler::NAME(Rd, Rd, offset);                                                             \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  INSN_ENTRY_RELOC(void, NAME(Register Rd, address dest, relocInfo::relocType rtype))              \\\n+    NAME(Rd, dest);                                                                                \\\n+  }                                                                                                \\\n+  void NAME(Register Rd, const Address &adr, Register temp = t0) {                                 \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        relocate(adr.rspec(), [&] {                                                                \\\n+          NAME(Rd, adr.target());                                                                  \\\n+        });                                                                                        \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rd, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset = 0;                                                                      \\\n+          if (Rd == adr.base()) {                                                                  \\\n+            baseOffset32(temp, adr, offset);                                                       \\\n+            Assembler::NAME(Rd, temp, offset);                                                     \\\n+          } else {                                                                                 \\\n+            baseOffset32(Rd, adr, offset);                                                         \\\n+            Assembler::NAME(Rd, Rd, offset);                                                       \\\n+          }                                                                                        \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  void NAME(Register Rd, Label &L) {                                                               \\\n+    wrap_label(Rd, L, &MacroAssembler::NAME);                                                      \\\n+  }\n+\n+  INSN(lb);\n+  INSN(lbu);\n+  INSN(lh);\n+  INSN(lhu);\n+  INSN(lw);\n+  INSN(lwu);\n+  INSN(ld);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(FloatRegister Rd, address dest, Register temp = t0) {                                  \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    int64_t distance = dest - pc();                                                                \\\n+    if (is_offset_in_range(distance, 32)) {                                                        \\\n+      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n+      Assembler::NAME(Rd, temp, ((int32_t)distance << 20) >> 20);                                  \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(temp, dest, offset);                                                                  \\\n+      Assembler::NAME(Rd, temp, offset);                                                           \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  INSN_ENTRY_RELOC(void, NAME(FloatRegister Rd, address dest,                                      \\\n+                              relocInfo::relocType rtype, Register temp = t0))                     \\\n+    NAME(Rd, dest, temp);                                                                          \\\n+  }                                                                                                \\\n+  void NAME(FloatRegister Rd, const Address &adr, Register temp = t0) {                            \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        relocate(adr.rspec(), [&] {                                                                \\\n+          NAME(Rd, adr.target(), temp);                                                            \\\n+        });                                                                                        \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rd, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset = 0;                                                                      \\\n+          baseOffset32(temp, adr, offset);                                                         \\\n+          Assembler::NAME(Rd, temp, offset);                                                       \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }\n+\n+  INSN(flw);\n+  INSN(fld);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                                                       \\\n+  INSN_ENTRY_RELOC(void, NAME(REGISTER Rs, address dest,                                           \\\n+                              relocInfo::relocType rtype, Register temp = t0))                     \\\n+    NAME(Rs, dest, temp);                                                                          \\\n+  }\n+\n+  INSN(sb,  Register);\n+  INSN(sh,  Register);\n+  INSN(sw,  Register);\n+  INSN(sd,  Register);\n+  INSN(fsw, FloatRegister);\n+  INSN(fsd, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(Register Rs, address dest, Register temp = t0) {                                       \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    assert_different_registers(Rs, temp);                                                          \\\n+    int64_t distance = dest - pc();                                                                \\\n+    if (is_offset_in_range(distance, 32)) {                                                        \\\n+      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n+      Assembler::NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                  \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(temp, dest, offset);                                                                  \\\n+      Assembler::NAME(Rs, temp, offset);                                                           \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  void NAME(Register Rs, const Address &adr, Register temp = t0) {                                 \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        assert_different_registers(Rs, temp);                                                      \\\n+        relocate(adr.rspec(), [&] {                                                                \\\n+          NAME(Rs, adr.target(), temp);                                                            \\\n+        });                                                                                        \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rs, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset= 0;                                                                       \\\n+          assert_different_registers(Rs, temp);                                                    \\\n+          baseOffset32(temp, adr, offset);                                                         \\\n+          Assembler::NAME(Rs, temp, offset);                                                       \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }\n+\n+  INSN(sb);\n+  INSN(sh);\n+  INSN(sw);\n+  INSN(sd);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(FloatRegister Rs, address dest, Register temp = t0) {                                  \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    int64_t distance = dest - pc();                                                                \\\n+    if (is_offset_in_range(distance, 32)) {                                                        \\\n+      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n+      Assembler::NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                  \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(temp, dest, offset);                                                                  \\\n+      Assembler::NAME(Rs, temp, offset);                                                           \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  void NAME(FloatRegister Rs, const Address &adr, Register temp = t0) {                            \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        relocate(adr.rspec(), [&] {                                                                \\\n+          NAME(Rs, adr.target(), temp);                                                            \\\n+        });                                                                                        \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rs, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset = 0;                                                                      \\\n+          baseOffset32(temp, adr, offset);                                                         \\\n+          Assembler::NAME(Rs, temp, offset);                                                       \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }\n+\n+  INSN(fsw);\n+  INSN(fsd);\n+\n+#undef INSN\n+\n+#undef INSN_ENTRY_RELOC\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":331,"deletions":18,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -2198,2 +2198,2 @@\n-  __ ld(fp, sp, 0);\n-  __ ld(ra, sp, wordSize);\n+  __ ld(fp, Address(sp, 0));\n+  __ ld(ra, Address(sp, wordSize));\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-    __ ld(t0, c_rarg5, 0);\n+    __ ld(t0, Address(c_rarg5, 0));\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1078,1 +1078,1 @@\n-    __ ld(t1, t1);\n+    __ ld(t1, Address(t1, 0));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-      __ flw(f10, t0, 0);\n+      __ flw(f10, Address(t0, 0));\n@@ -250,1 +250,1 @@\n-      __ flw(f10, t0, sizeof(float));\n+      __ flw(f10, Address(t0, sizeof(float)));\n@@ -266,1 +266,1 @@\n-      __ fld(f10, t0, 0);\n+      __ fld(f10, Address(t0, 0));\n@@ -269,1 +269,1 @@\n-      __ fld(f10, t0, sizeof(double));\n+      __ fld(f10, Address(t0, sizeof(double)));\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1933,0 +1933,28 @@\n+void Assembler::vcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/*uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x1D, (0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evcvtps2ph(Address dst, KRegister mask, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x1D);\n+  emit_operand(src, dst, 1);\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::vcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x13, (0xC0 | encode));\n+}\n+\n@@ -2132,0 +2160,7 @@\n+void Assembler::vcvttpd2dq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len <= AVX_256bit ? VM_Version::supports_avx() : VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE6, (0xC0 | encode));\n+}\n+\n@@ -2140,1 +2175,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2148,1 +2183,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2156,1 +2191,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2164,1 +2199,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2172,1 +2207,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2180,1 +2215,1 @@\n-  assert(UseAVX > 2  && VM_Version::supports_avx512bw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":41,"deletions":6,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1159,0 +1159,5 @@\n+  \/\/ Convert Halffloat to Single Precision Floating-Point value\n+  void vcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len);\n+  void vcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtps2ph(Address dst, KRegister mask, XMMRegister src, int imm8, int vector_len);\n+\n@@ -1199,0 +1204,3 @@\n+  \/\/ Convert vector double to int\n+  void vcvttpd2dq(XMMRegister dst, XMMRegister src, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4362,3 +4362,5 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                                            XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                                            Register rscratch) {\n+void C2_MacroAssembler::vector_cast_float_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                   XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                                                   Register rscratch, AddressLiteral float_sign_flip,\n+                                                                   int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4390,4 +4392,5 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                                             XMMRegister xtmp1, XMMRegister xtmp2,\n-                                                             KRegister ktmp1, KRegister ktmp2,\n-                                                             Register rscratch) {\n+void C2_MacroAssembler::vector_cast_float_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                    XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                    Register rscratch, AddressLiteral float_sign_flip,\n+                                                                    int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4411,5 +4414,4 @@\n-void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src,\n-                                                                     AddressLiteral double_sign_flip, int vec_enc,\n-                                                                     XMMRegister xtmp1, XMMRegister xtmp2,\n-                                                                     KRegister ktmp1, KRegister ktmp2,\n-                                                                     Register rscratch) {\n+void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                     XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                     Register rscratch, AddressLiteral double_sign_flip,\n+                                                                     int vec_enc) {\n@@ -4435,0 +4437,22 @@\n+void C2_MacroAssembler::vector_cast_double_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                     XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                     Register rscratch, AddressLiteral float_sign_flip,\n+                                                                     int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+  Label done;\n+  evmovdquq(xtmp1, k0, float_sign_flip, false, vec_enc, rscratch);\n+  Assembler::evpcmpeqd(ktmp1, k0, xtmp1, dst, vec_enc);\n+  kortestwl(ktmp1, ktmp1);\n+  jccb(Assembler::equal, done);\n+\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  evcmppd(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n+  evmovdqul(dst, ktmp2, xtmp2, true, vec_enc);\n+\n+  kxorwl(ktmp1, ktmp1, ktmp2);\n+  evcmppd(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n+  vpternlogq(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+  evmovdqul(dst, ktmp1, xtmp2, true, vec_enc);\n+  bind(done);\n+}\n+\n@@ -4443,4 +4467,4 @@\n-void C2_MacroAssembler::vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src,\n-                                                              AddressLiteral double_sign_flip, int vec_enc,\n-                                                              XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                              Register rscratch) {\n+void C2_MacroAssembler::vector_cast_double_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                      XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                      Register rscratch, AddressLiteral double_sign_flip,\n+                                                                      int vec_enc) {\n@@ -4466,0 +4490,76 @@\n+void C2_MacroAssembler::vector_crosslane_doubleword_pack_avx(XMMRegister dst, XMMRegister src, XMMRegister zero,\n+                                                             XMMRegister xtmp, int index, int vec_enc) {\n+   assert(vec_enc < Assembler::AVX_512bit, \"\");\n+   if (vec_enc == Assembler::AVX_256bit) {\n+     vextractf128_high(xtmp, src);\n+     vshufps(dst, src, xtmp, index, vec_enc);\n+   } else {\n+     vshufps(dst, src, zero, index, vec_enc);\n+   }\n+}\n+\n+void C2_MacroAssembler::vector_cast_double_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                                    XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5, Register rscratch,\n+                                                                    AddressLiteral float_sign_flip, int src_vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+\n+  Label done;\n+  \/\/ Compare the destination lanes with float_sign_flip\n+  \/\/ value to get mask for all special values.\n+  movdqu(xtmp1, float_sign_flip, rscratch);\n+  vpcmpeqd(xtmp2, dst, xtmp1, Assembler::AVX_128bit);\n+  ptest(xtmp2, xtmp2);\n+  jccb(Assembler::equal, done);\n+\n+  \/\/ Flip float_sign_flip to get max integer value.\n+  vpcmpeqd(xtmp4, xtmp4, xtmp4, Assembler::AVX_128bit);\n+  pxor(xtmp1, xtmp4);\n+\n+  \/\/ Set detination lanes corresponding to unordered source lanes as zero.\n+  vpxor(xtmp4, xtmp4, xtmp4, src_vec_enc);\n+  vcmppd(xtmp3, src, src, Assembler::UNORD_Q, src_vec_enc);\n+\n+  \/\/ Shuffle mask vector and pack lower doubles word from each quadword lane.\n+  vector_crosslane_doubleword_pack_avx(xtmp3, xtmp3, xtmp4, xtmp5, 0x88, src_vec_enc);\n+  vblendvps(dst, dst, xtmp4, xtmp3, Assembler::AVX_128bit);\n+\n+  \/\/ Recompute the mask for remaining special value.\n+  pxor(xtmp2, xtmp3);\n+  \/\/ Extract mask corresponding to non-negative source lanes.\n+  vcmppd(xtmp3, src, xtmp4, Assembler::NLT_UQ, src_vec_enc);\n+\n+  \/\/ Shuffle mask vector and pack lower doubles word from each quadword lane.\n+  vector_crosslane_doubleword_pack_avx(xtmp3, xtmp3, xtmp4, xtmp5, 0x88, src_vec_enc);\n+  pand(xtmp3, xtmp2);\n+\n+  \/\/ Replace destination lanes holding special value(0x80000000) with max int\n+  \/\/ if corresponding source lane holds a +ve value.\n+  vblendvps(dst, dst, xtmp1, xtmp3, Assembler::AVX_128bit);\n+  bind(done);\n+}\n+\n+\n+void C2_MacroAssembler::vector_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n+                                                   XMMRegister xtmp, Register rscratch, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_SHORT:\n+      assert(rscratch != noreg || always_reachable(ExternalAddress(StubRoutines::x86::vector_int_to_short_mask())), \"missing\");\n+      vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_short_mask()), vec_enc, rscratch);\n+      vpackusdw(dst, dst, zero, vec_enc);\n+      if (vec_enc == Assembler::AVX_256bit) {\n+        vector_crosslane_doubleword_pack_avx(dst, dst, zero, xtmp, 0x44, vec_enc);\n+      }\n+      break;\n+    case  T_BYTE:\n+      assert(rscratch != noreg || always_reachable(ExternalAddress(StubRoutines::x86::vector_int_to_byte_mask())), \"missing\");\n+      vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_byte_mask()), vec_enc, rscratch);\n+      vpackusdw(dst, dst, zero, vec_enc);\n+      if (vec_enc == Assembler::AVX_256bit) {\n+        vector_crosslane_doubleword_pack_avx(dst, dst, zero, xtmp, 0x44, vec_enc);\n+      }\n+      vpackuswb(dst, dst, zero, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n@@ -4476,13 +4576,5 @@\n-void C2_MacroAssembler::vector_castD2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n-\n-  evcvttpd2qq(dst, src, vec_enc);\n-  vector_cast_double_special_cases_evex(dst, src, double_sign_flip, vec_enc,\n-                                        xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n-}\n-\n-void C2_MacroAssembler::vector_castF2I_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                           XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-\n+void C2_MacroAssembler::vector_castF2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                           AddressLiteral float_sign_flip, Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz <= 4, \"\");\n@@ -4490,2 +4582,5 @@\n-  vector_cast_float_special_cases_avx(dst, src, float_sign_flip, vec_enc,\n-                                      xtmp1, xtmp2, xtmp3, xtmp4, rscratch);\n+  vector_cast_float_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, rscratch, float_sign_flip, vec_enc);\n+  if (to_elem_sz < 4) {\n+    vpxor(xtmp4, xtmp4, xtmp4, vec_enc);\n+    vector_cast_int_to_subword(to_elem_bt, dst, xtmp4, xtmp3, rscratch, vec_enc);\n+  }\n@@ -4494,4 +4589,5 @@\n-void C2_MacroAssembler::vector_castF2I_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-\n+void C2_MacroAssembler::vector_castF2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                            XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                                            Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz <= 4, \"\");\n@@ -4499,2 +4595,12 @@\n-  vector_cast_float_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n-                                       xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n+  vector_cast_float_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, float_sign_flip, vec_enc);\n+  switch(to_elem_bt) {\n+    case T_INT:\n+      break;\n+    case T_SHORT:\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n@@ -4503,4 +4609,3 @@\n-void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-\n+void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                            Register rscratch, int vec_enc) {\n@@ -4508,11 +4613,25 @@\n-  vector_cast_float_to_long_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n-                                               xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n-}\n-\n-void C2_MacroAssembler::vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n-\n-  vector_castD2L_evex(dst, src, double_sign_flip, vec_enc,\n-                      xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n-  if (to_elem_bt != T_LONG) {\n+  vector_cast_float_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, double_sign_flip, vec_enc);\n+}\n+\n+\/\/ Handling for downcasting from double to integer or sub-word types on AVX2.\n+void C2_MacroAssembler::vector_castD2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n+                                           AddressLiteral float_sign_flip, Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz < 8, \"\");\n+  vcvttpd2dq(dst, src, vec_enc);\n+  vector_cast_double_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, xtmp5, rscratch,\n+                                              float_sign_flip, vec_enc);\n+  if (to_elem_sz < 4) {\n+    \/\/ xtmp4 holds all zero lanes.\n+    vector_cast_int_to_subword(to_elem_bt, dst, xtmp4, xtmp5, rscratch, Assembler::AVX_128bit);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src,\n+                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1,\n+                                            KRegister ktmp2, AddressLiteral sign_flip,\n+                                            Register rscratch, int vec_enc) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evcvttpd2qq(dst, src, vec_enc);\n+    vector_cast_double_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, sign_flip, vec_enc);\n@@ -4520,0 +4639,2 @@\n+      case T_LONG:\n+        break;\n@@ -4533,0 +4654,15 @@\n+  } else {\n+    assert(type2aelembytes(to_elem_bt) <= 4, \"\");\n+    vcvttpd2dq(dst, src, vec_enc);\n+    vector_cast_double_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, sign_flip, vec_enc);\n+    switch(to_elem_bt) {\n+      case T_INT:\n+        break;\n+      case T_SHORT:\n+        evpmovdw(dst, dst, vec_enc);\n+        break;\n+      case T_BYTE:\n+        evpmovdb(dst, dst, vec_enc);\n+        break;\n+      default: assert(false, \"%s\", type2name(to_elem_bt));\n+    }\n@@ -4548,2 +4684,2 @@\n-  vector_cast_double_special_cases_evex(dst, src, double_sign_flip, vec_enc,\n-                                        xtmp1, xtmp2, ktmp1, ktmp2, tmp);\n+  vector_cast_double_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n+                                                double_sign_flip, vec_enc);;\n@@ -4566,2 +4702,2 @@\n-  vector_cast_float_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n-                                       xtmp1, xtmp2, ktmp1, ktmp2, tmp);\n+  vector_cast_float_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n+                                              float_sign_flip, vec_enc);\n@@ -4584,2 +4720,1 @@\n-  vector_cast_float_special_cases_avx(dst, src, float_sign_flip, vec_enc,\n-                                      xtmp1, xtmp2, xtmp3, xtmp4, tmp);\n+  vector_cast_float_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, tmp \/*rscratch*\/, float_sign_flip, vec_enc);\n@@ -4618,0 +4753,55 @@\n+void C2_MacroAssembler::vector_mask_cast(XMMRegister dst, XMMRegister src,\n+                                         BasicType dst_bt, BasicType src_bt, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(src_bt), type2aelembytes(dst_bt)) * vlen);\n+  assert(vlen_enc != AVX_512bit, \"\");\n+\n+  int dst_bt_size = type2aelembytes(dst_bt);\n+  int src_bt_size = type2aelembytes(src_bt);\n+  if (dst_bt_size > src_bt_size) {\n+    switch (dst_bt_size \/ src_bt_size) {\n+      case 2: vpmovsxbw(dst, src, vlen_enc); break;\n+      case 4: vpmovsxbd(dst, src, vlen_enc); break;\n+      case 8: vpmovsxbq(dst, src, vlen_enc); break;\n+      default: ShouldNotReachHere();\n+    }\n+  } else {\n+    assert(dst_bt_size < src_bt_size, \"\");\n+    switch (src_bt_size \/ dst_bt_size) {\n+      case 2: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpacksswb(dst, src, src, vlen_enc);\n+        } else {\n+          vpacksswb(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+        }\n+        break;\n+      }\n+      case 4: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      case 8: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, AVX_128bit);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      default: ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":248,"deletions":58,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -311,2 +311,2 @@\n-  void vector_castF2I_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                          XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, Register rscratch = noreg);\n+  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                            BasicType from_elem_bt, BasicType to_elem_bt);\n@@ -314,2 +314,2 @@\n-  void vector_castF2I_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n+  void vector_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n+                                  XMMRegister xtmp, Register rscratch, int vec_enc);\n@@ -317,2 +317,3 @@\n-  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n+  void vector_castF2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                          XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                          AddressLiteral float_sign_flip, Register rscratch, int vec_enc);\n@@ -320,2 +321,3 @@\n-  void vector_castD2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg );\n+  void vector_castF2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                           XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                           Register rscratch, int vec_enc);\n@@ -323,2 +325,3 @@\n-  void vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n+  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                           Register rscratch, int vec_enc);\n@@ -326,1 +329,3 @@\n-  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc, BasicType from_elem_bt, BasicType to_elem_bt);\n+  void vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                           XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral sign_flip,\n+                           Register rscratch, int vec_enc);\n@@ -328,2 +333,3 @@\n-  void vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg );\n+  void vector_castD2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                          XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n+                          AddressLiteral float_sign_flip, Register rscratch, int vec_enc);\n@@ -331,2 +337,0 @@\n-  void vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n@@ -334,3 +338,3 @@\n-  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                                                    XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                    Register rscratch = noreg);\n+  void vector_cast_double_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                   XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5, Register rscratch,\n+                                                   AddressLiteral float_sign_flip, int vec_enc);\n@@ -338,3 +342,24 @@\n-  void vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                           XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                           Register rscratch = noreg);\n+  void vector_cast_double_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                    KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral float_sign_flip,\n+                                                    int vec_enc);\n+\n+  void vector_cast_double_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                     KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral double_sign_flip,\n+                                                     int vec_enc);\n+\n+  void vector_cast_float_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                   KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral float_sign_flip,\n+                                                   int vec_enc);\n+\n+  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                    KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral double_sign_flip,\n+                                                    int vec_enc);\n+\n+  void vector_cast_float_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                                  XMMRegister xtmp4, Register rscratch, AddressLiteral float_sign_flip,\n+                                                  int vec_enc);\n+\n+  void vector_crosslane_doubleword_pack_avx(XMMRegister dst, XMMRegister src, XMMRegister zero,\n+                                            XMMRegister xtmp, int index, int vec_enc);\n+\n+  void vector_mask_cast(XMMRegister dst, XMMRegister src, BasicType dst_bt, BasicType src_bt, int vlen);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":46,"deletions":21,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -187,0 +187,3 @@\n+  \/\/ Currently, it's a rudimentary heuristic based on emitted code size for complex\n+  \/\/ IR nodes used by unroll policy. Idea is to constrain unrolling factor and prevent\n+  \/\/ generating bloated loop bodies.\n@@ -191,0 +194,4 @@\n+      case Op_VectorCastF2X: \/\/ fall through\n+      case Op_VectorCastD2X: {\n+        return is_floating_point_type(ety) ? 0 : (is_subword_type(ety) ? 35 : 30);\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#ifdef COMPILER2\n+\n+#include \"peephole_x86_64.hpp\"\n+\n+\/\/ This function transforms the shapes\n+\/\/ mov d, s1; add d, s2 into\n+\/\/ lea d, [s1 + s2]     and\n+\/\/ mov d, s1; shl d, s2 into\n+\/\/ lea d, [s1 << s2]    with s2 = 1, 2, 3\n+bool lea_coalesce_helper(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                         MachNode* (*new_root)(), uint inst0_rule, bool imm) {\n+  MachNode* inst0 = block->get_node(block_index)->as_Mach();\n+  assert(inst0->rule() == inst0_rule, \"sanity\");\n+\n+  OptoReg::Name dst = ra_->get_reg_first(inst0);\n+  MachNode* inst1 = nullptr;\n+  OptoReg::Name src1 = OptoReg::Bad;\n+\n+  if (inst0->in(1)->is_MachSpillCopy()) {\n+    OptoReg::Name in = ra_->get_reg_first(inst0->in(1)->in(1));\n+    if (OptoReg::is_reg(in) && OptoReg::as_VMReg(in)->is_Register()) {\n+      inst1 = inst0->in(1)->as_Mach();\n+      src1 = in;\n+    }\n+  }\n+  if (inst1 == nullptr) {\n+    return false;\n+  }\n+  assert(dst != src1, \"\");\n+\n+  \/\/ Only coalesce if inst1 is immediately followed by inst0\n+  \/\/ Can be improved for more general cases\n+  if (block_index < 1 || block->get_node(block_index - 1) != inst1) {\n+    return false;\n+  }\n+  int inst1_index = block_index - 1;\n+  Node* inst2;\n+  if (imm) {\n+    inst2 = nullptr;\n+  } else {\n+    inst2 = inst0->in(2);\n+    if (inst2 == inst1) {\n+      inst2 = inst2->in(1);\n+    }\n+  }\n+\n+  \/\/ See VM_Version::supports_fast_3op_lea()\n+  if (!imm) {\n+    Register rsrc1 = OptoReg::as_VMReg(src1)->as_Register();\n+    Register rsrc2 = OptoReg::as_VMReg(ra_->get_reg_first(inst2))->as_Register();\n+    if ((rsrc1 == rbp || rsrc1 == r13) && (rsrc2 == rbp || rsrc2 == r13)) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Go down the block to find the output proj node (the flag output) of inst0\n+  int proj_index = -1;\n+  Node* proj = nullptr;\n+  for (uint pos = block_index + 1; pos < block->number_of_nodes(); pos++) {\n+    Node* curr = block->get_node(pos);\n+    if (curr->is_MachProj() && curr->in(0) == inst0) {\n+      proj_index = pos;\n+      proj = curr;\n+      break;\n+    }\n+  }\n+  assert(proj != nullptr, \"\");\n+  \/\/ If some node uses the flag, cannot remove\n+  if (proj->outcnt() > 0) {\n+    return false;\n+  }\n+\n+  MachNode* root = new_root();\n+  \/\/ Assign register for the newly allocated node\n+  ra_->set_oop(root, ra_->is_oop(inst0));\n+  ra_->set_pair(root->_idx, ra_->get_reg_second(inst0), ra_->get_reg_first(inst0));\n+\n+  \/\/ Set input and output for the node\n+  root->add_req(inst0->in(0));\n+  root->add_req(inst1->in(1));\n+  \/\/ No input for constant after matching\n+  if (!imm) {\n+    root->add_req(inst2);\n+  }\n+  inst0->replace_by(root);\n+  proj->set_req(0, inst0);\n+\n+  \/\/ Initialize the operand array\n+  root->_opnds[0] = inst0->_opnds[0]->clone();\n+  root->_opnds[1] = inst0->_opnds[1]->clone();\n+  root->_opnds[2] = inst0->_opnds[2]->clone();\n+\n+  \/\/ Modify the block\n+  inst0->set_removed();\n+  inst1->set_removed();\n+  block->remove_node(proj_index);\n+  block->remove_node(block_index);\n+  block->remove_node(inst1_index);\n+  block->insert_node(root, block_index - 1);\n+\n+  \/\/ Modify the CFG\n+  cfg_->map_node_to_block(inst0, nullptr);\n+  cfg_->map_node_to_block(inst1, nullptr);\n+  cfg_->map_node_to_block(proj, nullptr);\n+  cfg_->map_node_to_block(root, block);\n+\n+  return true;\n+}\n+\n+bool Peephole::lea_coalesce_reg(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                                MachNode* (*new_root)(), uint inst0_rule) {\n+  return lea_coalesce_helper(block, block_index, cfg_, ra_, new_root, inst0_rule, false);\n+}\n+\n+bool Peephole::lea_coalesce_imm(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                                MachNode* (*new_root)(), uint inst0_rule) {\n+  return lea_coalesce_helper(block, block_index, cfg_, ra_, new_root, inst0_rule, true);\n+}\n+\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.cpp","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_PEEPHOLE_X86_64_HPP\n+#define CPU_X86_PEEPHOLE_X86_64_HPP\n+\n+#include \"opto\/machnode.hpp\"\n+#include \"opto\/regalloc.hpp\"\n+\n+class Peephole {\n+public:\n+  static bool lea_coalesce_reg(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                               MachNode* (*new_root)(), uint inst0_rule);\n+  static bool lea_coalesce_imm(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                               MachNode* (*new_root)(), uint inst0_rule);\n+};\n+\n+#endif \/\/ CPU_X86_PEEPHOLE_X86_64_HPP\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -2886,0 +2886,2 @@\n+    if (_cpuid_info.std_cpuid1_ecx.bits.f16c != 0)\n+      result |= CPU_F16C;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-                        : 2,\n+               f16c     : 1,\n+                        : 1,\n@@ -377,1 +378,2 @@\n-    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\n+    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n+    decl(F16C,              \"f16c\",              53) \/* Half-precision and single precision FP conversion instructions*\/\n@@ -684,0 +686,1 @@\n+  static bool supports_f16c()         { return (_features & CPU_F16C) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1395,0 +1395,2 @@\n+  static address vector_float_signflip() { return StubRoutines::x86::vector_float_sign_flip();}\n+  static address vector_double_signflip() { return StubRoutines::x86::vector_double_sign_flip();}\n@@ -1481,0 +1483,1 @@\n+    case Op_VectorMaskCast:\n@@ -1681,0 +1684,6 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      if (!VM_Version::supports_f16c() && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1852,0 +1861,1 @@\n+    case Op_VectorMaskCast:\n@@ -1880,8 +1890,6 @@\n-    case Op_VectorCastD2X:\n-      \/\/ Conversion to integral type is only supported on AVX-512 platforms with avx512dq.\n-      \/\/ Need avx512vl for size_in_bits < 512\n-      if (is_integral_type(bt)) {\n-        if (!VM_Version::supports_avx512dq()) {\n-          return false;\n-        }\n-        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+    case Op_VectorCastF2X: {\n+        \/\/ As per JLS section 5.1.3 narrowing conversion to sub-word types\n+        \/\/ happen after intermediate conversion to integer and special handling\n+        \/\/ code needs AVX2 vpcmpeqd instruction for 256 bit vectors.\n+        int src_size_in_bits = type2aelembytes(T_FLOAT) * vlen * BitsPerByte;\n+        if (is_integral_type(bt) && src_size_in_bits == 256 && UseAVX < 2) {\n@@ -1891,0 +1899,5 @@\n+      \/\/ fallthrough\n+    case Op_VectorCastD2X:\n+      if (bt == T_LONG && !VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n@@ -1897,17 +1910,0 @@\n-    case Op_VectorCastF2X:\n-      \/\/ F2I is supported on all AVX and above platforms\n-      \/\/ For conversion to other integral types need AVX512:\n-      \/\/     Conversion to long in addition needs avx512dq\n-      \/\/     Need avx512vl for size_in_bits < 512\n-      if (is_integral_type(bt) && (bt != T_INT)) {\n-        if (UseAVX <= 2) {\n-          return false;\n-        }\n-        if ((bt == T_LONG) && !VM_Version::supports_avx512dq()) {\n-          return false;\n-        }\n-        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n-          return false;\n-        }\n-      }\n-      break;\n@@ -3655,0 +3651,35 @@\n+instruct convF2HF_reg_reg(rRegI dst, regF src, regF tmp) %{\n+  effect(TEMP tmp);\n+  match(Set dst (ConvF2HF src));\n+  ins_cost(125);\n+  format %{ \"vcvtps2ph $dst,$src \\t using $tmp as TEMP\"%}\n+  ins_encode %{\n+    __ vcvtps2ph($tmp$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+    __ movdl($dst$$Register, $tmp$$XMMRegister);\n+    __ movswl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct convF2HF_mem_reg(memory mem, regF src, kReg ktmp, rRegI rtmp) %{\n+  predicate((UseAVX > 2) && VM_Version::supports_avx512vl());\n+  effect(TEMP ktmp, TEMP rtmp);\n+  match(Set mem (StoreC mem (ConvF2HF src)));\n+  format %{ \"evcvtps2ph $mem,$src \\t using $ktmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    __ movl($rtmp$$Register, 0x1);\n+    __ kmovwl($ktmp$$KRegister, $rtmp$$Register);\n+    __ evcvtps2ph($mem$$Address, $ktmp$$KRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct convHF2F_reg_reg(regF dst, rRegI src) %{\n+  match(Set dst (ConvHF2F src));\n+  format %{ \"vcvtph2ps $dst,$src\" %}\n+  ins_encode %{\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+    __ vcvtph2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -7338,6 +7369,3 @@\n-instruct castFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rFlagsReg cr) %{\n-  \/\/ F2I conversion for < 64 byte vector using AVX instructions\n-  \/\/ AVX512 platforms that dont support avx512vl also use AVX instructions to support F2I\n-  predicate(!VM_Version::supports_avx512vl() &&\n-            Matcher::vector_length_in_bytes(n) < 64 &&\n-            Matcher::vector_element_basic_type(n) == T_INT);\n+instruct castFtoX_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 4);\n@@ -7346,17 +7374,1 @@\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_castF2I_avx($dst$$XMMRegister, $src$$XMMRegister,\n-                          ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n-                          $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct castFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n-  predicate((VM_Version::supports_avx512vl() ||\n-             Matcher::vector_length_in_bytes(n) == 64) &&\n-             Matcher::vector_element_basic_type(n) == T_INT);\n-  match(Set dst (VectorCastF2X src));\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, KILL cr);\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n@@ -7364,4 +7376,12 @@\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister,\n-                           ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n-                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    \/\/ JDK-8292878 removed the need for an explicit scratch register needed to load greater than\n+    \/\/ 32 bit addresses for register indirect addressing mode since stub constants\n+    \/\/ are part of code cache and there is a cap of 2G on ReservedCodeCacheSize currently.\n+    \/\/ However, targets are free to increase this limit, but having a large code cache size\n+    \/\/ greater than 2G looks unreasonable in practical scenario, on the hind side with given\n+    \/\/ cap we save a temporary register allocation which in limiting case can prevent\n+    \/\/ spilling in high register pressure blocks.\n+    __ vector_castF2X_avx(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                          $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister,\n+                          ExternalAddress(vector_float_signflip()), noreg, vlen_enc);\n@@ -7373,4 +7393,2 @@\n-  \/\/ F2X conversion for integral non T_INT target using AVX512 instructions\n-  \/\/ Platforms that dont support avx512vl can only support 64 byte vectors\n-  predicate(is_integral_type(Matcher::vector_element_basic_type(n)) &&\n-            Matcher::vector_element_basic_type(n) != T_INT);\n+  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7379,1 +7397,1 @@\n-  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n@@ -7384,3 +7402,3 @@\n-      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister,\n-                             ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vlen_enc,\n-                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_double_signflip()), noreg, vlen_enc);\n@@ -7389,9 +7407,3 @@\n-      __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister,\n-                             ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n-                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n-      if (to_elem_bt == T_SHORT) {\n-        __ evpmovdw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      } else {\n-        assert(to_elem_bt == T_BYTE, \"required\");\n-        __ evpmovdb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      }\n+      __ vector_castF2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_float_signflip()), noreg, vlen_enc);\n@@ -7414,0 +7426,16 @@\n+instruct castDtoX_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, vec xtmp5, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP xtmp5, KILL cr);\n+  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 and $xtmp5 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_castD2X_avx(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                          $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister, $xtmp5$$XMMRegister,\n+                          ExternalAddress(vector_float_signflip()), noreg, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7415,1 +7443,2 @@\n-  predicate(is_integral_type(Matcher::vector_element_basic_type(n)));\n+  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7418,1 +7447,1 @@\n-  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n@@ -7422,3 +7451,4 @@\n-    __ vector_castD2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister,\n-                           ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vlen_enc,\n-                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    AddressLiteral signflip = VM_Version::supports_avx512dq() ? ExternalAddress(vector_double_signflip()) :\n+                              ExternalAddress(vector_float_signflip());\n+    __ vector_castD2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                           $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister, signflip, noreg, vlen_enc);\n@@ -8388,1 +8418,0 @@\n-  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)));\n@@ -8399,2 +8428,1 @@\n-  predicate((Matcher::vector_length(n) == Matcher::vector_length(n->in(1))) &&\n-            (Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1))));\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n@@ -8410,0 +8438,13 @@\n+instruct vmaskcast_avx(vec dst, vec src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vector_mask_cast $dst, $src\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast($dst$$XMMRegister, $src$$XMMRegister, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":118,"deletions":77,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -660,2 +660,2 @@\n-    st->print(\"CMPL     rsp, poll_offset[thread]  \\n\\t\"\n-              \"JA       #safepoint_stub\\t\"\n+    st->print(\"CMPL    rsp, poll_offset[thread]  \\n\\t\"\n+              \"JA      #safepoint_stub\\t\"\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -322,0 +322,8 @@\n+\n+source_hpp %{\n+\n+#include \"peephole_x86_64.hpp\"\n+\n+%}\n+\n+\/\/ Register masks\n@@ -964,2 +972,2 @@\n-    st->print_cr(\"cmpq     rsp, poll_offset[r15_thread] \\n\\t\"\n-                 \"ja       #safepoint_stub\\t\"\n+    st->print_cr(\"cmpq    rsp, poll_offset[r15_thread] \\n\\t\"\n+                 \"ja      #safepoint_stub\\t\"\n@@ -9004,0 +9012,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salI_rReg_immI2(rRegI dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9238,0 +9259,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salL_rReg_immI2(rRegL dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -13544,0 +13578,3 @@\n+\/\/ peeppredicate ( rule_predicate );\n+\/\/ \/\/ the predicate unless which the peephole rule will be ignored\n+\/\/\n@@ -13546,0 +13583,10 @@\n+\/\/ peepprocedure ( procedure_name );\n+\/\/ \/\/ provide a procedure name to perform the optimization, the procedure should\n+\/\/ \/\/ reside in the architecture dependent peephole file, the method has the\n+\/\/ \/\/ signature of MachNode* (Block*, int, PhaseRegAlloc*, (MachNode*)(*)(), int...)\n+\/\/ \/\/ with the arguments being the basic block, the current node index inside the\n+\/\/ \/\/ block, the register allocator, the functions upon invoked return a new node\n+\/\/ \/\/ defined in peepreplace, and the rules of the nodes appearing in the\n+\/\/ \/\/ corresponding peepmatch, the function return true if successful, else\n+\/\/ \/\/ return false\n+\/\/\n@@ -13566,4 +13613,1 @@\n-\/\/ Only match adjacent instructions in same basic block\n-\/\/ Only equality constraints\n-\/\/ Only constraints between operands, not (0.dest_reg == RAX_enc)\n-\/\/ Only one replacement instruction\n+\/\/ Only transformations inside a basic block (do we need more for peephole)\n@@ -13585,0 +13629,11 @@\n+\/\/ instruct leaI_rReg_immI(rRegI dst, immI_1 src)\n+\/\/ %{\n+\/\/   match(Set dst (AddI dst src));\n+\/\/ %}\n+\/\/\n+\/\/ 1. Simple replacement\n+\/\/ - Only match adjacent instructions in same basic block\n+\/\/ - Only equality constraints\n+\/\/ - Only constraints between operands, not (0.dest_reg == RAX_enc)\n+\/\/ - Only one replacement instruction\n+\/\/\n@@ -13587,0 +13642,2 @@\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n@@ -13597,3 +13654,6 @@\n-\n-\/\/ Implementation no longer uses movX instructions since\n-\/\/ machine-independent system no longer uses CopyX nodes.\n+\/\/ 2. Procedural replacement\n+\/\/ - More flexible finding relevent nodes\n+\/\/ - More flexible constraints\n+\/\/ - More flexible transformations\n+\/\/ - May utilise architecture-dependent API more effectively\n+\/\/ - Currently only one replacement instruction due to adlc parsing capabilities\n@@ -13601,5 +13661,11 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n+\/\/ \/\/ Change (inc mov) to lea\n+\/\/ peephole %{\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n+\/\/   \/\/ the rule numbers of these nodes inside are passed into the function below\n+\/\/   peepmatch ( incI_rReg movI );\n+\/\/   \/\/ the method that takes the responsibility of transformation\n+\/\/   peepprocedure ( inc_mov_to_lea );\n+\/\/   \/\/ the replacement is a leaI_rReg_immI, a lambda upon invoked creating this\n+\/\/   \/\/ node is passed into the function above\n+\/\/   peepreplace ( leaI_rReg_immI() );\n@@ -13608,6 +13674,19 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+\/\/ These instructions is not matched by the matcher but used by the peephole\n+instruct leaI_rReg_rReg_peep(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leal(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leal(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13615,6 +13694,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addI_rReg_imm movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI_peep(rRegI dst, rRegI src1, immI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leal($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13622,6 +13705,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI2_peep(rRegI dst, rRegI src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftI src shift));\n+  format %{ \"leal    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leal($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leal($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13629,6 +13722,18 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_rReg_peep(rRegL dst, rRegL src1, rRegL src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leaq(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leaq(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13636,6 +13741,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addL_rReg_imm movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immL32_peep(rRegL dst, rRegL src1, immL32 src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13643,6 +13752,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addP_rReg_imm movP);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immI2_peep(rRegL dst, rRegL src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftL src shift));\n+  format %{ \"leaq    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leaq($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leaq($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13650,11 +13769,63 @@\n-\/\/ \/\/ Change load of spilled value to only a spill\n-\/\/ instruct storeI(memory mem, rRegI src)\n-\/\/ %{\n-\/\/   match(Set mem (StoreI mem src));\n-\/\/ %}\n-\/\/\n-\/\/ instruct loadI(rRegI dst, memory mem)\n-\/\/ %{\n-\/\/   match(Set dst (LoadI mem));\n-\/\/ %}\n-\/\/\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaI_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salI_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI2_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaL_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n@@ -13664,3 +13835,4 @@\n-  peepmatch (loadI storeI);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeI(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n@@ -13671,3 +13843,4 @@\n-  peepmatch (loadL storeL);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeL(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salL_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immI2_peep());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":240,"deletions":67,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -947,1 +947,0 @@\n-\/\/ ported from solaris version\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1375,44 +1375,0 @@\n-struct _address_to_library_name {\n-  address addr;          \/\/ input : memory address\n-  size_t  buflen;        \/\/         size of fname\n-  char*   fname;         \/\/ output: library name\n-  address base;          \/\/         library base addr\n-};\n-\n-static int address_to_library_name_callback(struct dl_phdr_info *info,\n-                                            size_t size, void *data) {\n-  int i;\n-  bool found = false;\n-  address libbase = NULL;\n-  struct _address_to_library_name * d = (struct _address_to_library_name *)data;\n-\n-  \/\/ iterate through all loadable segments\n-  for (i = 0; i < info->dlpi_phnum; i++) {\n-    address segbase = (address)(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);\n-    if (info->dlpi_phdr[i].p_type == PT_LOAD) {\n-      \/\/ base address of a library is the lowest address of its loaded\n-      \/\/ segments.\n-      if (libbase == NULL || libbase > segbase) {\n-        libbase = segbase;\n-      }\n-      \/\/ see if 'addr' is within current segment\n-      if (segbase <= d->addr &&\n-          d->addr < segbase + info->dlpi_phdr[i].p_memsz) {\n-        found = true;\n-      }\n-    }\n-  }\n-\n-  \/\/ dlpi_name is NULL or empty if the ELF file is executable, return 0\n-  \/\/ so dll_address_to_library_name() can fall through to use dladdr() which\n-  \/\/ can figure out executable name from argv[0].\n-  if (found && info->dlpi_name && info->dlpi_name[0]) {\n-    d->base = libbase;\n-    if (d->fname) {\n-      jio_snprintf(d->fname, d->buflen, \"%s\", info->dlpi_name);\n-    }\n-    return 1;\n-  }\n-  return 0;\n-}\n-\n@@ -1422,1 +1378,1 @@\n-  assert(buf != NULL, \"sanity check\");\n+  assert(buf != nullptr, \"sanity check\");\n@@ -1425,18 +1381,0 @@\n-  struct _address_to_library_name data;\n-\n-  \/\/ There is a bug in old glibc dladdr() implementation that it could resolve\n-  \/\/ to wrong library name if the .so file has a base address != NULL. Here\n-  \/\/ we iterate through the program headers of all loaded libraries to find\n-  \/\/ out which library 'addr' really belongs to. This workaround can be\n-  \/\/ removed once the minimum requirement for glibc is moved to 2.3.x.\n-  data.addr = addr;\n-  data.fname = buf;\n-  data.buflen = buflen;\n-  data.base = NULL;\n-  int rslt = dl_iterate_phdr(address_to_library_name_callback, (void *)&data);\n-\n-  if (rslt) {\n-    \/\/ buf already contains library name\n-    if (offset) *offset = addr - data.base;\n-    return true;\n-  }\n@@ -1444,1 +1382,1 @@\n-    if (dlinfo.dli_fname != NULL) {\n+    if (dlinfo.dli_fname != nullptr) {\n@@ -1447,1 +1385,1 @@\n-    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n+    if (dlinfo.dli_fbase != nullptr && offset != nullptr) {\n@@ -1452,1 +1390,0 @@\n-\n@@ -1458,5 +1395,0 @@\n-\/\/ Loads .dll\/.so and\n-\/\/ in case of error it checks if .dll\/.so was built for the\n-\/\/ same architecture as Hotspot is running on\n-\n-\n@@ -2377,1 +2309,1 @@\n-static void print_sys_devices_cpu_info(outputStream* st, char* buf, size_t buflen) {\n+static void print_sys_devices_cpu_info(outputStream* st) {\n@@ -2430,1 +2362,1 @@\n-  print_sys_devices_cpu_info(st, buf, buflen);\n+  print_sys_devices_cpu_info(st);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":5,"deletions":73,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -1702,1 +1702,0 @@\n-#if _MSC_VER >= 1900\n@@ -1711,23 +1710,0 @@\n-#else\n-  \/\/ Before Visual Studio 2015, vsnprintf is not C99 compliant, so use\n-  \/\/ _vsnprintf, whose behavior seems to be *mostly* consistent across\n-  \/\/ versions.  However, when len == 0, avoid _vsnprintf too, and just\n-  \/\/ go straight to _vscprintf.  The output is going to be truncated in\n-  \/\/ that case, except in the unusual case of empty output.  More\n-  \/\/ importantly, the documentation for various versions of Visual Studio\n-  \/\/ are inconsistent about the behavior of _vsnprintf when len == 0,\n-  \/\/ including it possibly being an error.\n-  int result = -1;\n-  if (len > 0) {\n-    result = _vsnprintf(buf, len, fmt, args);\n-    \/\/ If output (including NUL terminator) is truncated, the buffer\n-    \/\/ won't be NUL terminated.  Add the trailing NUL specified by C99.\n-    if ((result < 0) || ((size_t)result >= len)) {\n-      buf[len - 1] = '\\0';\n-    }\n-  }\n-  if (result < 0) {\n-    result = _vscprintf(fmt, args);\n-  }\n-  return result;\n-#endif \/\/ _MSC_VER dispatch\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,4 +49,0 @@\n-#if _MSC_VER < 1900\n-#define snprintf _snprintf\n-#endif\n-\n","filename":"src\/hotspot\/share\/adlc\/adlc.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2049,1 +2049,3 @@\n-      if (strcmp(token,\"peepmatch\")==0) {\n+      if (strcmp(token,\"peeppredicate\")==0) {\n+        peep_predicate_parse(*peep); }\n+      else if (strcmp(token,\"peepmatch\")==0) {\n@@ -2051,0 +2053,2 @@\n+      else if (strcmp(token, \"peepprocedure\")==0) {\n+        peep_procedure_parse(*peep); }\n@@ -2056,1 +2060,3 @@\n-        parse_err(SYNERR, \"expected peepmatch, peepconstraint, or peepreplace for identifier %s.\\n\", token);\n+        parse_err(SYNERR,\n+            \"expected peeppreddicate, peepmatch, peepprocedure, peepconstraint, peepreplace, received %s.\\n\",\n+            token);\n@@ -2540,0 +2546,25 @@\n+\/\/---------------------------peep-predicate-parse------------------------------\n+\/\/ Syntax for a peeppredicate rule\n+\/\/\n+\/\/ peeppredicate ( predicate );\n+\/\/\n+void ADLParser::peep_predicate_parse(Peephole& peep) {\n+\n+  skipws();\n+  char* rule = nullptr;\n+  if ( (rule = get_paren_expr(\"pred expression\", true)) == nullptr ) {\n+    parse_err(SYNERR, \"incorrect or missing expression for 'peeppredicate'\\n\");\n+    return;\n+  }\n+  if (_curchar != ';') {\n+    parse_err(SYNERR, \"missing ';' in peeppredicate definition\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip ';'\n+  skipws();\n+\n+  \/\/ Construct PeepPredicate\n+  PeepPredicate* predicate = new PeepPredicate(rule);\n+  peep.add_predicate(predicate);\n+}\n+\n@@ -2586,0 +2617,40 @@\n+\/\/---------------------------peep-procedure-parse------------------------------\n+\/\/ Syntax for a peepprocedure rule\n+\/\/\n+\/\/ peeppredicate ( function_name );\n+\/\/\n+void ADLParser::peep_procedure_parse(Peephole& peep) {\n+\n+  skipws();\n+  \/\/ Check for open paren\n+  if (_curchar != '(') {\n+    parse_err(SYNERR, \"missing '(' at start of peepprocedure rule.\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip '('\n+  skipws();\n+\n+  char* name = nullptr;\n+  if ( (name = get_ident_dup()) == nullptr ) {\n+    parse_err(SYNERR, \"incorrect or missing expression for 'peepprocedure'\\n\");\n+    return;\n+  }\n+\n+  skipws();\n+  if (_curchar != ')') {\n+    parse_err(SYNERR, \"peepprocedure should contain a single identifier only\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip ')'\n+  if (_curchar != ';') {\n+    parse_err(SYNERR, \"missing ';' in peepprocedure definition\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip ';'\n+  skipws();\n+\n+  \/\/ Construct PeepProcedure\n+  PeepProcedure* procedure = new PeepProcedure(name);\n+  peep.add_procedure(procedure);\n+}\n+\n@@ -2632,1 +2703,1 @@\n-    int right_inst;        \/\/ Right-instructions's number\n+    int right_inst;        \/\/ Right-instruction's number\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":74,"deletions":3,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+class PeepPredicate;\n@@ -66,0 +67,1 @@\n+class PeepProcedure;\n@@ -139,0 +141,1 @@\n+  void peep_predicate_parse(Peephole &peep); \/\/ Parse the peephole predicate\n@@ -140,0 +143,1 @@\n+  void peep_procedure_parse(Peephole &peep); \/\/ Parse the peephole procedure\n","filename":"src\/hotspot\/share\/adlc\/adlparse.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -638,1 +638,2 @@\n-Peephole::Peephole() : _match(NULL), _constraint(NULL), _replace(NULL), _next(NULL) {\n+Peephole::Peephole() : _predicate(NULL), _match(NULL), _procedure(NULL),\n+                       _constraint(NULL), _replace(NULL), _next(NULL) {\n@@ -653,0 +654,6 @@\n+\/\/ Add a predicate to this peephole rule\n+void Peephole::add_predicate(PeepPredicate* predicate) {\n+  assert( _predicate == NULL, \"fatal()\" );\n+  _predicate = predicate;\n+}\n+\n@@ -659,0 +666,6 @@\n+\/\/ Add a procedure to this peephole rule\n+void Peephole::add_procedure(PeepProcedure* procedure) {\n+  assert( _procedure == NULL, \"fatal()\" );\n+  _procedure = procedure;\n+}\n+\n@@ -688,0 +701,18 @@\n+\/\/----------------------------PeepPredicate------------------------------------\n+PeepPredicate::PeepPredicate(const char* rule) : _rule(rule) {\n+}\n+PeepPredicate::~PeepPredicate() {\n+}\n+\n+const char* PeepPredicate::rule() const {\n+  return _rule;\n+}\n+\n+void PeepPredicate::dump() {\n+  output(stderr);\n+}\n+\n+void PeepPredicate::output(FILE* fp) {\n+  fprintf(fp, \"PeepPredicate\\n\");\n+}\n+\n@@ -694,1 +725,0 @@\n-\n@@ -744,0 +774,18 @@\n+\/\/----------------------------PeepProcedure------------------------------------\n+PeepProcedure::PeepProcedure(const char* name) : _name(name) {\n+}\n+PeepProcedure::~PeepProcedure() {\n+}\n+\n+const char* PeepProcedure::name() const {\n+  return _name;\n+}\n+\n+void PeepProcedure::dump() {\n+  output(stderr);\n+}\n+\n+void PeepProcedure::output(FILE* fp) {\n+  fprintf(fp, \"PeepProcedure\\n\");\n+}\n+\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,0 @@\n-class Peephole;\n-class PeepMatch;\n-class PeepConstraint;\n@@ -70,0 +67,2 @@\n+class Peephole;\n+class PeepPredicate;\n@@ -71,0 +70,1 @@\n+class PeepProcedure;\n@@ -529,0 +529,1 @@\n+  PeepPredicate  *_predicate;      \/\/ Predicate to apply peep rule\n@@ -530,0 +531,1 @@\n+  PeepProcedure  *_procedure;      \/\/ The detailed procedure to perform the rule\n@@ -544,0 +546,1 @@\n+  void add_predicate(PeepPredicate *only_one_predicate);\n@@ -545,0 +548,1 @@\n+  void add_procedure(PeepProcedure *only_one_procedure);\n@@ -550,0 +554,1 @@\n+  PeepPredicate  *predicate()   { return _predicate; }\n@@ -551,0 +556,1 @@\n+  PeepProcedure  *procedure()   { return _procedure; }\n@@ -559,0 +565,13 @@\n+class PeepPredicate : public Form {\n+private:\n+  const char* _rule;\n+public:\n+  \/\/ Public Methods\n+  PeepPredicate(const char* rule);\n+  ~PeepPredicate();\n+\n+  const char* rule() const;\n+\n+  void dump();\n+  void output(FILE* fp);\n+};\n@@ -591,0 +610,13 @@\n+class PeepProcedure : public Form {\n+private:\n+  const char* _name;\n+public:\n+  \/\/ Public Methods\n+  PeepProcedure(const char* name);\n+  ~PeepProcedure();\n+\n+  const char* name() const;\n+\n+  void dump();\n+  void output(FILE* fp);\n+};\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1268,1 +1268,2 @@\n-static void generate_peepreplace( FILE *fp, FormDict &globals, PeepMatch *pmatch, PeepConstraint *pconstraint, PeepReplace *preplace, int max_position ) {\n+static void generate_peepreplace( FILE *fp, FormDict &globals, int peephole_number, PeepMatch *pmatch,\n+                                  PeepConstraint *pconstraint, PeepReplace *preplace, int max_position ) {\n@@ -1317,1 +1318,0 @@\n-        fprintf(fp, \"        ra_->add_reference(root, inst%d);\\n\", inst_num);\n@@ -1343,0 +1343,3 @@\n+  \/\/ Set output of the new node\n+  fprintf(fp, \"        inst0->replace_by(root);\\n\");\n+  \/\/ Mark the node as removed because peephole does not remove nodes from the graph\n@@ -1345,0 +1348,1 @@\n+    fprintf(fp, \"        cfg_->map_node_to_block(inst%d, nullptr);\\n\", i);\n@@ -1346,3 +1350,7 @@\n-  \/\/ Return the new sub-tree\n-  fprintf(fp, \"        deleted = %d;\\n\", max_position+1 \/*zero to one based*\/);\n-  fprintf(fp, \"        return root;  \/\/ return new root;\\n\");\n+  for (int i = 0; i <= max_position; i++) {\n+    fprintf(fp, \"        block->remove_node(block_index - %d);\\n\", i);\n+  }\n+  fprintf(fp, \"        block->insert_node(root, block_index - %d);\\n\", max_position);\n+  fprintf(fp, \"        cfg_->map_node_to_block(root, block);\\n\");\n+  \/\/ Return the peephole index\n+  fprintf(fp, \"        return %d;  \/\/ return the peephole index;\\n\", peephole_number);\n@@ -1356,1 +1364,1 @@\n-  fprintf(fp, \"MachNode *%sNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted) {\\n\", node->_ident);\n+  fprintf(fp, \"int %sNode::peephole(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_) {\\n\", node->_ident);\n@@ -1369,0 +1377,3 @@\n+    if (peep->procedure() != NULL) {\n+      continue;\n+    }\n@@ -1387,0 +1398,1 @@\n+    PeepPredicate  *ppredicate  = peep->predicate();\n@@ -1388,0 +1400,1 @@\n+    PeepProcedure  *pprocedure  = peep->procedure();\n@@ -1396,4 +1409,10 @@\n-    fprintf(fp, \"  if( (OptoPeepholeAt == -1) || (OptoPeepholeAt==%d) ) {\\n\", peephole_number);\n-    fprintf(fp, \"    matches = true;\\n\");\n-    \/\/ Scan the peepmatch and output a test for each instruction\n-    check_peepmatch_instruction_sequence( fp, pmatch, pconstraint );\n+    fprintf(fp, \"  if( ((OptoPeepholeAt == -1) || (OptoPeepholeAt==%d)) && ( %s ) ) {\\n\",\n+            peephole_number, ppredicate != NULL ? ppredicate->rule() : \"true\");\n+    if (pprocedure == NULL) {\n+      fprintf(fp, \"    matches = true;\\n\");\n+      \/\/ Scan the peepmatch and output a test for each instruction\n+      check_peepmatch_instruction_sequence( fp, pmatch, pconstraint );\n+\n+      \/\/ Check constraints and build replacement inside scope\n+      fprintf(fp, \"    \/\/ If instruction subtree matches\\n\");\n+      fprintf(fp, \"    if( matches ) {\\n\");\n@@ -1401,3 +1420,2 @@\n-    \/\/ Check constraints and build replacement inside scope\n-    fprintf(fp, \"    \/\/ If instruction subtree matches\\n\");\n-    fprintf(fp, \"    if( matches ) {\\n\");\n+      \/\/ Generate tests for the constraints\n+      check_peepconstraints( fp, _globalNames, pmatch, pconstraint );\n@@ -1405,2 +1423,2 @@\n-    \/\/ Generate tests for the constraints\n-    check_peepconstraints( fp, _globalNames, pmatch, pconstraint );\n+      \/\/ Construct the new sub-tree\n+      generate_peepreplace( fp, _globalNames, peephole_number, pmatch, pconstraint, preplace, max_position );\n@@ -1408,2 +1426,28 @@\n-    \/\/ Construct the new sub-tree\n-    generate_peepreplace( fp, _globalNames, pmatch, pconstraint, preplace, max_position );\n+      \/\/ End of scope for this peephole's constraints\n+      fprintf(fp, \"    }\\n\");\n+    } else {\n+      const char* replace_inst = NULL;\n+      preplace->next_instruction(replace_inst);\n+      \/\/ Generate the target instruction\n+      fprintf(fp, \"    auto replacing = [](){ return static_cast<MachNode*>(new %sNode()); };\\n\", replace_inst);\n+\n+      \/\/ Call the precedure\n+      fprintf(fp, \"    bool replacement = Peephole::%s(block, block_index, cfg_, ra_, replacing\", pprocedure->name());\n+\n+      int         parent        = -1;\n+      int         inst_position = 0;\n+      const char* inst_name     = NULL;\n+      int         input         = 0;\n+      pmatch->reset();\n+      for (pmatch->next_instruction(parent, inst_position, inst_name, input);\n+           inst_name != NULL;\n+           pmatch->next_instruction(parent, inst_position, inst_name, input)) {\n+        fprintf(fp, \", %s_rule\", inst_name);\n+      }\n+      fprintf(fp, \");\\n\");\n+\n+      \/\/ If substitution succeeded, return the new node\n+      fprintf(fp, \"    if (replacement) {\\n\");\n+      fprintf(fp, \"      return %d;\\n\", peephole_number);\n+      fprintf(fp, \"    }\\n\");\n+    }\n@@ -1411,2 +1455,0 @@\n-    \/\/ End of scope for this peephole's constraints\n-    fprintf(fp, \"    }\\n\");\n@@ -1418,1 +1460,1 @@\n-  fprintf(fp, \"  return NULL;  \/\/ No peephole rules matched\\n\");\n+  fprintf(fp, \"  return -1;  \/\/ No peephole rules matched\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":62,"deletions":20,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1706,1 +1706,1 @@\n-      fprintf(fp,\"  virtual MachNode      *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted);\\n\");\n+      fprintf(fp,\"  virtual int            peephole(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_);\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,2 @@\n-  ADD_EXCL(\"jdk\/internal\/util\/StaticProperty\",           \"FILE_ENCODING\");         \/\/ C\n+  ADD_EXCL(\"jdk\/internal\/util\/StaticProperty\",           \"FILE_ENCODING\",          \/\/ C\n+                                                 \"JAVA_LOCALE_USE_OLD_ISO_CODES\"); \/\/ C\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,1 +57,3 @@\n-ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+  log_info(cds)(\"Parsing %s%s\", file,\n+                (parse_mode == _parse_lambda_forms_invokers_only) ? \" (lambda form invokers only)\" : \"\");\n@@ -76,0 +78,1 @@\n+  _parse_mode = parse_mode;\n@@ -107,0 +110,4 @@\n+    if (_parse_mode == _parse_lambda_forms_invokers_only) {\n+      continue;\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,7 @@\n+public:\n+  enum ParseMode {\n+    _parse_all,\n+    _parse_lambda_forms_invokers_only,\n+  };\n+\n+private:\n@@ -110,0 +117,1 @@\n+  ParseMode           _parse_mode;\n@@ -127,2 +135,1 @@\n-public:\n-  ClassListParser(const char* file);\n+  ClassListParser(const char* file, ParseMode _parse_mode);\n@@ -131,0 +138,6 @@\n+public:\n+  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n+    ClassListParser parser(classlist_path, parse_mode);\n+    return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -736,0 +736,27 @@\n+void MetaspaceShared::get_default_classlist(char* default_classlist, const size_t buf_size) {\n+  \/\/ Construct the path to the class list (in jre\/lib)\n+  \/\/ Walk up two directories from the location of the VM and\n+  \/\/ optionally tack on \"lib\" (depending on platform)\n+  os::jvm_path(default_classlist, (jint)(buf_size));\n+  for (int i = 0; i < 3; i++) {\n+    char *end = strrchr(default_classlist, *os::file_separator());\n+    if (end != NULL) *end = '\\0';\n+  }\n+  size_t classlist_path_len = strlen(default_classlist);\n+  if (classlist_path_len >= 3) {\n+    if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n+      if (classlist_path_len < buf_size - 4) {\n+        jio_snprintf(default_classlist + classlist_path_len,\n+                     buf_size - classlist_path_len,\n+                     \"%slib\", os::file_separator());\n+        classlist_path_len += 4;\n+      }\n+    }\n+  }\n+  if (classlist_path_len < buf_size - 10) {\n+    jio_snprintf(default_classlist + classlist_path_len,\n+                 buf_size - classlist_path_len,\n+                 \"%sclasslist\", os::file_separator());\n+  }\n+}\n+\n@@ -740,0 +767,1 @@\n+  get_default_classlist(default_classlist, sizeof(default_classlist));\n@@ -741,24 +769,0 @@\n-    \/\/ Construct the path to the class list (in jre\/lib)\n-    \/\/ Walk up two directories from the location of the VM and\n-    \/\/ optionally tack on \"lib\" (depending on platform)\n-    os::jvm_path(default_classlist, sizeof(default_classlist));\n-    for (int i = 0; i < 3; i++) {\n-      char *end = strrchr(default_classlist, *os::file_separator());\n-      if (end != NULL) *end = '\\0';\n-    }\n-    int classlist_path_len = (int)strlen(default_classlist);\n-    if (classlist_path_len >= 3) {\n-      if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n-        if (classlist_path_len < JVM_MAXPATHLEN - 4) {\n-          jio_snprintf(default_classlist + classlist_path_len,\n-                       sizeof(default_classlist) - classlist_path_len,\n-                       \"%slib\", os::file_separator());\n-          classlist_path_len += 4;\n-        }\n-      }\n-    }\n-    if (classlist_path_len < JVM_MAXPATHLEN - 10) {\n-      jio_snprintf(default_classlist + classlist_path_len,\n-                   sizeof(default_classlist) - classlist_path_len,\n-                   \"%sclasslist\", os::file_separator());\n-    }\n@@ -772,1 +776,2 @@\n-  int class_count = parse_classlist(classlist_path, CHECK);\n+  int class_count = ClassListParser::parse_classlist(classlist_path,\n+                                                     ClassListParser::_parse_all, CHECK);\n@@ -774,1 +779,10 @@\n-    class_count += parse_classlist(ExtraSharedClassListFile, CHECK);\n+    class_count += ClassListParser::parse_classlist(ExtraSharedClassListFile,\n+                                                    ClassListParser::_parse_all, CHECK);\n+  }\n+  if (classlist_path != default_classlist) {\n+    struct stat statbuf;\n+    if (os::stat(default_classlist, &statbuf) == 0) {\n+      \/\/ File exists, let's use it.\n+      class_count += ClassListParser::parse_classlist(default_classlist,\n+                                                      ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n+    }\n@@ -817,6 +831,0 @@\n-\n-int MetaspaceShared::parse_classlist(const char* classlist_path, TRAPS) {\n-  ClassListParser parser(classlist_path);\n-  return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":40,"deletions":32,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -91,3 +91,0 @@\n-  static int parse_classlist(const char * classlist_path,\n-                              TRAPS) NOT_CDS_RETURN_(0);\n-\n@@ -205,0 +202,1 @@\n+  static void get_default_classlist(char* default_classlist, const size_t buf_size);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -286,0 +286,6 @@\n+#ifdef ASSERT\n+void ClassLoaderData::verify_not_claimed(int claim) {\n+  assert((_claim & claim) == 0, \"Found claim: %d bits in _claim: %d\", claim, _claim);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+  void verify_not_claimed(int claim) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,9 @@\n+\n+void ClassLoaderDataGraph::verify_claimed_marks_cleared(int claim) {\n+#ifdef ASSERT\n+ for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != NULL; cld = cld->next()) {\n+    cld->verify_not_claimed(claim);\n+  }\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+  static void verify_claimed_marks_cleared(int claim);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -227,0 +227,6 @@\n+  do_intrinsic(_float16ToFloat,           java_lang_Float,        float16ToFloat_name,      f16_float_signature, F_S)   \\\n+   do_name(     float16ToFloat_name,                             \"float16ToFloat\")                                      \\\n+   do_signature(f16_float_signature,                             \"(S)F\")                                                \\\n+  do_intrinsic(_floatToFloat16,           java_lang_Float,        floatToFloat16_name,      float_f16_signature, F_S)   \\\n+   do_name(     floatToFloat16_name,                             \"floatToFloat16\")                                      \\\n+   do_signature(float_f16_signature,                             \"(F)S\")                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#ifndef ZERO\n@@ -75,0 +76,6 @@\n+#else\n+\/\/ Zero runs without compilers. Do not let this code to force\n+\/\/ the GC mode and default heap settings.\n+define_pd_global(bool, NeverActAsServerClassMachine, false);\n+define_pd_global(uint64_t,MaxRAM,                    128ULL*G);\n+#endif\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals_pd.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -244,4 +244,0 @@\n-double G1Analytics::predict_young_card_merge_to_scan_ratio() const {\n-  return predict_in_unit_interval(_young_card_merge_to_scan_ratio_seq);\n-}\n-\n@@ -250,1 +246,1 @@\n-    return (size_t)(rs_length * predict_young_card_merge_to_scan_ratio());\n+    return (size_t)(rs_length * predict_in_unit_interval(_young_card_merge_to_scan_ratio_seq));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,3 +142,0 @@\n-  double predict_young_card_merge_to_scan_ratio() const;\n-\n-  double predict_mixed_card_merge_to_scan_ratio() const;\n@@ -146,0 +143,2 @@\n+  \/\/ Predict how many cards in a remembered set of length rs_length will need to\n+  \/\/ be scanned in addition to the pending log buffer cards.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -424,1 +424,1 @@\n-  double predicted_base_time_ms = _policy->predict_base_elapsed_time_ms(pending_cards);\n+  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-    double survivor_base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);\n+    double base_time_ms = predict_base_time_ms(pending_cards, rs_length);\n@@ -263,1 +263,1 @@\n-      calculate_desired_eden_length_by_pause(survivor_base_time_ms,\n+      calculate_desired_eden_length_by_pause(base_time_ms,\n@@ -479,1 +479,1 @@\n-uint G1Policy::calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,\n+uint G1Policy::calculate_desired_eden_length_before_mixed(double base_time_ms,\n@@ -486,1 +486,1 @@\n-  double predicted_region_evac_time_ms = survivor_base_time_ms;\n+  double predicted_region_evac_time_ms = base_time_ms;\n@@ -489,1 +489,1 @@\n-    predicted_region_evac_time_ms += predict_region_total_time_ms(r, false);\n+    predicted_region_evac_time_ms += predict_region_total_time_ms(r, false \/* for_young_gc *\/);\n@@ -1011,8 +1011,21 @@\n-double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards,\n-                                              size_t rs_length) const {\n-  size_t effective_scanned_cards = _analytics->predict_scan_card_num(rs_length, collector_state()->in_young_only_phase());\n-  return\n-    _analytics->predict_card_merge_time_ms(pending_cards + rs_length, collector_state()->in_young_only_phase()) +\n-    _analytics->predict_card_scan_time_ms(effective_scanned_cards, collector_state()->in_young_only_phase()) +\n-    _analytics->predict_constant_other_time_ms() +\n-    predict_survivor_regions_evac_time();\n+double G1Policy::predict_base_time_ms(size_t pending_cards,\n+                                      size_t rs_length) const {\n+  bool in_young_only_phase = collector_state()->in_young_only_phase();\n+\n+  size_t unique_cards_from_rs = _analytics->predict_scan_card_num(rs_length, in_young_only_phase);\n+  \/\/ Assume that all cards from the log buffers will be scanned, i.e. there are no\n+  \/\/ duplicates in that set.\n+  size_t effective_scanned_cards = unique_cards_from_rs + pending_cards;\n+\n+  double card_merge_time = _analytics->predict_card_merge_time_ms(pending_cards + rs_length, in_young_only_phase);\n+  double card_scan_time = _analytics->predict_card_scan_time_ms(effective_scanned_cards, in_young_only_phase);\n+  double constant_other_time = _analytics->predict_constant_other_time_ms();\n+  double survivor_evac_time = predict_survivor_regions_evac_time();\n+\n+  double total_time = card_merge_time + card_scan_time + constant_other_time + survivor_evac_time;\n+\n+  log_trace(gc, ergo, heap)(\"Predicted base time: total %f lb_cards %zu rs_length %zu effective_scanned_cards %zu \"\n+                            \"card_merge_time %f card_scan_time %f constant_other_time %f survivor_evac_time %f\",\n+                            total_time, pending_cards, rs_length, effective_scanned_cards,\n+                            card_merge_time, card_scan_time, constant_other_time, survivor_evac_time);\n+  return total_time;\n@@ -1021,1 +1034,1 @@\n-double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards) const {\n+double G1Policy::predict_base_time_ms(size_t pending_cards) const {\n@@ -1023,1 +1036,1 @@\n-  return predict_base_elapsed_time_ms(pending_cards, rs_length);\n+  return predict_base_time_ms(pending_cards, rs_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-  double predict_base_elapsed_time_ms(size_t num_pending_cards) const;\n+  double predict_base_time_ms(size_t pending_cards) const;\n@@ -143,1 +143,1 @@\n-  double predict_base_elapsed_time_ms(size_t num_pending_cards, size_t rs_length) const;\n+  double predict_base_time_ms(size_t pending_cards, size_t rs_length) const;\n@@ -222,1 +222,1 @@\n-  uint calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,\n+  uint calculate_desired_eden_length_before_mixed(double base_time_ms,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,4 @@\n-  \/\/ This function clears the memory of the object\n+  \/\/ Initialization provided by subclasses.\n+  virtual oop initialize(HeapWord* mem) const = 0;\n+\n+  \/\/ This function clears the memory of the object.\n@@ -61,0 +64,1 @@\n+\n@@ -64,1 +68,1 @@\n-  virtual oop finish(HeapWord* mem) const;\n+  oop finish(HeapWord* mem) const;\n@@ -75,0 +79,1 @@\n+  \/\/ Allocate and fully construct the object, and perform various instrumentation. Could safepoint.\n@@ -77,1 +82,0 @@\n-  virtual oop initialize(HeapWord* mem) const = 0;\n@@ -88,0 +92,1 @@\n+protected:\n@@ -90,1 +95,1 @@\n-protected:\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -808,0 +808,4 @@\n+OopStorage* OopStorage::create(const char* name, MEMFLAGS memflags) {\n+  return new (memflags) OopStorage(name, memflags);\n+}\n+\n@@ -818,9 +822,0 @@\n-void* OopStorage::operator new(size_t size, MEMFLAGS memflags) {\n-  assert(size >= sizeof(OopStorage), \"precondition\");\n-  return NEW_C_HEAP_ARRAY(char, size, memflags);\n-}\n-\n-void OopStorage::operator delete(void* obj, MEMFLAGS \/* memflags *\/) {\n-  FREE_C_HEAP_ARRAY(char, obj);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-class OopStorage {\n+class OopStorage : public CHeapObjBase {\n@@ -77,1 +77,1 @@\n-  explicit OopStorage(const char* name, MEMFLAGS memflags);\n+  static OopStorage* create(const char* name, MEMFLAGS memflags);\n@@ -80,3 +80,0 @@\n-  void* operator new(size_t size, MEMFLAGS memflags);\n-  void operator delete(void* obj, MEMFLAGS memflags);\n-\n@@ -285,0 +282,4 @@\n+  \/\/ Clients construct via \"create\" factory function.\n+  OopStorage(const char* name, MEMFLAGS memflags);\n+  NONCOPYABLE(OopStorage);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  OopStorage* storage = new (memflags) OopStorage(name, memflags);\n+  OopStorage* storage = OopStorage::create(name, memflags);\n@@ -45,1 +45,1 @@\n-  OopStorage* storage = new (memflags) OopStorage(name, memflags);\n+  OopStorage* storage = OopStorage::create(name, memflags);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-  _alloc_failure_waiters_lock(Mutex::safepoint-1, \"ShenandoahAllocFailureGC_lock\", true),\n-  _gc_waiters_lock(Mutex::safepoint-1, \"ShenandoahRequestedGC_lock\", true),\n+  _alloc_failure_waiters_lock(Mutex::safepoint-2, \"ShenandoahAllocFailureGC_lock\", true),\n+  _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,5 +164,1 @@\n-  if (!do_zero) {\n-    return CollectedHeap::array_allocate(klass, size, length, false \/* do_zero *\/, THREAD);\n-  }\n-\n-  ZObjArrayAllocator allocator(klass, size, length, THREAD);\n+  ZObjArrayAllocator allocator(klass, size, length, do_zero, THREAD);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -224,0 +225,3 @@\n+  \/\/ Verification\n+  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_strong);\n+\n@@ -338,0 +342,4 @@\n+\n+  \/\/ Clear old markings claim bits.\n+  \/\/ Note: Clearing _claim_strong also clears _claim_finalizable.\n+  ClassLoaderDataGraph::clear_claimed_marks(ClassLoaderData::_claim_strong);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -239,0 +239,3 @@\n+\n+  \/\/ Clear claimed CLD bits\n+  ClassLoaderDataGraph::clear_claimed_marks(ClassLoaderData::_claim_other);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -31,2 +32,2 @@\n-ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, Thread* thread) :\n-    ObjArrayAllocator(klass, word_size, length, false \/* do_zero *\/, thread) {}\n+ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, bool do_zero, Thread* thread) :\n+    ObjArrayAllocator(klass, word_size, length, do_zero, thread) {}\n@@ -34,3 +35,3 @@\n-oop ZObjArrayAllocator::finish(HeapWord* mem) const {\n-  \/\/ Initialize object header and length field\n-  ObjArrayAllocator::finish(mem);\n+void ZObjArrayAllocator::yield_for_safepoint() const {\n+  ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n+}\n@@ -38,4 +39,8 @@\n-  \/\/ Keep the array alive across safepoints through an invisible\n-  \/\/ root. Invisible roots are not visited by the heap itarator\n-  \/\/ and the marking logic will not attempt to follow its elements.\n-  ZThreadLocalData::set_invisible_root(_thread, (oop*)&mem);\n+oop ZObjArrayAllocator::initialize(HeapWord* mem) const {\n+  \/\/ ZGC specializes the initialization by performing segmented clearing\n+  \/\/ to allow shorter time-to-safepoints.\n+\n+  if (!_do_zero) {\n+    \/\/ No need for ZGC specialization\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n@@ -47,2 +52,30 @@\n-  const size_t skip = arrayOopDesc::header_size(ArrayKlass::cast(_klass)->element_type());\n-  size_t remaining = _word_size - skip;\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t header = arrayOopDesc::header_size(element_type);\n+  const size_t payload_size = _word_size - header;\n+\n+  if (payload_size <= segment_max) {\n+    \/\/ To small to use segmented clearing\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n+\n+  \/\/ Segmented clearing\n+\n+  \/\/ The array is going to be exposed before it has been completely\n+  \/\/ cleared, therefore we can't expose the header at the end of this\n+  \/\/ function. Instead explicitly initialize it according to our needs.\n+  arrayOopDesc::set_mark(mem, markWord::prototype());\n+  arrayOopDesc::release_set_klass(mem, _klass);\n+  assert(_length >= 0, \"length should be non-negative\");\n+  arrayOopDesc::set_length(mem, _length);\n+\n+  \/\/ Keep the array alive across safepoints through an invisible\n+  \/\/ root. Invisible roots are not visited by the heap itarator\n+  \/\/ and the marking logic will not attempt to follow its elements.\n+  \/\/ Relocation knows how to dodge iterating over such objects.\n+  ZThreadLocalData::set_invisible_root(_thread, (oop*)&mem);\n+\n+  for (size_t processed = 0; processed < payload_size; processed += segment_max) {\n+    \/\/ Calculate segment\n+    HeapWord* const start = (HeapWord*)(mem + header + processed);\n+    const size_t remaining = payload_size - processed;\n+    const size_t segment_size = MIN2(remaining, segment_max);\n@@ -50,1 +83,0 @@\n-  while (remaining > 0) {\n@@ -52,3 +84,1 @@\n-    const size_t segment = MIN2(remaining, segment_max);\n-    Copy::zero_to_words(mem + (_word_size - remaining), segment);\n-    remaining -= segment;\n+    Copy::zero_to_words(start, segment_size);\n@@ -56,4 +86,2 @@\n-    if (remaining > 0) {\n-      \/\/ Safepoint\n-      ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n-    }\n+    \/\/ Safepoint\n+    yield_for_safepoint();\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":47,"deletions":19,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -30,2 +30,4 @@\n-public:\n-  ZObjArrayAllocator(Klass* klass, size_t word_size, int length, Thread* thread);\n+private:\n+  virtual oop initialize(HeapWord* mem) const override;\n+\n+  void yield_for_safepoint() const;\n@@ -33,1 +35,2 @@\n-  virtual oop finish(HeapWord* mem) const;\n+public:\n+  ZObjArrayAllocator(Klass* klass, size_t word_size, int length, bool do_zero, Thread* thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    ClassLoaderDataGraph::clear_claimed_marks(cld_claim);\n+    ClassLoaderDataGraph::verify_claimed_marks_cleared(cld_claim);\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,3 +280,1 @@\n-  if (periodMillis > 0) {\n-    JfrEventSetting::set_enabled(typed_event_id, true); \/\/ ensure sampling event is enabled\n-  }\n+  JfrEventSetting::set_enabled(typed_event_id, periodMillis > 0);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -302,2 +302,4 @@\n-    for (uint i = 0; i < _added_java; ++i) {\n-      _events[i].commit();\n+    if (EventExecutionSample::is_enabled()) {\n+      for (uint i = 0; i < _added_java; ++i) {\n+        _events[i].commit();\n+      }\n@@ -308,2 +310,4 @@\n-    for (uint i = 0; i < _added_native; ++i) {\n-      _events_native[i].commit();\n+    if (EventNativeMethodSample::is_enabled()) {\n+      for (uint i = 0; i < _added_native; ++i) {\n+        _events_native[i].commit();\n+      }\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+typedef JfrCheckpointManager::ConstBufferPtr ConstBufferPtr;\n@@ -80,2 +81,3 @@\n-  _global_mspace(NULL),\n-  _thread_local_mspace(NULL),\n+  _global_mspace(nullptr),\n+  _thread_local_mspace(nullptr),\n+  _virtual_thread_local_mspace(nullptr),\n@@ -94,2 +96,5 @@\n-static const size_t thread_local_buffer_prealloc_count = 32;\n-static const size_t thread_local_buffer_size = 4 * K;\n+static const size_t thread_local_buffer_prealloc_count = 16;\n+static const size_t thread_local_buffer_size = 256;\n+\n+static const size_t virtual_thread_local_buffer_prealloc_count = 0;\n+static const size_t virtual_thread_local_buffer_size = 4 * K;\n@@ -113,1 +118,1 @@\n-                                                                        JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n+                                                                        thread_local_buffer_prealloc_count,\n@@ -117,0 +122,8 @@\n+\n+  assert(_virtual_thread_local_mspace == NULL, \"invariant\");\n+  _virtual_thread_local_mspace = new JfrThreadLocalCheckpointMspace();\n+  if (_virtual_thread_local_mspace == NULL || !_virtual_thread_local_mspace->initialize(virtual_thread_local_buffer_size,\n+                                                                                        JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n+                                                                                        virtual_thread_local_buffer_prealloc_count)) {\n+    return false;\n+  }\n@@ -121,1 +134,1 @@\n-static void assert_lease(const BufferPtr buffer) {\n+static void assert_lease(ConstBufferPtr buffer) {\n@@ -127,1 +140,1 @@\n-static void assert_release(const BufferPtr buffer) {\n+static void assert_release(ConstBufferPtr buffer) {\n@@ -133,1 +146,1 @@\n-static void assert_retired(const BufferPtr buffer, Thread* thread) {\n+static void assert_retired(ConstBufferPtr buffer, Thread* thread) {\n@@ -145,1 +158,16 @@\n-BufferPtr JfrCheckpointManager::lease(Thread* thread, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n+static inline bool is_global(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_GLOBAL;\n+}\n+\n+static inline bool is_thread_local(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_THREADLOCAL;\n+}\n+\n+static inline bool is_virtual_thread_local(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_VIRTUAL_THREADLOCAL;\n+}\n+\n+BufferPtr JfrCheckpointManager::lease_global(Thread* thread, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n@@ -163,23 +191,9 @@\n-const u1 thread_local_context = 1;\n-\n-static bool is_thread_local(const JfrBuffer* buffer) {\n-  assert(buffer != NULL, \"invariant\");\n-  return buffer->context() == thread_local_context;\n-}\n-\n-static void retire(JfrBuffer* buffer) {\n-  DEBUG_ONLY(assert_release(buffer);)\n-  buffer->clear_lease();\n-  buffer->set_retired();\n-}\n-\n-\/*\n- * The buffer is effectively invalidated for the thread post-return,\n- * and the caller should take means to ensure that it is not referenced.\n- *\/\n-static void release(JfrBuffer* buffer) {\n-  DEBUG_ONLY(assert_release(buffer);)\n-  if (!is_thread_local(buffer)) {\n-    buffer->clear_lease();\n-    buffer->release();\n-  }\n+BufferPtr JfrCheckpointManager::lease_thread_local(Thread* thread, size_t size) {\n+  BufferPtr buffer = instance()._thread_local_mspace->acquire(size, thread);\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(buffer->free_size() >= size, \"invariant\");\n+  buffer->set_lease();\n+  DEBUG_ONLY(assert_lease(buffer);)\n+  buffer->set_context(JFR_THREADLOCAL);\n+  assert(is_thread_local(buffer), \"invariant\");\n+  return buffer;\n@@ -188,1 +202,1 @@\n-BufferPtr JfrCheckpointManager::get_thread_local(Thread* thread) {\n+BufferPtr JfrCheckpointManager::get_virtual_thread_local(Thread* thread) {\n@@ -194,1 +208,1 @@\n-void JfrCheckpointManager::set_thread_local(Thread* thread, BufferPtr buffer) {\n+void JfrCheckpointManager::set_virtual_thread_local(Thread* thread, BufferPtr buffer) {\n@@ -203,4 +217,3 @@\n-BufferPtr JfrCheckpointManager::acquire_thread_local(size_t size, Thread* thread) {\n-  assert(thread != NULL, \"invariant\");\n-  JfrBuffer* const buffer = instance()._thread_local_mspace->acquire(size, thread);\n-  assert(buffer != NULL, \"invariant\");\n+BufferPtr JfrCheckpointManager::new_virtual_thread_local(Thread* thread, size_t size) {\n+  BufferPtr buffer = instance()._virtual_thread_local_mspace->acquire(size, thread);\n+  assert(buffer != nullptr, \"invariant\");\n@@ -208,4 +221,3 @@\n-  buffer->set_context(thread_local_context);\n-  assert(is_thread_local(buffer), \"invariant\");\n-  buffer->set_lease();\n-  set_thread_local(thread, buffer);\n+  buffer->set_context(JFR_VIRTUAL_THREADLOCAL);\n+  assert(is_virtual_thread_local(buffer), \"invariant\");\n+  set_virtual_thread_local(thread, buffer);\n@@ -215,7 +227,4 @@\n-BufferPtr JfrCheckpointManager::lease_thread_local(Thread* thread, size_t size \/* 0 *\/) {\n-  JfrBuffer* buffer = get_thread_local(thread);\n-  if (buffer == NULL) {\n-    buffer = acquire_thread_local(size, thread);\n-  } else if (buffer->free_size() < size) {\n-    retire(buffer);\n-    buffer = acquire_thread_local(size, thread);\n+BufferPtr JfrCheckpointManager::acquire_virtual_thread_local(Thread* thread, size_t size \/* 0 *\/) {\n+  BufferPtr buffer = get_virtual_thread_local(thread);\n+  if (buffer == nullptr || buffer->free_size() < size) {\n+    buffer = new_virtual_thread_local(thread, size);\n@@ -223,1 +232,1 @@\n-  DEBUG_ONLY(assert_lease(buffer);)\n+  assert(buffer->acquired_by_self(), \"invariant\");\n@@ -225,1 +234,2 @@\n-  assert(get_thread_local(thread) == buffer, \"invariant\");\n+  assert(get_virtual_thread_local(thread) == buffer, \"invariant\");\n+  assert(is_virtual_thread_local(buffer), \"invariant\");\n@@ -229,1 +239,1 @@\n-BufferPtr JfrCheckpointManager::lease(BufferPtr old, Thread* thread, size_t size) {\n+BufferPtr JfrCheckpointManager::renew(ConstBufferPtr old, Thread* thread, size_t size, JfrCheckpointBufferKind kind \/* JFR_THREADLOCAL *\/) {\n@@ -231,2 +241,42 @@\n-  return is_thread_local(old) ? acquire_thread_local(size, thread) :\n-                                lease(thread, instance()._global_mspace->in_previous_epoch_list(old), size);\n+  assert(old->acquired_by_self(), \"invariant\");\n+  if (kind == JFR_GLOBAL) {\n+    return lease_global(thread, instance()._global_mspace->in_previous_epoch_list(old), size);\n+  }\n+  return kind == JFR_THREADLOCAL ? lease_thread_local(thread, size) : acquire_virtual_thread_local(thread, size);\n+}\n+\n+BufferPtr JfrCheckpointManager::acquire(Thread* thread, JfrCheckpointBufferKind kind \/* JFR_THREADLOCAL *\/, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n+  if (kind == JFR_GLOBAL) {\n+    return lease_global(thread, previous_epoch, size);\n+  }\n+  if (kind == JFR_THREADLOCAL) {\n+    return lease_thread_local(thread, size);\n+  }\n+  assert(kind == JFR_VIRTUAL_THREADLOCAL, \"invariant\");\n+  return acquire_virtual_thread_local(thread, size);\n+}\n+\n+static inline void retire(BufferPtr buffer) {\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(buffer->acquired_by_self(), \"invariant\");\n+  buffer->set_retired();\n+}\n+\n+\/*\n+ * The buffer is effectively invalidated for the thread post-return,\n+ * and the caller should take means to ensure that it is not referenced.\n+ *\/\n+static inline void release(BufferPtr buffer) {\n+  DEBUG_ONLY(assert_release(buffer);)\n+  assert(!is_virtual_thread_local(buffer), \"invariant\");\n+  if (is_global(buffer)) {\n+    buffer->release();\n+    return;\n+  }\n+  assert(is_thread_local(buffer), \"invariant\");\n+  retire(buffer);\n+}\n+\n+static inline JfrCheckpointBufferKind kind(ConstBufferPtr buffer) {\n+  assert(buffer != nullptr, \"invariant\");\n+  return static_cast<JfrCheckpointBufferKind>(buffer->context());\n@@ -237,1 +287,0 @@\n-  assert(old->lease(), \"invariant\");\n@@ -240,0 +289,1 @@\n+    assert(old->lease(), \"invariant\");\n@@ -245,1 +295,1 @@\n-  BufferPtr new_buffer = lease(old, thread, used + requested);\n+  BufferPtr new_buffer = renew(old, thread, used + requested, kind(old));\n@@ -375,1 +425,1 @@\n-class ThreadLocalCheckpointWriteOp {\n+class VirtualThreadLocalCheckpointWriteOp {\n@@ -384,1 +434,1 @@\n-  ThreadLocalCheckpointWriteOp(JfrChunkWriter& cw) : _cw(cw), _begin_offset(cw.current_offset()), _elements_offset(0), _processed(0), _elements(0) {\n+  VirtualThreadLocalCheckpointWriteOp(JfrChunkWriter& cw) : _cw(cw), _begin_offset(cw.current_offset()), _elements_offset(0), _processed(0), _elements(0) {\n@@ -399,1 +449,1 @@\n-  ~ThreadLocalCheckpointWriteOp() {\n+  ~VirtualThreadLocalCheckpointWriteOp() {\n@@ -420,2 +470,1 @@\n-typedef ThreadLocalCheckpointWriteOp<JfrCheckpointManager::Buffer> ThreadLocalCheckpointOperation;\n-typedef MutexedWriteOp<ThreadLocalCheckpointOperation> ThreadLocalWriteOperation;\n+typedef MutexedWriteOp<WriteOperation> MutexedWriteOperation;\n@@ -423,2 +472,3 @@\n-typedef ExclusiveOp<WriteOperation> GlobalWriteOperation;\n-typedef CompositeOperation<GlobalWriteOperation, ReleaseOperation> GlobalWriteReleaseOperation;\n+typedef CompositeOperation<MutexedWriteOperation, ReleaseOperation> WriteReleaseOperation;\n+typedef VirtualThreadLocalCheckpointWriteOp<JfrCheckpointManager::Buffer> VirtualThreadLocalCheckpointOperation;\n+typedef MutexedWriteOp<VirtualThreadLocalCheckpointOperation> VirtualThreadLocalWriteOperation;\n@@ -441,1 +491,2 @@\n-  GlobalWriteOperation gwo(wo);\n+  MutexedWriteOperation mwo(wo);\n+  _thread_local_mspace->iterate(mwo, true); \/\/ previous epoch list\n@@ -443,8 +494,8 @@\n-  ReleaseOperation ro(_global_mspace, _global_mspace->live_list(true));\n-  GlobalWriteReleaseOperation gwro(&gwo, &ro);\n-  process_live_list(gwro, _global_mspace, true); \/\/ previous epoch list\n-  \/\/ Do thread local list after global. Careful, the tlco destructor writes to chunk.\n-  ThreadLocalCheckpointOperation tlco(_chunkwriter);\n-  ThreadLocalWriteOperation tlwo(tlco);\n-  _thread_local_mspace->iterate(tlwo, true); \/\/ previous epoch list\n-  return wo.processed() + tlco.processed();\n+  ReleaseOperation ro(_global_mspace, _global_mspace->live_list(true)); \/\/ previous epoch list\n+  WriteReleaseOperation wro(&mwo, &ro);\n+  process_live_list(wro, _global_mspace, true); \/\/ previous epoch list\n+  \/\/ Do virtual thread local list last. Careful, the vtlco destructor writes to chunk.\n+  VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+  VirtualThreadLocalWriteOperation vtlwo(vtlco);\n+  _virtual_thread_local_mspace->iterate(vtlwo, true); \/\/ previous epoch list\n+  return wo.processed() + vtlco.processed();\n@@ -453,3 +504,2 @@\n-typedef DiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > ThreadLocalDiscardOperation;\n-typedef ExclusiveDiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > GlobalDiscardOperation;\n-typedef CompositeOperation<GlobalDiscardOperation, ReleaseOperation> DiscardReleaseOperation;\n+typedef DiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > DiscardOperation;\n+typedef CompositeOperation<DiscardOperation, ReleaseOperation> DiscardReleaseOperation;\n@@ -460,3 +510,3 @@\n-  ThreadLocalDiscardOperation tldo(mutexed); \/\/ mutexed discard mode\n-  _thread_local_mspace->iterate(tldo, true); \/\/ previous epoch list\n-  GlobalDiscardOperation gdo(mutexed); \/\/ mutexed discard mode\n+  DiscardOperation dop(mutexed); \/\/ mutexed discard mode\n+  _thread_local_mspace->iterate(dop, true); \/\/ previous epoch list\n+  _virtual_thread_local_mspace->iterate(dop, true); \/\/ previous epoch list\n@@ -464,1 +514,1 @@\n-  DiscardReleaseOperation dro(&gdo, &ro);\n+  DiscardReleaseOperation dro(&dop, &ro);\n@@ -467,1 +517,1 @@\n-  return tldo.elements() + gdo.elements();\n+  return dop.elements();\n@@ -564,0 +614,3 @@\n+    WriteOperation wo(_chunkwriter);\n+    MutexedWriteOperation mwo(wo);\n+    _thread_local_mspace->iterate(mwo); \/\/ current epoch list\n@@ -566,9 +619,5 @@\n-    WriteOperation wo(_chunkwriter);\n-    GlobalWriteOperation gwo(wo);\n-    ReleaseOperation ro(_global_mspace, _global_mspace->live_list()); \/\/ current epoch list\n-    GlobalWriteReleaseOperation gwro(&gwo, &ro);\n-    process_live_list(gwro, _global_mspace); \/\/ current epoch list\n-    \/\/ Do thread local list after global. Careful, the tlco destructor writes to chunk.\n-    ThreadLocalCheckpointOperation tlco(_chunkwriter);\n-    ThreadLocalWriteOperation tlwo(tlco);\n-    _thread_local_mspace->iterate(tlwo); \/\/ current epoch list\n+    process_live_list(mwo, _global_mspace); \/\/ current epoch list\n+    \/\/ Do virtual thread local list last. Careful, the vtlco destructor writes to chunk.\n+    VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+    VirtualThreadLocalWriteOperation vtlwo(vtlco);\n+    _virtual_thread_local_mspace->iterate(vtlwo); \/\/ current epoch list\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":138,"deletions":89,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  typedef const JfrCheckpointMspace::Node* ConstBufferPtr;\n@@ -63,0 +64,1 @@\n+  JfrThreadLocalCheckpointMspace* _virtual_thread_local_mspace;\n@@ -72,3 +74,4 @@\n-  static BufferPtr get_thread_local(Thread* thread);\n-  static void set_thread_local(Thread* thread, BufferPtr buffer);\n-  static BufferPtr acquire_thread_local(size_t size, Thread* thread);\n+  static BufferPtr get_virtual_thread_local(Thread* thread);\n+  static void set_virtual_thread_local(Thread* thread, BufferPtr buffer);\n+  static BufferPtr acquire_virtual_thread_local(Thread* thread, size_t size);\n+  static BufferPtr new_virtual_thread_local(Thread* thread, size_t size = 0);\n@@ -76,2 +79,0 @@\n-  static BufferPtr lease(Thread* thread, bool previous_epoch = false, size_t size = 0);\n-  static BufferPtr lease(BufferPtr old, Thread* thread, size_t size);\n@@ -79,0 +80,1 @@\n+  static BufferPtr lease_global(Thread* thread, bool previous_epoch = false, size_t size = 0);\n@@ -80,0 +82,2 @@\n+  static BufferPtr acquire(Thread* thread, JfrCheckpointBufferKind kind = JFR_THREADLOCAL, bool previous_epoch = false, size_t size = 0);\n+  static BufferPtr renew(ConstBufferPtr old, Thread* thread, size_t size, JfrCheckpointBufferKind kind = JFR_THREADLOCAL);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -34,2 +35,2 @@\n-JfrCheckpointWriter::JfrCheckpointWriter(JfrCheckpointType type \/* GENERIC *\/) :\n-  JfrCheckpointWriterBase(JfrCheckpointManager::lease(Thread::current()), Thread::current()),\n+JfrCheckpointWriter::JfrCheckpointWriter(bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, JfrCheckpointBufferKind kind \/* JFR_GLOBAL *\/) :\n+  JfrCheckpointWriterBase(JfrCheckpointManager::acquire(Thread::current(), kind), Thread::current()),\n@@ -40,1 +41,1 @@\n-  _header(true) {\n+  _header(header) {\n@@ -48,2 +49,2 @@\n-JfrCheckpointWriter::JfrCheckpointWriter(Thread* thread, bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, bool global_lease \/* true *\/) :\n-  JfrCheckpointWriterBase(global_lease ? JfrCheckpointManager::lease(thread) : JfrCheckpointManager::lease_thread_local(thread), thread),\n+JfrCheckpointWriter::JfrCheckpointWriter(Thread* thread, bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, JfrCheckpointBufferKind kind \/* JFR_GLOBAL *\/) :\n+  JfrCheckpointWriterBase(JfrCheckpointManager::acquire(thread, kind), thread),\n@@ -63,1 +64,1 @@\n-  JfrCheckpointWriterBase(JfrCheckpointManager::lease(thread, previous_epoch), thread),\n+  JfrCheckpointWriterBase(JfrCheckpointManager::lease_global(thread, previous_epoch), thread),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -73,3 +73,3 @@\n- public:\n-  JfrCheckpointWriter(JfrCheckpointType type = GENERIC);\n-  JfrCheckpointWriter(Thread* thread, bool header = true, JfrCheckpointType mode = GENERIC, bool global_lease = true);\n+public:\n+  JfrCheckpointWriter(bool header = true, JfrCheckpointType mode = GENERIC, JfrCheckpointBufferKind kind = JFR_GLOBAL);\n+  JfrCheckpointWriter(Thread* thread, bool header = true, JfrCheckpointType mode = GENERIC, JfrCheckpointBufferKind kind = JFR_GLOBAL);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -107,1 +108,1 @@\n-  JfrCheckpointWriter writer(jt, true, THREADS, false); \/\/ Thread local lease for blob creation.\n+  JfrCheckpointWriter writer(jt, true, THREADS, JFR_THREADLOCAL); \/\/ Thread local lease for blob creation.\n@@ -122,1 +123,1 @@\n-  JfrCheckpointWriter writer(current, true, THREADS, !is_vthread); \/\/ Virtual Threads use thread local lease.\n+  JfrCheckpointWriter writer(current, true, THREADS, is_vthread ? JFR_VIRTUAL_THREADLOCAL : JFR_THREADLOCAL);\n@@ -205,1 +206,1 @@\n-    JfrCheckpointWriter writer(STATICS);\n+    JfrCheckpointWriter writer(Thread::current(), true, STATICS);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeManager.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  bool _started;\n@@ -73,1 +72,1 @@\n-                                          _started(false), _untimed(timing == UNTIMED),\n+                                          _untimed(timing == UNTIMED),\n@@ -79,5 +78,2 @@\n-    if (T::is_enabled() && JfrThreadLocal::is_included(Thread::current())) {\n-      _started = true;\n-      if (TIMED == timing && !T::isInstant) {\n-        set_starttime(JfrTicks::now());\n-      }\n+    if (!T::isInstant && !_untimed && is_enabled()) {\n+      set_starttime(JfrTicks::now());\n@@ -149,2 +145,2 @@\n-  bool is_started() const {\n-    return _started;\n+  bool is_started() {\n+    return is_instant() || _start_time != 0 || _untimed;\n@@ -154,1 +150,1 @@\n-    if (!_started) {\n+    if (!is_enabled()) {\n@@ -160,3 +156,0 @@\n-    if (_evaluated) {\n-      return _should_commit;\n-    }\n@@ -170,1 +163,7 @@\n-    return _started && (_evaluated ? _should_commit : evaluate());\n+    if (_evaluated) {\n+      return _should_commit;\n+    }\n+    if (!is_enabled()) {\n+      return false;\n+    }\n+    return evaluate() && JfrThreadLocal::is_included(Thread::current());\n@@ -174,1 +173,0 @@\n-    assert(_started, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEvent.hpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-bool JfrBuffer::initialize(size_t header_size, size_t size) {\n+void JfrBuffer::initialize(size_t header_size, size_t size) {\n@@ -51,1 +51,0 @@\n-  return true;\n@@ -54,1 +53,1 @@\n-void JfrBuffer::reinitialize(bool exclusion \/* false *\/) {\n+void JfrBuffer::reinitialize() {\n@@ -176,2 +175,1 @@\n-  LEASE = 4,\n-  EXCLUDED = 8\n+  LEASE = 4\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-  bool initialize(size_t header_size, size_t size);\n-  void reinitialize(bool exclusion = false);\n+  void initialize(size_t header_size, size_t size);\n+  void reinitialize();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,4 +221,1 @@\n-  if (!node->initialize(sizeof(Node), aligned_size_bytes)) {\n-    JfrCHeapObj::free(node, aligned_size_bytes + sizeof(Node));\n-    return NULL;\n-  }\n+  node->initialize(sizeof(Node), aligned_size_bytes);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrMemorySpace.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,6 @@\n+enum JfrCheckpointBufferKind {\n+  JFR_GLOBAL,\n+  JFR_THREADLOCAL,\n+  JFR_VIRTUAL_THREADLOCAL\n+};\n+\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTypes.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1619,0 +1619,1 @@\n+      set_HotSpotInstalledCode_codeStart(obj, 0);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -823,0 +823,1 @@\n+      HotSpotJVMCI::HotSpotInstalledCode::set_codeStart(jvmciEnv, nmethod_mirror, 0);\n@@ -828,0 +829,1 @@\n+      HotSpotJVMCI::HotSpotInstalledCode::set_codeStart(jvmciEnv, nmethod_mirror, 0);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-    return (void*)AllocateHeap(size, f);\n+    return AllocateHeap(size, f);\n@@ -186,1 +186,1 @@\n-    return (void*)AllocateHeap(size, f, stack);\n+    return AllocateHeap(size, f, stack);\n@@ -193,1 +193,1 @@\n-    return (void*)AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n@@ -199,1 +199,1 @@\n-    return (void*)AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n@@ -203,1 +203,1 @@\n-    return (void*)AllocateHeap(size, f);\n+    return AllocateHeap(size, f);\n@@ -209,1 +209,1 @@\n-    return (void*)AllocateHeap(size, f, stack);\n+    return AllocateHeap(size, f, stack);\n@@ -216,1 +216,1 @@\n-    return (void*)AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n@@ -222,1 +222,1 @@\n-    return (void*)AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -274,23 +274,0 @@\n-void* Arena::operator new(size_t size) throw() {\n-  assert(false, \"Use dynamic memory type binding\");\n-  return NULL;\n-}\n-\n-void* Arena::operator new (size_t size, const std::nothrow_t&  nothrow_constant) throw() {\n-  assert(false, \"Use dynamic memory type binding\");\n-  return NULL;\n-}\n-\n-  \/\/ dynamic memory type binding\n-void* Arena::operator new(size_t size, MEMFLAGS flags) throw() {\n-  return (void *) AllocateHeap(size, flags, CALLER_PC);\n-}\n-\n-void* Arena::operator new(size_t size, const std::nothrow_t& nothrow_constant, MEMFLAGS flags) throw() {\n-  return (void*)AllocateHeap(size, flags, CALLER_PC, AllocFailStrategy::RETURN_NULL);\n-}\n-\n-void Arena::operator delete(void* p) {\n-  FreeHeap(p);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-class Arena : public CHeapObj<mtNone> {\n+class Arena : public CHeapObjBase {\n@@ -124,9 +124,0 @@\n-  \/\/ new operators\n-  void* operator new (size_t size) throw();\n-  void* operator new (size_t size, const std::nothrow_t& nothrow_constant) throw();\n-\n-  \/\/ dynamic memory type tagging\n-  void* operator new(size_t size, MEMFLAGS flags) throw();\n-  void* operator new(size_t size, const std::nothrow_t& nothrow_constant, MEMFLAGS flags) throw();\n-  void  operator delete(void* p);\n-\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -303,0 +303,6 @@\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!Matcher::match_rule_supported(Op_ConvHF2F)) return false;\n+    break;\n+  case vmIntrinsics::_floatToFloat16:\n+    if (!Matcher::match_rule_supported(Op_ConvF2HF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+macro(ConvF2HF)\n+macro(ConvHF2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,15 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvF2HFNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == Type::FLOAT ) return TypeInt::SHORT;\n+  const TypeF *tf = t->is_float_constant();\n+  return TypeInt::make( SharedRuntime::f2hf( tf->getf() ) );\n+}\n+\n+\/\/------------------------------Identity---------------------------------------\n+Node* ConvF2HFNode::Identity(PhaseGVN* phase) {\n+  return (in(1)->Opcode() == Op_ConvHF2F) ? in(1)->in(1) : this;\n+}\n+\n@@ -222,0 +237,12 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvHF2FNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == TypeInt::SHORT ) return Type::FLOAT;\n+  const TypeInt *ti = t->is_int();\n+  if ( ti->is_con() ) return TypeF::make( SharedRuntime::hf2f( ti->get_con() ) );\n+\n+  return bottom_type();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -103,0 +103,12 @@\n+\/\/------------------------------ConvF2HFNode------------------------------------\n+\/\/ Convert Float to Halffloat\n+class ConvF2HFNode : public Node {\n+  public:\n+  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n@@ -130,0 +142,11 @@\n+\/\/------------------------------ConvHF2FNode------------------------------------\n+\/\/ Convert Halffloat to float\n+class ConvHF2FNode : public Node {\n+  public:\n+  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -734,1 +734,1 @@\n-  GrowableArray<Node *> nodeStack(Thread::current()->resource_area(), 0, 0, NULL);\n+  GrowableArray<Node *> nodeStack(Thread::current()->resource_area(), 0, 0, nullptr);\n@@ -736,2 +736,1 @@\n-  visited.test_set(start->_idx);\n-  if (C->cfg() != NULL) {\n+  if (C->cfg() != nullptr) {\n@@ -748,1 +747,5 @@\n-  while(nodeStack.length() > 0) {\n+  while (nodeStack.length() > 0) {\n+    Node* n = nodeStack.pop();\n+    if (visited.test_set(n->_idx)) {\n+      continue;\n+    }\n@@ -750,1 +753,0 @@\n-    Node *n = nodeStack.pop();\n@@ -755,4 +757,1 @@\n-        Node* p = n->out(i);\n-        if (!visited.test_set(p->_idx)) {\n-          nodeStack.push(p);\n-        }\n+        nodeStack.push(n->out(i));\n@@ -762,5 +761,3 @@\n-    for ( uint i = 0; i < n->len(); i++ ) {\n-      if ( n->in(i) ) {\n-        if (!visited.test_set(n->in(i)->_idx)) {\n-          nodeStack.push(n->in(i));\n-        }\n+    for (uint i = 0; i < n->len(); i++) {\n+      if (n->in(i) != nullptr) {\n+        nodeStack.push(n->in(i));\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -517,1 +517,3 @@\n-  case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());\n+  case vmIntrinsics::_longBitsToDouble:\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:           return inline_fp_conversions(intrinsic_id());\n@@ -4443,0 +4445,2 @@\n+  case vmIntrinsics::_floatToFloat16:       result = new ConvF2HFNode(arg); break;\n+  case vmIntrinsics::_float16ToFloat:       result = new ConvHF2FNode(arg); break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1007,0 +1007,2 @@\n+      case Op_VectorCastD2X:\n+      case Op_VectorCastF2X:\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,2 +432,2 @@\n-MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted) {\n-  return NULL;\n+int MachNode::peephole(Block *block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc *ra_) {\n+  return -1;\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-  virtual MachNode *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted);\n+  virtual int peephole(Block *block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc *ra_);\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2164,11 +2164,11 @@\n-    \/\/ and each instruction within a block\n-    uint end_index = block->number_of_nodes();\n-    \/\/ block->end_idx() not valid after PhaseRegAlloc\n-    for( uint instruction_index = 1; instruction_index < end_index; ++instruction_index ) {\n-      Node     *n = block->get_node(instruction_index);\n-      if( n->is_Mach() ) {\n-        MachNode *m = n->as_Mach();\n-        int deleted_count = 0;\n-        \/\/ check for peephole opportunities\n-        MachNode *m2 = m->peephole(block, instruction_index, _regalloc, deleted_count);\n-        if( m2 != NULL ) {\n+    for (bool progress = true; progress;) {\n+      progress = false;\n+      \/\/ block->end_idx() not valid after PhaseRegAlloc\n+      uint end_index = block->number_of_nodes();\n+      for( uint instruction_index = end_index - 1; instruction_index > 0; --instruction_index ) {\n+        Node     *n = block->get_node(instruction_index);\n+        if( n->is_Mach() ) {\n+          MachNode *m = n->as_Mach();\n+          \/\/ check for peephole opportunities\n+          int result = m->peephole(block, instruction_index, &_cfg, _regalloc);\n+          if( result != -1 ) {\n@@ -2176,15 +2176,14 @@\n-          if( PrintOptoPeephole ) {\n-            \/\/ Print method, first time only\n-            if( C->method() && method_name_not_printed ) {\n-              C->method()->print_short_name(); tty->cr();\n-              method_name_not_printed = false;\n-            }\n-            \/\/ Print this block\n-            if( Verbose && block_not_printed) {\n-              tty->print_cr(\"in block\");\n-              block->dump();\n-              block_not_printed = false;\n-            }\n-            \/\/ Print instructions being deleted\n-            for( int i = (deleted_count - 1); i >= 0; --i ) {\n-              block->get_node(instruction_index-i)->as_Mach()->format(_regalloc); tty->cr();\n+            if( PrintOptoPeephole ) {\n+              \/\/ Print method, first time only\n+              if( C->method() && method_name_not_printed ) {\n+                C->method()->print_short_name(); tty->cr();\n+                method_name_not_printed = false;\n+              }\n+              \/\/ Print this block\n+              if( Verbose && block_not_printed) {\n+                tty->print_cr(\"in block\");\n+                block->dump();\n+                block_not_printed = false;\n+              }\n+              \/\/ Print the peephole number\n+              tty->print_cr(\"peephole number: %d\", result);\n@@ -2192,5 +2191,1 @@\n-            tty->print_cr(\"replaced with\");\n-            \/\/ Print new instruction\n-            m2->format(_regalloc);\n-            tty->print(\"\\n\\n\");\n-          }\n+            inc_peepholes();\n@@ -2198,7 +2193,3 @@\n-          \/\/ Remove old nodes from basic block and update instruction_index\n-          \/\/ (old nodes still exist and may have edges pointing to them\n-          \/\/  as register allocation info is stored in the allocator using\n-          \/\/  the node index to live range mappings.)\n-          uint safe_instruction_index = (instruction_index - deleted_count);\n-          for( ; (instruction_index > safe_instruction_index); --instruction_index ) {\n-            block->remove_node( instruction_index );\n+            \/\/ Set progress, start again\n+            progress = true;\n+            break;\n@@ -2206,4 +2197,0 @@\n-          \/\/ install new node after safe_instruction_index\n-          block->insert_node(m2, safe_instruction_index + 1);\n-          end_index = block->number_of_nodes() - 1; \/\/ Recompute new block size\n-          NOT_PRODUCT( inc_peepholes(); )\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":29,"deletions":42,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2491,9 +2491,2 @@\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    if (is_mask && is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_mask && is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from, !is_ucast);\n+    assert(!is_mask || num_elem_from == num_elem_to, \"vector mask cast needs the same elem num\");\n+    int cast_vopc = VectorCastNode::opcode(elem_bt_from, !is_ucast);\n@@ -2501,5 +2494,3 @@\n-    \/\/ Make sure that vector cast is implemented to particular type\/size combination.\n-    bool no_vec_cast_check = is_mask &&\n-                             ((src_type->isa_vectmask() && dst_type->isa_vectmask()) ||\n-                              type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to));\n-    if (!no_vec_cast_check && !arch_supports_vector(cast_vopc, num_elem_to, new_elem_bt_to, VecMaskNotUsed)) {\n+    \/\/ Make sure that vector cast is implemented to particular type\/size combination if it is\n+    \/\/ not a mask casting.\n+    if (!is_mask && !arch_supports_vector(cast_vopc, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n@@ -2508,1 +2499,1 @@\n-                      cast_vopc, num_elem_to, type2name(new_elem_bt_to), is_mask);\n+                      cast_vopc, num_elem_to, type2name(elem_bt_to), is_mask);\n@@ -2555,5 +2546,7 @@\n-        if ((dst_type->isa_vectmask() && src_type->isa_vectmask()) ||\n-            (type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to))) {\n-          op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n-        } else {\n-          op = VectorMaskCastNode::makeCastNode(&gvn(), op, dst_type);\n+        \/\/ Make sure that cast for vector mask is implemented to particular type\/size combination.\n+        if (!arch_supports_vector(Op_VectorMaskCast, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n+          if (C->print_intrinsics()) {\n+            tty->print_cr(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n+                          num_elem_to, type2name(elem_bt_to), is_mask);\n+          }\n+          return false;\n@@ -2561,0 +2554,1 @@\n+        op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1622,0 +1622,1 @@\n+          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n@@ -1623,10 +1624,1 @@\n-          if (in_vt->length_in_bytes() == out_vt->length_in_bytes() &&\n-              Matcher::match_rule_supported_vector(Op_VectorMaskCast, out_vt->length(), out_vt->element_basic_type())) {\n-            \/\/ Apply \"VectorUnbox (VectorBox vmask) ==> VectorMaskCast (vmask)\"\n-            \/\/ directly. This could avoid the transformation ordering issue from\n-            \/\/ \"VectorStoreMask (VectorLoadMask vmask) => vmask\".\n-            return new VectorMaskCastNode(value, vmask_type);\n-          }\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorLoadMask (VectorStoreMask vmask)\n-          value = phase->transform(VectorStoreMaskNode::make(*phase, value, in_vt->element_basic_type(), in_vt->length()));\n-          return new VectorLoadMaskNode(value, vmask_type);\n+          return new VectorMaskCastNode(value, vmask_type);\n@@ -1723,42 +1715,0 @@\n-Node* VectorMaskCastNode::makeCastNode(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n-  const TypeVect* src_type = src->bottom_type()->is_vect();\n-  assert(src_type->length() == dst_type->length(), \"\");\n-\n-  int num_elem = src_type->length();\n-  BasicType elem_bt_from = src_type->element_basic_type();\n-  BasicType elem_bt_to = dst_type->element_basic_type();\n-\n-  if (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask() == NULL &&\n-      type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to)) {\n-\n-    Node* op = src;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    if (is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from =  elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-\n-    \/\/ Special handling for casting operation involving floating point types.\n-    \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n-    \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n-    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n-\n-    if (new_elem_bt_from != elem_bt_from) {\n-      const TypeVect* new_src_type = TypeVect::makemask(new_elem_bt_from, num_elem);\n-      op = phase->transform(new VectorMaskCastNode(op, new_src_type));\n-    }\n-\n-    op = phase->transform(VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem));\n-\n-    if (new_elem_bt_to != elem_bt_to) {\n-      op = phase->transform(new VectorMaskCastNode(op, dst_type));\n-    }\n-    return op;\n-  } else {\n-    return new VectorMaskCastNode(src, dst_type);\n-  }\n-}\n-\n@@ -1785,1 +1735,1 @@\n-       return VectorMaskCastNode::makeCastNode(phase, src, dst_type);\n+       return new VectorMaskCastNode(src, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":53,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1508,1 +1508,0 @@\n-  static Node* makeCastNode(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,5 +206,1 @@\n-      #if _MSC_VER == 1800\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 12.0 (VS2013)\"\n-      #elif _MSC_VER == 1900\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 14.0 (VS2015)\"\n-      #elif _MSC_VER == 1911\n+      #if _MSC_VER == 1911\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3155,6 +3155,0 @@\n-\n-  \/\/ Zero runs without compilers. Do not let compiler selection code\n-  \/\/ to force it into Serial GC, let the GC ergonomics decide.\n-  if (FLAG_IS_DEFAULT(NeverActAsServerClassMachine)) {\n-    FLAG_SET_ERGO(NeverActAsServerClassMachine, false);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -573,2 +573,2 @@\n-    st->print(\" - obj    [\");\n-    current->obj()->print_value_on(st);\n+    st->print(\" - obj    [%s\", current->obj() == nullptr ? \"null\" : \"\");\n+    if (current->obj() != nullptr) current->obj()->print_value_on(st);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -274,0 +274,4 @@\n+JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n+  return (jfloat)x;\n+JRT_END\n+\n@@ -307,4 +311,0 @@\n-JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n-  return (jfloat)x;\n-JRT_END\n-\n@@ -451,0 +451,80 @@\n+\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:floatToFloat16\n+JRT_LEAF(jshort, SharedRuntime::f2hf(jfloat  x))\n+  jint doppel = SharedRuntime::f2i(x);\n+  jshort sign_bit = (jshort) ((doppel & 0x80000000) >> 16);\n+  if (g_isnan(x))\n+    return (jshort)(sign_bit | 0x7c00 | (doppel & 0x007fe000) >> 13 | (doppel & 0x00001ff0) >> 4 | (doppel & 0x0000000f));\n+\n+  jfloat abs_f = (x >= 0.0f) ? x : (x * -1.0f);\n+\n+  \/\/ Overflow threshold is halffloat max value + 1\/2 ulp\n+  if (abs_f >= (65504.0f + 16.0f)) {\n+    return (jshort)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+  }\n+\n+  \/\/ Smallest magnitude of Halffloat is 0x1.0p-24, half-way or smaller rounds to zero\n+  if (abs_f <= (pow(2, -24) * 0.5f)) { \/\/ Covers float zeros and subnormals.\n+    return sign_bit; \/\/ Positive or negative zero\n+  }\n+\n+  jint exp = 0x7f800000 & doppel;\n+\n+  \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+  \/\/ the difference exp_delta = E_min - exp.  This is the excess\n+  \/\/ shift value, in addition to 13, to be used in the\n+  \/\/ computations below. Further the (hidden) msb with value 1\n+  \/\/ in f must be involved as well\n+  jint exp_delta = 0;\n+  jint msb = 0x00000000;\n+  if (exp < -14) {\n+    exp_delta = -14 - exp;\n+    exp = -15;\n+    msb = 0x00800000;\n+  }\n+  jint f_signif_bits = ((doppel & 0x007fffff) | msb);\n+\n+  \/\/ Significand bits as if using rounding to zero\n+  jshort signif_bits = (jshort)(f_signif_bits >> (13 + exp_delta));\n+\n+  jint lsb = f_signif_bits & (1 << (13 + exp_delta));\n+  jint round  = f_signif_bits & (1 << (12 + exp_delta));\n+  jint sticky = f_signif_bits & ((1 << (12 + exp_delta)) - 1);\n+\n+  if (round != 0 && ((lsb | sticky) != 0 )) {\n+    signif_bits++;\n+  }\n+\n+  return (jshort)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+JRT_END\n+\n+\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:float16ToFloat\n+JRT_LEAF(jfloat, SharedRuntime::hf2f(jshort x))\n+  \/\/ Halffloat format has 1 signbit, 5 exponent bits and\n+  \/\/ 10 significand bits\n+  jint hf_arg = (jint)x;\n+  jint hf_sign_bit = 0x8000 & hf_arg;\n+  jint hf_exp_bits = 0x7c00 & hf_arg;\n+  jint hf_significand_bits = 0x03ff & hf_arg;\n+\n+  jint significand_shift = 13; \/\/difference between float and halffloat precision\n+\n+  jfloat sign = (hf_sign_bit != 0) ? -1.0f : 1.0f;\n+\n+  \/\/ Extract halffloat exponent, remove its bias\n+  jint hf_exp = (hf_exp_bits >> 10) - 15;\n+\n+  if (hf_exp == -15) {\n+    \/\/ For subnormal values, return 2^-24 * significand bits\n+    return (sign * (pow(2,-24)) * hf_significand_bits);\n+  }else if (hf_exp == 16) {\n+    return (hf_significand_bits == 0) ? sign * float_infinity : (SharedRuntime::i2f((hf_sign_bit << 16) | 0x7f800000 |\n+           (hf_significand_bits << significand_shift)));\n+  }\n+\n+  \/\/ Add the bias of float exponent and shift\n+  int float_exp_bits = (hf_exp + 127) << (24 - 1);\n+\n+  \/\/ Combine sign, exponent and significand bits\n+  return SharedRuntime::i2f((hf_sign_bit << 16) | float_exp_bits | (hf_significand_bits << significand_shift));\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":84,"deletions":4,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  static jfloat  hf2f(jshort  x);\n+  static jshort  f2hf(jfloat  x);\n+  static jfloat  i2f (jint    x);\n@@ -134,1 +137,0 @@\n-  static jfloat  i2f (jint    x);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,2 +52,959 @@\n-final class AESCrypt extends SymmetricCipher implements AESConstants\n-{\n+final class AESCrypt extends SymmetricCipher implements AESConstants {\n+    \/\/\n+    \/\/ Pre-computed tables, which are copied or derived from FIPS 197.\n+    \/\/\n+\n+    \/\/ the pre-computed substitution table (S-box), 256 bytes\n+    private static final byte[] S = {\n+            (byte)0x63, (byte)0x7C, (byte)0x77, (byte)0x7B,\n+            (byte)0xF2, (byte)0x6B, (byte)0x6F, (byte)0xC5,\n+            (byte)0x30, (byte)0x01, (byte)0x67, (byte)0x2B,\n+            (byte)0xFE, (byte)0xD7, (byte)0xAB, (byte)0x76,\n+            (byte)0xCA, (byte)0x82, (byte)0xC9, (byte)0x7D,\n+            (byte)0xFA, (byte)0x59, (byte)0x47, (byte)0xF0,\n+            (byte)0xAD, (byte)0xD4, (byte)0xA2, (byte)0xAF,\n+            (byte)0x9C, (byte)0xA4, (byte)0x72, (byte)0xC0,\n+            (byte)0xB7, (byte)0xFD, (byte)0x93, (byte)0x26,\n+            (byte)0x36, (byte)0x3F, (byte)0xF7, (byte)0xCC,\n+            (byte)0x34, (byte)0xA5, (byte)0xE5, (byte)0xF1,\n+            (byte)0x71, (byte)0xD8, (byte)0x31, (byte)0x15,\n+            (byte)0x04, (byte)0xC7, (byte)0x23, (byte)0xC3,\n+            (byte)0x18, (byte)0x96, (byte)0x05, (byte)0x9A,\n+            (byte)0x07, (byte)0x12, (byte)0x80, (byte)0xE2,\n+            (byte)0xEB, (byte)0x27, (byte)0xB2, (byte)0x75,\n+            (byte)0x09, (byte)0x83, (byte)0x2C, (byte)0x1A,\n+            (byte)0x1B, (byte)0x6E, (byte)0x5A, (byte)0xA0,\n+            (byte)0x52, (byte)0x3B, (byte)0xD6, (byte)0xB3,\n+            (byte)0x29, (byte)0xE3, (byte)0x2F, (byte)0x84,\n+            (byte)0x53, (byte)0xD1, (byte)0x00, (byte)0xED,\n+            (byte)0x20, (byte)0xFC, (byte)0xB1, (byte)0x5B,\n+            (byte)0x6A, (byte)0xCB, (byte)0xBE, (byte)0x39,\n+            (byte)0x4A, (byte)0x4C, (byte)0x58, (byte)0xCF,\n+            (byte)0xD0, (byte)0xEF, (byte)0xAA, (byte)0xFB,\n+            (byte)0x43, (byte)0x4D, (byte)0x33, (byte)0x85,\n+            (byte)0x45, (byte)0xF9, (byte)0x02, (byte)0x7F,\n+            (byte)0x50, (byte)0x3C, (byte)0x9F, (byte)0xA8,\n+            (byte)0x51, (byte)0xA3, (byte)0x40, (byte)0x8F,\n+            (byte)0x92, (byte)0x9D, (byte)0x38, (byte)0xF5,\n+            (byte)0xBC, (byte)0xB6, (byte)0xDA, (byte)0x21,\n+            (byte)0x10, (byte)0xFF, (byte)0xF3, (byte)0xD2,\n+            (byte)0xCD, (byte)0x0C, (byte)0x13, (byte)0xEC,\n+            (byte)0x5F, (byte)0x97, (byte)0x44, (byte)0x17,\n+            (byte)0xC4, (byte)0xA7, (byte)0x7E, (byte)0x3D,\n+            (byte)0x64, (byte)0x5D, (byte)0x19, (byte)0x73,\n+            (byte)0x60, (byte)0x81, (byte)0x4F, (byte)0xDC,\n+            (byte)0x22, (byte)0x2A, (byte)0x90, (byte)0x88,\n+            (byte)0x46, (byte)0xEE, (byte)0xB8, (byte)0x14,\n+            (byte)0xDE, (byte)0x5E, (byte)0x0B, (byte)0xDB,\n+            (byte)0xE0, (byte)0x32, (byte)0x3A, (byte)0x0A,\n+            (byte)0x49, (byte)0x06, (byte)0x24, (byte)0x5C,\n+            (byte)0xC2, (byte)0xD3, (byte)0xAC, (byte)0x62,\n+            (byte)0x91, (byte)0x95, (byte)0xE4, (byte)0x79,\n+            (byte)0xE7, (byte)0xC8, (byte)0x37, (byte)0x6D,\n+            (byte)0x8D, (byte)0xD5, (byte)0x4E, (byte)0xA9,\n+            (byte)0x6C, (byte)0x56, (byte)0xF4, (byte)0xEA,\n+            (byte)0x65, (byte)0x7A, (byte)0xAE, (byte)0x08,\n+            (byte)0xBA, (byte)0x78, (byte)0x25, (byte)0x2E,\n+            (byte)0x1C, (byte)0xA6, (byte)0xB4, (byte)0xC6,\n+            (byte)0xE8, (byte)0xDD, (byte)0x74, (byte)0x1F,\n+            (byte)0x4B, (byte)0xBD, (byte)0x8B, (byte)0x8A,\n+            (byte)0x70, (byte)0x3E, (byte)0xB5, (byte)0x66,\n+            (byte)0x48, (byte)0x03, (byte)0xF6, (byte)0x0E,\n+            (byte)0x61, (byte)0x35, (byte)0x57, (byte)0xB9,\n+            (byte)0x86, (byte)0xC1, (byte)0x1D, (byte)0x9E,\n+            (byte)0xE1, (byte)0xF8, (byte)0x98, (byte)0x11,\n+            (byte)0x69, (byte)0xD9, (byte)0x8E, (byte)0x94,\n+            (byte)0x9B, (byte)0x1E, (byte)0x87, (byte)0xE9,\n+            (byte)0xCE, (byte)0x55, (byte)0x28, (byte)0xDF,\n+            (byte)0x8C, (byte)0xA1, (byte)0x89, (byte)0x0D,\n+            (byte)0xBF, (byte)0xE6, (byte)0x42, (byte)0x68,\n+            (byte)0x41, (byte)0x99, (byte)0x2D, (byte)0x0F,\n+            (byte)0xB0, (byte)0x54, (byte)0xBB, (byte)0x16,\n+    };\n+\n+    \/\/ the pre-computed substitution table (inverse S-box), 256 bytes\n+    private static final byte[] Si = {\n+            (byte)0x52, (byte)0x09, (byte)0x6A, (byte)0xD5,\n+            (byte)0x30, (byte)0x36, (byte)0xA5, (byte)0x38,\n+            (byte)0xBF, (byte)0x40, (byte)0xA3, (byte)0x9E,\n+            (byte)0x81, (byte)0xF3, (byte)0xD7, (byte)0xFB,\n+            (byte)0x7C, (byte)0xE3, (byte)0x39, (byte)0x82,\n+            (byte)0x9B, (byte)0x2F, (byte)0xFF, (byte)0x87,\n+            (byte)0x34, (byte)0x8E, (byte)0x43, (byte)0x44,\n+            (byte)0xC4, (byte)0xDE, (byte)0xE9, (byte)0xCB,\n+            (byte)0x54, (byte)0x7B, (byte)0x94, (byte)0x32,\n+            (byte)0xA6, (byte)0xC2, (byte)0x23, (byte)0x3D,\n+            (byte)0xEE, (byte)0x4C, (byte)0x95, (byte)0x0B,\n+            (byte)0x42, (byte)0xFA, (byte)0xC3, (byte)0x4E,\n+            (byte)0x08, (byte)0x2E, (byte)0xA1, (byte)0x66,\n+            (byte)0x28, (byte)0xD9, (byte)0x24, (byte)0xB2,\n+            (byte)0x76, (byte)0x5B, (byte)0xA2, (byte)0x49,\n+            (byte)0x6D, (byte)0x8B, (byte)0xD1, (byte)0x25,\n+            (byte)0x72, (byte)0xF8, (byte)0xF6, (byte)0x64,\n+            (byte)0x86, (byte)0x68, (byte)0x98, (byte)0x16,\n+            (byte)0xD4, (byte)0xA4, (byte)0x5C, (byte)0xCC,\n+            (byte)0x5D, (byte)0x65, (byte)0xB6, (byte)0x92,\n+            (byte)0x6C, (byte)0x70, (byte)0x48, (byte)0x50,\n+            (byte)0xFD, (byte)0xED, (byte)0xB9, (byte)0xDA,\n+            (byte)0x5E, (byte)0x15, (byte)0x46, (byte)0x57,\n+            (byte)0xA7, (byte)0x8D, (byte)0x9D, (byte)0x84,\n+            (byte)0x90, (byte)0xD8, (byte)0xAB, (byte)0x00,\n+            (byte)0x8C, (byte)0xBC, (byte)0xD3, (byte)0x0A,\n+            (byte)0xF7, (byte)0xE4, (byte)0x58, (byte)0x05,\n+            (byte)0xB8, (byte)0xB3, (byte)0x45, (byte)0x06,\n+            (byte)0xD0, (byte)0x2C, (byte)0x1E, (byte)0x8F,\n+            (byte)0xCA, (byte)0x3F, (byte)0x0F, (byte)0x02,\n+            (byte)0xC1, (byte)0xAF, (byte)0xBD, (byte)0x03,\n+            (byte)0x01, (byte)0x13, (byte)0x8A, (byte)0x6B,\n+            (byte)0x3A, (byte)0x91, (byte)0x11, (byte)0x41,\n+            (byte)0x4F, (byte)0x67, (byte)0xDC, (byte)0xEA,\n+            (byte)0x97, (byte)0xF2, (byte)0xCF, (byte)0xCE,\n+            (byte)0xF0, (byte)0xB4, (byte)0xE6, (byte)0x73,\n+            (byte)0x96, (byte)0xAC, (byte)0x74, (byte)0x22,\n+            (byte)0xE7, (byte)0xAD, (byte)0x35, (byte)0x85,\n+            (byte)0xE2, (byte)0xF9, (byte)0x37, (byte)0xE8,\n+            (byte)0x1C, (byte)0x75, (byte)0xDF, (byte)0x6E,\n+            (byte)0x47, (byte)0xF1, (byte)0x1A, (byte)0x71,\n+            (byte)0x1D, (byte)0x29, (byte)0xC5, (byte)0x89,\n+            (byte)0x6F, (byte)0xB7, (byte)0x62, (byte)0x0E,\n+            (byte)0xAA, (byte)0x18, (byte)0xBE, (byte)0x1B,\n+            (byte)0xFC, (byte)0x56, (byte)0x3E, (byte)0x4B,\n+            (byte)0xC6, (byte)0xD2, (byte)0x79, (byte)0x20,\n+            (byte)0x9A, (byte)0xDB, (byte)0xC0, (byte)0xFE,\n+            (byte)0x78, (byte)0xCD, (byte)0x5A, (byte)0xF4,\n+            (byte)0x1F, (byte)0xDD, (byte)0xA8, (byte)0x33,\n+            (byte)0x88, (byte)0x07, (byte)0xC7, (byte)0x31,\n+            (byte)0xB1, (byte)0x12, (byte)0x10, (byte)0x59,\n+            (byte)0x27, (byte)0x80, (byte)0xEC, (byte)0x5F,\n+            (byte)0x60, (byte)0x51, (byte)0x7F, (byte)0xA9,\n+            (byte)0x19, (byte)0xB5, (byte)0x4A, (byte)0x0D,\n+            (byte)0x2D, (byte)0xE5, (byte)0x7A, (byte)0x9F,\n+            (byte)0x93, (byte)0xC9, (byte)0x9C, (byte)0xEF,\n+            (byte)0xA0, (byte)0xE0, (byte)0x3B, (byte)0x4D,\n+            (byte)0xAE, (byte)0x2A, (byte)0xF5, (byte)0xB0,\n+            (byte)0xC8, (byte)0xEB, (byte)0xBB, (byte)0x3C,\n+            (byte)0x83, (byte)0x53, (byte)0x99, (byte)0x61,\n+            (byte)0x17, (byte)0x2B, (byte)0x04, (byte)0x7E,\n+            (byte)0xBA, (byte)0x77, (byte)0xD6, (byte)0x26,\n+            (byte)0xE1, (byte)0x69, (byte)0x14, (byte)0x63,\n+            (byte)0x55, (byte)0x21, (byte)0x0C, (byte)0x7D,\n+    };\n+\n+    \/\/ pre-computed tables (T-box)\n+    private static final int[] T1 = {\n+            0xC66363A5, 0xF87C7C84, 0xEE777799, 0xF67B7B8D,\n+            0xFFF2F20D, 0xD66B6BBD, 0xDE6F6FB1, 0x91C5C554,\n+            0x60303050, 0x02010103, 0xCE6767A9, 0x562B2B7D,\n+            0xE7FEFE19, 0xB5D7D762, 0x4DABABE6, 0xEC76769A,\n+            0x8FCACA45, 0x1F82829D, 0x89C9C940, 0xFA7D7D87,\n+            0xEFFAFA15, 0xB25959EB, 0x8E4747C9, 0xFBF0F00B,\n+            0x41ADADEC, 0xB3D4D467, 0x5FA2A2FD, 0x45AFAFEA,\n+            0x239C9CBF, 0x53A4A4F7, 0xE4727296, 0x9BC0C05B,\n+            0x75B7B7C2, 0xE1FDFD1C, 0x3D9393AE, 0x4C26266A,\n+            0x6C36365A, 0x7E3F3F41, 0xF5F7F702, 0x83CCCC4F,\n+            0x6834345C, 0x51A5A5F4, 0xD1E5E534, 0xF9F1F108,\n+            0xE2717193, 0xABD8D873, 0x62313153, 0x2A15153F,\n+            0x0804040C, 0x95C7C752, 0x46232365, 0x9DC3C35E,\n+            0x30181828, 0x379696A1, 0x0A05050F, 0x2F9A9AB5,\n+            0x0E070709, 0x24121236, 0x1B80809B, 0xDFE2E23D,\n+            0xCDEBEB26, 0x4E272769, 0x7FB2B2CD, 0xEA75759F,\n+            0x1209091B, 0x1D83839E, 0x582C2C74, 0x341A1A2E,\n+            0x361B1B2D, 0xDC6E6EB2, 0xB45A5AEE, 0x5BA0A0FB,\n+            0xA45252F6, 0x763B3B4D, 0xB7D6D661, 0x7DB3B3CE,\n+            0x5229297B, 0xDDE3E33E, 0x5E2F2F71, 0x13848497,\n+            0xA65353F5, 0xB9D1D168, 0x00000000, 0xC1EDED2C,\n+            0x40202060, 0xE3FCFC1F, 0x79B1B1C8, 0xB65B5BED,\n+            0xD46A6ABE, 0x8DCBCB46, 0x67BEBED9, 0x7239394B,\n+            0x944A4ADE, 0x984C4CD4, 0xB05858E8, 0x85CFCF4A,\n+            0xBBD0D06B, 0xC5EFEF2A, 0x4FAAAAE5, 0xEDFBFB16,\n+            0x864343C5, 0x9A4D4DD7, 0x66333355, 0x11858594,\n+            0x8A4545CF, 0xE9F9F910, 0x04020206, 0xFE7F7F81,\n+            0xA05050F0, 0x783C3C44, 0x259F9FBA, 0x4BA8A8E3,\n+            0xA25151F3, 0x5DA3A3FE, 0x804040C0, 0x058F8F8A,\n+            0x3F9292AD, 0x219D9DBC, 0x70383848, 0xF1F5F504,\n+            0x63BCBCDF, 0x77B6B6C1, 0xAFDADA75, 0x42212163,\n+            0x20101030, 0xE5FFFF1A, 0xFDF3F30E, 0xBFD2D26D,\n+            0x81CDCD4C, 0x180C0C14, 0x26131335, 0xC3ECEC2F,\n+            0xBE5F5FE1, 0x359797A2, 0x884444CC, 0x2E171739,\n+            0x93C4C457, 0x55A7A7F2, 0xFC7E7E82, 0x7A3D3D47,\n+            0xC86464AC, 0xBA5D5DE7, 0x3219192B, 0xE6737395,\n+            0xC06060A0, 0x19818198, 0x9E4F4FD1, 0xA3DCDC7F,\n+            0x44222266, 0x542A2A7E, 0x3B9090AB, 0x0B888883,\n+            0x8C4646CA, 0xC7EEEE29, 0x6BB8B8D3, 0x2814143C,\n+            0xA7DEDE79, 0xBC5E5EE2, 0x160B0B1D, 0xADDBDB76,\n+            0xDBE0E03B, 0x64323256, 0x743A3A4E, 0x140A0A1E,\n+            0x924949DB, 0x0C06060A, 0x4824246C, 0xB85C5CE4,\n+            0x9FC2C25D, 0xBDD3D36E, 0x43ACACEF, 0xC46262A6,\n+            0x399191A8, 0x319595A4, 0xD3E4E437, 0xF279798B,\n+            0xD5E7E732, 0x8BC8C843, 0x6E373759, 0xDA6D6DB7,\n+            0x018D8D8C, 0xB1D5D564, 0x9C4E4ED2, 0x49A9A9E0,\n+            0xD86C6CB4, 0xAC5656FA, 0xF3F4F407, 0xCFEAEA25,\n+            0xCA6565AF, 0xF47A7A8E, 0x47AEAEE9, 0x10080818,\n+            0x6FBABAD5, 0xF0787888, 0x4A25256F, 0x5C2E2E72,\n+            0x381C1C24, 0x57A6A6F1, 0x73B4B4C7, 0x97C6C651,\n+            0xCBE8E823, 0xA1DDDD7C, 0xE874749C, 0x3E1F1F21,\n+            0x964B4BDD, 0x61BDBDDC, 0x0D8B8B86, 0x0F8A8A85,\n+            0xE0707090, 0x7C3E3E42, 0x71B5B5C4, 0xCC6666AA,\n+            0x904848D8, 0x06030305, 0xF7F6F601, 0x1C0E0E12,\n+            0xC26161A3, 0x6A35355F, 0xAE5757F9, 0x69B9B9D0,\n+            0x17868691, 0x99C1C158, 0x3A1D1D27, 0x279E9EB9,\n+            0xD9E1E138, 0xEBF8F813, 0x2B9898B3, 0x22111133,\n+            0xD26969BB, 0xA9D9D970, 0x078E8E89, 0x339494A7,\n+            0x2D9B9BB6, 0x3C1E1E22, 0x15878792, 0xC9E9E920,\n+            0x87CECE49, 0xAA5555FF, 0x50282878, 0xA5DFDF7A,\n+            0x038C8C8F, 0x59A1A1F8, 0x09898980, 0x1A0D0D17,\n+            0x65BFBFDA, 0xD7E6E631, 0x844242C6, 0xD06868B8,\n+            0x824141C3, 0x299999B0, 0x5A2D2D77, 0x1E0F0F11,\n+            0x7BB0B0CB, 0xA85454FC, 0x6DBBBBD6, 0x2C16163A,\n+    };\n+\n+    private static final int[] T2 = {\n+            0xA5C66363, 0x84F87C7C, 0x99EE7777, 0x8DF67B7B,\n+            0x0DFFF2F2, 0xBDD66B6B, 0xB1DE6F6F, 0x5491C5C5,\n+            0x50603030, 0x03020101, 0xA9CE6767, 0x7D562B2B,\n+            0x19E7FEFE, 0x62B5D7D7, 0xE64DABAB, 0x9AEC7676,\n+            0x458FCACA, 0x9D1F8282, 0x4089C9C9, 0x87FA7D7D,\n+            0x15EFFAFA, 0xEBB25959, 0xC98E4747, 0x0BFBF0F0,\n+            0xEC41ADAD, 0x67B3D4D4, 0xFD5FA2A2, 0xEA45AFAF,\n+            0xBF239C9C, 0xF753A4A4, 0x96E47272, 0x5B9BC0C0,\n+            0xC275B7B7, 0x1CE1FDFD, 0xAE3D9393, 0x6A4C2626,\n+            0x5A6C3636, 0x417E3F3F, 0x02F5F7F7, 0x4F83CCCC,\n+            0x5C683434, 0xF451A5A5, 0x34D1E5E5, 0x08F9F1F1,\n+            0x93E27171, 0x73ABD8D8, 0x53623131, 0x3F2A1515,\n+            0x0C080404, 0x5295C7C7, 0x65462323, 0x5E9DC3C3,\n+            0x28301818, 0xA1379696, 0x0F0A0505, 0xB52F9A9A,\n+            0x090E0707, 0x36241212, 0x9B1B8080, 0x3DDFE2E2,\n+            0x26CDEBEB, 0x694E2727, 0xCD7FB2B2, 0x9FEA7575,\n+            0x1B120909, 0x9E1D8383, 0x74582C2C, 0x2E341A1A,\n+            0x2D361B1B, 0xB2DC6E6E, 0xEEB45A5A, 0xFB5BA0A0,\n+            0xF6A45252, 0x4D763B3B, 0x61B7D6D6, 0xCE7DB3B3,\n+            0x7B522929, 0x3EDDE3E3, 0x715E2F2F, 0x97138484,\n+            0xF5A65353, 0x68B9D1D1, 0x00000000, 0x2CC1EDED,\n+            0x60402020, 0x1FE3FCFC, 0xC879B1B1, 0xEDB65B5B,\n+            0xBED46A6A, 0x468DCBCB, 0xD967BEBE, 0x4B723939,\n+            0xDE944A4A, 0xD4984C4C, 0xE8B05858, 0x4A85CFCF,\n+            0x6BBBD0D0, 0x2AC5EFEF, 0xE54FAAAA, 0x16EDFBFB,\n+            0xC5864343, 0xD79A4D4D, 0x55663333, 0x94118585,\n+            0xCF8A4545, 0x10E9F9F9, 0x06040202, 0x81FE7F7F,\n+            0xF0A05050, 0x44783C3C, 0xBA259F9F, 0xE34BA8A8,\n+            0xF3A25151, 0xFE5DA3A3, 0xC0804040, 0x8A058F8F,\n+            0xAD3F9292, 0xBC219D9D, 0x48703838, 0x04F1F5F5,\n+            0xDF63BCBC, 0xC177B6B6, 0x75AFDADA, 0x63422121,\n+            0x30201010, 0x1AE5FFFF, 0x0EFDF3F3, 0x6DBFD2D2,\n+            0x4C81CDCD, 0x14180C0C, 0x35261313, 0x2FC3ECEC,\n+            0xE1BE5F5F, 0xA2359797, 0xCC884444, 0x392E1717,\n+            0x5793C4C4, 0xF255A7A7, 0x82FC7E7E, 0x477A3D3D,\n+            0xACC86464, 0xE7BA5D5D, 0x2B321919, 0x95E67373,\n+            0xA0C06060, 0x98198181, 0xD19E4F4F, 0x7FA3DCDC,\n+            0x66442222, 0x7E542A2A, 0xAB3B9090, 0x830B8888,\n+            0xCA8C4646, 0x29C7EEEE, 0xD36BB8B8, 0x3C281414,\n+            0x79A7DEDE, 0xE2BC5E5E, 0x1D160B0B, 0x76ADDBDB,\n+            0x3BDBE0E0, 0x56643232, 0x4E743A3A, 0x1E140A0A,\n+            0xDB924949, 0x0A0C0606, 0x6C482424, 0xE4B85C5C,\n+            0x5D9FC2C2, 0x6EBDD3D3, 0xEF43ACAC, 0xA6C46262,\n+            0xA8399191, 0xA4319595, 0x37D3E4E4, 0x8BF27979,\n+            0x32D5E7E7, 0x438BC8C8, 0x596E3737, 0xB7DA6D6D,\n+            0x8C018D8D, 0x64B1D5D5, 0xD29C4E4E, 0xE049A9A9,\n+            0xB4D86C6C, 0xFAAC5656, 0x07F3F4F4, 0x25CFEAEA,\n+            0xAFCA6565, 0x8EF47A7A, 0xE947AEAE, 0x18100808,\n+            0xD56FBABA, 0x88F07878, 0x6F4A2525, 0x725C2E2E,\n+            0x24381C1C, 0xF157A6A6, 0xC773B4B4, 0x5197C6C6,\n+            0x23CBE8E8, 0x7CA1DDDD, 0x9CE87474, 0x213E1F1F,\n+            0xDD964B4B, 0xDC61BDBD, 0x860D8B8B, 0x850F8A8A,\n+            0x90E07070, 0x427C3E3E, 0xC471B5B5, 0xAACC6666,\n+            0xD8904848, 0x05060303, 0x01F7F6F6, 0x121C0E0E,\n+            0xA3C26161, 0x5F6A3535, 0xF9AE5757, 0xD069B9B9,\n+            0x91178686, 0x5899C1C1, 0x273A1D1D, 0xB9279E9E,\n+            0x38D9E1E1, 0x13EBF8F8, 0xB32B9898, 0x33221111,\n+            0xBBD26969, 0x70A9D9D9, 0x89078E8E, 0xA7339494,\n+            0xB62D9B9B, 0x223C1E1E, 0x92158787, 0x20C9E9E9,\n+            0x4987CECE, 0xFFAA5555, 0x78502828, 0x7AA5DFDF,\n+            0x8F038C8C, 0xF859A1A1, 0x80098989, 0x171A0D0D,\n+            0xDA65BFBF, 0x31D7E6E6, 0xC6844242, 0xB8D06868,\n+            0xC3824141, 0xB0299999, 0x775A2D2D, 0x111E0F0F,\n+            0xCB7BB0B0, 0xFCA85454, 0xD66DBBBB, 0x3A2C1616,\n+    };\n+\n+    private static final int[] T3 = {\n+            0x63A5C663, 0x7C84F87C, 0x7799EE77, 0x7B8DF67B,\n+            0xF20DFFF2, 0x6BBDD66B, 0x6FB1DE6F, 0xC55491C5,\n+            0x30506030, 0x01030201, 0x67A9CE67, 0x2B7D562B,\n+            0xFE19E7FE, 0xD762B5D7, 0xABE64DAB, 0x769AEC76,\n+            0xCA458FCA, 0x829D1F82, 0xC94089C9, 0x7D87FA7D,\n+            0xFA15EFFA, 0x59EBB259, 0x47C98E47, 0xF00BFBF0,\n+            0xADEC41AD, 0xD467B3D4, 0xA2FD5FA2, 0xAFEA45AF,\n+            0x9CBF239C, 0xA4F753A4, 0x7296E472, 0xC05B9BC0,\n+            0xB7C275B7, 0xFD1CE1FD, 0x93AE3D93, 0x266A4C26,\n+            0x365A6C36, 0x3F417E3F, 0xF702F5F7, 0xCC4F83CC,\n+            0x345C6834, 0xA5F451A5, 0xE534D1E5, 0xF108F9F1,\n+            0x7193E271, 0xD873ABD8, 0x31536231, 0x153F2A15,\n+            0x040C0804, 0xC75295C7, 0x23654623, 0xC35E9DC3,\n+            0x18283018, 0x96A13796, 0x050F0A05, 0x9AB52F9A,\n+            0x07090E07, 0x12362412, 0x809B1B80, 0xE23DDFE2,\n+            0xEB26CDEB, 0x27694E27, 0xB2CD7FB2, 0x759FEA75,\n+            0x091B1209, 0x839E1D83, 0x2C74582C, 0x1A2E341A,\n+            0x1B2D361B, 0x6EB2DC6E, 0x5AEEB45A, 0xA0FB5BA0,\n+            0x52F6A452, 0x3B4D763B, 0xD661B7D6, 0xB3CE7DB3,\n+            0x297B5229, 0xE33EDDE3, 0x2F715E2F, 0x84971384,\n+            0x53F5A653, 0xD168B9D1, 0x00000000, 0xED2CC1ED,\n+            0x20604020, 0xFC1FE3FC, 0xB1C879B1, 0x5BEDB65B,\n+            0x6ABED46A, 0xCB468DCB, 0xBED967BE, 0x394B7239,\n+            0x4ADE944A, 0x4CD4984C, 0x58E8B058, 0xCF4A85CF,\n+            0xD06BBBD0, 0xEF2AC5EF, 0xAAE54FAA, 0xFB16EDFB,\n+            0x43C58643, 0x4DD79A4D, 0x33556633, 0x85941185,\n+            0x45CF8A45, 0xF910E9F9, 0x02060402, 0x7F81FE7F,\n+            0x50F0A050, 0x3C44783C, 0x9FBA259F, 0xA8E34BA8,\n+            0x51F3A251, 0xA3FE5DA3, 0x40C08040, 0x8F8A058F,\n+            0x92AD3F92, 0x9DBC219D, 0x38487038, 0xF504F1F5,\n+            0xBCDF63BC, 0xB6C177B6, 0xDA75AFDA, 0x21634221,\n+            0x10302010, 0xFF1AE5FF, 0xF30EFDF3, 0xD26DBFD2,\n+            0xCD4C81CD, 0x0C14180C, 0x13352613, 0xEC2FC3EC,\n+            0x5FE1BE5F, 0x97A23597, 0x44CC8844, 0x17392E17,\n+            0xC45793C4, 0xA7F255A7, 0x7E82FC7E, 0x3D477A3D,\n+            0x64ACC864, 0x5DE7BA5D, 0x192B3219, 0x7395E673,\n+            0x60A0C060, 0x81981981, 0x4FD19E4F, 0xDC7FA3DC,\n+            0x22664422, 0x2A7E542A, 0x90AB3B90, 0x88830B88,\n+            0x46CA8C46, 0xEE29C7EE, 0xB8D36BB8, 0x143C2814,\n+            0xDE79A7DE, 0x5EE2BC5E, 0x0B1D160B, 0xDB76ADDB,\n+            0xE03BDBE0, 0x32566432, 0x3A4E743A, 0x0A1E140A,\n+            0x49DB9249, 0x060A0C06, 0x246C4824, 0x5CE4B85C,\n+            0xC25D9FC2, 0xD36EBDD3, 0xACEF43AC, 0x62A6C462,\n+            0x91A83991, 0x95A43195, 0xE437D3E4, 0x798BF279,\n+            0xE732D5E7, 0xC8438BC8, 0x37596E37, 0x6DB7DA6D,\n+            0x8D8C018D, 0xD564B1D5, 0x4ED29C4E, 0xA9E049A9,\n+            0x6CB4D86C, 0x56FAAC56, 0xF407F3F4, 0xEA25CFEA,\n+            0x65AFCA65, 0x7A8EF47A, 0xAEE947AE, 0x08181008,\n+            0xBAD56FBA, 0x7888F078, 0x256F4A25, 0x2E725C2E,\n+            0x1C24381C, 0xA6F157A6, 0xB4C773B4, 0xC65197C6,\n+            0xE823CBE8, 0xDD7CA1DD, 0x749CE874, 0x1F213E1F,\n+            0x4BDD964B, 0xBDDC61BD, 0x8B860D8B, 0x8A850F8A,\n+            0x7090E070, 0x3E427C3E, 0xB5C471B5, 0x66AACC66,\n+            0x48D89048, 0x03050603, 0xF601F7F6, 0x0E121C0E,\n+            0x61A3C261, 0x355F6A35, 0x57F9AE57, 0xB9D069B9,\n+            0x86911786, 0xC15899C1, 0x1D273A1D, 0x9EB9279E,\n+            0xE138D9E1, 0xF813EBF8, 0x98B32B98, 0x11332211,\n+            0x69BBD269, 0xD970A9D9, 0x8E89078E, 0x94A73394,\n+            0x9BB62D9B, 0x1E223C1E, 0x87921587, 0xE920C9E9,\n+            0xCE4987CE, 0x55FFAA55, 0x28785028, 0xDF7AA5DF,\n+            0x8C8F038C, 0xA1F859A1, 0x89800989, 0x0D171A0D,\n+            0xBFDA65BF, 0xE631D7E6, 0x42C68442, 0x68B8D068,\n+            0x41C38241, 0x99B02999, 0x2D775A2D, 0x0F111E0F,\n+            0xB0CB7BB0, 0x54FCA854, 0xBBD66DBB, 0x163A2C16,\n+    };\n+\n+    private static final int[] T4 = {\n+            0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6,\n+            0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491,\n+            0x30305060, 0x01010302, 0x6767A9CE, 0x2B2B7D56,\n+            0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC,\n+            0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA,\n+            0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB,\n+            0xADADEC41, 0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45,\n+            0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B,\n+            0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C,\n+            0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83,\n+            0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9,\n+            0x717193E2, 0xD8D873AB, 0x31315362, 0x15153F2A,\n+            0x04040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D,\n+            0x18182830, 0x9696A137, 0x05050F0A, 0x9A9AB52F,\n+            0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF,\n+            0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA,\n+            0x09091B12, 0x83839E1D, 0x2C2C7458, 0x1A1A2E34,\n+            0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B,\n+            0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D,\n+            0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713,\n+            0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1,\n+            0x20206040, 0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6,\n+            0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72,\n+            0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85,\n+            0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED,\n+            0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411,\n+            0x4545CF8A, 0xF9F910E9, 0x02020604, 0x7F7F81FE,\n+            0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B,\n+            0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05,\n+            0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1,\n+            0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342,\n+            0x10103020, 0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF,\n+            0xCDCD4C81, 0x0C0C1418, 0x13133526, 0xECEC2FC3,\n+            0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E,\n+            0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A,\n+            0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6,\n+            0x6060A0C0, 0x81819819, 0x4F4FD19E, 0xDCDC7FA3,\n+            0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B,\n+            0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28,\n+            0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD,\n+            0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14,\n+            0x4949DB92, 0x06060A0C, 0x24246C48, 0x5C5CE4B8,\n+            0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4,\n+            0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2,\n+            0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA,\n+            0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049,\n+            0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3, 0xEAEA25CF,\n+            0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x08081810,\n+            0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C,\n+            0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197,\n+            0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E,\n+            0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D, 0x8A8A850F,\n+            0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC,\n+            0x4848D890, 0x03030506, 0xF6F601F7, 0x0E0E121C,\n+            0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069,\n+            0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927,\n+            0xE1E138D9, 0xF8F813EB, 0x9898B32B, 0x11113322,\n+            0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733,\n+            0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9,\n+            0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5,\n+            0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A,\n+            0xBFBFDA65, 0xE6E631D7, 0x4242C684, 0x6868B8D0,\n+            0x4141C382, 0x9999B029, 0x2D2D775A, 0x0F0F111E,\n+            0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C,\n+    };\n+\n+\n+    \/\/ pre-computed inverse tables (inverse T-box)\n+    private static final int[] T5 = {\n+            0x51F4A750, 0x7E416553, 0x1A17A4C3, 0x3A275E96,\n+            0x3BAB6BCB, 0x1F9D45F1, 0xACFA58AB, 0x4BE30393,\n+            0x2030FA55, 0xAD766DF6, 0x88CC7691, 0xF5024C25,\n+            0x4FE5D7FC, 0xC52ACBD7, 0x26354480, 0xB562A38F,\n+            0xDEB15A49, 0x25BA1B67, 0x45EA0E98, 0x5DFEC0E1,\n+            0xC32F7502, 0x814CF012, 0x8D4697A3, 0x6BD3F9C6,\n+            0x038F5FE7, 0x15929C95, 0xBF6D7AEB, 0x955259DA,\n+            0xD4BE832D, 0x587421D3, 0x49E06929, 0x8EC9C844,\n+            0x75C2896A, 0xF48E7978, 0x99583E6B, 0x27B971DD,\n+            0xBEE14FB6, 0xF088AD17, 0xC920AC66, 0x7DCE3AB4,\n+            0x63DF4A18, 0xE51A3182, 0x97513360, 0x62537F45,\n+            0xB16477E0, 0xBB6BAE84, 0xFE81A01C, 0xF9082B94,\n+            0x70486858, 0x8F45FD19, 0x94DE6C87, 0x527BF8B7,\n+            0xAB73D323, 0x724B02E2, 0xE31F8F57, 0x6655AB2A,\n+            0xB2EB2807, 0x2FB5C203, 0x86C57B9A, 0xD33708A5,\n+            0x302887F2, 0x23BFA5B2, 0x02036ABA, 0xED16825C,\n+            0x8ACF1C2B, 0xA779B492, 0xF307F2F0, 0x4E69E2A1,\n+            0x65DAF4CD, 0x0605BED5, 0xD134621F, 0xC4A6FE8A,\n+            0x342E539D, 0xA2F355A0, 0x058AE132, 0xA4F6EB75,\n+            0x0B83EC39, 0x4060EFAA, 0x5E719F06, 0xBD6E1051,\n+            0x3E218AF9, 0x96DD063D, 0xDD3E05AE, 0x4DE6BD46,\n+            0x91548DB5, 0x71C45D05, 0x0406D46F, 0x605015FF,\n+            0x1998FB24, 0xD6BDE997, 0x894043CC, 0x67D99E77,\n+            0xB0E842BD, 0x07898B88, 0xE7195B38, 0x79C8EEDB,\n+            0xA17C0A47, 0x7C420FE9, 0xF8841EC9, 0x00000000,\n+            0x09808683, 0x322BED48, 0x1E1170AC, 0x6C5A724E,\n+            0xFD0EFFFB, 0x0F853856, 0x3DAED51E, 0x362D3927,\n+            0x0A0FD964, 0x685CA621, 0x9B5B54D1, 0x24362E3A,\n+            0x0C0A67B1, 0x9357E70F, 0xB4EE96D2, 0x1B9B919E,\n+            0x80C0C54F, 0x61DC20A2, 0x5A774B69, 0x1C121A16,\n+            0xE293BA0A, 0xC0A02AE5, 0x3C22E043, 0x121B171D,\n+            0x0E090D0B, 0xF28BC7AD, 0x2DB6A8B9, 0x141EA9C8,\n+            0x57F11985, 0xAF75074C, 0xEE99DDBB, 0xA37F60FD,\n+            0xF701269F, 0x5C72F5BC, 0x44663BC5, 0x5BFB7E34,\n+            0x8B432976, 0xCB23C6DC, 0xB6EDFC68, 0xB8E4F163,\n+            0xD731DCCA, 0x42638510, 0x13972240, 0x84C61120,\n+            0x854A247D, 0xD2BB3DF8, 0xAEF93211, 0xC729A16D,\n+            0x1D9E2F4B, 0xDCB230F3, 0x0D8652EC, 0x77C1E3D0,\n+            0x2BB3166C, 0xA970B999, 0x119448FA, 0x47E96422,\n+            0xA8FC8CC4, 0xA0F03F1A, 0x567D2CD8, 0x223390EF,\n+            0x87494EC7, 0xD938D1C1, 0x8CCAA2FE, 0x98D40B36,\n+            0xA6F581CF, 0xA57ADE28, 0xDAB78E26, 0x3FADBFA4,\n+            0x2C3A9DE4, 0x5078920D, 0x6A5FCC9B, 0x547E4662,\n+            0xF68D13C2, 0x90D8B8E8, 0x2E39F75E, 0x82C3AFF5,\n+            0x9F5D80BE, 0x69D0937C, 0x6FD52DA9, 0xCF2512B3,\n+            0xC8AC993B, 0x10187DA7, 0xE89C636E, 0xDB3BBB7B,\n+            0xCD267809, 0x6E5918F4, 0xEC9AB701, 0x834F9AA8,\n+            0xE6956E65, 0xAAFFE67E, 0x21BCCF08, 0xEF15E8E6,\n+            0xBAE79BD9, 0x4A6F36CE, 0xEA9F09D4, 0x29B07CD6,\n+            0x31A4B2AF, 0x2A3F2331, 0xC6A59430, 0x35A266C0,\n+            0x744EBC37, 0xFC82CAA6, 0xE090D0B0, 0x33A7D815,\n+            0xF104984A, 0x41ECDAF7, 0x7FCD500E, 0x1791F62F,\n+            0x764DD68D, 0x43EFB04D, 0xCCAA4D54, 0xE49604DF,\n+            0x9ED1B5E3, 0x4C6A881B, 0xC12C1FB8, 0x4665517F,\n+            0x9D5EEA04, 0x018C355D, 0xFA877473, 0xFB0B412E,\n+            0xB3671D5A, 0x92DBD252, 0xE9105633, 0x6DD64713,\n+            0x9AD7618C, 0x37A10C7A, 0x59F8148E, 0xEB133C89,\n+            0xCEA927EE, 0xB761C935, 0xE11CE5ED, 0x7A47B13C,\n+            0x9CD2DF59, 0x55F2733F, 0x1814CE79, 0x73C737BF,\n+            0x53F7CDEA, 0x5FFDAA5B, 0xDF3D6F14, 0x7844DB86,\n+            0xCAAFF381, 0xB968C43E, 0x3824342C, 0xC2A3405F,\n+            0x161DC372, 0xBCE2250C, 0x283C498B, 0xFF0D9541,\n+            0x39A80171, 0x080CB3DE, 0xD8B4E49C, 0x6456C190,\n+            0x7BCB8461, 0xD532B670, 0x486C5C74, 0xD0B85742,\n+    };\n+\n+    private static final int[] T6 = {\n+            0x5051F4A7, 0x537E4165, 0xC31A17A4, 0x963A275E,\n+            0xCB3BAB6B, 0xF11F9D45, 0xABACFA58, 0x934BE303,\n+            0x552030FA, 0xF6AD766D, 0x9188CC76, 0x25F5024C,\n+            0xFC4FE5D7, 0xD7C52ACB, 0x80263544, 0x8FB562A3,\n+            0x49DEB15A, 0x6725BA1B, 0x9845EA0E, 0xE15DFEC0,\n+            0x02C32F75, 0x12814CF0, 0xA38D4697, 0xC66BD3F9,\n+            0xE7038F5F, 0x9515929C, 0xEBBF6D7A, 0xDA955259,\n+            0x2DD4BE83, 0xD3587421, 0x2949E069, 0x448EC9C8,\n+            0x6A75C289, 0x78F48E79, 0x6B99583E, 0xDD27B971,\n+            0xB6BEE14F, 0x17F088AD, 0x66C920AC, 0xB47DCE3A,\n+            0x1863DF4A, 0x82E51A31, 0x60975133, 0x4562537F,\n+            0xE0B16477, 0x84BB6BAE, 0x1CFE81A0, 0x94F9082B,\n+            0x58704868, 0x198F45FD, 0x8794DE6C, 0xB7527BF8,\n+            0x23AB73D3, 0xE2724B02, 0x57E31F8F, 0x2A6655AB,\n+            0x07B2EB28, 0x032FB5C2, 0x9A86C57B, 0xA5D33708,\n+            0xF2302887, 0xB223BFA5, 0xBA02036A, 0x5CED1682,\n+            0x2B8ACF1C, 0x92A779B4, 0xF0F307F2, 0xA14E69E2,\n+            0xCD65DAF4, 0xD50605BE, 0x1FD13462, 0x8AC4A6FE,\n+            0x9D342E53, 0xA0A2F355, 0x32058AE1, 0x75A4F6EB,\n+            0x390B83EC, 0xAA4060EF, 0x065E719F, 0x51BD6E10,\n+            0xF93E218A, 0x3D96DD06, 0xAEDD3E05, 0x464DE6BD,\n+            0xB591548D, 0x0571C45D, 0x6F0406D4, 0xFF605015,\n+            0x241998FB, 0x97D6BDE9, 0xCC894043, 0x7767D99E,\n+            0xBDB0E842, 0x8807898B, 0x38E7195B, 0xDB79C8EE,\n+            0x47A17C0A, 0xE97C420F, 0xC9F8841E, 0x00000000,\n+            0x83098086, 0x48322BED, 0xAC1E1170, 0x4E6C5A72,\n+            0xFBFD0EFF, 0x560F8538, 0x1E3DAED5, 0x27362D39,\n+            0x640A0FD9, 0x21685CA6, 0xD19B5B54, 0x3A24362E,\n+            0xB10C0A67, 0x0F9357E7, 0xD2B4EE96, 0x9E1B9B91,\n+            0x4F80C0C5, 0xA261DC20, 0x695A774B, 0x161C121A,\n+            0x0AE293BA, 0xE5C0A02A, 0x433C22E0, 0x1D121B17,\n+            0x0B0E090D, 0xADF28BC7, 0xB92DB6A8, 0xC8141EA9,\n+            0x8557F119, 0x4CAF7507, 0xBBEE99DD, 0xFDA37F60,\n+            0x9FF70126, 0xBC5C72F5, 0xC544663B, 0x345BFB7E,\n+            0x768B4329, 0xDCCB23C6, 0x68B6EDFC, 0x63B8E4F1,\n+            0xCAD731DC, 0x10426385, 0x40139722, 0x2084C611,\n+            0x7D854A24, 0xF8D2BB3D, 0x11AEF932, 0x6DC729A1,\n+            0x4B1D9E2F, 0xF3DCB230, 0xEC0D8652, 0xD077C1E3,\n+            0x6C2BB316, 0x99A970B9, 0xFA119448, 0x2247E964,\n+            0xC4A8FC8C, 0x1AA0F03F, 0xD8567D2C, 0xEF223390,\n+            0xC787494E, 0xC1D938D1, 0xFE8CCAA2, 0x3698D40B,\n+            0xCFA6F581, 0x28A57ADE, 0x26DAB78E, 0xA43FADBF,\n+            0xE42C3A9D, 0x0D507892, 0x9B6A5FCC, 0x62547E46,\n+            0xC2F68D13, 0xE890D8B8, 0x5E2E39F7, 0xF582C3AF,\n+            0xBE9F5D80, 0x7C69D093, 0xA96FD52D, 0xB3CF2512,\n+            0x3BC8AC99, 0xA710187D, 0x6EE89C63, 0x7BDB3BBB,\n+            0x09CD2678, 0xF46E5918, 0x01EC9AB7, 0xA8834F9A,\n+            0x65E6956E, 0x7EAAFFE6, 0x0821BCCF, 0xE6EF15E8,\n+            0xD9BAE79B, 0xCE4A6F36, 0xD4EA9F09, 0xD629B07C,\n+            0xAF31A4B2, 0x312A3F23, 0x30C6A594, 0xC035A266,\n+            0x37744EBC, 0xA6FC82CA, 0xB0E090D0, 0x1533A7D8,\n+            0x4AF10498, 0xF741ECDA, 0x0E7FCD50, 0x2F1791F6,\n+            0x8D764DD6, 0x4D43EFB0, 0x54CCAA4D, 0xDFE49604,\n+            0xE39ED1B5, 0x1B4C6A88, 0xB8C12C1F, 0x7F466551,\n+            0x049D5EEA, 0x5D018C35, 0x73FA8774, 0x2EFB0B41,\n+            0x5AB3671D, 0x5292DBD2, 0x33E91056, 0x136DD647,\n+            0x8C9AD761, 0x7A37A10C, 0x8E59F814, 0x89EB133C,\n+            0xEECEA927, 0x35B761C9, 0xEDE11CE5, 0x3C7A47B1,\n+            0x599CD2DF, 0x3F55F273, 0x791814CE, 0xBF73C737,\n+            0xEA53F7CD, 0x5B5FFDAA, 0x14DF3D6F, 0x867844DB,\n+            0x81CAAFF3, 0x3EB968C4, 0x2C382434, 0x5FC2A340,\n+            0x72161DC3, 0x0CBCE225, 0x8B283C49, 0x41FF0D95,\n+            0x7139A801, 0xDE080CB3, 0x9CD8B4E4, 0x906456C1,\n+            0x617BCB84, 0x70D532B6, 0x74486C5C, 0x42D0B857,\n+    };\n+\n+    private static final int[] T7 = {\n+            0xA75051F4, 0x65537E41, 0xA4C31A17, 0x5E963A27,\n+            0x6BCB3BAB, 0x45F11F9D, 0x58ABACFA, 0x03934BE3,\n+            0xFA552030, 0x6DF6AD76, 0x769188CC, 0x4C25F502,\n+            0xD7FC4FE5, 0xCBD7C52A, 0x44802635, 0xA38FB562,\n+            0x5A49DEB1, 0x1B6725BA, 0x0E9845EA, 0xC0E15DFE,\n+            0x7502C32F, 0xF012814C, 0x97A38D46, 0xF9C66BD3,\n+            0x5FE7038F, 0x9C951592, 0x7AEBBF6D, 0x59DA9552,\n+            0x832DD4BE, 0x21D35874, 0x692949E0, 0xC8448EC9,\n+            0x896A75C2, 0x7978F48E, 0x3E6B9958, 0x71DD27B9,\n+            0x4FB6BEE1, 0xAD17F088, 0xAC66C920, 0x3AB47DCE,\n+            0x4A1863DF, 0x3182E51A, 0x33609751, 0x7F456253,\n+            0x77E0B164, 0xAE84BB6B, 0xA01CFE81, 0x2B94F908,\n+            0x68587048, 0xFD198F45, 0x6C8794DE, 0xF8B7527B,\n+            0xD323AB73, 0x02E2724B, 0x8F57E31F, 0xAB2A6655,\n+            0x2807B2EB, 0xC2032FB5, 0x7B9A86C5, 0x08A5D337,\n+            0x87F23028, 0xA5B223BF, 0x6ABA0203, 0x825CED16,\n+            0x1C2B8ACF, 0xB492A779, 0xF2F0F307, 0xE2A14E69,\n+            0xF4CD65DA, 0xBED50605, 0x621FD134, 0xFE8AC4A6,\n+            0x539D342E, 0x55A0A2F3, 0xE132058A, 0xEB75A4F6,\n+            0xEC390B83, 0xEFAA4060, 0x9F065E71, 0x1051BD6E,\n+            0x8AF93E21, 0x063D96DD, 0x05AEDD3E, 0xBD464DE6,\n+            0x8DB59154, 0x5D0571C4, 0xD46F0406, 0x15FF6050,\n+            0xFB241998, 0xE997D6BD, 0x43CC8940, 0x9E7767D9,\n+            0x42BDB0E8, 0x8B880789, 0x5B38E719, 0xEEDB79C8,\n+            0x0A47A17C, 0x0FE97C42, 0x1EC9F884, 0x00000000,\n+            0x86830980, 0xED48322B, 0x70AC1E11, 0x724E6C5A,\n+            0xFFFBFD0E, 0x38560F85, 0xD51E3DAE, 0x3927362D,\n+            0xD9640A0F, 0xA621685C, 0x54D19B5B, 0x2E3A2436,\n+            0x67B10C0A, 0xE70F9357, 0x96D2B4EE, 0x919E1B9B,\n+            0xC54F80C0, 0x20A261DC, 0x4B695A77, 0x1A161C12,\n+            0xBA0AE293, 0x2AE5C0A0, 0xE0433C22, 0x171D121B,\n+            0x0D0B0E09, 0xC7ADF28B, 0xA8B92DB6, 0xA9C8141E,\n+            0x198557F1, 0x074CAF75, 0xDDBBEE99, 0x60FDA37F,\n+            0x269FF701, 0xF5BC5C72, 0x3BC54466, 0x7E345BFB,\n+            0x29768B43, 0xC6DCCB23, 0xFC68B6ED, 0xF163B8E4,\n+            0xDCCAD731, 0x85104263, 0x22401397, 0x112084C6,\n+            0x247D854A, 0x3DF8D2BB, 0x3211AEF9, 0xA16DC729,\n+            0x2F4B1D9E, 0x30F3DCB2, 0x52EC0D86, 0xE3D077C1,\n+            0x166C2BB3, 0xB999A970, 0x48FA1194, 0x642247E9,\n+            0x8CC4A8FC, 0x3F1AA0F0, 0x2CD8567D, 0x90EF2233,\n+            0x4EC78749, 0xD1C1D938, 0xA2FE8CCA, 0x0B3698D4,\n+            0x81CFA6F5, 0xDE28A57A, 0x8E26DAB7, 0xBFA43FAD,\n+            0x9DE42C3A, 0x920D5078, 0xCC9B6A5F, 0x4662547E,\n+            0x13C2F68D, 0xB8E890D8, 0xF75E2E39, 0xAFF582C3,\n+            0x80BE9F5D, 0x937C69D0, 0x2DA96FD5, 0x12B3CF25,\n+            0x993BC8AC, 0x7DA71018, 0x636EE89C, 0xBB7BDB3B,\n+            0x7809CD26, 0x18F46E59, 0xB701EC9A, 0x9AA8834F,\n+            0x6E65E695, 0xE67EAAFF, 0xCF0821BC, 0xE8E6EF15,\n+            0x9BD9BAE7, 0x36CE4A6F, 0x09D4EA9F, 0x7CD629B0,\n+            0xB2AF31A4, 0x23312A3F, 0x9430C6A5, 0x66C035A2,\n+            0xBC37744E, 0xCAA6FC82, 0xD0B0E090, 0xD81533A7,\n+            0x984AF104, 0xDAF741EC, 0x500E7FCD, 0xF62F1791,\n+            0xD68D764D, 0xB04D43EF, 0x4D54CCAA, 0x04DFE496,\n+            0xB5E39ED1, 0x881B4C6A, 0x1FB8C12C, 0x517F4665,\n+            0xEA049D5E, 0x355D018C, 0x7473FA87, 0x412EFB0B,\n+            0x1D5AB367, 0xD25292DB, 0x5633E910, 0x47136DD6,\n+            0x618C9AD7, 0x0C7A37A1, 0x148E59F8, 0x3C89EB13,\n+            0x27EECEA9, 0xC935B761, 0xE5EDE11C, 0xB13C7A47,\n+            0xDF599CD2, 0x733F55F2, 0xCE791814, 0x37BF73C7,\n+            0xCDEA53F7, 0xAA5B5FFD, 0x6F14DF3D, 0xDB867844,\n+            0xF381CAAF, 0xC43EB968, 0x342C3824, 0x405FC2A3,\n+            0xC372161D, 0x250CBCE2, 0x498B283C, 0x9541FF0D,\n+            0x017139A8, 0xB3DE080C, 0xE49CD8B4, 0xC1906456,\n+            0x84617BCB, 0xB670D532, 0x5C74486C, 0x5742D0B8,\n+    };\n+\n+    private static final int[] T8 = {\n+            0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A,\n+            0xAB6BCB3B, 0x9D45F11F, 0xFA58ABAC, 0xE303934B,\n+            0x30FA5520, 0x766DF6AD, 0xCC769188, 0x024C25F5,\n+            0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5,\n+            0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D,\n+            0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B,\n+            0x8F5FE703, 0x929C9515, 0x6D7AEBBF, 0x5259DA95,\n+            0xBE832DD4, 0x7421D358, 0xE0692949, 0xC9C8448E,\n+            0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27,\n+            0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D,\n+            0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562,\n+            0x6477E0B1, 0x6BAE84BB, 0x81A01CFE, 0x082B94F9,\n+            0x48685870, 0x45FD198F, 0xDE6C8794, 0x7BF8B752,\n+            0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66,\n+            0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3,\n+            0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED,\n+            0xCF1C2B8A, 0x79B492A7, 0x07F2F0F3, 0x69E2A14E,\n+            0xDAF4CD65, 0x05BED506, 0x34621FD1, 0xA6FE8AC4,\n+            0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4,\n+            0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD,\n+            0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D,\n+            0x548DB591, 0xC45D0571, 0x06D46F04, 0x5015FF60,\n+            0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767,\n+            0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79,\n+            0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000,\n+            0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C,\n+            0x0EFFFBFD, 0x8538560F, 0xAED51E3D, 0x2D392736,\n+            0x0FD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24,\n+            0x0A67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B,\n+            0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C,\n+            0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12,\n+            0x090D0B0E, 0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814,\n+            0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3,\n+            0x01269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B,\n+            0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8,\n+            0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084,\n+            0x4A247D85, 0xBB3DF8D2, 0xF93211AE, 0x29A16DC7,\n+            0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077,\n+            0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247,\n+            0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22,\n+            0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698,\n+            0xF581CFA6, 0x7ADE28A5, 0xB78E26DA, 0xADBFA43F,\n+            0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254,\n+            0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582,\n+            0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF,\n+            0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB,\n+            0x267809CD, 0x5918F46E, 0x9AB701EC, 0x4F9AA883,\n+            0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF,\n+            0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629,\n+            0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035,\n+            0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533,\n+            0x04984AF1, 0xECDAF741, 0xCD500E7F, 0x91F62F17,\n+            0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4,\n+            0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46,\n+            0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB,\n+            0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D,\n+            0xD7618C9A, 0xA10C7A37, 0xF8148E59, 0x133C89EB,\n+            0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A,\n+            0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73,\n+            0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678,\n+            0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2,\n+            0x1DC37216, 0xE2250CBC, 0x3C498B28, 0x0D9541FF,\n+            0xA8017139, 0x0CB3DE08, 0xB4E49CD8, 0x56C19064,\n+            0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0,\n+    };\n+\n+    private static final int[] U1 = {\n+            0x00000000, 0x0E090D0B, 0x1C121A16, 0x121B171D,\n+            0x3824342C, 0x362D3927, 0x24362E3A, 0x2A3F2331,\n+            0x70486858, 0x7E416553, 0x6C5A724E, 0x62537F45,\n+            0x486C5C74, 0x4665517F, 0x547E4662, 0x5A774B69,\n+            0xE090D0B0, 0xEE99DDBB, 0xFC82CAA6, 0xF28BC7AD,\n+            0xD8B4E49C, 0xD6BDE997, 0xC4A6FE8A, 0xCAAFF381,\n+            0x90D8B8E8, 0x9ED1B5E3, 0x8CCAA2FE, 0x82C3AFF5,\n+            0xA8FC8CC4, 0xA6F581CF, 0xB4EE96D2, 0xBAE79BD9,\n+            0xDB3BBB7B, 0xD532B670, 0xC729A16D, 0xC920AC66,\n+            0xE31F8F57, 0xED16825C, 0xFF0D9541, 0xF104984A,\n+            0xAB73D323, 0xA57ADE28, 0xB761C935, 0xB968C43E,\n+            0x9357E70F, 0x9D5EEA04, 0x8F45FD19, 0x814CF012,\n+            0x3BAB6BCB, 0x35A266C0, 0x27B971DD, 0x29B07CD6,\n+            0x038F5FE7, 0x0D8652EC, 0x1F9D45F1, 0x119448FA,\n+            0x4BE30393, 0x45EA0E98, 0x57F11985, 0x59F8148E,\n+            0x73C737BF, 0x7DCE3AB4, 0x6FD52DA9, 0x61DC20A2,\n+            0xAD766DF6, 0xA37F60FD, 0xB16477E0, 0xBF6D7AEB,\n+            0x955259DA, 0x9B5B54D1, 0x894043CC, 0x87494EC7,\n+            0xDD3E05AE, 0xD33708A5, 0xC12C1FB8, 0xCF2512B3,\n+            0xE51A3182, 0xEB133C89, 0xF9082B94, 0xF701269F,\n+            0x4DE6BD46, 0x43EFB04D, 0x51F4A750, 0x5FFDAA5B,\n+            0x75C2896A, 0x7BCB8461, 0x69D0937C, 0x67D99E77,\n+            0x3DAED51E, 0x33A7D815, 0x21BCCF08, 0x2FB5C203,\n+            0x058AE132, 0x0B83EC39, 0x1998FB24, 0x1791F62F,\n+            0x764DD68D, 0x7844DB86, 0x6A5FCC9B, 0x6456C190,\n+            0x4E69E2A1, 0x4060EFAA, 0x527BF8B7, 0x5C72F5BC,\n+            0x0605BED5, 0x080CB3DE, 0x1A17A4C3, 0x141EA9C8,\n+            0x3E218AF9, 0x302887F2, 0x223390EF, 0x2C3A9DE4,\n+            0x96DD063D, 0x98D40B36, 0x8ACF1C2B, 0x84C61120,\n+            0xAEF93211, 0xA0F03F1A, 0xB2EB2807, 0xBCE2250C,\n+            0xE6956E65, 0xE89C636E, 0xFA877473, 0xF48E7978,\n+            0xDEB15A49, 0xD0B85742, 0xC2A3405F, 0xCCAA4D54,\n+            0x41ECDAF7, 0x4FE5D7FC, 0x5DFEC0E1, 0x53F7CDEA,\n+            0x79C8EEDB, 0x77C1E3D0, 0x65DAF4CD, 0x6BD3F9C6,\n+            0x31A4B2AF, 0x3FADBFA4, 0x2DB6A8B9, 0x23BFA5B2,\n+            0x09808683, 0x07898B88, 0x15929C95, 0x1B9B919E,\n+            0xA17C0A47, 0xAF75074C, 0xBD6E1051, 0xB3671D5A,\n+            0x99583E6B, 0x97513360, 0x854A247D, 0x8B432976,\n+            0xD134621F, 0xDF3D6F14, 0xCD267809, 0xC32F7502,\n+            0xE9105633, 0xE7195B38, 0xF5024C25, 0xFB0B412E,\n+            0x9AD7618C, 0x94DE6C87, 0x86C57B9A, 0x88CC7691,\n+            0xA2F355A0, 0xACFA58AB, 0xBEE14FB6, 0xB0E842BD,\n+            0xEA9F09D4, 0xE49604DF, 0xF68D13C2, 0xF8841EC9,\n+            0xD2BB3DF8, 0xDCB230F3, 0xCEA927EE, 0xC0A02AE5,\n+            0x7A47B13C, 0x744EBC37, 0x6655AB2A, 0x685CA621,\n+            0x42638510, 0x4C6A881B, 0x5E719F06, 0x5078920D,\n+            0x0A0FD964, 0x0406D46F, 0x161DC372, 0x1814CE79,\n+            0x322BED48, 0x3C22E043, 0x2E39F75E, 0x2030FA55,\n+            0xEC9AB701, 0xE293BA0A, 0xF088AD17, 0xFE81A01C,\n+            0xD4BE832D, 0xDAB78E26, 0xC8AC993B, 0xC6A59430,\n+            0x9CD2DF59, 0x92DBD252, 0x80C0C54F, 0x8EC9C844,\n+            0xA4F6EB75, 0xAAFFE67E, 0xB8E4F163, 0xB6EDFC68,\n+            0x0C0A67B1, 0x02036ABA, 0x10187DA7, 0x1E1170AC,\n+            0x342E539D, 0x3A275E96, 0x283C498B, 0x26354480,\n+            0x7C420FE9, 0x724B02E2, 0x605015FF, 0x6E5918F4,\n+            0x44663BC5, 0x4A6F36CE, 0x587421D3, 0x567D2CD8,\n+            0x37A10C7A, 0x39A80171, 0x2BB3166C, 0x25BA1B67,\n+            0x0F853856, 0x018C355D, 0x13972240, 0x1D9E2F4B,\n+            0x47E96422, 0x49E06929, 0x5BFB7E34, 0x55F2733F,\n+            0x7FCD500E, 0x71C45D05, 0x63DF4A18, 0x6DD64713,\n+            0xD731DCCA, 0xD938D1C1, 0xCB23C6DC, 0xC52ACBD7,\n+            0xEF15E8E6, 0xE11CE5ED, 0xF307F2F0, 0xFD0EFFFB,\n+            0xA779B492, 0xA970B999, 0xBB6BAE84, 0xB562A38F,\n+            0x9F5D80BE, 0x91548DB5, 0x834F9AA8, 0x8D4697A3,\n+    };\n+\n+    private static final int[] U2 = {\n+            0x00000000, 0x0B0E090D, 0x161C121A, 0x1D121B17,\n+            0x2C382434, 0x27362D39, 0x3A24362E, 0x312A3F23,\n+            0x58704868, 0x537E4165, 0x4E6C5A72, 0x4562537F,\n+            0x74486C5C, 0x7F466551, 0x62547E46, 0x695A774B,\n+            0xB0E090D0, 0xBBEE99DD, 0xA6FC82CA, 0xADF28BC7,\n+            0x9CD8B4E4, 0x97D6BDE9, 0x8AC4A6FE, 0x81CAAFF3,\n+            0xE890D8B8, 0xE39ED1B5, 0xFE8CCAA2, 0xF582C3AF,\n+            0xC4A8FC8C, 0xCFA6F581, 0xD2B4EE96, 0xD9BAE79B,\n+            0x7BDB3BBB, 0x70D532B6, 0x6DC729A1, 0x66C920AC,\n+            0x57E31F8F, 0x5CED1682, 0x41FF0D95, 0x4AF10498,\n+            0x23AB73D3, 0x28A57ADE, 0x35B761C9, 0x3EB968C4,\n+            0x0F9357E7, 0x049D5EEA, 0x198F45FD, 0x12814CF0,\n+            0xCB3BAB6B, 0xC035A266, 0xDD27B971, 0xD629B07C,\n+            0xE7038F5F, 0xEC0D8652, 0xF11F9D45, 0xFA119448,\n+            0x934BE303, 0x9845EA0E, 0x8557F119, 0x8E59F814,\n+            0xBF73C737, 0xB47DCE3A, 0xA96FD52D, 0xA261DC20,\n+            0xF6AD766D, 0xFDA37F60, 0xE0B16477, 0xEBBF6D7A,\n+            0xDA955259, 0xD19B5B54, 0xCC894043, 0xC787494E,\n+            0xAEDD3E05, 0xA5D33708, 0xB8C12C1F, 0xB3CF2512,\n+            0x82E51A31, 0x89EB133C, 0x94F9082B, 0x9FF70126,\n+            0x464DE6BD, 0x4D43EFB0, 0x5051F4A7, 0x5B5FFDAA,\n+            0x6A75C289, 0x617BCB84, 0x7C69D093, 0x7767D99E,\n+            0x1E3DAED5, 0x1533A7D8, 0x0821BCCF, 0x032FB5C2,\n+            0x32058AE1, 0x390B83EC, 0x241998FB, 0x2F1791F6,\n+            0x8D764DD6, 0x867844DB, 0x9B6A5FCC, 0x906456C1,\n+            0xA14E69E2, 0xAA4060EF, 0xB7527BF8, 0xBC5C72F5,\n+            0xD50605BE, 0xDE080CB3, 0xC31A17A4, 0xC8141EA9,\n+            0xF93E218A, 0xF2302887, 0xEF223390, 0xE42C3A9D,\n+            0x3D96DD06, 0x3698D40B, 0x2B8ACF1C, 0x2084C611,\n+            0x11AEF932, 0x1AA0F03F, 0x07B2EB28, 0x0CBCE225,\n+            0x65E6956E, 0x6EE89C63, 0x73FA8774, 0x78F48E79,\n+            0x49DEB15A, 0x42D0B857, 0x5FC2A340, 0x54CCAA4D,\n+            0xF741ECDA, 0xFC4FE5D7, 0xE15DFEC0, 0xEA53F7CD,\n+            0xDB79C8EE, 0xD077C1E3, 0xCD65DAF4, 0xC66BD3F9,\n+            0xAF31A4B2, 0xA43FADBF, 0xB92DB6A8, 0xB223BFA5,\n+            0x83098086, 0x8807898B, 0x9515929C, 0x9E1B9B91,\n+            0x47A17C0A, 0x4CAF7507, 0x51BD6E10, 0x5AB3671D,\n+            0x6B99583E, 0x60975133, 0x7D854A24, 0x768B4329,\n+            0x1FD13462, 0x14DF3D6F, 0x09CD2678, 0x02C32F75,\n+            0x33E91056, 0x38E7195B, 0x25F5024C, 0x2EFB0B41,\n+            0x8C9AD761, 0x8794DE6C, 0x9A86C57B, 0x9188CC76,\n+            0xA0A2F355, 0xABACFA58, 0xB6BEE14F, 0xBDB0E842,\n+            0xD4EA9F09, 0xDFE49604, 0xC2F68D13, 0xC9F8841E,\n+            0xF8D2BB3D, 0xF3DCB230, 0xEECEA927, 0xE5C0A02A,\n+            0x3C7A47B1, 0x37744EBC, 0x2A6655AB, 0x21685CA6,\n+            0x10426385, 0x1B4C6A88, 0x065E719F, 0x0D507892,\n+            0x640A0FD9, 0x6F0406D4, 0x72161DC3, 0x791814CE,\n+            0x48322BED, 0x433C22E0, 0x5E2E39F7, 0x552030FA,\n+            0x01EC9AB7, 0x0AE293BA, 0x17F088AD, 0x1CFE81A0,\n+            0x2DD4BE83, 0x26DAB78E, 0x3BC8AC99, 0x30C6A594,\n+            0x599CD2DF, 0x5292DBD2, 0x4F80C0C5, 0x448EC9C8,\n+            0x75A4F6EB, 0x7EAAFFE6, 0x63B8E4F1, 0x68B6EDFC,\n+            0xB10C0A67, 0xBA02036A, 0xA710187D, 0xAC1E1170,\n+            0x9D342E53, 0x963A275E, 0x8B283C49, 0x80263544,\n+            0xE97C420F, 0xE2724B02, 0xFF605015, 0xF46E5918,\n+            0xC544663B, 0xCE4A6F36, 0xD3587421, 0xD8567D2C,\n+            0x7A37A10C, 0x7139A801, 0x6C2BB316, 0x6725BA1B,\n+            0x560F8538, 0x5D018C35, 0x40139722, 0x4B1D9E2F,\n+            0x2247E964, 0x2949E069, 0x345BFB7E, 0x3F55F273,\n+            0x0E7FCD50, 0x0571C45D, 0x1863DF4A, 0x136DD647,\n+            0xCAD731DC, 0xC1D938D1, 0xDCCB23C6, 0xD7C52ACB,\n+            0xE6EF15E8, 0xEDE11CE5, 0xF0F307F2, 0xFBFD0EFF,\n+            0x92A779B4, 0x99A970B9, 0x84BB6BAE, 0x8FB562A3,\n+            0xBE9F5D80, 0xB591548D, 0xA8834F9A, 0xA38D4697,\n+    };\n+\n+    private static final int[] U3 = {\n+            0x00000000, 0x0D0B0E09, 0x1A161C12, 0x171D121B,\n+            0x342C3824, 0x3927362D, 0x2E3A2436, 0x23312A3F,\n+            0x68587048, 0x65537E41, 0x724E6C5A, 0x7F456253,\n+            0x5C74486C, 0x517F4665, 0x4662547E, 0x4B695A77,\n+            0xD0B0E090, 0xDDBBEE99, 0xCAA6FC82, 0xC7ADF28B,\n+            0xE49CD8B4, 0xE997D6BD, 0xFE8AC4A6, 0xF381CAAF,\n+            0xB8E890D8, 0xB5E39ED1, 0xA2FE8CCA, 0xAFF582C3,\n+            0x8CC4A8FC, 0x81CFA6F5, 0x96D2B4EE, 0x9BD9BAE7,\n+            0xBB7BDB3B, 0xB670D532, 0xA16DC729, 0xAC66C920,\n+            0x8F57E31F, 0x825CED16, 0x9541FF0D, 0x984AF104,\n+            0xD323AB73, 0xDE28A57A, 0xC935B761, 0xC43EB968,\n+            0xE70F9357, 0xEA049D5E, 0xFD198F45, 0xF012814C,\n+            0x6BCB3BAB, 0x66C035A2, 0x71DD27B9, 0x7CD629B0,\n+            0x5FE7038F, 0x52EC0D86, 0x45F11F9D, 0x48FA1194,\n+            0x03934BE3, 0x0E9845EA, 0x198557F1, 0x148E59F8,\n+            0x37BF73C7, 0x3AB47DCE, 0x2DA96FD5, 0x20A261DC,\n+            0x6DF6AD76, 0x60FDA37F, 0x77E0B164, 0x7AEBBF6D,\n+            0x59DA9552, 0x54D19B5B, 0x43CC8940, 0x4EC78749,\n+            0x05AEDD3E, 0x08A5D337, 0x1FB8C12C, 0x12B3CF25,\n+            0x3182E51A, 0x3C89EB13, 0x2B94F908, 0x269FF701,\n+            0xBD464DE6, 0xB04D43EF, 0xA75051F4, 0xAA5B5FFD,\n+            0x896A75C2, 0x84617BCB, 0x937C69D0, 0x9E7767D9,\n+            0xD51E3DAE, 0xD81533A7, 0xCF0821BC, 0xC2032FB5,\n+            0xE132058A, 0xEC390B83, 0xFB241998, 0xF62F1791,\n+            0xD68D764D, 0xDB867844, 0xCC9B6A5F, 0xC1906456,\n+            0xE2A14E69, 0xEFAA4060, 0xF8B7527B, 0xF5BC5C72,\n+            0xBED50605, 0xB3DE080C, 0xA4C31A17, 0xA9C8141E,\n+            0x8AF93E21, 0x87F23028, 0x90EF2233, 0x9DE42C3A,\n+            0x063D96DD, 0x0B3698D4, 0x1C2B8ACF, 0x112084C6,\n+            0x3211AEF9, 0x3F1AA0F0, 0x2807B2EB, 0x250CBCE2,\n+            0x6E65E695, 0x636EE89C, 0x7473FA87, 0x7978F48E,\n+            0x5A49DEB1, 0x5742D0B8, 0x405FC2A3, 0x4D54CCAA,\n+            0xDAF741EC, 0xD7FC4FE5, 0xC0E15DFE, 0xCDEA53F7,\n+            0xEEDB79C8, 0xE3D077C1, 0xF4CD65DA, 0xF9C66BD3,\n+            0xB2AF31A4, 0xBFA43FAD, 0xA8B92DB6, 0xA5B223BF,\n+            0x86830980, 0x8B880789, 0x9C951592, 0x919E1B9B,\n+            0x0A47A17C, 0x074CAF75, 0x1051BD6E, 0x1D5AB367,\n+            0x3E6B9958, 0x33609751, 0x247D854A, 0x29768B43,\n+            0x621FD134, 0x6F14DF3D, 0x7809CD26, 0x7502C32F,\n+            0x5633E910, 0x5B38E719, 0x4C25F502, 0x412EFB0B,\n+            0x618C9AD7, 0x6C8794DE, 0x7B9A86C5, 0x769188CC,\n+            0x55A0A2F3, 0x58ABACFA, 0x4FB6BEE1, 0x42BDB0E8,\n+            0x09D4EA9F, 0x04DFE496, 0x13C2F68D, 0x1EC9F884,\n+            0x3DF8D2BB, 0x30F3DCB2, 0x27EECEA9, 0x2AE5C0A0,\n+            0xB13C7A47, 0xBC37744E, 0xAB2A6655, 0xA621685C,\n+            0x85104263, 0x881B4C6A, 0x9F065E71, 0x920D5078,\n+            0xD9640A0F, 0xD46F0406, 0xC372161D, 0xCE791814,\n+            0xED48322B, 0xE0433C22, 0xF75E2E39, 0xFA552030,\n+            0xB701EC9A, 0xBA0AE293, 0xAD17F088, 0xA01CFE81,\n+            0x832DD4BE, 0x8E26DAB7, 0x993BC8AC, 0x9430C6A5,\n+            0xDF599CD2, 0xD25292DB, 0xC54F80C0, 0xC8448EC9,\n+            0xEB75A4F6, 0xE67EAAFF, 0xF163B8E4, 0xFC68B6ED,\n+            0x67B10C0A, 0x6ABA0203, 0x7DA71018, 0x70AC1E11,\n+            0x539D342E, 0x5E963A27, 0x498B283C, 0x44802635,\n+            0x0FE97C42, 0x02E2724B, 0x15FF6050, 0x18F46E59,\n+            0x3BC54466, 0x36CE4A6F, 0x21D35874, 0x2CD8567D,\n+            0x0C7A37A1, 0x017139A8, 0x166C2BB3, 0x1B6725BA,\n+            0x38560F85, 0x355D018C, 0x22401397, 0x2F4B1D9E,\n+            0x642247E9, 0x692949E0, 0x7E345BFB, 0x733F55F2,\n+            0x500E7FCD, 0x5D0571C4, 0x4A1863DF, 0x47136DD6,\n+            0xDCCAD731, 0xD1C1D938, 0xC6DCCB23, 0xCBD7C52A,\n+            0xE8E6EF15, 0xE5EDE11C, 0xF2F0F307, 0xFFFBFD0E,\n+            0xB492A779, 0xB999A970, 0xAE84BB6B, 0xA38FB562,\n+            0x80BE9F5D, 0x8DB59154, 0x9AA8834F, 0x97A38D46,\n+    };\n+\n+    private static final int[] U4 = {\n+            0x00000000, 0x090D0B0E, 0x121A161C, 0x1B171D12,\n+            0x24342C38, 0x2D392736, 0x362E3A24, 0x3F23312A,\n+            0x48685870, 0x4165537E, 0x5A724E6C, 0x537F4562,\n+            0x6C5C7448, 0x65517F46, 0x7E466254, 0x774B695A,\n+            0x90D0B0E0, 0x99DDBBEE, 0x82CAA6FC, 0x8BC7ADF2,\n+            0xB4E49CD8, 0xBDE997D6, 0xA6FE8AC4, 0xAFF381CA,\n+            0xD8B8E890, 0xD1B5E39E, 0xCAA2FE8C, 0xC3AFF582,\n+            0xFC8CC4A8, 0xF581CFA6, 0xEE96D2B4, 0xE79BD9BA,\n+            0x3BBB7BDB, 0x32B670D5, 0x29A16DC7, 0x20AC66C9,\n+            0x1F8F57E3, 0x16825CED, 0x0D9541FF, 0x04984AF1,\n+            0x73D323AB, 0x7ADE28A5, 0x61C935B7, 0x68C43EB9,\n+            0x57E70F93, 0x5EEA049D, 0x45FD198F, 0x4CF01281,\n+            0xAB6BCB3B, 0xA266C035, 0xB971DD27, 0xB07CD629,\n+            0x8F5FE703, 0x8652EC0D, 0x9D45F11F, 0x9448FA11,\n+            0xE303934B, 0xEA0E9845, 0xF1198557, 0xF8148E59,\n+            0xC737BF73, 0xCE3AB47D, 0xD52DA96F, 0xDC20A261,\n+            0x766DF6AD, 0x7F60FDA3, 0x6477E0B1, 0x6D7AEBBF,\n+            0x5259DA95, 0x5B54D19B, 0x4043CC89, 0x494EC787,\n+            0x3E05AEDD, 0x3708A5D3, 0x2C1FB8C1, 0x2512B3CF,\n+            0x1A3182E5, 0x133C89EB, 0x082B94F9, 0x01269FF7,\n+            0xE6BD464D, 0xEFB04D43, 0xF4A75051, 0xFDAA5B5F,\n+            0xC2896A75, 0xCB84617B, 0xD0937C69, 0xD99E7767,\n+            0xAED51E3D, 0xA7D81533, 0xBCCF0821, 0xB5C2032F,\n+            0x8AE13205, 0x83EC390B, 0x98FB2419, 0x91F62F17,\n+            0x4DD68D76, 0x44DB8678, 0x5FCC9B6A, 0x56C19064,\n+            0x69E2A14E, 0x60EFAA40, 0x7BF8B752, 0x72F5BC5C,\n+            0x05BED506, 0x0CB3DE08, 0x17A4C31A, 0x1EA9C814,\n+            0x218AF93E, 0x2887F230, 0x3390EF22, 0x3A9DE42C,\n+            0xDD063D96, 0xD40B3698, 0xCF1C2B8A, 0xC6112084,\n+            0xF93211AE, 0xF03F1AA0, 0xEB2807B2, 0xE2250CBC,\n+            0x956E65E6, 0x9C636EE8, 0x877473FA, 0x8E7978F4,\n+            0xB15A49DE, 0xB85742D0, 0xA3405FC2, 0xAA4D54CC,\n+            0xECDAF741, 0xE5D7FC4F, 0xFEC0E15D, 0xF7CDEA53,\n+            0xC8EEDB79, 0xC1E3D077, 0xDAF4CD65, 0xD3F9C66B,\n+            0xA4B2AF31, 0xADBFA43F, 0xB6A8B92D, 0xBFA5B223,\n+            0x80868309, 0x898B8807, 0x929C9515, 0x9B919E1B,\n+            0x7C0A47A1, 0x75074CAF, 0x6E1051BD, 0x671D5AB3,\n+            0x583E6B99, 0x51336097, 0x4A247D85, 0x4329768B,\n+            0x34621FD1, 0x3D6F14DF, 0x267809CD, 0x2F7502C3,\n+            0x105633E9, 0x195B38E7, 0x024C25F5, 0x0B412EFB,\n+            0xD7618C9A, 0xDE6C8794, 0xC57B9A86, 0xCC769188,\n+            0xF355A0A2, 0xFA58ABAC, 0xE14FB6BE, 0xE842BDB0,\n+            0x9F09D4EA, 0x9604DFE4, 0x8D13C2F6, 0x841EC9F8,\n+            0xBB3DF8D2, 0xB230F3DC, 0xA927EECE, 0xA02AE5C0,\n+            0x47B13C7A, 0x4EBC3774, 0x55AB2A66, 0x5CA62168,\n+            0x63851042, 0x6A881B4C, 0x719F065E, 0x78920D50,\n+            0x0FD9640A, 0x06D46F04, 0x1DC37216, 0x14CE7918,\n+            0x2BED4832, 0x22E0433C, 0x39F75E2E, 0x30FA5520,\n+            0x9AB701EC, 0x93BA0AE2, 0x88AD17F0, 0x81A01CFE,\n+            0xBE832DD4, 0xB78E26DA, 0xAC993BC8, 0xA59430C6,\n+            0xD2DF599C, 0xDBD25292, 0xC0C54F80, 0xC9C8448E,\n+            0xF6EB75A4, 0xFFE67EAA, 0xE4F163B8, 0xEDFC68B6,\n+            0x0A67B10C, 0x036ABA02, 0x187DA710, 0x1170AC1E,\n+            0x2E539D34, 0x275E963A, 0x3C498B28, 0x35448026,\n+            0x420FE97C, 0x4B02E272, 0x5015FF60, 0x5918F46E,\n+            0x663BC544, 0x6F36CE4A, 0x7421D358, 0x7D2CD856,\n+            0xA10C7A37, 0xA8017139, 0xB3166C2B, 0xBA1B6725,\n+            0x8538560F, 0x8C355D01, 0x97224013, 0x9E2F4B1D,\n+            0xE9642247, 0xE0692949, 0xFB7E345B, 0xF2733F55,\n+            0xCD500E7F, 0xC45D0571, 0xDF4A1863, 0xD647136D,\n+            0x31DCCAD7, 0x38D1C1D9, 0x23C6DCCB, 0x2ACBD7C5,\n+            0x15E8E6EF, 0x1CE5EDE1, 0x07F2F0F3, 0x0EFFFBFD,\n+            0x79B492A7, 0x70B999A9, 0x6BAE84BB, 0x62A38FB5,\n+            0x5D80BE9F, 0x548DB591, 0x4F9AA883, 0x4697A38D,\n+    };\n+\n+    private static final int[] rcon = {\n+            0x00000001, 0x00000002, 0x00000004, 0x00000008,\n+            0x00000010, 0x00000020, 0x00000040, 0x00000080,\n+            0x0000001B, 0x00000036, 0x0000006C, 0x000000D8,\n+            0x000000AB, 0x0000004D, 0x0000009A, 0x0000002F,\n+            0x0000005E, 0x000000BC, 0x00000063, 0x000000C6,\n+            0x00000097, 0x00000035, 0x0000006A, 0x000000D4,\n+            0x000000B3, 0x0000007D, 0x000000FA, 0x000000EF,\n+            0x000000C5, 0x00000091,\n+    };\n+\n@@ -138,203 +1095,0 @@\n-    private static int[]\n-        alog = new int[256],\n-        log  = new int[256];\n-\n-    private static final byte[]\n-        S  = new byte[256],\n-        Si = new byte[256];\n-\n-    private static final int[]\n-        T1 = new int[256],\n-        T2 = new int[256],\n-        T3 = new int[256],\n-        T4 = new int[256],\n-        T5 = new int[256],\n-        T6 = new int[256],\n-        T7 = new int[256],\n-        T8 = new int[256];\n-\n-    private static final int[]\n-        U1 = new int[256],\n-        U2 = new int[256],\n-        U3 = new int[256],\n-        U4 = new int[256];\n-\n-    private static final byte[] rcon = new byte[30];\n-\n-\n-    \/\/ Static code - to initialise S-boxes and T-boxes\n-    static\n-    {\n-        int ROOT = 0x11B;\n-        int i, j = 0;\n-\n-        \/\/\n-        \/\/ produce log and alog tables, needed for multiplying in the\n-        \/\/ field GF(2^m) (generator = 3)\n-        \/\/\n-        alog[0] = 1;\n-        for (i = 1; i < 256; i++)\n-        {\n-            j = (alog[i-1] << 1) ^ alog[i-1];\n-            if ((j & 0x100) != 0) {\n-                j ^= ROOT;\n-            }\n-            alog[i] = j;\n-        }\n-        for (i = 1; i < 255; i++) {\n-            log[alog[i]] = i;\n-        }\n-        byte[][] A = new byte[][]\n-        {\n-            {1, 1, 1, 1, 1, 0, 0, 0},\n-            {0, 1, 1, 1, 1, 1, 0, 0},\n-            {0, 0, 1, 1, 1, 1, 1, 0},\n-            {0, 0, 0, 1, 1, 1, 1, 1},\n-            {1, 0, 0, 0, 1, 1, 1, 1},\n-            {1, 1, 0, 0, 0, 1, 1, 1},\n-            {1, 1, 1, 0, 0, 0, 1, 1},\n-            {1, 1, 1, 1, 0, 0, 0, 1}\n-        };\n-        byte[] B = new byte[] { 0, 1, 1, 0, 0, 0, 1, 1};\n-\n-        \/\/\n-        \/\/ substitution box based on F^{-1}(x)\n-        \/\/\n-        int t;\n-        byte[][] box = new byte[256][8];\n-        box[1][7] = 1;\n-        for (i = 2; i < 256; i++) {\n-            j = alog[255 - log[i]];\n-            for (t = 0; t < 8; t++) {\n-                box[i][t] = (byte)((j >>> (7 - t)) & 0x01);\n-            }\n-        }\n-        \/\/\n-        \/\/ affine transform:  box[i] <- B + A*box[i]\n-        \/\/\n-        byte[][] cox = new byte[256][8];\n-        for (i = 0; i < 256; i++) {\n-            for (t = 0; t < 8; t++) {\n-                cox[i][t] = B[t];\n-                for (j = 0; j < 8; j++) {\n-                    cox[i][t] ^= (byte)(A[t][j] * box[i][j]);\n-                }\n-            }\n-        }\n-        \/\/\n-        \/\/ S-boxes and inverse S-boxes\n-        \/\/\n-        for (i = 0; i < 256; i++) {\n-            S[i] = (byte)(cox[i][0] << 7);\n-            for (t = 1; t < 8; t++) {\n-                    S[i] ^= (byte)(cox[i][t] << (7-t));\n-            }\n-            Si[S[i] & 0xFF] = (byte) i;\n-        }\n-        \/\/\n-        \/\/ T-boxes\n-        \/\/\n-        byte[][] G = new byte[][] {\n-            {2, 1, 1, 3},\n-            {3, 2, 1, 1},\n-            {1, 3, 2, 1},\n-            {1, 1, 3, 2}\n-        };\n-        byte[][] AA = new byte[4][8];\n-        for (i = 0; i < 4; i++) {\n-            for (j = 0; j < 4; j++) AA[i][j] = G[i][j];\n-            AA[i][i+4] = 1;\n-        }\n-        byte pivot, tmp;\n-        byte[][] iG = new byte[4][4];\n-        for (i = 0; i < 4; i++) {\n-            pivot = AA[i][i];\n-            if (pivot == 0) {\n-                t = i + 1;\n-                while ((AA[t][i] == 0) && (t < 4)) {\n-                    t++;\n-                }\n-                if (t == 4) {\n-                    throw new RuntimeException(\"G matrix is not invertible\");\n-                }\n-                else {\n-                    for (j = 0; j < 8; j++) {\n-                        tmp = AA[i][j];\n-                        AA[i][j] = AA[t][j];\n-                        AA[t][j] = tmp;\n-                    }\n-                    pivot = AA[i][i];\n-                }\n-            }\n-            for (j = 0; j < 8; j++) {\n-                if (AA[i][j] != 0) {\n-                    AA[i][j] = (byte)\n-                        alog[(255 + log[AA[i][j] & 0xFF] - log[pivot & 0xFF])\n-                        % 255];\n-                }\n-            }\n-            for (t = 0; t < 4; t++) {\n-                if (i != t) {\n-                    for (j = i+1; j < 8; j++) {\n-                        AA[t][j] ^= (byte)(mul(AA[i][j], AA[t][i]));\n-                    }\n-                    AA[t][i] = 0;\n-                }\n-            }\n-        }\n-        for (i = 0; i < 4; i++) {\n-            for (j = 0; j < 4; j++) {\n-                iG[i][j] = AA[i][j + 4];\n-            }\n-        }\n-\n-        int s;\n-        for (t = 0; t < 256; t++) {\n-            s = S[t];\n-            T1[t] = mul4(s, G[0]);\n-            T2[t] = mul4(s, G[1]);\n-            T3[t] = mul4(s, G[2]);\n-            T4[t] = mul4(s, G[3]);\n-\n-            s = Si[t];\n-            T5[t] = mul4(s, iG[0]);\n-            T6[t] = mul4(s, iG[1]);\n-            T7[t] = mul4(s, iG[2]);\n-            T8[t] = mul4(s, iG[3]);\n-\n-            U1[t] = mul4(t, iG[0]);\n-            U2[t] = mul4(t, iG[1]);\n-            U3[t] = mul4(t, iG[2]);\n-            U4[t] = mul4(t, iG[3]);\n-        }\n-        \/\/\n-        \/\/ round constants\n-        \/\/\n-        rcon[0] = 1;\n-        int r = 1;\n-        for (t = 1; t < 30; t++) {\n-            r = mul(2, r);\n-            rcon[t] = (byte) r;\n-        }\n-        log = null;\n-        alog = null;\n-    }\n-\n-    \/\/ multiply two elements of GF(2^m)\n-    private static final int mul (int a, int b) {\n-        return (a != 0 && b != 0) ?\n-            alog[(log[a & 0xFF] + log[b & 0xFF]) % 255] :\n-            0;\n-    }\n-\n-    \/\/ convenience method used in generating Transposition boxes\n-    private static final int mul4 (int a, byte[] b) {\n-        if (a == 0) return 0;\n-        a = log[a & 0xFF];\n-        int a0 = (b[0] != 0) ? alog[(a + log[b[0] & 0xFF]) % 255] & 0xFF : 0;\n-        int a1 = (b[1] != 0) ? alog[(a + log[b[1] & 0xFF]) % 255] & 0xFF : 0;\n-        int a2 = (b[2] != 0) ? alog[(a + log[b[2] & 0xFF]) % 255] & 0xFF : 0;\n-        int a3 = (b[3] != 0) ? alog[(a + log[b[3] & 0xFF]) % 255] & 0xFF : 0;\n-        return a0 << 24 | a1 << 16 | a2 << 8 | a3;\n-    }\n-\n@@ -342,3 +1096,3 @@\n-    static final boolean isKeySizeValid(int len) {\n-        for (int i = 0; i < AES_KEYSIZES.length; i++) {\n-            if (len == AES_KEYSIZES[i]) {\n+    static boolean isKeySizeValid(int len) {\n+        for (int aesKeysize : AES_KEYSIZES) {\n+            if (len == aesKeysize) {\n@@ -382,1 +1136,1 @@\n-                    (in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];\n+                    (in[inOffset]   & 0xFF)        ) ^ K[keyOffset++];\n@@ -423,1 +1177,1 @@\n-        tt = K[keyOffset++];\n+        tt = K[keyOffset];\n@@ -574,1 +1328,1 @@\n-             T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];\n+             T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset];\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCrypt.java","additions":965,"deletions":211,"binary":false,"changes":1176,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-        if (markpos < 0)\n+        if (markpos == -1)\n@@ -309,1 +309,1 @@\n-            if (len >= getBufIfOpen().length && markpos < 0) {\n+            if (len >= getBufIfOpen().length && markpos == -1) {\n@@ -430,1 +430,1 @@\n-            if (markpos <0)\n+            if (markpos == -1)\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1016,1 +1016,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n@@ -1091,1 +1091,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,4 +153,5 @@\n- * float  {@link #getFloat()}\n- * float  {@link #getFloat(int) getFloat(int index)}\n- *  void  {@link #putFloat(float) putFloat(float f)}\n- *  void  {@link #putFloat(int,float) putFloat(int index, float f)}<\/pre><\/blockquote>\n+ * float      {@link #getFloat()}\n+ * float      {@link #getFloat(int) getFloat(int index)}\n+ * ByteBuffer {@link #putFloat(float) putFloat(float f)}\n+ * ByteBuffer {@link #putFloat(int,float) putFloat(int index, float f)}\n+ * <\/pre><\/blockquote>\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -531,0 +531,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -546,0 +550,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -562,0 +570,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -577,0 +589,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -596,0 +612,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -616,0 +636,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/DatagramChannel.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -375,0 +375,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -386,0 +390,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -397,0 +405,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -415,0 +427,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -432,0 +448,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -449,0 +469,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -78,0 +82,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SeekableByteChannel.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,0 +606,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -612,0 +615,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -619,0 +625,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -627,0 +636,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -633,0 +645,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -640,0 +655,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SocketChannel.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -313,0 +313,2 @@\n+     *\n+     * @throws  ClosedChannelException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelectableChannel.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    private static final String JAVA_LOCALE_USE_OLD_ISO_CODES;\n@@ -77,0 +78,1 @@\n+        JAVA_LOCALE_USE_OLD_ISO_CODES = getProperty(props, \"java.locale.useOldISOCodes\", \"\");\n@@ -246,0 +248,11 @@\n+\n+    \/**\n+     * {@return the {@code java.locale.useOldISOCodes} system property}\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method. The caller of this method should take care to ensure\n+     * that the returned property is not made accessible to untrusted code.<\/strong>\n+     *\/\n+    public static String javaLocaleUseOldISOCodes() {\n+        return JAVA_LOCALE_USE_OLD_ISO_CODES;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n- *      {@link java.nio.file.FileSystems#newFileSystem\n- *      FileSystems.newFileSystem(URI.create(\"jrt:\/\"))}.\n+ *      {@link java.nio.file.FileSystems#getFileSystem\n+ *      FileSystems.getFileSystem(URI.create(\"jrt:\/\"))}.\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.OptionalInt;\n@@ -249,0 +250,13 @@\n+\n+    public OptionalInt findInt(String k) {\n+        try {\n+            String s = findValue(k);\n+            if (s == null) {\n+                return OptionalInt.empty();\n+            }\n+            return OptionalInt.of(Integer.parseInt(s));\n+        } catch (Throwable t) {\n+            return OptionalInt.empty();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/HeaderParser.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,4 @@\n-                assert (n - i >= 2);\n+                if (n - i < 2) {\n+                    throw new IllegalArgumentException(\"Malformed escape pair: \" + s);\n+                }\n+\n@@ -203,2 +206,2 @@\n-                } catch (NumberFormatException e) {\n-                    throw new IllegalArgumentException();\n+                } catch (NumberFormatException | IndexOutOfBoundsException e) {\n+                    throw new IllegalArgumentException(\"Malformed escape pair: \" + s);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/ParseUtil.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.OptionalInt;\n@@ -130,0 +131,1 @@\n+     * -2: the server provided \"Connection: keep-alive\" and timeout=0\n@@ -906,4 +908,2 @@\n-                        keepAliveTimeout = p.findInt(\"timeout\", -1);\n-                        if (keepAliveTimeout < -1) {\n-                            \/\/ if the server specified a negative (invalid) value\n-                            \/\/ then we set to -1, which is equivalent to no value\n+                        OptionalInt timeout = p.findInt(\"timeout\");\n+                        if (timeout.isEmpty()) {\n@@ -911,0 +911,10 @@\n+                        } else {\n+                            keepAliveTimeout = timeout.getAsInt();\n+                            if (keepAliveTimeout < 0) {\n+                                \/\/ if the server specified a negative (invalid) value\n+                                \/\/ then we set to -1, which is equivalent to no value\n+                                keepAliveTimeout = -1;\n+                            } else if (keepAliveTimeout == 0) {\n+                                \/\/ handled specially to mean close connection immediately\n+                                keepAliveTimeout = -2;\n+                            }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -176,0 +176,2 @@\n+                } else if (keepAliveTimeout == -2) {\n+                    keepAliveTimeout = 0;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.net.MalformedURLException;\n@@ -61,1 +62,9 @@\n-        return new FtpURLConnection(u, p);\n+        FtpURLConnection connection = null;\n+        try {\n+            connection = new FtpURLConnection(u, p);\n+        } catch (IllegalArgumentException e) {\n+            var mfue = new MalformedURLException(e.getMessage());\n+            mfue.initCause(e);\n+            throw mfue;\n+        }\n+        return connection;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/ftp\/Handler.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1672,11 +1672,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -1796,11 +1785,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -1969,11 +1947,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2099,11 +2066,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2238,11 +2194,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2367,11 +2312,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2529,11 +2463,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2660,11 +2583,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+        recordLock.lock();\n@@ -259,0 +260,3 @@\n+            if (isClosed) {\n+                return null;\n+            }\n@@ -267,0 +271,2 @@\n+        } finally {\n+            recordLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketInputRecord.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -332,1 +332,2 @@\n-        BigInteger mod = BigInteger.valueOf(1 << bitsPerLimb);\n+        assert bitsPerLimb < 32;\n+        long limbMask = (1L << bitsPerLimb) - 1;\n@@ -334,1 +335,1 @@\n-            limbs[i] = v.mod(mod).longValue();\n+            limbs[i] = v.intValue() & limbMask;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -37,1 +38,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -104,0 +104,2 @@\n+     * The system property \"java.locale.useOldISOCodes\" is not security sensitive,\n+     * so no need to ensure privileged access here.\n@@ -105,2 +107,1 @@\n-    private static final boolean OLD_ISO_CODES = GetPropertyAction.privilegedGetProperties()\n-            .getProperty(\"java.locale.useOldISOCodes\", \"false\")\n+    private static final boolean OLD_ISO_CODES = StaticProperty.javaLocaleUseOldISOCodes()\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2022d\n+tzdata2022e\n","filename":"src\/java.base\/share\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2257,0 +2257,11 @@\n+# From Issam Al-Zuwairi (2022-10-05):\n+# The Council of Ministers in Jordan decided Wednesday 5th October 2022,\n+# that daylight saving time (DST) will be throughout the year....\n+#\n+# From Brian Inglis (2022-10-06):\n+# https:\/\/petra.gov.jo\/Include\/InnerPage.jsp?ID=45567&lang=en&name=en_news\n+#\n+# From Paul Eggert (2022-10-05):\n+# Like Syria, model this as a transition from EEST +03 (DST) to plain +03\n+# (non-DST) at the point where DST would otherwise have ended.\n+\n@@ -2288,2 +2299,2 @@\n-Rule\tJordan\t2014\tmax\t-\tOct\tlastFri\t0:00s\t0\t-\n-Rule\tJordan\t2022\tmax\t-\tFeb\tlastThu\t24:00\t1:00\tS\n+Rule\tJordan\t2014\t2022\t-\tOct\tlastFri\t0:00s\t0\t-\n+Rule\tJordan\t2022\tonly\t-\tFeb\tlastThu\t24:00\t1:00\tS\n@@ -2292,1 +2303,2 @@\n-\t\t\t2:00\tJordan\tEE%sT\n+\t\t\t2:00\tJordan\tEE%sT\t2022 Oct 28 0:00s\n+\t\t\t3:00\t-\t+03\n@@ -3841,2 +3853,9 @@\n-# From Arthur David Olson (2012-03-27):\n-# Assume last Friday in March going forward XXX.\n+# From Steffen Thorsen (2022-10-05):\n+# Syria is adopting year-round DST, starting this autumn....\n+# From https:\/\/www.enabbaladi.net\/archives\/607812\n+# \"This [the decision] came after the weekly government meeting today,\n+# Tuesday 4 October ...\"\n+#\n+# From Paul Eggert (2022-10-05):\n+# Like Jordan, model this as a transition from EEST +03 (DST) to plain +03\n+# (non-DST) at the point where DST would otherwise have ended.\n@@ -3848,2 +3867,2 @@\n-Rule\tSyria\t2012\tmax\t-\tMar\tlastFri\t0:00\t1:00\tS\n-Rule\tSyria\t2009\tmax\t-\tOct\tlastFri\t0:00\t0\t-\n+Rule\tSyria\t2012\t2022\t-\tMar\tlastFri\t0:00\t1:00\tS\n+Rule\tSyria\t2009\t2022\t-\tOct\tlastFri\t0:00\t0\t-\n@@ -3853,1 +3872,2 @@\n-\t\t\t2:00\tSyria\tEE%sT\n+\t\t\t2:00\tSyria\tEE%sT\t2022 Oct 28 0:00\n+\t\t\t3:00\t-\t+03\n","filename":"src\/java.base\/share\/data\/tzdata\/asia","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3420,1 +3420,1 @@\n-Zone\tAfrica\/Ceuta\t-0:21:16 -\tLMT\t1900 Dec 31 23:38:44\n+Zone\tAfrica\/Ceuta\t-0:21:16 -\tLMT\t1901 Jan  1  0:00u\n","filename":"src\/java.base\/share\/data\/tzdata\/europe","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-Zone America\/Chicago\t-5:50:36 -\tLMT\t1883 Nov 18 12:09:24\n+Zone America\/Chicago\t-5:50:36 -\tLMT\t1883 Nov 18 18:00u\n@@ -474,1 +474,1 @@\n-Zone America\/North_Dakota\/Center -6:45:12 - LMT\t1883 Nov 18 12:14:48\n+Zone America\/North_Dakota\/Center -6:45:12 - LMT\t1883 Nov 18 19:00u\n@@ -484,1 +484,1 @@\n-Zone America\/North_Dakota\/New_Salem -6:45:39 - LMT\t1883 Nov 18 12:14:21\n+Zone America\/North_Dakota\/New_Salem -6:45:39 - LMT 1883 Nov 18 19:00u\n@@ -501,1 +501,1 @@\n-Zone America\/North_Dakota\/Beulah -6:47:07 - LMT\t1883 Nov 18 12:12:53\n+Zone America\/North_Dakota\/Beulah -6:47:07 - LMT\t1883 Nov 18 19:00u\n@@ -533,1 +533,1 @@\n-Zone America\/Denver\t-6:59:56 -\tLMT\t1883 Nov 18 12:00:04\n+Zone America\/Denver\t-6:59:56 -\tLMT\t1883 Nov 18 19:00u\n@@ -586,1 +586,1 @@\n-Zone America\/Los_Angeles -7:52:58 -\tLMT\t1883 Nov 18 12:07:02\n+Zone America\/Los_Angeles -7:52:58 -\tLMT\t1883 Nov 18 20:00u\n@@ -848,1 +848,1 @@\n-Zone America\/Phoenix\t-7:28:18 -\tLMT\t1883 Nov 18 11:31:42\n+Zone America\/Phoenix\t-7:28:18 -\tLMT\t1883 Nov 18 19:00u\n@@ -876,1 +876,1 @@\n-Zone America\/Boise\t-7:44:49 -\tLMT\t1883 Nov 18 12:15:11\n+Zone America\/Boise\t-7:44:49 -\tLMT\t1883 Nov 18 20:00u\n@@ -948,1 +948,1 @@\n-Zone America\/Indiana\/Indianapolis -5:44:38 - LMT\t1883 Nov 18 12:15:22\n+Zone America\/Indiana\/Indianapolis -5:44:38 - LMT 1883 Nov 18 18:00u\n@@ -968,1 +968,1 @@\n-Zone America\/Indiana\/Marengo -5:45:23 -\tLMT\t1883 Nov 18 12:14:37\n+Zone America\/Indiana\/Marengo -5:45:23 -\tLMT\t1883 Nov 18 18:00u\n@@ -992,1 +992,1 @@\n-Zone America\/Indiana\/Vincennes -5:50:07 - LMT\t1883 Nov 18 12:09:53\n+Zone America\/Indiana\/Vincennes -5:50:07 - LMT\t1883 Nov 18 18:00u\n@@ -1012,1 +1012,1 @@\n-Zone America\/Indiana\/Tell_City -5:47:03 - LMT\t1883 Nov 18 12:12:57\n+Zone America\/Indiana\/Tell_City -5:47:03 - LMT\t1883 Nov 18 18:00u\n@@ -1029,1 +1029,1 @@\n-Zone America\/Indiana\/Petersburg -5:49:07 - LMT\t1883 Nov 18 12:10:53\n+Zone America\/Indiana\/Petersburg -5:49:07 - LMT\t1883 Nov 18 18:00u\n@@ -1051,1 +1051,1 @@\n-Zone America\/Indiana\/Knox -5:46:30 -\tLMT\t1883 Nov 18 12:13:30\n+Zone America\/Indiana\/Knox -5:46:30 -\tLMT\t1883 Nov 18 18:00u\n@@ -1067,1 +1067,1 @@\n-Zone America\/Indiana\/Winamac -5:46:25 - LMT\t1883 Nov 18 12:13:35\n+Zone America\/Indiana\/Winamac -5:46:25 - LMT\t1883 Nov 18 18:00u\n@@ -1078,1 +1078,1 @@\n-Zone America\/Indiana\/Vevay -5:40:16 -\tLMT\t1883 Nov 18 12:19:44\n+Zone America\/Indiana\/Vevay -5:40:16 -\tLMT\t1883 Nov 18 18:00u\n@@ -1114,1 +1114,1 @@\n-Zone America\/Kentucky\/Louisville -5:43:02 -\tLMT\t1883 Nov 18 12:16:58\n+Zone America\/Kentucky\/Louisville -5:43:02 - LMT\t1883 Nov 18 18:00u\n@@ -1148,1 +1148,1 @@\n-Zone America\/Kentucky\/Monticello -5:39:24 - LMT\t1883 Nov 18 12:20:36\n+Zone America\/Kentucky\/Monticello -5:39:24 - LMT\t1883 Nov 18 18:00u\n@@ -2643,0 +2643,2 @@\n+Rule\tMexico\t1931\tonly\t-\tMay\t1\t23:00\t1:00\tD\n+Rule\tMexico\t1931\tonly\t-\tOct\t1\t0:00\t0\tS\n@@ -2659,1 +2661,1 @@\n-Zone America\/Cancun\t-5:47:04 -\tLMT\t1922 Jan  1  0:12:56\n+Zone America\/Cancun\t-5:47:04 -\tLMT\t1922 Jan  1  6:00u\n@@ -2665,1 +2667,1 @@\n-Zone America\/Merida\t-5:58:28 -\tLMT\t1922 Jan  1  0:01:32\n+Zone America\/Merida\t-5:58:28 -\tLMT\t1922 Jan  1  6:00u\n@@ -2679,1 +2681,1 @@\n-Zone America\/Matamoros\t-6:40:00 -\tLMT\t1921 Dec 31 23:20:00\n+Zone America\/Matamoros\t-6:30:00 -\tLMT\t1922 Jan  1  6:00u\n@@ -2685,1 +2687,1 @@\n-Zone America\/Monterrey\t-6:41:16 -\tLMT\t1921 Dec 31 23:18:44\n+Zone America\/Monterrey\t-6:41:16 -\tLMT\t1922 Jan  1  6:00u\n@@ -2690,1 +2692,1 @@\n-Zone America\/Mexico_City -6:36:36 -\tLMT\t1922 Jan  1  0:23:24\n+Zone America\/Mexico_City -6:36:36 -\tLMT\t1922 Jan  1  7:00u\n@@ -2693,3 +2695,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2703,1 +2703,1 @@\n-Zone America\/Ojinaga\t-6:57:40 -\tLMT\t1922 Jan  1  0:02:20\n+Zone America\/Ojinaga\t-6:57:40 -\tLMT\t1922 Jan  1  7:00u\n@@ -2706,3 +2706,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2715,1 +2713,1 @@\n-Zone America\/Chihuahua\t-7:04:20 -\tLMT\t1921 Dec 31 23:55:40\n+Zone America\/Chihuahua\t-7:04:20 -\tLMT\t1922 Jan  1  7:00u\n@@ -2718,3 +2716,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2726,1 +2722,1 @@\n-Zone America\/Hermosillo\t-7:23:52 -\tLMT\t1921 Dec 31 23:36:08\n+Zone America\/Hermosillo\t-7:23:52 -\tLMT\t1922 Jan  1  7:00u\n@@ -2729,3 +2725,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2766,1 +2760,1 @@\n-Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1921 Dec 31 23:54:20\n+Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1922 Jan  1  7:00u\n@@ -2769,3 +2763,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2778,1 +2770,1 @@\n-Zone America\/Bahia_Banderas\t-7:01:00 -\tLMT\t1921 Dec 31 23:59:00\n+Zone America\/Bahia_Banderas -7:01:00 -\tLMT\t1922 Jan  1  7:00u\n@@ -2781,3 +2773,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2791,1 +2781,1 @@\n-Zone America\/Tijuana\t-7:48:04 -\tLMT\t1922 Jan  1  0:11:56\n+Zone America\/Tijuana\t-7:48:04 -\tLMT\t1922 Jan  1  7:00u\n","filename":"src\/java.base\/share\/data\/tzdata\/northamerica","additions":37,"deletions":47,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-for the specific language governing rights and limitations under the License. \n+for the specific language governing rights and limitations under the License.\n@@ -62,1 +62,1 @@\n-    means a work that combines Covered Software with other material, in \n+    means a work that combines Covered Software with other material, in\n","filename":"src\/java.base\/share\/legal\/public_suffix.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-[http:\/\/openjdk.java.net\/jeps\/330] for complete details.\n+[https:\/\/openjdk.org\/jeps\/330] for complete details.\n@@ -4114,2 +4114,1 @@\n-261\\f[R]\n-[https:\/\/openjdk.java.net\/jeps\/261#Relaxed\\-strong\\-encapsulation].\n+261\\f[R] [https:\/\/openjdk.org\/jeps\/261#Relaxed\\-strong\\-encapsulation].\n@@ -4117,2 +4116,2 @@\n-[https:\/\/openjdk.java.net\/jeps\/396] and made obsolete in JDK 17 by\n-\\f[B]JEP 403\\f[R] [https:\/\/openjdk.java.net\/jeps\/403].\n+[https:\/\/openjdk.org\/jeps\/396] and made obsolete in JDK 17 by \\f[B]JEP\n+403\\f[R] [https:\/\/openjdk.org\/jeps\/403].\n@@ -4395,1 +4394,1 @@\n-[https:\/\/bugs.openjdk.java.net\/secure\/attachment\/75649\/JVM_CodeHeap_StateAnalytics_V2.pdf]\n+[https:\/\/bugs.openjdk.org\/secure\/attachment\/75649\/JVM_CodeHeap_StateAnalytics_V2.pdf]\n","filename":"src\/java.base\/share\/man\/java.1","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+#define JLI_Snprintf            snprintf\n+\n@@ -91,1 +93,0 @@\n-int JLI_Snprintf(char *buffer, size_t size, const char *format, ...);\n@@ -101,1 +102,0 @@\n-#define JLI_Snprintf                    snprintf\n","filename":"src\/java.base\/share\/native\/libjli\/jli_util.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -478,32 +478,0 @@\n-\/*\n- * windows snprintf does not guarantee a null terminator in the buffer,\n- * if the computed size is equal to or greater than the buffer size,\n- * as well as error conditions. This function guarantees a null terminator\n- * under all these conditions. An unreasonable buffer or size will return\n- * an error value. Under all other conditions this function will return the\n- * size of the bytes actually written minus the null terminator, similar\n- * to ansi snprintf api. Thus when calling this function the caller must\n- * ensure storage for the null terminator.\n- *\/\n-int\n-JLI_Snprintf(char* buffer, size_t size, const char* format, ...) {\n-    int rc;\n-    va_list vl;\n-    if (size == 0 || buffer == NULL)\n-        return -1;\n-    buffer[0] = '\\0';\n-    va_start(vl, format);\n-    rc = vsnprintf(buffer, size, format, vl);\n-    va_end(vl);\n-    \/* force a null terminator, if something is amiss *\/\n-    if (rc < 0) {\n-        \/* apply ansi semantics *\/\n-        buffer[size - 1] = '\\0';\n-        return (int)size;\n-    } else if (rc == size) {\n-        \/* force a null terminator *\/\n-        buffer[size - 1] = '\\0';\n-    }\n-    return rc;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libjli\/java_md.c","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,3 +68,3 @@\n-    private List<Method> methods;\n-    private Map<String,PropertyInfo> properties;\n-    private Map<String,EventSetInfo> eventSets;\n+    private volatile List<Method> methods;\n+    private volatile Map<String,PropertyInfo> properties;\n+    private volatile Map<String,EventSetInfo> eventSets;\n@@ -77,1 +77,2 @@\n-        if (this.methods == null) {\n+        List<Method> methods = this.methods;\n+        if (methods == null) {\n@@ -79,2 +80,4 @@\n-                if (this.methods == null) {\n-                    this.methods = MethodInfo.get(this.type);\n+                methods = this.methods;\n+                if (methods == null) {\n+                    methods = MethodInfo.get(this.type);\n+                    this.methods = methods;\n@@ -84,1 +87,1 @@\n-        return this.methods;\n+        return methods;\n@@ -88,1 +91,2 @@\n-        if (this.properties == null) {\n+        Map<String, PropertyInfo> properties = this.properties;\n+        if (properties == null) {\n@@ -90,2 +94,4 @@\n-                if (this.properties == null) {\n-                    this.properties = PropertyInfo.get(this.type);\n+                properties = this.properties;\n+                if (properties == null) {\n+                    properties = PropertyInfo.get(this.type);\n+                    this.properties = properties;\n@@ -95,1 +101,1 @@\n-        return this.properties;\n+        return properties;\n@@ -99,1 +105,2 @@\n-        if (this.eventSets == null) {\n+        Map<String, EventSetInfo> eventSets = this.eventSets;\n+        if (eventSets == null) {\n@@ -101,2 +108,4 @@\n-                if (this.eventSets == null) {\n-                    this.eventSets = EventSetInfo.get(this.type);\n+                eventSets = this.eventSets;\n+                if (eventSets == null) {\n+                    eventSets = EventSetInfo.get(this.type);\n+                    this.eventSets = eventSets;\n@@ -106,1 +115,1 @@\n-        return this.eventSets;\n+        return eventSets;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/introspect\/ClassInfo.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -983,0 +983,20 @@\n+\n+        @Override\n+        public Vector<File> getDirectories() {\n+            Vector<File> files = super.getDirectories();\n+\n+            \/*\n+             * Delete the \"\/..\" file entry from file chooser directory list in\n+             * GTK LAF if current directory is root and files vector contains\n+             * \"\/..\" entry.\n+             *\n+             * It is not possible to go beyond root directory.\n+             *\/\n+            File crntDir = getFileChooser().getCurrentDirectory();\n+            FileSystemView fsv = getFileChooser().getFileSystemView();\n+            if (crntDir != null && fsv.isFileSystemRoot(crntDir) &&\n+                files.contains(new File(\"\/..\"))) {\n+                    files.removeElementAt(0);\n+            }\n+            return files;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKFileChooserUI.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -74,4 +74,4 @@\n- * The details of this class are not important for simple applets, which draw in\n- * a default color space or manipulate and display imported images with a known\n- * color space. At most, such applets would need to get one of the default color\n- * spaces via {@link ColorSpace#getInstance}.\n+ * The details of this class are not important for simple applications, which\n+ * draw in a default color space or manipulate and display imported images with\n+ * a known color space. At most, such applications would need to get one of the\n+ * default color spaces via {@link ColorSpace#getInstance}.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ColorSpace.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1076,2 +1076,2 @@\n-     * This method is useful for advanced applets or applications which need to\n-     * access profile data directly.\n+     * This method is useful for advanced applications which need to access\n+     * profile data directly.\n@@ -1102,2 +1102,2 @@\n-     * This method is useful for advanced applets or applications which need to\n-     * access profile data directly.\n+     * This method is useful for advanced applications which need to access\n+     * profile data directly.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.beans.*;\n+import java.util.ArrayList;\n@@ -256,1 +256,1 @@\n-            listeners = new java.util.Vector<>();\n+            listeners = new ArrayList<>();\n@@ -258,1 +258,1 @@\n-        listeners.addElement(listener);\n+        listeners.add(listener);\n@@ -276,1 +276,1 @@\n-        listeners.removeElement(listener);\n+        listeners.remove(listener);\n@@ -283,1 +283,1 @@\n-        java.util.Vector<PropertyChangeListener> targets;\n+        ArrayList<PropertyChangeListener> targets;\n@@ -288,1 +288,1 @@\n-            targets = unsafeClone(listeners);\n+            targets = new ArrayList<>(listeners);\n@@ -294,1 +294,1 @@\n-            PropertyChangeListener target = targets.elementAt(i);\n+            PropertyChangeListener target = targets.get(i);\n@@ -299,5 +299,0 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private <T> java.util.Vector<T> unsafeClone(java.util.Vector<T> v) {\n-        return (java.util.Vector<T>)v.clone();\n-    }\n-\n@@ -308,1 +303,1 @@\n-    private java.util.Vector<PropertyChangeListener> listeners;\n+    private ArrayList<PropertyChangeListener> listeners;\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/PropertyEditorSupport.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -211,0 +214,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -219,0 +225,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -227,0 +236,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -241,0 +253,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -245,0 +260,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -249,0 +267,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -265,0 +286,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -269,0 +293,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -283,0 +310,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -287,0 +317,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -321,0 +354,4 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     * @throws java.io.UTFDataFormatException {@inheritDoc}\n+     *\/\n@@ -343,0 +380,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -360,0 +400,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -364,0 +407,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -380,0 +426,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -396,0 +445,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -412,0 +464,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -428,0 +483,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -444,0 +502,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -644,0 +705,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -666,0 +730,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageInputStreamImpl.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,0 +159,3 @@\n+    \/**\n+     * @throws UTFDataFormatException {@inheritDoc}\n+     *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageOutputStreamImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,3 +1269,1 @@\n-            if (!getFileChooser().getCurrentDirectory().equals(f)) {\n-                getFileChooser().setCurrentDirectory(f);\n-            }\n+            getFileChooser().setCurrentDirectory(f);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalFileChooserUI.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1821,2 +1821,0 @@\n-    static final Border noBorder = new EmptyBorder(0,0,0,0);\n-\n@@ -2522,1 +2520,0 @@\n-        URL imageurl;\n@@ -3226,2 +3223,0 @@\n-    static final int DEFAULT_FONT_SIZE = 3;\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/StyleSheet.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import java.text.NumberFormat;\n@@ -1124,2 +1125,5 @@\n-        JFileChooser chooser;\n-        DateFormat df;\n+        private final JFileChooser chooser;\n+        private final DateFormat df;\n+        private final MessageFormat mf = new MessageFormat(\"\");\n+        private final NumberFormat nf = NumberFormat.getNumberInstance();\n+        private static final double baseFileSize = 1000.0;\n@@ -1131,0 +1135,1 @@\n+            nf.setMinimumFractionDigits(1);\n@@ -1192,2 +1197,12 @@\n-            } else if (value instanceof Long) {\n-                long len = ((Long) value) \/ 1024L;\n+            } else if (value instanceof final Long len) {\n+                \/*\n+                 * This code block is relevant to Linux.\n+                 * File size is displayed up to 1 decimal precision.\n+                 * Base-10 number system is used for formatting file size\n+                 * similar to how it's formatted in file managers on Linux.\n+                 * Empty file size is shown as 0.0 KB,\n+                 * 1-100-byte files are shown as 0.1 KB,\n+                 * 101-200-byte files are shown as 0.2 KB and so on.\n+                 *\/\n+                Object[] displayedFileSize = new Object[1];\n+\n@@ -1195,3 +1210,2 @@\n-                    text = MessageFormat.format(kiloByteString, len + 1);\n-                } else if (len < 1024L) {\n-                    text = MessageFormat.format(kiloByteString, (len == 0L) ? 1L : len);\n+                    updateMessageFormatPattern(kiloByteString);\n+                    displayedFileSize[0] = roundToOneDecimalPlace(len);\n@@ -1199,3 +1213,4 @@\n-                    len \/= 1024L;\n-                    if (len < 1024L) {\n-                        text = MessageFormat.format(megaByteString, len);\n+                    double kbVal = roundToOneDecimalPlace(len);\n+                    if (kbVal < baseFileSize) {\n+                        updateMessageFormatPattern(kiloByteString);\n+                        displayedFileSize[0] = kbVal;\n@@ -1203,2 +1218,8 @@\n-                        len \/= 1024L;\n-                        text = MessageFormat.format(gigaByteString, len);\n+                        double mbVal = roundToOneDecimalPlace(Math.ceil(kbVal));\n+                        if (mbVal < baseFileSize) {\n+                            updateMessageFormatPattern(megaByteString);\n+                            displayedFileSize[0] = mbVal;\n+                        } else {\n+                            updateMessageFormatPattern(gigaByteString);\n+                            displayedFileSize[0] = roundToOneDecimalPlace(Math.ceil(mbVal));\n+                        }\n@@ -1207,0 +1228,1 @@\n+                text = mf.format(displayedFileSize);\n@@ -1219,0 +1241,17 @@\n+\n+        private void updateMessageFormatPattern(String pattern) {\n+            mf.applyPattern(pattern);\n+            mf.setFormat(0, nf);\n+        }\n+\n+        \/**\n+         * Rounds a value to one decimal place. It's used to format\n+         * file size similar to how it's formatted in file managers on Linux.\n+         * For example, the file size of 1200 bytes is rounded to 1.2 KB.\n+         *\n+         * @param fileSize the file size to round to one decimal place\n+         * @return file size rounded to one decimal place\n+         *\/\n+        private static double roundToOneDecimalPlace(double fileSize) {\n+            return Math.ceil(fileSize \/ 100.0d) \/ 10.0d;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/FilePane.java","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-Copyright  2019,2020  Facebook, Inc. \n+Copyright  2019,2020  Facebook, Inc.\n","filename":"src\/java.desktop\/share\/legal\/harfbuzz.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-IJG is not affiliated with the official ISO JPEG standards committee. \n+IJG is not affiliated with the official ISO JPEG standards committee.\n","filename":"src\/java.desktop\/share\/legal\/jpeg.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -416,0 +416,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -420,0 +424,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -424,0 +432,3 @@\n+    \/**\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -428,0 +439,3 @@\n+    \/**\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -432,0 +446,3 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     *\/\n@@ -436,0 +453,3 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     *\/\n@@ -440,0 +460,3 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     *\/\n@@ -444,0 +467,3 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     *\/\n@@ -472,0 +498,5 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     * @throws  NotContextException {@inheritDoc}\n+     * @throws  ContextNotEmptyException {@inheritDoc}\n+     *\/\n@@ -476,0 +507,5 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     * @throws  NotContextException {@inheritDoc}\n+     * @throws  ContextNotEmptyException {@inheritDoc}\n+     *\/\n@@ -480,0 +516,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -484,0 +524,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -554,0 +598,3 @@\n+    \/**\n+     * @throws OperationNotSupportedException {@inheritDoc}\n+     *\/\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/InitialContext.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,0 +477,2 @@\n+      *\n+      * @throws OperationNotSupportedException {@inheritDoc}\n@@ -487,0 +489,2 @@\n+      *\n+      * @throws OperationNotSupportedException {@inheritDoc}\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/BasicAttribute.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -184,0 +184,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -189,0 +192,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -194,0 +200,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -199,0 +208,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -204,0 +216,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -209,0 +225,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -214,0 +234,3 @@\n+    \/**\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -219,0 +242,3 @@\n+    \/**\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -224,0 +250,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -229,0 +259,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -234,0 +268,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -238,0 +275,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -242,0 +282,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -247,0 +290,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -290,0 +336,4 @@\n+    \/**\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     *\/\n@@ -299,0 +349,4 @@\n+    \/**\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     *\/\n@@ -308,0 +362,4 @@\n+    \/**\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     *\/\n@@ -319,0 +377,4 @@\n+    \/**\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     *\/\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/InitialDirContext.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -754,3 +754,8 @@\n-        \/\/ TODO: userinfo deprecated. Needs to be removed\n-        hdrs.setHeader(\":authority\", uri.getAuthority());\n-        \/\/ TODO: ensure header names beginning with : not in user headers\n+        String host = uri.getHost();\n+        int port = uri.getPort();\n+        assert host != null;\n+        if (port != -1) {\n+            hdrs.setHeader(\":authority\", host + \":\" + port);\n+        } else {\n+            hdrs.setHeader(\":authority\", host);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -321,1 +321,1 @@\n-     * @throws NullPointerException {@inheritDoc}.\n+     * @throws NullPointerException {@inheritDoc}\n","filename":"src\/java.prefs\/share\/classes\/java\/util\/prefs\/AbstractPreferences.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -14,2 +14,2 @@\n-   Specifically, we only include the XSLTC portion of the source from the Xalan distribution. \n-   The Xalan project has two processors: an interpretive one (Xalan Interpretive) and a \n+   Specifically, we only include the XSLTC portion of the source from the Xalan distribution.\n+   The Xalan project has two processors: an interpretive one (Xalan Interpretive) and a\n@@ -237,7 +237,7 @@\n-Permission to use, copy, modify, and distribute this software and \n-its documentation for any purpose and without fee is hereby granted, \n-provided that the above copyright notice appear in all copies and that \n-both the copyright notice and this permission notice and warranty \n-disclaimer appear in supporting documentation, and that the name of \n-the authors or their employers not be used in advertising or publicity \n-pertaining to distribution of the software without specific, written \n+Permission to use, copy, modify, and distribute this software and\n+its documentation for any purpose and without fee is hereby granted,\n+provided that the above copyright notice appear in all copies and that\n+both the copyright notice and this permission notice and warranty\n+disclaimer appear in supporting documentation, and that the name of\n+the authors or their employers not be used in advertising or publicity\n+pertaining to distribution of the software without specific, written\n@@ -245,8 +245,8 @@\n-The authors and their employers disclaim all warranties with regard to \n-this software, including all implied warranties of merchantability and \n-fitness. In no event shall the authors or their employers be liable for \n-any special, indirect or consequential damages or any damages whatsoever \n-resulting from loss of use, data or profits, whether in an action of \n-contract, negligence or other tortious action, arising out of or in \n-connection with the use or performance of this software.The portions of \n-JLex output which are hard-coded into the JLex source code are (naturally) \n+The authors and their employers disclaim all warranties with regard to\n+this software, including all implied warranties of merchantability and\n+fitness. In no event shall the authors or their employers be liable for\n+any special, indirect or consequential damages or any damages whatsoever\n+resulting from loss of use, data or profits, whether in an action of\n+contract, negligence or other tortious action, arising out of or in\n+connection with the use or performance of this software.The portions of\n+JLex output which are hard-coded into the JLex source code are (naturally)\n","filename":"src\/java.xml\/share\/legal\/xalan.md","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    \n+\n","filename":"src\/java.xml\/share\/legal\/xerces.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,3 +212,0 @@\n-            \/\/\n-            \/\/ PKCS11 does not support GCM mode as the author made the comment,\n-            \/\/ so the macBits is unlikely to be zero. It's only a place holder.\n@@ -221,0 +218,7 @@\n+                \/\/ NSS allocates MAC keys even if macBits is zero\n+                if (out.hClientMacSecret != CK_INVALID_HANDLE) {\n+                    token.p11.C_DestroyObject(session.id(), out.hClientMacSecret);\n+                }\n+                if (out.hServerMacSecret != CK_INVALID_HANDLE) {\n+                    token.p11.C_DestroyObject(session.id(), out.hServerMacSecret);\n+                }\n@@ -232,0 +236,2 @@\n+                assert out.hClientKey == 0;\n+                assert out.hServerKey == 0;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsKeyMaterialGenerator.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -307,3 +307,1 @@\n-        p.getX().setValue(p.getY()).setProduct(two);\n-        p.getY().setSum(p.getX());\n-        p.getY().setReduced();\n+        p.getY().setProduct(three);\n@@ -316,2 +314,1 @@\n-        t3.setValue(t2).setProduct(two);\n-        t2.setSum(t3);\n+        t2.setProduct(three);\n@@ -320,1 +317,0 @@\n-        t2.setReduced();\n@@ -323,3 +319,1 @@\n-        t3.setValue(p.getZ()).setProduct(two);\n-        p.getZ().setReduced();\n-        p.getZ().setSum(t3);\n+        p.getZ().setProduct(three);\n@@ -385,3 +379,1 @@\n-        p.getX().setReduced();\n-        p.getZ().setValue(p.getX()).setProduct(two);\n-        p.getX().setSum(p.getZ());\n+        p.getX().setProduct(three);\n@@ -393,3 +385,1 @@\n-        t1.setValue(t2).setProduct(two);\n-        t2.setSum(t1);\n-        t2.setReduced();\n+        t2.setProduct(three);\n@@ -399,3 +389,1 @@\n-        p.getY().setReduced();\n-        t1.setValue(p.getY()).setProduct(two);\n-        p.getY().setSum(t1);\n+        p.getY().setProduct(three);\n@@ -403,2 +391,1 @@\n-        t1.setValue(t0).setProduct(two);\n-        t0.setSum(t1);\n+        t0.setProduct(three);\n@@ -416,2 +403,2 @@\n-        t1.setValue(t3).setProduct(t0);\n-        p.getZ().setSum(t1);\n+        t3.setProduct(t0);\n+        p.getZ().setSum(t3);\n@@ -456,1 +443,0 @@\n-        p.getZ().setValue(p.getX()).setProduct(two);\n@@ -458,2 +444,2 @@\n-        p.getX().setSum(p.getZ());\n-        p.getX().setReduced();\n+        p.getX().setProduct(three);\n+\n@@ -464,3 +450,1 @@\n-        t1.setValue(t2).setSum(t2);\n-        t2.setSum(t1);\n-        t2.setReduced();\n+        t2.setProduct(three);\n@@ -470,2 +454,1 @@\n-        p.getY().setReduced();\n-        t1.setValue(p.getY()).setSum(p.getY());\n+        p.getY().setProduct(three);\n@@ -473,3 +456,1 @@\n-        p.getY().setSum(t1);\n-        t1.setValue(t0).setProduct(two);\n-        t0.setSum(t1);\n+        t0.setProduct(three);\n@@ -487,1 +468,0 @@\n-        t1.setValue(t3).setProduct(t0);\n@@ -489,1 +469,2 @@\n-        p.getZ().setSum(t1);\n+        t3.setProduct(t0);\n+        p.getZ().setSum(t3);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":16,"deletions":35,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-        if (xLSB != x.asBigInteger().mod(BigInteger.valueOf(2)).intValue()) {\n+        if (xLSB != (x.asBigInteger().intValue() & 1)) {\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed25519Operations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +130,1 @@\n-        if (xLSB != x.asBigInteger().mod(TWO).intValue()) {\n+        if (xLSB != (x.asBigInteger().intValue() & 1)) {\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed448Operations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -13,2 +13,12 @@\n-always successfully open the dump. This is due to kernel, library (shared\n-objects or DLLs) mismatch between core dump machine and debugger machine.\n+always successfully open the core dump. This is due to library (shared\n+objects or DLLs) mismatches between the core dump machine and the debugger machine.\n+For this reason you should first consider using one of the following approaches to\n+debugging the core dump rather than transporting it to a different machine:\n+<ul>\n+  <li>Remote login to the machine that the core dump was produced on,\n+    and use <a href=\"clhsdb.html\">CLHSDB - SA command line HSDB interface<\/a>.\n+  <li>Use SA remote debugging support to remotely debug the core directly on the machine\n+    it was produced on. This is done by first running <b>jhsdb debugd<\/b> on the machine with\n+    the core dump, and then attaching to it from another machine by using the jhsdb\n+    <b>--connect<\/b> argument. See the <b>jhsdb<\/b> man page for details.\n+<\/ul>\n@@ -18,4 +28,6 @@\n-In most platforms, core dumps do not contain text (a.k.a) Code pages.\n-There pages are to be read from executable and shared objects (or DLLs).\n-Therefore it is important to have matching executable and shared object\n-files in debugger machine. \n+With transported core dumps, SA may produce an error message or throw\n+an exception (such as for a missing hotspot symbol) when opening the core dump.\n+Environment variable <b>LIBSAPROC_DEBUG<\/b> may be set to any value\n+to help debug the root casue of these failures. With <b>LIBSAPROC_DEBUG<\/b> set, SA prints many\n+messages in standard error which can be useful for further debugging. Note that\n+<b>LIBSAPROC_DEBUG<\/b> is not supported on Windows.\n@@ -24,2 +36,0 @@\n-<h3>Solaris transported core dumps<\/h3>\n-\n@@ -27,11 +37,11 @@\n-Debuggers on Solaris (and Linux) use two additional shared objects\n-<b>rtld_db.so<\/b> and <b>libthread_db.so<\/b>. rtld_db.so is used to\n-read information on shared objects from the core dump. libthread_db.so\n-is used to get information on threads from the core dump. rtld_db.so\n-evolves along with rtld.so (the runtime linker library) and libthread_db.so\n-evolves along with libthread.so (user land multithreading library). \n-Hence, debugger machine should have right version of rtld_db.so and\n-libthread_db.so to open the core dump successfully. More details on\n-these debugger libraries can be found in \n-<a href=\"http:\/\/docs.sun.com\/app\/docs\/doc\/817-1984\/\">\n-Solaris Linkers and Libraries Guide - 817-1984<\/a>\n+On most platforms, core dumps do not contain text (code) pages.\n+Their pages are instead read from the executable and shared objects (or DLLs).\n+Therefore it is important to have a matching java executable and shared object\n+files on the debugger machine. The best way to guarantee this match is to match the\n+debugger machine to that of core dump machine. This means having the same\n+OS version and libraries, and also having the same version of the JDK. It also means having\n+the OS libraries and JDK installed in the same locations on both machines. However, often\n+this isn't an option, and instead you need to copy the libraries and java installation from\n+the machine where the core dump was produced to the debugger machine, and you need\n+to tell SA where these are all located. That is done differently for each\n+OS type, and is described in the following sections.\n@@ -40,2 +50,1 @@\n-<h3>Solaris SA against transported core dumps<\/h3>\n-\n+<h3>Using transported core dumps on Linux<\/h3>\n@@ -43,9 +52,9 @@\n-With transported core dumps, you may get \"rtld_db failures\" or\n-\"libthread_db failures\" or SA may just throw some other error\n-(hotspot symbol is missing) when opening the core dump. \n-Environment variable <b>LIBSAPROC_DEBUG<\/b> may be set to any value\n-to debug such scenarios. With this env. var set, SA prints many\n-messages in standard error which can be useful for further debugging.\n-SA on Solaris uses <b>libproc.so<\/b> library. This library also\n-prints debug messages with env. var <b>LIBPROC_DEBUG<\/b>. But,\n-setting LIBSAPROC_DEBUG results in setting LIBPROC_DEBUG as well.\n+On Linux, SA parses core and shared library ELF files. But, you\n+may still face problems with transported core dumps, because matching shared\n+objects may not be in the path(s) specified in core dump file. To\n+workaround this, you can define environment variable <b>SA_ALTROOT<\/b>\n+to be the directory where shared libraries are kept. In this directory you should\n+copy all the needed JDK libraries, and any other user JNI libraries that were used.\n+You should also copy any referenced linux\n+libraries from the core dump machine, unless they are identical to what are\n+installed on the debugger machine.\n@@ -54,5 +63,5 @@\n-The best possible way to debug a transported core dump is to match the\n-debugger machine to that of core dump machine. i.e., have same Kernel\n-and libthread patch level between the machines. mdb (Solaris modular\n-debugger) may be used to find the Kernel patch level of core dump\n-machine and debugger machine may be brought to the same level.\n+ You can also use <b>SA_ALTROOT<\/b> to specify a path mapping. For example, if you\n+ set <b>SA_ALTROOT=\/altroot<\/b>, then <b>\/altroot<\/b> will be prepended to any path found\n+ in the core file, and also prepended to any subdir with the root part stripped off. For example,\n+ when looking up <b>\/usr\/lib\/libfoo.so<\/b>, SA will try to find <b>\/altroot\/usr\/lib\/libfoo.so<\/b>,\n+ <b>\/altroot\/lib\/libfoo.so<\/b>, and <b>\/altroot\/libfoo.so<\/b>.\n@@ -60,0 +69,2 @@\n+\n+<h3>Using transported core dumps on Windows<\/h3>\n@@ -61,5 +72,9 @@\n-If the matching machine is \"far off\" in your network, then\n-<ul>\n-<li>consider using rlogin and <a href=\"clhsdb.html\">CLHSDB - SA command line HSDB interface<\/a> or\n-<li>use SA remote debugging and debug the core from core machine remotely.\n-<\/ul>\n+ If the debugger machine and core dump machine have identical Windows libraries, then you only\n+ need to point SA to the location of the JDK <b>java.exe<\/b> and libraries. This is done by making\n+ sure the <b>bin<\/b> and <b>bin\/server<\/b> directories are included in the <b>PATH<\/b>\n+ environment variable. Something like the following should work if <b>JAVA_HOME<\/b>\n+ is setup:\n+ <\/p>\n+\n+<p>\n+ set PATH=%JAVA_HOME%\\bin;%JAVA_HOME%\\bin\\server;%PATH%\n@@ -69,8 +84,3 @@\n-But, it may not be feasible to find matching machine to debug. \n-If so, you can copy all application shared objects (and libthread_db.so, if needed) from the core dump \n-machine into your debugger machine's directory, say, \/export\/applibs. Now, set <b>SA_ALTROOT<\/b> \n-environment variable to point to \/export\/applibs directory. Note that \/export\/applibs should either \n-contain matching 'full path' of libraries. i.e., \/usr\/lib\/libthread_db.so from core \n-machine should be under \/export\/applibs\/use\/lib directory and \/use\/java\/jre\/lib\/sparc\/client\/libjvm.so \n-from core machine should be under \/export\/applibs\/use\/java\/jre\/lib\/sparc\/client so on or \/export\/applibs \n-should just contain libthread_db.so, libjvm.so etc. directly. \n+You can also include user JNI libraries in <b>PATH<\/b>.\n+If the windows libraries are not identical, then they may also need to be copied\n+to the debugger machine and included in <b>PATH<\/b>.\n@@ -79,0 +89,1 @@\n+<h3>Using transported core dumps on macOS<\/h3>\n@@ -80,5 +91,5 @@\n-Support for transported core dumps is <b>not<\/b> built into the standard version of libproc.so. You need to\n-set <b>LD_LIBRARY_PATH<\/b> env var to point to the path of a specially built version of libproc.so. \n-Note that this version of libproc.so has a special symbol to support transported core dump debugging. \n-In future, we may get this feature built into standard libproc.so -- if that happens, this step (of \n-setting LD_LIBRARY_PATH) can be skipped.\n+ SA normally uses the path to the specified java executable to locate the JDK libraries. It will look\n+ in the following subdirectories for them (relative to the path to the specified java executable):\n+ <b>..\/lib<\/b>, <b>..\/lib\/server<\/b>, <b>..\/jre\/lib<\/b>, and <b>..\/jre\/lib\/server<\/b>. If not found\n+ in any of those locations, it will look in the same subdirectories relative to the <b>JAVA_HOME<\/b>\n+ environment variable, but using <b>JAVA_HOME<\/b> normally should not be necessary.\n@@ -87,1 +98,0 @@\n-<h3>Ignoring libthread_db.so failures<\/h3>\n@@ -89,5 +99,4 @@\n-If you are okay with missing thread related information, you can set \n-<b>SA_IGNORE_THREADDB<\/b> environment variable to any value. With this\n-set, SA ignores libthread_db failure, but you won't be able to get any\n-thread related information. But, you would be able to use SA and get\n-other information.\n+ For locating the user JNI libraries, SA uses <b>DYLD_LIBRARY_PATH<\/b>. It can contain\n+ more than one directory separated by a colon. <b>DYLD_LIBRARY_PATH<\/b> can also be\n+ used for locating the JDK libraries, but it needs to specify the full path to the libraries. SA will\n+ not automatically search subdirs such as <b>lib\/server<\/b> as it does for <b>JAVA_HOME<\/b>.\n@@ -96,1 +105,0 @@\n-<h3>Linux SA against transported core dumps<\/h3>\n@@ -98,8 +106,7 @@\n-On Linux, SA parses core and shared library ELF files. SA <b>does not<\/b> use\n-libthread_db.so or rtld_db.so for core dump debugging (although \n-libthread_db.so is used for live process debugging). But, you\n-may still face problems with transported core dumps, because matching shared\n-objects may not be in the path(s) specified in core dump file. To\n-workaround this, you can define environment variable <b>SA_ALTROOT<\/b>\n-to be the directory where shared libraries are kept. The semantics of\n-this env. variable is same as that for Solaris (please refer above).\n+ For locating the macOS libraries, SA uses <b>SA_ALTROOT<\/b> similar to the linux support,\n+ except it does not use it to map all the subdirs. It just appends <b>SA_ALTROOT<\/b> to the\n+ full path of each macOS library. So if you specify <b>SA_ALTROOT=\/altroot<\/b>, SA will\n+ prepend <b>\/altroot<\/b> to the full path of each macOS library. Note however, due to\n+ <a href=\"https:\/\/bugs.openjdk.org\/browse\/JDK-8249779\">JDK-8249779<\/a> , SA will not\n+ even try to open macOS libraries, so at the moment there is no need to try to match up the\n+ macOS libraries by pointing to them with <b>SA_ALTROOT<\/b>.\n@@ -108,0 +115,4 @@\n+<p>\n+ Note: Starting with macOS 12, core files are no longer working with macOS on the x64 platform.\n+ See <a href=\"https:\/\/bugs.openjdk.org\/browse\/JDK-8294316\">JDK-8294316<\/a>.\n+<\/p>\n","filename":"src\/jdk.hotspot.agent\/doc\/transported_core.html","additions":79,"deletions":68,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-    private FilenameFilter oldtmpFileFilter;\n@@ -56,1 +55,1 @@\n-        \/\/ 1.4.2 and later: The files are in {tmpdir}\/hsperfdata_{any_user_name}\/[0-9]+\n+        \/\/ The files are in {tmpdir}\/hsperfdata_{any_user_name}\/[0-9]+\n@@ -70,9 +69,0 @@\n-\n-        \/\/ 1.4.1 (or earlier?): the files are stored directly under {tmpdir}\/ with\n-        \/\/ the following pattern.\n-        Pattern oldtmpFilePattern = Pattern.compile(PerfDataFile.tmpFileNamePattern);\n-        oldtmpFileFilter = new FilenameFilter() {\n-            public boolean accept(File dir, String name) {\n-                return oldtmpFilePattern.matcher(name).matches();\n-            }\n-        };\n@@ -103,1 +93,1 @@\n-            \/\/ 1.4.2 and later: Look for the files {tmpdir}\/hsperfdata_{any_user_name}\/[0-9]+\n+            \/\/ Look for the files {tmpdir}\/hsperfdata_{any_user_name}\/[0-9]+\n@@ -124,14 +114,0 @@\n-\n-            \/\/ look for any 1.4.1 files that are readable by the current user.\n-            File[] files = tmpdir.listFiles(oldtmpFileFilter);\n-            if (files != null) {\n-                for (File file : files) {\n-                    if (file.isFile() && file.canRead()) {\n-                        int vmid = PerfDataFile.getLocalVmId(file);\n-                        if (vmid != -1) {\n-                            jvmSet.add(vmid);\n-                        }\n-                    }\n-                }\n-            }\n-\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/local\/LocalVmManager.java","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-            \/\/ Try 1.4.2 and later first\n@@ -67,24 +66,0 @@\n-\n-        } catch (IllegalArgumentException e) {\n-            \/\/ now try 1.4.1 by attempting to directly map the files.\n-            try {\n-                String filename = PerfDataFile.getTempDirectory()\n-                                  + PerfDataFile.dirNamePrefix\n-                                  + Integer.toString(vmid.getLocalVmId());\n-\n-                File f = new File(filename);\n-\n-                FileChannel fc = new RandomAccessFile(f, \"r\").getChannel();\n-                ByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0L,\n-                                       (int)fc.size());\n-                fc.close();\n-                createPerfDataBuffer(bb, vmid.getLocalVmId());\n-\n-            } catch (FileNotFoundException e2) {\n-                \/\/ re-throw the exception from the 1.4.2 attach method\n-                throw new MonitorException(vmid.getLocalVmId() + \" not found\",\n-                                           e);\n-            } catch (IOException e2) {\n-                throw new MonitorException(\"Could not map 1.4.1 file for \"\n-                                           + vmid.getLocalVmId(), e2);\n-            }\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/local\/PerfDataBuffer.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,2 @@\n-     * used by the 1.4.2 and later HotSpot JVM.\n+     * used by the 1.4.2 and later HotSpot JVM. Earlier versions are\n+     * no longer supported.\n@@ -71,10 +72,0 @@\n-    \/**\n-     * The file name pattern for 1.4.1 PerfData shared memory files.\n-     * <p>\n-     * This pattern must be kept in synch with the file name pattern\n-     * used by the 1.4.1 HotSpot JVM.\n-     *\/\n-    public static final String tmpFileNamePattern =\n-            \"^hsperfdata_[0-9]+(_[1-2]+)?$\";\n-\n-\n@@ -100,1 +91,0 @@\n-            \/\/ try 1.4.2 and later format first\n@@ -104,14 +94,1 @@\n-        \/\/ now try the 1.4.1 format\n-        String name = file.getName();\n-        if (name.startsWith(dirNamePrefix)) {\n-            int first = name.indexOf('_');\n-            int last = name.lastIndexOf('_');\n-            try {\n-                if (first == last) {\n-                    return Integer.parseInt(name.substring(first + 1));\n-                } else {\n-                    return Integer.parseInt(name.substring(first + 1, last));\n-                }\n-            } catch (NumberFormatException e) { }\n-        }\n-        throw new IllegalArgumentException(\"file name does not match pattern\");\n+        throw new IllegalArgumentException(\"Cannot convert '\" + file + \"' to VM id\");\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/local\/PerfDataFile.java","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+        F16C,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.amd64\/src\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import jdk.jfr.internal.EventInstrumentation.SettingInfo;\n@@ -69,1 +68,1 @@\n-    private final ArrayList<SettingInfo> settingInfos = new ArrayList<>();\n+    private final ArrayList<SettingControl> settingControls = new ArrayList<>();\n@@ -166,1 +165,0 @@\n-            int index = settingInfos.size();\n@@ -183,1 +181,1 @@\n-                settingInfos.add(new SettingInfo(FIELD_SETTING_PREFIX + index, index, null, null, settingControl));\n+                settingControls.add(settingControl);\n@@ -311,2 +309,9 @@\n-    public List<SettingInfo> getSettingInfos() {\n-        return settingInfos;\n+    \/**\n+     * A malicious user must never be able to run a callback in the wrong\n+     * context. Methods on SettingControl must therefore never be invoked directly\n+     * by JFR, instead use jdk.jfr.internal.Control.\n+     *\n+     * The returned list is only to be used inside EventConfiguration\n+     *\/\n+    public List<SettingControl> getSettingControls() {\n+        return settingControls;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -63,9 +63,1 @@\n-    record SettingInfo(String fieldName, int index, Type paramType, String methodName, SettingControl settingControl) {\n-        \/**\n-         * A malicious user must never be able to run a callback in the wrong\n-         * context. Methods on SettingControl must therefore never be invoked directly\n-         * by JFR, instead use jdk.jfr.internal.Control.\n-         *\/\n-        public SettingControl settingControl() {\n-            return this.settingControl;\n-        }\n+    record SettingInfo(Type paramType, String methodName) {\n@@ -74,1 +66,1 @@\n-    record FieldInfo(String fieldName, String fieldDescriptor, String internalClassName) {\n+    record FieldInfo(String name, String descriptor) {\n@@ -139,2 +131,2 @@\n-        for (FieldInfo v : fields) {\n-            sb.append(v.fieldDescriptor);\n+        for (FieldInfo field : fields) {\n+            sb.append(field.descriptor);\n@@ -247,2 +239,0 @@\n-                                String fieldName = EventControl.FIELD_SETTING_PREFIX + settingInfos.size();\n-                                int index = settingInfos.size();\n@@ -250,1 +240,1 @@\n-                                settingInfos.add(new SettingInfo(fieldName, index, paramType, m.name, null));\n+                                settingInfos.add(new SettingInfo(paramType, m.name));\n@@ -266,2 +256,0 @@\n-                                String fieldName = EventControl.FIELD_SETTING_PREFIX + settingInfos.size();\n-                                int index = settingInfos.size();\n@@ -269,1 +257,1 @@\n-                                settingInfos.add(new SettingInfo(fieldName, index, paramType, method.getName(), null));\n+                                settingInfos.add(new SettingInfo(paramType, method.getName()));\n@@ -288,2 +276,2 @@\n-        fieldInfos.add(new FieldInfo(\"startTime\", Type.LONG_TYPE.getDescriptor(), classNode.name));\n-        fieldInfos.add(new FieldInfo(\"duration\", Type.LONG_TYPE.getDescriptor(), classNode.name));\n+        fieldInfos.add(new FieldInfo(\"startTime\", Type.LONG_TYPE.getDescriptor()));\n+        fieldInfos.add(new FieldInfo(\"duration\", Type.LONG_TYPE.getDescriptor()));\n@@ -292,1 +280,1 @@\n-                FieldInfo fi = new FieldInfo(field.name, field.desc, classNode.name);\n+                FieldInfo fi = new FieldInfo(field.name, field.desc);\n@@ -306,1 +294,1 @@\n-                            fieldInfos.add(new FieldInfo(fieldName, fieldType.getDescriptor(), internalClassName));\n+                            fieldInfos.add(new FieldInfo(fieldName, fieldType.getDescriptor()));\n@@ -577,1 +565,1 @@\n-                    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), field.fieldName, field.fieldDescriptor);\n+                    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), field.name, field.descriptor);\n@@ -636,2 +624,2 @@\n-            int index = 0;\n-            for (SettingInfo si : settingInfos) {\n+            for (int index = 0; index < settingInfos.size(); index++) {\n+                SettingInfo si = settingInfos.get(index);\n@@ -651,1 +639,0 @@\n-                index++;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    public static EventWriterMethod lookupMethod(FieldInfo v) {\n+    public static EventWriterMethod lookupMethod(FieldInfo field) {\n@@ -72,1 +72,1 @@\n-        if (v.fieldName().equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n+        if (field.name().equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n@@ -76,1 +76,1 @@\n-            if (v.fieldDescriptor().equals(m.typeDescriptor)) {\n+            if (field.descriptor().equals(m.typeDescriptor)) {\n@@ -80,1 +80,1 @@\n-        throw new Error(\"Unknown type \" + v.fieldDescriptor());\n+        throw new Error(\"Unknown type \" + field.descriptor());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterMethod.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-    private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec, SettingControl[] settings) {\n+    private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec) {\n@@ -194,1 +194,1 @@\n-                var argClasses = new Class<?>[] { EventType.class, EventControl.class, SettingControl[].class };\n+                var argClasses = new Class<?>[] { EventType.class, EventControl.class};\n@@ -199,1 +199,1 @@\n-            return cachedEventConfigurationConstructor.newInstance(eventType, ec, settings);\n+            return cachedEventConfigurationConstructor.newInstance(eventType, ec);\n@@ -212,7 +212,1 @@\n-        List<SettingInfo> settingInfos = ec.getSettingInfos();\n-        SettingControl[] settings = new SettingControl[settingInfos.size()];\n-        int index = 0;\n-        for (var settingInfo : settingInfos) {\n-            settings[index++] = settingInfo.settingControl();\n-        }\n-        EventConfiguration configuration = newEventConfiguration(eventType, ec, settings);\n+        EventConfiguration configuration = newEventConfiguration(eventType, ec);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -240,1 +240,5 @@\n-    public boolean isEveryChunk() {\n+    \/**\n+     * Returns true if \"beginChunk\", \"endChunk\" or \"everyChunk\" have\n+     * been set.\n+     *\/\n+    public boolean isChunkTime() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -43,0 +44,1 @@\n+    private static final ReentrantLock lock = new ReentrantLock();\n@@ -69,1 +71,1 @@\n-                        jvm.emitEvent(type.getId(), JVM.counterTime(), 0);\n+                        emitJVMEvent(type);\n@@ -83,0 +85,12 @@\n+        private void emitJVMEvent(PlatformEventType type) {\n+            try {\n+                \/\/ There should only be one thread in native at a time.\n+                \/\/ ReentrantLock is used to avoid JavaMonitorBlocked event\n+                \/\/ from synchronized block.\n+                lock.lock();\n+                jvm.emitEvent(type.getId(), JVM.counterTime(), 0);\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n@@ -224,1 +238,1 @@\n-            if (!es.isEnabled() || es.isEveryChunk()) {\n+            if (!es.isEnabled() || es.isChunkTime()) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RequestEngine.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -167,2 +167,12 @@\n-                } else if (finished) {\n-                    throw new IOException(\"No metadata event found in finished chunk.\");\n+                } else {\n+                    if (finished) {\n+                        throw new IOException(\"No metadata event found in finished chunk.\");\n+                    }\n+                    if (chunkSize == HEADER_SIZE) {\n+                        \/\/ This ensures that a non-streaming parser is able\n+                        \/\/ to break out of the loop in case the file is\n+                        \/\/ ended before the first metadata event has\n+                        \/\/ been written. This can happen during a failed crash\n+                        \/\/ dump.\n+                        input.pollWait();\n+                    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkHeader.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    private EventConfiguration(EventType eventType, EventControl eventControl, SettingControl[] settings) {\n+    private EventConfiguration(EventType eventType, EventControl eventControl) {\n@@ -47,1 +47,1 @@\n-        this.settings = settings;\n+        this.settings = eventControl.getSettingControls().toArray(new SettingControl[0]);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventConfiguration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -136,0 +141,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -176,0 +186,7 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     * @throws ExecutionControl.EngineTerminationException {@inheritDoc}\n+     * @throws ExecutionControl.NotImplementedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/DirectExecutionControl.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -119,0 +119,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/RemoteExecutionControl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -108,0 +113,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -154,0 +164,7 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     * @throws ExecutionControl.EngineTerminationException {@inheritDoc}\n+     * @throws ExecutionControl.NotImplementedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/StreamingExecutionControl.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,214 +0,0 @@\n-#\n-# Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n-# Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# The Universal Permissive License (UPL), Version 1.0\n-#\n-# Subject to the condition set forth below, permission is hereby granted to\n-# any person obtaining a copy of this software, associated documentation\n-# and\/or data (collectively the \"Software\"), free of charge and under any\n-# and all copyright rights in the Software, and any and all patent rights\n-# owned or freely licensable by each licensor hereunder covering either (i)\n-# the unmodified Software as contributed to or provided by such licensor,\n-# or (ii) the Larger Works (as defined below), to deal in both\n-#\n-# (a) the Software, and\n-#\n-# (b) any piece of software and\/or hardware listed in the lrgrwrks.txt file\n-# if one is included with the Software (each a \"Larger Work\" to which the\n-# Software is contributed by such licensors),\n-#\n-# without restriction, including without limitation the rights to copy,\n-# create derivative works of, display, perform, and distribute the Software\n-# and make, use, sell, offer for sale, import, export, have made, and have\n-# sold the Software and the Larger Work(s), and to sublicense the foregoing\n-# rights on either these or other terms.\n-#\n-# This license is subject to the following condition:\n-#\n-# The above copyright notice and either this complete permission notice or\n-# at a minimum a reference to the UPL must be included in all copies or\n-# substantial portions of the Software.\n-#\n-# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-# NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-# USE OR OTHER DEALINGS IN THE SOFTWARE.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-#\n-\n-# Single gnu makefile for linux and windows (windows requires cygwin and mingw)\n-\n-# Default arch; it is changed below as needed.\n-ARCH\t\t= i386\n-OS\t\t= $(shell uname)\n-AR\t\t= ar\n-\n-## OS = Linux ##\n-ifeq\t\t($(OS),Linux)\n-ifneq           ($(MINGW),)\n-LIB_EXT\t\t= .dll\n-CPPFLAGS += -I$(TARGET_DIR)\/include\n-LDFLAGS += -L$(TARGET_DIR)\/lib\n-OS=windows\n-ifneq           ($(findstring x86_64-,$(MINGW)),)\n-ARCH=amd64\n-else\n-ARCH=i386\n-endif\n-CC \t\t= $(MINGW)-gcc\n-CONFIGURE_ARGS= --host=$(MINGW) --target=$(MINGW)\n-else   #linux\n-CPU             = $(shell uname -m)\n-ARCH1=$(CPU:x86_64=amd64)\n-ARCH=$(ARCH1:i686=i386)\n-ifdef LP64\n-CFLAGS\/amd64\t+= -m64\n-CFLAGS\/ppc64\t+= -m64\n-CFLAGS\/ppc64le  += -m64 -DABI_ELFv2\n-else\n-ARCH=$(ARCH1:amd64=i386)\n-ifneq ($(findstring arm,$(ARCH)),)\n-ARCH=arm\n-endif\n-CFLAGS\/i386\t+= -m32\n-endif\n-CFLAGS\t\t+= $(CFLAGS\/$(ARCH))\n-CFLAGS\t\t+= -fPIC\n-OS\t\t= linux\n-LIB_EXT\t\t= .so\n-CC \t\t= gcc\n-endif\n-CFLAGS\t\t+= -O\n-DLDFLAGS\t+= -shared\n-LDFLAGS         += -ldl\n-OUTFLAGS\t+= -o $@\n-else\n-## OS = AIX ##\n-ifeq\t\t($(OS),AIX)\n-OS              = aix\n-ARCH            = ppc64\n-CC              = xlc_r\n-CFLAGS          += -DAIX -g -qpic=large -q64\n-CFLAGS\/ppc64    += -q64\n-AR              = ar -X64\n-DLDFLAGS        += -qmkshrobj -lz\n-OUTFLAGS        += -o $@\n-LIB_EXT\t\t= .so\n-else\n-## OS = Darwin ##\n-ifeq ($(OS),Darwin)\n-CPU             = $(shell uname -m)\n-ARCH1=$(CPU:x86_64=amd64)\n-ARCH2=$(ARCH1:arm64=aarch64)\n-ARCH=$(ARCH2:i686=i386)\n-CONFIGURE_ARGS\/aarch64= --enable-targets=aarch64-darwin\n-CONFIGURE_ARGS = $(CONFIGURE_ARGS\/$(ARCH))\n-ifdef LP64\n-CFLAGS\/amd64    += -m64\n-else\n-ARCH=$(ARCH2:amd64=i386)\n-CFLAGS\/i386     += -m32\n-endif # LP64\n-ifeq ($(CPU), arm64)\n-CFLAGS\/aarch64  += -m64\n-endif # arm64\n-CFLAGS          += $(CFLAGS\/$(ARCH))\n-CFLAGS          += -fPIC\n-OS              = macosx\n-LIB_EXT         = .dylib\n-CC              = gcc\n-CFLAGS          += -O\n-# CFLAGS        += -DZ_PREFIX\n-DLDFLAGS        += -shared\n-DLDFLAGS        += -lz\n-LDFLAGS         += -ldl\n-OUTFLAGS        += -o $@\n-else\n-## OS = Windows ##\n-OS\t\t= windows\n-CC\t\t= gcc\n-CFLAGS\t\t+=  \/nologo \/MD \/W3 \/WX \/O2 \/Fo$(@:.dll=.obj) \/Gi-\n-CFLAGS\t\t+= LIBARCH=\\\"$(LIBARCH)\\\"\n-DLDFLAGS\t+= \/dll \/subsystem:windows \/incremental:no \\\n-\t\t\t\/export:decode_instruction\n-OUTFLAGS\t+= \/link \/out:$@\n-LIB_EXT\t\t= .dll\n-endif   # Darwin\n-endif   # AIX\n-endif\t# Linux\n-\n-LIBARCH\t\t= $(ARCH)\n-ifdef\t\tLP64\n-LIBARCH64\/i386\t= amd64\n-LIBARCH64\t= $(LIBARCH64\/$(ARCH))\n-ifneq\t\t($(LIBARCH64),)\n-LIBARCH\t\t= $(LIBARCH64)\n-endif   # LIBARCH64\/$(ARCH)\n-endif   # LP64\n-\n-JDKARCH=$(LIBARCH:i386=i586)\n-\n-ifeq            ($(BINUTILS),)\n-# Pop all the way out of the workspace to look for binutils.\n-# ...You probably want to override this setting.\n-BINUTILSDIR\t= $(shell cd build\/binutils;pwd)\n-else\n-BINUTILSDIR\t= $(shell cd $(BINUTILS);pwd)\n-endif\n-\n-CPPFLAGS\t+= -I$(BINUTILSDIR)\/include -I$(BINUTILSDIR)\/bfd -I$(TARGET_DIR)\/bfd\n-CPPFLAGS\t+= -DLIBARCH_$(LIBARCH) -DLIBARCH=\\\"$(LIBARCH)\\\" -DLIB_EXT=\\\"$(LIB_EXT)\\\"\n-\n-TARGET_DIR\t= build\/$(OS)-$(JDKARCH)\n-TARGET\t\t= $(TARGET_DIR)\/hsdis-$(LIBARCH)$(LIB_EXT)\n-\n-SOURCE\t\t= hsdis.c\n-\n-LIBRARIES =\t$(TARGET_DIR)\/bfd\/libbfd.a \\\n-\t\t$(TARGET_DIR)\/opcodes\/libopcodes.a \\\n-\t\t$(TARGET_DIR)\/libiberty\/libiberty.a\n-\n-ifneq ($(MINGW),)\n-LIBRARIES +=\t$(TARGET_DIR)\/zlib\/libz.a\n-endif\n-\n-DEMO_TARGET\t= $(TARGET_DIR)\/hsdis-demo\n-DEMO_SOURCE\t= hsdis-demo.c\n-\n-.PHONY:  all clean demo both\n-\n-all:  $(TARGET)\n-\n-both: all all64\n-\n-%64:\n-\t$(MAKE) LP64=1 ${@:%64=%}\n-\n-demo: $(TARGET) $(DEMO_TARGET)\n-\n-$(LIBRARIES): $(TARGET_DIR) $(TARGET_DIR)\/Makefile\n-\tif [ ! -f $@ ]; then cd $(TARGET_DIR); make all-opcodes; fi\n-\n-$(TARGET_DIR)\/Makefile:\n-\t(cd $(TARGET_DIR); CC=$(CC) CFLAGS=\"$(CFLAGS)\" AR=\"$(AR)\" $(BINUTILSDIR)\/configure --disable-nls $(CONFIGURE_ARGS))\n-\n-$(TARGET): $(SOURCE) $(LIBS) $(LIBRARIES) $(TARGET_DIR)\n-\t$(CC) $(OUTFLAGS) $(CPPFLAGS) $(CFLAGS) $(SOURCE) $(DLDFLAGS) $(LIBRARIES)\n-\n-$(DEMO_TARGET): $(DEMO_SOURCE) $(TARGET) $(TARGET_DIR)\n-\t$(CC) $(OUTFLAGS) -DTARGET_DIR=\\\"$(TARGET_DIR)\\\" $(CPPFLAGS) -g $(CFLAGS\/$(ARCH)) $(DEMO_SOURCE) $(LDFLAGS)\n-\n-$(TARGET_DIR):\n-\t[ -d $@ ] || mkdir -p $@\n-\n-clean:\n-\trm -rf $(TARGET_DIR)\n","filename":"src\/utils\/hsdis\/Makefile","additions":0,"deletions":214,"binary":false,"changes":214,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,0 +175,2 @@\n+  OopStorage* _storage;\n+\n@@ -179,1 +181,1 @@\n-  OopStorage _storage;\n+  OopStorage& storage() const { return *_storage; }\n@@ -186,1 +188,1 @@\n-  _storage(\"Test Storage\", mtGC)\n+  _storage(OopStorage::create(\"Test Storage\", mtGC))\n@@ -190,1 +192,2 @@\n-  clear_list(TestAccess::allocation_list(_storage));\n+  clear_list(TestAccess::allocation_list(storage()));\n+  delete _storage;\n@@ -203,1 +206,1 @@\n-    _entries[i] = _storage.allocate();\n+    _entries[i] = storage().allocate();\n@@ -205,1 +208,1 @@\n-    EXPECT_EQ(i + 1, _storage.allocation_count());\n+    EXPECT_EQ(i + 1, storage().allocation_count());\n@@ -236,2 +239,2 @@\n-  EXPECT_EQ(0u, active_count(_storage));\n-  EXPECT_TRUE(is_list_empty(TestAccess::allocation_list(_storage)));\n+  EXPECT_EQ(0u, active_count(storage()));\n+  EXPECT_TRUE(is_list_empty(TestAccess::allocation_list(storage())));\n@@ -239,1 +242,1 @@\n-  oop* ptr = _storage.allocate();\n+  oop* ptr = storage().allocate();\n@@ -241,1 +244,1 @@\n-  EXPECT_EQ(1u, _storage.allocation_count());\n+  EXPECT_EQ(1u, storage().allocation_count());\n@@ -243,3 +246,3 @@\n-  EXPECT_EQ(1u, active_count(_storage));\n-  EXPECT_EQ(1u, _storage.block_count());\n-  EXPECT_EQ(1u, list_length(TestAccess::allocation_list(_storage)));\n+  EXPECT_EQ(1u, active_count(storage()));\n+  EXPECT_EQ(1u, storage().block_count());\n+  EXPECT_EQ(1u, list_length(TestAccess::allocation_list(storage())));\n@@ -247,1 +250,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -249,1 +252,1 @@\n-  const OopBlock* block = TestAccess::allocation_list(_storage).chead();\n+  const OopBlock* block = TestAccess::allocation_list(storage()).chead();\n@@ -251,1 +254,1 @@\n-  EXPECT_EQ(block, active_head(_storage));\n+  EXPECT_EQ(block, active_head(storage()));\n@@ -256,2 +259,2 @@\n-  release_entry(_storage, ptr);\n-  EXPECT_EQ(0u, _storage.allocation_count());\n+  release_entry(storage(), ptr);\n+  EXPECT_EQ(0u, storage().allocation_count());\n@@ -259,3 +262,3 @@\n-  EXPECT_EQ(1u, active_count(_storage));\n-  EXPECT_EQ(1u, _storage.block_count());\n-  EXPECT_EQ(1u, list_length(TestAccess::allocation_list(_storage)));\n+  EXPECT_EQ(1u, active_count(storage()));\n+  EXPECT_EQ(1u, storage().block_count());\n+  EXPECT_EQ(1u, list_length(TestAccess::allocation_list(storage())));\n@@ -263,1 +266,1 @@\n-  EXPECT_EQ(1u, empty_block_count(_storage));\n+  EXPECT_EQ(1u, empty_block_count(storage()));\n@@ -265,1 +268,1 @@\n-  const OopBlock* new_block = TestAccess::allocation_list(_storage).chead();\n+  const OopBlock* new_block = TestAccess::allocation_list(storage()).chead();\n@@ -267,1 +270,1 @@\n-  EXPECT_EQ(block, active_head(_storage));\n+  EXPECT_EQ(block, active_head(storage()));\n@@ -277,1 +280,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -279,2 +282,2 @@\n-  EXPECT_EQ(0u, active_count(_storage));\n-  EXPECT_EQ(0u, _storage.block_count());\n+  EXPECT_EQ(0u, active_count(storage()));\n+  EXPECT_EQ(0u, storage().block_count());\n@@ -285,5 +288,5 @@\n-    EXPECT_EQ(allocated, _storage.allocation_count());\n-    if (active_count(_storage) != 0) {\n-      EXPECT_EQ(1u, active_count(_storage));\n-      EXPECT_EQ(1u, _storage.block_count());\n-      const OopBlock& block = *TestAccess::active_array(_storage).at(0);\n+    EXPECT_EQ(allocated, storage().allocation_count());\n+    if (active_count(storage()) != 0) {\n+      EXPECT_EQ(1u, active_count(storage()));\n+      EXPECT_EQ(1u, storage().block_count());\n+      const OopBlock& block = *TestAccess::active_array(storage()).at(0);\n@@ -298,1 +301,1 @@\n-    entries[allocated] = _storage.allocate();\n+    entries[allocated] = storage().allocate();\n@@ -301,3 +304,3 @@\n-  EXPECT_EQ(allocated, _storage.allocation_count());\n-  EXPECT_EQ(1u, active_count(_storage));\n-  EXPECT_EQ(1u, _storage.block_count());\n+  EXPECT_EQ(allocated, storage().allocation_count());\n+  EXPECT_EQ(1u, active_count(storage()));\n+  EXPECT_EQ(1u, storage().block_count());\n@@ -305,1 +308,1 @@\n-  const OopBlock& block = *TestAccess::active_array(_storage).at(0);\n+  const OopBlock& block = *TestAccess::active_array(storage()).at(0);\n@@ -310,1 +313,1 @@\n-    release_entry(_storage, entries[i]);\n+    release_entry(storage(), entries[i]);\n@@ -313,1 +316,1 @@\n-    EXPECT_EQ(remaining, _storage.allocation_count());\n+    EXPECT_EQ(remaining, storage().allocation_count());\n@@ -322,1 +325,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -324,1 +327,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -326,1 +329,1 @@\n-  entries[0] = _storage.allocate();\n+  entries[0] = storage().allocate();\n@@ -328,2 +331,2 @@\n-  EXPECT_EQ(1u, active_count(_storage));\n-  EXPECT_EQ(1u, _storage.block_count());\n+  EXPECT_EQ(1u, active_count(storage()));\n+  EXPECT_EQ(1u, storage().block_count());\n@@ -331,1 +334,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -333,1 +336,1 @@\n-  const OopBlock* block = TestAccess::active_array(_storage).at(0);\n+  const OopBlock* block = TestAccess::active_array(storage()).at(0);\n@@ -338,2 +341,2 @@\n-    entries[i] = _storage.allocate();\n-    EXPECT_EQ(i + 1, _storage.allocation_count());\n+    entries[i] = storage().allocate();\n+    EXPECT_EQ(i + 1, storage().allocation_count());\n@@ -341,1 +344,1 @@\n-    EXPECT_EQ(0u, empty_block_count(_storage));\n+    EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -348,1 +351,1 @@\n-      EXPECT_EQ(block, active_head(_storage));\n+      EXPECT_EQ(block, active_head(storage()));\n@@ -355,1 +358,1 @@\n-      EXPECT_EQ(block, active_head(_storage));\n+      EXPECT_EQ(block, active_head(storage()));\n@@ -363,1 +366,1 @@\n-    EXPECT_EQ(block, active_head(_storage));\n+    EXPECT_EQ(block, active_head(storage()));\n@@ -367,3 +370,3 @@\n-    release_entry(_storage, entries[i]);\n-    EXPECT_TRUE(is_allocation_list_sorted(_storage));\n-    EXPECT_EQ(max_entries - (i + 1), total_allocation_count(_storage));\n+    release_entry(storage(), entries[i]);\n+    EXPECT_TRUE(is_allocation_list_sorted(storage()));\n+    EXPECT_EQ(max_entries - (i + 1), total_allocation_count(storage()));\n@@ -372,3 +375,3 @@\n-  EXPECT_EQ(active_count(_storage), list_length(allocation_list));\n-  EXPECT_EQ(active_count(_storage), _storage.block_count());\n-  EXPECT_EQ(active_count(_storage), empty_block_count(_storage));\n+  EXPECT_EQ(active_count(storage()), list_length(allocation_list));\n+  EXPECT_EQ(active_count(storage()), storage().block_count());\n+  EXPECT_EQ(active_count(storage()), empty_block_count(storage()));\n@@ -386,1 +389,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -388,1 +391,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -390,1 +393,1 @@\n-  EXPECT_EQ(_max_entries, total_allocation_count(_storage));\n+  EXPECT_EQ(_max_entries, total_allocation_count(storage()));\n@@ -397,1 +400,1 @@\n-      release_entry(_storage, _entries[i]);\n+      release_entry(storage(), _entries[i]);\n@@ -400,2 +403,2 @@\n-      EXPECT_EQ(_max_entries - released, total_allocation_count(_storage));\n-      EXPECT_TRUE(is_allocation_list_sorted(_storage));\n+      EXPECT_EQ(_max_entries - released, total_allocation_count(storage()));\n+      EXPECT_TRUE(is_allocation_list_sorted(storage()));\n@@ -405,4 +408,4 @@\n-  EXPECT_EQ(active_count(_storage), list_length(allocation_list));\n-  EXPECT_EQ(active_count(_storage), _storage.block_count());\n-  EXPECT_EQ(0u, total_allocation_count(_storage));\n-  EXPECT_EQ(list_length(allocation_list), empty_block_count(_storage));\n+  EXPECT_EQ(active_count(storage()), list_length(allocation_list));\n+  EXPECT_EQ(active_count(storage()), storage().block_count());\n+  EXPECT_EQ(0u, total_allocation_count(storage()));\n+  EXPECT_EQ(list_length(allocation_list), empty_block_count(storage()));\n@@ -416,1 +419,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -418,1 +421,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -420,1 +423,1 @@\n-  EXPECT_EQ(_max_entries, total_allocation_count(_storage));\n+  EXPECT_EQ(_max_entries, total_allocation_count(storage()));\n@@ -429,1 +432,1 @@\n-      release_entry(_storage, _entries[i]);\n+      release_entry(storage(), _entries[i]);\n@@ -433,2 +436,2 @@\n-      EXPECT_EQ(_max_entries - released, total_allocation_count(_storage));\n-      EXPECT_TRUE(is_allocation_list_sorted(_storage));\n+      EXPECT_EQ(_max_entries - released, total_allocation_count(storage()));\n+      EXPECT_TRUE(is_allocation_list_sorted(storage()));\n@@ -436,1 +439,1 @@\n-        _entries[i] = _storage.allocate();\n+        _entries[i] = storage().allocate();\n@@ -438,2 +441,2 @@\n-        EXPECT_EQ(_max_entries - released, total_allocation_count(_storage));\n-        EXPECT_TRUE(is_allocation_list_sorted(_storage));\n+        EXPECT_EQ(_max_entries - released, total_allocation_count(storage()));\n+        EXPECT_TRUE(is_allocation_list_sorted(storage()));\n@@ -444,4 +447,4 @@\n-  EXPECT_EQ(active_count(_storage), list_length(allocation_list));\n-  EXPECT_EQ(active_count(_storage), _storage.block_count());\n-  EXPECT_EQ(0u, total_allocation_count(_storage));\n-  EXPECT_EQ(list_length(allocation_list), empty_block_count(_storage));\n+  EXPECT_EQ(active_count(storage()), list_length(allocation_list));\n+  EXPECT_EQ(active_count(storage()), storage().block_count());\n+  EXPECT_EQ(0u, total_allocation_count(storage()));\n+  EXPECT_EQ(list_length(allocation_list), empty_block_count(storage()));\n@@ -465,2 +468,2 @@\n-    _storage.release(to_release, nrelease);\n-    EXPECT_EQ(_max_entries - nrelease, _storage.allocation_count());\n+    storage().release(to_release, nrelease);\n+    EXPECT_EQ(_max_entries - nrelease, storage().allocation_count());\n@@ -469,2 +472,2 @@\n-      release_entry(_storage, _entries[2 * i + 1], false);\n-      EXPECT_EQ(_max_entries - nrelease - (i + 1), _storage.allocation_count());\n+      release_entry(storage(), _entries[2 * i + 1], false);\n+      EXPECT_EQ(_max_entries - nrelease - (i + 1), storage().allocation_count());\n@@ -472,1 +475,1 @@\n-    EXPECT_TRUE(process_deferred_updates(_storage));\n+    EXPECT_TRUE(process_deferred_updates(storage()));\n@@ -474,1 +477,1 @@\n-    EXPECT_EQ(_storage.block_count(), empty_block_count(_storage));\n+    EXPECT_EQ(storage().block_count(), empty_block_count(storage()));\n@@ -497,1 +500,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -499,2 +502,2 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n-  size_t allocated = _storage.allocate(entries, max_entries);\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n+  size_t allocated = storage().allocate(entries, max_entries);\n@@ -507,1 +510,1 @@\n-    EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(entries[i]));\n+    EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, storage().allocation_status(entries[i]));\n@@ -512,2 +515,2 @@\n-  _storage.release(entries, allocated);\n-  EXPECT_EQ(0u, _storage.allocation_count());\n+  storage().release(entries, allocated);\n+  EXPECT_EQ(0u, storage().allocation_count());\n@@ -515,1 +518,1 @@\n-    EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, _storage.allocation_status(entries[i]));\n+    EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, storage().allocation_status(entries[i]));\n@@ -525,1 +528,1 @@\n-    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(ptr));\n+    EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(ptr));\n@@ -533,1 +536,1 @@\n-    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(ptr));\n+    EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(ptr));\n@@ -597,1 +600,1 @@\n-      entries[allocated] = _storage.allocate();\n+      entries[allocated] = storage().allocate();\n@@ -607,1 +610,1 @@\n-      VM_CountAtSafepoint<false> op(&_storage, &cl);\n+      VM_CountAtSafepoint<false> op(&storage(), &cl);\n@@ -620,1 +623,1 @@\n-      VM_CountAtSafepoint<true> op(&_storage, &cl);\n+      VM_CountAtSafepoint<true> op(&storage(), &cl);\n@@ -633,1 +636,1 @@\n-    release_entry(_storage, entries[--allocated], false);\n+    release_entry(storage(), entries[--allocated], false);\n@@ -635,1 +638,1 @@\n-  process_deferred_updates(_storage);\n+  process_deferred_updates(storage());\n@@ -654,1 +657,1 @@\n-    for ( ; empty_block_count(_storage) < 2; ++initial_release) {\n+    for ( ; empty_block_count(storage()) < 2; ++initial_release) {\n@@ -656,1 +659,1 @@\n-      release_entry(_storage, _entries[initial_release]);\n+      release_entry(storage(), _entries[initial_release]);\n@@ -661,1 +664,1 @@\n-      release_entry(_storage, _entries[i], false);\n+      release_entry(storage(), _entries[i], false);\n@@ -664,1 +667,1 @@\n-    process_deferred_updates(_storage);\n+    process_deferred_updates(storage());\n@@ -834,1 +837,1 @@\n-  VM_Verify<false> op(&_storage, &vstate);\n+  VM_Verify<false> op(&storage(), &vstate);\n@@ -845,1 +848,1 @@\n-  VM_Verify<true> op(&_storage, &vstate);\n+  VM_Verify<true> op(&storage(), &vstate);\n@@ -856,1 +859,1 @@\n-  VM_VerifyUsingOopsDo op(&_storage, &vstate);\n+  VM_VerifyUsingOopsDo op(&storage(), &vstate);\n@@ -949,1 +952,1 @@\n-  Task<false, false> task(\"test\", &_storage, &vstate);\n+  Task<false, false> task(\"test\", &storage(), &vstate);\n@@ -960,1 +963,1 @@\n-  Task<false, true> task(\"test\", &_storage, &vstate);\n+  Task<false, true> task(\"test\", &storage(), &vstate);\n@@ -971,1 +974,1 @@\n-  TaskUsingOopsDo<false, false> task(\"test\", &_storage, &vstate);\n+  TaskUsingOopsDo<false, false> task(\"test\", &storage(), &vstate);\n@@ -982,1 +985,1 @@\n-  TaskUsingOopsDo<false, true> task(\"test\", &_storage, &vstate);\n+  TaskUsingOopsDo<false, true> task(\"test\", &storage(), &vstate);\n@@ -993,1 +996,1 @@\n-  Task<true, false> task(\"test\", &_storage, &vstate);\n+  Task<true, false> task(\"test\", &storage(), &vstate);\n@@ -1000,1 +1003,1 @@\n-  Task<true, true> task(\"test\", &_storage, &vstate);\n+  Task<true, true> task(\"test\", &storage(), &vstate);\n@@ -1007,1 +1010,1 @@\n-  TaskUsingOopsDo<true, false> task(\"test\", &_storage, &vstate);\n+  TaskUsingOopsDo<true, false> task(\"test\", &storage(), &vstate);\n@@ -1014,1 +1017,1 @@\n-  TaskUsingOopsDo<true, true> task(\"test\", &_storage, &vstate);\n+  TaskUsingOopsDo<true, true> task(\"test\", &storage(), &vstate);\n@@ -1020,2 +1023,2 @@\n-  size_t initial_active_size = active_count(_storage);\n-  EXPECT_EQ(initial_active_size, _storage.block_count());\n+  size_t initial_active_size = active_count(storage());\n+  EXPECT_EQ(initial_active_size, storage().block_count());\n@@ -1024,1 +1027,1 @@\n-  for (size_t i = 0; empty_block_count(_storage) < 3; ++i) {\n+  for (size_t i = 0; empty_block_count(storage()) < 3; ++i) {\n@@ -1026,1 +1029,1 @@\n-    release_entry(_storage, _entries[i]);\n+    release_entry(storage(), _entries[i]);\n@@ -1029,3 +1032,3 @@\n-  EXPECT_EQ(initial_active_size, active_count(_storage));\n-  EXPECT_EQ(initial_active_size, _storage.block_count());\n-  EXPECT_EQ(3u, empty_block_count(_storage));\n+  EXPECT_EQ(initial_active_size, active_count(storage()));\n+  EXPECT_EQ(initial_active_size, storage().block_count());\n+  EXPECT_EQ(3u, empty_block_count(storage()));\n@@ -1034,1 +1037,1 @@\n-    while (_storage.delete_empty_blocks()) {}\n+    while (storage().delete_empty_blocks()) {}\n@@ -1036,3 +1039,3 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n-  EXPECT_EQ(initial_active_size - 3, active_count(_storage));\n-  EXPECT_EQ(initial_active_size - 3, _storage.block_count());\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n+  EXPECT_EQ(initial_active_size - 3, active_count(storage()));\n+  EXPECT_EQ(initial_active_size - 3, storage().block_count());\n@@ -1045,1 +1048,1 @@\n-  release_entry(_storage, released);\n+  release_entry(storage(), released);\n@@ -1047,3 +1050,3 @@\n-  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));\n-  EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, _storage.allocation_status(released));\n-  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));\n+  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, storage().allocation_status(retained));\n+  EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, storage().allocation_status(released));\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(garbage));\n@@ -1054,1 +1057,1 @@\n-      release_entry(_storage, _entries[i], false);\n+      release_entry(storage(), _entries[i], false);\n@@ -1060,1 +1063,1 @@\n-    while (_storage.delete_empty_blocks()) {}\n+    while (storage().delete_empty_blocks()) {}\n@@ -1062,3 +1065,3 @@\n-  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));\n-  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(released));\n-  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));\n+  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, storage().allocation_status(retained));\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(released));\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(garbage));\n@@ -1072,1 +1075,1 @@\n-  EXPECT_EQ(0u, _storage.block_count());\n+  EXPECT_EQ(0u, storage().block_count());\n@@ -1074,1 +1077,1 @@\n-  EXPECT_LT(0u, _storage.total_memory_usage());\n+  EXPECT_LT(0u, storage().total_memory_usage());\n@@ -1076,3 +1079,3 @@\n-  while (_storage.block_count() < goal_blocks) {\n-    size_t this_count = _storage.block_count();\n-    while (_storage.block_count() == this_count) {\n+  while (storage().block_count() < goal_blocks) {\n+    size_t this_count = storage().block_count();\n+    while (storage().block_count() == this_count) {\n@@ -1080,1 +1083,1 @@\n-      entries[allocated] = _storage.allocate();\n+      entries[allocated] = storage().allocate();\n@@ -1084,2 +1087,2 @@\n-    EXPECT_NE(0u, _storage.block_count());\n-    EXPECT_NE(0u, _storage.total_memory_usage());\n+    EXPECT_NE(0u, storage().block_count());\n+    EXPECT_NE(0u, storage().total_memory_usage());\n@@ -1088,2 +1091,2 @@\n-  EXPECT_LT(TestAccess::memory_per_block() * _storage.block_count(),\n-            _storage.total_memory_usage());\n+  EXPECT_LT(TestAccess::memory_per_block() * storage().block_count(),\n+            storage().total_memory_usage());\n@@ -1098,1 +1101,1 @@\n-    release_entry(_storage, _entries[i], false);\n+    release_entry(storage(), _entries[i], false);\n@@ -1104,1 +1107,1 @@\n-    release_entry(_storage, _entries[i], false);\n+    release_entry(storage(), _entries[i], false);\n@@ -1109,1 +1112,1 @@\n-  EXPECT_EQ(expected_entries, _storage.allocation_count());\n+  EXPECT_EQ(expected_entries, storage().allocation_count());\n@@ -1113,1 +1116,1 @@\n-  EXPECT_EQ(expected_blocks, _storage.block_count());\n+  EXPECT_EQ(expected_blocks, storage().block_count());\n@@ -1126,1 +1129,1 @@\n-                      _storage.total_memory_usage());\n+                      storage().total_memory_usage());\n@@ -1128,1 +1131,1 @@\n-    _storage.print_on(&st);\n+    storage().print_on(&st);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage.cpp","additions":155,"deletions":152,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+  OopStorage* _storage;\n+\n@@ -65,0 +67,1 @@\n+  OopStorage& storage() const { return *_storage; }\n@@ -71,1 +74,0 @@\n-  OopStorage _storage;\n@@ -88,1 +90,1 @@\n-  _storage(\"Test Storage\", mtGC)\n+  _storage(OopStorage::create(\"Test Storage\", mtGC))\n@@ -91,1 +93,1 @@\n-    _entries[i] = _storage.allocate();\n+    _entries[i] = storage().allocate();\n@@ -97,1 +99,2 @@\n-  _storage.release(_entries, ARRAY_SIZE(_entries));\n+  storage().release(_entries, ARRAY_SIZE(_entries));\n+  delete _storage;\n@@ -180,1 +183,1 @@\n-    Task task(&_storage, &closure, nthreads);\n+    Task task(&storage(), &closure, nthreads);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage_parperf.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+ -runtime\/cds\/appcds\/lambdaForm\/DefaultClassListLFInvokers.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+        Asserts.assertNotEquals(nmethod.getStart(), 0L);\n@@ -99,0 +100,1 @@\n+        Asserts.assertEquals(nmethod.getStart(), 0L);\n@@ -104,0 +106,1 @@\n+        Asserts.assertEquals(nmethod.getStart(), 0L);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/InvalidateInstalledCodeTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -205,0 +205,1 @@\n+    public static final String VECTOR_MASK_CAST = START + \"VectorMaskCast\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *      -XX:StressLongCountedLoop=0\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:StressLongCountedLoop=0\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestRemoveEmptyLoop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,4 @@\n- * @summary Test various reverse bytes ideal transforms on X86(AVX2, AVX512) and AARCH64(NEON)\n+ * @summary Test various reverse bytes ideal transforms on X86(AVX2, AVX512) and AArch64(NEON).\n+ *          For AArch64(SVE), we have a specific optimization,\n+ *          ReverseBytesV (ReverseBytesV X MASK) MASK => X, which eliminates both ReverseBytesV\n+ *          nodes. The test cases for AArch64(SVE) are in TestReverseByteTransformsSVE.java.\n@@ -42,0 +45,1 @@\n+ * @requires !(vm.cpu.features ~= \".*sve.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransforms.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-* @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx512dq.*\")\n@@ -90,1 +89,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -107,1 +106,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"}, applyIfCPUFeature = {\"avx512dq\", \"true\"})\n@@ -124,1 +123,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -141,1 +140,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -158,1 +157,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -175,1 +174,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"}, applyIfCPUFeature = {\"avx512dq\", \"true\"})\n@@ -192,1 +191,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -209,1 +208,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFPtoIntCastTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -35,1 +37,0 @@\n-import jdk.test.lib.Utils;\n@@ -37,2 +38,2 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n@@ -42,1 +43,1 @@\n- * @bug 8273264\n+ * @bug 8273264 8292898\n@@ -44,2 +45,2 @@\n- * @library \/test\/lib\n- * @summary AArch64: [vector] Add missing rules for VectorMaskCast\n+ * @library \/test\/lib \/\n+ * @summary Unify vector mask cast and add missing rules for VectorMaskCast\n@@ -48,1 +49,1 @@\n- * @run testng\/othervm -XX:-TieredCompilation -XX:CompileThreshold=100 compiler.vectorapi.VectorMaskCastTest\n+ * @run driver compiler.vectorapi.VectorMaskCastTest\n@@ -51,1 +52,0 @@\n-\n@@ -59,1 +59,1 @@\n-public class VectorMaskCastTest{\n+public class VectorMaskCastTest {\n@@ -61,1 +61,0 @@\n-    private static final int NUM_ITER = 5000;\n@@ -64,4 +63,6 @@\n-    public static boolean[] genMask() {\n-        boolean[] mask = new boolean[64];\n-        for (int i = 0; i < 64; i ++) {\n-            mask[i] = rd.nextBoolean();\n+    private static final boolean[] mask_arr;\n+\n+    static {\n+        mask_arr = new boolean[64];\n+        for (int i = 0; i < 64; i++) {\n+            mask_arr[i] = rd.nextBoolean();\n@@ -69,1 +70,0 @@\n-        return mask;\n@@ -73,1 +73,3 @@\n-    private static void testByte64ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testByte64ToShort128() {\n@@ -75,1 +77,1 @@\n-        Assert.assertEquals(mByte64.cast(ShortVector.SPECIES_128).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(ShortVector.SPECIES_128).toString(), mByte64.toString());\n@@ -78,1 +80,3 @@\n-    private static void testByte64ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testByte64ToInt256() {\n@@ -80,1 +84,1 @@\n-        Assert.assertEquals(mByte64.cast(IntVector.SPECIES_256).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(IntVector.SPECIES_256).toString(), mByte64.toString());\n@@ -83,1 +87,3 @@\n-    private static void testByte64ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testByte64ToFloat256() {\n@@ -85,1 +91,1 @@\n-        Assert.assertEquals(mByte64.cast(FloatVector.SPECIES_256).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(FloatVector.SPECIES_256).toString(), mByte64.toString());\n@@ -88,1 +94,3 @@\n-    private static void testByte64ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte64ToLong512() {\n@@ -90,1 +98,1 @@\n-        Assert.assertEquals(mByte64.cast(LongVector.SPECIES_512).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(LongVector.SPECIES_512).toString(), mByte64.toString());\n@@ -93,1 +101,3 @@\n-    private static void testByte64ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte64ToDouble512() {\n@@ -95,1 +105,1 @@\n-        Assert.assertEquals(mByte64.cast(DoubleVector.SPECIES_512).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(DoubleVector.SPECIES_512).toString(), mByte64.toString());\n@@ -98,1 +108,3 @@\n-    private static void testByte128ToShort256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testByte128ToShort256() {\n@@ -100,1 +112,1 @@\n-        Assert.assertEquals(mByte128.cast(ShortVector.SPECIES_256).toString(), mByte128.toString());\n+        Asserts.assertEquals(mByte128.cast(ShortVector.SPECIES_256).toString(), mByte128.toString());\n@@ -103,1 +115,3 @@\n-    private static void testByte128ToInt512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte128ToInt512() {\n@@ -105,1 +119,1 @@\n-        Assert.assertEquals(mByte128.cast(IntVector.SPECIES_512).toString(), mByte128.toString());\n+        Asserts.assertEquals(mByte128.cast(IntVector.SPECIES_512).toString(), mByte128.toString());\n@@ -108,1 +122,3 @@\n-    private static void testByte128ToFloat512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte128ToFloat512() {\n@@ -110,1 +126,1 @@\n-        Assert.assertEquals(mByte128.cast(FloatVector.SPECIES_512).toString(), mByte128.toString());\n+        Asserts.assertEquals(mByte128.cast(FloatVector.SPECIES_512).toString(), mByte128.toString());\n@@ -113,1 +129,3 @@\n-    private static void testByte256ToShort512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte256ToShort512() {\n@@ -115,1 +133,1 @@\n-        Assert.assertEquals(mByte256.cast(ShortVector.SPECIES_512).toString(), mByte256.toString());\n+        Asserts.assertEquals(mByte256.cast(ShortVector.SPECIES_512).toString(), mByte256.toString());\n@@ -119,1 +137,3 @@\n-    private static void testShort64ToInt128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testShort64ToInt128() {\n@@ -121,1 +141,1 @@\n-        Assert.assertEquals(mShort64.cast(IntVector.SPECIES_128).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(IntVector.SPECIES_128).toString(), mShort64.toString());\n@@ -124,1 +144,3 @@\n-    private static void testShort64ToFloat128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testShort64ToFloat128() {\n@@ -126,1 +148,1 @@\n-        Assert.assertEquals(mShort64.cast(FloatVector.SPECIES_128).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(FloatVector.SPECIES_128).toString(), mShort64.toString());\n@@ -129,1 +151,3 @@\n-    private static void testShort64ToLong256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort64ToLong256() {\n@@ -131,1 +155,1 @@\n-        Assert.assertEquals(mShort64.cast(LongVector.SPECIES_256).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(LongVector.SPECIES_256).toString(), mShort64.toString());\n@@ -134,1 +158,3 @@\n-    private static void testShort64ToDouble256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort64ToDouble256() {\n@@ -136,1 +162,1 @@\n-        Assert.assertEquals(mShort64.cast(DoubleVector.SPECIES_256).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(DoubleVector.SPECIES_256).toString(), mShort64.toString());\n@@ -139,1 +165,3 @@\n-    private static void testShort128ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testShort128ToByte64() {\n@@ -141,1 +169,1 @@\n-        Assert.assertEquals(mShort128.cast(ByteVector.SPECIES_64).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(ByteVector.SPECIES_64).toString(), mShort128.toString());\n@@ -144,1 +172,3 @@\n-    private static void testShort128ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort128ToInt256() {\n@@ -146,1 +176,1 @@\n-        Assert.assertEquals(mShort128.cast(IntVector.SPECIES_256).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(IntVector.SPECIES_256).toString(), mShort128.toString());\n@@ -149,1 +179,3 @@\n-    private static void testShort128ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort128ToFloat256() {\n@@ -151,1 +183,1 @@\n-        Assert.assertEquals(mShort128.cast(FloatVector.SPECIES_256).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(FloatVector.SPECIES_256).toString(), mShort128.toString());\n@@ -154,1 +186,3 @@\n-    private static void testShort128ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort128ToLong512() {\n@@ -156,1 +190,1 @@\n-        Assert.assertEquals(mShort128.cast(LongVector.SPECIES_512).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(LongVector.SPECIES_512).toString(), mShort128.toString());\n@@ -159,1 +193,3 @@\n-    private static void testShort128ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort128ToDouble512() {\n@@ -161,1 +197,1 @@\n-        Assert.assertEquals(mShort128.cast(DoubleVector.SPECIES_512).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(DoubleVector.SPECIES_512).toString(), mShort128.toString());\n@@ -164,1 +200,3 @@\n-    private static void testShort256ToByte128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort256ToByte128() {\n@@ -166,1 +204,1 @@\n-        Assert.assertEquals(mShort256.cast(ByteVector.SPECIES_128).toString(), mShort256.toString());\n+        Asserts.assertEquals(mShort256.cast(ByteVector.SPECIES_128).toString(), mShort256.toString());\n@@ -169,1 +207,3 @@\n-    private static void testShort256ToInt512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort256ToInt512() {\n@@ -171,1 +211,1 @@\n-        Assert.assertEquals(mShort256.cast(IntVector.SPECIES_512).toString(), mShort256.toString());\n+        Asserts.assertEquals(mShort256.cast(IntVector.SPECIES_512).toString(), mShort256.toString());\n@@ -174,1 +214,3 @@\n-    private static void testShort256ToFloat512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort256ToFloat512() {\n@@ -176,1 +218,1 @@\n-        Assert.assertEquals(mShort256.cast(FloatVector.SPECIES_512).toString(), mShort256.toString());\n+        Asserts.assertEquals(mShort256.cast(FloatVector.SPECIES_512).toString(), mShort256.toString());\n@@ -179,1 +221,3 @@\n-    private static void testShort512ToByte256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort512ToByte256() {\n@@ -181,1 +225,1 @@\n-        Assert.assertEquals(mShort512.cast(ByteVector.SPECIES_256).toString(), mShort512.toString());\n+        Asserts.assertEquals(mShort512.cast(ByteVector.SPECIES_256).toString(), mShort512.toString());\n@@ -185,1 +229,3 @@\n-    private static void testInt64ToLong128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testInt64ToLong128() {\n@@ -187,1 +233,1 @@\n-        Assert.assertEquals(mInt64.cast(LongVector.SPECIES_128).toString(), mInt64.toString());\n+        Asserts.assertEquals(mInt64.cast(LongVector.SPECIES_128).toString(), mInt64.toString());\n@@ -190,1 +236,3 @@\n-    private static void testInt64ToDouble128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testInt64ToDouble128() {\n@@ -192,1 +240,1 @@\n-        Assert.assertEquals(mInt64.cast(DoubleVector.SPECIES_128).toString(), mInt64.toString());\n+        Asserts.assertEquals(mInt64.cast(DoubleVector.SPECIES_128).toString(), mInt64.toString());\n@@ -195,1 +243,3 @@\n-    private static void testInt128ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testInt128ToShort64() {\n@@ -197,1 +247,1 @@\n-        Assert.assertEquals(mInt128.cast(ShortVector.SPECIES_64).toString(), mInt128.toString());\n+        Asserts.assertEquals(mInt128.cast(ShortVector.SPECIES_64).toString(), mInt128.toString());\n@@ -200,1 +250,3 @@\n-    private static void testInt128ToLong256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt128ToLong256() {\n@@ -202,1 +254,1 @@\n-        Assert.assertEquals(mInt128.cast(LongVector.SPECIES_256).toString(), mInt128.toString());\n+        Asserts.assertEquals(mInt128.cast(LongVector.SPECIES_256).toString(), mInt128.toString());\n@@ -205,1 +257,3 @@\n-    private static void testInt128ToDouble256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt128ToDouble256() {\n@@ -207,1 +261,1 @@\n-        Assert.assertEquals(mInt128.cast(DoubleVector.SPECIES_256).toString(), mInt128.toString());\n+        Asserts.assertEquals(mInt128.cast(DoubleVector.SPECIES_256).toString(), mInt128.toString());\n@@ -210,1 +264,3 @@\n-    private static void testInt256ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt256ToShort128() {\n@@ -212,1 +268,1 @@\n-        Assert.assertEquals(mInt256.cast(ShortVector.SPECIES_128).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(ShortVector.SPECIES_128).toString(), mInt256.toString());\n@@ -215,1 +271,3 @@\n-    private static void testInt256ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt256ToByte64() {\n@@ -217,1 +275,1 @@\n-        Assert.assertEquals(mInt256.cast(ByteVector.SPECIES_64).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(ByteVector.SPECIES_64).toString(), mInt256.toString());\n@@ -220,1 +278,3 @@\n-    private static void testInt256ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testInt256ToLong512() {\n@@ -222,1 +282,1 @@\n-        Assert.assertEquals(mInt256.cast(LongVector.SPECIES_512).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(LongVector.SPECIES_512).toString(), mInt256.toString());\n@@ -225,1 +285,3 @@\n-    private static void testInt256ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testInt256ToDouble512() {\n@@ -227,1 +289,1 @@\n-        Assert.assertEquals(mInt256.cast(DoubleVector.SPECIES_512).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(DoubleVector.SPECIES_512).toString(), mInt256.toString());\n@@ -230,1 +292,3 @@\n-    private static void testInt512ToShort256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testInt512ToShort256() {\n@@ -232,1 +296,1 @@\n-        Assert.assertEquals(mInt512.cast(ShortVector.SPECIES_256).toString(), mInt512.toString());\n+        Asserts.assertEquals(mInt512.cast(ShortVector.SPECIES_256).toString(), mInt512.toString());\n@@ -235,1 +299,3 @@\n-    private static void testInt512ToByte128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testInt512ToByte128() {\n@@ -237,1 +303,1 @@\n-        Assert.assertEquals(mInt512.cast(ByteVector.SPECIES_128).toString(), mInt512.toString());\n+        Asserts.assertEquals(mInt512.cast(ByteVector.SPECIES_128).toString(), mInt512.toString());\n@@ -241,1 +307,3 @@\n-    private static void testFloat64ToLong128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloat64ToLong128() {\n@@ -243,1 +311,1 @@\n-        Assert.assertEquals(mFloat64.cast(LongVector.SPECIES_128).toString(), mFloat64.toString());\n+        Asserts.assertEquals(mFloat64.cast(LongVector.SPECIES_128).toString(), mFloat64.toString());\n@@ -246,1 +314,3 @@\n-    private static void testFloat64ToDouble128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloat64ToDouble128() {\n@@ -248,1 +318,1 @@\n-        Assert.assertEquals(mFloat64.cast(DoubleVector.SPECIES_128).toString(), mFloat64.toString());\n+        Asserts.assertEquals(mFloat64.cast(DoubleVector.SPECIES_128).toString(), mFloat64.toString());\n@@ -251,1 +321,3 @@\n-    private static void testFloat128ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testFloat128ToShort64() {\n@@ -253,1 +325,1 @@\n-        Assert.assertEquals(mFloat128.cast(ShortVector.SPECIES_64).toString(), mFloat128.toString());\n+        Asserts.assertEquals(mFloat128.cast(ShortVector.SPECIES_64).toString(), mFloat128.toString());\n@@ -256,1 +328,3 @@\n-    private static void testFloat128ToLong256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat128ToLong256() {\n@@ -258,1 +332,1 @@\n-        Assert.assertEquals(mFloat128.cast(LongVector.SPECIES_256).toString(), mFloat128.toString());\n+        Asserts.assertEquals(mFloat128.cast(LongVector.SPECIES_256).toString(), mFloat128.toString());\n@@ -261,1 +335,3 @@\n-    private static void testFloat128ToDouble256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat128ToDouble256() {\n@@ -263,1 +339,1 @@\n-        Assert.assertEquals(mFloat128.cast(DoubleVector.SPECIES_256).toString(), mFloat128.toString());\n+        Asserts.assertEquals(mFloat128.cast(DoubleVector.SPECIES_256).toString(), mFloat128.toString());\n@@ -266,1 +342,3 @@\n-    private static void testFloat256ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat256ToShort128() {\n@@ -268,1 +346,1 @@\n-        Assert.assertEquals(mFloat256.cast(ShortVector.SPECIES_128).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(ShortVector.SPECIES_128).toString(), mFloat256.toString());\n@@ -271,1 +349,3 @@\n-    private static void testFloat256ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat256ToByte64() {\n@@ -273,1 +353,1 @@\n-        Assert.assertEquals(mFloat256.cast(ByteVector.SPECIES_64).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(ByteVector.SPECIES_64).toString(), mFloat256.toString());\n@@ -276,1 +356,3 @@\n-    private static void testFloat256ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testFloat256ToLong512() {\n@@ -278,1 +360,1 @@\n-        Assert.assertEquals(mFloat256.cast(LongVector.SPECIES_512).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(LongVector.SPECIES_512).toString(), mFloat256.toString());\n@@ -281,1 +363,3 @@\n-    private static void testFloat256ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testFloat256ToDouble512() {\n@@ -283,1 +367,1 @@\n-        Assert.assertEquals(mFloat256.cast(DoubleVector.SPECIES_512).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(DoubleVector.SPECIES_512).toString(), mFloat256.toString());\n@@ -286,1 +370,3 @@\n-    private static void testFloat512ToShort256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testFloat512ToShort256() {\n@@ -288,1 +374,1 @@\n-        Assert.assertEquals(mFloat512.cast(ShortVector.SPECIES_256).toString(), mFloat512.toString());\n+        Asserts.assertEquals(mFloat512.cast(ShortVector.SPECIES_256).toString(), mFloat512.toString());\n@@ -291,1 +377,3 @@\n-    private static void testFloat512ToByte128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testFloat512ToByte128() {\n@@ -293,1 +381,1 @@\n-        Assert.assertEquals(mFloat512.cast(ByteVector.SPECIES_128).toString(), mFloat512.toString());\n+        Asserts.assertEquals(mFloat512.cast(ByteVector.SPECIES_128).toString(), mFloat512.toString());\n@@ -297,1 +385,3 @@\n-    private static void testLong128ToInt64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLong128ToInt64() {\n@@ -299,1 +389,1 @@\n-        Assert.assertEquals(mLong128.cast(IntVector.SPECIES_64).toString(), mLong128.toString());\n+        Asserts.assertEquals(mLong128.cast(IntVector.SPECIES_64).toString(), mLong128.toString());\n@@ -302,1 +392,3 @@\n-    private static void testLong128ToFloat64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLong128ToFloat64() {\n@@ -304,1 +396,1 @@\n-        Assert.assertEquals(mLong128.cast(FloatVector.SPECIES_64).toString(), mLong128.toString());\n+        Asserts.assertEquals(mLong128.cast(FloatVector.SPECIES_64).toString(), mLong128.toString());\n@@ -307,1 +399,3 @@\n-    private static void testLong256ToInt128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testLong256ToInt128() {\n@@ -309,1 +403,1 @@\n-        Assert.assertEquals(mLong256.cast(IntVector.SPECIES_128).toString(), mLong256.toString());\n+        Asserts.assertEquals(mLong256.cast(IntVector.SPECIES_128).toString(), mLong256.toString());\n@@ -312,1 +406,3 @@\n-    private static void testLong256ToFloat128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testLong256ToFloat128() {\n@@ -314,1 +410,1 @@\n-        Assert.assertEquals(mLong256.cast(FloatVector.SPECIES_128).toString(), mLong256.toString());\n+        Asserts.assertEquals(mLong256.cast(FloatVector.SPECIES_128).toString(), mLong256.toString());\n@@ -317,1 +413,3 @@\n-    private static void testLong256ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testLong256ToShort64() {\n@@ -319,1 +417,1 @@\n-        Assert.assertEquals(mLong256.cast(ShortVector.SPECIES_64).toString(), mLong256.toString());\n+        Asserts.assertEquals(mLong256.cast(ShortVector.SPECIES_64).toString(), mLong256.toString());\n@@ -322,1 +420,3 @@\n-    private static void testLong512ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testLong512ToInt256() {\n@@ -324,1 +424,1 @@\n-        Assert.assertEquals(mLong512.cast(IntVector.SPECIES_256).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(IntVector.SPECIES_256).toString(), mLong512.toString());\n@@ -327,1 +427,3 @@\n-    private static void testLong512ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testLong512ToFloat256() {\n@@ -329,1 +431,1 @@\n-        Assert.assertEquals(mLong512.cast(FloatVector.SPECIES_256).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(FloatVector.SPECIES_256).toString(), mLong512.toString());\n@@ -332,1 +434,3 @@\n-    private static void testLong512ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testLong512ToShort128() {\n@@ -334,1 +438,1 @@\n-        Assert.assertEquals(mLong512.cast(ShortVector.SPECIES_128).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(ShortVector.SPECIES_128).toString(), mLong512.toString());\n@@ -337,1 +441,3 @@\n-    private static void testLong512ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testLong512ToByte64() {\n@@ -339,1 +445,1 @@\n-        Assert.assertEquals(mLong512.cast(ByteVector.SPECIES_64).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(ByteVector.SPECIES_64).toString(), mLong512.toString());\n@@ -343,1 +449,3 @@\n-    private static void testDouble128ToInt64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDouble128ToInt64() {\n@@ -345,1 +453,1 @@\n-        Assert.assertEquals(mDouble128.cast(IntVector.SPECIES_64).toString(), mDouble128.toString());\n+        Asserts.assertEquals(mDouble128.cast(IntVector.SPECIES_64).toString(), mDouble128.toString());\n@@ -348,1 +456,3 @@\n-    private static void testDouble128ToFloat64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDouble128ToFloat64() {\n@@ -350,1 +460,1 @@\n-        Assert.assertEquals(mDouble128.cast(FloatVector.SPECIES_64).toString(), mDouble128.toString());\n+        Asserts.assertEquals(mDouble128.cast(FloatVector.SPECIES_64).toString(), mDouble128.toString());\n@@ -353,1 +463,3 @@\n-    private static void testDouble256ToInt128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testDouble256ToInt128() {\n@@ -355,1 +467,1 @@\n-        Assert.assertEquals(mDouble256.cast(IntVector.SPECIES_128).toString(), mDouble256.toString());\n+        Asserts.assertEquals(mDouble256.cast(IntVector.SPECIES_128).toString(), mDouble256.toString());\n@@ -358,1 +470,3 @@\n-    private static void testDouble256ToFloat128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testDouble256ToFloat128() {\n@@ -360,1 +474,1 @@\n-        Assert.assertEquals(mDouble256.cast(FloatVector.SPECIES_128).toString(), mDouble256.toString());\n+        Asserts.assertEquals(mDouble256.cast(FloatVector.SPECIES_128).toString(), mDouble256.toString());\n@@ -363,1 +477,3 @@\n-    private static void testDouble256ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testDouble256ToShort64() {\n@@ -365,2 +481,2 @@\n-        Assert.assertEquals(mDouble256.cast(ShortVector.SPECIES_64).toString(), mDouble256.toString());\n-    };\n+        Asserts.assertEquals(mDouble256.cast(ShortVector.SPECIES_64).toString(), mDouble256.toString());\n+    }\n@@ -368,1 +484,3 @@\n-    private static void testDouble512ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testDouble512ToInt256() {\n@@ -370,1 +488,1 @@\n-        Assert.assertEquals(mDouble512.cast(IntVector.SPECIES_256).toString(), mDouble512.toString());\n+        Asserts.assertEquals(mDouble512.cast(IntVector.SPECIES_256).toString(), mDouble512.toString());\n@@ -373,1 +491,3 @@\n-    private static void testDouble512ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testDouble512ToFloat256() {\n@@ -375,1 +495,1 @@\n-        Assert.assertEquals(mDouble512.cast(FloatVector.SPECIES_256).toString(), mDouble512.toString());\n+        Asserts.assertEquals(mDouble512.cast(FloatVector.SPECIES_256).toString(), mDouble512.toString());\n@@ -378,1 +498,3 @@\n-    private static void testDouble512ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testDouble512ToShort128() {\n@@ -380,1 +502,1 @@\n-        Assert.assertEquals(mDouble512.cast(ShortVector.SPECIES_128).toString(), mDouble512.toString());\n+        Asserts.assertEquals(mDouble512.cast(ShortVector.SPECIES_128).toString(), mDouble512.toString());\n@@ -383,1 +505,3 @@\n-    private static void testDouble512ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testDouble512ToByte64() {\n@@ -385,82 +509,8 @@\n-        Assert.assertEquals(mDouble512.cast(ByteVector.SPECIES_64).toString(), mDouble512.toString());\n-    }\n-\n-\n-    @Test\n-    public static void testMaskCast() {\n-        for (int i = 0; i < NUM_ITER; i++) {\n-            boolean[] mask = genMask();\n-            \/\/ Byte\n-            testByte64ToShort128(mask);\n-            testByte64ToInt256(mask);\n-            testByte64ToFloat256(mask);\n-            testByte64ToLong512(mask);\n-            testByte64ToDouble512(mask);\n-            testByte128ToShort256(mask);\n-            testByte128ToInt512(mask);\n-            testByte128ToFloat512(mask);\n-            testByte256ToShort512(mask);\n-\n-            \/\/ Short\n-            testShort64ToInt128(mask);\n-            testShort64ToFloat128(mask);\n-            testShort64ToLong256(mask);\n-            testShort64ToDouble256(mask);\n-            testShort128ToByte64(mask);\n-            testShort128ToInt256(mask);\n-            testShort128ToFloat256(mask);\n-            testShort128ToLong512(mask);\n-            testShort128ToDouble512(mask);\n-            testShort256ToByte128(mask);\n-            testShort256ToInt512(mask);\n-            testShort256ToFloat512(mask);\n-            testShort512ToByte256(mask);\n-\n-            \/\/ Int\n-            testInt64ToLong128(mask);\n-            testInt64ToDouble128(mask);\n-            testInt128ToShort64(mask);\n-            testInt128ToLong256(mask);\n-            testInt128ToDouble256(mask);\n-            testInt256ToShort128(mask);\n-            testInt256ToByte64(mask);\n-            testInt256ToLong512(mask);\n-            testInt256ToDouble512(mask);\n-            testInt512ToShort256(mask);\n-            testInt512ToByte128(mask);\n-\n-            \/\/ Float\n-            testFloat64ToLong128(mask);\n-            testFloat64ToDouble128(mask);\n-            testFloat128ToShort64(mask);\n-            testFloat128ToLong256(mask);\n-            testFloat128ToDouble256(mask);\n-            testFloat256ToShort128(mask);\n-            testFloat256ToByte64(mask);\n-            testFloat256ToLong512(mask);\n-            testFloat256ToDouble512(mask);\n-            testFloat512ToShort256(mask);\n-            testFloat512ToByte128(mask);\n-\n-            \/\/ Long\n-            testLong128ToInt64(mask);\n-            testLong128ToFloat64(mask);\n-            testLong256ToInt128(mask);\n-            testLong256ToFloat128(mask);\n-            testLong256ToShort64(mask);\n-            testLong512ToInt256(mask);\n-            testLong512ToFloat256(mask);\n-            testLong512ToShort128(mask);\n-            testLong512ToByte64(mask);\n-\n-            \/\/ Double\n-            testDouble128ToInt64(mask);\n-            testDouble128ToFloat64(mask);\n-            testDouble256ToInt128(mask);\n-            testDouble256ToFloat128(mask);\n-            testDouble256ToShort64(mask);\n-            testDouble512ToInt256(mask);\n-            testDouble512ToFloat256(mask);\n-            testDouble512ToShort128(mask);\n-            testDouble512ToByte64(mask);\n-        }\n+        Asserts.assertEquals(mDouble512.cast(ByteVector.SPECIES_64).toString(), mDouble512.toString());\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastTest.java","additions":272,"deletions":222,"binary":false,"changes":494,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+            makePair(FSPEC128, ISPEC128),\n+            makePair(FSPEC128, SSPEC64),\n@@ -67,0 +69,1 @@\n+            makePair(DSPEC128, ISPEC64),\n@@ -77,0 +80,5 @@\n+            makePair(DSPEC256, ISPEC128),\n+            makePair(DSPEC256, SSPEC64),\n+            makePair(FSPEC256, ISPEC256),\n+            makePair(FSPEC256, SSPEC128),\n+            makePair(FSPEC256, BSPEC64),\n@@ -92,1 +100,0 @@\n-            makePair(FSPEC256, ISPEC256),\n@@ -118,1 +125,0 @@\n-            makePair(FSPEC512, ISPEC512),\n@@ -121,0 +127,6 @@\n+            makePair(DSPEC512, ISPEC256),\n+            makePair(DSPEC512, SSPEC128),\n+            makePair(DSPEC512, BSPEC64),\n+            makePair(FSPEC512, ISPEC512),\n+            makePair(FSPEC512, SSPEC256),\n+            makePair(FSPEC512, BSPEC128),\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.io.IOException;\n@@ -748,0 +749,33 @@\n+\n+    public static void filesMustMatch(Path a, Path b) throws IOException {\n+        linesMustMatch(Files.readString(a).split(\"\\n\"),\n+                       Files.readString(b).split(\"\\n\"));\n+    }\n+\n+    public static void linesMustMatch(String a[], String b[]) {\n+        int limit = Math.min(a.length, b.length);\n+\n+        \/\/ Check the lines that are in both a[] and b[]\n+        for (int i = 0; i < limit; i++) {\n+            if (!a[i].equals(b[i])) {\n+                System.out.println(\"a:\" + i + \" \" + a[i]);\n+                System.out.println(\"b:\" + i + \" \" + b[i]);\n+                throw new RuntimeException(\"Output mismatch on line \" + i\n+                                           + \": a=\" + a[i]\n+                                           + \", b=\" + b[i]);\n+            }\n+        }\n+\n+        \/\/ Report the first line that is in one array but not in the other\n+        if (a.length > b.length) {\n+            throw new RuntimeException(\"Output mismatch on line \" + limit\n+                                       + \": a=\" + a[limit]\n+                                       + \", b=<none>\");\n+\n+        }\n+        if (a.length < b.length) {\n+            throw new RuntimeException(\"Output mismatch on line \" + limit\n+                                       + \": a=<none>\"\n+                                       + \", b=\" + b[limit]);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295102\n+ * @summary Always load the lambda-form-invoker lines from default classlist\n+ * @requires vm.cds\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build DefaultClassListLFInvokers\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *             DefaultClassListLFInvokersApp DefaultClassListLFInvokersApp$CompMethods\n+ * @run driver DefaultClassListLFInvokers\n+ *\/\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class DefaultClassListLFInvokers {\n+    static final String appClass = DefaultClassListLFInvokersApp.class.getName();\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+\n+    static final String[] classlist = {\n+        appClass,\n+        \/\/ If we have at least one line of @lambda-form-invoker in the classlist, it triggers\n+        \/\/ the regeneration of the 4 XXX$Holder during -Xshare:dump.\n+        \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic L_V\"\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        File classListFile = CDSTestUtils.makeClassList(classlist);\n+        CDSTestUtils.createArchiveAndCheck(\"-XX:SharedClassListFile=\" + classListFile.getPath(),\n+                                           \"-cp\", appJar);\n+\n+        \/\/ Make sure we still have all the LF invoker methods as when CDS is disabled,\n+        \/\/ in which case the XXX$Holder classes are loaded from $JAVA_HOME\/lib\/modules\n+        Path no_cds_logfile = run(Mode.no_cds);\n+        Path custom_cds_logfile = run(Mode.custom_cds);\n+        System.out.println(\"\\n\\n============================== Checking output: custom_cds vs no_cds\");\n+        TestCommon.filesMustMatch(custom_cds_logfile, no_cds_logfile);\n+\n+        \/\/ We should also have all the LF invoker methods as when the default CDS archive is used\n+        \/\/ in which case the XXX$Holder classes are loaded from the default archive,\n+        \/\/ e.g., $JAVA_HOME\/lib\/server\/classes.jsa\n+        Path default_cds_logfile = run(Mode.default_cds);\n+        System.out.println(\"\\n\\n============================== Checking output: custom_cds vs default_cds\");\n+        TestCommon.filesMustMatch(custom_cds_logfile, default_cds_logfile);\n+    }\n+\n+    enum Mode {\n+        no_cds,\n+        default_cds,\n+        custom_cds\n+    };\n+\n+    static Path run(Mode mode) throws Exception {\n+        File f = new File(\"log_\" + mode.name() + \".txt\");\n+        CDSOptions opts = (new CDSOptions())\n+            .addSuffix(\"-showversion\", \"-cp\", appJar, appClass, f.toString())\n+            .setUseVersion(false);\n+\n+        switch (mode) {\n+        case no_cds:\n+            opts.setXShareMode(\"off\");\n+            break;\n+        case custom_cds:\n+            \/\/ We will use the archive created by the last CDSTestUtils.createArchiveAndCheck() call\n+            opts.setUseSystemArchive(false);\n+            opts.setXShareMode(\"auto\");\n+            break;\n+        case default_cds:\n+        default:\n+            \/\/ We will use the default archive.\n+            opts.setUseSystemArchive(true);\n+            opts.setXShareMode(\"auto\");\n+            break;\n+        }\n+        CDSTestUtils.run(opts).assertNormalExit(DefaultClassListLFInvokersApp.FLAG);\n+        return f.toPath();\n+    }\n+}\n+\n+class DefaultClassListLFInvokersApp {\n+    public static final String FLAG = \"Test Success!\";\n+    static class CompMethods implements Comparator<Method> {\n+        public int compare(Method a, Method b) {\n+            return a.toString().compareTo(b.toString());\n+        }\n+    }\n+    static final CompMethods compMethods = new CompMethods();\n+\n+    public static void main(String[] args) throws Exception {\n+        try (BufferedWriter w = new BufferedWriter(new FileWriter(args[0]))) {\n+            test(w, \"java.lang.invoke.Invokers$Holder\");\n+            test(w, \"java.lang.invoke.DirectMethodHandle$Holder\");\n+            test(w, \"java.lang.invoke.DelegatingMethodHandle$Holder\");\n+            test(w, \"java.lang.invoke.LambdaForm$Holder\");\n+            System.out.println(FLAG);\n+        }\n+    }\n+\n+    static void test(BufferedWriter w, String className) throws Exception {\n+        Class c = Class.forName(className);\n+        Method[] methods = c.getDeclaredMethods();\n+        w.write(\"Dumping all methods in \" + c + \"\\n\");\n+        Arrays.sort(methods, 0, methods.length, compMethods);\n+        for (Method m : methods) {\n+            w.write(m + \"\\n\");\n+        }\n+        w.write(\"Found \" + methods.length + \" methods\\n\\n\\n\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/lambdaForm\/DefaultClassListLFInvokers.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -1,177 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-#include \"jvmti_thread.h\"\n-\n-extern \"C\" {\n-\n-\/* scaffold objects *\/\n-static jlong timeout = 0;\n-\n-\/* constant names *\/\n-#define THREAD_NAME     \"TestedThread\"\n-#define N_LATE_CALLS    10000\n-\n-\/** Agent algorithm. *\/\n-static void JNICALL\n-agentProc(jvmtiEnv *jvmti, JNIEnv *jni, void *arg) {\n-  jvmtiError err;\n-  \/* Original agentProc test block starts here: *\/\n-  LOG(\"Wait for thread to start\\n\");\n-  \/\/ SP2.1-n - notify agent is waiting and wait\n-  \/\/ SP3.1-w - wait to start test\n-  if (!agent_wait_for_sync(timeout))\n-    return;\n-\n-  \/* perform testing *\/\n-  {\n-    jthread testedThread = NULL;\n-    int late_count;\n-\n-    LOG(\"Find thread: %s\\n\", THREAD_NAME);\n-    testedThread = find_thread_by_name(jvmti, jni, THREAD_NAME);\n-    if (testedThread == NULL) {\n-      return;\n-    }\n-    LOG(\"  ... found thread: %p\\n\", (void *) testedThread);\n-\n-    LOG(\"Suspend thread: %p\\n\", (void *) testedThread);\n-    err = jvmti->SuspendThread(testedThread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      set_agent_fail_status();\n-      return;\n-    }\n-\n-    LOG(\"Let thread to run and finish\\n\");\n-    \/\/ SP5.1-n - notify suspend done\n-    if (!agent_resume_sync())\n-      return;\n-\n-    LOG(\"Get state vector for thread: %p\\n\", (void *) testedThread);\n-    {\n-      jint state = 0;\n-\n-      err = jvmti->GetThreadState(testedThread, &state);\n-      if (err != JVMTI_ERROR_NONE) {\n-        set_agent_fail_status();\n-        return;\n-      }\n-      LOG(\"  ... got state vector: %s (%d)\\n\", TranslateState(state), (int) state);\n-\n-      if ((state & JVMTI_THREAD_STATE_SUSPENDED) == 0) {\n-        LOG(\"SuspendThread() does not turn on flag SUSPENDED:\\n\"\n-            \"#   state: %s (%d)\\n\", TranslateState(state), (int) state);\n-        set_agent_fail_status();\n-      }\n-    }\n-\n-    LOG(\"Resume thread: %p\\n\", (void *) testedThread);\n-    err = jvmti->ResumeThread(testedThread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      set_agent_fail_status();\n-      return;\n-    }\n-    \/* Original agentProc test block ends here. *\/\n-\n-    \/*\n-     * Using LOG() instead of LOG() in this loop\n-     * in order to slow down the rate of SuspendThread() calls.\n-     *\/\n-    for (late_count = 0; late_count < N_LATE_CALLS; late_count++) {\n-      jvmtiError l_err;\n-      LOG(\"INFO: Late suspend thread: %p\\n\", (void *) testedThread);\n-      l_err = jvmti->SuspendThread(testedThread);\n-      if (l_err != JVMTI_ERROR_NONE) {\n-        LOG(\"INFO: Late suspend thread err: %d\\n\", l_err);\n-        \/\/ testedThread has exited so we're done with late calls\n-        break;\n-      }\n-\n-      \/\/ Only resume a thread if suspend worked. Using LOG()\n-      \/\/ here because we want ResumeThread() to be faster.\n-      LOG(\"INFO: Late resume thread: %p\\n\", (void *) testedThread);\n-      err = jvmti->ResumeThread(testedThread);\n-      if (err != JVMTI_ERROR_NONE) {\n-        set_agent_fail_status();\n-        return;\n-      }\n-    }\n-\n-    LOG(\"INFO: made %d late calls to JVM\/TI SuspendThread()\\n\", late_count);\n-    LOG(\"INFO: N_LATE_CALLS == %d value is %slarge enough to cause a \"\n-        \"SuspendThread() call after thread exit.\\n\", N_LATE_CALLS,\n-        (late_count == N_LATE_CALLS) ? \"NOT \" : \"\");\n-\n-    \/* Second part of original agentProc test block starts here: *\/\n-    LOG(\"Wait for thread to finish\\n\");\n-    \/\/ SP4.1-n - notify agent is waiting and wait\n-    \/\/ SP6.1-w - wait to end test\n-    if (!agent_wait_for_sync(timeout))\n-      return;\n-\n-    LOG(\"Delete thread reference\\n\");\n-    jni->DeleteGlobalRef(testedThread);\n-  }\n-\n-  LOG(\"Let debugee to finish\\n\");\n-  \/\/ SP7.1-n - notify agent end\n-  if (!agent_resume_sync())\n-    return;\n-  \/* Second part of original agentProc test block ends here. *\/\n-}\n-\n-JNIEXPORT jint JNICALL\n-Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  jvmtiEnv *jvmti = NULL;\n-\n-  timeout = 60 * 1000;\n-\n-  jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    LOG(\"Wrong result of a valid call to GetEnv!\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  \/* add specific capabilities for suspending thread *\/\n-  jvmtiCapabilities suspendCaps;\n-  memset(&suspendCaps, 0, sizeof(suspendCaps));\n-  suspendCaps.can_suspend = 1;\n-  if (jvmti->AddCapabilities(&suspendCaps) != JVMTI_ERROR_NONE) {\n-    return JNI_ERR;\n-  }\n-\n-  if (init_agent_data(jvmti, &agent_data) != JVMTI_ERROR_NONE) {\n-    return JNI_ERR;\n-  }\n-  \/* register agent proc and arg *\/\n-  if (!set_agent_proc(agentProc, NULL)) {\n-    return JNI_ERR;\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThread\/suspendthrd03\/libsuspendthrd03.cpp","additions":0,"deletions":177,"binary":false,"changes":177,"status":"deleted"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/SuspendThread\/suspendthrd003.\n- * VM Testbase keywords: [jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Same test as suspendthrd001 with additional calls to\n- *     SuspendThread() and ResumeThread() while threads are exiting.\n- *     Failing criteria for the test are:\n- *       - failures of used JVMTI functions.\n- * COMMENTS\n- *     Derived from nsk\/jvmti\/SuspendThread\/suspendthrd001.\n- * Transaction Diagram for this test:\n- * main thread                                      agent thread                                       TestedThread-N\n- * ===============================================  =================================================  =============================================\n- * data->thread_state = NEW\n- * for N = 0; i < N_THREADS; i++ {\n- *   thr = new TestedThread-N\n- *   thr.start()                                                                                       run()\n- *   # SP1-w - wait for TestedThread-N to be ready                                                     :\n- *   thr.checkReady()                                                                                  \/\/ SP1-n - tell main we are ready\n- *   :                                                                                                 threadReady = true\n- *   \/\/ SP2.1-w - wait for agent thread                                                                while (!shouldFinish) {\n- *   \/\/ SP3.1-n - notify to start test                                                                   \/\/ do work\n- *   \/\/ SP5.1-w - wait while testing                                                                     :\n- *   checkStatus(() {                                                                                    :\n- *     enter(data.monitor)                                                                               :\n- *     if data.thread_state == NEW {                                                                     :\n- *       run_agent_thread                                                                        :\n- *       :                                          \/\/ this set is in the agent wrapper:                 :\n- *       :                                          data.thread_state = RUNNABLE                         :\n- *       :                                          agentProc() {                                        :\n- *       :                                            \/\/ SP2.1-n - notify agent is waiting               :\n- *       :                                            \/\/ SP3.1-w - wait to start test                    :\n- *       while (data.thread_state == NEW) {           waitForSync() {                                    :\n- *         \/\/ SP2.2-w - wait for agent thread           enter(data.monitor)                              :\n- *         wait(data.monitor)                           : <blocked>                                      :\n- *         :                                            : <enter>                                        :\n- *         :                                            data.thread_state = WAITING                      :\n- *         :                                            \/\/ SP2.2-n - notify agent is waiting and wait    :\n- *         :                                            notify(data.monitor)                             :\n- *         : <notified>                                 while (data.thread_state == WAITING) {           :\n- *         :                                              \/\/ SP3.2-w - wait to start test                :\n- *         :                                              wait(data.monitor)                             :\n- *         : <reentered>                                  :                                              :\n- *       }                                                :                                              :\n- *       \/\/ saw data.thread_state == WAITING              :                                              :\n- *     }                                                  :                                              :\n- *     \/\/ we don't enter loop in first call               :                                              :\n- *     while (data.thread_state != WAITING                :                                              :\n- *            data.thread_state != TERMINATED) {          :                                              :\n- *       \/\/ SP4.2-w - second wait for agent thread        :                                              :\n- *       wait(data.monitor)                               :                                              :\n- *     }                                                  :                                              :\n- *     if (data.thread_state != TERMINATED) {             :                                              :\n- *       data.thread_state = SUSPENDED                    :                                              :\n- *       \/\/ SP3.2-n - notify to start test                :                                              :\n- *       notify(data.monitor)                             :                                              :\n- *     }                                                  : <notified>                                   :\n- *     while (data.thread_state == SUSPENDED) {           :                                              :\n- *       \/\/ SP5.2-w - wait while testing                  :                                              :\n- *       wait(data.monitor)                               :                                              :\n- *       :                                                : <reentered>                                  :\n- *       :                                              }                                                :\n- *       :                                              \/\/ saw data.thread_state == SUSPENDED            :\n- *       :                                              exit(data.monitor)                               :\n- *       :                                            } \/\/ end waitForSync()                             :\n- *       :                                            SuspendThread(TestedThread-N)                      :\n- *       :                                            \/\/ SP5.1-n - notify suspend done                   : <thread suspended>\n- *       :                                            resumeSync() {                                     :\n- *       :                                              enter(data.monitor)                              :\n- *       :                                              if (data.thread_state == SUSPENDED) {            :\n- *       :                                                data.thread_state = RUNNABLE                   :\n- *       :                                                \/\/ SP5.2-n - notify suspend done               :\n- *       :                                                notify(data.monitor)                           :\n- *       : <notified>                                   }                                                :\n- *       :                                              exit(data.monitor)                               :\n- *       : <re-entered>                               } \/\/ end resumeSync()                              :\n- *     }                                              GetThreadState(TestedThread-N)                     :\n- *     \/\/ saw data.thread_state -= RUNNABLE           ResumeThread(TestedThread-N)                       : <thread resumed>\n- *     :                                              for (1..N_LATE_CALLS) {                            :\n- *   } \/\/ end checkStatus()                             SuspendThread(TestedThread-N)                    :\n- *   :                                                  :                                                : <thread suspended>\n- *   thr.letFinish()                                    ResumeThread(TestedThread-N)                     :\n- *     shouldFinish = true;                             :                                                : <thread resumed>\n- *   thr.join()                                         :                                                : <sees shouldFinish == true>\n- *   :                                                  :                                              }\n- *   :                                                  :                                              : <thread exits>\n- *   : <join() sees thread exit>                        : <SuspendThread sees thread exit & breaks>\n- *   \/\/ SP4.1-w - second wait for agent thread        }\n- *   \/\/ SP6.1-n - notify to end test                  :\n- *   \/\/ SP7.1 - wait for agent end                    :\n- *   checkStatus()                                    \/\/ SP4.1-n - notify agent is waiting and wait\n- *     enter(data.monitor)                            \/\/ SP6.1-w - wait to end test\n- *     :                                              waitForSync()\n- *     \/\/ we don't enter if-stmt in second call         enter(data.monitor)\n- *     if data.thread_state == NEW {                    : <blocked>\n- *     }                                                :\n- *     while (data.thread_state != WAITING              :\n- *            data.thread_state != TERMINATED) {        :\n- *       \/\/ SP4.2-w - second wait for agent thread      :\n- *       wait(data.monitor)                             :\n- *       :                                              : <enter>\n- *       :                                              data.thread_state = WAITING\n- *       :                                              \/\/ SP4.2-n - notify agent is waiting and wait\n- *       :                                              notify(data.monitor)\n- *       : <notified>                                   while (data.thread_state == WAITING) {\n- *       :                                                \/\/ SP6.2-w - wait to end test\n- *       :                                                wait(data.monitor)\n- *       : <reentered>                                    :\n- *     }                                                  :\n- *     \/\/ saw thread_state == WAITING                     :\n- *     if (data.thread_state != TERMINATED) {             :\n- *       data.thread_state = SUSPENDED                    :\n- *       \/\/ SP6.2-n - notify to end test                  :\n- *       notify(data.monitor)                             :\n- *     }                                                  : <notified>\n- *     while (data.thread_state == SUSPENDED) {           :\n- *       \/\/ SP7.2 - wait for agent end                    :\n- *       wait(data.monitor)                               :\n- *       :                                                : <reentered>\n- *       :                                              }\n- *       :                                              \/\/ saw data.thread_state == SUSPENDED\n- *       :                                              exit(data.monitor)\n- *       :                                            } \/\/ end waitForSync()\n- *       :                                            \/\/ SP7.1-n - notify agent end\n- *       :                                            resumeSync() {\n- *       :                                              enter(data.monitor)\n- *       :                                              if (data.thread_state == SUSPENDED) {\n- *       :                                                data.thread_state = RUNNABLE\n- *       :                                                \/\/ SP7.2-n - notify agent end\n- *       :                                                notify(data.monitor)\n- *       : <notified>                                   }\n- *       :                                              exit(data.monitor)\n- *       : <re-entered>                               } \/\/ end resumeSync()\n- *     }                                            } \/\/ end agentProc\n- *     \/\/ saw data.thread_state -= RUNNABLE         \/\/ this set is in the wrapper:\n- *   } \/\/ end checkStatus()                         data.thread_state = TERMINATED\n- *   resetAgentData() {\n- *     enter(data.monitor)\n- *     while (data.thread_state != TERMINATED) {\n- *       wait(data.monitor, 10);\n- *     }\n- *     data.thread_state = NEW\n- *     exit(data.monitor)\n- *   } \/\/ end resetAgentData()\n- *\n- * @library \/test\/lib\n- * @run main\/othervm\/native -Xlog:thread+smr=debug -agentlib:suspendthrd03=-waittime=5 suspendthrd03\n- *\/\n-\n-import jdk.test.lib.jvmti.DebugeeClass;\n-\n-public class suspendthrd03 extends DebugeeClass {\n-\n-    final static int N_THREADS = 10;\n-\n-    \/\/ load native library if required\n-    static {\n-        System.loadLibrary(\"suspendthrd03\");\n-    }\n-\n-    public static void main(String argv[]) {\n-        int result =  new suspendthrd03().runIt();\n-        if (result != 0) {\n-            throw new RuntimeException(\"check failed with result \" + result);\n-        }\n-    }\n-\n-    \/* =================================================================== *\/\n-    long timeout = 0;\n-    int status = DebugeeClass.TEST_PASSED;\n-\n-    \/\/ tested thread\n-    suspendthrd03Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt() {\n-        timeout = 60 * 1000; \/\/ milliseconds\n-\n-        for (int i = 0; i < N_THREADS; i++) {\n-            System.out.println(\"Starting TestedThread #\" + i + \".\");\n-\n-            \/\/ Original suspendthrd001 test block starts here:\n-            \/\/\n-            \/\/ create tested thread\n-            \/\/ Note: Cannot use TestedThread-N for thread name since\n-            \/\/ the agent has to know the thread's name.\n-            thread = new suspendthrd03Thread(\"TestedThread\");\n-\n-            \/\/ run tested thread\n-            System.out.println(\"Starting tested thread\");\n-            try {\n-                thread.start();\n-                \/\/ SP1-w - wait for TestedThread-N to be ready\n-                if (!thread.checkReady()) {\n-                    throw new RuntimeException(\"Unable to prepare tested thread: \" + thread);\n-                }\n-\n-                \/\/ testing sync\n-                System.out.println(\"Sync: thread started\");\n-                \/\/ SP2.1-w - wait for agent thread\n-                \/\/ SP3.1-n - notify to start test\n-                \/\/ SP5.1-w - wait while testing\n-                status = checkStatus(status);\n-            } finally {\n-                \/\/ let thread to finish\n-                thread.letFinish();\n-            }\n-\n-            \/\/ wait for thread to finish\n-            System.out.println(\"Finishing tested thread\");\n-            try {\n-                thread.join();\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-            \/\/ testing sync\n-            System.out.println(\"Sync: thread finished\");\n-            \/\/ SP4.1-w - second wait for agent thread\n-            \/\/ SP6.1-n - notify to end test\n-            \/\/ SP7.1 - wait for agent end\n-            status = checkStatus(status);\n-\n-            \/\/ Original suspendthrd001 test block ends here.\n-\n-            if (status != DebugeeClass.TEST_PASSED) {\n-                break;\n-            }\n-\n-            resetAgentData();  \/\/ reset for another iteration\n-        }\n-\n-        return status;\n-    }\n-}\n-\n-\/* =================================================================== *\/\n-\n-\/\/ basic class for tested threads\n-class suspendthrd03Thread extends Thread {\n-    private volatile boolean threadReady = false;\n-    private volatile boolean shouldFinish = false;\n-\n-    \/\/ make thread with specific name\n-    public suspendthrd03Thread(String name) {\n-        super(name);\n-    }\n-\n-    \/\/ run thread continuously\n-    public void run() {\n-        \/\/ run in a loop\n-        \/\/ SP1-n - tell main we are ready\n-        threadReady = true;\n-        int i = 0;\n-        int n = 1000;\n-        while (!shouldFinish) {\n-            if (n <= 0) {\n-                n = 1000;\n-            }\n-            if (i > n) {\n-                i = 0;\n-                n = n - 1;\n-            }\n-            i = i + 1;\n-        }\n-    }\n-\n-    \/\/ check if thread is ready\n-    public boolean checkReady() {\n-        try {\n-            while (!threadReady) {\n-                sleep(1000);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Interruption while preparing tested thread: \\n\\t\" + e);\n-        }\n-        return threadReady;\n-    }\n-\n-    \/\/ let thread to finish\n-    public void letFinish() {\n-        shouldFinish = true;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThread\/suspendthrd03\/suspendthrd03.java","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package xpath;\n+\n+\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+\/*\n+ * @test\n+ * @bug 8289509\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm xpath.XPathExpDescendantTest\n+ * @summary Tests for XPath descendant\/descendant-or-self axis specifier.\n+ *\/\n+public class XPathExpDescendantTest extends XPathTestBase {\n+\n+    \/*\n+     * DataProvider: provides XPath Axis descendant expressions and equivalent xpath expression.\n+     *\/\n+    @DataProvider(name = \"descendantXpath\")\n+    public Object[][] getDescendantXpathExpression() {\n+        return new Object[][] {\n+                {\"\/Customers\/descendant::*\", \"\/Customers\/\/*\"},\n+                {\"\/Customers\/descendant::Customer\", \"\/\/Customer\"},\n+                {\"\/Customers\/descendant::foo:Customer\", \"\/\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::Address\",\n+                        \"\/Customers\/Customer[@id='x1']\/Address\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::*\",\n+                        \"\/Customers\/Customer[@id='x1']\/\/*\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Address\/\/*\"},\n+                {\"\/Customers\/descendant::Name\", \"\/Customers\/\/Name\"},\n+                {\"\/Customers\/descendant::Street\", \"\/Customers\/\/Street\"},\n+                {\"\/Customers\/descendant::Street[2]\", \"Customers\/Customer[@id='x2']\/Address\/Street\"},\n+                {\"\/Customers\/descendant::Street[2]\", \"(Customers\/\/Street)[2]\"},\n+                {\"\/Customers\/descendant::Street[position() = 2]\",\n+                        \"Customers\/Customer[@id='x2']\/Address\/Street\"},\n+                {\"\/Customers\/descendant-or-self::*\", \"\/\/*\"},\n+                {\"\/Customers\/descendant-or-self::Customer\", \"\/Customers\/Customer\"},\n+                {\"\/Customers\/descendant-or-self::foo:Customer\", \"\/Customers\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::Address\",\n+                        \"\/Customers\/Customer[@id = 'x1']\/Address\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::*\",\n+                        \"\/Customers\/Customer[@id='x1'] | \/Customers\/Customer[@id = 'x1']\/\/*\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant-or-self::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Address | \/Customers\/foo:Customer\/foo:Address\/\/*\"},\n+                {\"\/Customers\/Customer\/*[descendant::Street]\", \"\/Customers\/Customer\/Address\"},\n+                {\"\/Customers\/Customer\/*[not(descendant::Street)]\", \"\/Customers\/Customer\/*[name() != \\\"Address\\\"]\"},\n+                {\"\/Customers\/Customer\/*[descendant-or-self::Street]\", \"\/Customers\/Customer\/Address\"},\n+                {\"\/Customers\/Customer\/*[not(descendant-or-self::Street)]\",\n+                        \"\/Customers\/Customer\/*[name() != \\\"Address\\\"]\"}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath descendant expressions and expected number of descendant nodes returned\n+     *\/\n+    @DataProvider(name = \"descendantXpathNodeCount\")\n+    public Object[][] getDescendantXpathExpressionNodeCount() {\n+        return new Object[][] {\n+                {\"\/Customers\/descendant::*\", 40},\n+                {\"\/Customers\/descendant::Customer\", 3},\n+                {\"\/Customers\/descendant::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::Address\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::*\", 9},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant::*\", 3},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/descendant::Address\", 0},\n+                {\"\/Customers\/descendant-or-self::*\", 41},\n+                {\"\/Customers\/descendant-or-self::Customer\", 3},\n+                {\"\/Customers\/descendant-or-self::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::Address\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/descendant-or-self::Address\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::*\", 10},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant-or-self::*\", 4},\n+                {\"\/Customers\/*[descendant::Name]\", 3},\n+                {\"\/Customers\/foo:Customer\/*[descendant-or-self::foo:Street]\", 1}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath descendant expressions which should return null.\n+     *\/\n+    @DataProvider(name = \"descendantXpathEmpty\")\n+    public Object[][] getDescendantXpathExpressionEmpty() {\n+        return new Object[][] {\n+                {\"\/Customers\/Customer\/Name\/descendant::*\"},\n+                {\"\/Customers\/foo:Customer\/descendant::Name\"},\n+                {\"\/Customers\/Customer\/descendant::foo:Name\"},\n+                {\"\/Customers\/descendant::id\"},\n+                {\"\/Customers\/Customer\/Name\/descendant-or-self::id\"},\n+                {\"\/Customers\/foo:Customer\/descendant-or-self::Name\"},\n+                {\"\/Customers\/Customer\/descendant-or-self::foo:Name\"},\n+                {\"\/Customers\/descendant-or-self::id\"}\n+        };\n+    }\n+\n+    \/**\n+     * Verifies descendant xpath expression returns same nodes as returns when used normal xpath expression\n+     * @param  descexp  descendant XPath expression.\n+     * @param  expath   normal xPath expression\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"descendantXpath\")\n+    public void descendantExpTests(String descexp, String expath) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList actualNodeList = (NodeList) xPath.evaluate(descexp, doc, XPathConstants.NODESET);\n+        NodeList expectedNodeList = (NodeList) xPath.evaluate(expath, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(actualNodeList.getLength(), expectedNodeList.getLength());\n+\n+        for(int i = 0; i < actualNodeList.getLength(); i++) {\n+            actualNodeList.item(i).equals(expectedNodeList.item(i));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies descendant xpath expression return descendant nodes list with correct number of nodes.\n+     * @param  exp       XPath expression.\n+     * @param  nodeCount number of descendant nodes in nodelist.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"descendantXpathNodeCount\")\n+    public void descendantNodesCountTests(String exp, int nodeCount) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList nodeList = (NodeList) xPath.evaluate(exp, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(nodeList.getLength(), nodeCount);\n+    }\n+\n+    \/**\n+     * Verifies descendant xpath expression return no nodes if descendant expression context nodes don't have matching descendants\n+     * @param  exp     XPath expression.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"descendantXpathEmpty\")\n+    public void DescendantScopeTests(String exp) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node node = xPath.evaluateExpression(exp, doc, Node.class);\n+        Assert.assertNull(node);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathExpDescendantTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package xpath;\n+\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+\/*\n+ * @test\n+ * @bug 8289509\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm xpath.XPathExpFollowingTest\n+ * @summary Tests for XPath following\/following-sibling axis specifier.\n+ *\/\n+public class XPathExpFollowingTest extends XPathTestBase {\n+    \/*\n+     * DataProvider: provides XPath Axis following expressions and equivalent xpath expression.\n+     *\/\n+    @DataProvider(name = \"followingXpath\")\n+    public Object[][] getFollowingXpathExpression() {\n+        return new Object[][] {\n+                {\"\/Customers\/following::*\", \"\/None\"},\n+                {\"\/Customers\/Customer\/following::Customer\", \"\/\/Customer[@id != 'x1']\"},\n+                {\"\/Customers\/Customer\/following::foo:Customer\", \"\/\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::Address\",\n+                        \"\/Customers\/Customer[@id != 'x1']\/Address\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::Street\",\n+                        \"\/Customers\/Customer[@id != 'x1']\/Address\/Street\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::Street[2]\",\n+                        \"\/Customers\/Customer[@id='x2']\/Address\/Street\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::*\",\n+                        \"\/Customers\/Customer[@id != 'x1']\/descendant-or-self::*\" +\n+                                \" | \/Customers\/foo:Customer\/descendant-or-self::*\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Age | \/Customers\/foo:Customer\/foo:ClubMember\"},\n+                {\"\/Customers\/Customer[@id = 'x1']\/*[following::Street]\", \"\/Customers\/Customer[@id = 'x1']\/*\"},\n+                {\"\/Customers\/foo:Customer\/*[following::foo:Name]\", \"\/None\"},\n+                {\"\/Customers\/foo:Customer\/*[not(following::foo:Name)]\", \"\/Customers\/foo:Customer\/*\"},\n+                {\"\/Customers\/following-sibling::*\", \"\/None\"},\n+                {\"\/Customers\/Customer\/following-sibling::Customer\",\n+                        \"\/Customers\/Customer[@id != 'x1']\"},\n+                {\"\/Customers\/Customer\/following-sibling::foo:Customer\",\n+                        \"\/Customers\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/Name\/following-sibling::Address\",\n+                        \"\/Customers\/Customer[@id='x1']\/Address\"},\n+                {\"\/Customers\/Customer\/Name\/following-sibling::Address\",\n+                        \"\/Customers\/\/Address\"},\n+                {\"(\/Customers\/Customer\/Address\/Street\/following-sibling::State)[3]\",\n+                        \"\/Customers\/Customer[@id='x3']\/Address\/State\"},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/Street\/following-sibling::*[2]\",\n+                        \"\/Customers\/Customer[@id='x3']\/Address\/State\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following-sibling::*\",\n+                        \"\/Customers\/Customer[@id != 'x1'] | \/Customers\/foo:Customer\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following-sibling::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Age | \/Customers\/foo:Customer\/foo:ClubMember\"},\n+                {\"\/Customers\/Customer[@id = 'x1']\/*[following-sibling::Street]\", \"\/None\"},\n+                {\"\/Customers\/foo:Customer\/*[following-sibling::foo:Address]\", \"\/Customers\/foo:Customer\/foo:Name |\" +\n+                        \"\/Customers\/foo:Customer\/foo:Phone | \/Customers\/foo:Customer\/foo:Email\"},\n+                {\"\/Customers\/foo:Customer\/*[not(following-sibling::foo:Address)]\", \"\/Customers\/foo:Customer\/foo:Age | \" +\n+                        \"\/Customers\/foo:Customer\/foo:ClubMember | \/Customers\/foo:Customer\/foo:Address\"}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath following expressions and expected number of following nodes returned\n+     *\/\n+    @DataProvider(name = \"followingXpathNodeCount\")\n+    public Object[][] getFollowingXpathExpressionNodeCount() {\n+        return new Object[][] {\n+                {\"\/Customers\/following::*\", 0},\n+                {\"\/Customers\/Customer\/following::*\", 30},\n+                {\"\/Customers\/Customer\/following::Customer\", 2},\n+                {\"\/Customers\/Customer\/following::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/Name\/following::*\", 38},\n+                {\"\/Customers\/Customer\/Address\/following::*\", 32},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following::*\", 2},\n+                {\"\/Customers\/foo:Customer\/foo:Name\/following::*\", 8},\n+                {\"\/Customers\/foo:Customer\/*[following::foo:Name]\", 0},\n+                {\"\/Customers\/foo:Customer\/*[not(following::foo:Name)]\", 6},\n+                {\"\/Customers\/following-sibling::*\", 0},\n+                {\"\/Customers\/Customer\/following-sibling::*\", 3},\n+                {\"\/Customers\/Customer\/following-sibling::Customer\", 2},\n+                {\"\/Customers\/Customer\/following-sibling::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/Name\/following-sibling::*\", 5},\n+                {\"\/Customers\/Customer\/Address\/following-sibling::*\", 6},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/following-sibling::*\", 2},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following-sibling::*\", 2},\n+                {\"\/Customers\/Customer[@id = 'x1']\/*[following-sibling::Street]\", 0},\n+                {\"\/Customers\/foo:Customer\/*[following-sibling::foo:Address]\", 3},\n+                {\"\/Customers\/foo:Customer\/*[not(following-sibling::foo:Address)]\", 3}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath following expressions which should not return any node.\n+     *\/\n+    @DataProvider(name = \"followingXpathEmpty\")\n+    public Object[][] getFollowingXpathExpressionEmpty() {\n+        return new Object[][] {\n+                {\"\/Customers\/following::*\"},\n+                {\"\/Customers\/foo:Customer\/following::*\"},\n+                {\"\/Customers\/Customer[@id = 'x3' ]\/following::Customer\"},\n+                {\"\/Customers\/following::id\"},\n+                {\"\/Customers\/Customer[@id = 'x3' ]\/following-sibling::Customer\"},\n+                {\"\/Customers\/foo:Customer\/following-sibling::*\"},\n+                {\"\/Customers\/Customer\/following-sibling::foo:Name\"},\n+                {\"\/Customers\/following-sibling::id\"}\n+        };\n+    }\n+\n+    \/**\n+     * Verifies Axis following xpath expression returns same nodes as returns when used normal xpath expression\n+     * @param  descexp  Axis following XPath expression.\n+     * @param  expath   normal xPath expression\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"followingXpath\")\n+    public void followingExpTests(String descexp, String expath) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList actualNodeList = (NodeList) xPath.evaluate(descexp, doc, XPathConstants.NODESET);\n+        NodeList expectedNodeList = (NodeList) xPath.evaluate(expath, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(actualNodeList.getLength(), expectedNodeList.getLength());\n+\n+        for(int i = 0; i < actualNodeList.getLength(); i++) {\n+            actualNodeList.item(i).equals(expectedNodeList.item(i));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies following xpath expression return following nodes list with correct number of nodes.\n+     * @param  exp       XPath expression.\n+     * @param  nodeCount number of following nodes in nodelist.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"followingXpathNodeCount\")\n+    public void followingNodesCountTests(String exp, int nodeCount) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList nodeList = (NodeList) xPath.evaluate(exp, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(nodeList.getLength(), nodeCount);\n+    }\n+\n+    \/**\n+     * Verifies following xpath expression return no nodes if following expression context nodes don't have matching following elements.\n+     * @param  exp     XPath expression.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"followingXpathEmpty\")\n+    public void FollowingScopeTests(String exp) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node node = xPath.evaluateExpression(exp, doc, Node.class);\n+        Assert.assertNull(node);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathExpFollowingTest.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -196,1 +196,1 @@\n-java\/awt\/TrayIcon\/ActionEventMask\/ActionEventMask.java 8150540 windows-all\n+java\/awt\/TrayIcon\/ActionEventMask\/ActionEventMask.java 8150540,8295300 windows-all,linux-all\n@@ -198,6 +198,6 @@\n-java\/awt\/TrayIcon\/ModalityTest\/ModalityTest.java 8150540 windows-all,macosx-all\n-java\/awt\/TrayIcon\/MouseEventMask\/MouseEventMaskTest.java 8150540 windows-all\n-java\/awt\/TrayIcon\/MouseMovedTest\/MouseMovedTest.java 8150540 windows-all\n-java\/awt\/TrayIcon\/SecurityCheck\/FunctionalityCheck\/FunctionalityCheck.java 8150540 windows-all\n-java\/awt\/TrayIcon\/TrayIconEventModifiers\/TrayIconEventModifiersTest.java 8150540 windows-all\n-java\/awt\/TrayIcon\/TrayIconEvents\/TrayIconEventsTest.java 8150540 windows-all\n+java\/awt\/TrayIcon\/ModalityTest\/ModalityTest.java 8150540,8295300 windows-all,macosx-all,linux-all\n+java\/awt\/TrayIcon\/MouseEventMask\/MouseEventMaskTest.java 8150540,8295300 windows-all,linux-all\n+java\/awt\/TrayIcon\/MouseMovedTest\/MouseMovedTest.java 8150540,8295300 windows-all,linux-all\n+java\/awt\/TrayIcon\/SecurityCheck\/FunctionalityCheck\/FunctionalityCheck.java 8150540,8295300 windows-all,linux-all\n+java\/awt\/TrayIcon\/TrayIconEventModifiers\/TrayIconEventModifiersTest.java 8150540,8295300 windows-all,linux-all\n+java\/awt\/TrayIcon\/TrayIconEvents\/TrayIconEventsTest.java 8150540,8295300 windows-all,linux-all\n@@ -510,1 +510,0 @@\n-java\/io\/BufferedInputStream\/TransferTo.java                     8294541 generic-all\n@@ -620,1 +619,0 @@\n-sun\/security\/ssl\/SSLSessionImpl\/NoInvalidateSocketException.java 8277970 linux-all,macosx-x64\n@@ -668,0 +666,1 @@\n+javax\/swing\/JRadioButton\/4314194\/bug4314194.java 8295006 linux-all\n@@ -752,1 +751,0 @@\n-jdk\/jfr\/event\/runtime\/TestActiveSettingEvent.java               8287832 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -613,2 +613,1 @@\n-    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java \\\n-    sun\/security\/tools\/keytool\/i18n.java\n+    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java\n@@ -618,1 +617,2 @@\n-    java\/util\/TimeZone\/DefaultTimeZoneTest.java\n+    java\/util\/TimeZone\/DefaultTimeZoneTest.java \\\n+    sun\/security\/tools\/keytool\/i18n.java\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+        String hashAlgorithm = null; \/\/ TLS1.2+ only\n@@ -97,0 +98,2 @@\n+            } else if (line.startsWith(\"km-hashalg:\")) {\n+                hashAlgorithm = data;\n@@ -122,1 +125,3 @@\n-                    KeyGenerator.getInstance(\"SunTlsKeyMaterial\", provider);\n+                        KeyGenerator.getInstance(minor == 3 ?\n+                                \"SunTls12KeyMaterial\" :\n+                                \"SunTlsKeyMaterial\", provider);\n@@ -125,0 +130,20 @@\n+                int prfHashLength, prfBlockSize;\n+\n+                if (hashAlgorithm != null) {\n+                    switch (hashAlgorithm) {\n+                        case \"SHA-256\":\n+                            prfHashLength = 32;\n+                            prfBlockSize = 64;\n+                            break;\n+                        case \"SHA-384\":\n+                            prfHashLength = 48;\n+                            prfBlockSize = 128;\n+                            break;\n+                        default:\n+                            throw new RuntimeException(\"Unexpected hashalg: \" +\n+                                    hashAlgorithm);\n+                    }\n+                } else {\n+                    prfHashLength = -1;\n+                    prfBlockSize = -1;\n+                }\n@@ -129,1 +154,1 @@\n-                        null, -1, -1);\n+                        hashAlgorithm, prfHashLength, prfBlockSize);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/TLS\/TestKeyMaterial.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3649,0 +3649,34 @@\n+km-master:  f1:05:15:45:33:be:50:d6:88:0b:03:bb:88:9b:ef:d4:3b:98:aa:40:13:71:3c:1c:d9:df:34:c7:50:75:ad:5c:0a:d4:fe:ed:d5:58:6b:ff:2b:ce:c6:12:bc:6b:7e:dc\n+km-major:   3\n+km-minor:   3\n+km-crandom: 42:f3:36:8e:9d:c9:69:3e:c1:8a:38:d3:e0:ec:2b:58:c2:e0:0c:de:4f:f3:af:51:d2:5c:bc:b2:c3:3b:1e:56\n+km-srandom: 42:f3:36:8e:fa:fd:23:3e:fd:f9:bc:88:3c:98:93:f3:c3:1d:9c:2a:4a:3b:02:a7:40:d4:64:04:59:e9:65:97\n+km-cipalg:  AES\n+km-hashalg: SHA-256\n+km-keylen:  16\n+km-explen:  0\n+km-ivlen:   4\n+km-maclen:  0\n+km-ccipkey: 60:7a:45:a9:6e:76:58:ea:d9:44:c5:25:f8:92:f1:26\n+km-scipkey: 42:c0:ed:75:a2:51:21:7c:50:74:9d:78:9a:f7:35:2b\n+km-civ:     a1:3c:3e:4a\n+km-siv:     85:ab:ee:70\n+km-cmackey: (null)\n+km-smackey: (null)\n+km-master:  f1:05:15:45:33:be:50:d6:88:0b:03:bb:88:9b:ef:d4:3b:98:aa:40:13:71:3c:1c:d9:df:34:c7:50:75:ad:5c:0a:d4:fe:ed:d5:58:6b:ff:2b:ce:c6:12:bc:6b:7e:dc\n+km-major:   3\n+km-minor:   3\n+km-crandom: 42:f3:36:8e:9d:c9:69:3e:c1:8a:38:d3:e0:ec:2b:58:c2:e0:0c:de:4f:f3:af:51:d2:5c:bc:b2:c3:3b:1e:56\n+km-srandom: 42:f3:36:8e:fa:fd:23:3e:fd:f9:bc:88:3c:98:93:f3:c3:1d:9c:2a:4a:3b:02:a7:40:d4:64:04:59:e9:65:97\n+km-cipalg:  AES\n+km-hashalg: SHA-384\n+km-keylen:  32\n+km-explen:  0\n+km-ivlen:   4\n+km-maclen:  0\n+km-ccipkey: 3c:03:17:61:1e:88:4a:aa:01:4c:ac:6c:f8:bb:91:c3:0e:ec:57:c7:bf:07:ff:eb:49:22:f9:80:12:64:72:2a\n+km-scipkey: f8:00:8e:b2:dc:25:98:f1:97:00:55:28:60:a3:65:da:42:89:18:bb:40:94:53:d2:75:2a:29:e5:aa:94:1d:7a\n+km-civ:     24:02:76:6f\n+km-siv:     3b:6d:33:5a\n+km-cmackey: (null)\n+km-smackey: (null)\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/TLS\/keymatdata.txt","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6777156\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"linux\")\n+ * @summary Verifies if user is not able to select \"..\/\" beyond\n+ * root file system.\n+ * @run main\/manual TestFileChooserDirectorySelection\n+ *\/\n+\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class TestFileChooserDirectorySelection {\n+    private static JFrame frame;\n+    private static final String INSTRUCTIONS =\n+            \"Double click on the \\\"..\/\\\" entry from directory list.\\n\\n\" +\n+            \"Repeat the same process till the current directory is root \" +\n+            \"i.e \\\" \/ \\\" .\\n\\n\" +\n+            \"If \\\" ..\/ \\\" option is not available at root directory\" +\n+            \", press Pass else Fail.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\n+                \"JFileChooser Test Instructions\", INSTRUCTIONS, 5, 8, 35);\n+        try {\n+            SwingUtilities.invokeAndWait(\n+                    TestFileChooserDirectorySelection::createAndShowUI);\n+            passFailJFrame.awaitAndCheck();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test File Chooser Directory Selection\");\n+        JFileChooser fileChooser = new JFileChooser();\n+        fileChooser.setControlButtonsAreShown(false);\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(\n+                frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.add(fileChooser);\n+        frame.setSize(500, 500);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/gtk\/TestFileChooserDirectorySelection.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -64,2 +64,2 @@\n- * @run testng\/othervm\/timeout=180 TransferTo\n- * @bug 8279283\n+ * @run testng\/othervm\/timeout=180 -Xmx1280m TransferTo\n+ * @bug 8279283 8294541\n","filename":"test\/jdk\/java\/io\/BufferedInputStream\/TransferTo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ * -XX:DisableIntrinsic=_float16ToFloat,_floatToFloat16 Binary16Conversion\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16Conversion.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.1 Binary16ConversionNaN\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ * -XX:DisableIntrinsic=_float16ToFloat,_floatToFloat16 Binary16ConversionNaN\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/* @test\n+ * @summary URL.openConnection can throw IOOBE\n+ * @bug 8282395\n+ *\/\n+\n+import java.net.MalformedURLException;\n+import java.net.Proxy;\n+import java.net.URL;\n+\n+public class B8282395 {\n+    public static void main(String[] args) throws Exception {\n+        boolean res = false;\n+        URL url = new URL(\"ftp:\/\/.:%@\");\n+        try {\n+            \/\/ Will throw IndexOutOfBoundsException if not fixed\n+            url.openConnection();\n+        } catch (MalformedURLException e) {\n+            res = true;\n+        }\n+        if (!res) {\n+            throw new RuntimeException(\"MalformedURLException should be thrown\");\n+        }\n+        res = false;\n+        try {\n+            \/\/ Will throw IndexOutOfBoundsException if not fixed\n+            url.openConnection(Proxy.NO_PROXY);\n+        } catch (MalformedURLException e) {\n+            res = true;\n+        }\n+        if (!res) {\n+            throw new RuntimeException(\"MalformedURLException should be thrown\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/URL\/B8282395.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-            Arrays.asList( NO_DURATION,   ofSeconds(1)  ),\n@@ -59,1 +58,0 @@\n-            Arrays.asList( NO_DURATION,   ofNanos(99)   ),\n@@ -62,1 +60,0 @@\n-            Arrays.asList( ofSeconds(1),  NO_DURATION   ),\n@@ -64,1 +61,0 @@\n-            Arrays.asList( ofNanos(99),   NO_DURATION   ),\n@@ -67,1 +63,0 @@\n-            Arrays.asList( ofSeconds(1),  ofMinutes(1)  ),\n@@ -69,1 +64,0 @@\n-            Arrays.asList( ofNanos(99),   ofMinutes(1)  ),\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractConnectTimeout.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,3 +71,1 @@\n-            Arrays.asList( NO_DURATION,   ofSeconds(1)  ),\n-            Arrays.asList( NO_DURATION,   ofSeconds(2)  ),\n-            Arrays.asList( NO_DURATION,   ofMillis(500) ),\n+            Arrays.asList( NO_DURATION,   ofMillis(100) ),\n@@ -75,3 +73,1 @@\n-            Arrays.asList( ofSeconds(1),  NO_DURATION   ),\n-            Arrays.asList( ofSeconds(2),  NO_DURATION   ),\n-            Arrays.asList( ofMillis(500), NO_DURATION   ),\n+            Arrays.asList( ofMillis(100), NO_DURATION   ),\n@@ -79,3 +75,1 @@\n-            Arrays.asList( ofSeconds(1),  ofMinutes(1)  ),\n-            Arrays.asList( ofSeconds(2),  ofMinutes(1)  ),\n-            Arrays.asList( ofMillis(500), ofMinutes(1)  )\n+            Arrays.asList( ofMillis(100), ofMinutes(1)  )\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractConnectTimeoutHandshake.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\n+\/**\n+ * @test\n+ * @bug 8292876\n+ * @library \/test\/lib server\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ * @run junit UserInfoTest\n+ *\/\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class UserInfoTest {\n+\n+    Http2TestServer server;\n+    int port;\n+    SSLContext sslContext;\n+\n+    @BeforeAll\n+    void before() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        server = createServer(sslContext);\n+        port = server.getAddress().getPort();\n+        server.start();\n+    }\n+\n+    @AfterAll\n+    void after() throws Exception {\n+        server.close();\n+    }\n+\n+    static class Http2TestHandler implements Http2Handler {\n+        @Override\n+        public void handle(Http2TestExchange e) throws IOException {\n+            String authorityHeader = e.getRequestHeaders().firstValue(\":authority\").orElse(null);\n+            if (authorityHeader == null || authorityHeader.contains(\"user@\")) {\n+                e.sendResponseHeaders(500, -1);\n+            } else {\n+                e.sendResponseHeaders(200, -1);\n+            }\n+        }\n+    }\n+\n+    private static Http2TestServer createServer(SSLContext sslContext) throws Exception {\n+        Http2TestServer http2TestServer = new Http2TestServer(\"localhost\", true, sslContext);\n+        Http2TestHandler handler = new Http2TestHandler();\n+        http2TestServer.addHandler(handler, \"\/\");\n+        return http2TestServer;\n+    }\n+\n+    @Test\n+    public void testAuthorityHeader() throws Exception {\n+        HttpClient client = HttpClient\n+                .newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .sslContext(sslContext)\n+                .build();\n+\n+        URI uri = URIBuilder.newBuilder()\n+                .scheme(\"https\")\n+                .userInfo(\"user\")\n+                .loopback()\n+                .port(port)\n+                .build();\n+\n+        HttpRequest request = HttpRequest\n+                .newBuilder(uri)\n+                .GET()\n+                .build();\n+\n+        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+        assertEquals(200, response.statusCode(), \"Test Failed : \" + response.uri().getAuthority());\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/UserInfoTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/**\n+ * @test\n+ * @bug 8295232\n+ * @summary Ensures java.locale.useOldISOCodes is statically initialized\n+ * @library \/test\/lib\n+ * @run main UseOldISOCodesTest\n+ *\/\n+import java.util.Locale;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class UseOldISOCodesTest {\n+    public static void main(String[] args) throws Exception {\n+        ProcessTools.executeTestJvm(\"-Djava.locale.useOldISOCodes=true\", \"UseOldISOCodesTest$Runner\")\n+                .outputTo(System.out)\n+                .errorTo(System.err)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    static class Runner {\n+        private static final String obsoleteCode = \"iw\";\n+        private static final String newCode = \"he\";\n+\n+        public static void main(String[] args) {\n+            System.setProperty(\"java.locale.useOldISOCodes\", \"false\");\n+            Locale locale = Locale.of(newCode);\n+            if(!obsoleteCode.equals(locale.getLanguage())){\n+                throw new RuntimeException(\"Expected that newcode mapped to old \");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/UseOldISOCodesTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-tzdata2022d\n+tzdata2022e\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-Asia\/Amman EET EEST\n@@ -102,1 +101,0 @@\n-Asia\/Damascus EET EEST\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/displaynames.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-   \n+\n","filename":"test\/jdk\/javax\/accessibility\/manual\/README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8288882\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"linux\")\n+ * @summary To test if the 1-Empty-File size shows 0.0 KB and other files show correct size.\n+ * @run main\/manual FileSizeCheck\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+\n+public class FileSizeCheck {\n+    private static Path[] tempFilePaths;\n+    private static final String INSTRUCTIONS =\n+            \"Click on the \\\"Details\\\" button in right-top corner.\\n\\n\" +\n+                    \"Scroll Down if required. \\n\\n\" +\n+                    \"Test 1: If the size of 1st-Empty-File shows 0.0 KB\\n\" +\n+                    \"Test 2: If the size of 2nd-File-1-Byte shows 0.1 KB\\n\" +\n+                    \"Test 3: If the size of 3rd-File-160-Byte shows 0.2 KB\\n\" +\n+                    \"Test 3: If the size of 4th-File-299-Byte shows 0.3 KB\\n\" +\n+                    \"Test 4: If the size of 5th-File-900-Byte shows 0.9 KB\\n\" +\n+                    \"Test 6: If the size of 6th-File-901-Byte shows 1.0 KB\\n\" +\n+                    \"Test 7: If the size of 7th-File-999-KB shows 999.0 KB\\n\" +\n+                    \"Test 8: If the size of 8th-File-1000-KB shows 1.0 MB\\n\" +\n+                    \"Test 9: If the size of 9th-File-2.8-MB shows 2.8 MB\\n\\n\" +\n+                           \"press PASS.\\n\\n\";\n+\n+    public static void test() {\n+        JFrame frame = new JFrame(\"JFileChooser File Size test\");\n+        JFileChooser fc = new JFileChooser();\n+        fc.setControlButtonsAreShown(false);\n+        Path dir = Paths.get(\".\");\n+        String[] tempFilesName = {\"1st-Empty-File\", \"2nd-File-1-Byte\", \"3rd-File-160-Byte\",\n+                \"4th-File-299-Byte\", \"5th-File-900-Byte\", \"6th-File-901-Byte\",\n+                \"7th-File-999-KB\", \"8th-File-1000-KB\", \"9th-File-2.8-MB\"};\n+\n+        int[] tempFilesSize = {0, 1, 160, 299, 900, 901, 999_000, 1_000_000, 2_800_000};\n+\n+        tempFilePaths = new Path[tempFilesName.length];\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+\n+        \/\/ Create temp files\n+        try {\n+            for (int i = 0; i < tempFilePaths.length; i++) {\n+                tempFilePaths[i] = dir.resolve(tempFilesName[i]);\n+                if (!Files.exists(tempFilePaths[i])){\n+                    RandomAccessFile f = new RandomAccessFile(tempFilePaths[i].toFile(), \"rw\");\n+                    f.setLength(tempFilesSize[i]);\n+                    f.close();\n+                }\n+            }\n+            fc.setCurrentDirectory(dir.toFile());\n+        } catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+        frame.add(fc);\n+        frame.pack();\n+        frame.setVisible(true);\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\"JFileChooser Test Instructions\",\n+                INSTRUCTIONS, 5, 19, 35);\n+        try {\n+            SwingUtilities.invokeAndWait(FileSizeCheck::test);\n+            passFailJFrame.awaitAndCheck();\n+        } finally {\n+            try {\n+                for (int i = 0; i < tempFilePaths.length; ++i) {\n+                    Files.deleteIfExists(tempFilePaths[i]);\n+                }\n+            } catch (IOException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileSizeCheck.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JFileChooser;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+\n+import javax.swing.filechooser.FileView;\n+\n+\/*\n+ * @test\n+ * @bug 6616245\n+ * @key headful\n+ * @requires (os.family == \"windows\" | os.family == \"linux\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test to check if NPE occurs when using custom FileView.\n+ * @run main\/manual FileViewNPETest\n+ *\/\n+public class FileViewNPETest {\n+    static PassFailJFrame passFailJFrame;\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            public void run() {\n+                try {\n+                    initialize();\n+                } catch (InterruptedException | InvocationTargetException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    static void initialize() throws InterruptedException, InvocationTargetException {\n+        JFrame frame;\n+        JFileChooser jfc;\n+\n+        \/\/Initialize the components\n+        final String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. The traversable folder is set to the Documents folder,\n+                 if it exists, in the user's home folder, otherwise\n+                 it's the user's home. Other folders are non-traversable.\n+                2. When the file chooser appears on the screen, select any\n+                 non-traversable folder from \"Look-In\" combo box,\n+                 for example the user's folder or a folder above it.\n+                 (The folder will not be opened since it's non-traversable).\n+                3. Select the Documents folder again.\n+                4. If NullPointerException does not occur in the step 3,\n+                 click Pass, otherwise the test fails automatically.\n+                \"\"\";\n+        frame = new JFrame(\"JFileChooser File View NPE test\");\n+        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS,\n+                5L, 13, 40);\n+        jfc = new JFileChooser();\n+\n+        String userHome = System.getProperty(\"user.home\");\n+        String docs = userHome + File.separator + \"Documents\";\n+        String path = (new File(docs).exists()) ? docs : userHome;\n+\n+        jfc.setCurrentDirectory(new File(path));\n+        jfc.setFileView(new CustomFileView(path));\n+        jfc.setControlButtonsAreShown(false);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+\n+        frame.add(jfc, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+}\n+\n+class CustomFileView extends FileView {\n+    private final String basePath;\n+\n+    public CustomFileView(String path) {\n+        basePath = path;\n+    }\n+\n+    public Boolean isTraversable(File filePath) {\n+        return ((filePath != null) && (filePath.isDirectory()))\n+                && filePath.getAbsolutePath().startsWith(basePath);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileViewNPETest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -75,0 +75,1 @@\n+        System.out.println(\"correctColoredPixels \" + correctColoredPixels + \" totalPixels \" + totalPixels);\n@@ -93,2 +94,2 @@\n-        checkBox = new JCheckBox(\"WWWWW\");\n-        radioButton = new JRadioButton(\"WWWWW\");\n+        checkBox = new JCheckBox(\"\\u2588\".repeat(5));\n+        radioButton = new JRadioButton(\"\\u2588\".repeat(5));\n","filename":"test\/jdk\/javax\/swing\/JRadioButton\/4314194\/bug4314194.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.nio.file.Path;\n@@ -27,0 +28,1 @@\n+import java.util.Set;\n@@ -30,1 +32,6 @@\n-import jdk.test.lib.Asserts;\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.SettingDefinition;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.assertFalse;\n@@ -34,1 +41,1 @@\n- * @summary Test enable\/disable event and verify recording has expected events.\n+ * @summary Test jdk.jfr.Event::shouldCommit()\n@@ -38,1 +45,1 @@\n- * @run main\/othervm -Xlog:jfr+event+setting=trace jdk.jfr.api.event.TestShouldCommit\n+ * @run main\/othervm jdk.jfr.api.event.TestShouldCommit\n@@ -40,1 +47,0 @@\n-\n@@ -43,33 +49,2 @@\n-    public static void main(String[] args) throws Exception {\n-        Recording rA = new Recording();\n-\n-        verifyShouldCommitFalse(); \/\/ No active recordings\n-\n-        rA.start();\n-        rA.enable(MyEvent.class).withoutThreshold(); \/\/ recA=all\n-        verifyShouldCommitTrue();\n-\n-        setThreshold(rA, 100); \/\/ recA=100\n-        verifyThreshold(100);\n-\n-        setThreshold(rA, 200); \/\/ recA=200\n-        verifyThreshold(200);\n-\n-        Recording rB = new Recording();\n-        verifyThreshold(200);  \/\/ recA=200, recB=not started\n-\n-        rB.start();\n-        verifyThreshold(200);  \/\/ recA=200, recB=not specified, settings from recA is used.\n-\n-        setThreshold(rB, 100); \/\/ recA=200, recB=100\n-        verifyThreshold(100);\n-\n-        setThreshold(rB, 300); \/\/ recA=200, recB=300\n-        verifyThreshold(200);\n-\n-        rA.disable(MyEvent.class); \/\/ recA=disabled, recB=300\n-\n-        verifyThreshold(300);\n-\n-        rB.disable(MyEvent.class); \/\/ recA=disabled, recB=disabled\n-        verifyShouldCommitFalse();\n+    private static class CatEvent extends Event {\n+    }\n@@ -77,2 +52,2 @@\n-        setThreshold(rA, 200); \/\/ recA=200, recB=disabled\n-        verifyThreshold(200);\n+    private static class DogEvent extends Event {\n+    }\n@@ -80,2 +55,2 @@\n-        rB.enable(MyEvent.class).withoutThreshold(); \/\/ recA=200, recB=all\n-        verifyShouldCommitTrue();\n+    private static class BirdEvent extends Event {\n+        public boolean isFlying;\n@@ -83,2 +58,5 @@\n-        setThreshold(rB, 100); \/\/ recA=200, recB=100\n-        verifyThreshold(100);\n+        @SettingDefinition\n+        public boolean fly(FlySetting control) {\n+            return control.shouldFly() == isFlying;\n+        }\n+    }\n@@ -86,2 +64,2 @@\n-        rB.stop(); \/\/ recA=200, recB=stopped\n-        verifyThreshold(200);\n+    private static class FlySetting extends SettingControl {\n+        private boolean shouldFly;\n@@ -89,2 +67,9 @@\n-        rA.stop(); \/\/ recA=stopped, recB=stopped\n-        verifyShouldCommitFalse();\n+        @Override\n+        public String combine(Set<String> settingValues) {\n+            for (String s : settingValues) {\n+                if (\"true\".equals(s)) {\n+                    return \"true\";\n+                }\n+            }\n+            return \"false\";\n+        }\n@@ -92,2 +77,3 @@\n-        rA.close();\n-        rB.close();\n+        public boolean shouldFly() {\n+            return shouldFly;\n+        }\n@@ -95,2 +81,4 @@\n-        verifyShouldCommitFalse();\n-    }\n+        @Override\n+        public void setValue(String settingValue) {\n+            shouldFly = \"true\".equals(settingValue);\n+        }\n@@ -98,2 +86,4 @@\n-    private static void setThreshold(Recording r, long millis) {\n-        r.enable(MyEvent.class).withThreshold(Duration.ofMillis(millis));\n+        @Override\n+        public String getValue() {\n+            return String.valueOf(shouldFly);\n+        }\n@@ -102,5 +92,6 @@\n-    private static void verifyThreshold(long threshold) throws Exception {\n-        \/\/ Create 2 events, with different sleep time between begin() and end()\n-        \/\/ First event ends just before threshold, the other just after.\n-        verifyThreshold(threshold-5, threshold);\n-        verifyThreshold(threshold+5, threshold);\n+    public static void main(String[] args) throws Exception {\n+        testEnablement();\n+        testThreshold();\n+        testCustomSetting();\n+        testWithoutEnd();\n+        testCommit();\n@@ -109,2 +100,3 @@\n-    private static void verifyThreshold(long sleepMs, long thresholdMs) throws Exception {\n-        MyEvent event = new MyEvent();\n+    private static void testEnablement() throws Exception {\n+        DogEvent b = new DogEvent();\n+        assertFalse(b.shouldCommit(), \"Expected false before recording is started\");\n@@ -112,3 +104,4 @@\n-        long beforeStartNanos = System.nanoTime();\n-        event.begin();\n-        long afterStartNanos = System.nanoTime();\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class);\n+            r.disable(DogEvent.class);\n+            r.start();\n@@ -116,1 +109,2 @@\n-        Thread.sleep(sleepMs);\n+            CatEvent c = new CatEvent();\n+            assertTrue(c.shouldCommit(), \"Expected true for enabled event\");\n@@ -118,3 +112,3 @@\n-        long beforeStopNanos = System.nanoTime();\n-        event.end();\n-        long afterStopNanos = System.nanoTime();\n+            DogEvent d = new DogEvent();\n+            assertFalse(d.shouldCommit(), \"Expected false for disabled event\");\n+        }\n@@ -122,1 +116,3 @@\n-        boolean actualShouldCommit = event.shouldCommit();\n+        CatEvent c = new CatEvent();\n+        assertFalse(c.shouldCommit(), \"Expected false after recording is stopped\");\n+    }\n@@ -124,1 +120,5 @@\n-        final long safetyMarginNanos = 2000000; \/\/ Allow an error of 2 ms. May have to be tuned.\n+    private static void testThreshold() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class).withThreshold(Duration.ofNanos(0));\n+            r.enable(DogEvent.class).withThreshold(Duration.ofDays(1));\n+            r.start();\n@@ -126,5 +126,5 @@\n-        \/\/Duration of event has been at least minDurationMicros\n-        long minDurationMicros = (beforeStopNanos - afterStartNanos - safetyMarginNanos) \/ 1000;\n-        \/\/Duration of event has been at most maxDurationMicros\n-        long maxDurationMicros = (afterStopNanos - beforeStartNanos + safetyMarginNanos) \/ 1000;\n-        Asserts.assertLessThanOrEqual(minDurationMicros, maxDurationMicros, \"Wrong min\/max duration. Test error.\");\n+            CatEvent c = new CatEvent();\n+            c.begin();\n+            Thread.sleep(1);\n+            c.end();\n+            assertTrue(c.shouldCommit(), \"Expected true if above threshold\");\n@@ -132,8 +132,5 @@\n-        long thresholdMicros = thresholdMs * 1000;\n-        Boolean shouldCommit = null;\n-        if (minDurationMicros > thresholdMicros) {\n-            shouldCommit = new Boolean(true);  \/\/ shouldCommit() must be true\n-        } else if (maxDurationMicros < thresholdMicros) {\n-            shouldCommit = new Boolean(false); \/\/ shouldCommit() must be false\n-        } else {\n-            \/\/ Too close to call. No checks are done since we are not sure of expected shouldCommit().\n+            DogEvent d = new DogEvent();\n+            d.begin();\n+            Thread.sleep(1);\n+            d.end();\n+            assertFalse(d.shouldCommit(), \"Expected false if below threshold\");\n@@ -141,0 +138,1 @@\n+    }\n@@ -142,13 +140,15 @@\n-        System.out.printf(\n-            \"threshold=%d, duration=[%d-%d], shouldCommit()=%b, expected=%s%n\",\n-            thresholdMicros, minDurationMicros, maxDurationMicros, actualShouldCommit,\n-            (shouldCommit!=null ? shouldCommit : \"too close to call\"));\n-\n-        try {\n-            if (shouldCommit != null) {\n-                Asserts.assertEquals(shouldCommit.booleanValue(), actualShouldCommit, \"Wrong shouldCommit()\");\n-            }\n-        } catch (Exception e) {\n-            System.out.println(\"Unexpected value of shouldCommit(). Searching for active threshold...\");\n-            searchThreshold(thresholdMs, 2000+thresholdMs);\n-            throw e;\n+    private static void testCustomSetting() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(BirdEvent.class).with(\"fly\", \"true\");\n+            r.start();\n+            BirdEvent b1 = new BirdEvent();\n+            b1.isFlying = false;\n+            b1.begin();\n+            b1.end();\n+            assertFalse(b1.shouldCommit(), \"Expected false if rejected by custom setting\");\n+\n+            BirdEvent b2 = new BirdEvent();\n+            b2.isFlying = true;\n+            b2.begin();\n+            b2.end();\n+            assertTrue(b2.shouldCommit(), \"Expected true if accepted by custom setting\");\n@@ -158,4 +158,5 @@\n-    \/\/ Sleeps until shouldCommit() is true, or give up. Used for logging.\n-    private static void searchThreshold(long expectedMs, long maxMs) throws Exception {\n-        long start = System.nanoTime();\n-        long stop = start + maxMs * 1000000;\n+    private static void testWithoutEnd() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class).withThreshold(Duration.ofDays(0));\n+            r.enable(DogEvent.class).withThreshold(Duration.ofDays(1));\n+            r.start();\n@@ -163,3 +164,4 @@\n-        MyEvent event = new MyEvent();\n-        event.begin();\n-        event.end();\n+            CatEvent c = new CatEvent();\n+            c.begin();\n+            Thread.sleep(1);\n+            assertTrue(c.shouldCommit(), \"Expected true when above threshold and end() not invoked\");\n@@ -167,1 +169,2 @@\n-        while (!event.shouldCommit() && System.nanoTime() < stop) {\n+            DogEvent d = new DogEvent();\n+            d.begin();\n@@ -169,1 +172,1 @@\n-            event.end();\n+            assertFalse(d.shouldCommit(), \"Expected false when below threshold and end() not invoked\");\n@@ -171,17 +174,0 @@\n-        long durationMicros = (System.nanoTime() - start) \/ 1000;\n-        long expectedMicros = expectedMs * 1000;\n-        System.out.printf(\"shouldCommit()=%b after %,d ms, expected %,d%n\", event.shouldCommit(), durationMicros, expectedMicros);\n-    }\n-\n-    private static void verifyShouldCommitFalse() {\n-        MyEvent event = new MyEvent();\n-        event.begin();\n-        event.end();\n-        Asserts.assertFalse(event.shouldCommit(), \"shouldCommit() expected false\");\n-    }\n-\n-    private static void verifyShouldCommitTrue() {\n-        MyEvent event = new MyEvent();\n-        event.begin();\n-        event.end();\n-        Asserts.assertTrue(event.shouldCommit(), \"shouldCommit() expected true\");\n@@ -190,1 +176,17 @@\n-    private static class MyEvent extends Event {\n+    private static void testCommit() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class);\n+            r.start();\n+            CatEvent c = new CatEvent();\n+            c.begin();\n+            Thread.sleep(1);\n+            c.end();\n+            if (c.shouldCommit()) {\n+                c.commit();\n+            }\n+            r.stop();\n+            Path file = Path.of(\"dump.jfr\");\n+            r.dump(file);\n+            boolean hasEvent = RecordingFile.readAllEvents(file).size() > 0;\n+            assertTrue(hasEvent, \"Expected event when using commit() after shouldCommit()\");\n+        }\n@@ -192,1 +194,0 @@\n-\n","filename":"test\/jdk\/jdk\/jfr\/api\/event\/TestShouldCommit.java","additions":125,"deletions":124,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -0,0 +1,1272 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @bug 8291226 8291638\n+ * @modules java.base\/sun.net:+open\n+ *          java.base\/sun.net.www.http:+open\n+ *          java.base\/sun.net.www:+open\n+ *          java.base\/sun.net.www.protocol.http:+open\n+ * @run main\/othervm KeepAliveTest 0\n+ * @run main\/othervm KeepAliveTest 1\n+ * @run main\/othervm KeepAliveTest 2\n+ * @run main\/othervm KeepAliveTest 3\n+ * @run main\/othervm KeepAliveTest 4\n+ * @run main\/othervm KeepAliveTest 5\n+ * @run main\/othervm KeepAliveTest 6\n+ * @run main\/othervm KeepAliveTest 7\n+ * @run main\/othervm KeepAliveTest 8\n+ * @run main\/othervm KeepAliveTest 9\n+ * @run main\/othervm KeepAliveTest 10\n+ * @run main\/othervm KeepAliveTest 11\n+ * @run main\/othervm KeepAliveTest 12\n+ * @run main\/othervm KeepAliveTest 13\n+ * @run main\/othervm KeepAliveTest 14\n+ * @run main\/othervm KeepAliveTest 15\n+ * @run main\/othervm KeepAliveTest 16\n+ * @run main\/othervm KeepAliveTest 17\n+ * @run main\/othervm KeepAliveTest 18\n+ * @run main\/othervm KeepAliveTest 19\n+ * @run main\/othervm KeepAliveTest 20\n+ * @run main\/othervm KeepAliveTest 21\n+ * @run main\/othervm KeepAliveTest 22\n+ * @run main\/othervm KeepAliveTest 23\n+ * @run main\/othervm KeepAliveTest 24\n+ * @run main\/othervm KeepAliveTest 25\n+ * @run main\/othervm KeepAliveTest 26\n+ * @run main\/othervm KeepAliveTest 27\n+ * @run main\/othervm KeepAliveTest 28\n+ * @run main\/othervm KeepAliveTest 29\n+ * @run main\/othervm KeepAliveTest 30\n+ * @run main\/othervm KeepAliveTest 31\n+ * @run main\/othervm KeepAliveTest 32\n+ * @run main\/othervm KeepAliveTest 33\n+ * @run main\/othervm KeepAliveTest 34\n+ * @run main\/othervm KeepAliveTest 35\n+ * @run main\/othervm KeepAliveTest 36\n+ * @run main\/othervm KeepAliveTest 37\n+ * @run main\/othervm KeepAliveTest 38\n+ * @run main\/othervm KeepAliveTest 39\n+ * @run main\/othervm KeepAliveTest 40\n+ * @run main\/othervm KeepAliveTest 41\n+ * @run main\/othervm KeepAliveTest 42\n+ * @run main\/othervm KeepAliveTest 43\n+ * @run main\/othervm KeepAliveTest 44\n+ * @run main\/othervm KeepAliveTest 45\n+ * @run main\/othervm KeepAliveTest 46\n+ * @run main\/othervm KeepAliveTest 47\n+ * @run main\/othervm KeepAliveTest 48\n+ * @run main\/othervm KeepAliveTest 49\n+ * @run main\/othervm KeepAliveTest 50\n+ * @run main\/othervm KeepAliveTest 51\n+ * @run main\/othervm KeepAliveTest 52\n+ * @run main\/othervm KeepAliveTest 53\n+ * @run main\/othervm KeepAliveTest 54\n+ * @run main\/othervm KeepAliveTest 55\n+ * @run main\/othervm KeepAliveTest 56\n+ * @run main\/othervm KeepAliveTest 57\n+ * @run main\/othervm KeepAliveTest 58\n+ * @run main\/othervm KeepAliveTest 59\n+ * @run main\/othervm KeepAliveTest 60\n+ * @run main\/othervm KeepAliveTest 61\n+ * @run main\/othervm KeepAliveTest 62\n+ * @run main\/othervm KeepAliveTest 63\n+ * @run main\/othervm KeepAliveTest 64\n+ * @run main\/othervm KeepAliveTest 65\n+ * @run main\/othervm KeepAliveTest 66\n+ * @run main\/othervm KeepAliveTest 67\n+ * @run main\/othervm KeepAliveTest 68\n+ * @run main\/othervm KeepAliveTest 69\n+ * @run main\/othervm KeepAliveTest 70\n+ * @run main\/othervm KeepAliveTest 71\n+ * @run main\/othervm KeepAliveTest 72\n+ * @run main\/othervm KeepAliveTest 73\n+ * @run main\/othervm KeepAliveTest 74\n+ * @run main\/othervm KeepAliveTest 75\n+ * @run main\/othervm KeepAliveTest 76\n+ * @run main\/othervm KeepAliveTest 77\n+ * @run main\/othervm KeepAliveTest 78\n+ * @run main\/othervm KeepAliveTest 79\n+ * @run main\/othervm KeepAliveTest 80\n+ * @run main\/othervm KeepAliveTest 81\n+ * @run main\/othervm KeepAliveTest 82\n+ * @run main\/othervm KeepAliveTest 83\n+ * @run main\/othervm KeepAliveTest 84\n+ * @run main\/othervm KeepAliveTest 85\n+ * @run main\/othervm KeepAliveTest 86\n+ * @run main\/othervm KeepAliveTest 87\n+ * @run main\/othervm KeepAliveTest 88\n+ * @run main\/othervm KeepAliveTest 89\n+ * @run main\/othervm KeepAliveTest 90\n+ * @run main\/othervm KeepAliveTest 91\n+ * @run main\/othervm KeepAliveTest 92\n+ * @run main\/othervm KeepAliveTest 93\n+ * @run main\/othervm KeepAliveTest 94\n+ * @run main\/othervm KeepAliveTest 95\n+ * @run main\/othervm KeepAliveTest 96\n+ * @run main\/othervm KeepAliveTest 97\n+ * @run main\/othervm KeepAliveTest 98\n+ * @run main\/othervm KeepAliveTest 99\n+ * @run main\/othervm KeepAliveTest 100\n+ * @run main\/othervm KeepAliveTest 101\n+ * @run main\/othervm KeepAliveTest 102\n+ * @run main\/othervm KeepAliveTest 103\n+ * @run main\/othervm KeepAliveTest 104\n+ * @run main\/othervm KeepAliveTest 105\n+ * @run main\/othervm KeepAliveTest 106\n+ * @run main\/othervm KeepAliveTest 107\n+ * @run main\/othervm KeepAliveTest 108\n+ * @run main\/othervm KeepAliveTest 109\n+ * @run main\/othervm KeepAliveTest 110\n+ * @run main\/othervm KeepAliveTest 111\n+ * @run main\/othervm KeepAliveTest 112\n+ * @run main\/othervm KeepAliveTest 113\n+ * @run main\/othervm KeepAliveTest 114\n+ * @run main\/othervm KeepAliveTest 115\n+ * @run main\/othervm KeepAliveTest 116\n+ * @run main\/othervm KeepAliveTest 117\n+ * @run main\/othervm KeepAliveTest 118\n+ * @run main\/othervm KeepAliveTest 119\n+ * @run main\/othervm KeepAliveTest 120\n+ * @run main\/othervm KeepAliveTest 121\n+ * @run main\/othervm KeepAliveTest 122\n+ * @run main\/othervm KeepAliveTest 123\n+ * @run main\/othervm KeepAliveTest 124\n+ * @run main\/othervm KeepAliveTest 125\n+ * @run main\/othervm KeepAliveTest 126\n+ * @run main\/othervm KeepAliveTest 127\n+ * @run main\/othervm KeepAliveTest 128\n+ * @run main\/othervm KeepAliveTest 129\n+ * @run main\/othervm KeepAliveTest 130\n+ * @run main\/othervm KeepAliveTest 131\n+ * @run main\/othervm KeepAliveTest 132\n+ * @run main\/othervm KeepAliveTest 133\n+ * @run main\/othervm KeepAliveTest 134\n+ * @run main\/othervm KeepAliveTest 135\n+ * @run main\/othervm KeepAliveTest 136\n+ * @run main\/othervm KeepAliveTest 137\n+ * @run main\/othervm KeepAliveTest 138\n+ * @run main\/othervm KeepAliveTest 139\n+ * @run main\/othervm KeepAliveTest 140\n+ * @run main\/othervm KeepAliveTest 141\n+ * @run main\/othervm KeepAliveTest 142\n+ * @run main\/othervm KeepAliveTest 143\n+ * @run main\/othervm KeepAliveTest 144\n+ * @run main\/othervm KeepAliveTest 145\n+ * @run main\/othervm KeepAliveTest 146\n+ * @run main\/othervm KeepAliveTest 147\n+ * @run main\/othervm KeepAliveTest 148\n+ * @run main\/othervm KeepAliveTest 149\n+ * @run main\/othervm KeepAliveTest 150\n+ * @run main\/othervm KeepAliveTest 151\n+ * @run main\/othervm KeepAliveTest 152\n+ * @run main\/othervm KeepAliveTest 153\n+ * @run main\/othervm KeepAliveTest 154\n+ * @run main\/othervm KeepAliveTest 155\n+ * @run main\/othervm KeepAliveTest 156\n+ * @run main\/othervm KeepAliveTest 157\n+ * @run main\/othervm KeepAliveTest 158\n+ * @run main\/othervm KeepAliveTest 159\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.io.InputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.Proxy.Type;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import sun.net.www.http.HttpClient;\n+import sun.net.www.http.KeepAliveCache;\n+import sun.net.www.protocol.http.HttpURLConnection;\n+import jdk.test.lib.net.URIBuilder;\n+\n+public class KeepAliveTest {\n+    private static final Logger logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n+    private static final String NOT_CACHED = \"NotCached\";\n+    private static final String CLIENT_SEPARATOR = \";\";\n+    private static final String NEW_LINE = \"\\r\\n\";\n+    private volatile int SERVER_PORT = 0;\n+    \/*\n+     * isProxySet is shared variable between server thread and client thread(main) and it should be set and reset to false for each and\n+     * every scenario.\n+     * isProxySet variable should be set by server thread before proceeding to client thread(main).\n+     *\/\n+    private volatile boolean isProxySet = false;\n+    private static final String CONNECTION_KEEP_ALIVE_ONLY = \"Connection: keep-alive\";\n+    private static final String PROXY_CONNECTION_KEEP_ALIVE_ONLY = \"Proxy-Connection: keep-alive\";\n+    private static final String KEEP_ALIVE_TIMEOUT_NEG = \"Keep-alive: timeout=-20\";\n+    private static final String KEEP_ALIVE_TIMEOUT_ZERO = \"Keep-alive: timeout=0\";\n+    private static final String KEEP_ALIVE_TIMEOUT = \"Keep-alive: timeout=20\";\n+    private static final String KEEP_ALIVE_PROXY_TIMEOUT = \"Keep-alive: timeout=120\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_NEGATIVE = \"http.keepAlive.time.server=-100\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_NEGATIVE = \"http.keepAlive.time.proxy=-200\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_ZERO = \"http.keepAlive.time.server=0\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_ZERO = \"http.keepAlive.time.proxy=0\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_POSITIVE = \"http.keepAlive.time.server=100\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_POSITIVE = \"http.keepAlive.time.proxy=200\";\n+    private static final String CONNECTION_KEEP_ALIVE_WITH_TIMEOUT = CONNECTION_KEEP_ALIVE_ONLY + NEW_LINE\n+        + KEEP_ALIVE_TIMEOUT;\n+   \/*\n+    * Following Constants represents Client Side Properties and is used as reference in below table as\n+    * CLIENT_INPUT_CONSTANT_NAMES\n+    *\/\n+    private static final String SERVER_100_NEGATIVE = CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_NEGATIVE;\n+    private static final String PROXY_200_NEGATIVE = CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_NEGATIVE;\n+    private static final String SERVER_ZERO = CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_ZERO;\n+    private static final String PROXY_ZERO = CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_ZERO;\n+    private static final String SERVER_100 = CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_POSITIVE;\n+    private static final String PROXY_200 = CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_POSITIVE;\n+\n+   \/*\n+    * CONSTANTS A,B,C,D,E,NI,F,G,H,I represents ServerScenarios and is used as reference in below table\n+    * as SERVER_RESPONSE_CONSTANT_NAME\n+    *\/\n+    private static final String A = CONNECTION_KEEP_ALIVE_ONLY;\n+    private static final String B = CONNECTION_KEEP_ALIVE_WITH_TIMEOUT;\n+    private static final String C = PROXY_CONNECTION_KEEP_ALIVE_ONLY;\n+    private static final String D = PROXY_CONNECTION_KEEP_ALIVE_ONLY + NEW_LINE + CONNECTION_KEEP_ALIVE_ONLY;\n+    private static final String E = C + NEW_LINE + KEEP_ALIVE_PROXY_TIMEOUT;\n+    private static final String NI = \"NO_INPUT\";\n+    private static final String F = A + NEW_LINE + KEEP_ALIVE_TIMEOUT_NEG;\n+    private static final String G = A + NEW_LINE + KEEP_ALIVE_TIMEOUT_ZERO;\n+    private static final String H = C + NEW_LINE + KEEP_ALIVE_TIMEOUT_NEG;\n+    private static final String I = C + NEW_LINE + KEEP_ALIVE_TIMEOUT_ZERO;\n+\n+   \/*\n+    * There are 160 scenarios run by this program.\n+    * For every scenario there is mapping between serverScenarios[int],clientScenarios[int] and expectedOutput[int]\n+    *\n+    * serverScenarios[0] clientScenarios[0] expectedOutput[0]\n+    * serverScenarios[1] clientScenarios[1] expectedOutput[1]\n+    * serverScenarios[2] clientScenarios[2] expectedOutput[2]\n+    *\n+    * ...\n+    *\n+    * serverScenarios[159] cientScenarios[159] expectedOutput[159]\n+    *\n+    * whereas serverScenarios[int] is retrieved using getServerScenario(int)\n+    * whereas clientScenarios[int] is retrieved using clientScenario[getClientScenarioNumber[int]]\n+    * and\n+    * expectedOutput[int] is retrieved using expectedOuput[int] directly.\n+    *\n+    *\/\n+\n+   \/* Here is the complete table of server_response, client system properties input and expected cached timeout at client side *\/\n+   \/* ScNo  |  SERVER RESPONSE (SERVER_RESPONSE_CONSTANT_NAME)| CLIENT SYSTEM PROPERTIES INPUT (CLIENT_INPUT_CONSTANT_NAMES) | EXPECTED CACHED TIMEOUT AT CLIENT SIDE\n+    *****************************************************************************************************************************************\n+    *    0  |  Connection: keep-alive (A)                     | No Input Provided (NI)                       | Default Timeout set to 5\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    1  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=100 (SERVER_100)| Client Timeout set to 100\n+    *--------------------------------------------------------------------------------------------------------------------------\n+    *    2  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.proxy=200 (PROXY_200)  | Default Timeout set to 5\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    3  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=100 &&          |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=200              | Timeout set to 100\n+    *       |                                                 | (SERVER_100 && PROXY_200)                    |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    4  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=-100            | Default Timeout set to 5\n+    *       |                                                 | (SERVER_100_NEGATIVE)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    5  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.proxy=-200             | Default Timeout set to 5\n+    *       |                                                 | (PROXY_200_NEGATIVE)                         |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    6  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=-100 &&         |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=-200             | Default Timeout set to 5\n+    *       |                                                 | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    7  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=0               | Connection Closed Immediately\n+    *       |                                                 | (SERVER_ZERO)                                |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    8  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.proxy=0                | Default Timeout set to 5\n+    *       |                                                 | (PROXY_ZERO)                                 |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    9  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=0 &&            |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=0                | Connection Closed Immediately\n+    *       |                                                 | (SERVER_ZERO && PROXY_ZERO)                  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   10  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=0 &&            |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=-200             | Connection Closed Immediately\n+    *       |                                                 | (SERVER_ZERO && PROXY_200_NEGATIVE)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   11  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=-100 &&         |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=0                | Default Timeout set to 5\n+    *       |                                                 | (SERVER_100_NEGATIVE && PROXY_ZERO)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   12  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=100 &&          |\n+    *       |                                                 |  -Dhttp.keepAlive.time.proxy=0               | Timeout set to 100\n+    *       |                                                 | (SERVER_100 && PROXY_ZERO)                   |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   13  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=0 &&            |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=200              | Connection Closed Immediately\n+    *       |                                                 | (SERVER_ZERO && PROXY_200)                   |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   14  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=100 &&          |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=-200             | Timeout set to 100\n+    *       |                                                 | (SERVER_100 && PROXY_200_NEGATIVE)           |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   15  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=-100 &&         |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=200              | Default Timeout set to 5\n+    *       |                                                 | (SERVER_100_NEGATIVE && PROXY_200)           |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   16  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | No Input Provided (NI)                   | Timeout set to 20\n+    *------------------------------------------------------------------------------------------------------------------------\n+    *   17  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=100         | Timeout set to 20\n+    *       |                                                     | (SERVER_100)                             |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   18  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.proxy=200          | Timeout set to 20\n+    *       |                                                     | (PROXY_200)                              |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   19  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=100 &&      |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=200          | Timeout set to 20\n+    *       |                                                     | (SERVER_100 && PROXY_200)                |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   20  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=-100        | Timeout set to 20\n+    *       |                                                     | (SERVER_100_NEGATIVE)                    |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   21  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.proxy=-200         | Timeout set to 20\n+    *       |                                                     | (PROXY_200_NEGATIVE)                     |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   22  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=-100 &&       |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=-200           | Timeout set to 20\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   23  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=0      | Timeout set to 20\n+    *       |                                                     | (SERVER_ZERO)                       |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   24  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 20\n+    *       |                                                     | (PROXY_ZERO)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   25  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 20\n+    *       |                                                     | (SERVER_ZERO && PROXY_ZERO)         |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   26  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=-200    | Timeout set to 20\n+    *       |                                                     | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   27  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 20\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   28  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 20\n+    *       |                                                     | (SERVER_100 && PROXY_ZERO)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   29  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 20\n+    *       |                                                     | (SERVER_ZERO && PROXY_200)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   30  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=-200    | Timeout set to 20\n+    *       |                                                     | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   31  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                     |-Dhttp.keepAlive.time.proxy=200      | Timeout set to 20\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   32  |Proxy-Connection: keep-alive (C)                     | No Input Provided (NI)              | Default timeout set to 60\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   33  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=100    | Default timeout set to 60\n+    *       |                                                     | (SERVER_100)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   34  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                     | (PROXY_200)                         |\n+    *--------------------------------------------------------------------------------------------------------------------------\n+    *   35  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                     | (SERVER_100 && PROXY_200)           |\n+    *--------------------------------------------------------------------------------------------------------------------------\n+    *   36  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=-100   | Default timeout set to 60\n+    *       |                                                     | (SERVER_100_NEGATIVE)               |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   37  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.proxy=-200    | Default timeout set to 60\n+    *       |                                                     | (PROXY_200_NEGATIVE)                |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   38  |Proxy-Connection: keep-alive (C)                     |-Dhttp.keepAlive.time.server=-100 &&       |\n+    *       |                                                     |-Dhttp.keepAlive.time.proxy=-200           | Default timeout set to 60\n+    *       |                                                     |(SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   39  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=0      | Default timeout set to 60\n+    *       |                                                     | (SERVER_ZERO)                       |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   40  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                     | (PROXY_ZERO)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   41  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                     | (SERVER_ZERO && PROXY_ZERO)         |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   42  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=-200    | Default timeout set to 60\n+    *       |                                                     | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   43  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   44  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                     | (SERVER_100 && PROXY_ZERO)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   45  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                     | (SERVER_ZERO && PROXY_200)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   46  |Proxy-Connection: keep-alive (C)                     |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                     |-Dhttp.keepAlive.time.proxy=-200     | Default timeout set to 60\n+    *       |                                                     | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   47  |Proxy-Connection: keep-alive (C)                     |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                     |-Dhttp.keepAlive.time.proxy=200      | Timeout set to 200\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   48  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | No Input Provided (NI)              | Default timeout set to 60\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   49  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=100    | Default timeout set to 60\n+    *       |                                                         | (SERVER_100)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   50  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                         | (PROXY_200)                         |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   51  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                         | (SERVER_100 && PROXY_200)           |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   52  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=-100   | Default timeout set to 60\n+    *       |                                                         | (SERVER_100_NEGATIVE)               |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   53  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.proxy=-200    | Default timeout set to 60\n+    *       |                                                         | (PROXY_200_NEGATIVE)                |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   54  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=-100&&        |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200           | Default timeout set to 60\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   55  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=0      | Default timeout set to 60\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   56  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   57  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   58  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | Default timeout set to 60\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   59  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   60  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   61  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   62  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | default timeout set to 60\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   63  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   64  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| No Input Provided (NI)              | Timeout set to 120\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   65  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=100    | Timeout set to 120\n+    *       |                                                         | (SERVER_100)                        |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   66  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.proxy=200     | Timeout set to 120\n+    *       |                                                         | (PROXY_200)                         |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   67  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 120\n+    *       |                                                         | (SERVER_100 && PROXY_200)           |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   68  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=-100   | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE)               |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   69  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.proxy=-200    | Timeout set to 120\n+    *       |                                                         | (PROXY_200_NEGATIVE)                |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   70  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=-100 &&       |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200           | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   71  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=0      | Timeout set to 120\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   72  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.proxy=0       | Timeout set to 120\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   73  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 120\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   74  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | Timeout set to 120\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   75  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   76  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 120\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   77  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 120\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   78  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=100 &&         |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200            | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE) |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   79  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   80  |No Input (NI)                                            | No Input Provided (NI)              | default timeout set to 5\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   81  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=100    | Timeout set to 100\n+    *       |                                                         | (SERVER_100)                        |\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   82  |No Input (NI)                                            | -Dhttp.keepAlive.time.proxy=200     | default timeout set to 5\n+    *       |                                                         | (PROXY_200)                         |\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   83  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | client timeot set to 100\n+    *       |                                                         | (SERVER_100 && PROXY_200)           |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   84  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=-100   | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE)               |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   85  |No Input (NI)                                            | -Dhttp.keepAlive.time.proxy=-200    | default timeout set to 5\n+    *       |                                                         | (PROXY_200_NEGATIVE)                |\n+    *----------------------------------------------------------------------------------------------------------------------------\n+    *   86  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=-100 &&       |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200           | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   87  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=0      | close connection immediately\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   88  |No Input (NI)                                            | -Dhttp.keepAlive.time.proxy=0       | default timeout set to 5\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   89  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   90  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   91  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   92  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 100\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   93  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   94  |No Input (NI)                                            |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200     | Timeout set to 100\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   95  |No Input (NI)                                            |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200      | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   96  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    | No Input Provided (NI)              | default timeout set to 5\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   97  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=100     | Timeout set to 100\n+    *       |                                                         | (SERVER_100)                        |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   98  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.proxy=200      | default timeout set to 5\n+    *       |                                                         | (PROXY_200)                         |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *   99  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200      | Timeout set to 100\n+    *       |                                                         |(SERVER_100 && PROXY_200)            |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  100  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=-100    | default timeout set to 5\n+    *       |                                                         |(SERVER_100_NEGATIVE)                |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  101  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.proxy=-200     | default timeout set to 5\n+    *       |                                                         |(PROXY_200_NEGATIVE)                 |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  102  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=-100 &&        |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200            | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  103  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  104  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.proxy=0        | default timeout set to 5\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  105  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=0 &&    |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  106  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=0 &&    |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200     | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO_NEGATIVE)|\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  107  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=0        | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  108  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=0        | Timeout set to 100\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  109  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=0 &&    |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200      | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  110  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200     | Timeout set to 100\n+    *       |                                                         |(SERVER_100 && PROXY_200_NEGATIVE)   |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  111  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200      | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  112  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | No Input Provided (NI)              | close connection immediately\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  113  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=100    | close connection immediately\n+    *       |                                                         | (SERVER_100)                        |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  114  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (PROXY_200)                         |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  115  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_200)           |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  116  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=-100   | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE)               |\n+    *------------------------------------------------------------------------------------------------------------------------------------\n+    *  117  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.proxy=-200    | close connection immediately\n+    *       |                                                         | (PROXY_200_NEGATIVE)                |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  118  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      |-Dhttp.keepAlive.time.server=-100 &&         |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200             | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE) |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  119  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=0      | close connection immediately\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  120  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *------------------------------------------------------------------------------------------------------------------------------------\n+    *  121  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  122  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  123  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  124  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  125  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  126  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  127  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  128  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| No Input Provided (NI)                | default timeout set to 60\n+    ---------------------------------------------------------------------------------------------------------------------------------------\n+    *  129  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=100      | default timeout set to 60\n+    *       |                                                         | (SERVER_100)                          |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  130  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.proxy=200       | Timeout set to 200\n+    *       |                                                         | (PROXY_200)                           |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  131  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | Timeout set to 200\n+    *       |                                                         | (SERVER_100 && PROXY_200)             |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  132  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=-100     | default timeout set to 60\n+    *       |                                                         | (SERVER_100_NEGATIVE)                 |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  133  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.proxy=-200      | default timeout set to 60\n+    *       |                                                         | (PROXY_200_NEGATIVE)                  |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  134  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)|-Dhttp.keepAlive.time.server=-100 &&        |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200            | default timeout set to 60\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *  135  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=0        | default timeout set to 60\n+    *       |                                                         | (SERVER_ZERO)                         |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  136  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (PROXY_ZERO)                          |\n+    *----------------------------------------------------------------------------------------------------------------------------------\n+    *  137  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)           |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  138  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200      | default timeout set to 60\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE)   |\n+    *---------------------------------------------------------------------------------------------------------------------------------------\n+    *  139  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=-100 &&  |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO)   |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  140  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)            |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  141  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | Timeout set to 20\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)            |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  142  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)|-Dhttp.keepAlive.time.server=100 &&    |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200       | default timeout set to 60\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)    |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  143  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)|-Dhttp.keepAlive.time.server=-100 &&   |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200        | Timeout set to 200\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)    |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  144  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | No Input Provided (NI)                | close connection immediately\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  145  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=100      | close connection immediately\n+    *       |                                                         | (SERVER_100)                          |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  146  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.proxy=200       | close connection immediately\n+    *       |                                                         | (PROXY_200)                           |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  147  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_200)             |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  148  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=-100     | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE)                 |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  149  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.proxy=-200      | close connection immediately\n+    *       |                                                         | (PROXY_200_NEGATIVE)                  |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  150  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=-100 &&        |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200            | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE) |\n+    *------------------------------------------------------------------------------------------------------------------------------------\n+    *  151  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=0        | close connection immediately\n+    *       |                                                         | (SERVER_ZERO)                         |\n+    *-----------------------------------------------------------------------------------------------------------------------------------\n+    *  152  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (PROXY_ZERO)                          |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *  153  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)           |\n+    *------------------------------------------------------------------------------------------------------------------------------------\n+    *  154  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200      | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE)   |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  155  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=-100 &&  |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO)   |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  156  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)            |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  157  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)            |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  158  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200      | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)    |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  159  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=-100 &&  |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)    |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *\/\n+\n+   \/* private static final String[] serverScenarios = {\n+        A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A,\n+        B, B, B, B, B, B, B, B, B, B,B, B, B, B, B, B,\n+        C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C,\n+        D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D,\n+        E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E,\n+        NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI,\n+        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,\n+        G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\n+        H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H,\n+        I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I\n+    }; *\/\n+    \/*\n+     * following are client scenarios which are repeated.\n+     *\/\n+    private static final String[] a = {\n+        NI, SERVER_100,     PROXY_200, SERVER_100 + CLIENT_SEPARATOR + PROXY_200,    SERVER_100_NEGATIVE,\n+        PROXY_200_NEGATIVE, SERVER_100_NEGATIVE + CLIENT_SEPARATOR + PROXY_200_NEGATIVE,\n+        SERVER_ZERO,         PROXY_ZERO, SERVER_ZERO + CLIENT_SEPARATOR + PROXY_ZERO,\n+        SERVER_ZERO + CLIENT_SEPARATOR + PROXY_200_NEGATIVE, SERVER_100_NEGATIVE + CLIENT_SEPARATOR + PROXY_ZERO,\n+        SERVER_100 + CLIENT_SEPARATOR + PROXY_ZERO, SERVER_ZERO + CLIENT_SEPARATOR + PROXY_200,\n+        SERVER_100 + CLIENT_SEPARATOR + PROXY_200_NEGATIVE, SERVER_100_NEGATIVE + CLIENT_SEPARATOR + PROXY_200\n+    };\n+\n+   \/* private String[] clientScenarios = {\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+    }; *\/\n+\n+    private static final String[] clientScenarios = {\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]\n+    };\n+\n+    private static final int[] expectedValues = {\n+        5,  100,    5, 100,  5,  5,  5,  0,  5,   0,   0,   5,  100,    0,   100,    5,\n+        20,   20 ,  20,  20, 20, 20, 20, 20, 20,  20 , 20,  20,   20,   20,    20,   20,\n+        60,   60,  200, 200, 60, 60, 60, 60,  0,   0,  60,   0,    0,  200,    60,  200,\n+        60,   60,  200, 200, 60, 60, 60, 60,  0,   0,  60,   0,    0,  200,    60,  200,\n+        120, 120,  120, 120,120,120,120,120,120, 120, 120, 120,  120,  120,   120,  120,\n+        5,  100,    5, 100,  5,  5,  5,  0,  5,   0,   0,   5,  100,    0,   100,    5,\n+        5,  100,    5, 100,  5,  5,  5,  0,  5,   0,   0,   5,  100,    0,   100,    5,\n+        0,    0,    0,   0,  0,  0,  0,  0,  0,   0,   0,   0,    0,    0,     0,    0,\n+        60,  60,  200, 200, 60, 60, 60, 60,  0,   0,  60,   0,    0,  200,    60,  200,\n+        0,    0,    0,   0,  0,  0,  0,  0,  0,   0,   0,   0,    0,    0,     0,    0,\n+    };\n+\n+    private final CountDownLatch countDownLatch = new CountDownLatch(1);\n+\n+    private final CountDownLatch serverCountDownLatch = new CountDownLatch(1);\n+\n+    \/*\n+     * setting of client properties -Dhttp.keepAlive.time.server and -Dhttp.keepAlive.time.proxy is handled through this method.\n+     * There are 16 client scenarios in total starting with scenarioNumber 0(zero) and ending with 15.\n+     * Server Scenarios are grouped into batch of 16 scenarios.\n+     * There are 10 batches in total and each batch contains 16 scenarios so 10 * 16 = 160 scenarios in total.\n+     * 16 Client Scenarios are used repeatedly for every server scenario batch.\n+     * for serverscenario[0],serverscenario[16],serverscenario[32] ... serverscenario[144] is mapped to clientscenario[0]\n+     * for serverscenario[1],serverscenario[17],serverscenario[33] ... serverscenario[145] is mapped to clientscenario[1]\n+     * for serverscenario[2],serverscenario[18],serverscenario[34] ... serverscenario[146] is mapped to clientscenario[2]\n+     * ...\n+     * for serverscenario[15],serverscenario[31],serverscenario[47] ... serverscenario[159] is mapped to clientscenario[15]\n+     *\/\n+    private int getClientScenarioNumber(int scenarioNumber) {\n+        return scenarioNumber % 16 ;\n+    }\n+\n+    \/*\n+     * Returns SERVER_RESPONSE as String based on integer inputParameter scenarioNumber.\n+     * Server Scenarios are grouped into batch of 16 scenarios starting with scenarioNumber 0 (zero)\n+     * so there are 10 batches in total and each batch contains 16 scenarios so 10 * 16 = 160 scenarios in total.\n+     * For each batch of 16 scenarios, there will be common SERVER_RESPONSE for all 16 scenarios in batch.\n+     * for scenario numbers from 0 to 15 server  response is: Connection:keep-alive\n+     * for scenario numbers from 16 to 31 server response is: SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=20\n+     * for scenario numbers from 32 to 47 server response is: SERVER_RESPONSE=Proxy-Connection: keep-alive\n+     * for scenario numbers from 48 to 63 server response is: SERVER_RESPONSE=Connection:keep-alive\\r\\nProxy-connection:keep-alive\n+     * for scenario numbers from 64 to 79 server response is: SERVER_RESPONSE=Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120\n+     * for scenario numbers from 80 to 95 server response is: SERVER_RESPONSE=No Input\n+     * for scenario numbers from 96 to 111 server response is: SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=-20\n+     * for scenario numbers from 112 to 127 server resonse is: Connection: keep-alive\\r\\nKeep-alive: timeout=0\n+     * for scenario numbers from 128 to 143 server response is: Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=-20\n+     * for scenario numbers from 144 to 159 server response is: Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=0\n+     *\/\n+    private String getServerScenario(int scenarioNumber) {\n+        \/*\n+         *  ServerResponse for scenarios from 0 to 15\n+         *  SERVER_RESPONSE:Connection:keep-alive\n+         *\/\n+        if(scenarioNumber >= 0 && scenarioNumber <= 15) {\n+            return A;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 16 to 31\n+         * SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=20\n+         *\/\n+        else if (scenarioNumber >= 16 && scenarioNumber <= 31){\n+            return B;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 32 to 47\n+         * SERVER_RESPONSE=Proxy-Connection: keep-alive\n+         *\/\n+        else if (scenarioNumber >= 32 && scenarioNumber <= 47){\n+            return C;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 48 to 63\n+         * SERVER_RESPONSE=Connection:keep-alive\\r\\nProxy-connection:keep-alive\n+         *\/\n+        else if (scenarioNumber >= 48 && scenarioNumber <= 63){\n+            return D;\n+        \/*\n+         * ServerResponse for scenarios from 64 to 79\n+         * SERVER_RESPONSE=Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120\n+         *\/\n+        } else if (scenarioNumber >= 64 && scenarioNumber <= 79){\n+            return E;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 80 to 95\n+         * SERVER_RESPONSE=No Input\n+         *\/\n+        else if (scenarioNumber >= 80 && scenarioNumber <= 95){\n+            return NI;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 96 to 111\n+         * SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=-20\n+         *\/\n+        else if (scenarioNumber >= 96 && scenarioNumber <= 111){\n+            return F;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 112 to 127\n+         * SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=0\n+         *\/\n+        else if (scenarioNumber >= 112 && scenarioNumber <= 127){\n+            return G;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 128 to 143\n+         * SERVER_RESPONSE=Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=-20\n+         *\/\n+        else if (scenarioNumber >= 128 && scenarioNumber <= 143){\n+            return H;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 144 to 159\n+         * SERVER_RESPONSE=Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=0\n+         *\/\n+        else if (scenarioNumber >= 144 && scenarioNumber <= 159){\n+            return I;\n+        }\n+        \/*Invalid Case*\/\n+        return null;\n+    }\n+\n+    private void startScenario(int scenarioNumber) throws Exception {\n+        System.out.println(\"serverScenarios[\" + scenarioNumber + \"]=\" + getServerScenario(scenarioNumber));\n+        System.out.println(\"clientScenarios[\" + scenarioNumber + \"]=\" + clientScenarios[getClientScenarioNumber(scenarioNumber)]);\n+        if(expectedValues[scenarioNumber] == 0) {\n+            System.out.println(\"ExpectedOutput=\" + NOT_CACHED);\n+        } else {\n+            System.out.println(\"ExpectedOutput=\" + expectedValues[scenarioNumber]);\n+        }\n+        System.out.println();\n+        startServer(scenarioNumber);\n+        runClient(scenarioNumber);\n+    }\n+\n+    private void startServer(int scenarioNumber) {\n+        Thread server = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                   executeServer(scenarioNumber);\n+                } catch (IOException e) {\n+                   e.printStackTrace();\n+                }\n+            }\n+        }, \"SERVER\");\n+        server.start();\n+    }\n+\n+    private void readAll(Socket s) throws IOException {\n+        byte[] buf = new byte[128];\n+        int c;\n+        String request = \"\";\n+        InputStream is = s.getInputStream();\n+        while ((c = is.read(buf)) > 0) {\n+            request += new String(buf, 0, c, StandardCharsets.US_ASCII);\n+            if (request.contains(\"\\r\\n\\r\\n\")) {\n+                return;\n+            }\n+        }\n+        if (c == -1) {\n+            throw new IOException(\"Socket closed\");\n+        }\n+    }\n+\n+    private void executeServer(int scenarioNumber) throws IOException {\n+        String serverScenarioContent = null;\n+        if (!getServerScenario(scenarioNumber).equalsIgnoreCase(NI)) {\n+            serverScenarioContent = getServerScenario(scenarioNumber) + NEW_LINE;\n+            \/*\n+             * isProxySet should be set before Server is moved to Listen State.\n+             *\/\n+            if (serverScenarioContent.contains(\"Proxy\")) {\n+                isProxySet = true;\n+            } else {\n+                isProxySet = false;\n+            }\n+        }\n+        ServerSocket serverSocket = null;\n+        Socket socket = null;\n+        OutputStreamWriter out = null;\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        try {\n+            serverSocket = new ServerSocket();\n+            serverSocket.bind(new InetSocketAddress(loopback, 0));\n+            SERVER_PORT = serverSocket.getLocalPort();\n+            \/\/serverReady = true;\n+            this.serverCountDownLatch.countDown();\n+            System.out\n+                .println(\"SERVER_PORT= \" + SERVER_PORT +\" isProxySet=\" + isProxySet);\n+            \/*\n+             * Server will be waiting for clients to connect.\n+             *\/\n+            socket = serverSocket.accept();\n+            readAll(socket);\n+            out = new OutputStreamWriter(socket.getOutputStream());\n+            String BODY = \"SERVER REPLY: Hello world\";\n+            String CLEN = \"Content-Length: \" + BODY.length() + NEW_LINE;\n+            \/* send the header *\/\n+            out.write(\"HTTP\/1.1 200 OK\\r\\n\");\n+            out.write(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+            \/*\n+             * append each scenario content from array.\n+             *\/\n+            if(serverScenarioContent != null) {\n+                out.write(serverScenarioContent);\n+            }\n+            out.write(CLEN);\n+            out.write(NEW_LINE);\n+            out.write(BODY);\n+            out.flush();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        } finally {\n+            if (out != null) {\n+                out.flush();\n+                out.close();\n+            }\n+            if (socket != null) {\n+                socket.close();\n+            }\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+            }\n+        }\n+    }\n+\n+    private void runClient(int scenarioNumber) throws Exception {\n+        try {\n+            connectToServerURL(scenarioNumber);\n+        } finally {\n+            System.out.println(\"client count down latch:\" + scenarioNumber);\n+            this.countDownLatch.countDown();\n+            System.out.println();\n+            System.out.println();\n+        }\n+    }\n+\n+    private void connectToServerURL(int scenarioNumber) throws Exception {\n+        \/\/    System.setProperty(\"java.net.useSystemProxies\", \"false\");\n+        \/\/    System.setProperty(\"http.nonProxyHosts\", \"\");\n+        \/\/    System.setProperty(\"http.proxyHost\", \"localhost\");\n+        \/\/    System.setProperty(\"http.proxyPort\", String.valueOf(SERVER_PORT));\n+        System.out.println(\"Following are Existing System Properties if set any\");\n+        System.out.println(\"http.keepAlive.time.server:\" + System.getProperty(\"http.keepAlive.time.server\"));\n+        System.out.println(\"http.keepAlive.time.proxy:\" + System.getProperty(\"http.keepAlive.time.proxy\"));\n+        System.setProperty(\"java.net.useSystemProxies\", \"false\");\n+        System.out.println(\"http.proxyPort:\"+System.getProperty(\"http.proxyPort\"));\n+        System.out.println(\"http.proxyHost:\"+System.getProperty(\"http.proxyHost\"));\n+        System.clearProperty(\"http.keepAlive.time.server\");\n+        System.clearProperty(\"http.keepAlive.time.proxy\");\n+        \/\/ fetch clientScenearios for each scenarioNumber from array and set it to\n+        \/\/ System property.\n+        if (!clientScenarios[getClientScenarioNumber(scenarioNumber)].equalsIgnoreCase(NI)) {\n+            System.out.println(\"Client Input Parsing\");\n+            for (String clientScenarioString : clientScenarios[getClientScenarioNumber(scenarioNumber)].split(CLIENT_SEPARATOR)) {\n+                System.out.println(clientScenarioString);\n+                String key = clientScenarioString.split(\"=\")[0];\n+                String value = clientScenarioString.split(\"=\")[1];\n+                System.setProperty(key, value);\n+            }\n+        }\n+        \/\/ wait until ServerSocket moves to listening state.\n+        this.serverCountDownLatch.await();\n+        System.out.println(\"client started\");\n+        URL url = URIBuilder.newBuilder().scheme(\"http\").loopback().port(SERVER_PORT).toURL();\n+        System.out.println(\"connecting from client to SERVER URL:\" + url);\n+        HttpURLConnection httpUrlConnection = null;\n+        \/*\n+         * isProxySet is set to true when Expected Server Response contains Proxy-Connection header.\n+         *\/\n+        if (isProxySet) {\n+            httpUrlConnection = (sun.net.www.protocol.http.HttpURLConnection) url\n+                .openConnection(new Proxy(Type.HTTP, new InetSocketAddress(\"localhost\", SERVER_PORT)));\n+        } else {\n+            httpUrlConnection = (sun.net.www.protocol.http.HttpURLConnection) url.openConnection();\n+        }\n+        InputStreamReader inputStreamReader = new InputStreamReader(httpUrlConnection.getInputStream());\n+        BufferedReader bufferedReader = null;\n+        try {\n+            bufferedReader = new BufferedReader(inputStreamReader);\n+            while (true) {\n+                String eachLine = bufferedReader.readLine();\n+                if (eachLine == null) {\n+                    break;\n+                }\n+                System.out.println(eachLine);\n+            }\n+        } finally {\n+            if (bufferedReader != null) {\n+                bufferedReader.close();\n+            }\n+        }\n+        \/\/    System.out.println(\"ResponseCode:\" + httpUrlConnection.getResponseCode());\n+        \/\/    System.out.println(\"ResponseMessage:\" + httpUrlConnection.getResponseMessage());\n+        \/\/    System.out.println(\"Content:\" + httpUrlConnection.getContent());\n+        \/\/    Thread.sleep(2000);\n+        for (Entry<String, List<String>> header : httpUrlConnection.getHeaderFields().entrySet()) {\n+            System.out.println(header.getKey() + \"=\" + header.getValue());\n+        }\n+        fetchInfo(scenarioNumber, httpUrlConnection);\n+    }\n+\n+    private void fetchInfo(int scenarioNumber, sun.net.www.protocol.http.HttpURLConnection httpUrlConnection)\n+        throws Exception {\n+       Field field = Class.forName(\"sun.net.www.protocol.http.HttpURLConnection\").getDeclaredField(\"http\");\n+       field.setAccessible(true);\n+       HttpClient httpClient = (HttpClient) field.get(httpUrlConnection);\n+       \/\/    System.out.println(\"httpclient=\" + httpClient);\n+       Field keepAliveField = Class.forName(\"sun.net.www.http.HttpClient\").getDeclaredField(\"kac\");\n+       keepAliveField.setAccessible(true);\n+       KeepAliveCache keepAliveCache = (KeepAliveCache) keepAliveField.get(httpClient);\n+       System.out.println(\"keepAliveCache\" + keepAliveCache);\n+       System.out.println(\"SERVER URL:\" + httpUrlConnection.getURL());\n+       \/*\n+        * create KeepAliveKey(URL,Object) object and compare created KeepAliveKey and\n+        * existing using equals() method: KeepAliveKey.equals()\n+        *\/\n+       Class keepAliveKeyClass = Class.forName(\"sun.net.www.http.KeepAliveKey\");\n+       \/\/    System.out.println(\"keepAliveKeyClass=\" + keepAliveKeyClass);\n+       Constructor keepAliveKeyClassconstructor = keepAliveKeyClass.getDeclaredConstructors()[0];\n+       keepAliveKeyClassconstructor.setAccessible(true);\n+       Object expectedKeepAliveKey = keepAliveKeyClassconstructor.newInstance(httpUrlConnection.getURL(), null);\n+       System.out.println(\"ExpectedKeepAliveKey=\" + expectedKeepAliveKey);\n+       Object clientVectorObjectInMap = keepAliveCache.get(expectedKeepAliveKey);\n+       System.out.println(\"ClientVector=\" + clientVectorObjectInMap);\n+       HttpClient httpClientCached = keepAliveCache.get(httpUrlConnection.getURL(), null);\n+       System.out.println(\"HttpClient in Cache:\" + httpClientCached);\n+       if(httpClientCached != null) {\n+            System.out.println(\"KeepingAlive:\" + httpClientCached.isKeepingAlive());\n+            System.out.println(\"UsingProxy:\" + httpClientCached.getUsingProxy());\n+            System.out.println(\"ProxiedHost:\" + httpClientCached.getProxyHostUsed());\n+            System.out.println(\"ProxiedPort:\" + httpClientCached.getProxyPortUsed());\n+            System.out.println(\"ProxyPortUsingSystemProperty:\" + System.getProperty(\"http.proxyPort\"));\n+            System.out.println(\"ProxyHostUsingSystemProperty:\" + System.getProperty(\"http.proxyHost\"));\n+            System.out.println(\"http.keepAlive.time.server=\" + System.getProperty(\"http.keepAlive.time.server\"));\n+            System.out.println(\"http.keepAlive.time.proxy=\" + System.getProperty(\"http.keepAlive.time.proxy\"));\n+            Class clientVectorClass = Class.forName(\"sun.net.www.http.ClientVector\");\n+            \/\/      System.out.println(\"clientVectorClass=\" + clientVectorClass);\n+            Field napField = clientVectorClass.getDeclaredField(\"nap\");\n+            napField.setAccessible(true);\n+            int napValue = (int) napField.get(clientVectorObjectInMap);\n+            int actualValue = napValue \/ 1000;\n+            \/\/      System.out.println(\"nap=\" + napValue \/ 1000);\n+            System.out.printf(\"ExpectedOutput:%d ActualOutput:%d \", expectedValues[scenarioNumber], actualValue);\n+            System.out.println();\n+            if (expectedValues[scenarioNumber] != actualValue) {\n+                throw new RuntimeException(\n+                            \"ExpectedOutput:\" + expectedValues[scenarioNumber] + \" ActualOutput: \" + actualValue);\n+            }\n+        } else {\n+            \/\/executed when value is not cached.\n+            String expected = expectedValues[scenarioNumber] == 0 ? NOT_CACHED\n+                    : String.valueOf(expectedValues[scenarioNumber]);\n+            System.out.println(\"ExpectedOutput:\" + expected + \" ActualOutput:\" + NOT_CACHED);\n+            if (!expected.equalsIgnoreCase(NOT_CACHED)) {\n+                    throw new RuntimeException(\"ExpectedOutput:\" + expected + \" ActualOutput:\" + NOT_CACHED);\n+            }\n+       }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Usage:java KeepAliveTest.java <scenarioNumber>\");\n+        }\n+        logger.setLevel(Level.FINEST);\n+        ConsoleHandler h = new ConsoleHandler();\n+        h.setLevel(Level.FINEST);\n+        logger.addHandler(h);\n+        KeepAliveTest keepAliveTest = new KeepAliveTest();\n+        if (args.length != 0) {\n+            keepAliveTest.startScenario(Integer.valueOf(args[0]));\n+        }\n+        \/\/ make main thread wait until server and client is completed.\n+        keepAliveTest.countDownLatch.await();\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/KeepAliveTest.java","additions":1272,"deletions":0,"binary":false,"changes":1272,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6316539 8136355\n+ * @bug 6316539 8136355 8294906\n@@ -80,0 +80,1 @@\n+            String hashAlgorithm = null; \/\/ TLS1.2+ only\n@@ -113,0 +114,2 @@\n+                } else if (line.startsWith(\"km-hashalg:\")) {\n+                    hashAlgorithm = data;\n@@ -138,1 +141,3 @@\n-                        KeyGenerator.getInstance(\"SunTlsKeyMaterial\", provider);\n+                        KeyGenerator.getInstance(minor == 3 ?\n+                                \"SunTls12KeyMaterial\" :\n+                                \"SunTlsKeyMaterial\", provider);\n@@ -141,0 +146,1 @@\n+                    \/\/ prfHashLength and prfBlockSize are ignored by PKCS11 provider\n@@ -145,1 +151,1 @@\n-                        null, -1, -1);\n+                        hashAlgorithm, -1 \/*ignored*\/, -1 \/*ignored*\/);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/TestKeyMaterial.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3649,0 +3649,34 @@\n+km-master:  f1:05:15:45:33:be:50:d6:88:0b:03:bb:88:9b:ef:d4:3b:98:aa:40:13:71:3c:1c:d9:df:34:c7:50:75:ad:5c:0a:d4:fe:ed:d5:58:6b:ff:2b:ce:c6:12:bc:6b:7e:dc\n+km-major:   3\n+km-minor:   3\n+km-crandom: 42:f3:36:8e:9d:c9:69:3e:c1:8a:38:d3:e0:ec:2b:58:c2:e0:0c:de:4f:f3:af:51:d2:5c:bc:b2:c3:3b:1e:56\n+km-srandom: 42:f3:36:8e:fa:fd:23:3e:fd:f9:bc:88:3c:98:93:f3:c3:1d:9c:2a:4a:3b:02:a7:40:d4:64:04:59:e9:65:97\n+km-cipalg:  AES\n+km-hashalg: SHA-256\n+km-keylen:  16\n+km-explen:  0\n+km-ivlen:   4\n+km-maclen:  0\n+km-ccipkey: 60:7a:45:a9:6e:76:58:ea:d9:44:c5:25:f8:92:f1:26\n+km-scipkey: 42:c0:ed:75:a2:51:21:7c:50:74:9d:78:9a:f7:35:2b\n+km-civ:     a1:3c:3e:4a\n+km-siv:     85:ab:ee:70\n+km-cmackey: (null)\n+km-smackey: (null)\n+km-master:  f1:05:15:45:33:be:50:d6:88:0b:03:bb:88:9b:ef:d4:3b:98:aa:40:13:71:3c:1c:d9:df:34:c7:50:75:ad:5c:0a:d4:fe:ed:d5:58:6b:ff:2b:ce:c6:12:bc:6b:7e:dc\n+km-major:   3\n+km-minor:   3\n+km-crandom: 42:f3:36:8e:9d:c9:69:3e:c1:8a:38:d3:e0:ec:2b:58:c2:e0:0c:de:4f:f3:af:51:d2:5c:bc:b2:c3:3b:1e:56\n+km-srandom: 42:f3:36:8e:fa:fd:23:3e:fd:f9:bc:88:3c:98:93:f3:c3:1d:9c:2a:4a:3b:02:a7:40:d4:64:04:59:e9:65:97\n+km-cipalg:  AES\n+km-hashalg: SHA-384\n+km-keylen:  32\n+km-explen:  0\n+km-ivlen:   4\n+km-maclen:  0\n+km-ccipkey: 3c:03:17:61:1e:88:4a:aa:01:4c:ac:6c:f8:bb:91:c3:0e:ec:57:c7:bf:07:ff:eb:49:22:f9:80:12:64:72:2a\n+km-scipkey: f8:00:8e:b2:dc:25:98:f1:97:00:55:28:60:a3:65:da:42:89:18:bb:40:94:53:d2:75:2a:29:e5:aa:94:1d:7a\n+km-civ:     24:02:76:6f\n+km-siv:     3b:6d:33:5a\n+km-cmackey: (null)\n+km-smackey: (null)\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/keymatdata.txt","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @bug 8274736\n+ * @bug 8274736 8277970\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/NoInvalidateSocketException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 4348369 8076069\n- * @summary keytool not i18n compliant\n+ * @bug 4348369 8076069 8294994\n+ * @summary keytool i18n compliant\n@@ -29,1 +29,3 @@\n- * @run main\/manual i18n\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @run main\/manual\/othervm -Duser.language=en i18n\n@@ -32,1 +34,323 @@\n-import java.nio.file.Path;\n+\/*\n+ * @test\n+ * @bug 4348369 8076069 8294994\n+ * @summary keytool i18n compliant\n+ * @author charlie lai\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @run main\/manual\/othervm -Duser.language=de i18n\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4348369 8076069 8294994\n+ * @summary keytool i18n compliant\n+ * @author charlie lai\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @run main\/manual\/othervm -Duser.language=ja i18n\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4348369 8076069 8294994\n+ * @summary keytool i18n compliant\n+ * @author charlie lai\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @run main\/manual\/othervm -Duser.language=zh -Duser.country=CN i18n\n+ *\/\n+\n+import jdk.test.lib.UIBuilder;\n+\n+import javax.swing.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.Locale;\n+\n+public class i18n {\n+    private static final String[][] TABLE = new String[][]{\n+            {\"-help\", \"All the output in this test should be in ${LANG}. \"\n+                    + \"Otherwise, the test failed.\"},\n+\n+            {\"-genkeypair -keyalg DSA -v -keysize 512 \"\n+                    + \"-dname cn=Name,ou=Java,o=Oracle,l=City,s=State,c=Country \"\n+                    + \"-storepass a \"\n+                    + \"-keypass a \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang.Exception: \"\n+                            + \"Keystore password must be at least 6 characters.\"},\n+\n+            {\"-genkeypair -keyalg DSA -v -keysize 512 \"\n+                    + \"-dname cn=Name,ou=Java,o=Oracle,l=City,s=State,c=Country \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: generated a 512 bit DSA key pair \"\n+                            + \"for CN=Name, OU=Java, O=Oracle, L=City, ST=State \"\n+                            + \"C=Country.\"},\n+\n+            {\"-list -v -storepass password -keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: contains 1 keystore entry with \"\n+                            + \"512-bit DSA key algorithm for CN=Name, OU=Java, \"\n+                            + \"O=Oracle, L=City, ST=State C=Country.\"},\n+\n+            {\"-list -v -storepass a -keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error:java.io.IOException: \"\n+                            + \"keystore password was incorrect.\"},\n+\n+            {\"-genkey -keyalg DSA -v -keysize 512 \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang.Exception: \"\n+                            + \"alias 'mykey' already exists.\"},\n+\n+            {\"-genkeypair -keyalg DSA -v -keysize 512 \"\n+                    + \"-dname cn=Name,ou=Java,o=Oracle,l=City,s=State,c=Country \"\n+                    + \"-alias mykey2 \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: generated a 512 bit DSA key pair \"\n+                            + \"for CN=Name, OU=Java, O=Oracle, L=City, ST=State \"\n+                            + \"C=Country.\"},\n+\n+            {\"-list -v -storepass password -keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: contains 2 keystore entries \"\n+                            + \"(alias name mykey & mykey2), both with 512-bit DSA\"\n+                            + \" key algorithm for CN=Name, OU=Java, O=Oracle, \"\n+                            + \"L=City, ST=State C=Country.\"},\n+\n+            {\"-keypasswd -v \"\n+                    + \"-alias mykey2 \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-new a \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang.Exception: \"\n+                            + \"New password must be at least 6 characters.\"},\n+\n+            {\"-keypasswd -v \"\n+                    + \"-alias mykey2 \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-new aaaaaa \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: -keypasswd \"\n+                            + \"commands not supported if -storetype is PKCS12.\"},\n+\n+            {\"-genkeypair -keyalg DSA -v -keysize 512 \"\n+                    + \"-dname cn=Name,ou=Java,o=Oracle,l=City,s=State,c=Country \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.jks \"\n+                    + \"-storetype JKS\",\n+                    \"Output in ${LANG}. Check: generated a 512 bit DSA key pair \"\n+                            + \"with a JKS warning.\"},\n+\n+            {\"-keypasswd -v \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-new aaaaaa \"\n+                    + \"-keystore .\/i18n.jks\",\n+                    \"Output in ${LANG}. Check: storing i18n.jks with a JKS warning.\"},\n+\n+            {\"-selfcert -v -alias mykey \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: generated a new certificate \"\n+                            + \"(self-signed).\"},\n+\n+            {\"-list -v -storepass password -keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: contains 2 keystore entries \"\n+                            + \"(alias name mykey & mykey2), both with 512-bit DSA\"\n+                            + \" key algorithm for CN=Name, OU=Java, O=Oracle, \"\n+                            + \"L=City, ST=State C=Country.\"},\n+\n+            {\"-export -v -alias mykey \"\n+                    + \"-file backup.keystore \"\n+                    + \"-storepass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: certificate stored in file <backup\"\n+                            + \".keystore>.\"},\n+\n+            {\"-import -v \"\n+                    + \"-file backup.keystore \"\n+                    + \"-storepass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: reply and certificate \"\n+                            + \"in keystore are identical.\"},\n+\n+            {\"-printcert -file backup.keystore\",\n+                    \"Output in ${LANG}. Check: 512 bit DSA key pair for CN=Name,\"\n+                            + \" OU=Java, O=Oracle, L=City, ST=State C=Country.\"},\n+\n+            {\"-list -storepass password -keystore .\/i18n.keystore \"\n+                    + \"-addprovider SUN\",\n+                    \"Output in ${LANG}. Check: contains 2 keystore entries \"\n+                            + \"(alias name mykey & mykey2).\"},\n+\n+            {\"-storepasswd \"\n+                    + \"-storepass password \"\n+                    + \"-new a \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang.Exception: \"\n+                            + \"New password must be at least 6 characters.\"},\n+\n+            {\"-storepasswd \"\n+                    + \"-storetype PKCS11 \"\n+                    + \"-keystore NONE\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".UnsupportedOperationException: -storepasswd and \"\n+                            + \"-keypasswd commands not supported if -storetype is\"\n+                            + \" PKCS11.\"},\n+\n+            {\"-keypasswd \"\n+                    + \"-storetype PKCS11 \"\n+                    + \"-keystore NONE\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".UnsupportedOperationException: -storepasswd and \"\n+                            + \"-keypasswd commands not supported if -storetype is\"\n+                            + \" PKCS11.\"},\n+\n+            {\"-list -protected \"\n+                    + \"-storepass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".IllegalArgumentException: if -protected is \"\n+                            + \"specified, then -storepass, -keypass, and -new \"\n+                            + \"must not be specified.\"},\n+\n+            {\"-keypasswd -protected \"\n+                    + \"-storepass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".IllegalArgumentException: if -protected is \"\n+                            + \"specified, then -storepass, -keypass, and -new \"\n+                            + \"must not be specified.\"},\n+\n+            {\"-keypasswd -protected \"\n+                    + \"-storepass password \"\n+                    + \"-new aaaaaa \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".IllegalArgumentException: if -protected is \"\n+                            + \"specified, then -storepass, -keypass, and -new \"\n+                            + \"must not be specified.\"},\n+    };\n+    private static String TEST_SRC = System.getProperty(\"test.src\");\n+    private static int TIMEOUT_MS = 120000;\n+    private volatile boolean failed = false;\n+    private volatile boolean aborted = false;\n+    private Thread currentThread = null;\n+\n+    public static void executeKeytool(String command) throws Exception {\n+        sun.security.tools.keytool.Main.main(command.split(\"\\\\s+\"));\n+    }\n+\n+    public static void main(String[] args) {\n+        final String lang = System.getProperty(\"user.language\");\n+        final String country = System.getProperty(\"user.country\");\n+\n+        if (lang != null) {\n+            if (country != null) {\n+                Locale.setDefault(Locale.of(lang, country));\n+            } else {\n+                Locale.setDefault(Locale.of(lang));\n+            }\n+        }\n+\n+        final String displayName = Locale.getDefault().getDisplayName();\n+\n+        boolean testFailed = false;\n+        i18n i18nTest = new i18n();\n+\n+        for (String[] entry : TABLE) {\n+            String command = entry[0].replaceAll(\"\\\\$\\\\{TEST_SRC\\\\}\", TEST_SRC);\n+            String instruction = entry[1].replaceAll(\"\\\\$\\\\{LANG\\\\}\", displayName);\n+\n+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+\n+            doKeytool(command, new PrintStream(buffer, true));\n+\n+            testFailed |= i18nTest.validate(command, instruction, buffer.toString());\n+        }\n+\n+        if (testFailed) {\n+            throw new RuntimeException(\"One or more tests failed.\");\n+        }\n+    }\n+\n+    public static void doKeytool(String command, PrintStream dest) {\n+        \/\/ Backups stdout and stderr.\n+        PrintStream origStdOut = System.out;\n+        PrintStream origErrOut = System.err;\n+\n+        \/\/ Redirects the system output to a custom one.\n+        System.setOut(dest);\n+        System.setErr(dest);\n+\n+        try {\n+            executeKeytool(\"-debug \" + command);\n+        } catch (Exception e) {\n+            \/\/ Do nothing.\n+        } finally {\n+            System.setOut(origStdOut);\n+            System.setErr(origErrOut);\n+        }\n+    }\n+\n+    public boolean validate(String command, String instruction, String message) {\n+        failed = false;\n+        currentThread = Thread.currentThread();\n+        JDialog dialog = new UIBuilder.DialogBuilder()\n+                .setTitle(\"keytool \" + command)\n+                .setInstruction(instruction)\n+                .setMessage(message)\n+                .setPassAction(e -> pass())\n+                .setFailAction(e -> fail())\n+                .setCloseAction(() -> abort())\n+                .build();\n+\n+        SwingUtilities.invokeLater(() -> {\n+            try {\n+                dialog.setVisible(true);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        try {\n+            Thread.sleep(TIMEOUT_MS);\n+            \/\/Timed out, so fail the test\n+            throw new RuntimeException(\n+                    \"Timed out after \" + TIMEOUT_MS \/ 1000 + \" seconds\");\n+        } catch (InterruptedException e) {\n+            if (aborted) {\n+                throw new RuntimeException(\"TEST ABORTED\");\n+            }\n+\n+            if (failed) {\n+                System.out.println(command + \": TEST FAILED\");\n+                System.out.println(message);\n+            } else {\n+                System.out.println(command + \": TEST PASSED\");\n+            }\n+        } finally {\n+            dialog.dispose();\n+        }\n+\n+        return failed;\n+    }\n+\n+    public void pass() {\n+        failed = false;\n+        currentThread.interrupt();\n+    }\n+\n+    public void fail() {\n+        failed = true;\n+        currentThread.interrupt();\n+    }\n@@ -34,4 +358,3 @@\n-public class i18n{\n-    public static void main(String[] args) throws Exception {\n-        System.out.println(\"see i18n.html\");\n-        System.out.println(Path.of(System.getProperty(\"test.jdk\"), \"bin\", \"keytool\"));\n+    public void abort() {\n+        aborted = true;\n+        currentThread.interrupt();\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/i18n.java","additions":332,"deletions":9,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-                    \"hv\",           \"fsrm\",             \"avx512_bitalg\",     \"gfni\"\n+                    \"hv\",           \"fsrm\",             \"avx512_bitalg\",     \"gfni\",\n+                    \"f16c\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib;\n+\n+import javax.swing.*;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+\/**\n+ * This is a common library for building UI for testing purposes.\n+ *\/\n+public class UIBuilder {\n+\n+    \/**\n+     * Creates a {@link javax.swing.JDialog} object with a fixed layout that contains\n+     * an instructions {@link javax.swing.JTextArea} and a message\n+     * {@link javax.swing.JTextArea} for displaying text contents. Text contents can\n+     * be set by using {@code setInstruction} method and {@code setMessage} method.\n+     *\n+     * The {@link javax.swing.JDialog} object also a pass {@link javax.swing.JButton}\n+     * and a fail {@link javax.swing.JButton} to indicate test result. Buttons' action\n+     * can be bound by using {@code setPassAction} and {@code setFailAction}.\n+     *\/\n+    public static class DialogBuilder {\n+        private JDialog dialog;\n+        private JTextArea instructionsText;\n+        private JTextArea messageText;\n+        private JButton pass;\n+        private JButton fail;\n+\n+        \/**\n+         * Construct a new DialogBuilder object.\n+         *\/\n+        public DialogBuilder() {\n+            dialog = new JDialog(new JFrame());\n+            dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n+            instructionsText = new JTextArea(\"\", 5, 100);\n+\n+            dialog.add(\"North\", new JScrollPane(instructionsText,\n+                    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n+                    JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS));\n+\n+            messageText = new JTextArea(\"\", 20, 100);\n+            dialog.add(\"Center\", new JScrollPane(messageText,\n+                    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n+                    JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS));\n+\n+            JPanel buttons = new JPanel();\n+            pass = new JButton(\"pass\");\n+            pass.setActionCommand(\"pass\");\n+            buttons.add(\"East\", pass);\n+\n+            fail = new JButton(\"fail\");\n+            fail.setActionCommand(\"fail\");\n+            buttons.add(\"West\", fail);\n+\n+            dialog.add(\"South\", buttons);\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting the dialog's title to a new value.\n+         * @param title a string value\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setTitle(String title) {\n+            dialog.setTitle(title);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting the instruction text to a new\n+         * value.\n+         * @param instruction a string value\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setInstruction(String instruction) {\n+            instructionsText.setText(\"Test instructions:\\n\" + instruction);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting the message text to a new value.\n+         * @param message a string value\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setMessage(String message) {\n+            messageText.setText(message);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting pass button action to\n+         * {@link java.awt.event.ActionListener}.\n+         * @param action an action to perform on button click\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setPassAction(ActionListener action) {\n+            pass.addActionListener(action);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting fail button action to\n+         * {@link java.awt.event.ActionListener}.\n+         * @param action an action to perform on button click\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setFailAction(ActionListener action) {\n+            fail.addActionListener(action);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting window-closing action to\n+         * {@link java.lang.Runnable}.\n+         * @param action a runnerable action to perform on window close\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setCloseAction(Runnable action) {\n+            dialog.addWindowListener(new WindowAdapter() {\n+                @Override\n+                public void windowClosing(WindowEvent e) {\n+                    super.windowClosing(e);\n+                    action.run();\n+                }\n+            });\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns a {@link javax.swing.JDialog} window.\n+         * @returns a JDialog\n+         *\/\n+        public JDialog build() {\n+            dialog.pack();\n+            return dialog;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/UIBuilder.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.math;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class Fp16ConversionBenchmark {\n+\n+  @Param({\"2048\"})\n+  public int size;\n+\n+  public short[] f16in;\n+  public short[] f16out;\n+  public float[] fin;\n+  public float[] fout;\n+  public static short f16, s;\n+  public static float f;\n+\n+  @Setup(Level.Trial)\n+  public void BmSetup() {\n+      int i = 0;\n+      Random r = new Random(1024);\n+\n+      f16in  = new short[size];\n+      f16out = new short[size];\n+      f16    = (short) r.nextInt();\n+\n+      for (; i < size; i++) {\n+          f16in[i] = Float.floatToFloat16(r.nextFloat());;\n+      }\n+\n+      fin  = new float[size];\n+      fout = new float[size];\n+      f    = r.nextFloat();\n+\n+      i = 0;\n+\n+      for (; i < size; i++) {\n+          fin[i] = Float.float16ToFloat((short)r.nextInt());\n+      }\n+  }\n+\n+  @Benchmark\n+  public short[] floatToFloat16() {\n+      for (int i = 0; i < fin.length; i++) {\n+          f16out[i] = Float.floatToFloat16(fin[i]);\n+      }\n+      return f16out;\n+  }\n+\n+  @Benchmark\n+  public float[] float16ToFloat() {\n+      for (int i = 0; i < f16in.length; i++) {\n+          fout[i] = Float.float16ToFloat(f16in[i]);\n+      }\n+      return fout;\n+  }\n+\n+  @Benchmark\n+  public float float16ToFloatMemory() {\n+      f = Float.float16ToFloat(f16);\n+      return f;\n+  }\n+\n+  @Benchmark\n+  public short floatToFloat16Memory() {\n+      s = Float.floatToFloat16(f);\n+      return s;\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/Fp16ConversionBenchmark.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Random;\n@@ -35,0 +36,2 @@\n+    @Param({\"512\", \"1024\"})\n+    static int SIZE;\n@@ -36,7 +39,6 @@\n-    FloatVector fvec256;\n-    FloatVector fvec512;\n-    DoubleVector dvec512;\n-\n-    static final float [] float_arr = {\n-      1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f,\n-      9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f\n+    static final float [] float_sp_vals = {\n+       Float.NaN,\n+       Float.POSITIVE_INFINITY,\n+       Float.NEGATIVE_INFINITY,\n+       0.0f,\n+       -0.0f\n@@ -45,3 +47,6 @@\n-    static final double [] double_arr = {\n-      1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0,\n-      9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0\n+    static final double [] double_sp_vals = {\n+       Double.NaN,\n+       Double.POSITIVE_INFINITY,\n+       Double.NEGATIVE_INFINITY,\n+       0.0,\n+       -0.0\n@@ -50,0 +55,12 @@\n+    static float [] float_arr;\n+\n+    static double [] double_arr;\n+\n+    static long [] long_res;\n+\n+    static int [] int_res;\n+\n+    static short [] short_res;\n+\n+    static byte [] byte_res;\n+\n@@ -52,3 +69,496 @@\n-        fvec256 = FloatVector.fromArray(FloatVector.SPECIES_256, float_arr, 0);\n-        fvec512 = FloatVector.fromArray(FloatVector.SPECIES_512, float_arr, 0);\n-        dvec512 = DoubleVector.fromArray(DoubleVector.SPECIES_512, double_arr, 0);\n+        Random r = new Random(1024);\n+        float_arr = new float[SIZE];\n+        double_arr = new double[SIZE];\n+        long_res = new long[SIZE];\n+        int_res = new int[SIZE * 2];\n+        short_res = new short[SIZE * 4];\n+        byte_res = new byte[SIZE * 8];\n+        for(int i = 0; i < SIZE; i++) {\n+            float_arr[i] = SIZE * r.nextFloat();\n+            double_arr[i] = SIZE * r.nextDouble();\n+        }\n+        for(int i = 0 ; i < SIZE; i += 100) {\n+            System.arraycopy(float_sp_vals, 0, float_arr, i, float_sp_vals.length);\n+            System.arraycopy(double_sp_vals, 0, double_arr, i, double_sp_vals.length);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microFloat128ToByte128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToByte256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToByte512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 16); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToShort128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToShort256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToShort512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToInteger128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToInteger256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToInteger512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToLong128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToLong256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToLong512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToByte128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToByte256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToByte512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToShort128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToShort256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToShort512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToInteger128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToInteger256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToInteger512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToLong128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToLong256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToLong512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToByte128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToByte256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 16); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToByte512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 32); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToShort128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToShort256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToShort512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 16); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToInteger128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToInteger256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToInteger512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToLong128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToLong256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToLong512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble256ToByte128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble256ToByte256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble256ToByte512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 16); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble256ToShort128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n@@ -58,2 +568,9 @@\n-    public Vector microFloat2Int() {\n-        return fvec512.convertShape(VectorOperators.F2I, IntVector.SPECIES_512, 0);\n+    public void microDouble256ToShort256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n@@ -63,2 +580,9 @@\n-    public Vector microFloat2Long() {\n-        return fvec256.convertShape(VectorOperators.F2L, LongVector.SPECIES_512, 0);\n+    public void microDouble256ToShort512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n@@ -68,2 +592,9 @@\n-    public Vector microFloat2Short() {\n-        return fvec512.convertShape(VectorOperators.F2S, ShortVector.SPECIES_256, 0);\n+    public void microDouble256ToInteger128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n@@ -73,2 +604,9 @@\n-    public Vector microFloat2Byte() {\n-        return fvec512.convertShape(VectorOperators.F2B, ByteVector.SPECIES_128, 0);\n+    public void microDouble256ToInteger256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n@@ -78,2 +616,9 @@\n-    public Vector microDouble2Int() {\n-        return dvec512.convertShape(VectorOperators.D2I, IntVector.SPECIES_256, 0);\n+    public void microDouble256ToInteger512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n@@ -83,2 +628,9 @@\n-    public Vector microDouble2Long() {\n-        return dvec512.convertShape(VectorOperators.D2L, LongVector.SPECIES_512, 0);\n+    public void microDouble256ToLong128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n@@ -88,2 +640,9 @@\n-    public Vector microDouble2Short() {\n-        return dvec512.convertShape(VectorOperators.D2S, ShortVector.SPECIES_128, 0);\n+    public void microDouble256ToLong256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n@@ -93,2 +652,9 @@\n-    public Vector microDouble2Byte() {\n-        return dvec512.convertShape(VectorOperators.D2B, ByteVector.SPECIES_64, 0);\n+    public void microDouble256ToLong512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorFPtoIntCastOperations.java","additions":595,"deletions":29,"binary":false,"changes":624,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1)\n+@State(Scope.Thread)\n+public class LeaPeephole {\n+    static final int ITERATION = 1000;\n+\n+    int x, y;\n+\n+    @Benchmark\n+    public void B_I_int(Blackhole bh) {\n+        int x = this.x;\n+        int y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            int x1 = x + y;\n+            x = x1 + y;\n+            y = x1 + x;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_D_int(Blackhole bh) {\n+        int x = this.x;\n+        int y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x + 10);\n+            bh.consume(x + 20);\n+            bh.consume(x + 30);\n+            bh.consume(y + 10);\n+            bh.consume(y + 20);\n+            bh.consume(y + 30);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void I_S_int(Blackhole bh) {\n+        int x = this.x;\n+        int y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x << 1);\n+            bh.consume(x << 2);\n+            bh.consume(x << 3);\n+            bh.consume(y << 1);\n+            bh.consume(y << 2);\n+            bh.consume(y << 3);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void B_I_long(Blackhole bh) {\n+        long x = this.x;\n+        long y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            long x1 = x + y;\n+            x = x1 + y;\n+            y = x1 + x;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_D_long(Blackhole bh) {\n+        long x = this.x;\n+        long y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x + 10);\n+            bh.consume(x + 20);\n+            bh.consume(x + 30);\n+            bh.consume(y + 10);\n+            bh.consume(y + 20);\n+            bh.consume(y + 30);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void I_S_long(Blackhole bh) {\n+        long x = this.x;\n+        long y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x << 1);\n+            bh.consume(x << 2);\n+            bh.consume(x << 3);\n+            bh.consume(y << 1);\n+            bh.consume(y << 2);\n+            bh.consume(y << 3);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/LeaPeephole.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}