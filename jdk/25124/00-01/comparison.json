{"files":[{"patch":"@@ -26,10 +26,0 @@\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Handle;\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n-import java.io.FileInputStream;\n@@ -37,0 +27,11 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.Label;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -43,1 +44,0 @@\n-import java.nio.file.Paths;\n@@ -46,0 +46,2 @@\n+import static java.lang.constant.ConstantDescs.*;\n+\n@@ -51,1 +53,1 @@\n-public class InvokeDynamicPatcher extends ClassVisitor {\n+public final class InvokeDynamicPatcher {\n@@ -53,2 +55,1 @@\n-    private static final String CLASS = InvokeDynamic.class.getName()\n-            .replace('.', '\/');\n+    private static final ClassDesc CLASS = InvokeDynamic.class.describeConstable().orElseThrow();\n@@ -60,6 +61,6 @@\n-    private static final String CALL_NATIVE_FIELD_DESC = \"Z\";\n-    private static final String CALLEE_METHOD_DESC\n-            = \"(L\" + CLASS + \";IJFDLjava\/lang\/String;)Z\";\n-    private static final String ASSERTTRUE_METHOD_DESC\n-            = \"(ZLjava\/lang\/String;)V\";\n-    private static final String ASSERTS_CLASS = \"jdk\/test\/lib\/Asserts\";\n+    private static final ClassDesc CALL_NATIVE_FIELD_DESC = CD_boolean;\n+    private static final MethodTypeDesc CALLEE_METHOD_DESC = MethodTypeDesc.of(\n+            CD_boolean, CLASS, CD_int, CD_long, CD_float, CD_double, CD_String);\n+    private static final MethodTypeDesc ASSERTTRUE_METHOD_DESC = MethodTypeDesc.of(\n+            CD_void, CD_boolean, CD_String);\n+    private static final ClassDesc ASSERTS_CLASS = ClassDesc.ofInternalName(\"jdk\/test\/lib\/Asserts\");\n@@ -68,179 +69,73 @@\n-    private static final String SRC = \"\"\"\n-            package compiler.calls.common;\n-\n-            import java.lang.invoke.CallSite;\n-            import java.lang.invoke.ConstantCallSite;\n-            import java.lang.invoke.MethodHandles;\n-            import java.lang.invoke.MethodType;\n-\n-            \/**\n-             * A test class checking InvokeDynamic instruction.\n-             * This is not quite \"ready-to-use\" class, since javac can't generate indy\n-             * directly(only as part of lambda init) so, this class bytecode should be\n-             * patched with method \"caller\" which uses indy. Other methods can be written in\n-             * java for easier support and readability.\n-             *\/\n-\n-            public class InvokeDynamic extends CallsBase {\n-                private static final Object LOCK = new Object();\n-\n-                public static void main(String args[]) {\n-                    new InvokeDynamic().runTest(args);\n-                }\n-\n-                \/**\n-                 * Caller method to call \"callee\" method. Must be overwritten with InvokeDynamicPatcher\n-                 *\/\n-                @Override\n-                public void caller() {\n-                }\n-\n-                \/**\n-                 * A bootstrap method for invokedynamic\n-                 * @param lookup a lookup object\n-                 * @param methodName methodName\n-                 * @param type method type\n-                 * @return CallSite for method\n-                 *\/\n-                public static CallSite bootstrapMethod(MethodHandles.Lookup lookup,\n-                        String methodName, MethodType type) throws IllegalAccessException,\n-                        NoSuchMethodException {\n-                    MethodType mtype = MethodType.methodType(boolean.class,\n-                            new Class<?>[]{int.class, long.class, float.class,\n-                                double.class, String.class});\n-                    return new ConstantCallSite(lookup.findVirtual(lookup.lookupClass(),\n-                            methodName, mtype));\n-                }\n-\n-                \/**\n-                 * A callee method, assumed to be called by \"caller\"\n-                 *\/\n-                public boolean callee(int param1, long param2, float param3, double param4,\n-                        String param5) {\n-                    calleeVisited = true;\n-                    CallsBase.checkValues(param1, param2, param3, param4, param5);\n-                    return true;\n-                }\n-\n-                \/**\n-                 * A native callee method, assumed to be called by \"caller\"\n-                 *\/\n-                public native boolean calleeNative(int param1, long param2, float param3,\n-                        double param4, String param5);\n-\n-                \/**\n-                 * Returns object to lock execution on\n-                 * @return lock object\n-                 *\/\n-                @Override\n-                protected Object getLockObject() {\n-                    return LOCK;\n-                }\n-\n-                @Override\n-                protected void callerNative() {\n-                    throw new Error(\"No native call for invokedynamic\");\n-                }\n-            }\n-            \"\"\";\n-\n-    public static void main(String args[]) {\n-        ClassReader cr;\n-        Path filePath;\n-        try {\n-            filePath = Paths.get(InvokeDynamic.class.getProtectionDomain().getCodeSource()\n-                    .getLocation().toURI()).resolve(CLASS + \".class\");\n-        } catch (URISyntaxException ex) {\n-            throw new Error(\"TESTBUG: Can't get code source\" + ex, ex);\n-        }\n-        cr = new ClassReader(InMemoryJavaCompiler.compile(InvokeDynamic.class.getName(), SRC, \"--release\", \"21\"));\n-        ClassWriter cw = new ClassWriter(cr,\n-                ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n-        cr.accept(new InvokeDynamicPatcher(Opcodes.ASM5, cw), 0);\n-        try {\n-            Files.write(filePath, cw.toByteArray(),\n-                    StandardOpenOption.WRITE);\n-        } catch (IOException e) {\n-            throw new Error(e);\n-        }\n-    }\n-\n-    public InvokeDynamicPatcher(int api, ClassWriter cw) {\n-        super(api, cw);\n-    }\n-\n-    @Override\n-    public MethodVisitor visitMethod(final int access, final String name,\n-            final String desc, final String signature,\n-            final String[] exceptions) {\n-        \/* a code generate looks like\n-         *  0: aload_0\n-         *  1: ldc           #125  \/\/ int 1\n-         *  3: ldc2_w        #126  \/\/ long 2l\n-         *  6: ldc           #128  \/\/ float 3.0f\n-         *  8: ldc2_w        #129  \/\/ double 4.0d\n-         * 11: ldc           #132  \/\/ String 5\n-         * 13: aload_0\n-         * 14: getfield      #135  \/\/ Field nativeCallee:Z\n-         * 17: ifeq          28\n-         * 20: invokedynamic #181,  0            \/\/ InvokeDynamic #1:calleeNative:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n-         * 25: goto          33\n-         * 28: invokedynamic #183,  0            \/\/ InvokeDynamic #1:callee:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n-         * 33: ldc           #185                \/\/ String Call insuccessfull\n-         * 35: invokestatic  #191                \/\/ Method jdk\/test\/lib\/Asserts.assertTrue:(ZLjava\/lang\/String;)V\n-         * 38: return\n-         *\n-         * or, using java-like pseudo-code\n-         * if (this.nativeCallee == false) {\n-         *     invokedynamic-call-return-value = invokedynamic-of-callee\n-         * } else {\n-         *     invokedynamic-call-return-value = invokedynamic-of-nativeCallee\n-         * }\n-         * Asserts.assertTrue(invokedynamic-call-return-value, error-message);\n-         * return;\n-         *\/\n-        if (name.equals(CALLER_METHOD_NAME)) {\n-            MethodVisitor mv = cv.visitMethod(access, name, desc,\n-                    signature, exceptions);\n-            Label nonNativeLabel = new Label();\n-            Label checkLabel = new Label();\n-            MethodType mtype = MethodType.methodType(CallSite.class,\n-                    MethodHandles.Lookup.class, String.class, MethodType.class);\n-            Handle bootstrap = new Handle(Opcodes.H_INVOKESTATIC, CLASS,\n-                    BOOTSTRAP_METHOD_NAME, mtype.toMethodDescriptorString());\n-            mv.visitCode();\n-            \/\/ push callee parameters onto stack\n-            mv.visitVarInsn(Opcodes.ALOAD, 0);\/\/push \"this\"\n-            mv.visitLdcInsn(1);\n-            mv.visitLdcInsn(2L);\n-            mv.visitLdcInsn(3.0f);\n-            mv.visitLdcInsn(4.0d);\n-            mv.visitLdcInsn(\"5\");\n-            \/\/ params loaded. let's decide what method to call\n-            mv.visitVarInsn(Opcodes.ALOAD, 0); \/\/ push \"this\"\n-            \/\/ get nativeCallee field\n-            mv.visitFieldInsn(Opcodes.GETFIELD, CLASS, CALL_NATIVE_FIELD,\n-                    CALL_NATIVE_FIELD_DESC);\n-            \/\/ if nativeCallee == false goto nonNativeLabel\n-            mv.visitJumpInsn(Opcodes.IFEQ, nonNativeLabel);\n-            \/\/ invokedynamic nativeCalleeMethod using bootstrap method\n-            mv.visitInvokeDynamicInsn(NATIVE_CALLEE_METHOD_NAME,\n-                    CALLEE_METHOD_DESC, bootstrap);\n-            \/\/ goto checkLabel\n-            mv.visitJumpInsn(Opcodes.GOTO, checkLabel);\n-            \/\/ label: nonNativeLabel\n-            mv.visitLabel(nonNativeLabel);\n-            \/\/ invokedynamic calleeMethod using bootstrap method\n-            mv.visitInvokeDynamicInsn(CALLEE_METHOD_NAME, CALLEE_METHOD_DESC,\n-                    bootstrap);\n-            mv.visitLabel(checkLabel);\n-            mv.visitLdcInsn(CallsBase.CALL_ERR_MSG);\n-            mv.visitMethodInsn(Opcodes.INVOKESTATIC, ASSERTS_CLASS,\n-                    ASSERTTRUE_METHOD_NAME, ASSERTTRUE_METHOD_DESC, false);\n-            \/\/ label: return\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-            return null;\n-        }\n-        return super.visitMethod(access, name, desc, signature, exceptions);\n+    public static void main(String args[]) throws IOException, URISyntaxException {\n+        Path filePath = Path.of(InvokeDynamic.class.getProtectionDomain().getCodeSource()\n+                    .getLocation().toURI()).resolve(InvokeDynamic.class.getName().replace('.', '\/') +\".class\");\n+        var bytes = ClassFile.of().transformClass(ClassFile.of().parse(filePath),\n+                ClassTransform.transformingMethodBodies(m -> m.methodName().equalsString(CALLER_METHOD_NAME), new CodeTransform() {\n+                    @Override\n+                    public void accept(CodeBuilder builder, CodeElement element) {\n+                        \/\/ discard\n+                    }\n+\n+                    \/* a code generate looks like\n+                     *  0: aload_0\n+                     *  1: ldc           #125  \/\/ int 1\n+                     *  3: ldc2_w        #126  \/\/ long 2l\n+                     *  6: ldc           #128  \/\/ float 3.0f\n+                     *  8: ldc2_w        #129  \/\/ double 4.0d\n+                     * 11: ldc           #132  \/\/ String 5\n+                     * 13: aload_0\n+                     * 14: getfield      #135  \/\/ Field nativeCallee:Z\n+                     * 17: ifeq          28\n+                     * 20: invokedynamic #181,  0            \/\/ InvokeDynamic #1:calleeNative:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n+                     * 25: goto          33\n+                     * 28: invokedynamic #183,  0            \/\/ InvokeDynamic #1:callee:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n+                     * 33: ldc           #185                \/\/ String Call insuccessfull\n+                     * 35: invokestatic  #191                \/\/ Method jdk\/test\/lib\/Asserts.assertTrue:(ZLjava\/lang\/String;)V\n+                     * 38: return\n+                     *\n+                     * or, using java-like pseudo-code\n+                     * if (this.nativeCallee == false) {\n+                     *     invokedynamic-call-return-value = invokedynamic-of-callee\n+                     * } else {\n+                     *     invokedynamic-call-return-value = invokedynamic-of-nativeCallee\n+                     * }\n+                     * Asserts.assertTrue(invokedynamic-call-return-value, error-message);\n+                     * return;\n+                     *\/\n+                    @Override\n+                    public void atEnd(CodeBuilder builder) {\n+                        Label nonNativeLabel = builder.newLabel();\n+                        Label checkLabel = builder.newLabel();\n+                        MethodType mtype = MethodType.methodType(CallSite.class,\n+                                MethodHandles.Lookup.class, String.class, MethodType.class);\n+                        DirectMethodHandleDesc dmh = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.STATIC,\n+                                CLASS, BOOTSTRAP_METHOD_NAME, mtype.descriptorString());\n+                        \/\/ push callee parameters onto stack\n+                        builder.aload(builder.receiverSlot())\n+                               .ldc(1)\n+                               .ldc(2L)\n+                               .ldc(3.0f)\n+                               .ldc(4.0d)\n+                               .ldc(\"5\")\n+                               \/\/ params loaded. let's decide what method to call\n+                               .aload(builder.receiverSlot())\n+                               \/\/ get nativeCallee field\n+                               .getfield(CLASS, CALL_NATIVE_FIELD, CALL_NATIVE_FIELD_DESC)\n+                               \/\/ if nativeCallee == false goto nonNativeLabel\n+                               .ifeq(nonNativeLabel)\n+                               \/\/ invokedynamic nativeCalleeMethod using bootstrap method\n+                               .invokedynamic(DynamicCallSiteDesc.of(dmh, NATIVE_CALLEE_METHOD_NAME, CALLEE_METHOD_DESC))\n+                               \/\/ goto checkLabel\n+                               .goto_(checkLabel)\n+                               \/\/ label: nonNativeLabel\n+                               .labelBinding(nonNativeLabel)\n+                               \/\/ invokedynamic calleeMethod using bootstrap method\n+                               .invokedynamic(DynamicCallSiteDesc.of(dmh, CALLEE_METHOD_NAME, CALLEE_METHOD_DESC))\n+                               .labelBinding(checkLabel)\n+                               .ldc(CallsBase.CALL_ERR_MSG)\n+                               .invokestatic(ASSERTS_CLASS, ASSERTTRUE_METHOD_NAME, ASSERTTRUE_METHOD_DESC)\n+                               \/\/ label: return\n+                               .return_();\n+                    }\n+                }));\n+        Files.write(filePath, bytes, StandardOpenOption.WRITE);\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/common\/InvokeDynamicPatcher.java","additions":94,"deletions":199,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2CompiledTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2InterpretedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2NativeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2CompiledTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2InterpretedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2NativeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,5 @@\n-import org.objectweb.asm.*;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n@@ -27,21 +31,14 @@\n-    static byte[] fixup(byte[] buf) throws java.io.IOException {\n-        ClassReader cr = new ClassReader(buf);\n-        ClassWriter cw = new ClassWriter(0);\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) {\n-            public MethodVisitor visitMethod(\n-                final int access,\n-                final String name,\n-                final String desc,\n-                final String signature,\n-                final String[] exceptions)\n-            {\n-                MethodVisitor mv = super.visitMethod(access,\n-                        name,\n-                        desc,\n-                        signature,\n-                        exceptions);\n-                if (mv == null)  return null;\n-                if (name.equals(\"callme\")) {\n-                    \/\/ make receiver go dead!\n-                    mv.visitInsn(Opcodes.ACONST_NULL);\n-                    mv.visitVarInsn(Opcodes.ASTORE, 0);\n+    static byte[] fixup(byte[] buf) {\n+        return ClassFile.of().transformClass(ClassFile.of().parse(buf), ClassTransform.transformingMethodBodies(\n+                m -> m.methodName().equalsString(\"callme\"),\n+                new CodeTransform() {\n+                    @Override\n+                    public void atStart(CodeBuilder builder) {\n+                        \/\/ make receiver go dead!\n+                        builder.aconst_null().astore(0);\n+                    }\n+\n+                    @Override\n+                    public void accept(CodeBuilder builder, CodeElement element) {\n+                        builder.with(element); \/\/ pass through\n+                    }\n@@ -49,5 +46,1 @@\n-                return mv;\n-            }\n-        };\n-        cr.accept(cv, 0);\n-        return cw.toByteArray();\n+        ));\n","filename":"test\/hotspot\/jtreg\/runtime\/MirrorFrame\/Asmator.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -30,1 +29,1 @@\n- * @compile -XDignore.symbol.file -source 21 -target 21 Victim.java\n+ * @compile -XDignore.symbol.file Victim.java\n","filename":"test\/hotspot\/jtreg\/runtime\/MirrorFrame\/Test8003720.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/testlibrary\/asm\n@@ -33,1 +32,0 @@\n- * @compile --release 21 RedefineRetransform.java\n@@ -46,7 +44,9 @@\n-\n-import org.objectweb.asm.AnnotationVisitor;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.Type;\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.util.NoSuchElementException;\n@@ -85,43 +85,1 @@\n-    private static class VersionScanner extends ClassVisitor {\n-        private Integer detectedVersion;\n-        private Integer versionToSet;\n-        \/\/ to get version\n-        public VersionScanner() {\n-            super(Opcodes.ASM7);\n-        }\n-        \/\/ to set version\n-        public VersionScanner(int verToSet, ClassVisitor classVisitor) {\n-            super(Opcodes.ASM7, classVisitor);\n-            versionToSet = verToSet;\n-        }\n-\n-        public int detectedVersion() {\n-            if (detectedVersion == null) {\n-                throw new RuntimeException(\"Version not detected\");\n-            }\n-            return detectedVersion;\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n-            \/\/log(\"visitAnnotation: descr = '\" + descriptor + \"', visible = \" + visible);\n-            if (Type.getDescriptor(ClassVersion.class).equals(descriptor)) {\n-                return new AnnotationVisitor(Opcodes.ASM7, super.visitAnnotation(descriptor, visible)) {\n-                    @Override\n-                    public void visit(String name, Object value) {\n-                        \/\/log(\"visit: name = '\" + name + \"', value = \" + value\n-                        \/\/        + \" (\" + (value == null ? \"N\/A\" : value.getClass()) + \")\");\n-                        if (\"value\".equals(name) && value instanceof Integer intValue) {\n-                            detectedVersion = intValue;\n-                            if (versionToSet != null) {\n-                                \/\/log(\"replace with \" + versionToSet);\n-                                value = versionToSet;\n-                            }\n-                        }\n-                        super.visit(name, value);\n-                    }\n-                };\n-            }\n-            return super.visitAnnotation(descriptor, visible);\n-        }\n-    }\n+    private static final ClassDesc CD_ClassVersion = ClassVersion.class.describeConstable().orElseThrow();\n@@ -134,4 +92,4 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        ClassReader cr = new ClassReader(initialClassBytes);\n-        cr.accept(new VersionScanner(ver, cw), 0);\n-        return cw.toByteArray();\n+        return ClassFile.of().transformClass(ClassFile.of().parse(initialClassBytes),\n+                \/\/ overwrites previously passed RVAA\n+                ClassTransform.endHandler(clb -> clb.with(RuntimeVisibleAnnotationsAttribute\n+                        .of(Annotation.of(CD_ClassVersion, AnnotationElement.ofInt(\"value\", ver))))));\n@@ -142,4 +100,9 @@\n-        ClassReader cr = new ClassReader(classBytes);\n-        VersionScanner scanner = new VersionScanner();\n-        cr.accept(scanner, 0);\n-        return scanner.detectedVersion();\n+        var cm = ClassFile.of().parse(classBytes);\n+        var rvaa = cm.findAttribute(Attributes.runtimeVisibleAnnotations()).orElseThrow();\n+        var elements = rvaa.annotations().stream().filter(anno -> anno.className().isFieldType(CD_ClassVersion)).findFirst().orElseThrow().elements();\n+        if (elements.size() != 1)\n+            throw new NoSuchElementException();\n+        var element = elements.getFirst();\n+        if (!element.name().equalsString(\"value\") || !(element.value() instanceof AnnotationValue.OfInt intVal))\n+            throw new NoSuchElementException();\n+        return intVal.intValue();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":23,"deletions":60,"binary":false,"changes":83,"status":"modified"}]}