{"files":[{"patch":"@@ -26,0 +26,1 @@\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n@@ -67,0 +68,79 @@\n+    private static final String SRC = \"\"\"\n+            package compiler.calls.common;\n+\n+            import java.lang.invoke.CallSite;\n+            import java.lang.invoke.ConstantCallSite;\n+            import java.lang.invoke.MethodHandles;\n+            import java.lang.invoke.MethodType;\n+\n+            \/**\n+             * A test class checking InvokeDynamic instruction.\n+             * This is not quite \"ready-to-use\" class, since javac can't generate indy\n+             * directly(only as part of lambda init) so, this class bytecode should be\n+             * patched with method \"caller\" which uses indy. Other methods can be written in\n+             * java for easier support and readability.\n+             *\/\n+\n+            public class InvokeDynamic extends CallsBase {\n+                private static final Object LOCK = new Object();\n+\n+                public static void main(String args[]) {\n+                    new InvokeDynamic().runTest(args);\n+                }\n+\n+                \/**\n+                 * Caller method to call \"callee\" method. Must be overwritten with InvokeDynamicPatcher\n+                 *\/\n+                @Override\n+                public void caller() {\n+                }\n+\n+                \/**\n+                 * A bootstrap method for invokedynamic\n+                 * @param lookup a lookup object\n+                 * @param methodName methodName\n+                 * @param type method type\n+                 * @return CallSite for method\n+                 *\/\n+                public static CallSite bootstrapMethod(MethodHandles.Lookup lookup,\n+                        String methodName, MethodType type) throws IllegalAccessException,\n+                        NoSuchMethodException {\n+                    MethodType mtype = MethodType.methodType(boolean.class,\n+                            new Class<?>[]{int.class, long.class, float.class,\n+                                double.class, String.class});\n+                    return new ConstantCallSite(lookup.findVirtual(lookup.lookupClass(),\n+                            methodName, mtype));\n+                }\n+\n+                \/**\n+                 * A callee method, assumed to be called by \"caller\"\n+                 *\/\n+                public boolean callee(int param1, long param2, float param3, double param4,\n+                        String param5) {\n+                    calleeVisited = true;\n+                    CallsBase.checkValues(param1, param2, param3, param4, param5);\n+                    return true;\n+                }\n+\n+                \/**\n+                 * A native callee method, assumed to be called by \"caller\"\n+                 *\/\n+                public native boolean calleeNative(int param1, long param2, float param3,\n+                        double param4, String param5);\n+\n+                \/**\n+                 * Returns object to lock execution on\n+                 * @return lock object\n+                 *\/\n+                @Override\n+                protected Object getLockObject() {\n+                    return LOCK;\n+                }\n+\n+                @Override\n+                protected void callerNative() {\n+                    throw new Error(\"No native call for invokedynamic\");\n+                }\n+            }\n+            \"\"\";\n+\n@@ -76,5 +156,1 @@\n-        try (FileInputStream fis = new FileInputStream(filePath.toFile())) {\n-            cr = new ClassReader(fis);\n-        } catch (IOException e) {\n-            throw new Error(\"Error reading file\", e);\n-        }\n+        cr = new ClassReader(InMemoryJavaCompiler.compile(InvokeDynamic.class.getName(), SRC, \"--release\", \"21\"));\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/common\/InvokeDynamicPatcher.java","additions":81,"deletions":5,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -26,8 +26,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.tree.ClassNode;\n-import jdk.test.lib.Utils;\n@@ -37,1 +29,0 @@\n-import jdk.vm.ci.hotspot.HotSpotNmethod;\n@@ -41,0 +32,5 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -43,1 +39,0 @@\n-import java.lang.reflect.Field;\n@@ -46,2 +41,1 @@\n-import java.lang.reflect.Parameter;\n-import java.util.HashMap;\n+import java.util.Arrays;\n@@ -76,1 +70,1 @@\n-        ClassReader cr;\n+        ClassModel cm;\n@@ -80,2 +74,2 @@\n-            cr = new ClassReader(aModule.getResourceAsStream(\n-                    name.replace('.', '\/') + \".class\"));\n+            cm = ClassFile.of().parse(aModule.getResourceAsStream(\n+                    name.replace('.', '\/') + \".class\").readAllBytes());\n@@ -85,2 +79,0 @@\n-        ClassNode cn = new ClassNode();\n-        cr.accept(cn, ClassReader.EXPAND_FRAMES);\n@@ -88,23 +80,7 @@\n-        Map<Label, Integer> labels = new HashMap<>();\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        ClassVisitor cv = new ClassVisitorForLabels(cw, labels, method);\n-        cr.accept(cv, ClassReader.EXPAND_FRAMES);\n-        labels.forEach((k, v) -> lineNumbers.put(k.getOffset(), v));\n-        boolean isEmptyMethod = Modifier.isAbstract(method.getModifiers())\n-                || Modifier.isNative(method.getModifiers());\n-        if (lineNumbers.isEmpty() && !isEmptyMethod) {\n-            throw new Error(method + \" doesn't contains the line numbers table \"\n-                    +\"(the method marked neither abstract nor native)\");\n-        }\n-        return lineNumbers;\n-    }\n-\n-    private static class ClassVisitorForLabels extends ClassVisitor {\n-        private final Map<Label, Integer> lineNumbers;\n-        private final String targetName;\n-        private final String targetDesc;\n-\n-        public ClassVisitorForLabels(ClassWriter cw, Map<Label, Integer> lines,\n-                                     Executable target) {\n-            super(Opcodes.ASM7, cw);\n-            this.lineNumbers = lines;\n+        var params = Arrays.stream(method.getParameterTypes())\n+                .map(cl -> cl.describeConstable().orElseThrow())\n+                .toList();\n+        var ret = method instanceof Method m ? m.getReturnType().describeConstable().orElseThrow()\n+                                             : ConstantDescs.CD_void;\n+        var mt = MethodTypeDesc.of(ret, params);\n+        var name = method instanceof Method m ? m.getName() : ConstantDescs.INIT_NAME;\n@@ -112,28 +88,9 @@\n-            StringBuilder builder = new StringBuilder(\"(\");\n-            for (Parameter parameter : target.getParameters()) {\n-                builder.append(Utils.toJVMTypeSignature(parameter.getType()));\n-            }\n-            builder.append(\")\");\n-            if (target instanceof Constructor) {\n-                targetName = \"<init>\";\n-                builder.append(\"V\");\n-            } else {\n-                targetName = target.getName();\n-                builder.append(Utils.toJVMTypeSignature(\n-                        ((Method) target).getReturnType()));\n-            }\n-            targetDesc = builder.toString();\n-        }\n-\n-        @Override\n-        public final MethodVisitor visitMethod(int access, String name,\n-                                               String desc, String signature,\n-                                               String[] exceptions) {\n-            MethodVisitor mv = cv.visitMethod(access, name, desc, signature,\n-                    exceptions);\n-            if (targetDesc.equals(desc) && targetName.equals(name)) {\n-                return new MethodVisitor(Opcodes.ASM7, mv) {\n-                    @Override\n-                    public void visitLineNumber(int i, Label label) {\n-                        super.visitLineNumber(i, label);\n-                        lineNumbers.put(label, i);\n+        for (var m : cm.methods()) {\n+            if (m.methodName().equalsString(name) && m.methodType().isMethodType(mt)) {\n+                var optLnt = m.code().flatMap(code -> code.findAttribute(Attributes.lineNumberTable()));\n+                if (optLnt.isEmpty()) {\n+                    boolean isEmptyMethod = Modifier.isAbstract(method.getModifiers())\n+                            || Modifier.isNative(method.getModifiers());\n+                    if (!isEmptyMethod) {\n+                        throw new Error(method + \" doesn't contains the line numbers table \"\n+                                + \"(the method marked neither abstract nor native)\");\n@@ -141,1 +98,4 @@\n-                };\n+                    break;\n+                }\n+                optLnt.get().lineNumbers().forEach(ln -> lineNumbers.put(ln.startPc(), ln.lineNumber()));\n+                break;\n@@ -143,1 +103,0 @@\n-            return  mv;\n@@ -145,0 +104,1 @@\n+        return lineNumbers;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/CTVMUtilities.java","additions":30,"deletions":70,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDignore.symbol.file Victim.java\n+ * @compile -XDignore.symbol.file -source 21 -target 21 Victim.java\n","filename":"test\/hotspot\/jtreg\/runtime\/MirrorFrame\/Test8003720.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/testlibrary\/asm\n@@ -36,5 +35,2 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n@@ -61,20 +57,6 @@\n-        ClassReader reader = new ClassReader(classfileBuffer);\n-        final int[] frameCount = {0};\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM9) {\n-            @Override\n-            public MethodVisitor visitMethod(int access, String name,\n-                                             String descriptor, String signature,\n-                                             String[] exceptions) {\n-                return new MethodVisitor(Opcodes.ASM9) {\n-                    private int methodFrames = 0;\n-                    @Override\n-                    public void visitFrame(int type, int numLocal, Object[] local,\n-                                           int numStack, Object[] stack) {\n-                        methodFrames++;\n-                    }\n-                    @Override\n-                    public void visitEnd() {\n-                        log(\"  method \" + name + \" - \" + methodFrames + \" frames\");\n-                        frameCount[0] += methodFrames;\n-                    }\n-                };\n+        var cm = ClassFile.of().parse(classfileBuffer);\n+        int count = 0;\n+        for (var mth : cm.methods()) {\n+            var optSmt = mth.code().flatMap(code -> code.findAttribute(Attributes.stackMapTable()));\n+            if (optSmt.isPresent()) {\n+                count += optSmt.get().entries().size();\n@@ -82,3 +64,2 @@\n-        };\n-        reader.accept(cv, 0);\n-        return frameCount[0];\n+        }\n+        return count;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/MissedStackMapFrames.java","additions":10,"deletions":29,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @library \/testlibrary\/asm\n@@ -49,0 +48,5 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.FieldModel;\n@@ -58,1 +62,0 @@\n-import java.lang.reflect.TypeVariable;\n@@ -60,2 +63,1 @@\n-import java.util.Arrays;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n@@ -64,5 +66,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.FieldVisitor;\n-import static org.objectweb.asm.Opcodes.ASM7;\n@@ -89,24 +86,4 @@\n-            ClassWriter cw = new ClassWriter(0);\n-            ClassVisitor cv = new ReAddDummyFieldsClassVisitor(ASM7, cw) { };\n-            ClassReader cr = new ClassReader(classfileBuffer);\n-            cr.accept(cv, 0);\n-            return cw.toByteArray();\n-        }\n-\n-        public class ReAddDummyFieldsClassVisitor extends ClassVisitor {\n-\n-            LinkedList<F> fields = new LinkedList<>();\n-\n-            public ReAddDummyFieldsClassVisitor(int api, ClassVisitor cv) {\n-                super(api, cv);\n-            }\n-\n-            @Override public FieldVisitor visitField(int access, String name,\n-                    String desc, String signature, Object value) {\n-                if (name.startsWith(\"dummy\")) {\n-                    \/\/ Remove dummy field\n-                    fields.addLast(new F(access, name, desc, signature, value));\n-                    return null;\n-                }\n-                return cv.visitField(access, name, desc, signature, value);\n-            }\n+            var cf = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL);\n+            return cf.transformClass(cf.parse(classfileBuffer), new ClassTransform() {\n+                \/\/ Shuffle constant pool\n+                final List<FieldModel> fields = new ArrayList<>();\n@@ -114,5 +91,7 @@\n-            @Override public void visitEnd() {\n-                F f;\n-                while ((f = fields.pollFirst()) != null) {\n-                    \/\/ Re-add dummy fields\n-                    cv.visitField(f.access, f.name, f.desc, f.signature, f.value);\n+                @Override\n+                public void accept(ClassBuilder builder, ClassElement element) {\n+                    if (element instanceof FieldModel field && field.fieldName().stringValue().startsWith(\"dummy\")) {\n+                        fields.addLast(field);\n+                    } else {\n+                        builder.with(element);\n+                    }\n@@ -120,1 +99,0 @@\n-            }\n@@ -122,12 +100,3 @@\n-            private class F {\n-                private int access;\n-                private String name;\n-                private String desc;\n-                private String signature;\n-                private Object value;\n-                F(int access, String name, String desc, String signature, Object value) {\n-                    this.access = access;\n-                    this.name = name;\n-                    this.desc = desc;\n-                    this.signature = signature;\n-                    this.value = value;\n+                @Override\n+                public void atEnd(ClassBuilder builder) {\n+                    fields.forEach(builder);\n@@ -135,1 +104,1 @@\n-            }\n+            });\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineAnnotations.java","additions":21,"deletions":52,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        byte[] bytecode = InMemoryJavaCompiler.compile(GenericSignatureTarget.class.getName(), newTargetClassSource);\n+        byte[] bytecode = InMemoryJavaCompiler.compile(GenericSignatureTarget.class.getName(), newTargetClassSource, \"--release\", \"21\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineGenericSignatureTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/testlibrary\/asm\n@@ -44,0 +43,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileVersion;\n@@ -49,8 +50,0 @@\n-import java.util.Arrays;\n-\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-\n-import static org.objectweb.asm.Opcodes.ASM6;\n-import static org.objectweb.asm.Opcodes.V1_8;\n@@ -72,25 +65,8 @@\n-            ClassWriter cw = new ClassWriter(0);\n-            \/\/ Force an older ASM to force a bytecode update\n-            ClassVisitor cv = new DummyClassVisitor(ASM6, cw) { };\n-            ClassReader cr = new ClassReader(classfileBuffer);\n-            cr.accept(cv, 0);\n-            byte[] bytes = cw.toByteArray();\n-            return bytes;\n-        }\n-\n-        public class DummyClassVisitor extends ClassVisitor {\n-\n-            public DummyClassVisitor(int api, ClassVisitor cv) {\n-                super(api, cv);\n-            }\n-\n-            public void visit(\n-                    final int version,\n-                    final int access,\n-                    final String name,\n-                    final String signature,\n-                    final String superName,\n-                    final String[] interfaces) {\n-                \/\/ Artificially lower to JDK 8 version to force a redefine\n-                cv.visit(V1_8, access, name, signature, superName, interfaces);\n-            }\n+            return ClassFile.of().transformClass(ClassFile.of().parse(classfileBuffer), (cb, ce) -> {\n+                if (ce instanceof ClassFileVersion cfv) {\n+                    \/\/ Force a redefine with different class file versions\n+                    cb.with(ClassFileVersion.of(cfv.majorVersion() - 1, 0));\n+                } else {\n+                    cb.with(ce);\n+                }\n+            });\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineObject.java","additions":10,"deletions":34,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @compile --release 21 RedefineRetransform.java\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}