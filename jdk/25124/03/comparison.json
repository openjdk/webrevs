{"files":[{"patch":"@@ -26,9 +26,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Handle;\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n-import java.io.FileInputStream;\n@@ -36,0 +27,11 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.Label;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -42,1 +44,0 @@\n-import java.nio.file.Paths;\n@@ -45,0 +46,2 @@\n+import static java.lang.constant.ConstantDescs.*;\n+\n@@ -50,1 +53,1 @@\n-public class InvokeDynamicPatcher extends ClassVisitor {\n+public final class InvokeDynamicPatcher {\n@@ -52,2 +55,1 @@\n-    private static final String CLASS = InvokeDynamic.class.getName()\n-            .replace('.', '\/');\n+    private static final ClassDesc CLASS = InvokeDynamic.class.describeConstable().orElseThrow();\n@@ -59,6 +61,6 @@\n-    private static final String CALL_NATIVE_FIELD_DESC = \"Z\";\n-    private static final String CALLEE_METHOD_DESC\n-            = \"(L\" + CLASS + \";IJFDLjava\/lang\/String;)Z\";\n-    private static final String ASSERTTRUE_METHOD_DESC\n-            = \"(ZLjava\/lang\/String;)V\";\n-    private static final String ASSERTS_CLASS = \"jdk\/test\/lib\/Asserts\";\n+    private static final ClassDesc CALL_NATIVE_FIELD_DESC = CD_boolean;\n+    private static final MethodTypeDesc CALLEE_METHOD_DESC = MethodTypeDesc.of(\n+            CD_boolean, CLASS, CD_int, CD_long, CD_float, CD_double, CD_String);\n+    private static final MethodTypeDesc ASSERTTRUE_METHOD_DESC = MethodTypeDesc.of(\n+            CD_void, CD_boolean, CD_String);\n+    private static final ClassDesc ASSERTS_CLASS = ClassDesc.ofInternalName(\"jdk\/test\/lib\/Asserts\");\n@@ -67,28 +69,9 @@\n-    public static void main(String args[]) {\n-        ClassReader cr;\n-        Path filePath;\n-        try {\n-            filePath = Paths.get(InvokeDynamic.class.getProtectionDomain().getCodeSource()\n-                    .getLocation().toURI()).resolve(CLASS + \".class\");\n-        } catch (URISyntaxException ex) {\n-            throw new Error(\"TESTBUG: Can't get code source\" + ex, ex);\n-        }\n-        try (FileInputStream fis = new FileInputStream(filePath.toFile())) {\n-            cr = new ClassReader(fis);\n-        } catch (IOException e) {\n-            throw new Error(\"Error reading file\", e);\n-        }\n-        ClassWriter cw = new ClassWriter(cr,\n-                ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n-        cr.accept(new InvokeDynamicPatcher(Opcodes.ASM5, cw), 0);\n-        try {\n-            Files.write(filePath, cw.toByteArray(),\n-                    StandardOpenOption.WRITE);\n-        } catch (IOException e) {\n-            throw new Error(e);\n-        }\n-    }\n-\n-    public InvokeDynamicPatcher(int api, ClassWriter cw) {\n-        super(api, cw);\n-    }\n+    public static void main(String args[]) throws IOException, URISyntaxException {\n+        Path filePath = Path.of(InvokeDynamic.class.getProtectionDomain().getCodeSource()\n+                    .getLocation().toURI()).resolve(InvokeDynamic.class.getName().replace('.', '\/') +\".class\");\n+        var bytes = ClassFile.of().transformClass(ClassFile.of().parse(filePath),\n+                ClassTransform.transformingMethodBodies(m -> m.methodName().equalsString(CALLER_METHOD_NAME), new CodeTransform() {\n+                    @Override\n+                    public void accept(CodeBuilder builder, CodeElement element) {\n+                        \/\/ discard\n+                    }\n@@ -96,75 +79,63 @@\n-    @Override\n-    public MethodVisitor visitMethod(final int access, final String name,\n-            final String desc, final String signature,\n-            final String[] exceptions) {\n-        \/* a code generate looks like\n-         *  0: aload_0\n-         *  1: ldc           #125  \/\/ int 1\n-         *  3: ldc2_w        #126  \/\/ long 2l\n-         *  6: ldc           #128  \/\/ float 3.0f\n-         *  8: ldc2_w        #129  \/\/ double 4.0d\n-         * 11: ldc           #132  \/\/ String 5\n-         * 13: aload_0\n-         * 14: getfield      #135  \/\/ Field nativeCallee:Z\n-         * 17: ifeq          28\n-         * 20: invokedynamic #181,  0            \/\/ InvokeDynamic #1:calleeNative:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n-         * 25: goto          33\n-         * 28: invokedynamic #183,  0            \/\/ InvokeDynamic #1:callee:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n-         * 33: ldc           #185                \/\/ String Call insuccessfull\n-         * 35: invokestatic  #191                \/\/ Method jdk\/test\/lib\/Asserts.assertTrue:(ZLjava\/lang\/String;)V\n-         * 38: return\n-         *\n-         * or, using java-like pseudo-code\n-         * if (this.nativeCallee == false) {\n-         *     invokedynamic-call-return-value = invokedynamic-of-callee\n-         * } else {\n-         *     invokedynamic-call-return-value = invokedynamic-of-nativeCallee\n-         * }\n-         * Asserts.assertTrue(invokedynamic-call-return-value, error-message);\n-         * return;\n-         *\/\n-        if (name.equals(CALLER_METHOD_NAME)) {\n-            MethodVisitor mv = cv.visitMethod(access, name, desc,\n-                    signature, exceptions);\n-            Label nonNativeLabel = new Label();\n-            Label checkLabel = new Label();\n-            MethodType mtype = MethodType.methodType(CallSite.class,\n-                    MethodHandles.Lookup.class, String.class, MethodType.class);\n-            Handle bootstrap = new Handle(Opcodes.H_INVOKESTATIC, CLASS,\n-                    BOOTSTRAP_METHOD_NAME, mtype.toMethodDescriptorString());\n-            mv.visitCode();\n-            \/\/ push callee parameters onto stack\n-            mv.visitVarInsn(Opcodes.ALOAD, 0);\/\/push \"this\"\n-            mv.visitLdcInsn(1);\n-            mv.visitLdcInsn(2L);\n-            mv.visitLdcInsn(3.0f);\n-            mv.visitLdcInsn(4.0d);\n-            mv.visitLdcInsn(\"5\");\n-            \/\/ params loaded. let's decide what method to call\n-            mv.visitVarInsn(Opcodes.ALOAD, 0); \/\/ push \"this\"\n-            \/\/ get nativeCallee field\n-            mv.visitFieldInsn(Opcodes.GETFIELD, CLASS, CALL_NATIVE_FIELD,\n-                    CALL_NATIVE_FIELD_DESC);\n-            \/\/ if nativeCallee == false goto nonNativeLabel\n-            mv.visitJumpInsn(Opcodes.IFEQ, nonNativeLabel);\n-            \/\/ invokedynamic nativeCalleeMethod using bootstrap method\n-            mv.visitInvokeDynamicInsn(NATIVE_CALLEE_METHOD_NAME,\n-                    CALLEE_METHOD_DESC, bootstrap);\n-            \/\/ goto checkLabel\n-            mv.visitJumpInsn(Opcodes.GOTO, checkLabel);\n-            \/\/ label: nonNativeLabel\n-            mv.visitLabel(nonNativeLabel);\n-            \/\/ invokedynamic calleeMethod using bootstrap method\n-            mv.visitInvokeDynamicInsn(CALLEE_METHOD_NAME, CALLEE_METHOD_DESC,\n-                    bootstrap);\n-            mv.visitLabel(checkLabel);\n-            mv.visitLdcInsn(CallsBase.CALL_ERR_MSG);\n-            mv.visitMethodInsn(Opcodes.INVOKESTATIC, ASSERTS_CLASS,\n-                    ASSERTTRUE_METHOD_NAME, ASSERTTRUE_METHOD_DESC, false);\n-            \/\/ label: return\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-            return null;\n-        }\n-        return super.visitMethod(access, name, desc, signature, exceptions);\n+                    \/* a code generate looks like\n+                     *  0: aload_0\n+                     *  1: ldc           #125  \/\/ int 1\n+                     *  3: ldc2_w        #126  \/\/ long 2l\n+                     *  6: ldc           #128  \/\/ float 3.0f\n+                     *  8: ldc2_w        #129  \/\/ double 4.0d\n+                     * 11: ldc           #132  \/\/ String 5\n+                     * 13: aload_0\n+                     * 14: getfield      #135  \/\/ Field nativeCallee:Z\n+                     * 17: ifeq          28\n+                     * 20: invokedynamic #181,  0            \/\/ InvokeDynamic #1:calleeNative:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n+                     * 25: goto          33\n+                     * 28: invokedynamic #183,  0            \/\/ InvokeDynamic #1:callee:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n+                     * 33: ldc           #185                \/\/ String Call insuccessfull\n+                     * 35: invokestatic  #191                \/\/ Method jdk\/test\/lib\/Asserts.assertTrue:(ZLjava\/lang\/String;)V\n+                     * 38: return\n+                     *\n+                     * or, using java-like pseudo-code\n+                     * if (this.nativeCallee == false) {\n+                     *     invokedynamic-call-return-value = invokedynamic-of-callee\n+                     * } else {\n+                     *     invokedynamic-call-return-value = invokedynamic-of-nativeCallee\n+                     * }\n+                     * Asserts.assertTrue(invokedynamic-call-return-value, error-message);\n+                     * return;\n+                     *\/\n+                    @Override\n+                    public void atEnd(CodeBuilder builder) {\n+                        Label nonNativeLabel = builder.newLabel();\n+                        Label checkLabel = builder.newLabel();\n+                        MethodType mtype = MethodType.methodType(CallSite.class,\n+                                MethodHandles.Lookup.class, String.class, MethodType.class);\n+                        DirectMethodHandleDesc dmh = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.STATIC,\n+                                CLASS, BOOTSTRAP_METHOD_NAME, mtype.descriptorString());\n+                        \/\/ push callee parameters onto stack\n+                        builder.aload(builder.receiverSlot())\n+                               .ldc(1)\n+                               .ldc(2L)\n+                               .ldc(3.0f)\n+                               .ldc(4.0d)\n+                               .ldc(\"5\")\n+                               \/\/ params loaded. let's decide what method to call\n+                               .aload(builder.receiverSlot())\n+                               \/\/ get nativeCallee field\n+                               .getfield(CLASS, CALL_NATIVE_FIELD, CALL_NATIVE_FIELD_DESC)\n+                               \/\/ if nativeCallee == false goto nonNativeLabel\n+                               .ifeq(nonNativeLabel)\n+                               \/\/ invokedynamic nativeCalleeMethod using bootstrap method\n+                               .invokedynamic(DynamicCallSiteDesc.of(dmh, NATIVE_CALLEE_METHOD_NAME, CALLEE_METHOD_DESC))\n+                               \/\/ goto checkLabel\n+                               .goto_(checkLabel)\n+                               \/\/ label: nonNativeLabel\n+                               .labelBinding(nonNativeLabel)\n+                               \/\/ invokedynamic calleeMethod using bootstrap method\n+                               .invokedynamic(DynamicCallSiteDesc.of(dmh, CALLEE_METHOD_NAME, CALLEE_METHOD_DESC))\n+                               .labelBinding(checkLabel)\n+                               .ldc(CallsBase.CALL_ERR_MSG)\n+                               .invokestatic(ASSERTS_CLASS, ASSERTTRUE_METHOD_NAME, ASSERTTRUE_METHOD_DESC)\n+                               \/\/ label: return\n+                               .return_();\n+                    }\n+                }));\n+        Files.write(filePath, bytes, StandardOpenOption.WRITE);\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/common\/InvokeDynamicPatcher.java","additions":93,"deletions":122,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2CompiledTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2InterpretedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2NativeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2CompiledTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2InterpretedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2NativeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -29,1 +29,0 @@\n- * @library \/testlibrary\/asm\n@@ -40,6 +39,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n@@ -49,0 +42,4 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassHierarchyResolver;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -162,16 +159,7 @@\n-                ClassReader cr = new ClassReader(classfileBuffer);\n-                ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);\n-                ClassVisitor adapter = new ClassVisitor(Opcodes.ASM5, cw) {\n-                    @Override\n-                    public MethodVisitor visitMethod(int access, String base, String desc, String signature, String[] exceptions) {\n-                        MethodVisitor mv = cv.visitMethod(access, base, desc, signature, exceptions);\n-                        if (mv != null) {\n-                            mv = new MethodVisitor(Opcodes.ASM5, mv) {\n-                                @Override\n-                                public void visitLdcInsn(Object cst) {\n-                                    System.out.println(\"replacing \\\"\" + cst + \"\\\" with \\\"bar\\\"\");\n-                                    mv.visitLdcInsn(\"bar\");\n-                                }\n-                            };\n-                        }\n-                        return mv;\n+                var cf = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(cl)));\n+                return cf.transformClass(cf.parse(classfileBuffer), ClassTransform.transformingMethodBodies((cob, coe) -> {\n+                    if (coe instanceof ConstantInstruction.LoadConstantInstruction ldc) {\n+                        System.out.println(\"replacing \\\"\" + ldc.constantEntry().constantValue() + \"\\\" with \\\"bar\\\"\");\n+                        cob.ldc(\"bar\");\n+                    } else {\n+                        cob.with(coe);\n@@ -179,5 +167,1 @@\n-                };\n-\n-                cr.accept(adapter, ClassReader.SKIP_FRAMES);\n-                cw.visitEnd();\n-                return cw.toByteArray();\n+                }));\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/RedefineMethodUsedByMultipleMethodHandles.java","additions":13,"deletions":29,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,8 +26,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.tree.ClassNode;\n-import jdk.test.lib.Utils;\n@@ -37,1 +29,0 @@\n-import jdk.vm.ci.hotspot.HotSpotNmethod;\n@@ -41,0 +32,5 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -43,1 +39,0 @@\n-import java.lang.reflect.Field;\n@@ -46,2 +41,1 @@\n-import java.lang.reflect.Parameter;\n-import java.util.HashMap;\n+import java.util.Arrays;\n@@ -76,1 +70,1 @@\n-        ClassReader cr;\n+        ClassModel cm;\n@@ -80,2 +74,2 @@\n-            cr = new ClassReader(aModule.getResourceAsStream(\n-                    name.replace('.', '\/') + \".class\"));\n+            cm = ClassFile.of().parse(aModule.getResourceAsStream(\n+                    name.replace('.', '\/') + \".class\").readAllBytes());\n@@ -85,2 +79,0 @@\n-        ClassNode cn = new ClassNode();\n-        cr.accept(cn, ClassReader.EXPAND_FRAMES);\n@@ -88,23 +80,7 @@\n-        Map<Label, Integer> labels = new HashMap<>();\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        ClassVisitor cv = new ClassVisitorForLabels(cw, labels, method);\n-        cr.accept(cv, ClassReader.EXPAND_FRAMES);\n-        labels.forEach((k, v) -> lineNumbers.put(k.getOffset(), v));\n-        boolean isEmptyMethod = Modifier.isAbstract(method.getModifiers())\n-                || Modifier.isNative(method.getModifiers());\n-        if (lineNumbers.isEmpty() && !isEmptyMethod) {\n-            throw new Error(method + \" doesn't contains the line numbers table \"\n-                    +\"(the method marked neither abstract nor native)\");\n-        }\n-        return lineNumbers;\n-    }\n-\n-    private static class ClassVisitorForLabels extends ClassVisitor {\n-        private final Map<Label, Integer> lineNumbers;\n-        private final String targetName;\n-        private final String targetDesc;\n-\n-        public ClassVisitorForLabels(ClassWriter cw, Map<Label, Integer> lines,\n-                                     Executable target) {\n-            super(Opcodes.ASM7, cw);\n-            this.lineNumbers = lines;\n+        var params = Arrays.stream(method.getParameterTypes())\n+                .map(cl -> cl.describeConstable().orElseThrow())\n+                .toList();\n+        var ret = method instanceof Method m ? m.getReturnType().describeConstable().orElseThrow()\n+                                             : ConstantDescs.CD_void;\n+        var mt = MethodTypeDesc.of(ret, params);\n+        var name = method instanceof Method m ? m.getName() : ConstantDescs.INIT_NAME;\n@@ -112,28 +88,9 @@\n-            StringBuilder builder = new StringBuilder(\"(\");\n-            for (Parameter parameter : target.getParameters()) {\n-                builder.append(Utils.toJVMTypeSignature(parameter.getType()));\n-            }\n-            builder.append(\")\");\n-            if (target instanceof Constructor) {\n-                targetName = \"<init>\";\n-                builder.append(\"V\");\n-            } else {\n-                targetName = target.getName();\n-                builder.append(Utils.toJVMTypeSignature(\n-                        ((Method) target).getReturnType()));\n-            }\n-            targetDesc = builder.toString();\n-        }\n-\n-        @Override\n-        public final MethodVisitor visitMethod(int access, String name,\n-                                               String desc, String signature,\n-                                               String[] exceptions) {\n-            MethodVisitor mv = cv.visitMethod(access, name, desc, signature,\n-                    exceptions);\n-            if (targetDesc.equals(desc) && targetName.equals(name)) {\n-                return new MethodVisitor(Opcodes.ASM7, mv) {\n-                    @Override\n-                    public void visitLineNumber(int i, Label label) {\n-                        super.visitLineNumber(i, label);\n-                        lineNumbers.put(label, i);\n+        for (var m : cm.methods()) {\n+            if (m.methodName().equalsString(name) && m.methodType().isMethodType(mt)) {\n+                var optLnt = m.code().flatMap(code -> code.findAttribute(Attributes.lineNumberTable()));\n+                if (optLnt.isEmpty()) {\n+                    boolean isEmptyMethod = Modifier.isAbstract(method.getModifiers())\n+                            || Modifier.isNative(method.getModifiers());\n+                    if (!isEmptyMethod) {\n+                        throw new Error(method + \" doesn't contains the line numbers table \"\n+                                + \"(the method marked neither abstract nor native)\");\n@@ -141,1 +98,4 @@\n-                };\n+                    break;\n+                }\n+                optLnt.get().lineNumbers().forEach(ln -> lineNumbers.put(ln.startPc(), ln.lineNumber()));\n+                break;\n@@ -143,1 +103,0 @@\n-            return  mv;\n@@ -145,0 +104,1 @@\n+        return lineNumbers;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/CTVMUtilities.java","additions":30,"deletions":70,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -24,1 +24,5 @@\n-import org.objectweb.asm.*;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n@@ -27,21 +31,14 @@\n-    static byte[] fixup(byte[] buf) throws java.io.IOException {\n-        ClassReader cr = new ClassReader(buf);\n-        ClassWriter cw = new ClassWriter(0);\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) {\n-            public MethodVisitor visitMethod(\n-                final int access,\n-                final String name,\n-                final String desc,\n-                final String signature,\n-                final String[] exceptions)\n-            {\n-                MethodVisitor mv = super.visitMethod(access,\n-                        name,\n-                        desc,\n-                        signature,\n-                        exceptions);\n-                if (mv == null)  return null;\n-                if (name.equals(\"callme\")) {\n-                    \/\/ make receiver go dead!\n-                    mv.visitInsn(Opcodes.ACONST_NULL);\n-                    mv.visitVarInsn(Opcodes.ASTORE, 0);\n+    static byte[] fixup(byte[] buf) {\n+        return ClassFile.of().transformClass(ClassFile.of().parse(buf), ClassTransform.transformingMethodBodies(\n+                m -> m.methodName().equalsString(\"callme\"),\n+                new CodeTransform() {\n+                    @Override\n+                    public void atStart(CodeBuilder builder) {\n+                        \/\/ make receiver go dead!\n+                        builder.aconst_null().astore(0);\n+                    }\n+\n+                    @Override\n+                    public void accept(CodeBuilder builder, CodeElement element) {\n+                        builder.with(element); \/\/ pass through\n+                    }\n@@ -49,5 +46,1 @@\n-                return mv;\n-            }\n-        };\n-        cr.accept(cv, 0);\n-        return cw.toByteArray();\n+        ));\n","filename":"test\/hotspot\/jtreg\/runtime\/MirrorFrame\/Asmator.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/runtime\/MirrorFrame\/Test8003720.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/testlibrary\/asm\n@@ -36,5 +35,2 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n@@ -61,20 +57,6 @@\n-        ClassReader reader = new ClassReader(classfileBuffer);\n-        final int[] frameCount = {0};\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM9) {\n-            @Override\n-            public MethodVisitor visitMethod(int access, String name,\n-                                             String descriptor, String signature,\n-                                             String[] exceptions) {\n-                return new MethodVisitor(Opcodes.ASM9) {\n-                    private int methodFrames = 0;\n-                    @Override\n-                    public void visitFrame(int type, int numLocal, Object[] local,\n-                                           int numStack, Object[] stack) {\n-                        methodFrames++;\n-                    }\n-                    @Override\n-                    public void visitEnd() {\n-                        log(\"  method \" + name + \" - \" + methodFrames + \" frames\");\n-                        frameCount[0] += methodFrames;\n-                    }\n-                };\n+        var cm = ClassFile.of().parse(classfileBuffer);\n+        int count = 0;\n+        for (var mth : cm.methods()) {\n+            var optSmt = mth.code().flatMap(code -> code.findAttribute(Attributes.stackMapTable()));\n+            if (optSmt.isPresent()) {\n+                count += optSmt.get().entries().size();\n@@ -82,3 +64,2 @@\n-        };\n-        reader.accept(cv, 0);\n-        return frameCount[0];\n+        }\n+        return count;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/MissedStackMapFrames.java","additions":10,"deletions":29,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @library \/testlibrary\/asm\n@@ -49,0 +48,5 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.FieldModel;\n@@ -58,1 +62,0 @@\n-import java.lang.reflect.TypeVariable;\n@@ -60,2 +63,1 @@\n-import java.util.Arrays;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n@@ -64,5 +66,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.FieldVisitor;\n-import static org.objectweb.asm.Opcodes.ASM7;\n@@ -89,24 +86,4 @@\n-            ClassWriter cw = new ClassWriter(0);\n-            ClassVisitor cv = new ReAddDummyFieldsClassVisitor(ASM7, cw) { };\n-            ClassReader cr = new ClassReader(classfileBuffer);\n-            cr.accept(cv, 0);\n-            return cw.toByteArray();\n-        }\n-\n-        public class ReAddDummyFieldsClassVisitor extends ClassVisitor {\n-\n-            LinkedList<F> fields = new LinkedList<>();\n-\n-            public ReAddDummyFieldsClassVisitor(int api, ClassVisitor cv) {\n-                super(api, cv);\n-            }\n-\n-            @Override public FieldVisitor visitField(int access, String name,\n-                    String desc, String signature, Object value) {\n-                if (name.startsWith(\"dummy\")) {\n-                    \/\/ Remove dummy field\n-                    fields.addLast(new F(access, name, desc, signature, value));\n-                    return null;\n-                }\n-                return cv.visitField(access, name, desc, signature, value);\n-            }\n+            var cf = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL);\n+            return cf.transformClass(cf.parse(classfileBuffer), new ClassTransform() {\n+                \/\/ Shuffle constant pool\n+                final List<FieldModel> fields = new ArrayList<>();\n@@ -114,5 +91,7 @@\n-            @Override public void visitEnd() {\n-                F f;\n-                while ((f = fields.pollFirst()) != null) {\n-                    \/\/ Re-add dummy fields\n-                    cv.visitField(f.access, f.name, f.desc, f.signature, f.value);\n+                @Override\n+                public void accept(ClassBuilder builder, ClassElement element) {\n+                    if (element instanceof FieldModel field && field.fieldName().stringValue().startsWith(\"dummy\")) {\n+                        fields.addLast(field);\n+                    } else {\n+                        builder.with(element);\n+                    }\n@@ -120,1 +99,0 @@\n-            }\n@@ -122,12 +100,3 @@\n-            private class F {\n-                private int access;\n-                private String name;\n-                private String desc;\n-                private String signature;\n-                private Object value;\n-                F(int access, String name, String desc, String signature, Object value) {\n-                    this.access = access;\n-                    this.name = name;\n-                    this.desc = desc;\n-                    this.signature = signature;\n-                    this.value = value;\n+                @Override\n+                public void atEnd(ClassBuilder builder) {\n+                    fields.forEach(builder);\n@@ -135,1 +104,1 @@\n-            }\n+            });\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineAnnotations.java","additions":21,"deletions":52,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n@@ -144,3 +149,2 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        ClassReader cr = new ClassReader(bytecode);\n-        cr.accept(new ClassVisitor(Opcodes.ASM7, cw) {\n+        var cf = ClassFile.of();\n+        return cf.transformClass(cf.parse(bytecode), new ClassTransform() {\n@@ -149,4 +153,8 @@\n-            public void visitSource(String source, String debug) {\n-                sourceSet = true;\n-                log(\"Changing source: \\\"\" + source + \"\\\" -> \\\"\" + sourceFileNameNew + \"\\\"\");\n-                super.visitSource(sourceFileNameNew, debug);\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                if (element instanceof SourceFileAttribute src) {\n+                    sourceSet = true;\n+                    log(\"Changing source: \\\"\" + src.sourceFile() + \"\\\" -> \\\"\" + sourceFileNameNew + \"\\\"\");\n+                    builder.with(SourceFileAttribute.of(sourceFileNameNew));\n+                } else {\n+                    builder.with(element);\n+                }\n@@ -156,1 +164,1 @@\n-            public void visitEnd() {\n+            public void atEnd(ClassBuilder builder) {\n@@ -159,1 +167,1 @@\n-                    super.visitSource(sourceFileNameNew, null);\n+                    builder.with(SourceFileAttribute.of(sourceFileNameNew));\n@@ -161,1 +169,0 @@\n-                super.visitEnd();\n@@ -163,2 +170,1 @@\n-        }, 0);\n-        return cw.toByteArray();\n+        });\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineGenericSignatureTest.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/testlibrary\/asm\n@@ -44,0 +43,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileVersion;\n@@ -49,8 +50,0 @@\n-import java.util.Arrays;\n-\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-\n-import static org.objectweb.asm.Opcodes.ASM6;\n-import static org.objectweb.asm.Opcodes.V1_8;\n@@ -72,25 +65,8 @@\n-            ClassWriter cw = new ClassWriter(0);\n-            \/\/ Force an older ASM to force a bytecode update\n-            ClassVisitor cv = new DummyClassVisitor(ASM6, cw) { };\n-            ClassReader cr = new ClassReader(classfileBuffer);\n-            cr.accept(cv, 0);\n-            byte[] bytes = cw.toByteArray();\n-            return bytes;\n-        }\n-\n-        public class DummyClassVisitor extends ClassVisitor {\n-\n-            public DummyClassVisitor(int api, ClassVisitor cv) {\n-                super(api, cv);\n-            }\n-\n-            public void visit(\n-                    final int version,\n-                    final int access,\n-                    final String name,\n-                    final String signature,\n-                    final String superName,\n-                    final String[] interfaces) {\n-                \/\/ Artificially lower to JDK 8 version to force a redefine\n-                cv.visit(V1_8, access, name, signature, superName, interfaces);\n-            }\n+            return ClassFile.of().transformClass(ClassFile.of().parse(classfileBuffer), (cb, ce) -> {\n+                if (ce instanceof ClassFileVersion cfv) {\n+                    \/\/ Force a redefine with different class file versions\n+                    cb.with(ClassFileVersion.of(cfv.majorVersion() - 1, 0));\n+                } else {\n+                    cb.with(ce);\n+                }\n+            });\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineObject.java","additions":10,"deletions":34,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/testlibrary\/asm\n@@ -45,7 +44,9 @@\n-\n-import org.objectweb.asm.AnnotationVisitor;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.Type;\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.util.NoSuchElementException;\n@@ -84,43 +85,1 @@\n-    private static class VersionScanner extends ClassVisitor {\n-        private Integer detectedVersion;\n-        private Integer versionToSet;\n-        \/\/ to get version\n-        public VersionScanner() {\n-            super(Opcodes.ASM7);\n-        }\n-        \/\/ to set version\n-        public VersionScanner(int verToSet, ClassVisitor classVisitor) {\n-            super(Opcodes.ASM7, classVisitor);\n-            versionToSet = verToSet;\n-        }\n-\n-        public int detectedVersion() {\n-            if (detectedVersion == null) {\n-                throw new RuntimeException(\"Version not detected\");\n-            }\n-            return detectedVersion;\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n-            \/\/log(\"visitAnnotation: descr = '\" + descriptor + \"', visible = \" + visible);\n-            if (Type.getDescriptor(ClassVersion.class).equals(descriptor)) {\n-                return new AnnotationVisitor(Opcodes.ASM7, super.visitAnnotation(descriptor, visible)) {\n-                    @Override\n-                    public void visit(String name, Object value) {\n-                        \/\/log(\"visit: name = '\" + name + \"', value = \" + value\n-                        \/\/        + \" (\" + (value == null ? \"N\/A\" : value.getClass()) + \")\");\n-                        if (\"value\".equals(name) && value instanceof Integer intValue) {\n-                            detectedVersion = intValue;\n-                            if (versionToSet != null) {\n-                                \/\/log(\"replace with \" + versionToSet);\n-                                value = versionToSet;\n-                            }\n-                        }\n-                        super.visit(name, value);\n-                    }\n-                };\n-            }\n-            return super.visitAnnotation(descriptor, visible);\n-        }\n-    }\n+    private static final ClassDesc CD_ClassVersion = ClassVersion.class.describeConstable().orElseThrow();\n@@ -133,4 +92,4 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        ClassReader cr = new ClassReader(initialClassBytes);\n-        cr.accept(new VersionScanner(ver, cw), 0);\n-        return cw.toByteArray();\n+        return ClassFile.of().transformClass(ClassFile.of().parse(initialClassBytes),\n+                \/\/ overwrites previously passed RVAA\n+                ClassTransform.endHandler(clb -> clb.with(RuntimeVisibleAnnotationsAttribute\n+                        .of(Annotation.of(CD_ClassVersion, AnnotationElement.ofInt(\"value\", ver))))));\n@@ -141,4 +100,9 @@\n-        ClassReader cr = new ClassReader(classBytes);\n-        VersionScanner scanner = new VersionScanner();\n-        cr.accept(scanner, 0);\n-        return scanner.detectedVersion();\n+        var cm = ClassFile.of().parse(classBytes);\n+        var rvaa = cm.findAttribute(Attributes.runtimeVisibleAnnotations()).orElseThrow();\n+        var elements = rvaa.annotations().stream().filter(anno -> anno.className().isFieldType(CD_ClassVersion)).findFirst().orElseThrow().elements();\n+        if (elements.size() != 1)\n+            throw new NoSuchElementException();\n+        var element = elements.getFirst();\n+        if (!element.name().equalsString(\"value\") || !(element.value() instanceof AnnotationValue.OfInt intVal))\n+            throw new NoSuchElementException();\n+        return intVal.intValue();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":23,"deletions":59,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.constant.ClassDesc;\n@@ -45,5 +48,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Opcodes;\n-\n@@ -262,5 +260,2 @@\n-       ClassReader cr = new ClassReader(classToMorph);\n-       ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);\n-       ClassVisitor cv = new ClassRenamer(cw, newName);\n-       cr.accept(cv, 0);\n-       return cw.toByteArray();\n+       var cf = ClassFile.of();\n+       return cf.transformClass(cf.parse(classToMorph), ClassDesc.ofInternalName(newName), ClassTransform.ACCEPT_ALL);\n@@ -268,18 +263,0 @@\n-\n-    \/**\n-     * Visitor to rename class.\n-     *\/\n-    static class ClassRenamer extends ClassVisitor implements Opcodes {\n-        private final String newName;\n-\n-        public ClassRenamer(ClassVisitor cv, String newName) {\n-            super(ASM4, cv);\n-            this.newName = newName;\n-        }\n-\n-        @Override\n-        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-            cv.visit(version, access, newName, signature, superName, interfaces);\n-        }\n-\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/GenClassPoolJar.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -31,5 +32,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.FieldVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n@@ -82,2 +78,1 @@\n-        FieldExplorer explorer = new FieldExplorer(cls);\n-        List<String> fields = explorer.get();\n+        List<String> fields = getFields(cls);\n@@ -87,23 +82,5 @@\n-    \/\/ helper class to get list of the class fields\n-    \/\/ in the order they appear in the class file\n-    static class FieldExplorer extends ClassVisitor {\n-        private final Class cls;\n-        private List<String> fieldNameAndSig = new ArrayList<>();\n-        private FieldExplorer(Class cls) {\n-            super(Opcodes.ASM7);\n-            this.cls = cls;\n-        }\n-\n-        @Override\n-        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n-            System.out.println(\"  field '\" + name + \"', type = \" + descriptor);\n-            fieldNameAndSig.add(name);\n-            fieldNameAndSig.add(descriptor);\n-            return super.visitField(access, name, descriptor, signature, value);\n-        }\n-\n-        private InputStream getClassBytes() throws Exception {\n-            String clsName = cls.getName();\n-            String clsPath = clsName.replace('.', '\/') + \".class\";\n-            return cls.getClassLoader().getResourceAsStream(clsPath);\n-        }\n+    private static InputStream getClassBytes(Class<?> cls) throws Exception {\n+        String clsName = cls.getName();\n+        String clsPath = clsName.replace('.', '\/') + \".class\";\n+        return cls.getClassLoader().getResourceAsStream(clsPath);\n+    }\n@@ -111,6 +88,10 @@\n-        \/\/ each field is represented by 2 Strings in the list: name and type descriptor\n-        public List<String> get() throws Exception {\n-            System.out.println(\"Class \" + cls.getName());\n-            try (InputStream classBytes = getClassBytes()) {\n-                ClassReader classReader = new ClassReader(classBytes);\n-                classReader.accept(this, 0);\n+    \/\/ get list of the class fields in the order they appear in the class file\n+    \/\/ each field is represented by 2 Strings in the list: name and type descriptor\n+    public static List<String> getFields(Class<?> cls) throws Exception {\n+        System.out.println(\"Class \" + cls.getName());\n+        List<String> fieldNameAndSig = new ArrayList<>();\n+        try (InputStream classBytes = getClassBytes(cls)) {\n+            var classModel = ClassFile.of().parse(classBytes.readAllBytes());\n+            for (var field : classModel.fields()) {\n+                fieldNameAndSig.add(field.fieldName().stringValue());\n+                fieldNameAndSig.add(field.fieldType().stringValue());\n@@ -118,1 +99,0 @@\n-            return fieldNameAndSig;\n@@ -120,0 +100,1 @@\n+        return fieldNameAndSig;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld007.java","additions":18,"deletions":37,"binary":false,"changes":55,"status":"modified"}]}