{"files":[{"patch":"@@ -1508,0 +1508,3 @@\n+  \/\/ Vector Widening Integer Add\/Subtract\n+  INSN(vwadd_vx, 0b1010111, 0b110, 0b110001);\n+\n@@ -1541,0 +1544,2 @@\n+\n+  \/\/ Vector Integer reverse subtract\n@@ -1603,0 +1608,1 @@\n+  \/\/ Vector Integer Comparison Instructions\n@@ -1609,0 +1615,2 @@\n+\n+  \/\/ Vector Bitwise Logical Instructions\n@@ -1612,0 +1620,2 @@\n+\n+  \/\/ Vector Single-Width Integer Add and Subtract\n@@ -1613,0 +1623,2 @@\n+\n+  \/\/ Vector Integer reverse subtract\n@@ -1615,0 +1627,3 @@\n+  \/\/ Vector Narrowing Integer Right Shift Instructions\n+  INSN(vnsra_wi,  0b1010111, 0b011, 0b101101);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1812,2 +1812,2 @@\n-  \/\/ in riscv, NaN needs a special process as fcvt does not work in that case.\n-  \/\/ in riscv, Inf does not need a special process as fcvt can handle it correctly.\n+  \/\/ On riscv, NaN needs a special process as fcvt does not work in that case.\n+  \/\/ On riscv, Inf does not need a special process as fcvt can handle it correctly.\n@@ -1860,1 +1860,1 @@\n-  \/\/ in riscv, NaN needs a special process as fcvt does not work in that case.\n+  \/\/ On riscv, NaN needs a special process as fcvt does not work in that case.\n@@ -1875,0 +1875,111 @@\n+static void float16_to_float_v_slow_path(C2_MacroAssembler& masm, C2GeneralStub<VectorRegister, VectorRegister, uint>& stub) {\n+#define __ masm.\n+  VectorRegister dst = stub.data<0>();\n+  VectorRegister src = stub.data<1>();\n+  uint length = stub.data<2>();\n+  __ bind(stub.entry());\n+\n+  \/\/ following instructions mainly focus on NaN, as riscv does not handle\n+  \/\/ NaN well with vfwcvt_f_f_v, but the code also works for Inf at the same time.\n+  \/\/\n+  \/\/ construct NaN's in 32 bits from the NaN's in 16 bits,\n+  \/\/ we need the payloads of non-canonical NaNs to be preserved.\n+\n+  \/\/ adjust vector type to 2 * SEW.\n+  __ vsetvli_helper(T_FLOAT, length, Assembler::m1);\n+  \/\/ widen and sign-extend src data.\n+  __ vsext_vf2(dst, src, Assembler::v0_t);\n+  __ mv(t0, 0x7f800000);\n+  \/\/ sign-bit was already set via sign-extension if necessary.\n+  __ vsll_vi(dst, dst, 13, Assembler::v0_t);\n+  __ vor_vx(dst, dst, t0, Assembler::v0_t);\n+\n+  __ j(stub.continuation());\n+#undef __\n+}\n+\n+\/\/ j.l.Float.float16ToFloat\n+void C2_MacroAssembler::float16_to_float_v(VectorRegister dst, VectorRegister src, uint length) {\n+  auto stub = C2CodeStub::make<VectorRegister, VectorRegister, uint>\n+              (dst, src, length, 24, float16_to_float_v_slow_path);\n+\n+  \/\/ On riscv, NaN needs a special process as vfwcvt_f_f_v does not work in that case.\n+  \/\/ On riscv, Inf does not need a special process as vfwcvt_f_f_v can handle it correctly.\n+  \/\/ but we consider to get the slow path to process NaN and Inf at the same time,\n+  \/\/ as both of them are rare cases, and if we try to get the slow path to handle\n+  \/\/ only NaN case it would sacrifise the performance for normal cases,\n+  \/\/ i.e. non-NaN and non-Inf cases.\n+\n+  vsetvli_helper(BasicType::T_SHORT, length, Assembler::mf2);\n+\n+  \/\/ check whether there is a NaN or +\/- Inf.\n+  mv(t0, 0x7c00);\n+  vand_vx(v0, src, t0);\n+  \/\/ v0 will be used as mask in slow path.\n+  vmseq_vx(v0, v0, t0);\n+  vcpop_m(t0, v0);\n+\n+  \/\/ non-NaN or non-Inf cases, just use built-in instructions.\n+  vfwcvt_f_f_v(dst, src);\n+\n+  \/\/ jump to stub processing NaN and Inf cases if there is any of them in the vector-wide.\n+  bgtz(t0, stub->entry());\n+\n+  bind(stub->continuation());\n+}\n+\n+static void float_to_float16_v_slow_path(C2_MacroAssembler& masm,\n+                                         C2GeneralStub<VectorRegister, VectorRegister, VectorRegister, uint>& stub) {\n+#define __ masm.\n+  VectorRegister dst = stub.data<0>();\n+  VectorRegister src = stub.data<1>();\n+  VectorRegister tmp = stub.data<2>();\n+  uint length = stub.data<3>();\n+  __ bind(stub.entry());\n+\n+  \/\/ mul is already set to mf2 in float_to_float16_v.\n+\n+  \/\/ preserve the payloads of non-canonical NaNs.\n+  __ vnsra_wi(dst, src, 13, Assembler::v0_t);\n+\n+  __ mv(t0, 26);\n+  \/\/ preserve the sign bit.\n+  __ vnsra_wx(tmp, src, t0, Assembler::v0_t);\n+  __ vsll_vi(tmp, tmp, 10, Assembler::v0_t);\n+  __ mv(t0, 0x3ff);\n+  __ vor_vx(tmp, tmp, t0, Assembler::v0_t);\n+\n+  \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n+  __ vand_vv(dst, dst, tmp, Assembler::v0_t);\n+\n+  __ j(stub.continuation());\n+#undef __\n+}\n+\n+\/\/ j.l.Float.float16ToFloat\n+void C2_MacroAssembler::float_to_float16_v(VectorRegister dst, VectorRegister src, VectorRegister tmp, uint length) {\n+  auto stub = C2CodeStub::make<VectorRegister, VectorRegister, VectorRegister, uint>\n+              (dst, src, tmp, length, 36, float_to_float16_v_slow_path);\n+\n+  \/\/ On riscv, NaN needs a special process as vfncvt_f_f_w does not work in that case.\n+\n+  vsetvli_helper(BasicType::T_FLOAT, length, Assembler::m1);\n+\n+  \/\/ check whether there is a NaN.\n+  \/\/ replace v_fclass with vmseq_vv as performance optimization.\n+  vmfne_vv(v0, src, src);\n+\n+  \/\/ move vsetvli_helper forward here, as t0 is used as default temp register in vsetvli_helper in some situations.\n+  \/\/ and also moving vsetvli_helper(..., mf2) here does not impact vcpop_m.\n+  vsetvli_helper(BasicType::T_SHORT, length, Assembler::mf2);\n+  vcpop_m(t0, v0);\n+\n+  \/\/ non-NaN cases, just use built-in instructions.\n+  vfncvt_f_f_w(dst, src);\n+\n+  \/\/ jump to stub processing NaN cases.\n+  bnez(t0, stub->entry());\n+\n+  bind(stub->continuation());\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":114,"deletions":3,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -190,0 +190,3 @@\n+  void float16_to_float_v(VectorRegister dst, VectorRegister src, uint length);\n+  void float_to_float16_v(VectorRegister dst, VectorRegister src, VectorRegister tmp, uint length);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+  product(bool, UseZvfh, false, EXPERIMENTAL, \"Use Zvfh instructions\")           \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+      case Op_VectorCastHF2F:\n+      case Op_VectorCastF2HF:\n+        return UseZvfh;\n@@ -3680,0 +3683,30 @@\n+\/\/ ---------------- Convert Half Floating to Floating Vector Operations ----------------\n+\n+\/\/ half precision -> single\n+\n+instruct vconvHF2F(vReg dst, vReg src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastHF2F src));\n+  effect(TEMP_DEF dst, TEMP v0);\n+  format %{ \"vfwcvt.f.f.v $dst, $src\\t# convert half to single precision\" %}\n+  ins_encode %{\n+    __ float16_to_float_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                          Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ single precision -> half\n+\n+instruct vconvF2HF(vReg dst, vReg src, vReg tmp, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastF2HF src));\n+  effect(TEMP_DEF dst, TEMP v0, TEMP tmp);\n+  format %{ \"vfncvt.f.f.w $dst, $src\\t# convert single to half precision\" %}\n+  ins_encode %{\n+    __ float_to_float16_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                          as_VectorRegister($tmp$$reg), Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+  decl(ext_Zvfh        , \"Zvfh\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZvfh))        \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -255,0 +255,2 @@\n+  ext_Zvfh.enable_feature();\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,3 @@\n- * @requires (os.simpleArch == \"x64\" & (vm.cpu.features ~= \".*avx512f.*\" | vm.cpu.features ~= \".*f16c.*\")) | os.arch == \"aarch64\"\n+ * @requires (os.simpleArch == \"x64\" & (vm.cpu.features ~= \".*avx512f.*\" | vm.cpu.features ~= \".*f16c.*\")) |\n+ *           os.arch == \"aarch64\" |\n+ *           os.arch == \"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8320646\n+ * @summary Auto-vectorize Float.floatToFloat16, Float.float16ToFloat APIs, with NaN\n+ * @requires vm.compiler2.enabled\n+ * @requires os.arch == \"riscv64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestFloatConversionsVectorNaN\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.HexFormat;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+public class TestFloatConversionsVectorNaN {\n+    private static final int ARRLEN = 1024;\n+    private static final int ITERS  = 11000;\n+    private static float  [] finp;\n+    private static short  [] sout;\n+    private static short  [] sinp;\n+    private static float  [] fout;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                   \"-XX:CompileThresholdScaling=0.3\");\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"})\n+    public void test_float_float16(short[] sout, float[] finp) {\n+        for (int i = 0; i < finp.length; i++) {\n+            sout[i] = Float.floatToFloat16(finp[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test_float_float16\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_float_float16() {\n+        int errno = 0;\n+        finp = new float[ARRLEN];\n+        sout = new short[ARRLEN];\n+\n+        \/\/ Setup\n+        for (int i = 0; i < ARRLEN; i++) {\n+            if (i%39 == 0) {\n+                int x = 0x7f800000 + ((i\/39) << 13);\n+                x = (i%2 == 0) ? x : (x | 0x80000000);\n+                finp[i] = Float.intBitsToFloat(x);\n+            } else {\n+                finp[i] = (float) i * 1.4f;\n+            }\n+        }\n+        int ranges[][] = {\n+            {128, 64},\n+            {256, 19},\n+            {384-19, 19},\n+            {512-19, 17},\n+            {640+19, 19},\n+            {768+19, 32},\n+            {896-19, 32}\n+        };\n+        for (int range[] : ranges) {\n+            int start = range[0];\n+            int offset = range[1];\n+            for (int i = start; i < start+offset; i++) {\n+                int x = 0x7f800000 + (i << 13);\n+                finp[i] = Float.intBitsToFloat(x);\n+            }\n+        }\n+\n+        \/\/ Test\n+        for (int i = 0; i < ITERS; i++) {\n+            test_float_float16(sout, finp);\n+        }\n+\n+        \/\/ Verifying the result\n+        for (int i = 0; i < ARRLEN; i++) {\n+            errno += assertEquals(i, finp[i], Float.floatToFloat16(finp[i]), sout[i]);\n+        }\n+\n+        if (errno > 0) {\n+            throw new RuntimeException(\"errors occur\");\n+        }\n+    }\n+\n+    static int assertEquals(int idx, float f, short expected, short actual) {\n+        HexFormat hf = HexFormat.of();\n+        String msg = \"floatToFloat16 wrong result: idx: \" + idx + \", \\t\" + f +\n+                     \",\\t expected: \" + hf.toHexDigits(expected) +\n+                     \",\\t actual: \" + hf.toHexDigits(actual);\n+        if ((expected & 0x7c00) != 0x7c00) {\n+            if (expected != actual) {\n+                System.err.println(msg);\n+                return 1;\n+            }\n+        } else if ((expected & 0x3ff) != 0) {\n+            if (((actual & 0x7c00) != 0x7c00) || (actual & 0x3ff) == 0) {\n+                System.err.println(msg);\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"})\n+    public void test_float16_float(float[] fout, short[] sinp) {\n+        for (int i = 0; i < sinp.length; i++) {\n+            fout[i] = Float.float16ToFloat(sinp[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test_float16_float\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_float16_float() {\n+        int errno = 0;\n+        sinp = new short[ARRLEN];\n+        fout = new float[ARRLEN];\n+\n+        \/\/ Setup\n+        for (int i = 0; i < ARRLEN; i++) {\n+            if (i%39 == 0) {\n+                int x = 0x7c00 + i;\n+                x = (i%2 == 0) ? x : (x | 0x8000);\n+                sinp[i] = (short)x;\n+            } else {\n+                sinp[i] = (short)i;\n+            }\n+        }\n+\n+        int ranges[][] = {\n+            {128, 64},\n+            {256, 19},\n+            {384-19, 19},\n+            {512-19, 17},\n+            {640+19, 19},\n+            {768+19, 32},\n+            {896-19, 32}\n+        };\n+        for (int range[] : ranges) {\n+            int start = range[0];\n+            int offset = range[1];\n+            for (int i = start; i < start+offset; i++) {\n+                int x = 0x7c00 + i;\n+                x = (i%2 == 0) ? x : (x | 0x8000);\n+                sinp[i] = (short)x;\n+            }\n+        }\n+\n+        \/\/ Test\n+        for (int i = 0; i < ITERS; i++) {\n+            test_float16_float(fout, sinp);\n+        }\n+\n+        \/\/ Verifying the result\n+        for (int i = 0; i < ARRLEN; i++) {\n+            errno += assertEquals(i, sinp[i], Float.float16ToFloat(sinp[i]), fout[i]);\n+        }\n+\n+        if (errno > 0) {\n+            throw new RuntimeException(\"errors occur\");\n+        }\n+    }\n+\n+    static int assertEquals(int idx, short s, float expected, float actual) {\n+        String msg = \"float16ToFloat wrong result: idx: \" + idx + \", \\t\" + s +\n+                     \",\\t expected: \" + expected + \",\\t\" + Integer.toHexString(Float.floatToIntBits(expected)) +\n+                     \",\\t actual: \" + actual + \",\\t\" + Integer.toHexString(Float.floatToIntBits(actual));\n+        if (!Float.isNaN(expected) || !Float.isNaN(actual)) {\n+            if (expected != actual) {\n+                System.err.println(msg);\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVectorNaN.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}