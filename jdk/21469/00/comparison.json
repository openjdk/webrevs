{"files":[{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.util.ModuleInfoWriter;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleFinder;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/**\n+ * @test\n+ * @bug 8341957\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.module\n+ * @library \/test\/lib\n+ * @summary Verify unspecified but long-standing behavior of URLClassLoader and\n+ *          the module system class loader with respect to invalid class file data\n+ *          and invalid JAR file CRC checksums\n+ * @run junit InvalidCRCClassData\n+ *\/\n+public class InvalidCRCClassData {\n+\n+    \/\/ Name of the class being loaded in this test\n+    private static String className = \"foo.bar.Library\";\n+\n+    \/*\n+     * Provide expected behaviors for all eight combinations of\n+     *   - URLClassLoader or module system class loader\n+     *   - Valid or invalid class file data\n+     *   - Valid or invalid class file JAR CRC32 checksums\n+     *\/\n+    public static Stream<Arguments> parameters() throws IOException {\n+        return Stream.of(\n+                \/\/ Verify URLClassLoader:\n+                \/\/ Invalid class data + invalid CRC: ClassFormatError, suppressed exception\n+                Arguments.of(ucl(false, false), ClassFormatError.class, true),\n+                \/\/ Invalid class data + valid CRC: ClassFormatError, no suppressed exception\n+                Arguments.of(ucl(false, true), ClassFormatError.class, false),\n+                \/\/ Valid class data + invalid CRC: No exception\n+                Arguments.of(ucl(true, false), null, false),\n+                \/\/ Valid class data + valid CRC: No exception\n+                Arguments.of(ucl(true, true), null, false),\n+\n+                \/\/ Verify module system class loader:\n+                \/\/ Invalid class data + invalid CRC: ClassFormatError, no suppressed exception\n+                Arguments.of(module(false, false), ClassFormatError.class, false),\n+                \/\/ Invalid class data + valid CRC: ClassFormatError, no suppressed exception\n+                Arguments.of(module(false, true), ClassFormatError.class, false),\n+                \/\/ Valid class data + invalid CRC: No exception\n+                Arguments.of(module(true, false), null, false),\n+                \/\/ Valid class data + valid CRC: No exception\n+                Arguments.of(module(true, true), null, false)\n+        );\n+    }\n+\n+    \/**\n+     * Verify behavior of a class loader with respect to invalid class file data\n+     * and\/or invalid JAR file CRC checksums.\n+     * @param ctx representing URLClassLoader or module system class loader with the backing JAR file\n+     * @param expectedException Exception to expect during class loading\n+     * @param expectSuppressed Whether to expect a suppressed CRC32 exception on the ClassFormatError\n+     *\n+     * @throws ClassNotFoundException if an class cannot be found unexpectedly\n+     * @throws IOException if an unexpected IO error occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"parameters\")\n+    public void verifyClassLoading(Supplier<ClassLoaderContext> ctx,\n+                                   Class<? extends ClassFormatError> expectedException,\n+                                   boolean expectSuppressed)\n+            throws ClassNotFoundException, IOException\n+    {\n+        \/\/ Get the context for the class loader and JAR file\n+        var context = ctx.get();\n+\n+        try {\n+            if (expectedException != null) {\n+                \/\/ Verify that ClassFormatError is thrown\n+                ClassFormatError cfe = assertThrows(expectedException, () -> {\n+                    context.getClassLoader().loadClass(className);\n+                });\n+                \/\/ Check whether CRC mismatch caused suppressed exception\n+                assertEquals(expectSuppressed, isCRC32Suppressed(cfe));\n+            } else {\n+                \/\/ Class should load normally\n+                assertEquals(className, context.getClassLoader().loadClass(className).getName());\n+            }\n+        } finally {\n+            \/\/ Clean up after this test\n+            Files.deleteIfExists(context.getJarFile());\n+        }\n+    }\n+\n+    \/\/ Return true iff ClassFormatError has a suppressed CRC32 mismatch IOException\n+    private static boolean isCRC32Suppressed(ClassFormatError exception) {\n+        for (Throwable t : exception.getSuppressed()) {\n+            if (t instanceof IOException ioe &&\n+                    \"CRC error while extracting entry from JAR file\".equals(ioe.getMessage())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ Abstraction of URLClassLoader \/ module system class loader context\n+    interface ClassLoaderContext {\n+        ClassLoader getClassLoader();\n+        Path getJarFile();\n+    }\n+\n+    \/\/ A ClassLoadingContext for loading classes using URLClassLoader\n+    static class URLClassLoaderContext implements ClassLoaderContext {\n+        private final Path jarFile;\n+\n+        private final URLClassLoader loader;\n+\n+        URLClassLoaderContext(Path jarFile, URLClassLoader loader) {\n+            this.jarFile = jarFile;\n+            this.loader = loader;\n+        }\n+\n+        @Override\n+        public ClassLoader getClassLoader() {\n+            return loader;\n+        }\n+        @Override\n+        public Path getJarFile() {\n+            return jarFile;\n+        }\n+\n+    }\n+\n+\n+    \/\/ A ClassLoadingContext for loading classes using the module system\n+    private static class ModuleClassLoaderContext implements ClassLoaderContext {\n+\n+        private final Module module;\n+        private final Path jarFile;\n+\n+        private ModuleClassLoaderContext(Module module, Path jarFile) {\n+            this.module = module;\n+            this.jarFile = jarFile;\n+        }\n+\n+        @Override\n+        public ClassLoader getClassLoader() {\n+            return module.getClassLoader();\n+        }\n+\n+        @Override\n+        public Path getJarFile() {\n+            return jarFile;\n+        }\n+    }\n+\n+    \/\/ Create a context for loading classes from a JAR file using URLClassLoader\n+    private static Supplier<ClassLoaderContext> ucl(boolean validClass, boolean validCrc) throws IOException {\n+        return () -> {\n+            try {\n+                Path jarFile = createJarFile(validClass, validCrc);\n+                return new URLClassLoaderContext(jarFile, new URLClassLoader(new URL[] {jarFile.toUri().toURL()}));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        };\n+    }\n+\n+    \/\/ Create a context for loading classes from a JAR file using the module system\n+    private static Supplier<ClassLoaderContext> module(boolean validClass, boolean validCrc) throws IOException {\n+        return () -> {\n+            try {\n+                Path jarFile = createJarFile(validClass, validCrc);\n+                \/\/ Load the module\n+                ModuleFinder moduleFinder = ModuleFinder.of(jarFile);\n+                Configuration parent = ModuleLayer.boot().configuration();\n+\n+                Configuration configuration = parent.resolve(moduleFinder, ModuleFinder.of(), Set.of(\"m1\"));\n+\n+                ModuleLayer.Controller controller = ModuleLayer.defineModulesWithOneLoader(configuration,\n+                        Collections.singletonList(ModuleLayer.boot()),\n+                        InvalidCRCClassData.class.getClassLoader());\n+\n+\n+                Module m1 = controller.layer().findModule(\"m1\").orElseThrow();\n+                return new ModuleClassLoaderContext(m1, jarFile);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        };\n+    }\n+\n+    \/\/ Create a JAR \/ module file for use in this test,\n+    \/\/ optionally with invalid class file data and\/or invalid CRC checksum\n+    private static Path createJarFile(boolean validClass, boolean validCrc) throws IOException {\n+        \/\/ Create a ZIP file with an invalid class file\n+        Path zipFile = Path.of(\"invalid-class-data.jar\");\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (var zo = new ZipOutputStream(out)) {\n+            \/\/ Write library class\n+            String entryName = className.replace('.', '\/') +\".class\";\n+            zo.putNextEntry(new ZipEntry(entryName));\n+            if (!validClass) {\n+                \/\/ Invalid class file data\n+                zo.write(\"efac\".getBytes(StandardCharsets.UTF_8));\n+            }\n+            zo.write(libraryClass());\n+\n+            \/\/ Write module descriptor\n+            zo.putNextEntry(new ZipEntry(\"module-info.class\"));\n+            ModuleDescriptor descriptor = ModuleDescriptor.newModule(\"m1\")\n+                    .requires(\"java.base\")\n+                    .build();\n+            ModuleInfoWriter.write(descriptor, zo);\n+        }\n+\n+        byte[] bytes = out.toByteArray();\n+\n+        if (!validCrc) {\n+            \/\/ Put an invalid CRC value in the CEN header for the class file entry\n+            ByteBuffer buf = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n+            int cenOff = buf.getInt(bytes.length - ZipEntry.ENDHDR + ZipEntry.ENDOFF);\n+            buf.putInt(cenOff + ZipEntry.CENCRC, 0x0);\n+        }\n+\n+        \/\/ Write the file to disk\n+        Files.write(zipFile, bytes);\n+        return zipFile;\n+    }\n+\n+    \/\/ Build a valid class file byte array\n+    private static byte[] libraryClass() {\n+        return ClassFile.of().build(ClassDesc.of(className), cb -> {\n+            cb.withSuperclass(ConstantDescs.CD_Object);\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/InvalidCRCClassData.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"}]}