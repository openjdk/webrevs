{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -62,1 +61,0 @@\n-    private final char descriptorChar;\n@@ -106,1 +104,0 @@\n-        this.descriptorChar = descriptor.charAt(0);\n@@ -139,5 +136,13 @@\n-        var ret = fromChar(s.charAt(0));\n-        if (ret == null) {\n-            throw new IllegalArgumentException(\"Bad type: \" + s);\n-        }\n-        return ret;\n+        return switch (s.charAt(0)) {\n+            case '[', 'L' -> TypeKind.ReferenceType;\n+            case 'B' -> TypeKind.ByteType;\n+            case 'C' -> TypeKind.CharType;\n+            case 'Z' -> TypeKind.BooleanType;\n+            case 'S' -> TypeKind.ShortType;\n+            case 'I' -> TypeKind.IntType;\n+            case 'F' -> TypeKind.FloatType;\n+            case 'J' -> TypeKind.LongType;\n+            case 'D' -> TypeKind.DoubleType;\n+            case 'V' -> TypeKind.VoidType;\n+            default -> throw new IllegalArgumentException(\"Bad type: \" + s);\n+        };\n@@ -155,18 +160,0 @@\n-\n-    private static final @Stable TypeKind[] TABLE = new TypeKind[16];\n-\n-    static {\n-        for (TypeKind kind : values()) {\n-            char c = kind.descriptorChar;\n-            TABLE[(c + (c >> 1)) & 0xf] = kind;\n-        }\n-        TABLE[8] = TypeKind.ReferenceType; \/\/ hash for '['\n-    }\n-\n-    private static TypeKind fromChar(char c) {\n-        var tk = TABLE[(c + (c >> 1)) & 0xf];\n-        if (tk.descriptorChar == c || c == '[') {\n-            return tk;\n-        }\n-        return null;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -49,29 +48,0 @@\n-\n-    @Test\n-    void testMapping() {\n-        for (char c : \"BCDFIJSZVL[\".toCharArray()) {\n-            var s = String.valueOf(c);\n-            assertEquals(fromDescriptorSwitch(s), TypeKind.fromDescriptor(s));\n-        }\n-\n-        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"E\"));\n-        \/\/ hash of P same as [\n-        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"P\"));\n-    }\n-\n-    \/\/ The known correct switch-based version of fromDescriptor\n-    private static TypeKind fromDescriptorSwitch(String s) {\n-        return switch (s.charAt(0)) {\n-            case '[', 'L' -> TypeKind.ReferenceType;\n-            case 'B' -> TypeKind.ByteType;\n-            case 'C' -> TypeKind.CharType;\n-            case 'Z' -> TypeKind.BooleanType;\n-            case 'S' -> TypeKind.ShortType;\n-            case 'I' -> TypeKind.IntType;\n-            case 'F' -> TypeKind.FloatType;\n-            case 'J' -> TypeKind.LongType;\n-            case 'D' -> TypeKind.DoubleType;\n-            case 'V' -> TypeKind.VoidType;\n-            default -> throw new IllegalArgumentException(\"Bad type: \" + s);\n-        };\n-    }\n","filename":"test\/jdk\/jdk\/classfile\/TypeKindTest.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"}]}