{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -61,0 +62,1 @@\n+    private final char descriptorChar;\n@@ -104,0 +106,1 @@\n+        this.descriptorChar = descriptor.charAt(0);\n@@ -136,13 +139,5 @@\n-        return switch (s.charAt(0)) {\n-            case '[', 'L' -> TypeKind.ReferenceType;\n-            case 'B' -> TypeKind.ByteType;\n-            case 'C' -> TypeKind.CharType;\n-            case 'Z' -> TypeKind.BooleanType;\n-            case 'S' -> TypeKind.ShortType;\n-            case 'I' -> TypeKind.IntType;\n-            case 'F' -> TypeKind.FloatType;\n-            case 'J' -> TypeKind.LongType;\n-            case 'D' -> TypeKind.DoubleType;\n-            case 'V' -> TypeKind.VoidType;\n-            default -> throw new IllegalArgumentException(\"Bad type: \" + s);\n-        };\n+        var ret = fromChar(s.charAt(0));\n+        if (ret == null) {\n+            throw new IllegalArgumentException(\"Bad type: \" + s);\n+        }\n+        return ret;\n@@ -160,0 +155,18 @@\n+\n+    private static final @Stable TypeKind[] TABLE = new TypeKind[16];\n+\n+    static {\n+        for (TypeKind kind : values()) {\n+            char c = kind.descriptorChar;\n+            TABLE[(c + (c >> 1)) & 0xf] = kind;\n+        }\n+        TABLE[8] = TypeKind.ReferenceType; \/\/ hash for '['\n+    }\n+\n+    private static TypeKind fromChar(char c) {\n+        var tk = TABLE[(c + (c >> 1)) & 0xf];\n+        if (tk.descriptorChar == c || c == '[') {\n+            return tk;\n+        }\n+        return null;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -48,0 +49,29 @@\n+\n+    @Test\n+    void testMapping() {\n+        for (char c : \"BCDFIJSZVL[\".toCharArray()) {\n+            var s = String.valueOf(c);\n+            assertEquals(fromDescriptorSwitch(s), TypeKind.fromDescriptor(s));\n+        }\n+\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"E\"));\n+        \/\/ hash of P same as [\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"P\"));\n+    }\n+\n+    \/\/ The known correct switch-based version of fromDescriptor\n+    private static TypeKind fromDescriptorSwitch(String s) {\n+        return switch (s.charAt(0)) {\n+            case '[', 'L' -> TypeKind.ReferenceType;\n+            case 'B' -> TypeKind.ByteType;\n+            case 'C' -> TypeKind.CharType;\n+            case 'Z' -> TypeKind.BooleanType;\n+            case 'S' -> TypeKind.ShortType;\n+            case 'I' -> TypeKind.IntType;\n+            case 'F' -> TypeKind.FloatType;\n+            case 'J' -> TypeKind.LongType;\n+            case 'D' -> TypeKind.DoubleType;\n+            case 'V' -> TypeKind.VoidType;\n+            default -> throw new IllegalArgumentException(\"Bad type: \" + s);\n+        };\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/TypeKindTest.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import java.util.concurrent.ThreadLocalRandom;\n+import java.util.Random;\n@@ -84,1 +84,3 @@\n-        classes = ThreadLocalRandom.current()\n+        \/\/ Use fixed seed to ensure results are comparable across\n+        \/\/ different JVMs\n+        classes = new Random(0xbf5fe40dd887d9e2L)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/classfile\/TypeKindBench.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}