{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-    private final int newarraycode;\n+    private final int newarrayCode;\n@@ -69,3 +69,6 @@\n-    \/** {@return the code used by the {@code newarray} opcode corresponding to this type} *\/\n-    public int newarraycode() {\n-        return newarraycode;\n+    \/**\n+     * {@return the code used by the {@code newarray} opcode corresponding to this type}\n+     * @since 23\n+     *\/\n+    public int newarrayCode() {\n+        return newarrayCode;\n@@ -97,1 +100,1 @@\n-    TypeKind(String name, String descriptor, int newarraycode) {\n+    TypeKind(String name, String descriptor, int newarrayCode) {\n@@ -100,1 +103,1 @@\n-        this.newarraycode = newarraycode;\n+        this.newarrayCode = newarrayCode;\n@@ -106,1 +109,3 @@\n-     * @param newarraycode the operand of the {@code newarray} instruction\n+     * @param newarrayCode the operand of the {@code newarray} instruction\n+     * @throws IllegalArgumentException if the code is invalid\n+     * @since 23\n@@ -108,2 +113,2 @@\n-    public static TypeKind fromNewArrayCode(int newarraycode) {\n-        return switch (newarraycode) {\n+    public static TypeKind fromNewarrayCode(int newarrayCode) {\n+        return switch (newarrayCode) {\n@@ -118,1 +123,1 @@\n-            default -> throw new IllegalArgumentException(\"Bad new array code: \" + newarraycode);\n+            default -> throw new IllegalArgumentException(\"Bad newarray code: \" + newarrayCode);\n@@ -125,0 +130,1 @@\n+     * @throws IllegalArgumentException only if the descriptor is not valid\n@@ -127,0 +133,3 @@\n+        if (s.isEmpty()) { \/\/ implicit null check\n+            throw new IllegalArgumentException(\"Empty descriptor\");\n+        }\n@@ -147,1 +156,3 @@\n-        return fromDescriptor(descriptor.descriptorString());\n+        return descriptor.isPrimitive() \/\/ implicit null check\n+                ? fromDescriptor(descriptor.descriptorString())\n+                : TypeKind.ReferenceType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        if (typeKind.newarraycode() < 0) {\n+        if (typeKind.newarrayCode() < 0) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-            return TypeKind.fromNewArrayCode(code.classReader.readU1(pos + 1));\n+            return TypeKind.fromNewarrayCode(code.classReader.readU1(pos + 1));\n@@ -1152,1 +1152,1 @@\n-            writer.writeNewPrimitiveArray(typeKind.newarraycode());\n+            writer.writeNewPrimitiveArray(typeKind.newarrayCode());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing TypeKind.\n+ * @bug 8331744\n+ * @run junit TypeKindTest\n+ *\/\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.classfile.TypeKind;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+class TypeKindTest {\n+    @Test\n+    void testContracts() {\n+        assertThrows(NullPointerException.class, () -> TypeKind.from(null));\n+\n+        assertThrows(NullPointerException.class, () -> TypeKind.fromDescriptor(null));\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"\"));\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"int\"));\n+\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromNewarrayCode(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromNewarrayCode(21));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/TypeKindTest.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.classfile;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Performance of conversion from type descriptor objects to type kind.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@State(Scope.Thread)\n+public class TypeKindBench {\n+\n+    public enum ClassType {\n+        PRIMITIVE, REFERENCE;\n+    }\n+\n+    @Param\n+    ClassType type;\n+    Class<?>[] classes;\n+    ClassDesc[] classDescs;\n+\n+    @Setup\n+    public void setup() {\n+        final List<Class<?>> candidates = type == ClassType.REFERENCE\n+                ? List.of(Character.class, String.class, Integer.class,\n+                Long.class, Object.class, int[].class, TypeKindBench.class,\n+                Byte[].class, boolean[][].class)\n+                : List.of(int.class, long.class, void.class, double.class,\n+                float.class, boolean.class, char.class, short.class, byte.class);\n+        classes = ThreadLocalRandom.current()\n+                .ints(100, 0, candidates.size())\n+                .mapToObj(candidates::get)\n+                .toArray(Class<?>[]::new);\n+        classDescs = Arrays.stream(classes)\n+                .map(cl -> cl.describeConstable().orElseThrow())\n+                .toArray(ClassDesc[]::new);\n+    }\n+\n+    @Benchmark\n+    public void fromClasses(Blackhole bh) {\n+        for (var clz : classes) {\n+            bh.consume(TypeKind.from(clz));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fromClassDescs(Blackhole bh) {\n+        for (var clz : classDescs) {\n+            bh.consume(TypeKind.from(clz));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/classfile\/TypeKindBench.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}