{"files":[{"patch":"@@ -2881,1 +2881,0 @@\n-  push_bool_with_cmpu_and_mask(worklist, use);\n@@ -2928,51 +2927,0 @@\n-\/\/ Look for the following shape, which can be optimized by BoolNode::Value_cmpu_and_mask() (i.e. corresponds to case\n-\/\/ (1b): \"(m & x) <u (m + 1))\".\n-\/\/ If any of the inputs on the level (%%) change, we need to revisit Bool because we could have prematurely found that\n-\/\/ the Bool is constant (i.e. case (1b) can be applied) which could become invalid with new type information during CCP.\n-\/\/\n-\/\/  m    x  m    1  (%%)\n-\/\/   \\  \/    \\  \/\n-\/\/   AndI    AddI\n-\/\/      \\    \/\n-\/\/       CmpU\n-\/\/        |\n-\/\/       Bool\n-\/\/\n-void PhaseCCP::push_bool_with_cmpu_and_mask(Unique_Node_List& worklist, const Node* use) const {\n-  uint use_op = use->Opcode();\n-  if (use_op != Op_AndI && (use_op != Op_AddI || use->in(2)->find_int_con(0) != 1)) {\n-    \/\/ Not \"m & x\" or \"m + 1\"\n-    return;\n-  }\n-  for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n-    Node* cmpu = use->fast_out(i);\n-    if (cmpu->Opcode() == Op_CmpU) {\n-      push_bool_matching_case1b(worklist, cmpu);\n-    }\n-  }\n-}\n-\n-\/\/ Push any Bool below 'cmpu' that matches case (1b) of BoolNode::Value_cmpu_and_mask().\n-void PhaseCCP::push_bool_matching_case1b(Unique_Node_List& worklist, const Node* cmpu) const {\n-  assert(cmpu->Opcode() == Op_CmpU, \"must be\");\n-  for (DUIterator_Fast imax, i = cmpu->fast_outs(imax); i < imax; i++) {\n-    Node* bol = cmpu->fast_out(i);\n-    if (!bol->is_Bool() || bol->as_Bool()->_test._test != BoolTest::lt) {\n-      \/\/ Not a Bool with \"<u\"\n-      continue;\n-    }\n-    Node* andI = cmpu->in(1);\n-    Node* addI = cmpu->in(2);\n-    if (andI->Opcode() != Op_AndI || addI->Opcode() != Op_AddI || addI->in(2)->find_int_con(0) != 1) {\n-      \/\/ Not \"m & x\" and \"m + 1\"\n-      continue;\n-    }\n-\n-    Node* m = addI->in(1);\n-    if (m == andI->in(1) || m == andI->in(2)) {\n-      \/\/ Is \"m\" shared? Matched (1b) and thus we revisit Bool.\n-      push_if_not_bottom_type(worklist, bol);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -641,2 +641,0 @@\n-  void push_bool_with_cmpu_and_mask(Unique_Node_List& worklist, const Node* use) const;\n-  void push_bool_matching_case1b(Unique_Node_List& worklist, const Node* cmpu) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -804,0 +804,75 @@\n+\/\/ We use the following Lemmas\/insights for the following two transformations (1) and (2):\n+\/\/   x & y <=u y, for any x and y           (Lemma 1, masking always results in a smaller unsigned number)\n+\/\/   y <u y + 1 is always true if y != -1   (Lemma 2, (uint)(-1 + 1) == (uint)(UINT_MAX + 1) which overflows)\n+\/\/   y <u 0 is always false for any y       (Lemma 3, 0 == UINT_MIN and nothing can be smaller than that)\n+\/\/\n+\/\/ (1a) Always:     Change ((x & m) <=u m  ) or ((m & x) <=u m  ) to always true   (true by Lemma 1)\n+\/\/ (1b) If m != -1: Change ((x & m) <u  m + 1) or ((m & x) <u  m + 1) to always true:\n+\/\/    x & m <=u m          is always true   \/\/ (Lemma 1)\n+\/\/    x & m <=u m <u m + 1 is always true   \/\/ (Lemma 2: m <u m + 1, if m != -1)\n+\/\/\n+\/\/ A counter example for (1b), if we allowed m == -1:\n+\/\/     (x & m)  <u m + 1\n+\/\/     (x & -1) <u 0\n+\/\/      x       <u 0\n+\/\/   which is false for any x (Lemma 3)\n+\/\/\n+\/\/ (2) Change ((x & (m - 1)) <u m) or (((m - 1) & x) <u m) to (m >u 0)\n+\/\/ This is the off-by-one variant of the above.\n+\/\/\n+\/\/ We now prove that this replacement is correct. This is the same as proving\n+\/\/   \"m >u 0\" if and only if \"x & (m - 1) <u m\", i.e. \"m >u 0 <=> x & (m - 1) <u m\"\n+\/\/\n+\/\/ We use (Lemma 1) and (Lemma 3) from above.\n+\/\/\n+\/\/ Case \"x & (m - 1) <u m => m >u 0\":\n+\/\/   We prove this by contradiction:\n+\/\/     Assume m <=u 0 which is equivalent to m == 0:\n+\/\/   and thus\n+\/\/     x & (m - 1) <u m = 0               \/\/ m == 0\n+\/\/     y           <u     0               \/\/ y = x & (m - 1)\n+\/\/   by Lemma 3, this is always false, i.e. a contradiction to our assumption.\n+\/\/\n+\/\/ Case \"m >u 0 => x & (m - 1) <u m\":\n+\/\/   x & (m - 1) <=u (m - 1)              \/\/ (Lemma 1)\n+\/\/   x & (m - 1) <=u (m - 1) <u m         \/\/ Using assumption m >u 0, no underflow of \"m - 1\"\n+\/\/\n+\/\/\n+\/\/ Note that the signed version of \"m > 0\":\n+\/\/   m > 0 <=> x & (m - 1) <u m\n+\/\/ does not hold:\n+\/\/   Assume m == -1 and x == -1:\n+\/\/     x  & (m - 1) <u m\n+\/\/     -1 & -2      <u -1\n+\/\/     -2           <u -1\n+\/\/     UINT_MAX - 1 <u UINT_MAX           \/\/ Signed to unsigned numbers\n+\/\/ which is true while\n+\/\/   m > 0\n+\/\/ is false which is a contradiction.\n+\/\/\n+\/\/ (1a) and (1b) is covered by this method since we can directly return the corresponding TypeInt::CC_*\n+\/\/ while (2) is covered in BoolNode::Ideal since we create a new non-constant node (see [CMPU_MASK]).\n+const Type* CmpUNode::Value_cmpu_and_mask(PhaseValues* phase, const Node* in1, const Node* in2) {\n+  if (in1->Opcode() == Op_AndI) {\n+    \/\/ (1a) \"(x & m) <=u m\" and \"(m & x) <=u m\" are always true,\n+    \/\/ so CmpU(x & m, m) and CmpU(m & x, m) are known to be LE.\n+    const Node* rhs_m = in2;\n+    if (in1->in(2) == rhs_m || in1->in(1) == rhs_m) {\n+      return TypeInt::CC_LE;\n+    }\n+    \/\/ (1b) \"(x & m) <u m + 1\" and \"(m & x) <u m + 1\" are always true for m != -1,\n+    \/\/ so CmpU(x & m, m + 1) and CmpU(m & x, m + 1) are known to be LT.\n+    if (in2->Opcode() == Op_AddI && in2->in(2)->find_int_con(0) == 1) {\n+      rhs_m = in2->in(1);\n+      const TypeInt* rhs_m_type = phase->type(rhs_m)->isa_int();\n+      \/\/ Exclude any case where m == -1 is possible.\n+      if (rhs_m_type != nullptr && (rhs_m_type->_lo > -1 || rhs_m_type->_hi < -1)) {\n+        if (in1->in(2) == rhs_m || in1->in(1) == rhs_m) {\n+          return TypeInt::CC_LT;\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -811,0 +886,4 @@\n+  t = Value_cmpu_and_mask(phase, in1, in2);\n+  if (t != nullptr) {\n+    return t;\n+  }\n@@ -1642,1 +1721,1 @@\n-  \/\/ This is case [CMPU_MASK] which is further described at the method comment of BoolNode::Value_cmpu_and_mask().\n+  \/\/ This is case [CMPU_MASK] which is further described at the method comment of CmpUNode::Value_cmpu_and_mask().\n@@ -1817,81 +1896,0 @@\n-\/\/ We use the following Lemmas\/insights for the following two transformations (1) and (2):\n-\/\/   x & y <=u y, for any x and y           (Lemma 1, masking always results in a smaller unsigned number)\n-\/\/   y <u y + 1 is always true if y != -1   (Lemma 2, (uint)(-1 + 1) == (uint)(UINT_MAX + 1) which overflows)\n-\/\/   y <u 0 is always false for any y       (Lemma 3, 0 == UINT_MIN and nothing can be smaller than that)\n-\/\/\n-\/\/ (1a) Always:     Change ((x & m) <=u m  ) or ((m & x) <=u m  ) to always true   (true by Lemma 1)\n-\/\/ (1b) If m != -1: Change ((x & m) <u  m + 1) or ((m & x) <u  m + 1) to always true:\n-\/\/    x & m <=u m          is always true   \/\/ (Lemma 1)\n-\/\/    x & m <=u m <u m + 1 is always true   \/\/ (Lemma 2: m <u m + 1, if m != -1)\n-\/\/\n-\/\/ A counter example for (1b), if we allowed m == -1:\n-\/\/     (x & m)  <u m + 1\n-\/\/     (x & -1) <u 0\n-\/\/      x       <u 0\n-\/\/   which is false for any x (Lemma 3)\n-\/\/\n-\/\/ (2) Change ((x & (m - 1)) <u m) or (((m - 1) & x) <u m) to (m >u 0)\n-\/\/ This is the off-by-one variant of the above.\n-\/\/\n-\/\/ We now prove that this replacement is correct. This is the same as proving\n-\/\/   \"m >u 0\" if and only if \"x & (m - 1) <u m\", i.e. \"m >u 0 <=> x & (m - 1) <u m\"\n-\/\/\n-\/\/ We use (Lemma 1) and (Lemma 3) from above.\n-\/\/\n-\/\/ Case \"x & (m - 1) <u m => m >u 0\":\n-\/\/   We prove this by contradiction:\n-\/\/     Assume m <=u 0 which is equivalent to m == 0:\n-\/\/   and thus\n-\/\/     x & (m - 1) <u m = 0               \/\/ m == 0\n-\/\/     y           <u     0               \/\/ y = x & (m - 1)\n-\/\/   by Lemma 3, this is always false, i.e. a contradiction to our assumption.\n-\/\/\n-\/\/ Case \"m >u 0 => x & (m - 1) <u m\":\n-\/\/   x & (m - 1) <=u (m - 1)              \/\/ (Lemma 1)\n-\/\/   x & (m - 1) <=u (m - 1) <u m         \/\/ Using assumption m >u 0, no underflow of \"m - 1\"\n-\/\/\n-\/\/\n-\/\/ Note that the signed version of \"m > 0\":\n-\/\/   m > 0 <=> x & (m - 1) <u m\n-\/\/ does not hold:\n-\/\/   Assume m == -1 and x == -1:\n-\/\/     x  & (m - 1) <u m\n-\/\/     -1 & -2      <u -1\n-\/\/     -2           <u -1\n-\/\/     UINT_MAX - 1 <u UINT_MAX           \/\/ Signed to unsigned numbers\n-\/\/ which is true while\n-\/\/   m > 0\n-\/\/ is false which is a contradiction.\n-\/\/\n-\/\/ (1a) and (1b) is covered by this method since we can directly return a true value as type while (2) is covered\n-\/\/ in BoolNode::Ideal since we create a new non-constant node (see [CMPU_MASK]).\n-const Type* BoolNode::Value_cmpu_and_mask(PhaseValues* phase) const {\n-  Node* cmp = in(1);\n-  if (cmp != nullptr && cmp->Opcode() == Op_CmpU) {\n-    Node* cmp1 = cmp->in(1);\n-    Node* cmp2 = cmp->in(2);\n-\n-    if (cmp1->Opcode() == Op_AndI) {\n-      Node* m = nullptr;\n-      if (_test._test == BoolTest::le) {\n-        \/\/ (1a) \"((x & m) <=u m)\", cmp2 = m\n-        m = cmp2;\n-      } else if (_test._test == BoolTest::lt && cmp2->Opcode() == Op_AddI && cmp2->in(2)->find_int_con(0) == 1) {\n-        \/\/ (1b) \"(x & m) <u m + 1\" and \"(m & x) <u m + 1\", cmp2 = m + 1\n-        Node* rhs_m = cmp2->in(1);\n-        const TypeInt* rhs_m_type = phase->type(rhs_m)->isa_int();\n-        if (rhs_m_type != nullptr && (rhs_m_type->_lo > -1 || rhs_m_type->_hi < -1)) {\n-          \/\/ Exclude any case where m == -1 is possible.\n-          m = rhs_m;\n-        }\n-      }\n-\n-      if (cmp1->in(2) == m || cmp1->in(1) == m) {\n-        return TypeInt::ONE;\n-      }\n-    }\n-  }\n-\n-  return nullptr;\n-}\n-\n@@ -1901,10 +1899,1 @@\n-  const Type* input_type = phase->type(in(1));\n-  if (input_type == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  const Type* t = Value_cmpu_and_mask(phase);\n-  if (t != nullptr) {\n-    return t;\n-  }\n-\n-  return _test.cc2logical(input_type);\n+  return _test.cc2logical( phase->type( in(1) ) );\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":81,"deletions":92,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+  static const Type* Value_cmpu_and_mask(PhaseValues*, const Node*, const Node*);\n@@ -362,1 +363,0 @@\n-  const Type* Value_cmpu_and_mask(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}