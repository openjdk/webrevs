{"files":[{"patch":"@@ -853,2 +853,31 @@\n-\/\/ (1a) and (1b) is covered by this method since we can directly return the corresponding TypeInt::CC_*\n-\/\/ while (2) is covered in BoolNode::Ideal since we create a new non-constant node (see [CMPU_MASK]).\n+\/\/ (1a) and (1b) is covered by this method since we can directly return the\n+\/\/ corresponding TypeInt::CC_* while (2) is covered in BoolNode::Ideal since\n+\/\/ we create a new non-constant node (see [CMPU_MASK]).\n+\/\/\n+\/\/ Depending on the _test of the child(ren) Bool node(s) of CmpU, the following\n+\/\/ optimizations will be later performed in BoolTest::cc2logical.\n+\/\/\n+\/\/ (1a) \"(x & m) <=u m\" is always true, so type(CmpU) = CC_LE.\n+\/\/\n+\/\/      | BoolTest | CmpU + Bool expression  |      Result       |\n+\/\/      |----------|-------------------------|-------------------|\n+\/\/      |    eq    |     (x & m)  ==u  m     |      unknown      |\n+\/\/      |    ne    |     (x & m)  !=u  m     |      unknown      |\n+\/\/      |~~~ le ~~~|~~~~ (x & m)  <=u  m ~~~~|~~~~~~ true ~~~~~~~|\n+\/\/      |    ge    |     (x & m)  >=u  m     |      unknown      |\n+\/\/      |    lt    |     (x & m)   <u  m     |      unknown      |\n+\/\/      |    gt    |     (x & m)   >u  m     |       false       |\n+\/\/\n+\/\/ (1b) \"(x & m) <u m + 1\" is always true (if m != -1), so type(CmpU) = CC_LT.\n+\/\/\n+\/\/      | BoolTest | CmpU + Bool expression  | Result if m != -1 |\n+\/\/      |----------|-------------------------|-------------------|\n+\/\/      |    eq    |   (x & m)  ==u  m + 1   |       false       |\n+\/\/      |    ne    |   (x & m)  !=u  m + 1   |       true        |\n+\/\/      |    le    |   (x & m)  <=u  m + 1   |       true        |\n+\/\/      |    ge    |   (x & m)  >=u  m + 1   |       false       |\n+\/\/      |~~~ lt ~~~|~~ (x & m)   <u  m + 1 ~~|~~~~~~ true ~~~~~~~|\n+\/\/      |    gt    |   (x & m)   >u  m + 1   |       false       |\n+\/\/\n+\/\/ NOTE: all the cases with \"m & x\" also apply.\n+\/\/\n@@ -859,0 +888,2 @@\n+    \/\/ NOTE: any CCP update to \"m\" will push the CmpUNode to the worklist,\n+    \/\/ since rhs_m is a direct input of it.\n@@ -865,0 +896,2 @@\n+    \/\/ NOTE: any CCP update to \"m\" or \"1\" will push the CmpUNode to the worklist,\n+    \/\/ this granchild push is handled by PhaseCCP::push_cmpu.\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -44,3 +44,3 @@\n-     * Test changing ((x & m) u<= m) or ((m & x) u<= m) to always true, same with ((x & m) u< m+1) and ((m & x) u< m+1)\n-     * The test is only applicable to x64, aarch64 and riscv64 for having <code>Integer.compareUnsigned<\/code>\n-     * intrinsified.\n+     * Test CmpUNode::Value_cmpu_and_mask optimizations for cases 1a and 1b.\n+     * The test is only applicable to x64, aarch64 and riscv64 for having\n+     * <code>Integer.compareUnsigned<\/code> intrinsified.\n@@ -48,0 +48,101 @@\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForEQxm(int x, int m) {\n+        \/\/ [BoolTest::eq] 1a) x & m =u m is unknown\n+        return Integer.compareUnsigned((x & m), m) == 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForEQmx(int x, int m) {\n+        \/\/ [BoolTest::eq] 1a) m & x =u m is unknown\n+        return Integer.compareUnsigned((m & x), m) == 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForNExm(int x, int m) {\n+        \/\/ [BoolTest::ne] 1a) x & m ≠u m is unknown\n+        return Integer.compareUnsigned((x & m), m) != 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForNEmx(int x, int m) {\n+        \/\/ [BoolTest::ne] 1a) m & x ≠u m is unknown\n+        return Integer.compareUnsigned((m & x), m) != 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aOptimizeAsTrueForLExm(int x, int m) {\n+        \/\/ [BoolTest::le] 1a) x & m ≤u m is always true\n+        return Integer.compareUnsigned((x & m), m) <= 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aOptimizeAsTrueForLEmx(int x, int m) {\n+        \/\/ [BoolTest::le] 1a) m & x ≤u m is always true\n+        return Integer.compareUnsigned((m & x), m) <= 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForGExm(int x, int m) {\n+        \/\/ [BoolTest::ge] 1a) x & m ≥u m is unknown\n+        return Integer.compareUnsigned((x & m), m) >= 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForGEmx(int x, int m) {\n+        \/\/ [BoolTest::ge] 1a) m & x ≥u m is unknown\n+        return Integer.compareUnsigned((m & x), m) >= 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForLTxm(int x, int m) {\n+        \/\/ [BoolTest::lt] 1a) x & m <u m is unknown\n+        return Integer.compareUnsigned((x & m), m) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForLTmx(int x, int m) {\n+        \/\/ [BoolTest::lt] 1a) m & x <u m is unknown\n+        return Integer.compareUnsigned((m & x), m) < 0;\n+    }\n+\n@@ -53,2 +154,3 @@\n-    public static boolean testShouldReplaceCpmUCase1(int x, int m) {\n-        return !(Integer.compareUnsigned((x & m), m) > 0); \/\/ assert in inversions to generates the pattern looking for\n+    public static boolean testCase1aOptimizeAsFalseForGTxm(int x, int m) {\n+        \/\/ [BoolTest::gt] 1a) x & m >u m is always false\n+        return Integer.compareUnsigned((x & m), m) > 0;\n@@ -56,0 +158,1 @@\n+\n@@ -61,2 +164,91 @@\n-    public static boolean testShouldReplaceCpmUCase2(int x, int m) {\n-        return !(Integer.compareUnsigned((m & x), m) > 0);\n+    public static boolean testCase1aOptimizeAsFalseForGTmx(int x, int m) {\n+        \/\/ [BoolTest::gt] 1a) m & x >u m is always false\n+        return Integer.compareUnsigned((m & x), m) > 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForEQxm(int x, int m) {\n+        \/\/ [BoolTest::eq] 1b) x & m =u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) == 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForEQmx(int x, int m) {\n+        \/\/ [BoolTest::eq] 1b) m & x =u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) == 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsTrueForNExm(int x, int m) {\n+        \/\/ [BoolTest::ne] 1b) x & m ≠u m + 1 is always true (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) != 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsTrueForNEmx(int x, int m) {\n+        \/\/ [BoolTest::ne] 1b) m & x ≠u m + 1 is always true (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) != 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsTrueForLExm(int x, int m) {\n+        \/\/ [BoolTest::le] 1b) x & m ≤u m + 1 is always true (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) <= 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsTrueForLEmx(int x, int m) {\n+        \/\/ [BoolTest::le] 1b) m & x ≤u m + 1 is always true (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) <= 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForGExm(int x, int m) {\n+        \/\/ [BoolTest::ge] 1b) x & m ≥u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) >= 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForGEmx(int x, int m) {\n+        \/\/ [BoolTest::ge] 1b) m & x ≥u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) >= 0;\n@@ -70,1 +262,2 @@\n-    public static boolean testShouldReplaceCpmUCase3(int x, int m) {\n+    public static boolean testCase1bOptimizeAsTrueForLTxm(int x, int m) {\n+        \/\/ [BoolTest::lt] 1b) x & m <u m + 1 is always true (if m ≠ -1)\n@@ -80,1 +273,2 @@\n-    public static boolean testShouldReplaceCpmUCase4(int x, int m) {\n+    public static boolean testCase1bOptimizeAsTrueForLTmx(int x, int m) {\n+        \/\/ [BoolTest::lt] 1b) m & x <u m + 1 is always true (if m ≠ -1)\n@@ -85,0 +279,22 @@\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForGTxm(int x, int m) {\n+        \/\/ [BoolTest::gt] 1b) x & m >u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) > 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForGTmx(int x, int m) {\n+        \/\/ [BoolTest::gt] 1b) m & x >u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) > 0;\n+    }\n+\n@@ -109,1 +325,1 @@\n-        return !(Integer.compareUnsigned((x & m), m - 1) > 0);\n+        return Integer.compareUnsigned((x & m), m - 1) <= 0;\n@@ -118,1 +334,1 @@\n-        return !(Integer.compareUnsigned((m & x), m - 1) > 0);\n+        return Integer.compareUnsigned((m & x), m - 1) <= 0;\n@@ -147,5 +363,17 @@\n-                if (!testShouldReplaceCpmUCase1(x, m) ||\n-                    !testShouldReplaceCpmUCase2(x, m) ||\n-                    !testShouldReplaceCpmUCase3(x, m) ||\n-                    !testShouldReplaceCpmUCase4(x, m)) {\n-                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m + \", expected always true\");\n+                if (!testCase1aOptimizeAsTrueForLExm(x, m) ||\n+                    !testCase1aOptimizeAsTrueForLEmx(x, m) ||\n+                    testCase1aOptimizeAsFalseForGTxm(x, m) ||\n+                    testCase1aOptimizeAsFalseForGTmx(x, m) ||\n+                    testCase1bOptimizeAsFalseForEQxm(x, m) ||\n+                    testCase1bOptimizeAsFalseForEQmx(x, m) ||\n+                    !testCase1bOptimizeAsTrueForNExm(x, m) ||\n+                    !testCase1bOptimizeAsTrueForNEmx(x, m) ||\n+                    !testCase1bOptimizeAsTrueForLExm(x, m) ||\n+                    !testCase1bOptimizeAsTrueForLEmx(x, m) ||\n+                    testCase1bOptimizeAsFalseForGExm(x, m) ||\n+                    testCase1bOptimizeAsFalseForGEmx(x, m) ||\n+                    !testCase1bOptimizeAsTrueForLTxm(x, m) ||\n+                    !testCase1bOptimizeAsTrueForLTmx(x, m) ||\n+                    testCase1bOptimizeAsFalseForGTxm(x, m) ||\n+                    testCase1bOptimizeAsFalseForGTmx(x, m)) {\n+                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBoolNodeGVN.java","additions":244,"deletions":16,"binary":false,"changes":260,"status":"modified"}]}