{"files":[{"patch":"@@ -2881,1 +2881,0 @@\n-  push_bool_with_cmpu_and_mask(worklist, use);\n@@ -2928,51 +2927,0 @@\n-\/\/ Look for the following shape, which can be optimized by BoolNode::Value_cmpu_and_mask() (i.e. corresponds to case\n-\/\/ (1b): \"(m & x) <u (m + 1))\".\n-\/\/ If any of the inputs on the level (%%) change, we need to revisit Bool because we could have prematurely found that\n-\/\/ the Bool is constant (i.e. case (1b) can be applied) which could become invalid with new type information during CCP.\n-\/\/\n-\/\/  m    x  m    1  (%%)\n-\/\/   \\  \/    \\  \/\n-\/\/   AndI    AddI\n-\/\/      \\    \/\n-\/\/       CmpU\n-\/\/        |\n-\/\/       Bool\n-\/\/\n-void PhaseCCP::push_bool_with_cmpu_and_mask(Unique_Node_List& worklist, const Node* use) const {\n-  uint use_op = use->Opcode();\n-  if (use_op != Op_AndI && (use_op != Op_AddI || use->in(2)->find_int_con(0) != 1)) {\n-    \/\/ Not \"m & x\" or \"m + 1\"\n-    return;\n-  }\n-  for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n-    Node* cmpu = use->fast_out(i);\n-    if (cmpu->Opcode() == Op_CmpU) {\n-      push_bool_matching_case1b(worklist, cmpu);\n-    }\n-  }\n-}\n-\n-\/\/ Push any Bool below 'cmpu' that matches case (1b) of BoolNode::Value_cmpu_and_mask().\n-void PhaseCCP::push_bool_matching_case1b(Unique_Node_List& worklist, const Node* cmpu) const {\n-  assert(cmpu->Opcode() == Op_CmpU, \"must be\");\n-  for (DUIterator_Fast imax, i = cmpu->fast_outs(imax); i < imax; i++) {\n-    Node* bol = cmpu->fast_out(i);\n-    if (!bol->is_Bool() || bol->as_Bool()->_test._test != BoolTest::lt) {\n-      \/\/ Not a Bool with \"<u\"\n-      continue;\n-    }\n-    Node* andI = cmpu->in(1);\n-    Node* addI = cmpu->in(2);\n-    if (andI->Opcode() != Op_AndI || addI->Opcode() != Op_AddI || addI->in(2)->find_int_con(0) != 1) {\n-      \/\/ Not \"m & x\" and \"m + 1\"\n-      continue;\n-    }\n-\n-    Node* m = addI->in(1);\n-    if (m == andI->in(1) || m == andI->in(2)) {\n-      \/\/ Is \"m\" shared? Matched (1b) and thus we revisit Bool.\n-      push_if_not_bottom_type(worklist, bol);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -641,2 +641,0 @@\n-  void push_bool_with_cmpu_and_mask(Unique_Node_List& worklist, const Node* use) const;\n-  void push_bool_matching_case1b(Unique_Node_List& worklist, const Node* cmpu) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -804,0 +804,108 @@\n+\/\/ We use the following Lemmas\/insights for the following two transformations (1) and (2):\n+\/\/   x & y <=u y, for any x and y           (Lemma 1, masking always results in a smaller unsigned number)\n+\/\/   y <u y + 1 is always true if y != -1   (Lemma 2, (uint)(-1 + 1) == (uint)(UINT_MAX + 1) which overflows)\n+\/\/   y <u 0 is always false for any y       (Lemma 3, 0 == UINT_MIN and nothing can be smaller than that)\n+\/\/\n+\/\/ (1a) Always:     Change ((x & m) <=u m  ) or ((m & x) <=u m  ) to always true   (true by Lemma 1)\n+\/\/ (1b) If m != -1: Change ((x & m) <u  m + 1) or ((m & x) <u  m + 1) to always true:\n+\/\/    x & m <=u m          is always true   \/\/ (Lemma 1)\n+\/\/    x & m <=u m <u m + 1 is always true   \/\/ (Lemma 2: m <u m + 1, if m != -1)\n+\/\/\n+\/\/ A counter example for (1b), if we allowed m == -1:\n+\/\/     (x & m)  <u m + 1\n+\/\/     (x & -1) <u 0\n+\/\/      x       <u 0\n+\/\/   which is false for any x (Lemma 3)\n+\/\/\n+\/\/ (2) Change ((x & (m - 1)) <u m) or (((m - 1) & x) <u m) to (m >u 0)\n+\/\/ This is the off-by-one variant of the above.\n+\/\/\n+\/\/ We now prove that this replacement is correct. This is the same as proving\n+\/\/   \"m >u 0\" if and only if \"x & (m - 1) <u m\", i.e. \"m >u 0 <=> x & (m - 1) <u m\"\n+\/\/\n+\/\/ We use (Lemma 1) and (Lemma 3) from above.\n+\/\/\n+\/\/ Case \"x & (m - 1) <u m => m >u 0\":\n+\/\/   We prove this by contradiction:\n+\/\/     Assume m <=u 0 which is equivalent to m == 0:\n+\/\/   and thus\n+\/\/     x & (m - 1) <u m = 0               \/\/ m == 0\n+\/\/     y           <u     0               \/\/ y = x & (m - 1)\n+\/\/   by Lemma 3, this is always false, i.e. a contradiction to our assumption.\n+\/\/\n+\/\/ Case \"m >u 0 => x & (m - 1) <u m\":\n+\/\/   x & (m - 1) <=u (m - 1)              \/\/ (Lemma 1)\n+\/\/   x & (m - 1) <=u (m - 1) <u m         \/\/ Using assumption m >u 0, no underflow of \"m - 1\"\n+\/\/\n+\/\/\n+\/\/ Note that the signed version of \"m > 0\":\n+\/\/   m > 0 <=> x & (m - 1) <u m\n+\/\/ does not hold:\n+\/\/   Assume m == -1 and x == -1:\n+\/\/     x  & (m - 1) <u m\n+\/\/     -1 & -2      <u -1\n+\/\/     -2           <u -1\n+\/\/     UINT_MAX - 1 <u UINT_MAX           \/\/ Signed to unsigned numbers\n+\/\/ which is true while\n+\/\/   m > 0\n+\/\/ is false which is a contradiction.\n+\/\/\n+\/\/ (1a) and (1b) is covered by this method since we can directly return the\n+\/\/ corresponding TypeInt::CC_* while (2) is covered in BoolNode::Ideal since\n+\/\/ we create a new non-constant node (see [CMPU_MASK]).\n+\/\/\n+\/\/ Depending on the _test of the child(ren) Bool node(s) of CmpU, the following\n+\/\/ optimizations will be later performed in BoolTest::cc2logical.\n+\/\/\n+\/\/ (1a) \"(x & m) <=u m\" is always true, so type(CmpU) = CC_LE.\n+\/\/\n+\/\/      | BoolTest | CmpU + Bool expression  |      Result       |\n+\/\/      |----------|-------------------------|-------------------|\n+\/\/      |    eq    |     (x & m)  ==u  m     |      unknown      |\n+\/\/      |    ne    |     (x & m)  !=u  m     |      unknown      |\n+\/\/      |~~~ le ~~~|~~~~ (x & m)  <=u  m ~~~~|~~~~~~ true ~~~~~~~|\n+\/\/      |    ge    |     (x & m)  >=u  m     |      unknown      |\n+\/\/      |    lt    |     (x & m)   <u  m     |      unknown      |\n+\/\/      |    gt    |     (x & m)   >u  m     |       false       |\n+\/\/\n+\/\/ (1b) \"(x & m) <u m + 1\" is always true (if m != -1), so type(CmpU) = CC_LT.\n+\/\/\n+\/\/      | BoolTest | CmpU + Bool expression  | Result if m != -1 |\n+\/\/      |----------|-------------------------|-------------------|\n+\/\/      |    eq    |   (x & m)  ==u  m + 1   |       false       |\n+\/\/      |    ne    |   (x & m)  !=u  m + 1   |       true        |\n+\/\/      |    le    |   (x & m)  <=u  m + 1   |       true        |\n+\/\/      |    ge    |   (x & m)  >=u  m + 1   |       false       |\n+\/\/      |~~~ lt ~~~|~~ (x & m)   <u  m + 1 ~~|~~~~~~ true ~~~~~~~|\n+\/\/      |    gt    |   (x & m)   >u  m + 1   |       false       |\n+\/\/\n+\/\/ NOTE: all the cases with \"m & x\" also apply.\n+\/\/\n+const Type* CmpUNode::Value_cmpu_and_mask(PhaseValues* phase, const Node* andI, const Node* rhs) {\n+  if (andI->Opcode() == Op_AndI) {\n+    \/\/ (1a) \"(x & m) <=u m\" and \"(m & x) <=u m\" are always true,\n+    \/\/ so CmpU(x & m, m) and CmpU(m & x, m) are known to be LE.\n+    \/\/ NOTE: any CCP update to \"m\" will push the CmpUNode to the worklist,\n+    \/\/ since rhs_m is a direct input of it.\n+    const Node* rhs_m = rhs;\n+    if (andI->in(2) == rhs_m || andI->in(1) == rhs_m) {\n+      return TypeInt::CC_LE;\n+    }\n+    \/\/ (1b) \"(x & m) <u m + 1\" and \"(m & x) <u m + 1\" are always true for m != -1,\n+    \/\/ so CmpU(x & m, m + 1) and CmpU(m & x, m + 1) are known to be LT.\n+    \/\/ NOTE: any CCP update to \"m\" or \"1\" will push the CmpUNode to the worklist,\n+    \/\/ this granchild push is handled by PhaseCCP::push_cmpu.\n+    if (rhs->Opcode() == Op_AddI && rhs->in(2)->find_int_con(0) == 1) {\n+      rhs_m = rhs->in(1);\n+      const TypeInt* rhs_m_type = phase->type(rhs_m)->isa_int();\n+      \/\/ Exclude any case where m == -1 is possible.\n+      if (rhs_m_type != nullptr && (rhs_m_type->_lo > -1 || rhs_m_type->_hi < -1)) {\n+        if (andI->in(2) == rhs_m || andI->in(1) == rhs_m) {\n+          return TypeInt::CC_LT;\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -811,0 +919,4 @@\n+  t = Value_cmpu_and_mask(phase, in1, in2);\n+  if (t != nullptr) {\n+    return t;\n+  }\n@@ -1642,1 +1754,1 @@\n-  \/\/ This is case [CMPU_MASK] which is further described at the method comment of BoolNode::Value_cmpu_and_mask().\n+  \/\/ This is case [CMPU_MASK] which is further described at the method comment of CmpUNode::Value_cmpu_and_mask().\n@@ -1817,81 +1929,0 @@\n-\/\/ We use the following Lemmas\/insights for the following two transformations (1) and (2):\n-\/\/   x & y <=u y, for any x and y           (Lemma 1, masking always results in a smaller unsigned number)\n-\/\/   y <u y + 1 is always true if y != -1   (Lemma 2, (uint)(-1 + 1) == (uint)(UINT_MAX + 1) which overflows)\n-\/\/   y <u 0 is always false for any y       (Lemma 3, 0 == UINT_MIN and nothing can be smaller than that)\n-\/\/\n-\/\/ (1a) Always:     Change ((x & m) <=u m  ) or ((m & x) <=u m  ) to always true   (true by Lemma 1)\n-\/\/ (1b) If m != -1: Change ((x & m) <u  m + 1) or ((m & x) <u  m + 1) to always true:\n-\/\/    x & m <=u m          is always true   \/\/ (Lemma 1)\n-\/\/    x & m <=u m <u m + 1 is always true   \/\/ (Lemma 2: m <u m + 1, if m != -1)\n-\/\/\n-\/\/ A counter example for (1b), if we allowed m == -1:\n-\/\/     (x & m)  <u m + 1\n-\/\/     (x & -1) <u 0\n-\/\/      x       <u 0\n-\/\/   which is false for any x (Lemma 3)\n-\/\/\n-\/\/ (2) Change ((x & (m - 1)) <u m) or (((m - 1) & x) <u m) to (m >u 0)\n-\/\/ This is the off-by-one variant of the above.\n-\/\/\n-\/\/ We now prove that this replacement is correct. This is the same as proving\n-\/\/   \"m >u 0\" if and only if \"x & (m - 1) <u m\", i.e. \"m >u 0 <=> x & (m - 1) <u m\"\n-\/\/\n-\/\/ We use (Lemma 1) and (Lemma 3) from above.\n-\/\/\n-\/\/ Case \"x & (m - 1) <u m => m >u 0\":\n-\/\/   We prove this by contradiction:\n-\/\/     Assume m <=u 0 which is equivalent to m == 0:\n-\/\/   and thus\n-\/\/     x & (m - 1) <u m = 0               \/\/ m == 0\n-\/\/     y           <u     0               \/\/ y = x & (m - 1)\n-\/\/   by Lemma 3, this is always false, i.e. a contradiction to our assumption.\n-\/\/\n-\/\/ Case \"m >u 0 => x & (m - 1) <u m\":\n-\/\/   x & (m - 1) <=u (m - 1)              \/\/ (Lemma 1)\n-\/\/   x & (m - 1) <=u (m - 1) <u m         \/\/ Using assumption m >u 0, no underflow of \"m - 1\"\n-\/\/\n-\/\/\n-\/\/ Note that the signed version of \"m > 0\":\n-\/\/   m > 0 <=> x & (m - 1) <u m\n-\/\/ does not hold:\n-\/\/   Assume m == -1 and x == -1:\n-\/\/     x  & (m - 1) <u m\n-\/\/     -1 & -2      <u -1\n-\/\/     -2           <u -1\n-\/\/     UINT_MAX - 1 <u UINT_MAX           \/\/ Signed to unsigned numbers\n-\/\/ which is true while\n-\/\/   m > 0\n-\/\/ is false which is a contradiction.\n-\/\/\n-\/\/ (1a) and (1b) is covered by this method since we can directly return a true value as type while (2) is covered\n-\/\/ in BoolNode::Ideal since we create a new non-constant node (see [CMPU_MASK]).\n-const Type* BoolNode::Value_cmpu_and_mask(PhaseValues* phase) const {\n-  Node* cmp = in(1);\n-  if (cmp != nullptr && cmp->Opcode() == Op_CmpU) {\n-    Node* cmp1 = cmp->in(1);\n-    Node* cmp2 = cmp->in(2);\n-\n-    if (cmp1->Opcode() == Op_AndI) {\n-      Node* m = nullptr;\n-      if (_test._test == BoolTest::le) {\n-        \/\/ (1a) \"((x & m) <=u m)\", cmp2 = m\n-        m = cmp2;\n-      } else if (_test._test == BoolTest::lt && cmp2->Opcode() == Op_AddI && cmp2->in(2)->find_int_con(0) == 1) {\n-        \/\/ (1b) \"(x & m) <u m + 1\" and \"(m & x) <u m + 1\", cmp2 = m + 1\n-        Node* rhs_m = cmp2->in(1);\n-        const TypeInt* rhs_m_type = phase->type(rhs_m)->isa_int();\n-        if (rhs_m_type != nullptr && (rhs_m_type->_lo > -1 || rhs_m_type->_hi < -1)) {\n-          \/\/ Exclude any case where m == -1 is possible.\n-          m = rhs_m;\n-        }\n-      }\n-\n-      if (cmp1->in(2) == m || cmp1->in(1) == m) {\n-        return TypeInt::ONE;\n-      }\n-    }\n-  }\n-\n-  return nullptr;\n-}\n-\n@@ -1901,10 +1932,1 @@\n-  const Type* input_type = phase->type(in(1));\n-  if (input_type == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  const Type* t = Value_cmpu_and_mask(phase);\n-  if (t != nullptr) {\n-    return t;\n-  }\n-\n-  return _test.cc2logical(input_type);\n+  return _test.cc2logical(phase->type(in(1)));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":114,"deletions":92,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+  static const Type* Value_cmpu_and_mask(PhaseValues* phase, const Node* andI, const Node* rhs);\n@@ -362,1 +363,0 @@\n-  const Type* Value_cmpu_and_mask(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @bug 8327381\n+ * @bug 8327381 8364970\n@@ -40,1 +40,0 @@\n-        testCorrectness();\n@@ -44,3 +43,3 @@\n-     * Test changing ((x & m) u<= m) or ((m & x) u<= m) to always true, same with ((x & m) u< m+1) and ((m & x) u< m+1)\n-     * The test is only applicable to x64, aarch64 and riscv64 for having <code>Integer.compareUnsigned<\/code>\n-     * intrinsified.\n+     * Test CmpUNode::Value_cmpu_and_mask optimizations for cases 1a and 1b.\n+     * The test is only applicable to x64, aarch64 and riscv64 for having\n+     * <code>Integer.compareUnsigned<\/code> intrinsified.\n@@ -48,0 +47,21 @@\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForEQxm(int x, int m) {\n+        \/\/ [BoolTest::eq] 1a) x & m =u m is unknown\n+        return Integer.compareUnsigned((x & m), m) == 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForEQmx(int x, int m) {\n+        \/\/ [BoolTest::eq] 1a) m & x =u m is unknown\n+        return Integer.compareUnsigned((m & x), m) == 0;\n+    }\n+\n@@ -50,0 +70,28 @@\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForNExm(int x, int m) {\n+        \/\/ [BoolTest::ne] 1a) x & m ≠u m is unknown\n+        return Integer.compareUnsigned((x & m), m) != 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForNEmx(int x, int m) {\n+        \/\/ [BoolTest::ne] 1a) m & x ≠u m is unknown\n+        return Integer.compareUnsigned((m & x), m) != 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aOptimizeAsTrueForLExm(int x, int m) {\n+        \/\/ [BoolTest::le] 1a) x & m ≤u m is always true\n+        return Integer.compareUnsigned((x & m), m) <= 0;\n+    }\n+\n+    @Test\n@@ -53,2 +101,3 @@\n-    public static boolean testShouldReplaceCpmUCase1(int x, int m) {\n-        return !(Integer.compareUnsigned((x & m), m) > 0); \/\/ assert in inversions to generates the pattern looking for\n+    public static boolean testCase1aOptimizeAsTrueForLEmx(int x, int m) {\n+        \/\/ [BoolTest::le] 1a) m & x ≤u m is always true\n+        return Integer.compareUnsigned((m & x), m) <= 0;\n@@ -56,0 +105,1 @@\n+\n@@ -58,0 +108,67 @@\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForGExm(int x, int m) {\n+        \/\/ [BoolTest::ge] 1a) x & m ≥u m is unknown\n+        return Integer.compareUnsigned((x & m), m) >= 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForGEmx(int x, int m) {\n+        \/\/ [BoolTest::ge] 1a) m & x ≥u m is unknown\n+        return Integer.compareUnsigned((m & x), m) >= 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForLTxm(int x, int m) {\n+        \/\/ [BoolTest::lt] 1a) x & m <u m is unknown\n+        return Integer.compareUnsigned((x & m), m) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aDoNotOptimizeForLTmx(int x, int m) {\n+        \/\/ [BoolTest::lt] 1a) m & x <u m is unknown\n+        return Integer.compareUnsigned((m & x), m) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aOptimizeAsFalseForGTxm(int x, int m) {\n+        \/\/ [BoolTest::gt] 1a) x & m >u m is always false\n+        return Integer.compareUnsigned((x & m), m) > 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1aOptimizeAsFalseForGTmx(int x, int m) {\n+        \/\/ [BoolTest::gt] 1a) m & x >u m is always false\n+        return Integer.compareUnsigned((m & x), m) > 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForEQxm(int x, int m) {\n+        \/\/ [BoolTest::eq] 1b) x & m =u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) == 0;\n+    }\n+\n+    @Test\n@@ -61,2 +178,4 @@\n-    public static boolean testShouldReplaceCpmUCase2(int x, int m) {\n-        return !(Integer.compareUnsigned((m & x), m) > 0);\n+    public static boolean testCase1bOptimizeAsFalseForEQmx(int x, int m) {\n+        \/\/ [BoolTest::eq] 1b) m & x =u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) == 0;\n@@ -66,1 +185,0 @@\n-    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n@@ -70,1 +188,62 @@\n-    public static boolean testShouldReplaceCpmUCase3(int x, int m) {\n+    public static boolean testCase1bOptimizeAsTrueForNExm(int x, int m) {\n+        \/\/ [BoolTest::ne] 1b) x & m ≠u m + 1 is always true (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) != 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsTrueForNEmx(int x, int m) {\n+        \/\/ [BoolTest::ne] 1b) m & x ≠u m + 1 is always true (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) != 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsTrueForLExm(int x, int m) {\n+        \/\/ [BoolTest::le] 1b) x & m ≤u m + 1 is always true (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) <= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsTrueForLEmx(int x, int m) {\n+        \/\/ [BoolTest::le] 1b) m & x ≤u m + 1 is always true (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) <= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForGExm(int x, int m) {\n+        \/\/ [BoolTest::ge] 1b) x & m ≥u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForGEmx(int x, int m) {\n+        \/\/ [BoolTest::ge] 1b) m & x ≥u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsTrueForLTxm(int x, int m) {\n+        \/\/ [BoolTest::lt] 1b) x & m <u m + 1 is always true (if m ≠ -1)\n@@ -76,1 +255,0 @@\n-    @Arguments(values = {Argument.DEFAULT, Argument.RANDOM_EACH})\n@@ -80,1 +258,2 @@\n-    public static boolean testShouldReplaceCpmUCase4(int x, int m) {\n+    public static boolean testCase1bOptimizeAsTrueForLTmx(int x, int m) {\n+        \/\/ [BoolTest::lt] 1b) m & x <u m + 1 is always true (if m ≠ -1)\n@@ -85,0 +264,20 @@\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForGTxm(int x, int m) {\n+        \/\/ [BoolTest::gt] 1b) x & m >u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((x & m), m + 1) > 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testCase1bOptimizeAsFalseForGTmx(int x, int m) {\n+        \/\/ [BoolTest::gt] 1b) m & x >u m + 1 is always false (if m ≠ -1)\n+        m = Math.max(0, m);\n+        return Integer.compareUnsigned((m & x), m + 1) > 0;\n+    }\n+\n@@ -109,1 +308,1 @@\n-        return !(Integer.compareUnsigned((x & m), m - 1) > 0);\n+        return Integer.compareUnsigned((x & m), m - 1) <= 0;\n@@ -118,1 +317,1 @@\n-        return !(Integer.compareUnsigned((m & x), m - 1) > 0);\n+        return Integer.compareUnsigned((m & x), m - 1) <= 0;\n@@ -139,0 +338,16 @@\n+    @Run(test = { \"testCase1aOptimizeAsTrueForLExm\",\n+                  \"testCase1aOptimizeAsTrueForLEmx\",\n+                  \"testCase1aOptimizeAsFalseForGTxm\",\n+                  \"testCase1aOptimizeAsFalseForGTmx\",\n+                  \"testCase1bOptimizeAsFalseForEQxm\",\n+                  \"testCase1bOptimizeAsFalseForEQmx\",\n+                  \"testCase1bOptimizeAsTrueForNExm\",\n+                  \"testCase1bOptimizeAsTrueForNEmx\",\n+                  \"testCase1bOptimizeAsTrueForLExm\",\n+                  \"testCase1bOptimizeAsTrueForLEmx\",\n+                  \"testCase1bOptimizeAsFalseForGExm\",\n+                  \"testCase1bOptimizeAsFalseForGEmx\",\n+                  \"testCase1bOptimizeAsTrueForLTxm\",\n+                  \"testCase1bOptimizeAsTrueForLTmx\",\n+                  \"testCase1bOptimizeAsFalseForGTxm\",\n+                  \"testCase1bOptimizeAsFalseForGTmx\" })\n@@ -147,5 +362,17 @@\n-                if (!testShouldReplaceCpmUCase1(x, m) ||\n-                    !testShouldReplaceCpmUCase2(x, m) ||\n-                    !testShouldReplaceCpmUCase3(x, m) ||\n-                    !testShouldReplaceCpmUCase4(x, m)) {\n-                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m + \", expected always true\");\n+                if (!testCase1aOptimizeAsTrueForLExm(x, m) ||\n+                    !testCase1aOptimizeAsTrueForLEmx(x, m) ||\n+                    testCase1aOptimizeAsFalseForGTxm(x, m) ||\n+                    testCase1aOptimizeAsFalseForGTmx(x, m) ||\n+                    testCase1bOptimizeAsFalseForEQxm(x, m) ||\n+                    testCase1bOptimizeAsFalseForEQmx(x, m) ||\n+                    !testCase1bOptimizeAsTrueForNExm(x, m) ||\n+                    !testCase1bOptimizeAsTrueForNEmx(x, m) ||\n+                    !testCase1bOptimizeAsTrueForLExm(x, m) ||\n+                    !testCase1bOptimizeAsTrueForLEmx(x, m) ||\n+                    testCase1bOptimizeAsFalseForGExm(x, m) ||\n+                    testCase1bOptimizeAsFalseForGEmx(x, m) ||\n+                    !testCase1bOptimizeAsTrueForLTxm(x, m) ||\n+                    !testCase1bOptimizeAsTrueForLTmx(x, m) ||\n+                    testCase1bOptimizeAsFalseForGTxm(x, m) ||\n+                    testCase1bOptimizeAsFalseForGTmx(x, m)) {\n+                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBoolNodeGVN.java","additions":247,"deletions":20,"binary":false,"changes":267,"status":"modified"}]}