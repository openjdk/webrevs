{"files":[{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.net.http.common.ValidatingHeadersConsumer.Context;\n@@ -92,1 +93,0 @@\n-import static jdk.internal.net.http.frame.SettingsFrame.DEFAULT_INITIAL_WINDOW_SIZE;\n@@ -343,0 +343,1 @@\n+            super(Context.REQUEST);\n@@ -987,1 +988,4 @@\n-                        orphanedConsumer = new ValidatingHeadersConsumer();\n+                        orphanedConsumer = new ValidatingHeadersConsumer(\n+                                frame instanceof PushPromiseFrame ?\n+                                        Context.REQUEST :\n+                                        Context.RESPONSE);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1874,1 +1874,6 @@\n-    private class HeadersConsumer extends ValidatingHeadersConsumer implements DecodingCallback {\n+    private final class HeadersConsumer extends ValidatingHeadersConsumer\n+            implements DecodingCallback {\n+\n+        private HeadersConsumer() {\n+            super(Context.RESPONSE);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-    public HeaderDecoder() {\n+    public HeaderDecoder(Context context) {\n+        super(context);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HeaderDecoder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import java.net.ProtocolException;\n+import java.util.Map;\n+import java.util.Objects;\n@@ -36,2 +39,23 @@\n-    private static final Set<String> PSEUDO_HEADERS =\n-            Set.of(\":authority\", \":method\", \":path\", \":scheme\", \":status\");\n+    private final Context context;\n+\n+    public ValidatingHeadersConsumer(Context context) {\n+        this.context = Objects.requireNonNull(context);\n+    }\n+\n+    public enum Context {\n+        REQUEST,\n+        RESPONSE,\n+    }\n+\n+    \/\/ Map of permitted pseudo headers in requests and responses\n+    private static final Map<String, Context> PSEUDO_HEADERS =\n+            Map.of(\":authority\", Context.REQUEST,\n+                    \":method\", Context.REQUEST,\n+                    \":path\", Context.REQUEST,\n+                    \":scheme\", Context.REQUEST,\n+                    \":status\", Context.RESPONSE);\n+\n+    \/\/ connection-specific, prohibited by RFC 9113 section 8.2.2\n+    private static final Set<String> PROHIBITED_HEADERS =\n+            Set.of(\"connection\", \"proxy-connection\", \"keep-alive\",\n+                    \"transfer-encoding\", \"upgrade\");\n@@ -63,2 +87,7 @@\n-            } else if (!PSEUDO_HEADERS.contains(n)) {\n-                throw newException(\"Unknown pseudo-header '%s'\", n);\n+            } else {\n+                Context expectedContext = PSEUDO_HEADERS.get(n);\n+                if (expectedContext == null) {\n+                    throw newException(\"Unknown pseudo-header '%s'\", n);\n+                } else if (expectedContext != context) {\n+                    throw newException(\"Pseudo-header '%s' is not valid in context \" + context, n);\n+                }\n@@ -68,0 +97,9 @@\n+            \/\/ Check for prohibited connection-specific headers.\n+            \/\/ Some servers echo request headers in push promises.\n+            \/\/ If the request was a HTTP\/1.1 upgrade, it included some prohibited headers.\n+            \/\/ For compatibility, we ignore prohibited headers in push promises.\n+            if (context != Context.REQUEST) {\n+                if (PROHIBITED_HEADERS.contains(n)) {\n+                    throw newException(\"Prohibited header name '%s'\", n);\n+                }\n+            }\n@@ -87,1 +125,1 @@\n-                new IOException(formatMessage(message, header)));\n+                new ProtocolException(formatMessage(message, header)));\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/ValidatingHeadersConsumer.java","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,4 @@\n- * @bug 8303965\n+ * @bug 8303965 8354276\n+ * @summary This test verifies the behaviour of the HttpClient when presented\n+ *          with a HEADERS frame followed by CONTINUATION frames, and when presented\n+ *          with bad header fields.\n@@ -47,0 +50,1 @@\n+import java.net.ProtocolException;\n@@ -79,0 +83,2 @@\n+        of(entry(\":status\", \"200\"),  entry(\"connection\", \"close\")),                \/\/ Prohibited connection-specific header\n+        of(entry(\":status\", \"200\"),  entry(\":scheme\", \"https\")),                   \/\/ Request pseudo-header in response\n@@ -89,1 +95,1 @@\n-     * A function that returns a list of 1) a HEADERS frame ( with an empty\n+     * A function that returns a list of 1) one HEADERS frame ( with an empty\n@@ -103,1 +109,1 @@\n-     * A function that returns a list of a HEADERS frame followed by a number of\n+     * A function that returns a list of one HEADERS frame followed by a number of\n@@ -192,1 +198,1 @@\n-            } catch (Throwable t0) {\n+            } catch (Exception t0) {\n@@ -195,1 +201,3 @@\n-                    t0 = t0.getCause();\n+                    t = t0.getCause();\n+                } else {\n+                    t = t0;\n@@ -197,1 +205,0 @@\n-                t = t0;\n@@ -207,2 +214,2 @@\n-            assertTrue(throwable instanceof IOException,\n-                    \"Expected IOException, got, \" + throwable);\n+            assertTrue(throwable instanceof ProtocolException,\n+                    \"Expected ProtocolException, got \" + throwable);\n@@ -215,1 +222,7 @@\n-            } else if (iterationIndex == 4) { \/\/ unexpected\n+            } else if (iterationIndex == 4) { \/\/ prohibited\n+                assertTrue(throwable.getMessage().contains(\"Prohibited header name\"),\n+                        \"Expected \\\"Prohibited header name\\\" in: \" + throwable.getMessage());\n+            } else if (iterationIndex == 5) { \/\/ unexpected type\n+                assertTrue(throwable.getMessage().contains(\"not valid in context\"),\n+                        \"Expected \\\"not valid in context\\\" in: \" + throwable.getMessage());\n+            } else if (iterationIndex == 6) { \/\/ unexpected sequence\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/BadHeadersTest.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8354276\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.http2.Http2TestServer\n+ * @run testng\/othervm\n+ *      -Djdk.internal.httpclient.debug=true\n+ *      -Djdk.httpclient.HttpClient.log=errors,requests,responses,trace\n+ *      BadPushPromiseTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ProtocolException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.net.http.HttpResponse.PushPromiseHandler;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.List.of;\n+import static org.testng.Assert.*;\n+\n+public class BadPushPromiseTest {\n+\n+    private static final List<Map<String, List<String>>> BAD_HEADERS = of(\n+            Map.of(\":hello\", of(\"GET\")),                      \/\/ Unknown pseudo-header\n+            Map.of(\"hell o\", of(\"value\")),                    \/\/ Space in the name\n+            Map.of(\"hello\", of(\"line1\\r\\n  line2\\r\\n\")),      \/\/ Multiline value\n+            Map.of(\"hello\", of(\"DE\" + ((char) 0x7F) + \"L\")),  \/\/ Bad byte in value\n+            Map.of(\":status\", of(\"200\"))                     \/\/ Response pseudo-header in request\n+    );\n+\n+    static final String MAIN_RESPONSE_BODY = \"the main response body\";\n+\n+    HttpServerAdapters.HttpTestServer server;\n+    URI uri;\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        server = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n+        HttpServerAdapters.HttpTestHandler handler = new ServerPushHandler(MAIN_RESPONSE_BODY);\n+        server.addHandler(handler, \"\/\");\n+        server.start();\n+        String authority = server.serverAuthority();\n+        System.err.println(\"Server listening on address \" + authority);\n+        uri = new URI(\"http:\/\/\" + authority + \"\/foo\/a\/b\/c\");\n+    }\n+\n+    @AfterTest\n+    public void teardown() {\n+        server.stop();\n+    }\n+\n+    \/*\n+     * Malformed push promise headers should kill the connection\n+     *\/\n+    @Test\n+    public void test() throws Exception {\n+        HttpClient client = HttpClient.newHttpClient();\n+\n+        for (int i=0; i< BAD_HEADERS.size(); i++) {\n+            URI uriWithQuery = URI.create(uri +  \"?BAD_HEADERS=\" + i);\n+            HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                    .build();\n+            System.out.println(\"\\nSending request:\" + uriWithQuery);\n+            final HttpClient cc = client;\n+            try {\n+                ConcurrentMap<HttpRequest, CompletableFuture<HttpResponse<String>>> promises\n+                        = new ConcurrentHashMap<>();\n+                PushPromiseHandler<String> pph = PushPromiseHandler\n+                        .of((r) -> BodyHandlers.ofString(), promises);\n+                HttpResponse<String> response = cc.sendAsync(request, BodyHandlers.ofString(), pph).join();\n+                fail(\"Expected exception, got :\" + response + \", \" + response.body());\n+            } catch (CompletionException ce) {\n+                System.out.println(\"Got EXPECTED: \" + ce);\n+                assertDetailMessage(ce.getCause(), i);\n+            }\n+        }\n+    }\n+\n+    \/\/ Assertions based on implementation specific detail messages. Keep in\n+    \/\/ sync with implementation.\n+    static void assertDetailMessage(Throwable throwable, int iterationIndex) {\n+        try {\n+            assertTrue(throwable instanceof ProtocolException,\n+                    \"Expected ProtocolException, got \" + throwable);\n+\n+            if (iterationIndex == 0) { \/\/ unknown\n+                assertTrue(throwable.getMessage().contains(\"Unknown pseudo-header\"),\n+                        \"Expected \\\"Unknown pseudo-header\\\" in: \" + throwable.getMessage());\n+            } else if (iterationIndex == 4) { \/\/ unexpected type\n+                assertTrue(throwable.getMessage().contains(\"not valid in context\"),\n+                        \"Expected \\\"not valid in context\\\" in: \" + throwable.getMessage());\n+            } else {\n+                assertTrue(throwable.getMessage().contains(\"Bad header\"),\n+                        \"Expected \\\"Bad header\\\" in: \" + throwable.getMessage());\n+            }\n+        } catch (AssertionError e) {\n+            System.out.println(\"Exception does not match expectation: \" + throwable);\n+            throwable.printStackTrace(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    \/\/ --- server push handler ---\n+    static class ServerPushHandler implements HttpServerAdapters.HttpTestHandler {\n+\n+        private final String mainResponseBody;\n+\n+        public ServerPushHandler(String mainResponseBody) {\n+            this.mainResponseBody = mainResponseBody;\n+        }\n+\n+        public void handle(HttpServerAdapters.HttpTestExchange exchange) throws IOException {\n+            System.err.println(\"Server: handle \" + exchange);\n+            try (InputStream is = exchange.getRequestBody()) {\n+                is.readAllBytes();\n+            }\n+\n+            pushPromise(exchange);\n+\n+            \/\/ response data for the main response\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                byte[] bytes = mainResponseBody.getBytes(UTF_8);\n+                exchange.sendResponseHeaders(200, bytes.length);\n+                os.write(bytes);\n+            }\n+        }\n+\n+        private void pushPromise(HttpServerAdapters.HttpTestExchange exchange) {\n+            URI requestURI = exchange.getRequestURI();\n+            String query = exchange.getRequestURI().getQuery();\n+            int badHeadersIndex = Integer.parseInt(query.substring(query.indexOf(\"=\") + 1));\n+            URI uri = requestURI.resolve(\"\/push\/\"+badHeadersIndex);\n+            InputStream is = new ByteArrayInputStream(mainResponseBody.getBytes(UTF_8));\n+            HttpHeaders headers = HttpHeaders.of(BAD_HEADERS.get(badHeadersIndex), (x, y) -> true);\n+            exchange.serverPush(uri, headers, is);\n+            System.err.println(\"Server: push sent\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/BadPushPromiseTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"}]}