{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.DeserializationEvent\")\n@@ -41,1 +40,1 @@\n-public final class DeserializationEvent extends AbstractJDKEvent {\n+public final class DeserializationEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/DeserializationEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.ErrorThrownEvent\")\n@@ -41,1 +40,1 @@\n-public final class ErrorThrownEvent extends AbstractJDKEvent {\n+public final class ErrorThrownEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ErrorThrownEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.RemoveFields;\n@@ -40,2 +41,2 @@\n-@MirrorEvent(className = \"jdk.internal.event.ExceptionStatisticsEvent\")\n-public final class ExceptionStatisticsEvent extends AbstractPeriodicEvent {\n+@RemoveFields({\"duration\", \"eventThread\", \"stackTrace\"})\n+public final class ExceptionStatisticsEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ExceptionStatisticsEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.ExceptionThrownEvent\")\n@@ -42,1 +41,1 @@\n-public final class ExceptionThrownEvent extends AbstractJDKEvent {\n+public final class ExceptionThrownEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ExceptionThrownEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.ProcessStartEvent\")\n@@ -42,1 +41,1 @@\n-public final class ProcessStartEvent extends AbstractJDKEvent {\n+public final class ProcessStartEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ProcessStartEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.SecurityPropertyModificationEvent\")\n@@ -39,1 +38,1 @@\n-public final class SecurityPropertyModificationEvent extends AbstractJDKEvent {\n+public final class SecurityPropertyModificationEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SecurityPropertyModificationEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.SecurityProviderServiceEvent\")\n@@ -42,1 +41,1 @@\n-public final class SecurityProviderServiceEvent extends AbstractJDKEvent {\n+public final class SecurityProviderServiceEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SecurityProviderServiceEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.SerializationMisdeclarationEvent\")\n@@ -45,1 +44,1 @@\n-public final class SerializationMisdeclarationEvent extends AbstractJDKEvent {\n+public final class SerializationMisdeclarationEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SerializationMisdeclarationEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,1 @@\n-@MirrorEvent(className = \"jdk.internal.event.SocketReadEvent\")\n-public final class SocketReadEvent extends AbstractJDKEvent {\n+public final class SocketReadEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SocketReadEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,1 @@\n-@MirrorEvent(className = \"jdk.internal.event.SocketWriteEvent\")\n-public final class SocketWriteEvent extends AbstractJDKEvent {\n+public final class SocketWriteEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SocketWriteEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.TLSHandshakeEvent\")\n@@ -43,1 +42,1 @@\n-public final class TLSHandshakeEvent extends AbstractJDKEvent {\n+public final class TLSHandshakeEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/TLSHandshakeEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.ThreadSleepEvent\")\n@@ -41,1 +40,1 @@\n-public final class ThreadSleepEvent extends AbstractJDKEvent {\n+public final class ThreadSleepEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ThreadSleepEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.VirtualThreadEndEvent\")\n@@ -39,1 +38,1 @@\n-public final class VirtualThreadEndEvent extends AbstractJDKEvent {\n+public final class VirtualThreadEndEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/VirtualThreadEndEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n-@MirrorEvent(className = \"jdk.internal.event.VirtualThreadPinnedEvent\")\n-public final class VirtualThreadPinnedEvent extends AbstractJDKEvent {\n+public final class VirtualThreadPinnedEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/VirtualThreadPinnedEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.VirtualThreadStartEvent\")\n@@ -39,1 +38,1 @@\n-public final class VirtualThreadStartEvent extends AbstractJDKEvent {\n+public final class VirtualThreadStartEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/VirtualThreadStartEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.VirtualThreadSubmitFailedEvent\")\n@@ -41,1 +40,1 @@\n-public final class VirtualThreadSubmitFailedEvent extends AbstractJDKEvent {\n+public final class VirtualThreadSubmitFailedEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/VirtualThreadSubmitFailedEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.X509CertificateEvent\")\n@@ -38,1 +37,1 @@\n-public final class X509CertificateEvent extends AbstractJDKEvent {\n+public final class X509CertificateEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/X509CertificateEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-@MirrorEvent(className = \"jdk.internal.event.X509ValidationEvent\")\n@@ -38,1 +37,1 @@\n-public final class X509ValidationEvent extends AbstractJDKEvent {\n+public final class X509ValidationEvent extends MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/X509ValidationEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,0 @@\n-    private static final ClassDesc TYPE_MIRROR_EVENT = Bytecode.classDesc(MirrorEvent.class);\n@@ -147,3 +146,1 @@\n-            \/\/ For now, only support mirror events in java.base\n-            String fullName = \"java.base:\" + className;\n-            Class<?> eventClass = MirrorEvents.find(fullName);\n+            Class<?> eventClass = MirrorEvents.find(isJDK, className);\n@@ -224,14 +221,0 @@\n-    boolean isMirrorEvent() {\n-        String typeDescriptor = TYPE_MIRROR_EVENT.descriptorString();\n-        for (ClassElement ce : classModel.elements()) {\n-            if (ce instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n-                for (var annotation : rvaa.annotations()) {\n-                    if (annotation.className().equalsString(typeDescriptor)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,3 +115,0 @@\n-            if (ei.isMirrorEvent()) {\n-                return oldBytes;\n-            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -147,4 +147,0 @@\n-            if (eventClass.getAnnotation(MirrorEvent.class) != null) {\n-                \/\/ Don't register mirror classes.\n-                return null;\n-            }\n@@ -165,2 +161,1 @@\n-        String fullName = eventClass.getModule().getName() + \":\" + eventClass.getName();\n-        Class<? extends Event> mirrorClass = MirrorEvents.find(fullName);\n+        Class<? extends MirrorEvent> mirrorClass = MirrorEvents.find(eventClass);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-\n@@ -28,4 +27,4 @@\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.Target;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.ElementType;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Registered;\n+import jdk.jfr.StackTrace;\n+\n@@ -33,2 +32,12 @@\n- * Any event class annotated with this annotation must be added\n- * to the {@link MirrorEvents) class for it to take effect.\n+ * A mirror event is a fictitious event class that contains metadata about an\n+ * event, but not the implementation to write the event data to buffers.\n+ * <p>\n+ * A mirror event should be used when an event class is in a module where a\n+ * dependency on the jdk.jfr module is not possible, for example, due to a\n+ * circular dependency.\n+ * <p>\n+ * Subclass the MirrorEvent class and add the exact same fields as the actual\n+ * event, but with labels, descriptions etc.\n+ * <p>\n+ * For the mirror mechanism to work, the mirror class must be registered in the\n+ * jdk.jfr.internal.MirrorEvents class.\n@@ -36,17 +45,4 @@\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target({ ElementType.TYPE })\n-public @interface MirrorEvent {\n-    \/**\n-     * Fully qualified name of the class to mirror metadata for (for example,\n-     * {@code \"jdk.internal.event.Example\"})\n-     *\n-     * @return the fully qualified class name of the event\n-     *\/\n-    String className();\n-\n-    \/**\n-     * The module where the event is located, by default {@code \"java.base\"}.\n-     *\n-     * @return the module name\n-     *\/\n-    String module() default \"java.base\";\n+@Registered(false)\n+@Enabled(false)\n+@StackTrace(false)\n+public abstract class MirrorEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MirrorEvent.java","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.HashMap;\n@@ -29,0 +28,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -30,1 +30,0 @@\n-import jdk.jfr.Event;\n@@ -50,20 +49,26 @@\n-public final class MirrorEvents {\n-    private static final Class<?>[] mirrorEventClasses = {\n-        DeserializationEvent.class,\n-        ProcessStartEvent.class,\n-        SecurityPropertyModificationEvent.class,\n-        SecurityProviderServiceEvent.class,\n-        SerializationMisdeclarationEvent.class,\n-        SocketReadEvent.class,\n-        SocketWriteEvent.class,\n-        ThreadSleepEvent.class,\n-        TLSHandshakeEvent.class,\n-        VirtualThreadStartEvent.class,\n-        VirtualThreadEndEvent.class,\n-        VirtualThreadPinnedEvent.class,\n-        VirtualThreadSubmitFailedEvent.class,\n-        X509CertificateEvent.class,\n-        X509ValidationEvent.class,\n-        ErrorThrownEvent.class,\n-        ExceptionStatisticsEvent.class,\n-        ExceptionThrownEvent.class,\n+\/**\n+ * This class registers all mirror events.\n+ *\/\n+final class MirrorEvents {\n+    private static final Map<String, Class<? extends MirrorEvent>> mirrorLookup = new ConcurrentHashMap<>();\n+\n+    \/\/ Add mirror event mapping here. See MirrorEvent class for details.\n+    static {\n+        register(\"jdk.internal.event.DeserializationEvent\", DeserializationEvent.class);\n+        register(\"jdk.internal.event.ProcessStartEvent\", ProcessStartEvent.class);\n+        register(\"jdk.internal.event.SecurityPropertyModificationEvent\", SecurityPropertyModificationEvent.class);\n+        register(\"jdk.internal.event.SecurityProviderServiceEvent\", SecurityProviderServiceEvent.class);\n+        register(\"jdk.internal.event.SerializationMisdeclarationEvent\", SerializationMisdeclarationEvent.class);\n+        register(\"jdk.internal.event.SocketReadEvent\", SocketReadEvent.class);\n+        register(\"jdk.internal.event.SocketWriteEvent\", SocketWriteEvent.class);\n+        register(\"jdk.internal.event.ThreadSleepEvent\", ThreadSleepEvent.class);\n+        register(\"jdk.internal.event.TLSHandshakeEvent\", TLSHandshakeEvent.class);\n+        register(\"jdk.internal.event.VirtualThreadStartEvent\", VirtualThreadStartEvent.class);\n+        register(\"jdk.internal.event.VirtualThreadEndEvent\", VirtualThreadEndEvent.class);\n+        register(\"jdk.internal.event.VirtualThreadPinnedEvent\", VirtualThreadPinnedEvent.class);\n+        register(\"jdk.internal.event.VirtualThreadSubmitFailedEvent\", VirtualThreadSubmitFailedEvent.class);\n+        register(\"jdk.internal.event.X509CertificateEvent\", X509CertificateEvent.class);\n+        register(\"jdk.internal.event.X509ValidationEvent\", X509ValidationEvent.class);\n+        register(\"jdk.internal.event.ErrorThrownEvent\", ErrorThrownEvent.class);\n+        register(\"jdk.internal.event.ExceptionStatisticsEvent\", ExceptionStatisticsEvent.class);\n+        register(\"jdk.internal.event.ExceptionThrownEvent\", ExceptionThrownEvent.class);\n@@ -72,1 +77,3 @@\n-    private static final Map<String, Class<? extends Event>> mirrorLookup = createLookup();\n+    private static void register(String eventClassName, Class<? extends MirrorEvent> mirrorClass) {\n+        mirrorLookup.put(eventClassName, mirrorClass);\n+    }\n@@ -74,9 +81,2 @@\n-    public static Class<? extends Event> find(String name) {\n-        \/\/ When <clinit> of this class is executed it may lead\n-        \/\/ to a JVM up call and invocation of this method before\n-        \/\/ the mirrorLookup field has been set. This is fine,\n-        \/\/ mirrors should not be instrumented.\n-        if (mirrorLookup != null) {\n-            return mirrorLookup.get(name);\n-        }\n-        return null;\n+    static Class<? extends MirrorEvent> find(Class<? extends jdk.internal.event.Event> eventClass) {\n+        return find(eventClass.getClassLoader() == null, eventClass.getName());\n@@ -85,10 +85,3 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private static Map<String, Class<? extends Event>> createLookup() {\n-        Map<String, Class<? extends Event>> mirrors = new HashMap<>();\n-        for (Class<?> eventClass : mirrorEventClasses) {\n-            MirrorEvent me = eventClass.getAnnotation(MirrorEvent.class);\n-            if (me == null) {\n-                throw new InternalError(\"Mirror class must have annotation \" + MirrorEvent.class.getName());\n-            }\n-            String fullName = me.module() + \":\" + me.className();\n-            mirrors.put(fullName, (Class<? extends Event>) eventClass);\n+    static Class<? extends MirrorEvent> find(boolean bootClassLoader, String name) {\n+        if (bootClassLoader) {\n+            return mirrorLookup.get(name);\n@@ -96,1 +89,1 @@\n-        return mirrors;\n+        return null;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MirrorEvents.java","additions":37,"deletions":44,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-        if (jdk.internal.event.Event.class.isAssignableFrom(clazz)) {\n+        if (isEventClass(clazz)) {\n@@ -294,0 +294,10 @@\n+    private static boolean isEventClass(Class<?> clazz) {\n+        if (jdk.internal.event.Event.class.isAssignableFrom(clazz)) {\n+            return true;\n+        }\n+        if (MirrorEvent.class.isAssignableFrom(clazz)) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        fields.add(START_TIME); \/\/ for completeness, not really needed\n+        fields.add(START_TIME);\n@@ -48,1 +48,1 @@\n-        for (Class<?> c = eventClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {\n+        for (Class<?> c = eventClass; !Utils.isEventBaseClass(c); c = c.getSuperclass()) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ImplicitFields.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.jfr.internal.MirrorEvent;\n@@ -209,1 +210,0 @@\n-        Utils.ensureValidEventSubclass(clazz);\n@@ -211,1 +211,1 @@\n-        for (Class<?> c = clazz; c != jdk.internal.event.Event.class; c = c.getSuperclass()) {\n+        for (Class<?> c = clazz; !Utils.isEventBaseClass(c); c = c.getSuperclass()) {\n@@ -222,0 +222,10 @@\n+    public static boolean isEventBaseClass(Class<?> clazz) {\n+        if (jdk.internal.event.Event.class == clazz) {\n+            return true;\n+        }\n+        if (jdk.jfr.internal.MirrorEvent.class == clazz) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n@@ -341,1 +351,1 @@\n-    public static void verifyMirror(Class<?> mirror, Class<?> real) {\n+    public static void verifyMirror(Class<? extends MirrorEvent> mirror, Class<?> real) {\n@@ -356,1 +366,1 @@\n-                if (isSupportedType(realField.getType())) {\n+                if (isSupportedType(realField.getType()) && !realField.isSynthetic()) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"}]}