{"files":[{"patch":"@@ -945,1 +945,1 @@\n-    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -963,1 +963,1 @@\n-        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        Node* k = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1203,1 +1203,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n@@ -2782,1 +2782,1 @@\n-  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, nullptr, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+  Node* nkls = gvn.transform(LoadKlassNode::make(gvn, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3020,1 +3020,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(),\n@@ -3050,1 +3050,1 @@\n-    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(),\n@@ -3843,1 +3843,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n@@ -4039,1 +4039,1 @@\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n+    kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -4193,1 +4193,1 @@\n-    Node* kls = LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, adr_type, kls_type);\n+    Node* kls = LoadKlassNode::make(_gvn, immutable_memory(), p, adr_type, kls_type);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2341,1 +2341,1 @@\n-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-        Node* n1 = LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n+        Node* n1 = LoadKlassNode::make(_igvn, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2401,1 +2401,1 @@\n-Node* LoadKlassNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n+Node* LoadKlassNode::make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n@@ -2403,1 +2403,1 @@\n-  const TypePtr *adr_type = adr->bottom_type()->isa_ptr();\n+  const TypePtr* adr_type = adr->bottom_type()->isa_ptr();\n@@ -2408,1 +2408,1 @@\n-    Node* load_klass = gvn.transform(new LoadNKlassNode(ctl, mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n+    Node* load_klass = gvn.transform(new LoadNKlassNode(mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n@@ -2413,1 +2413,1 @@\n-  return new LoadKlassNode(ctl, mem, adr, at, tk, MemNode::unordered);\n+  return new LoadKlassNode(mem, adr, at, tk, MemNode::unordered);\n@@ -2421,6 +2421,0 @@\n-\/\/ In most cases, LoadKlassNode does not have the control input set. If the control\n-\/\/ input is set, it must not be removed (by LoadNode::Ideal()).\n-bool LoadKlassNode::can_remove_control() const {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -525,4 +525,4 @@\n-protected:\n-  \/\/ In most cases, LoadKlassNode does not have the control input set. If the control\n-  \/\/ input is set, it must not be removed (by LoadNode::Ideal()).\n-  virtual bool can_remove_control() const;\n+private:\n+  LoadKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk, MemOrd mo)\n+    : LoadPNode(nullptr, mem, adr, at, tk, mo) {}\n+\n@@ -530,2 +530,0 @@\n-  LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo)\n-    : LoadPNode(c, mem, adr, at, tk, mo) {}\n@@ -538,1 +536,1 @@\n-  static Node* make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,\n+  static Node* make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at,\n@@ -551,0 +549,5 @@\n+private:\n+  friend Node* LoadKlassNode::make(PhaseGVN&, Node*, Node*, const TypePtr*, const TypeKlassPtr*);\n+  LoadNKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeNarrowKlass* tk, MemOrd mo)\n+    : LoadNNode(nullptr, mem, adr, at, tk, mo) {}\n+\n@@ -552,2 +555,0 @@\n-  LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo)\n-    : LoadNNode(c, mem, adr, at, tk, mo) {}\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2123,1 +2123,1 @@\n-  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n+  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS));\n+  Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS));\n@@ -167,4 +167,1 @@\n-  bool always_see_exact_class = false;\n-  if (MonomorphicArrayCheck\n-      && !too_many_traps(Deoptimization::Reason_array_check)\n-      && !tak->klass_is_exact()\n+  if (MonomorphicArrayCheck && !too_many_traps(Deoptimization::Reason_array_check) && !tak->klass_is_exact()\n@@ -172,27 +169,23 @@\n-      \/\/ Regarding the fourth condition in the if-statement from above:\n-      \/\/\n-      \/\/ If the compiler has determined that the type of array 'ary' (represented\n-      \/\/ by 'array_klass') is java\/lang\/Object, the compiler must not assume that\n-      \/\/ the array 'ary' is monomorphic.\n-      \/\/\n-      \/\/ If 'ary' were of type java\/lang\/Object, this arraystore would have to fail,\n-      \/\/ because it is not possible to perform a arraystore into an object that is not\n-      \/\/ a \"proper\" array.\n-      \/\/\n-      \/\/ Therefore, let's obtain at runtime the type of 'ary' and check if we can still\n-      \/\/ successfully perform the store.\n-      \/\/\n-      \/\/ The implementation reasons for the condition are the following:\n-      \/\/\n-      \/\/ java\/lang\/Object is the superclass of all arrays, but it is represented by the VM\n-      \/\/ as an InstanceKlass. The checks generated by gen_checkcast() (see below) expect\n-      \/\/ 'array_klass' to be ObjArrayKlass, which can result in invalid memory accesses.\n-      \/\/\n-      \/\/ See issue JDK-8057622 for details.\n-\n-    always_see_exact_class = true;\n-    \/\/ (If no MDO at all, hope for the best, until a trap actually occurs.)\n-\n-    \/\/ Make a constant out of the inexact array klass\n-    const TypeKlassPtr *extak = tak->cast_to_exactness(true);\n-\n+    \/\/ Regarding the fourth condition in the if-statement from above:\n+    \/\/\n+    \/\/ If the compiler has determined that the type of array 'ary' (represented\n+    \/\/ by 'array_klass') is java\/lang\/Object, the compiler must not assume that\n+    \/\/ the array 'ary' is monomorphic.\n+    \/\/\n+    \/\/ If 'ary' were of type java\/lang\/Object, this arraystore would have to fail,\n+    \/\/ because it is not possible to perform a arraystore into an object that is not\n+    \/\/ a \"proper\" array.\n+    \/\/\n+    \/\/ Therefore, let's obtain at runtime the type of 'ary' and check if we can still\n+    \/\/ successfully perform the store.\n+    \/\/\n+    \/\/ The implementation reasons for the condition are the following:\n+    \/\/\n+    \/\/ java\/lang\/Object is the superclass of all arrays, but it is represented by the VM\n+    \/\/ as an InstanceKlass. The checks generated by gen_checkcast() (see below) expect\n+    \/\/ 'array_klass' to be ObjArrayKlass, which can result in invalid memory accesses.\n+    \/\/\n+    \/\/ See issue JDK-8057622 for details.\n+\n+    \/\/ Make a constant out of the exact array klass\n+    const TypeAryKlassPtr* extak = tak->cast_to_exactness(true)->is_aryklassptr();\n@@ -201,2 +194,2 @@\n-      Node* cmp = _gvn.transform(new CmpPNode( array_klass, con ));\n-      Node* bol = _gvn.transform(new BoolNode( cmp, BoolTest::eq ));\n+      Node* cmp = _gvn.transform(new CmpPNode(array_klass, con));\n+      Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n@@ -213,1 +206,1 @@\n-        replace_in_map(array_klass,con);\n+        replace_in_map(array_klass, con);\n@@ -228,6 +221,2 @@\n-  Node *p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);\n-  \/\/ We are allowed to use the constant type only if cast succeeded. If always_see_exact_class is true,\n-  \/\/ we must set a control edge from the IfTrue node created by the uncommon_trap above to the\n-  \/\/ LoadKlassNode.\n-  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : nullptr,\n-                                                       immutable_memory(), p2, tak));\n+  Node* p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);\n+  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p2, tak));\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":30,"deletions":41,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-          Node* nkls = phase->transform(LoadKlassNode::make(*phase, nullptr, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -221,1 +221,1 @@\n-    subklass  = phase->transform(LoadKlassNode::make(*phase, nullptr, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+    subklass  = phase->transform(LoadKlassNode::make(*phase, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}