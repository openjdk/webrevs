{"files":[{"patch":"@@ -950,1 +950,1 @@\n-    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -968,1 +968,1 @@\n-        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        Node* k = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1203,1 +1203,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n@@ -2782,1 +2782,1 @@\n-  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, nullptr, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+  Node* nkls = gvn.transform(LoadKlassNode::make(gvn, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3009,1 +3009,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(),\n@@ -3039,1 +3039,1 @@\n-    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(),\n@@ -3833,1 +3833,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n@@ -4029,1 +4029,1 @@\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n+    kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -4183,1 +4183,1 @@\n-    Node* kls = LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, adr_type, kls_type);\n+    Node* kls = LoadKlassNode::make(_gvn, immutable_memory(), p, adr_type, kls_type);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2341,1 +2341,1 @@\n-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-        Node* n1 = LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n+        Node* n1 = LoadKlassNode::make(_igvn, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2401,1 +2401,1 @@\n-Node* LoadKlassNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n+Node* LoadKlassNode::make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n@@ -2403,1 +2403,1 @@\n-  const TypePtr *adr_type = adr->bottom_type()->isa_ptr();\n+  const TypePtr* adr_type = adr->bottom_type()->isa_ptr();\n@@ -2408,1 +2408,1 @@\n-    Node* load_klass = gvn.transform(new LoadNKlassNode(ctl, mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n+    Node* load_klass = gvn.transform(new LoadNKlassNode(mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n@@ -2413,1 +2413,1 @@\n-  return new LoadKlassNode(ctl, mem, adr, at, tk, MemNode::unordered);\n+  return new LoadKlassNode(mem, adr, at, tk, MemNode::unordered);\n@@ -2421,6 +2421,0 @@\n-\/\/ In most cases, LoadKlassNode does not have the control input set. If the control\n-\/\/ input is set, it must not be removed (by LoadNode::Ideal()).\n-bool LoadKlassNode::can_remove_control() const {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -525,4 +525,4 @@\n-protected:\n-  \/\/ In most cases, LoadKlassNode does not have the control input set. If the control\n-  \/\/ input is set, it must not be removed (by LoadNode::Ideal()).\n-  virtual bool can_remove_control() const;\n+private:\n+  LoadKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk, MemOrd mo)\n+    : LoadPNode(nullptr, mem, adr, at, tk, mo) {}\n+\n@@ -530,2 +530,0 @@\n-  LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo)\n-    : LoadPNode(c, mem, adr, at, tk, mo) {}\n@@ -538,1 +536,1 @@\n-  static Node* make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,\n+  static Node* make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at,\n@@ -551,0 +549,5 @@\n+private:\n+  friend Node* LoadKlassNode::make(PhaseGVN&, Node*, Node*, const TypePtr*, const TypeKlassPtr*);\n+  LoadNKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeNarrowKlass* tk, MemOrd mo)\n+    : LoadNNode(nullptr, mem, adr, at, tk, mo) {}\n+\n@@ -552,2 +555,0 @@\n-  LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo)\n-    : LoadNNode(c, mem, adr, at, tk, mo) {}\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2123,1 +2123,1 @@\n-  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n+  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS));\n+  Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS));\n@@ -167,5 +167,4 @@\n-  bool always_see_exact_class = false;\n-  if (MonomorphicArrayCheck\n-      && !too_many_traps(Deoptimization::Reason_array_check)\n-      && !tak->klass_is_exact()\n-      && tak != TypeInstKlassPtr::OBJECT) {\n+  if (MonomorphicArrayCheck &&\n+      !too_many_traps(Deoptimization::Reason_array_check) &&\n+      !tak->klass_is_exact() &&\n+      tak->isa_aryklassptr()) {\n@@ -193,6 +192,2 @@\n-    always_see_exact_class = true;\n-    \/\/ (If no MDO at all, hope for the best, until a trap actually occurs.)\n-\n-    \/\/ Make a constant out of the inexact array klass\n-    const TypeKlassPtr *extak = tak->cast_to_exactness(true);\n-\n+    \/\/ Make a constant out of the exact array klass\n+    const TypeAryKlassPtr* extak = tak->cast_to_exactness(true)->is_aryklassptr();\n@@ -201,2 +196,2 @@\n-      Node* cmp = _gvn.transform(new CmpPNode( array_klass, con ));\n-      Node* bol = _gvn.transform(new BoolNode( cmp, BoolTest::eq ));\n+      Node* cmp = _gvn.transform(new CmpPNode(array_klass, con));\n+      Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n@@ -213,1 +208,1 @@\n-        replace_in_map(array_klass,con);\n+        replace_in_map(array_klass, con);\n@@ -228,6 +223,3 @@\n-  Node *p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);\n-  \/\/ We are allowed to use the constant type only if cast succeeded. If always_see_exact_class is true,\n-  \/\/ we must set a control edge from the IfTrue node created by the uncommon_trap above to the\n-  \/\/ LoadKlassNode.\n-  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : nullptr,\n-                                                       immutable_memory(), p2, tak));\n+  Node* p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);\n+  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p2, tak));\n+  assert(array_klass->is_Con() == a_e_klass->is_Con() || StressReflectiveCode, \"a constant array type must come with a constant element type\");\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-          Node* nkls = phase->transform(LoadKlassNode::make(*phase, nullptr, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -221,1 +221,1 @@\n-    subklass  = phase->transform(LoadKlassNode::make(*phase, nullptr, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+    subklass  = phase->transform(LoadKlassNode::make(*phase, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}