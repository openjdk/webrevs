{"files":[{"patch":"@@ -167,4 +167,1 @@\n-  bool always_see_exact_class = false;\n-  if (MonomorphicArrayCheck\n-      && !too_many_traps(Deoptimization::Reason_array_check)\n-      && !tak->klass_is_exact()\n+  if (MonomorphicArrayCheck && !too_many_traps(Deoptimization::Reason_array_check) && !tak->klass_is_exact()\n@@ -172,27 +169,23 @@\n-      \/\/ Regarding the fourth condition in the if-statement from above:\n-      \/\/\n-      \/\/ If the compiler has determined that the type of array 'ary' (represented\n-      \/\/ by 'array_klass') is java\/lang\/Object, the compiler must not assume that\n-      \/\/ the array 'ary' is monomorphic.\n-      \/\/\n-      \/\/ If 'ary' were of type java\/lang\/Object, this arraystore would have to fail,\n-      \/\/ because it is not possible to perform a arraystore into an object that is not\n-      \/\/ a \"proper\" array.\n-      \/\/\n-      \/\/ Therefore, let's obtain at runtime the type of 'ary' and check if we can still\n-      \/\/ successfully perform the store.\n-      \/\/\n-      \/\/ The implementation reasons for the condition are the following:\n-      \/\/\n-      \/\/ java\/lang\/Object is the superclass of all arrays, but it is represented by the VM\n-      \/\/ as an InstanceKlass. The checks generated by gen_checkcast() (see below) expect\n-      \/\/ 'array_klass' to be ObjArrayKlass, which can result in invalid memory accesses.\n-      \/\/\n-      \/\/ See issue JDK-8057622 for details.\n-\n-    always_see_exact_class = true;\n-    \/\/ (If no MDO at all, hope for the best, until a trap actually occurs.)\n-\n-    \/\/ Make a constant out of the inexact array klass\n-    const TypeKlassPtr *extak = tak->cast_to_exactness(true);\n-\n+    \/\/ Regarding the fourth condition in the if-statement from above:\n+    \/\/\n+    \/\/ If the compiler has determined that the type of array 'ary' (represented\n+    \/\/ by 'array_klass') is java\/lang\/Object, the compiler must not assume that\n+    \/\/ the array 'ary' is monomorphic.\n+    \/\/\n+    \/\/ If 'ary' were of type java\/lang\/Object, this arraystore would have to fail,\n+    \/\/ because it is not possible to perform a arraystore into an object that is not\n+    \/\/ a \"proper\" array.\n+    \/\/\n+    \/\/ Therefore, let's obtain at runtime the type of 'ary' and check if we can still\n+    \/\/ successfully perform the store.\n+    \/\/\n+    \/\/ The implementation reasons for the condition are the following:\n+    \/\/\n+    \/\/ java\/lang\/Object is the superclass of all arrays, but it is represented by the VM\n+    \/\/ as an InstanceKlass. The checks generated by gen_checkcast() (see below) expect\n+    \/\/ 'array_klass' to be ObjArrayKlass, which can result in invalid memory accesses.\n+    \/\/\n+    \/\/ See issue JDK-8057622 for details.\n+\n+    \/\/ Make a constant out of the exact array klass\n+    const TypeAryKlassPtr* extak = tak->cast_to_exactness(true)->is_aryklassptr();\n@@ -201,2 +194,2 @@\n-      Node* cmp = _gvn.transform(new CmpPNode( array_klass, con ));\n-      Node* bol = _gvn.transform(new BoolNode( cmp, BoolTest::eq ));\n+      Node* cmp = _gvn.transform(new CmpPNode(array_klass, con));\n+      Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n@@ -213,1 +206,1 @@\n-        replace_in_map(array_klass,con);\n+        replace_in_map(array_klass, con);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":27,"deletions":34,"binary":false,"changes":61,"status":"modified"}]}