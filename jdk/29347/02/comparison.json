{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/g1\/g1ConcurrentRefineStats.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-#include \"gc\/g1\/g1ConcurrentRefineStats.hpp\"\n+#include \"gc\/g1\/g1ConcurrentRefineStats.inline.hpp\"\n@@ -42,2 +42,2 @@\n-  AtomicAccess::add(&_sweep_duration, other->_sweep_duration, memory_order_relaxed);\n-  AtomicAccess::add(&_yield_during_sweep_duration, other->_yield_during_sweep_duration, memory_order_relaxed);\n+  _sweep_duration.add_then_fetch(other->_sweep_duration.load_relaxed(), memory_order_relaxed);\n+  _yield_during_sweep_duration.add_then_fetch(other->yield_during_sweep_duration(), memory_order_relaxed);\n@@ -45,6 +45,6 @@\n-  AtomicAccess::add(&_cards_scanned, other->_cards_scanned, memory_order_relaxed);\n-  AtomicAccess::add(&_cards_clean, other->_cards_clean, memory_order_relaxed);\n-  AtomicAccess::add(&_cards_not_parsable, other->_cards_not_parsable, memory_order_relaxed);\n-  AtomicAccess::add(&_cards_already_refer_to_cset, other->_cards_already_refer_to_cset, memory_order_relaxed);\n-  AtomicAccess::add(&_cards_refer_to_cset, other->_cards_refer_to_cset, memory_order_relaxed);\n-  AtomicAccess::add(&_cards_no_cross_region, other->_cards_no_cross_region, memory_order_relaxed);\n+  _cards_scanned.add_then_fetch(other->cards_scanned(), memory_order_relaxed);\n+  _cards_clean.add_then_fetch(other->cards_clean(), memory_order_relaxed);\n+  _cards_not_parsable.add_then_fetch(other->cards_not_parsable(), memory_order_relaxed);\n+  _cards_already_refer_to_cset.add_then_fetch(other->cards_already_refer_to_cset(), memory_order_relaxed);\n+  _cards_refer_to_cset.add_then_fetch(other->cards_refer_to_cset(), memory_order_relaxed);\n+  _cards_no_cross_region.add_then_fetch(other->cards_no_cross_region(), memory_order_relaxed);\n@@ -52,1 +52,1 @@\n-  AtomicAccess::add(&_refine_duration, other->_refine_duration, memory_order_relaxed);\n+  _refine_duration.add_then_fetch(other->refine_duration(), memory_order_relaxed);\n@@ -56,1 +56,9 @@\n-  *this = G1ConcurrentRefineStats();\n+  _sweep_duration.store_relaxed(0);\n+  _yield_during_sweep_duration.store_relaxed(0);\n+  _cards_scanned.store_relaxed(0);\n+  _cards_clean.store_relaxed(0);\n+  _cards_not_parsable.store_relaxed(0);\n+  _cards_already_refer_to_cset.store_relaxed(0);\n+  _cards_refer_to_cset.store_relaxed(0);\n+  _cards_no_cross_region.store_relaxed(0);\n+  _refine_duration.store_relaxed(0);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineStats.cpp","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"utilities\/ticks.hpp\"\n@@ -36,3 +36,3 @@\n-  jlong _sweep_duration;              \/\/ Time spent sweeping the table finding non-clean cards\n-                                      \/\/ and refining them.\n-  jlong _yield_during_sweep_duration; \/\/ Time spent yielding during the sweep (not doing the sweep).\n+  Atomic<jlong> _sweep_duration;              \/\/ Time spent sweeping the table finding non-clean cards\n+                                              \/\/ and refining them.\n+  Atomic<jlong> _yield_during_sweep_duration; \/\/ Time spent yielding during the sweep (not doing the sweep).\n@@ -40,6 +40,6 @@\n-  size_t _cards_scanned;              \/\/ Total number of cards scanned.\n-  size_t _cards_clean;                \/\/ Number of cards found clean.\n-  size_t _cards_not_parsable;         \/\/ Number of cards we could not parse and left unrefined.\n-  size_t _cards_already_refer_to_cset;\/\/ Number of cards marked found to be already young.\n-  size_t _cards_refer_to_cset;        \/\/ Number of dirty cards that were recently found to contain a to-cset reference.\n-  size_t _cards_no_cross_region;      \/\/ Number of dirty cards that were dirtied, but then cleaned again by the mutator.\n+  Atomic<size_t> _cards_scanned;              \/\/ Total number of cards scanned.\n+  Atomic<size_t> _cards_clean;                \/\/ Number of cards found clean.\n+  Atomic<size_t> _cards_not_parsable;         \/\/ Number of cards we could not parse and left unrefined.\n+  Atomic<size_t> _cards_already_refer_to_cset;\/\/ Number of cards marked found to be already young.\n+  Atomic<size_t> _cards_refer_to_cset;        \/\/ Number of dirty cards that were recently found to contain a to-cset reference.\n+  Atomic<size_t> _cards_no_cross_region;      \/\/ Number of dirty cards that were dirtied, but then cleaned again by the mutator.\n@@ -47,1 +47,1 @@\n-  jlong _refine_duration;             \/\/ Time spent during actual refinement.\n+  Atomic<jlong> _refine_duration;             \/\/ Time spent during actual refinement.\n@@ -54,3 +54,3 @@\n-  jlong sweep_duration() const { return _sweep_duration - _yield_during_sweep_duration; }\n-  jlong yield_during_sweep_duration() const { return _yield_during_sweep_duration; }\n-  jlong refine_duration() const { return _refine_duration; }\n+  inline jlong sweep_duration() const;\n+  inline jlong yield_during_sweep_duration() const;\n+  inline jlong refine_duration() const;\n@@ -59,1 +59,1 @@\n-  size_t refined_cards() const { return cards_not_clean(); }\n+  inline size_t refined_cards() const;\n@@ -61,7 +61,7 @@\n-  size_t cards_scanned() const { return _cards_scanned; }\n-  size_t cards_clean() const { return _cards_clean; }\n-  size_t cards_not_clean() const { return _cards_scanned - _cards_clean; }\n-  size_t cards_not_parsable() const { return _cards_not_parsable; }\n-  size_t cards_already_refer_to_cset() const { return _cards_already_refer_to_cset; }\n-  size_t cards_refer_to_cset() const { return _cards_refer_to_cset; }\n-  size_t cards_no_cross_region() const { return _cards_no_cross_region; }\n+  inline size_t cards_scanned() const;\n+  inline size_t cards_clean() const;\n+  inline size_t cards_not_clean() const;\n+  inline size_t cards_not_parsable() const;\n+  inline size_t cards_already_refer_to_cset() const;\n+  inline size_t cards_refer_to_cset() const;\n+  inline size_t cards_no_cross_region() const;\n@@ -70,1 +70,1 @@\n-  size_t cards_pending() const { return cards_not_clean() - _cards_already_refer_to_cset; }\n+  inline size_t cards_pending() const;\n@@ -72,1 +72,1 @@\n-  size_t cards_to_cset() const { return _cards_already_refer_to_cset + _cards_refer_to_cset; }\n+  inline size_t cards_to_cset() const;\n@@ -74,3 +74,3 @@\n-  void inc_sweep_time(jlong t) { _sweep_duration += t; }\n-  void inc_yield_during_sweep_duration(jlong t) { _yield_during_sweep_duration += t; }\n-  void inc_refine_duration(jlong t) { _refine_duration += t; }\n+  inline void inc_sweep_time(jlong t);\n+  inline void inc_yield_during_sweep_duration(jlong t);\n+  inline void inc_refine_duration(jlong t);\n@@ -78,6 +78,6 @@\n-  void inc_cards_scanned(size_t increment) { _cards_scanned += increment; }\n-  void inc_cards_clean(size_t increment) { _cards_clean += increment; }\n-  void inc_cards_not_parsable() { _cards_not_parsable++; }\n-  void inc_cards_already_refer_to_cset() { _cards_already_refer_to_cset++; }\n-  void inc_cards_refer_to_cset() { _cards_refer_to_cset++; }\n-  void inc_cards_no_cross_region() { _cards_no_cross_region++; }\n+  inline void inc_cards_scanned(size_t increment);\n+  inline void inc_cards_clean(size_t increment);\n+  inline void inc_cards_not_parsable();\n+  inline void inc_cards_already_refer_to_cset();\n+  inline void inc_cards_refer_to_cset();\n+  inline void inc_cards_no_cross_region();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineStats.hpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.inline See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CONCURRENTREFINESTATS_INLINE_HPP\n+#define SHARE_GC_G1_G1CONCURRENTREFINESTATS_INLINE_HPP\n+\n+#include \"gc\/g1\/g1ConcurrentRefineStats.hpp\"\n+\n+inline jlong G1ConcurrentRefineStats::sweep_duration() const {\n+  return _sweep_duration.load_relaxed() - yield_during_sweep_duration();\n+}\n+\n+inline jlong G1ConcurrentRefineStats::yield_during_sweep_duration() const {\n+  return _yield_during_sweep_duration.load_relaxed();\n+}\n+\n+inline jlong G1ConcurrentRefineStats::refine_duration() const {\n+  return _refine_duration.load_relaxed();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::refined_cards() const {\n+  return cards_not_clean();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::cards_scanned() const {\n+  return _cards_scanned.load_relaxed();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::cards_clean() const {\n+  return _cards_clean.load_relaxed();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::cards_not_clean() const {\n+  return cards_scanned() - cards_clean();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::cards_not_parsable() const {\n+  return _cards_not_parsable.load_relaxed();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::cards_already_refer_to_cset() const {\n+  return _cards_already_refer_to_cset.load_relaxed();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::cards_refer_to_cset() const {\n+  return _cards_refer_to_cset.load_relaxed();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::cards_no_cross_region() const {\n+  return _cards_no_cross_region.load_relaxed();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::cards_pending() const {\n+  return cards_not_clean() - cards_already_refer_to_cset();\n+}\n+\n+inline size_t G1ConcurrentRefineStats::cards_to_cset() const {\n+  return cards_already_refer_to_cset() + cards_refer_to_cset();\n+}\n+\n+inline void G1ConcurrentRefineStats::inc_sweep_time(jlong t) {\n+  _sweep_duration.store_relaxed(_sweep_duration.load_relaxed() + t);\n+}\n+\n+inline void G1ConcurrentRefineStats::inc_yield_during_sweep_duration(jlong t) {\n+  _yield_during_sweep_duration.store_relaxed(yield_during_sweep_duration() + t);\n+}\n+\n+inline void G1ConcurrentRefineStats::inc_refine_duration(jlong t) {\n+  _refine_duration.store_relaxed(refine_duration() + t);\n+}\n+\n+inline void G1ConcurrentRefineStats::inc_cards_scanned(size_t increment) {\n+  _cards_scanned.store_relaxed(cards_scanned() + increment);\n+}\n+\n+inline void G1ConcurrentRefineStats::inc_cards_clean(size_t increment) {\n+  _cards_clean.store_relaxed(cards_clean() + increment);\n+}\n+\n+inline void G1ConcurrentRefineStats::inc_cards_not_parsable() {\n+  _cards_not_parsable.store_relaxed(cards_not_parsable() + 1);\n+}\n+\n+inline void G1ConcurrentRefineStats::inc_cards_already_refer_to_cset() {\n+  _cards_already_refer_to_cset.store_relaxed(cards_already_refer_to_cset() + 1);\n+}\n+\n+inline void G1ConcurrentRefineStats::inc_cards_refer_to_cset() {\n+  _cards_refer_to_cset.store_relaxed(cards_refer_to_cset() + 1);\n+}\n+\n+inline void G1ConcurrentRefineStats::inc_cards_no_cross_region() {\n+  _cards_no_cross_region.store_relaxed(cards_no_cross_region() + 1);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CONCURRENTREFINESTATS_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineStats.inline.hpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1ConcurrentRefineStats.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineSweepTask.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/g1\/g1ConcurrentRefineStats.hpp\"\n@@ -32,0 +31,1 @@\n+class G1ConcurrentRefineStats;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineSweepTask.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1ConcurrentRefineStats.hpp\"\n+#include \"gc\/g1\/g1ConcurrentRefineStats.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/g1\/g1ConcurrentRefineStats.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/g1\/g1ConcurrentRefineStats.hpp\"\n+#include \"gc\/g1\/g1ConcurrentRefineStats.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/g1\/g1ConcurrentRefineStats.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}