{"files":[{"patch":"@@ -214,11 +214,0 @@\n-  for (uint8_t* j = offset_card + 1; j <= end_card; j++) {\n-    assert(offset_array(j) > 0 &&\n-           offset_array(j) <= (uint8_t) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1),\n-           \"offset array should have been set - \"\n-           \"%u not > 0 OR %u not <= %u\",\n-           (uint) offset_array(j),\n-           (uint) offset_array(j),\n-           (uint) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1));\n-  }\n-#endif\n-}\n@@ -226,4 +215,3 @@\n-void G1BlockOffsetTable::verify(const HeapRegion* hr) const {\n-  assert(hr->bottom() < hr->top(), \"Only non-empty regions should be verified.\");\n-  uint8_t* start_card = entry_for_addr(hr->bottom());\n-  uint8_t* end_card = entry_for_addr(hr->top() - 1);\n+  G1BlockOffsetTable::verify_for_block(blk_start, blk_end);\n+#endif \/\/ ASSERT\n+}\n@@ -231,22 +219,7 @@\n-  for (uint8_t* current_card = start_card; current_card < end_card; current_card++) {\n-    uint8_t entry = offset_array(current_card);\n-    if (entry < CardTable::card_size_in_words()) {\n-      \/\/ The entry should point to an object before the current card. Verify that\n-      \/\/ it is possible to walk from that object in to the current card by just\n-      \/\/ iterating over the objects following it.\n-      HeapWord* card_address = addr_for_entry(current_card);\n-      HeapWord* obj_end = card_address - entry;\n-      while (obj_end < card_address) {\n-        HeapWord* obj = obj_end;\n-        size_t obj_size = hr->block_size(obj);\n-        obj_end = obj + obj_size;\n-        guarantee(obj_end > obj && obj_end <= hr->top(),\n-                  \"Invalid object end. obj: \" PTR_FORMAT \" obj_size: \" SIZE_FORMAT \" obj_end: \" PTR_FORMAT \" top: \" PTR_FORMAT,\n-                  p2i(obj), obj_size, p2i(obj_end), p2i(hr->top()));\n-      }\n-    } else {\n-      \/\/ Because we refine the BOT based on which cards are dirty there is not much we can verify here.\n-      \/\/ We need to make sure that we are going backwards and that we don't pass the start of the\n-      \/\/ corresponding heap region. But that is about all we can verify.\n-      size_t backskip = BOTConstants::entry_to_cards_back(entry);\n-      guarantee(backskip >= 1, \"Must be going back at least one card.\");\n+#ifdef ASSERT\n+void G1BlockOffsetTable::verify_offset(uint8_t* card_index, uint8_t upper_boundary) const {\n+  assert(offset_array(card_index) <= upper_boundary,\n+         \"Offset %u should not be larger than upper boundary %u.\",\n+         (uint) offset_array(card_index),\n+         (uint) upper_boundary);\n+}\n@@ -254,4 +227,2 @@\n-      size_t max_backskip = current_card - start_card;\n-      guarantee(backskip <= max_backskip,\n-                \"Going backwards beyond the start_card. start_card: \" SIZE_FORMAT \" current_card: \" SIZE_FORMAT \" backskip: \" SIZE_FORMAT,\n-                p2i(start_card), p2i(current_card), backskip);\n+void G1BlockOffsetTable::verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const {\n+  assert(is_crossing_card_boundary(blk_start, blk_end), \"precondition\");\n@@ -259,4 +230,17 @@\n-      HeapWord* backskip_address = addr_for_entry(current_card - backskip);\n-      guarantee(backskip_address >= hr->bottom(),\n-                \"Going backwards beyond bottom of the region: bottom: \" PTR_FORMAT \", backskip_address: \" PTR_FORMAT,\n-                p2i(hr->bottom()), p2i(backskip_address));\n+  uint8_t* start_card = entry_for_addr(align_up_by_card_size(blk_start));\n+  uint8_t* end_card = entry_for_addr(blk_end - 1);\n+  \/\/ Check cards in [start_card, end_card]\n+  verify_offset(start_card, CardTable::card_size_in_words());\n+\n+  for (uint8_t* current_card = start_card + 1; current_card <= end_card; ++current_card) {\n+    assert(offset_array(current_card) > 0,\n+           \"Offset %u is not larger than 0.\",\n+           (uint) offset_array(current_card));\n+    verify_offset(current_card, (uint8_t) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1));\n+\n+    uint8_t* prev  = current_card - 1;\n+    uint8_t* value = current_card;\n+    if (offset_array(prev) != offset_array(value)) {\n+      assert(offset_array(value) >= offset_array(prev), \"monotonic\");\n+      size_t n_cards_back = BOTConstants::entry_to_cards_back(offset_array(value));\n+      assert(start_card == (current_card - n_cards_back), \"inv\");\n@@ -266,0 +250,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":30,"deletions":45,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -115,1 +115,2 @@\n-  void verify(const HeapRegion* hr) const;\n+  void verify_offset(uint8_t* card_index, uint8_t upper) const NOT_DEBUG_RETURN;\n+  void verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -698,5 +698,0 @@\n-  \/\/ Only regions in old generation contain valid BOT.\n-  if (!is_empty() && !is_young()) {\n-    _bot->verify(this);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}