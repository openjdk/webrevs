{"files":[{"patch":"@@ -291,1 +291,1 @@\n-bool HeapShared::archive_object(oop obj, KlassSubGraphInfo* subgraph_info) {\n+bool HeapShared::archive_object(oop obj, oop referrer, KlassSubGraphInfo* subgraph_info) {\n@@ -307,1 +307,1 @@\n-    CachedOopInfo info = make_cached_oop_info(obj);\n+    CachedOopInfo info = make_cached_oop_info(obj, referrer);\n@@ -1350,1 +1350,4 @@\n-class WalkOopAndArchiveClosure: public BasicOopIterateClosure {\n+\/\/ Push all oops that are referenced by _referencing_obj onto the _stack.\n+class HeapShared::ReferentPusher: public BasicOopIterateClosure {\n+  PendingOopStack* _stack;\n+  GrowableArray<oop> _found_oop_fields;\n@@ -1355,5 +1358,0 @@\n-\n-  \/\/ The following are for maintaining a stack for determining\n-  \/\/ CachedOopInfo::_referrer\n-  static WalkOopAndArchiveClosure* _current;\n-  WalkOopAndArchiveClosure* _last;\n@@ -1361,1 +1359,2 @@\n-  WalkOopAndArchiveClosure(int level,\n+  ReferentPusher(PendingOopStack* stack,\n+                           int level,\n@@ -1365,0 +1364,2 @@\n+    _stack(stack),\n+    _found_oop_fields(),\n@@ -1369,2 +1370,0 @@\n-    _last = _current;\n-    _current = this;\n@@ -1372,2 +1371,11 @@\n-  ~WalkOopAndArchiveClosure() {\n-    _current = _last;\n+  void do_oop(narrowOop *p) { ReferentPusher::do_oop_work(p); }\n+  void do_oop(      oop *p) { ReferentPusher::do_oop_work(p); }\n+\n+  ~ReferentPusher() {\n+    while (_found_oop_fields.length() > 0) {\n+      \/\/ This produces the exact same traversal order as the previous version\n+      \/\/ of ReferentPusher that recurses on the C stack -- a depth-first search,\n+      \/\/ walking the oop fields in _referencing_obj by ascending field offsets.\n+      oop obj = _found_oop_fields.pop();\n+      _stack->push(PendingOop(obj, _referencing_obj, _level + 1));\n+    }\n@@ -1375,2 +1383,0 @@\n-  void do_oop(narrowOop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }\n-  void do_oop(      oop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }\n@@ -1396,3 +1402,1 @@\n-      bool success = HeapShared::archive_reachable_objects_from(\n-          _level + 1, _subgraph_info, obj);\n-      assert(success, \"VM should have exited with unarchivable objects for _level > 1\");\n+      _found_oop_fields.push(obj);\n@@ -1403,1 +1407,0 @@\n-  static WalkOopAndArchiveClosure* current()  { return _current;              }\n@@ -1408,2 +1411,0 @@\n-WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = nullptr;\n-\n@@ -1425,3 +1426,1 @@\n-HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop obj) {\n-  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n-  oop referrer = (walker == nullptr) ? nullptr : walker->referencing_obj();\n+HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop obj, oop referrer) {\n@@ -1450,1 +1449,2 @@\n-\/\/ (3) Record the klasses of all orig_obj and all reachable objects.\n+\/\/ (3) Record the klasses of all objects that are reachable from orig_obj (including those that\n+\/\/     were already archived when this function is called)\n@@ -1455,0 +1455,16 @@\n+  PendingOopStack stack;\n+  stack.push(PendingOop(orig_obj, nullptr, level));\n+\n+  while (stack.length() > 0) {\n+    PendingOop po = stack.pop();\n+    _object_being_archived = po;\n+    bool status = walk_one_object(&stack, po.level(), subgraph_info, po.obj(), po.referrer());\n+    _object_being_archived = PendingOop();\n+\n+    if (!status) {\n+      \/\/ Don't archive a subgraph root that's too big. For archives static fields, that's OK\n+      \/\/ as the Java code will take care of initializing this field dynamically.\n+      assert(level == 1, \"VM should have exited with unarchivable objects for _level > 1\");\n+      return false;\n+    }\n+  }\n@@ -1456,0 +1472,6 @@\n+  return true;\n+}\n+\n+bool HeapShared::walk_one_object(PendingOopStack* stack, int level, KlassSubGraphInfo* subgraph_info,\n+                                 oop orig_obj, oop referrer) {\n+  assert(orig_obj != nullptr, \"must be\");\n@@ -1524,1 +1546,1 @@\n-    if (!archive_object(orig_obj, subgraph_info)) {\n+    if (!archive_object(orig_obj, referrer, subgraph_info)) {\n@@ -1547,2 +1569,7 @@\n-  WalkOopAndArchiveClosure walker(level, record_klasses_only, subgraph_info, orig_obj);\n-  orig_obj->oop_iterate(&walker);\n+  {\n+    \/\/ Find all the oops that are referenced by orig_obj, push them onto the stack\n+    \/\/ so we can work on them next.\n+    ResourceMark rm;\n+    ReferentPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n+    orig_obj->oop_iterate(&pusher);\n+  }\n@@ -1573,2 +1600,1 @@\n-\/\/ The Java heap object sub-graph archiving process (see\n-\/\/ WalkOopAndArchiveClosure):\n+\/\/ The Java heap object sub-graph archiving process (see ReferentPusher):\n@@ -1722,0 +1748,1 @@\n+HeapShared::PendingOop HeapShared::_object_being_archived;\n@@ -2043,2 +2070,2 @@\n-  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n-  if (walker != nullptr) {\n+  oop referrer = _object_being_archived.referrer();\n+  if (referrer != nullptr) {\n@@ -2046,1 +2073,2 @@\n-    CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n+    ls.print_cr(\"Reference trace\");\n+    CDSHeapVerifier::trace_to_root(&ls, referrer);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":61,"deletions":33,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-  static CachedOopInfo make_cached_oop_info(oop obj);\n+  static CachedOopInfo make_cached_oop_info(oop obj, oop referrer);\n@@ -318,1 +318,1 @@\n-  static bool archive_object(oop obj, KlassSubGraphInfo* subgraph_info);\n+  static bool archive_object(oop obj, oop referrer, KlassSubGraphInfo* subgraph_info);\n@@ -344,0 +344,24 @@\n+  \/\/ PendingOop and PendingOopStack are used for recursively discovering all cacheable\n+  \/\/ heap objects. The recursion is done using PendingOopStack so we won't overflow the\n+  \/\/ C stack with deep reference chains.\n+  class PendingOop {\n+    oop _obj;\n+    oop _referrer;\n+    int _level;\n+\n+  public:\n+    PendingOop() : _obj(nullptr), _referrer(nullptr), _level(-1) {}\n+    PendingOop(oop obj, oop referrer, int level) : _obj(obj), _referrer(referrer), _level(level) {}\n+\n+    oop obj()      const { return _obj; }\n+    oop referrer() const { return _referrer; }\n+    int level()    const { return _level; }\n+  };\n+\n+  class ReferentPusher;\n+  using PendingOopStack = GrowableArrayCHeap<PendingOop, mtClassShared>;\n+\n+  static PendingOop _object_being_archived;\n+  static bool walk_one_object(PendingOopStack* stack, int level, KlassSubGraphInfo* subgraph_info,\n+                              oop orig_obj, oop referrer);\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"}]}