{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -83,1 +84,1 @@\n-static void fill_klasses(GrowableArray<const void*>& event_subklasses, const InstanceKlass* event_klass, JavaThread* thread) {\n+static void fill_klasses(GrowableArray<jclass>& event_subklasses, const InstanceKlass* event_klass, JavaThread* thread) {\n@@ -87,0 +88,2 @@\n+  \/\/ Do not safepoint while walking the ClassHierarchy, keeping klasses alive and storing their mirrors in JNI handles.\n+  NoSafepointVerifier nsv;\n@@ -91,1 +94,5 @@\n-      event_subklasses.append(subk);\n+      \/\/ We are walking the class hierarchy and saving the relevant klasses in JNI handles.\n+      \/\/ To be allowed to store the java mirror, we must ensure that the klass and its oops are kept alive,\n+      \/\/ and perform the store before the next safepoint.\n+      subk->keep_alive();\n+      event_subklasses.append((jclass)JfrJavaSupport::local_jni_handle(subk->java_mirror(), thread));\n@@ -96,11 +103,0 @@\n-static void transform_klasses_to_local_jni_handles(GrowableArray<const void*>& event_subklasses, JavaThread* thread) {\n-  assert(event_subklasses.is_nonempty(), \"invariant\");\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));\n-\n-  for (int i = 0; i < event_subklasses.length(); ++i) {\n-    const InstanceKlass* k = static_cast<const InstanceKlass*>(event_subklasses.at(i));\n-    assert(is_allowed(k), \"invariant\");\n-    event_subklasses.at_put(i, JfrJavaSupport::local_jni_handle(k->java_mirror(), thread));\n-  }\n-}\n-\n@@ -129,1 +125,1 @@\n-  GrowableArray<const void*> event_subklasses(initial_array_size);\n+  GrowableArray<jclass> event_subklasses(initial_array_size);\n@@ -136,2 +132,0 @@\n-  transform_klasses_to_local_jni_handles(event_subklasses, THREAD);\n-\n@@ -155,1 +149,1 @@\n-    const jclass clazz = (jclass)event_subklasses.at(i);\n+    const jclass clazz = event_subklasses.at(i);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrJdkJfrEvent.cpp","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -589,0 +589,2 @@\n+  inline void keep_alive() const;\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,7 @@\n+inline void Klass::keep_alive() const {\n+  \/\/ Resolving the holder (a WeakHandle) will keep the klass alive until the next safepoint.\n+  \/\/ Making the klass's CLD handle oops (e.g. the java_mirror), safe to store in the object\n+  \/\/ graph and its roots (e.g. Handles).\n+  static_cast<void>(klass_holder());\n+}\n+\n@@ -54,0 +61,1 @@\n+\/\/ Loading the java_mirror does not keep its holder alive. See Klass::keep_alive().\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}