{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.io.IOException;\n-import java.io.InputStream;\n@@ -31,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -33,4 +30,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -190,44 +183,0 @@\n-\n-    \/**\n-     * Tries to determine the {@link ByteOrder} of a image file present at {@code imageFile}.\n-     * The implementation reads the first few relevant bytes of the image file and compares it to\n-     * the expected magic bytes of a jimage. If those bytes correspond to the magic bytes, then\n-     * this method returns the ByteOrder of the image file, else it returns null.\n-     *\n-     * @param imageFile The path to the image file\n-     * @return The ByteOrder if one could be determined. Else null.\n-     *\/\n-    static ByteOrder tryDetectByteOrder(Path imageFile) {\n-        byte[] bytes = new byte[Integer.SIZE]; \/\/ read only as much as the size of magic bytes\n-        @SuppressWarnings(\"removal\")\n-        int numRead = AccessController.doPrivileged(\n-                new PrivilegedAction<Integer>() {\n-                    @Override\n-                    public Integer run() {\n-                        try (InputStream is = Files.newInputStream(imageFile)) {\n-                            return is.read(bytes);\n-                        } catch (IOException e) {\n-                            \/\/ ignore\n-                            return -1;\n-                        }\n-                    }\n-                });\n-        if (numRead != bytes.length) {\n-            \/\/ not enough bytes to ascertain if this is a jimage\n-            return null;\n-        }\n-        ByteBuffer bb = ByteBuffer.wrap(bytes);\n-        if (bb.getInt() == MAGIC) {\n-            return bb.order();\n-        }\n-        \/\/ try with the other byte order\n-        ByteOrder altByteOrder = bb.order() == ByteOrder.BIG_ENDIAN\n-                ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;\n-        bb.flip();\n-        bb.order(altByteOrder);\n-        if (bb.getInt() == MAGIC) {\n-            return bb.order();\n-        }\n-        \/\/ doesn't match the magic bytes\n-        return null;\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageHeader.java","additions":1,"deletions":52,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,4 +71,1 @@\n-        \/\/ try to determine the byte order of the image file\n-        ByteOrder detectedOrder = ImageHeader.tryDetectByteOrder(imagePath);\n-        ByteOrder byteOrder = detectedOrder != null ? detectedOrder : ByteOrder.nativeOrder();\n-        return open(imagePath, byteOrder);\n+        return open(imagePath, ByteOrder.nativeOrder());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -287,14 +287,2 @@\n-        if (reader != NULL && reader->_invalid_magic) {\n-            \/\/ failed due to invalid magic bytes. now attempt with the other byte order\n-            delete reader;\n-            reader = new ImageFileReader(name, !big_endian);\n-            if (reader == NULL || !reader->open()) {\n-                \/\/ still failed to open.\n-                delete reader;\n-                return NULL;\n-            }\n-        } else {\n-            \/\/ failed to open for some other reason than invalid magic bytes in header\n-            delete reader;\n-            return NULL;\n-        }\n+        delete reader;\n+        return NULL;\n@@ -366,1 +354,0 @@\n-    _invalid_magic = false;\n@@ -396,10 +383,3 @@\n-        !read_at((u1*)&_header, header_size, 0)) {\n-        close();\n-        return false;\n-    }\n-    if (_header.magic(_endian) != IMAGE_MAGIC) {\n-        _invalid_magic = true;\n-        close();\n-        return false;\n-    }\n-    if (_header.major_version(_endian) != MAJOR_VERSION ||\n+        !read_at((u1*)&_header, header_size, 0) ||\n+        _header.magic(_endian) != IMAGE_MAGIC ||\n+        _header.major_version(_endian) != MAJOR_VERSION ||\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -432,2 +432,0 @@\n-    bool _invalid_magic; \/\/ true, if opening the image file failed due to the header having\n-                         \/\/ an invalid magic\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,2 @@\n-         * @param endian Jimage byte order. Native order by default\n+         * @param endian Jimage byte order. Can be null, which implies the byte order for\n+         *               the generated image will be determined during image generation\n@@ -167,1 +168,1 @@\n-            this.endian = Objects.requireNonNull(endian);\n+            this.endian = endian;\n@@ -172,1 +173,2 @@\n-         * @return the byte ordering\n+         * @return the byte ordering, can be null which implies no specific ByteOrder has been\n+         * explicitly set\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import jdk.internal.module.ModuleReferenceImpl;\n@@ -222,1 +223,1 @@\n-        ByteOrder endian = ByteOrder.nativeOrder();\n+        ByteOrder endian;\n@@ -815,1 +816,20 @@\n-            this.order = order;\n+            if (order != null) {\n+                this.order = order;\n+            } else {\n+                \/\/ Use the java.base module of the target platform to determine the endianness\n+                \/\/ of the target image\n+                String targetPlatform = null;\n+                Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n+                if (javaBase.isPresent()) {\n+                    ModuleReference ref = javaBase.get().reference();\n+                    if (ref instanceof ModuleReferenceImpl modRefImpl\n+                            && modRefImpl.moduleTarget() != null) {\n+                        targetPlatform = modRefImpl.moduleTarget().targetPlatform();\n+                    }\n+                }\n+                if (targetPlatform != null) {\n+                    this.order = getNativeEndianOfTargetPlatform(targetPlatform);\n+                } else {\n+                    this.order = ByteOrder.nativeOrder();\n+                }\n+            }\n@@ -887,0 +907,24 @@\n+        \/\/ returns the endianness of the target platform, if known. Else returns the\n+        \/\/ current platform's endianness\n+        private static ByteOrder getNativeEndianOfTargetPlatform(String targetPlatform) {\n+            int index = targetPlatform.indexOf(\"-\"); \/\/ of the form <operating system>-<arch>\n+            if (index < 0) {\n+                \/\/ unknown arch, return current platform's endianness\n+                return ByteOrder.nativeOrder();\n+            }\n+            String archName = targetPlatform.substring(index + 1);\n+            return switch (archName) {\n+                case \"x86\", \"x86_64\",\n+                        \"alpha\", \"amd64\",\n+                        \"arm\", \"aarch64\",\n+                        \"ia64\", \"mipsel\",\n+                        \"mips64el\", \"loongarch64\",\n+                        \"ppc64le\", \"riscv32\", \"riscv64\" -> ByteOrder.LITTLE_ENDIAN;\n+                case \"m68k\", \"mips\",\n+                        \"mips64\", \"ppc\",\n+                        \"s390\", \"s390x\",\n+                        \"sh\", \"sparc\", \"sparcv9\" -> ByteOrder.BIG_ENDIAN;\n+                default -> ByteOrder.nativeOrder();\n+            };\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":47,"deletions":3,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1,174 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.spi.ToolProvider;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-\n-\/*\n- * @test\n- * @bug 8206890\n- * @summary Tests that a jlink image created using --endian option works fine when used to\n- *          launch applications\n- * @library \/test\/lib\n- *\n- * @run main JLinkEndianTest little\n- * @run main JLinkEndianTest big\n- * @run main JLinkEndianTest\n- *\/\n-public class JLinkEndianTest {\n-\n-    private static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n-            .orElseThrow(() -> new RuntimeException(\"jlink tool not found\"));\n-\n-    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n-            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n-\n-    private static final String HELLO_WORLD_APP = \"\"\"\n-            public class Hello {\n-                public static void main(final String[] args) throws Exception {\n-                    System.out.print(\"Hello world\");\n-                }\n-            }\n-            \"\"\";\n-\n-    \/**\n-     * Launches {@code jlink} command with different {@code --endian} options and then launches\n-     * the {@code java} command from the newly created image and verifies that the launched\n-     * java process works fine without running into errors.\n-     *\/\n-    public static void main(final String[] args) throws Exception {\n-        final String endian = args.length > 0 ? args[0] : \"\";\n-        final Path imageDir = Path.of(\".\", \"8206890\", System.currentTimeMillis() + endian);\n-        \/\/ invoke jlink:\n-        \/\/ jlink --add-modules java.base --add-modules jdk.compiler --output <path> --endian <endian>\n-        System.out.println(\"Creating image at \" + imageDir + \" with --endian=\" + endian);\n-        final String[] commonArgs = new String[]{\n-                \"--add-modules\", \"java.base\",\n-                \"--add-modules\", \"jdk.compiler\",\n-                \"--output\", imageDir.toAbsolutePath().toString()\n-        };\n-        final String[] jlinkArgs;\n-        if (!endian.isEmpty()) {\n-            jlinkArgs = Arrays.copyOf(commonArgs, commonArgs.length + 2);\n-            jlinkArgs[jlinkArgs.length - 2] = \"--endian\";\n-            jlinkArgs[jlinkArgs.length - 1] = endian;\n-        } else {\n-            jlinkArgs = commonArgs;\n-        }\n-        System.out.println(\"Launching jlink with args: \" + Arrays.toString(jlinkArgs));\n-        final int jlinkExitCode = JLINK_TOOL.run(System.out, System.err, jlinkArgs);\n-        if (jlinkExitCode != 0) {\n-            throw new AssertionError(\"jlink execution failed with exit code \" + jlinkExitCode);\n-        }\n-        \/\/ verify the newly created image file is present\n-        final Path imageFile = Path.of(imageDir.toAbsolutePath().toString(), \"lib\", \"modules\");\n-        if (!Files.exists(imageFile)) {\n-            throw new AssertionError(imageFile + \" is missing\");\n-        }\n-        if (!Files.isRegularFile(imageFile)) {\n-            throw new AssertionError(imageFile + \" is not a file\");\n-        }\n-        \/\/ compile a trivial Java class which we will then launch using the newly generated image\n-        final Path helloWorldClassFile = compileApp();\n-        \/\/ now launch java from the created image and verify it launches correctly.\n-        launchJava(imageDir, helloWorldClassFile, false); \/\/ launch without security manager\n-        launchJava(imageDir, helloWorldClassFile, true); \/\/ launch with security manager\n-    }\n-\n-    private static Path compileApp() throws Exception {\n-        final Path tmpDir = Files.createTempDirectory(\"8206890\");\n-        final Path helloWorldJavaFile = Path.of(tmpDir.toAbsolutePath().toString(), \"Hello.java\");\n-        \/\/ write out the .java file\n-        Files.writeString(helloWorldJavaFile, HELLO_WORLD_APP);\n-        \/\/ now compile it\n-        final String[] javacArgs = new String[]{\"-d\", tmpDir.toAbsolutePath().toString(),\n-                helloWorldJavaFile.toAbsolutePath().toString()};\n-        final int exitCode = JAVAC_TOOL.run(System.out, System.err, javacArgs);\n-        if (exitCode != 0) {\n-            throw new AssertionError(\"Failed to compile hello world app\");\n-        }\n-        final Path helloClassFile = Path.of(tmpDir.toAbsolutePath().toString(), \"Hello.class\");\n-        if (!Files.exists(helloClassFile)) {\n-            throw new AssertionError(\"Compiled class file is missing at \" + helloClassFile);\n-        }\n-        System.out.println(\"Compiled Hello.class to \" + helloClassFile);\n-        \/\/ return the Path to the Hello.class file\n-        return Path.of(tmpDir.toAbsolutePath().toString(), \"Hello.class\");\n-    }\n-\n-    private static void launchJava(final Path imageDir, final Path helloWorldClassFile,\n-                                   final boolean withSecurityManager)\n-            throws Exception {\n-        \/\/ first try \"java --version\" from that created image\n-        final Path java = Path.of(imageDir.toAbsolutePath().toString(), \"bin\", \"java\");\n-        final String[] javaVersionCmd = new String[]{java.toAbsolutePath().toString(), \"-version\"};\n-        final String versionOutput = runProcess(javaVersionCmd, null).getStderr();\n-        System.out.println(\"java --version from newly created image returned: \" + versionOutput);\n-\n-        \/\/ now try launching a Java application from the newly created image\n-        final String[] helloWorldProcessCmd;\n-        if (withSecurityManager) {\n-            helloWorldProcessCmd = new String[]{\n-                    java.toAbsolutePath().toString(),\n-                    \"-cp\", \".\",\n-                    \"-Djava.security.manager=default\",\n-                    \"Hello\"\n-            };\n-        } else {\n-            helloWorldProcessCmd = new String[]{\n-                    java.toAbsolutePath().toString(),\n-                    \"-cp\", \".\",\n-                    \"Hello\"\n-            };\n-        }\n-        final String helloWorldOutput = runProcess(helloWorldProcessCmd,\n-                helloWorldClassFile.getParent().toFile()).getStdout();\n-        if (helloWorldOutput == null || !helloWorldOutput.equals(\"Hello world\")) {\n-            throw new AssertionError(\"Unexpected output from hello world application: \"\n-                    + helloWorldOutput);\n-        }\n-    }\n-\n-    \/\/ launches a process and asserts that the process exits with exit code 0.\n-    \/\/ returns the OutputAnalyzer instance of the completed process\n-    private static OutputAnalyzer runProcess(final String[] processCmd, final File workingDir)\n-            throws Exception {\n-        System.out.println(\"Launching process: \" + Arrays.toString(processCmd));\n-        final ProcessBuilder pb = new ProcessBuilder(processCmd).directory(workingDir);\n-        final OutputAnalyzer oa = ProcessTools.executeProcess(pb);\n-        final int exitCode = oa.getExitValue();\n-        if (exitCode != 0) {\n-            \/\/ dump the stdout and err of the completed process, for debugging\n-            oa.reportDiagnosticSummary();\n-            throw new AssertionError(\"Process execution failed with exit code: \" + exitCode);\n-        }\n-        return oa;\n-    }\n-}\n","filename":"test\/jdk\/tools\/jlink\/JLinkEndianTest.java","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"}]}