{"files":[{"patch":"@@ -27,0 +27,1 @@\n+COPY += target.properties\n","filename":"make\/modules\/jdk.jlink\/Java.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-import jdk.tools.jlink.plugin.ResourcePoolModule;\n@@ -147,1 +146,1 @@\n-    private Platform platform;\n+    private final Platform platform;\n@@ -153,0 +152,1 @@\n+     * @param launchers mapping of launcher command name to their module\/main class\n@@ -154,0 +154,1 @@\n+     * @throws NullPointerException If any of the params is null\n@@ -156,0 +157,15 @@\n+        this(root, launchers, Platform.UNKNOWN);\n+    }\n+\n+    \/**\n+     * Default image builder constructor.\n+     *\n+     * @param root The image root directory.\n+     * @param launchers mapping of launcher command name to their module\/main class\n+     * @param targetPlatform target platform of the image\n+     * @throws IOException\n+     * @throws NullPointerException If any of the params is null\n+     * @since 21\n+     *\/\n+    public DefaultImageBuilder(Path root, Map<String, String> launchers, Platform targetPlatform)\n+            throws IOException {\n@@ -157,0 +173,1 @@\n+        this.platform = Objects.requireNonNull(targetPlatform);\n@@ -170,9 +187,0 @@\n-            String value = files.moduleView()\n-                                .findModule(\"java.base\")\n-                                .map(ResourcePoolModule::targetPlatform)\n-                                .orElse(null);\n-            if (value == null) {\n-                throw new PluginException(\"ModuleTarget attribute is missing for java.base module\");\n-            }\n-            this.platform = Platform.parsePlatform(value);\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,2 @@\n-         * @param endian Jimage byte order. Native order by default\n+         * @param endian Jimage byte order. Can be null, which implies the byte order for\n+         *               the generated image will be determined during image generation\n@@ -167,1 +168,1 @@\n-            this.endian = Objects.requireNonNull(endian);\n+            this.endian = endian;\n@@ -172,1 +173,2 @@\n-         * @return the byte ordering\n+         * @return the byte ordering, can be null which implies no specific ByteOrder has been\n+         * explicitly set\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import jdk.internal.module.ModuleReferenceImpl;\n@@ -222,1 +223,1 @@\n-        ByteOrder endian = ByteOrder.nativeOrder();\n+        ByteOrder endian;\n@@ -389,1 +390,1 @@\n-        PluginsConfiguration config = taskHelper.getPluginsConfig(null, null);\n+        PluginsConfiguration config = taskHelper.getPluginsConfig(null, null, null);\n@@ -440,1 +441,1 @@\n-        ImageProvider imageProvider = createImageProvider(config,\n+        ImageHelper imageProvider = createImageProvider(config,\n@@ -449,1 +450,2 @@\n-            taskHelper.getPluginsConfig(options.output, options.launchers));\n+            taskHelper.getPluginsConfig(options.output, options.launchers,\n+                    imageProvider.targetPlatform));\n@@ -543,6 +545,6 @@\n-    private static ImageProvider createImageProvider(JlinkConfiguration config,\n-                                                     Path retainModulesPath,\n-                                                     boolean ignoreSigning,\n-                                                     boolean bindService,\n-                                                     boolean verbose,\n-                                                     PrintWriter log)\n+    private static ImageHelper createImageProvider(JlinkConfiguration config,\n+                                                   Path retainModulesPath,\n+                                                   boolean ignoreSigning,\n+                                                   boolean bindService,\n+                                                   boolean verbose,\n+                                                   PrintWriter log)\n@@ -595,1 +597,2 @@\n-        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning);\n+        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning,\n+                verbose, log);\n@@ -809,0 +812,1 @@\n+        final Platform targetPlatform;\n@@ -814,2 +818,45 @@\n-                    boolean ignoreSigning) throws IOException {\n-            this.order = order;\n+                    boolean ignoreSigning,\n+                    boolean verbose,\n+                    PrintWriter log) throws IOException {\n+            if (order != null) {\n+                this.order = order;\n+                String targetPlatformVal = readJavaBaseTargetPlatform(cf);\n+                this.targetPlatform = Platform.parsePlatform(targetPlatformVal);\n+                \/\/ explicit endianness specified, verify it matches the target java.base\n+                \/\/ platform's endianness\n+                ByteOrder targetEndianness = this.targetPlatform.getNativeByteOrder();\n+                if (targetEndianness != null && (this.order != targetEndianness)) {\n+                    \/\/ explicitly specified endianness doesn't match the determined endianness\n+                    \/\/ of the target platform\n+                    throw new IOException(\n+                            taskHelper.getMessage(\"err.target.endianness.mismatch\", order,\n+                                    targetPlatformVal));\n+                }\n+            } else {\n+                Path javaBasePath = modsPaths.get(\"java.base\");\n+                assert javaBasePath != null : \"java.base module path is missing\";\n+                if (this.isJavaBaseFromCurrentPlatform(javaBasePath)) {\n+                    \/\/ this implies that the java.base module used for the target image\n+                    \/\/ will correspond to the current platform. So this isn't an attempt to\n+                    \/\/ build a cross-platform image. We use the current platform's endianness\n+                    \/\/ in this case\n+                    this.targetPlatform = Platform.runtime();\n+                    this.order = ByteOrder.nativeOrder();\n+                } else {\n+                    \/\/ this is an attempt to build a cross-platform image. We now attempt to\n+                    \/\/ find the target platform's arch and thus its endianness from the java.base\n+                    \/\/ module's ModuleTarget attribute\n+                    String targetPlatformVal = readJavaBaseTargetPlatform(cf);\n+                    this.targetPlatform = Platform.parsePlatform(targetPlatformVal);\n+                    this.order = this.targetPlatform.getNativeByteOrder();\n+                    if (this.order == null) {\n+                        throw new IOException(\n+                                taskHelper.getMessage(\"err.unknown.target.endianness\",\n+                                        targetPlatformVal));\n+                    }\n+                    if (verbose && log != null) {\n+                        log.format(\"Cross-platform image generation, using %s for target platform\" +\n+                                        \" %s%n\", this.order, targetPlatformVal);\n+                    }\n+                }\n+            }\n@@ -834,0 +881,35 @@\n+        \/\/ returns true if the current platform's \"jmods\" directory is the parent of the\n+        \/\/ passed javaBasePath\n+        private boolean isJavaBaseFromCurrentPlatform(Path javaBasePath) throws IOException {\n+            Path currentPlatformJmods = getDefaultModulePath();\n+            if (currentPlatformJmods == null) {\n+                return false;\n+            }\n+            \/\/ resolve, against the current platform's jmods dir, the java.base module file used\n+            \/\/ for image creation\n+            Path javaBaseInDefaultPath = currentPlatformJmods.resolve(javaBasePath.getFileName());\n+            if (!Files.exists(javaBaseInDefaultPath)) {\n+                \/\/ the java.base module used for image creation doesn't exist in the default\n+                \/\/ module path of current platform\n+                return false;\n+            }\n+            return Files.isSameFile(javaBasePath, javaBaseInDefaultPath);\n+        }\n+\n+        \/\/ returns the targetPlatform value from the ModuleTarget attribute of the java.base module.\n+        \/\/ throws IOException if the targetPlatform cannot be determined.\n+        private static String readJavaBaseTargetPlatform(Configuration cf) throws IOException {\n+            Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n+            assert javaBase.isPresent() : \"java.base module is missing\";\n+            ModuleReference ref = javaBase.get().reference();\n+            if (ref instanceof ModuleReferenceImpl modRefImpl\n+                    && modRefImpl.moduleTarget() != null) {\n+                return modRefImpl.moduleTarget().targetPlatform();\n+            }\n+            \/\/ could not determine target platform\n+            throw new IOException(\n+                    taskHelper.getMessage(\"err.cannot.determine.target.platform\",\n+                            ref.location().map(URI::toString)\n+                                    .orElse(\"java.base module\")));\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":96,"deletions":14,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,4 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n@@ -28,0 +32,2 @@\n+import java.util.Map;\n+import java.util.Properties;\n@@ -34,0 +40,29 @@\n+    private static final Map<Platform, ByteOrder> endianness;\n+\n+    static {\n+        Properties p;\n+        try (InputStream is = Platform.class.getResourceAsStream(\"target.properties\")) {\n+            p = new Properties();\n+            p.load(is);\n+        } catch (IOException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+        Map<Platform, ByteOrder> byteOrders = new HashMap<>();\n+        for (String k : p.stringPropertyNames()) {\n+            Platform platform = parsePlatform(k);\n+            if (platform.os == OperatingSystem.UNKNOWN || platform.arch == Architecture.UNKNOWN) {\n+                \/\/ skip unknown platform\n+                continue;\n+            }\n+            String v = p.getProperty(k);\n+            ByteOrder endian = switch (v.trim().toLowerCase(Locale.ROOT)) {\n+                case \"little\" -> ByteOrder.LITTLE_ENDIAN;\n+                case \"big\" -> ByteOrder.BIG_ENDIAN;\n+                default -> throw new ExceptionInInitializerError(\"Unrecognized endian value '\"\n+                        + v + \"' for arch '\" + k + \"'\");\n+            };\n+            byteOrders.put(platform, endian);\n+        }\n+        endianness = byteOrders;\n+    }\n+\n@@ -47,0 +82,3 @@\n+        PPC64,\n+        PPC64LE,\n+        s390x,\n@@ -77,1 +115,1 @@\n-     * @return true is it's a 64-bit platform\n+     * @return true if it's a 64-bit platform\n@@ -80,2 +118,4 @@\n-        return (arch() == Platform.Architecture.x64 ||\n-                arch() == Platform.Architecture.AARCH64);\n+        return switch (arch) {\n+            case x64, AARCH64, PPC64, PPC64LE, s390x -> true;\n+            default -> false;\n+        };\n@@ -91,0 +131,7 @@\n+    \/**\n+     * {@return the native {@link ByteOrder} of this {@code Platform} or null if not known}\n+     *\/\n+    public ByteOrder getNativeByteOrder() {\n+        return endianness.get(this);\n+    }\n+\n@@ -131,0 +178,3 @@\n+            case \"ppc64\"           -> Architecture.PPC64;\n+            case \"ppc64le\"         -> Architecture.PPC64LE;\n+            case \"s390x\"           -> Architecture.s390x;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Platform.java","additions":54,"deletions":4,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -420,2 +420,3 @@\n-        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers\n-                    ) throws IOException, BadArgs {\n+        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                      Platform targetPlatform)\n+                throws IOException, BadArgs {\n@@ -468,1 +469,1 @@\n-                builder = new DefaultImageBuilder(output, launchers);\n+                builder = new DefaultImageBuilder(output, launchers, targetPlatform);\n@@ -719,1 +720,2 @@\n-    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers)\n+    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                 Platform targetPlatform)\n@@ -721,1 +723,1 @@\n-        return pluginOptions.getPluginsConfig(output, launchers);\n+        return pluginOptions.getPluginsConfig(output, launchers, targetPlatform);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+#\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# osname-architecture mapped to their endianness\n+aix-ppc64=big\n+linux-aarch64=little\n+linux-arm=little\n+linux-amd64=little\n+linux-ppc64le=little\n+linux-s390x=big\n+linux-x86=little\n+macos-aarch64=little\n+macos-amd64=little\n+windows-amd64=little\n+windows-x86=little\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/target.properties","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,4 @@\n+err.cannot.determine.target.platform=cannot determine target platform from {0}\n+err.target.endianness.mismatch=specified --endian {0} does not match endianness of target \\\n+platform {1}\n+err.unknown.target.endianness=Unknown native byte order for target platform {0}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}