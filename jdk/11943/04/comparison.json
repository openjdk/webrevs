{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,2 @@\n-         * @param endian Jimage byte order. Native order by default\n+         * @param endian Jimage byte order. Can be null, which implies the byte order for\n+         *               the generated image will be determined during image generation\n@@ -167,1 +168,1 @@\n-            this.endian = Objects.requireNonNull(endian);\n+            this.endian = endian;\n@@ -172,1 +173,2 @@\n-         * @return the byte ordering\n+         * @return the byte ordering, can be null which implies no specific ByteOrder has been\n+         * explicitly set\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,3 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n@@ -63,0 +66,1 @@\n+import jdk.internal.module.ModuleReferenceImpl;\n@@ -222,1 +226,1 @@\n-        ByteOrder endian = ByteOrder.nativeOrder();\n+        ByteOrder endian;\n@@ -595,1 +599,2 @@\n-        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning);\n+        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning,\n+                verbose, log);\n@@ -814,2 +819,45 @@\n-                    boolean ignoreSigning) throws IOException {\n-            this.order = order;\n+                    boolean ignoreSigning,\n+                    boolean verbose,\n+                    PrintWriter log) throws IOException {\n+            if (order != null) {\n+                this.order = order;\n+            } else {\n+                Path javaBasePath = modsPaths.get(\"java.base\");\n+                assert javaBasePath != null : \"java.base module path is missing\";\n+                if (this.isJavaBaseFromCurrentPlatform(javaBasePath)) {\n+                    \/\/ this implies that the java.base module used for the target image\n+                    \/\/ will correspond to the current platform. So this isn't an attempt to\n+                    \/\/ build a cross-platform image. We use the current platform's endianness\n+                    \/\/ in this case\n+                    this.order = ByteOrder.nativeOrder();\n+                } else {\n+                    \/\/ this is an attempt to build a cross-platform image. We now attempt to\n+                    \/\/ find the target platform's arch and thus its endianness from the java.base\n+                    \/\/ module's ModuleTarget attribute\n+                    Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n+                    assert javaBase.isPresent() : \"java.base module is missing\";\n+                    ModuleReference ref = javaBase.get().reference();\n+                    String targetPlatform = null;\n+                    if (ref instanceof ModuleReferenceImpl modRefImpl\n+                            && modRefImpl.moduleTarget() != null) {\n+                        targetPlatform = modRefImpl.moduleTarget().targetPlatform();\n+                    }\n+                    if (targetPlatform == null) {\n+                        \/\/ could not determine target platform\n+                        throw new IOException(\n+                                taskHelper.getMessage(\"err.cannot.determine.target.platform\"));\n+                    }\n+                    ByteOrder targetByteOrder = getNativeEndianOfTargetPlatform(targetPlatform);\n+                    if (targetByteOrder == null) {\n+                        \/\/ unsupported target platform\n+                        throw new IOException(\n+                                taskHelper.getMessage(\"err.unsupported.target.platform\",\n+                                        targetPlatform));\n+                    }\n+                    this.order = targetByteOrder;\n+                    if (verbose && log != null) {\n+                        log.format(\"Cross-platform image generation, using %s for target platform\" +\n+                                        \" %s%n\", this.order, targetPlatform);\n+                    }\n+                }\n+            }\n@@ -834,0 +882,22 @@\n+        \/\/ returns true if the current platform's \"jmods\" directory is the parent of the\n+        \/\/ passed javaBasePath\n+        private boolean isJavaBaseFromCurrentPlatform(Path javaBasePath) throws IOException {\n+            Path currentPlatformJmods = getDefaultModulePath();\n+            if (currentPlatformJmods == null) {\n+                return false;\n+            }\n+            boolean ret;\n+            try {\n+                @SuppressWarnings(\"removal\")\n+                var unused = ret = AccessController.doPrivileged(\n+                        \/\/ check if the current platform's \"jmods\" directory is the parent of\n+                        \/\/ the \"java.base\" module file used to create the image\n+                        (PrivilegedExceptionAction<Boolean>) () -> Files.isSameFile(javaBasePath,\n+                                currentPlatformJmods.resolve(Path.of(\"java.base.jmod\"))));\n+            } catch (PrivilegedActionException e) {\n+                \/\/ Files.isSameFile() is only expected to throw an IOException\n+                throw (IOException) e.getCause();\n+            }\n+            return ret;\n+        }\n+\n@@ -887,0 +957,21 @@\n+        \/\/ returns the endianness of the target platform, if the target platform is known\n+        \/\/ and supported for creating an image through jlink. Else returns null.\n+        private static ByteOrder getNativeEndianOfTargetPlatform(String targetPlatform) {\n+            int index = targetPlatform.indexOf(\"-\"); \/\/ of the form <operating system>-<arch>\n+            if (index < 0) {\n+                \/\/ unknown arch\n+                return null;\n+            }\n+            String archName = targetPlatform.substring(index + 1);\n+            return switch (archName) {\n+                case \"x86\", \"x86_64\",\n+                        \"amd64\", \"arm\", \"aarch64\",\n+                        \"loongarch64\", \"ppc64le\",\n+                        \"riscv32\", \"riscv64\" -> ByteOrder.LITTLE_ENDIAN;\n+                case \"ppc\", \"ppc64\",\n+                        \"s390\", \"s390x\",\n+                        \"sparc\", \"sparcv9\" -> ByteOrder.BIG_ENDIAN;\n+                default -> null;\n+            };\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":96,"deletions":5,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,2 @@\n+err.cannot.determine.target.platform=cannot determine target platform for image generation\n+err.unsupported.target.platform=image generation for target platform {0} is not supported\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}