{"files":[{"patch":"@@ -27,0 +27,1 @@\n+COPY += target.properties\n","filename":"make\/modules\/jdk.jlink\/Java.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-import jdk.tools.jlink.plugin.ResourcePoolModule;\n@@ -147,1 +146,1 @@\n-    private Platform platform;\n+    private final Platform platform;\n@@ -153,0 +152,1 @@\n+     * @param launchers mapping of launcher command name to their module\/main class\n@@ -154,0 +154,1 @@\n+     * @throws NullPointerException If any of the params is null\n@@ -156,0 +157,14 @@\n+        this(root, launchers, Platform.UNKNOWN);\n+    }\n+\n+    \/**\n+     * Default image builder constructor.\n+     *\n+     * @param root The image root directory.\n+     * @param launchers mapping of launcher command name to their module\/main class\n+     * @param targetPlatform target platform of the image\n+     * @throws IOException\n+     * @throws NullPointerException If any of the params is null\n+     *\/\n+    public DefaultImageBuilder(Path root, Map<String, String> launchers, Platform targetPlatform)\n+            throws IOException {\n@@ -157,0 +172,1 @@\n+        this.platform = Objects.requireNonNull(targetPlatform);\n@@ -170,9 +186,0 @@\n-            String value = files.moduleView()\n-                                .findModule(\"java.base\")\n-                                .map(ResourcePoolModule::targetPlatform)\n-                                .orElse(null);\n-            if (value == null) {\n-                throw new PluginException(\"ModuleTarget attribute is missing for java.base module\");\n-            }\n-            this.platform = Platform.parsePlatform(value);\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,2 @@\n-         * @param endian Jimage byte order. Native order by default\n+         * @param endian Jimage byte order. Can be null, which implies the byte order for\n+         *               the generated image will be determined during image generation\n@@ -167,1 +168,1 @@\n-            this.endian = Objects.requireNonNull(endian);\n+            this.endian = endian;\n@@ -172,1 +173,2 @@\n-         * @return the byte ordering\n+         * @return the byte ordering, can be null which implies no specific ByteOrder has been\n+         * explicitly set\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import jdk.internal.module.ModuleReferenceImpl;\n@@ -222,1 +223,1 @@\n-        ByteOrder endian = ByteOrder.nativeOrder();\n+        ByteOrder endian;\n@@ -411,1 +412,1 @@\n-        ImageProvider imageProvider = createImageProvider(config,\n+        ImageHelper imageProvider = createImageProvider(config,\n@@ -420,1 +421,2 @@\n-            taskHelper.getPluginsConfig(options.output, options.launchers));\n+            taskHelper.getPluginsConfig(options.output, options.launchers,\n+                    imageProvider.targetPlatform));\n@@ -514,6 +516,6 @@\n-    private static ImageProvider createImageProvider(JlinkConfiguration config,\n-                                                     Path retainModulesPath,\n-                                                     boolean ignoreSigning,\n-                                                     boolean bindService,\n-                                                     boolean verbose,\n-                                                     PrintWriter log)\n+    private static ImageHelper createImageProvider(JlinkConfiguration config,\n+                                                   Path retainModulesPath,\n+                                                   boolean ignoreSigning,\n+                                                   boolean bindService,\n+                                                   boolean verbose,\n+                                                   PrintWriter log)\n@@ -566,1 +568,2 @@\n-        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning);\n+        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning,\n+                verbose, log);\n@@ -780,0 +783,1 @@\n+        final Platform targetPlatform;\n@@ -785,2 +789,23 @@\n-                    boolean ignoreSigning) throws IOException {\n-            this.order = order;\n+                    boolean ignoreSigning,\n+                    boolean verbose,\n+                    PrintWriter log) throws IOException {\n+            this.targetPlatform = targetPlatform(cf, modsPaths);\n+            this.order = order != null ? order : targetPlatform.endianness();\n+            if (this.order == null) {\n+                throw new IOException(\n+                        taskHelper.getMessage(\"err.unknown.target.endianness\", targetPlatform));\n+            }\n+\n+            if (this.order != targetPlatform.endianness() && targetPlatform.endianness() != null) {\n+                \/\/ explicitly specified endianness doesn't match the determined endianness\n+                \/\/ of the target platform\n+                throw new IOException(\n+                        taskHelper.getMessage(\"err.target.endianness.mismatch\", order, targetPlatform));\n+            }\n+            if (verbose && log != null) {\n+                Platform runtime = Platform.runtime();\n+                if (runtime.os() != targetPlatform.os() || runtime.arch() != targetPlatform.arch()) {\n+                    log.format(\"Cross-platform image generation, using %s for target platform %s%n\",\n+                            this.order, targetPlatform);\n+                }\n+            }\n@@ -805,0 +830,53 @@\n+        private static Platform targetPlatform(Configuration cf, Map<String, Path> modsPaths) throws IOException {\n+            Path javaBasePath = modsPaths.get(\"java.base\");\n+            assert javaBasePath != null : \"java.base module path is missing\";\n+            if (isJavaBaseFromCurrentPlatform(javaBasePath)) {\n+                \/\/ this implies that the java.base module used for the target image\n+                \/\/ will correspond to the current platform. So this isn't an attempt to\n+                \/\/ build a cross-platform image. We use the current platform's endianness\n+                \/\/ in this case\n+                return Platform.runtime();\n+            } else {\n+                \/\/ this is an attempt to build a cross-platform image. We now attempt to\n+                \/\/ find the target platform's arch and thus its endianness from the java.base\n+                \/\/ module's ModuleTarget attribute\n+                String targetPlatformVal = readJavaBaseTargetPlatform(cf);\n+                return Platform.parsePlatform(targetPlatformVal);\n+            }\n+        }\n+\n+        \/\/ returns true if the current platform's \"jmods\" directory is the parent of the\n+        \/\/ passed javaBasePath\n+        private static boolean isJavaBaseFromCurrentPlatform(Path javaBasePath) throws IOException {\n+            Path currentPlatformJmods = getDefaultModulePath();\n+            if (currentPlatformJmods == null) {\n+                return false;\n+            }\n+            \/\/ resolve, against the current platform's jmods dir, the java.base module file used\n+            \/\/ for image creation\n+            Path javaBaseInDefaultPath = currentPlatformJmods.resolve(javaBasePath.getFileName());\n+            if (!Files.exists(javaBaseInDefaultPath)) {\n+                \/\/ the java.base module used for image creation doesn't exist in the default\n+                \/\/ module path of current platform\n+                return false;\n+            }\n+            return Files.isSameFile(javaBasePath, javaBaseInDefaultPath);\n+        }\n+\n+        \/\/ returns the targetPlatform value from the ModuleTarget attribute of the java.base module.\n+        \/\/ throws IOException if the targetPlatform cannot be determined.\n+        private static String readJavaBaseTargetPlatform(Configuration cf) throws IOException {\n+            Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n+            assert javaBase.isPresent() : \"java.base module is missing\";\n+            ModuleReference ref = javaBase.get().reference();\n+            if (ref instanceof ModuleReferenceImpl modRefImpl\n+                    && modRefImpl.moduleTarget() != null) {\n+                return modRefImpl.moduleTarget().targetPlatform();\n+            }\n+            \/\/ could not determine target platform\n+            throw new IOException(\n+                    taskHelper.getMessage(\"err.cannot.determine.target.platform\",\n+                            ref.location().map(URI::toString)\n+                                    .orElse(\"java.base module\")));\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":91,"deletions":13,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,4 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n@@ -28,0 +32,2 @@\n+import java.util.Map;\n+import java.util.Properties;\n@@ -32,1 +38,25 @@\n-public record Platform(OperatingSystem os, Architecture arch) {\n+public record Platform(OperatingSystem os, Architecture arch, ByteOrder endianness) {\n+    private static final Properties KNOWN_ENDIANNESS;\n+    private static final String ENDIANNESS_KEY_SUFFIX = \".endianness\";\n+\n+    static {\n+        Properties p = null;\n+        try (InputStream is = Platform.class.getResourceAsStream(\"target.properties\")) {\n+            p = new Properties();\n+            p.load(is);\n+        } catch (IOException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+        Properties endianness = new Properties();\n+        for (String key : p.stringPropertyNames()) {\n+            if (key.endsWith(ENDIANNESS_KEY_SUFFIX)) {\n+                String val = p.getProperty(key);\n+                String platform = key.substring(0, key.indexOf(ENDIANNESS_KEY_SUFFIX));\n+                if (platform.isEmpty()) {\n+                    throw new InternalError(\"Incorrect key '\" + key + \"'\");\n+                }\n+                endianness.put(platform, val);\n+            }\n+        }\n+        KNOWN_ENDIANNESS = endianness;\n+    }\n@@ -47,0 +77,3 @@\n+        PPC64,\n+        PPC64LE,\n+        s390x,\n@@ -50,1 +83,1 @@\n-    public static final Platform UNKNOWN = new Platform(OperatingSystem.UNKNOWN, Architecture.UNKNOWN);\n+    public static final Platform UNKNOWN = new Platform(OperatingSystem.UNKNOWN, Architecture.UNKNOWN, null);\n@@ -73,1 +106,14 @@\n-        return new Platform(os, arch);\n+\n+        if (os == OperatingSystem.UNKNOWN || arch == Architecture.UNKNOWN) {\n+            return UNKNOWN;\n+        }\n+        \/\/ map the endianness from target.properties\n+        \/\/ until ModuleTarget attribute is extended to include the endianness\n+        String v = KNOWN_ENDIANNESS.getProperty(platformString);\n+        ByteOrder endian = switch (v.trim().toLowerCase(Locale.ROOT)) {\n+            case \"little\" -> ByteOrder.LITTLE_ENDIAN;\n+            case \"big\" -> ByteOrder.BIG_ENDIAN;\n+            default -> throw new InternalError(\"Unrecognized endian value '\" + platformString + \"'\");\n+        };\n+\n+        return new Platform(os, arch, endian);\n@@ -77,1 +123,1 @@\n-     * @return true is it's a 64-bit platform\n+     * @return true if it's a 64-bit platform\n@@ -80,2 +126,4 @@\n-        return (arch() == Platform.Architecture.x64 ||\n-                arch() == Platform.Architecture.AARCH64);\n+        return switch (arch) {\n+            case x64, AARCH64, PPC64, PPC64LE, s390x -> true;\n+            default -> false;\n+        };\n@@ -88,1 +136,1 @@\n-        return new Platform(runtimeOS(), runtimeArch());\n+        return new Platform(runtimeOS(), runtimeArch(), ByteOrder.nativeOrder());\n@@ -131,0 +179,3 @@\n+            case \"ppc64\"           -> Architecture.PPC64;\n+            case \"ppc64le\"         -> Architecture.PPC64LE;\n+            case \"s390x\"           -> Architecture.s390x;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Platform.java","additions":59,"deletions":8,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,2 +412,3 @@\n-        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers\n-                    ) throws IOException, BadArgs {\n+        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                      Platform targetPlatform)\n+                throws IOException, BadArgs {\n@@ -460,1 +461,1 @@\n-                builder = new DefaultImageBuilder(output, launchers);\n+                builder = new DefaultImageBuilder(output, launchers, targetPlatform);\n@@ -711,1 +712,2 @@\n-    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers)\n+    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                 Platform targetPlatform)\n@@ -713,1 +715,1 @@\n-        return pluginOptions.getPluginsConfig(output, launchers);\n+        return pluginOptions.getPluginsConfig(output, launchers, targetPlatform);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+#\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# <osname-architecture>.endianness mapped to their endianness\n+aix-ppc64.endianness=big\n+linux-aarch64.endianness=little\n+linux-arm.endianness=little\n+linux-amd64.endianness=little\n+linux-ppc64le.endianness=little\n+linux-s390x.endianness=big\n+linux-x86.endianness=little\n+macos-aarch64.endianness=little\n+macos-amd64.endianness=little\n+windows-amd64.endianness=little\n+windows-x86.endianness=little\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/target.properties","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,0 +149,4 @@\n+err.cannot.determine.target.platform=cannot determine target platform from {0}\n+err.target.endianness.mismatch=specified --endian {0} does not match endianness of target \\\n+platform {1}\n+err.unknown.target.endianness=Unknown native byte order for target platform {0}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}