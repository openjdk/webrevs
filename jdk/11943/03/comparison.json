{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,2 @@\n-         * @param endian Jimage byte order. Native order by default\n+         * @param endian Jimage byte order. Can be null, which implies the byte order for\n+         *               the generated image will be determined during image generation\n@@ -167,1 +168,1 @@\n-            this.endian = Objects.requireNonNull(endian);\n+            this.endian = endian;\n@@ -172,1 +173,2 @@\n-         * @return the byte ordering\n+         * @return the byte ordering, can be null which implies no specific ByteOrder has been\n+         * explicitly set\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import jdk.internal.module.ModuleReferenceImpl;\n@@ -222,1 +223,1 @@\n-        ByteOrder endian = ByteOrder.nativeOrder();\n+        ByteOrder endian;\n@@ -815,1 +816,20 @@\n-            this.order = order;\n+            if (order != null) {\n+                this.order = order;\n+            } else {\n+                \/\/ Use the java.base module of the target platform to determine the endianness\n+                \/\/ of the target image\n+                String targetPlatform = null;\n+                Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n+                if (javaBase.isPresent()) {\n+                    ModuleReference ref = javaBase.get().reference();\n+                    if (ref instanceof ModuleReferenceImpl modRefImpl\n+                            && modRefImpl.moduleTarget() != null) {\n+                        targetPlatform = modRefImpl.moduleTarget().targetPlatform();\n+                    }\n+                }\n+                if (targetPlatform != null) {\n+                    this.order = getNativeEndianOfTargetPlatform(targetPlatform);\n+                } else {\n+                    this.order = ByteOrder.nativeOrder();\n+                }\n+            }\n@@ -887,0 +907,25 @@\n+        \/\/ returns the endianness of the target platform, if known. Else returns the\n+        \/\/ current platform's endianness\n+        private static ByteOrder getNativeEndianOfTargetPlatform(String targetPlatform) {\n+            int index = targetPlatform.indexOf(\"-\"); \/\/ of the form <operating system>-<arch>\n+            if (index < 0) {\n+                \/\/ unknown arch, return current platform's endianness\n+                return ByteOrder.nativeOrder();\n+            }\n+            String archName = targetPlatform.substring(index + 1);\n+            return switch (archName) {\n+                case \"x86\", \"x86_64\",\n+                        \"alpha\", \"amd64\",\n+                        \"arm\", \"aarch64\",\n+                        \"ia64\", \"mipsel\",\n+                        \"mips64el\", \"loongarch64\",\n+                        \"ppc64le\", \"riscv32\", \"riscv64\" -> ByteOrder.LITTLE_ENDIAN;\n+                case \"m68k\", \"mips\",\n+                        \"mips64\", \"ppc\",\n+                        \"ppc64\", \"s390\",\n+                        \"s390x\", \"sh\",\n+                        \"sparc\", \"sparcv9\" -> ByteOrder.BIG_ENDIAN;\n+                default -> ByteOrder.nativeOrder();\n+            };\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"}]}