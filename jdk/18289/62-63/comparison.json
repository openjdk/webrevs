{"files":[{"patch":"@@ -67,1 +67,1 @@\n-  device->_tree.in_order_traversal([&](VMATree::TreapNode* current) {\n+  device->_tree.visit_in_order([&](VMATree::TreapNode* current) {\n","filename":"src\/hotspot\/share\/nmt\/nmtMemoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-    this->in_order_traversal([&](TreapNode* node) {\n+    this->visit_in_order([&](TreapNode* node) {\n@@ -325,11 +325,0 @@\n-private:\n-  template<typename F>\n-  void in_order_traversal_doer(F f, TreapNode* node) const {\n-    if (node == nullptr) return;\n-    in_order_traversal_doer(f, node->left());\n-    f(node);\n-    in_order_traversal_doer(f, node->right());\n-  }\n-\n-public:\n-\n@@ -338,2 +327,12 @@\n-  void in_order_traversal(F f) const {\n-    in_order_traversal_doer(f, _root);\n+  void visit_in_order(F f) const {\n+    GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n+    TreapNode* head = _root;\n+    while (!to_visit.is_empty() || head != nullptr) {\n+      while (head != nullptr) {\n+        to_visit.push(head);\n+        head = head->left();\n+      }\n+      head = to_visit.pop();\n+      f(head);\n+      head = head->right();\n+    }\n@@ -342,1 +341,1 @@\n-  \/\/ Visit all TreapNodes where key is in range [from, to)\n+  \/\/ Visit all TreapNodes in ascending order whose keys are in range [from, to).\n@@ -344,1 +343,1 @@\n-  void visit_range(const K& from, const K& to, F f) {\n+  void visit_range_in_order(const K& from, const K& to, F f) {\n@@ -346,3 +345,13 @@\n-    to_visit.push(_root);\n-    TreapNode* head = nullptr;\n-    while (!to_visit.is_empty()) {\n+    TreapNode* head = _root;\n+    while (!to_visit.is_empty() || head != nullptr) {\n+      while (head != nullptr) {\n+        int cmp_from = COMPARATOR::cmp(head->key(), from);\n+        to_visit.push(head);\n+        if (cmp_from >= 0) {\n+          head = head->left();\n+        } else {\n+          \/\/ We've reached a node which is strictly less than from\n+          \/\/ We don't need to visit any further to the left.\n+          break;\n+        }\n+      }\n@@ -350,9 +359,3 @@\n-      if (head == nullptr) continue;\n-\n-      int cmp_from = COMPARATOR::cmp(head->key(), from);\n-      int cmp_to = COMPARATOR::cmp(head->key(), to);\n-      if (cmp_from < 0) {\n-        to_visit.push(head->right());\n-      } else if (cmp_to >= 0) {\n-        to_visit.push(head->left());\n-      } else if (cmp_from >= 0 && cmp_to < 0) {\n+      const int cmp_from = COMPARATOR::cmp(head->key(), from);\n+      const int cmp_to = COMPARATOR::cmp(head->key(), to);\n+      if (cmp_from >= 0 && cmp_to < 0) {\n@@ -360,2 +363,5 @@\n-        to_visit.push(head->left());\n-        to_visit.push(head->right());\n+      }\n+      if (cmp_to < 0) {\n+        head = head->right();\n+      } else {\n+        head = nullptr;\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -50,15 +50,0 @@\n-  \/\/ We will need the nodes which are closest to A from the left side and closest to B from the right side.\n-  \/\/ Motivating example: reserve(0,100, mtNMT); reserve(50,75, mtTest);\n-  \/\/ This will require the 2nd call to know which region the second reserve 'smashes' a hole into for proper summary accounting.\n-  \/\/ LEQ_A is figured out a bit later on, as we need to find it for other purposes anyway.\n-  bool LEQ_A_found = false;\n-  AddressState LEQ_A;\n-  bool GEQ_B_found = false;\n-  AddressState GEQ_B;\n-  TreapNode* geqB_n = tree.closest_geq(B);\n-  if (geqB_n != nullptr) {\n-    GEQ_B = {geqB_n->key(), geqB_n->val()};\n-    GEQ_B_found = true;\n-  }\n-\n-  SummaryDiff diff;\n@@ -73,0 +58,8 @@\n+\n+  \/\/ We will need the nodes which are closest to A from the left side and closest to B from the right side.\n+  \/\/ Motivating example: reserve(0,100, mtNMT); reserve(50,75, mtTest);\n+  \/\/ This example would require the 2nd call to know which region the second reserve 'smashes' a hole into for proper summary accounting.\n+  \/\/ LEQ_A is figured out a bit later on, as we need to find it for other purposes anyway.\n+  bool LEQ_A_found = false;\n+  AddressState LEQ_A;\n+\n@@ -137,1 +130,1 @@\n-  \/\/ Find all nodes between (A, B] and record their addresses. Also update B's\n+  \/\/ Find all nodes between (A, B] and record their addresses and values. Also update B's\n@@ -139,1 +132,1 @@\n-  tree.visit_range(A + 1, B + 1, [&](TreapNode* head) {\n+  tree.visit_range_in_order(A + 1, B + 1, [&](TreapNode* head) {\n@@ -165,2 +158,9 @@\n-  \/\/ 1. Delete all nodes between (A, B]. Including B in the case of a noop.\n-  \/\/ 2. Perform summary accounting\n+  \/\/ a) Delete all nodes between (A, B]. Including B in the case of a noop.\n+  \/\/ b) Perform summary accounting\n+  SummaryDiff diff;\n+\n+  AddressState GEQ_B;\n+  TreapNode* geqB_n = tree.closest_geq(B);\n+  if (geqB_n != nullptr) {\n+    GEQ_B = {geqB_n->key(), geqB_n->val()};\n+  }\n@@ -168,2 +168,2 @@\n-  if (to_be_deleted_inbetween_a_b.length() == 0 && LEQ_A_found && GEQ_B_found) {\n-    \/\/ We have smashed a hole in an existing region (or replaced it entirely).\n+  if (to_be_deleted_inbetween_a_b.length() == 0 && LEQ_A_found) {\n+    \/\/ We must have smashed a hole in an existing region (or replaced it entirely).\n@@ -180,5 +180,0 @@\n-  \/\/ Sort the found nodes in ascending order by address. This is for summary accounting purposes.\n-  to_be_deleted_inbetween_a_b.sort([](AddressState* a, AddressState* b) -> int {\n-    return -AddressComparator::cmp(a->address, b->address);\n-  });\n-\n@@ -187,3 +182,2 @@\n-  while (to_be_deleted_inbetween_a_b.length() > 0) {\n-    const AddressState delete_me = to_be_deleted_inbetween_a_b.top();\n-    to_be_deleted_inbetween_a_b.pop();\n+  for (int i = 0; i < to_be_deleted_inbetween_a_b.length(); i++) {\n+    const AddressState delete_me = to_be_deleted_inbetween_a_b.at(i);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":23,"deletions":29,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -154,2 +154,2 @@\n-  void in_order_traversal(F f) const {\n-    tree.in_order_traversal(f);\n+  void visit_in_order(F f) const {\n+    tree.visit_in_order(f);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    tree.tree.visit_range(0, 999999, [&](Node* x) {\n+    tree.tree.visit_range_in_order(0, 999999, [&](Node* x) {\n@@ -79,1 +79,1 @@\n-    tree.tree.visit_range(0, 999999, [&](Node* x) {\n+    tree.tree.visit_range_in_order(0, 999999, [&](Node* x) {\n@@ -90,1 +90,1 @@\n-    tree2.tree.visit_range(0, 999999, [&](Node* x) {\n+    tree2.tree.visit_range_in_order(0, 999999, [&](Node* x) {\n@@ -103,1 +103,1 @@\n-    tree2.tree.visit_range(0, 999999, [&](Node* x) {\n+    tree2.tree.visit_range_in_order(0, 999999, [&](Node* x) {\n@@ -141,1 +141,1 @@\n-    tree.tree.visit_range(0, 300, [&](Node* x) {\n+    tree.tree.visit_range_in_order(0, 300, [&](Node* x) {\n@@ -162,1 +162,1 @@\n-    tree.tree.visit_range(0, 999999, [&](Node* x) {\n+    tree.tree.visit_range_in_order(0, 999999, [&](Node* x) {\n@@ -190,1 +190,1 @@\n-    tree.tree.visit_range(0, 99999, [&](Node* x) {\n+    tree.tree.visit_range_in_order(0, 99999, [&](Node* x) {\n@@ -203,1 +203,1 @@\n-    tree.tree.visit_range(0, 99999, [&](Node* x) {\n+    tree.tree.visit_range_in_order(0, 99999, [&](Node* x) {\n@@ -222,1 +222,1 @@\n-    tree.tree.visit_range(0, 99999, [&](Node* x) {\n+    tree.tree.visit_range_in_order(0, 99999, [&](Node* x) {\n@@ -241,1 +241,1 @@\n-    tree.tree.visit_range(0, 99999, [&](Node* x) {\n+    tree.tree.visit_range_in_order(0, 99999, [&](Node* x) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}