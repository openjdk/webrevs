{"files":[{"patch":"@@ -27,0 +27,2 @@\n+#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/nmtNativeCallStackStorage.hpp\"\n@@ -340,0 +342,121 @@\n+\n+\/\/ Exceedingly simple tracker for page-granular allocations\n+\/\/ Use it for testing consistency with VMATree.\n+struct SimpleVMATracker : public CHeapObj<mtTest> {\n+  enum Tpe { Reserved, Committed, Free };\n+  struct Info {\n+    Tpe tpe;\n+    MEMFLAGS flag;\n+    NativeCallStack stack;\n+    Info() : tpe(Free), flag(mtNone), stack() {}\n+\n+    Info(Tpe tpe, NativeCallStack stack, MEMFLAGS flag)\n+    : tpe(tpe), flag(flag), stack(stack) {}\n+  };\n+  \/\/ Page (4KiB) granular array\n+  const size_t num_pages = 1024*1024;\n+  Info pages[1024 * 1024];\n+\n+  SimpleVMATracker()\n+  : pages() {\n+    for (size_t i = 0; i < num_pages; i++) {\n+      pages[i] = Info();\n+    }\n+  }\n+\n+  VMATree::SummaryDiff do_it(Tpe tpe, size_t start, size_t size, NativeCallStack stack, MEMFLAGS flag) {\n+    assert(size % 4096 == 0 && start % 4096 == 0, \"page alignment\");\n+    VMATree::SummaryDiff diff;\n+    const size_t page_count = size \/ 4096;\n+    const size_t start_idx = start \/ 4096;\n+    const size_t end_idx = start_idx + page_count - 1;\n+    assert(end_idx < (size_t)num_pages - 1, \"\");\n+\n+    Info new_info(tpe, stack, flag);\n+    for (size_t i = start_idx; i < end_idx; i++) {\n+      Info& old_info = pages[i];\n+\n+      \/\/ Register diff\n+      if (old_info.tpe == Reserved) {\n+        diff.flag[(int)old_info.flag].reserve -= 4096;\n+      } else if (old_info.tpe == Committed) {\n+        diff.flag[(int)old_info.flag].reserve -= 4096;\n+        diff.flag[(int)old_info.flag].commit -= 4096;\n+      }\n+\n+      if (tpe == Reserved) {\n+        diff.flag[(int)new_info.flag].reserve += 4096;\n+      } else if(tpe == Committed) {\n+        diff.flag[(int)new_info.flag].reserve += 4096;\n+        diff.flag[(int)new_info.flag].commit += 4096;\n+      }\n+      \/\/ Overwrite old one with new\n+      pages[i] = new_info;\n+    }\n+    return diff;\n+  }\n+\n+  VMATree::SummaryDiff reserve(size_t start, size_t size, NativeCallStack stack, MEMFLAGS flag) {\n+    return do_it(Reserved, start, size, stack, flag);\n+  }\n+\n+  VMATree::SummaryDiff commit(size_t start, size_t size, NativeCallStack stack, MEMFLAGS flag) {\n+    return do_it(Reserved, start, size, stack, flag);\n+  }\n+\n+  VMATree::SummaryDiff release(size_t start, size_t size) {\n+    return do_it(Reserved, start, size, NativeCallStack(), mtNone);\n+  }\n+};\n+\n+TEST_VM_F(VMATreeTest, TestConsistencyWithSimpleTracker) {\n+  SimpleVMATracker* tr = new SimpleVMATracker();\n+  VMATree tree;\n+  NativeCallStackStorage ncss(true);\n+\n+  NativeCallStack stacks[4] = {\n+    make_stack(0xA),\n+    make_stack(0xB),\n+    make_stack(0xC),\n+    make_stack(0xD)\n+  };\n+\n+\n+  const int operation_count = 1000000; \/\/ One million\n+  for (int i = 0; i < operation_count; i++) {\n+    const int page_start = os::random() % tr->num_pages;\n+    const int num_pages = os::random() % (tr->num_pages - page_start);\n+    if (num_pages == 0) {\n+      i--; continue;\n+    }\n+    const size_t start = page_start * 4096;\n+    const size_t size = num_pages * 4096;\n+\n+    const MEMFLAGS flag = (MEMFLAGS)(os::random() % mt_number_of_types);\n+    const NativeCallStack stack = stacks[os::random() % 4];\n+    const NativeCallStackStorage::StackIndex si = ncss.push(stack);\n+    VMATree::RegionData data(si, flag);\n+\n+    const SimpleVMATracker::Tpe tpe = (SimpleVMATracker::Tpe)(os::random() % 3);\n+\n+    VMATree::SummaryDiff tree_diff;\n+    VMATree::SummaryDiff simple_diff;\n+    if (tpe == SimpleVMATracker::Reserved) {\n+      simple_diff = tr->reserve(start, size, stack, flag);\n+      tree_diff = tree.reserve_mapping(start, size, data);\n+    } else if (tpe == SimpleVMATracker::Committed) {\n+      simple_diff = tr->commit(start, size, stack, flag);\n+      tree_diff = tree.commit_mapping(start, size, data);\n+    } else {\n+      simple_diff = tr->release(start, size);\n+      tree_diff = tree.release_mapping(start, size);\n+    }\n+\n+    for (int j = 0; j < mt_number_of_types; j++) {\n+      VMATree::SingleDiff td = tree_diff.flag[j];\n+      VMATree::SingleDiff sd = simple_diff.flag[j];\n+      EXPECT_EQ(td.reserve, sd.reserve);\n+      EXPECT_EQ(td.commit, sd.commit);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"}]}