{"files":[{"patch":"@@ -50,1 +50,0 @@\n-  friend class VMATree;\n@@ -56,2 +55,2 @@\n-  TreapNode<K, V, CMP>* left;\n-  TreapNode<K, V, CMP>* right;\n+  Nd* _left;\n+  Nd* _right;\n@@ -77,2 +76,2 @@\n-      auto p = split(head->right, key, mode);\n-      head->right = p.left;\n+      nd_pair p = split(head->_right, key, mode);\n+      head->_right = p.left;\n@@ -81,2 +80,2 @@\n-      auto p = split(head->left, key, mode);\n-      head->left = p.right;\n+      nd_pair p = split(head->_left, key, mode);\n+      head->_left = p.right;\n@@ -98,1 +97,1 @@\n-      left->right = merge(left->right, right);\n+      left->_right = merge(left->_right, right);\n@@ -106,1 +105,1 @@\n-      right->left = merge(left, right->left);\n+      right->_left = merge(left, right->_left);\n@@ -113,1 +112,1 @@\n-  : _priority(p), _key(k), _value(v), left(nullptr), right(nullptr) {\n+  : _priority(p), _key(k), _value(v), _left(nullptr), _right(nullptr) {\n@@ -119,1 +118,1 @@\n-  const V& val() const {\n+  V& val() const {\n@@ -123,0 +122,7 @@\n+  Nd* left() {\n+    return _left;\n+  }\n+  Nd* right() {\n+    return _left;\n+  }\n+\n@@ -132,1 +138,1 @@\n-      return find(node->left, k);\n+      return find(node->_left, k);\n@@ -134,1 +140,1 @@\n-      return find(node->right, k);\n+      return find(node->_right, k);\n@@ -178,2 +184,2 @@\n-      to_delete.push(head->left);\n-      to_delete.push(head->right);\n+      to_delete.push(head->_left);\n+      to_delete.push(head->_right);\n@@ -230,0 +236,44 @@\n+\n+  CTreap* closest_geq(const K& key) {\n+    \/\/ Need to go \"left-ward\" for EQ node, so do a leq search first.\n+    CTreap* leqB = closest_leq(key);\n+    if (leqB != nullptr && leqB->key() == key) {\n+      return leqB;\n+    }\n+    CTreap* gtB = nullptr;\n+    CTreap* head = tree;\n+    while (head != nullptr) {\n+      int cmp_r = addr_cmp(head->key(), key);\n+      if (cmp_r == 0) { \/\/ Exact match\n+        gtB = head;\n+        break; \/\/ Can't become better than that.\n+      }\n+      if (cmp_r > 0) {\n+        \/\/ Found a match, try to find a better one.\n+        gtB = head;\n+        head = head->_left;\n+      } else if (cmp_r < 0) {\n+        head = head->_right;\n+      }\n+    }\n+    return gtB;\n+  }\n+  CTreap* closest_leq(const K& key) {\n+    CTreap* leqA_n = nullptr;\n+    CTreap* head = tree;\n+    while (head != nullptr) {\n+      int cmp_r = addr_cmp(head->key(), key);\n+      if (cmp_r == 0) { \/\/ Exact match\n+        leqA_n = head;\n+        break; \/\/ Can't become better than that.\n+      }\n+      if (cmp_r < 0) {\n+        \/\/ Found a match, try to find a better one.\n+        leqA_n = head;\n+        head = head->_right;\n+      } else if (cmp_r > 0) {\n+        head = head->_left;\n+      }\n+    }\n+    return leqA_n;\n+  }\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":65,"deletions":15,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -27,6 +27,10 @@\n-int VMATree::addr_cmp(size_t a, size_t b) {\n-  if (a < b) return -1;\n-  if (a == b) return 0;\n-  if (a > b) return 1;\n-  ShouldNotReachHere();\n-}\n+VMATree::SummaryDiff VMATree::register_mapping(size_t A, size_t B, StateType state,\n+                                               Metadata& metadata) {\n+  \/\/ AddressState saves the necessary information for performing online summary accounting.\n+  struct AddressState {\n+    size_t address;\n+    NodeState state;\n+    MEMFLAGS flag_out() const {\n+      return state.out.data.flag;\n+    }\n+  };\n@@ -34,5 +38,12 @@\n-VMATree::VTreap* VMATree::closest_geq(size_t B) {\n-  \/\/ Need to go \"left-ward\" for EQ node, so do a leq search first.\n-  VTreap* leqB = closest_leq(B);\n-  if (leqB != nullptr && leqB->key() == B) {\n-    return leqB;\n+  \/\/ We will need the nodes which are closest to A from the left side and closest to B from the right side.\n+  \/\/ Motivating example: reserve(0,100, mtNMT); reserve(50,75, mtTest);\n+  \/\/ This will require the 2nd call to know which region the second reserve 'smashes' a hole into for proper summary accounting.\n+  \/\/ LEQ_A is figured out a bit later on, as we need to find it for other purposes anyway.\n+  bool LEQ_A_found = false;\n+  AddressState LEQ_A;\n+  bool GEQ_B_found = false;\n+  AddressState GEQ_B;\n+  VTreap* geqB_n = tree.closest_geq(B);\n+  if (geqB_n != nullptr) {\n+    GEQ_B = {geqB_n->key(), geqB_n->val()};\n+    GEQ_B_found = true;\n@@ -40,7 +51,20 @@\n-  VTreap* gtB = nullptr;\n-  VTreap* head = tree.tree;\n-  while (head != nullptr) {\n-    int cmp_r = addr_cmp(head->key(), B);\n-    if (cmp_r == 0) { \/\/ Exact match\n-      gtB = head;\n-      break; \/\/ Can't become better than that.\n+\n+  SummaryDiff diff;\n+  NodeState stA{\n+      Arrow{StateType::Released, Metadata{}},\n+      Arrow{              state,   metadata}\n+  };\n+  NodeState stB{\n+      Arrow{              state,   metadata},\n+      Arrow{StateType::Released, Metadata{}}\n+  };\n+  \/\/ First handle A.\n+  \/\/ Find closest node that is LEQ A\n+  VTreap* leqA_n = tree.closest_leq(A);\n+  if (leqA_n == nullptr) {\n+    \/\/ No match.\n+    if (stA.is_noop()) {\n+      \/\/ nothing to do.\n+    } else {\n+      \/\/ Add new node.\n+      tree.upsert(A, stA);\n@@ -48,6 +72,46 @@\n-    if (cmp_r > 0) {\n-      \/\/ Found a match, try to find a better one.\n-      gtB = head;\n-      head = head->left;\n-    } else if (cmp_r < 0) {\n-      head = head->right;\n+  } else {\n+    LEQ_A_found = true;\n+    LEQ_A = AddressState{leqA_n->key(), leqA_n->val()};\n+    \/\/ Unless we know better, let B's outgoing state be the outgoing state of the node at or preceding A.\n+    \/\/ Consider the case where the found node is the start of a region enclosing [A,B)\n+    stB.out = leqA_n->val().out;\n+\n+    \/\/ Direct address match.\n+    if (leqA_n->key() == A) {\n+      \/\/ Take over in state from old address.\n+      stA.in = leqA_n->val().in;\n+\n+      \/\/ We may now be able to merge two regions:\n+      \/\/ If the node's old state matches the new, it becomes a noop. That happens, for example,\n+      \/\/ when expanding a committed area: commit [x1, A); ... commit [A, x3)\n+      \/\/ and the result should be a larger area, [x1, x3). In that case, the middle node (A and le_n)\n+      \/\/ is not needed anymore. So we just remove the old node.\n+      \/\/ We can only do this merge if the metadata is considered equivalent.\n+      stA.out.merge(leqA_n->val().out);\n+      stB.in = stA.out;\n+      if (stA.is_noop()) {\n+        \/\/ invalidates leqA_n\n+        tree.remove(leqA_n->key());\n+        \/\/ Summary accounting: Not needed, we are only expanding\n+      } else {\n+        \/\/ If the state is not matching then we have different operations, such as:\n+        \/\/ reserve [x1, A); ... commit [A, x2); or\n+        \/\/ reserve [x1, A), flag1; ... reserve [A, x2), flag2; or\n+        \/\/ reserve [A, x1), flag1; ... reserve [A, x2), flag2;\n+        \/\/ then we re-use the existing out node, overwriting its old metadata.\n+        leqA_n->val() = stA;\n+      }\n+    } else {\n+      \/\/ The address must be smaller.\n+      assert(A > leqA_n->key(), \"must be\");\n+\n+      \/\/ We add a new node, but only if there would be a state change. If there would not be a\n+      \/\/ state change, we just omit the node.\n+      \/\/ That happens, for example, when reserving within an already reserved region with identical metadata.\n+      stA.in = leqA_n->val().out; \/\/ .. and the region's prior state is the incoming state\n+      if (stA.is_noop()) {\n+        \/\/ Nothing to do.\n+      } else {\n+        \/\/ Add new node.\n+        tree.upsert(A, stA);\n+      }\n@@ -56,2 +120,0 @@\n-  return gtB;\n-}\n@@ -59,8 +121,44 @@\n-VMATree::VTreap* VMATree::closest_leq(size_t A) {\n-  VTreap* leqA_n = nullptr;\n-  VTreap* head = tree.tree;\n-  while (head != nullptr) {\n-    int cmp_r = addr_cmp(head->key(), A);\n-    if (cmp_r == 0) { \/\/ Exact match\n-      leqA_n = head;\n-      break; \/\/ Can't become better than that.\n+  \/\/ Now we handle B.\n+  \/\/ We first search all nodes that are (A, B]. All of these nodes\n+  \/\/ need to be deleted and summary accounted for. The last node before B determines B's outgoing state.\n+  \/\/ If there is no node between A and B, its A's incoming state.\n+  GrowableArrayCHeap<AddressState, mtNMT> to_be_deleted_inbetween_a_b;\n+  bool B_needs_insert = true;\n+\n+  \/\/ Find all nodes between (A, B] and record their addresses. Also update B's\n+  \/\/ outgoing state.\n+  { \/\/ Iterate over each node which is larger than A\n+    GrowableArrayCHeap<VTreap*, mtNMT> to_visit;\n+    to_visit.push(tree.tree);\n+    VTreap* head = nullptr;\n+    while (!to_visit.is_empty()) {\n+      head = to_visit.pop();\n+      if (head == nullptr) continue;\n+\n+      int cmp_A = addr_cmp(head->key(), A);\n+      int cmp_B = addr_cmp(head->key(), B);\n+      if (cmp_B > 0) {\n+        to_visit.push(head->left());\n+      } else if (cmp_A <= 0) {\n+        to_visit.push(head->right());\n+      } else if (cmp_A > 0 && cmp_B <= 0) {\n+        to_visit.push(head->left());\n+        to_visit.push(head->right());\n+\n+        stB.out = head->val().out;\n+        if (cmp_B < 0) {\n+          \/\/ Record all nodes preceding B.\n+          to_be_deleted_inbetween_a_b.push({head->key(), head->val()});\n+        } else if (cmp_B == 0) {\n+          \/\/ Re-purpose B node, unless it would result in a noop node, in\n+          \/\/ which case record old node at B for deletion and summary accounting.\n+          stB.out.merge(head->val().out);\n+          if (stB.is_noop()) {\n+            to_be_deleted_inbetween_a_b.push(AddressState{B, head->val()});\n+          } else {\n+            head->val() = stB;\n+          }\n+          B_needs_insert = false;\n+        } else { \/* Unreachable *\/\n+        }\n+      }\n@@ -68,6 +166,54 @@\n-    if (cmp_r < 0) {\n-      \/\/ Found a match, try to find a better one.\n-      leqA_n = head;\n-      head = head->right;\n-    } else if (cmp_r > 0) {\n-      head = head->left;\n+  }\n+  \/\/ Insert B node if needed\n+  if (B_needs_insert && \/\/ Was not already inserted\n+      (!stB.is_noop() || \/\/ The operation is differing Or\n+       !Metadata::equals(stB.out.data, Metadata{})) \/\/ The metadata was changed from empty earlier\n+  ) {\n+    tree.upsert(B, stB);\n+  }\n+\n+  \/\/ Finally, we need to:\n+  \/\/ 1. Perform summary accounting.\n+  \/\/ 2. Delete all nodes between (A, B]. Including B in the case of a noop.\n+\n+  if (to_be_deleted_inbetween_a_b.length() == 0 && LEQ_A_found && GEQ_B_found &&\n+      GEQ_B.address >= B) {\n+    \/\/ We have smashed a hole in an existing region (or replaced it entirely).\n+    \/\/ LEQ_A - A - B - GEQ_B\n+    auto& rescom = diff.flag[NMTUtil::flag_to_index(LEQ_A.flag_out())];\n+    if (LEQ_A.state.out.type == StateType::Reserved) {\n+      rescom.reserve -= B - A;\n+    } else if (LEQ_A.state.out.type == StateType::Committed) {\n+      rescom.commit -= B - A;\n+      rescom.reserve -= B - A;\n+    }\n+  }\n+\n+  AddressState prev = {A, stA}; \/\/ stA is just filler\n+  MEMFLAGS flag_in = LEQ_A.flag_out();\n+  while (to_be_deleted_inbetween_a_b.length() > 0) {\n+    const AddressState delete_me = to_be_deleted_inbetween_a_b.top();\n+    to_be_deleted_inbetween_a_b.pop();\n+    tree.remove(delete_me.address);\n+    auto& rescom = diff.flag[NMTUtil::flag_to_index(flag_in)];\n+    if (delete_me.state.in.type == StateType::Reserved) {\n+      rescom.reserve -= delete_me.address - prev.address;\n+    } else if (delete_me.state.in.type == StateType::Committed) {\n+      rescom.commit -= delete_me.address - prev.address;\n+      rescom.reserve -= delete_me.address - prev.address;\n+    }\n+    prev = delete_me;\n+    flag_in = delete_me.flag_out();\n+  }\n+  if (prev.address != A && prev.state.out.type != StateType::Released &&\n+      GEQ_B.state.in.type != StateType::Released) {\n+    \/\/ There was some node inside of (A, B) and it is connected to GEQ_B\n+    \/\/ A - prev - B - GEQ_B\n+    \/\/ It might be that prev.address == B == GEQ_B.address, this is fine.\n+    if (prev.state.out.type == StateType::Reserved) {\n+      auto& rescom = diff.flag[NMTUtil::flag_to_index(prev.flag_out())];\n+      rescom.reserve -= B - prev.address;\n+    } else if (prev.state.out.type == StateType::Committed) {\n+      auto& rescom = diff.flag[NMTUtil::flag_to_index(prev.flag_out())];\n+      rescom.commit -= B - prev.address;\n+      rescom.reserve -= B - prev.address;\n@@ -76,1 +222,10 @@\n-  return leqA_n;\n+\n+  \/\/ Finally, we can register the new region [A, B)'s summary data.\n+  auto& rescom = diff.flag[NMTUtil::flag_to_index(metadata.flag)];\n+  if (state == StateType::Reserved) {\n+    rescom.reserve += B - A;\n+  } else if (state == StateType::Committed) {\n+    rescom.commit += B - A;\n+    rescom.reserve += B - A;\n+  }\n+  return diff;\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":196,"deletions":41,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -38,1 +38,7 @@\n-  static int addr_cmp(size_t a, size_t b);\n+  static int addr_cmp(size_t a, size_t b) {\n+    if (a < b) return -1;\n+    if (a == b) return 0;\n+    if (a > b) return 1;\n+    ShouldNotReachHere();\n+  }\n+\n@@ -109,214 +115,1 @@\n-private:\n-  \/\/ Utilities for the register_mapping function\n-\n-  \/\/ Find the closest node which is LEQ (<=) to A.\n-  VTreap* closest_leq(size_t A);\n-  \/\/ Find the closest node which is GEQ (>=) to B.\n-  VTreap* closest_geq(size_t B);\n-\n-public:\n-  template<typename Merge>\n-  SummaryDiff register_mapping(size_t A, size_t B, StateType state, Metadata& metadata, Merge merge) {\n-    \/\/ AddressState saves the necessary information for performing online summary accounting.\n-    struct AddressState {\n-      size_t address;\n-      NodeState state;\n-      MEMFLAGS flag_out() const {\n-        return state.out.data.flag;\n-      }\n-    };\n-\n-    \/\/ We will need the nodes which are closest to A from the left side and closest to B from the right side.\n-    \/\/ Motivating example: reserve(0,100, mtNMT); reserve(50,75, mtTest);\n-    \/\/ This will require the 2nd call to know which region the second reserve 'smashes' a hole into for proper summary accounting.\n-    \/\/ LEQ_A is figured out a bit later on, as we need to find it for other purposes anyway.\n-    bool LEQ_A_found = false;\n-    AddressState LEQ_A;\n-    bool GEQ_B_found = false;\n-    AddressState GEQ_B;\n-    VTreap* geqB_n = closest_geq(B);\n-    if (geqB_n != nullptr) {\n-      GEQ_B = {geqB_n->key(), geqB_n->val()};\n-      GEQ_B_found = true;\n-    }\n-\n-    SummaryDiff diff;\n-    NodeState stA{Arrow{StateType::Released, Metadata{}}, Arrow{state, metadata}};\n-    NodeState stB{Arrow{state, metadata}, Arrow{StateType::Released, Metadata{}}};\n-    \/\/ First handle A.\n-    \/\/ Find closest node that is LEQ A\n-    VTreap* leqA_n = closest_leq(A);\n-    if (leqA_n == nullptr) {\n-      \/\/ No match.\n-      if (stA.is_noop()) {\n-        \/\/ nothing to do.\n-      } else {\n-        \/\/ Add new node.\n-        tree.upsert(A, stA);\n-      }\n-    } else {\n-      LEQ_A_found = true;\n-      LEQ_A = AddressState{leqA_n->key(), leqA_n->val()};\n-      \/\/ Unless we know better, let B's outgoing state be the outgoing state of the node at or preceding A.\n-      \/\/ Consider the case where the found node is the start of a region enclosing [A,B)\n-      stB.out = leqA_n->val().out;\n-\n-      \/\/ Direct address match.\n-      if (leqA_n->key() == A) {\n-        \/\/ Take over in state from old address.\n-        stA.in = leqA_n->val().in;\n-\n-        \/\/ We may now be able to merge two regions:\n-        \/\/ If the node's old state matches the new, it becomes a noop. That happens, for example,\n-        \/\/ when expanding a committed area: commit [x1, A); ... commit [A, x3)\n-        \/\/ and the result should be a larger area, [x1, x3). In that case, the middle node (A and le_n)\n-        \/\/ is not needed anymore. So we just remove the old node.\n-        \/\/ We can only do this merge if the metadata is considered equivalent after merging.\n-        stA.out.merge(leqA_n->val().out);\n-        stB.in = stA.out;\n-        if (stA.is_noop()) {\n-          \/\/ invalidates leqA_n\n-          tree.remove(leqA_n->key());\n-          \/\/ Summary accounting: Not needed, we are only expanding\n-        } else {\n-          \/\/ If the state is not matching then we have different operations, such as:\n-          \/\/ reserve [x1, A); ... commit [A, x2); or\n-          \/\/ reserve [x1, A), flag1; ... reserve [A, x2), flag2; or\n-          \/\/ reserve [A, x1), flag1; ... reserve [A, x2), flag2;\n-          \/\/ then we re-use the existing out node, overwriting its old metadata.\n-          leqA_n->_value = stA;\n-        }\n-      } else {\n-        \/\/ The address must be smaller.\n-        assert(A > leqA_n->key(), \"must be\");\n-\n-        \/\/ We add a new node, but only if there would be a state change. If there would not be a\n-        \/\/ state change, we just omit the node.\n-        \/\/ That happens, for example, when reserving within an already reserved region with identical metadata.\n-        stA.in = leqA_n->val().out; \/\/ .. and the region's prior state is the incoming state\n-        if (stA.is_noop()) {\n-          \/\/ Nothing to do.\n-        } else {\n-          \/\/ Add new node.\n-          tree.upsert(A, stA);\n-        }\n-      }\n-    }\n-\n-    \/\/ Now we handle B.\n-    \/\/ We first search all nodes that are (A, B]. All of these nodes\n-    \/\/ need to be deleted and summary accounted for. The last node before B determines B's outgoing state.\n-    \/\/ If there is no node between A and B, its A's incoming state.\n-    GrowableArrayCHeap<AddressState, mtNMT> to_be_deleted_inbetween_a_b;\n-    bool B_needs_insert = true;\n-\n-    \/\/ Find all nodes between (A, B] and record their addresses. Also update B's\n-    \/\/ outgoing state.\n-    { \/\/ Iterate over each node which is larger than A\n-    GrowableArrayCHeap<VTreap*, mtNMT> to_visit;\n-      to_visit.push(tree.tree);\n-      VTreap* head = nullptr;\n-      while (!to_visit.is_empty()) {\n-        head = to_visit.pop();\n-        if (head == nullptr) continue;\n-\n-        int cmp_A = addr_cmp(head->key(), A);\n-        int cmp_B = addr_cmp(head->key(), B);\n-        if (cmp_B > 0) {\n-          to_visit.push(head->left);\n-        } else if (cmp_A <= 0) {\n-          to_visit.push(head->right);\n-        } else if (cmp_A > 0 && cmp_B <= 0) {\n-          to_visit.push(head->left);\n-          to_visit.push(head->right);\n-\n-          stB.out = head->val().out;\n-          if (cmp_B < 0) {\n-            \/\/ Record all nodes preceding B.\n-            to_be_deleted_inbetween_a_b.push({head->key(), head->val()});\n-          } else if (cmp_B == 0) {\n-            \/\/ Re-purpose B node, unless it would result in a noop node, in\n-            \/\/ which case record old node at B for deletion and summary accounting.\n-            stB.out.merge(head->val().out);\n-            if (stB.is_noop()) {\n-              to_be_deleted_inbetween_a_b.push(AddressState{B, head->val()});\n-            } else {\n-              head->_value = stB;\n-            }\n-            B_needs_insert = false;\n-          } else { \/* Unreachable *\/}\n-        }\n-      }\n-    }\n-    \/\/ Insert B node if needed\n-    if (B_needs_insert    && \/\/ Was not already inserted\n-        (!stB.is_noop()     || \/\/ The operation is differing Or\n-         !Metadata::equals(stB.out.data, Metadata{})) \/\/ The metadata was changed from empty earlier\n-        ) {\n-      tree.upsert(B, stB);\n-    }\n-\n-    \/\/ Finally, we need to:\n-    \/\/ 1. Perform summary accounting.\n-    \/\/ 2. Delete all nodes between (A, B]. Including B in the case of a noop.\n-\n-    if (to_be_deleted_inbetween_a_b.length() == 0\n-        && LEQ_A_found && GEQ_B_found\n-        && GEQ_B.address >= B) {\n-      \/\/ We have smashed a hole in an existing region (or replaced it entirely).\n-      \/\/ LEQ_A - A - B - GEQ_B\n-      auto& rescom = diff.flag[NMTUtil::flag_to_index(LEQ_A.flag_out())];\n-      if (LEQ_A.state.out.type == StateType::Reserved) {\n-        rescom.reserve -= B - A;\n-      } else if (LEQ_A.state.out.type == StateType::Committed) {\n-        rescom.commit -= B - A;\n-        rescom.reserve -= B - A;\n-      }\n-    }\n-\n-    AddressState prev = {A, stA}; \/\/ stA is just filler\n-    MEMFLAGS flag_in = LEQ_A.flag_out();\n-    while (to_be_deleted_inbetween_a_b.length() > 0) {\n-      const AddressState delete_me = to_be_deleted_inbetween_a_b.top();\n-      to_be_deleted_inbetween_a_b.pop();\n-      tree.remove(delete_me.address);\n-      auto& rescom = diff.flag[NMTUtil::flag_to_index(flag_in)];\n-      if (delete_me.state.in.type == StateType::Reserved) {\n-        rescom.reserve -= delete_me.address - prev.address;\n-      } else if (delete_me.state.in.type == StateType::Committed) {\n-        rescom.commit -= delete_me.address - prev.address;\n-        rescom.reserve -= delete_me.address - prev.address;\n-      }\n-      prev = delete_me;\n-      flag_in = delete_me.flag_out();\n-    }\n-    if (prev.address != A &&\n-        prev.state.out.type != StateType::Released &&\n-        GEQ_B.state.in.type != StateType::Released) {\n-      \/\/ There was some node inside of (A, B) and it is connected to GEQ_B\n-      \/\/ A - prev - B - GEQ_B\n-      \/\/ It might be that prev.address == B == GEQ_B.address, this is fine.\n-      if (prev.state.out.type == StateType::Reserved) {\n-        auto& rescom = diff.flag[NMTUtil::flag_to_index(prev.flag_out())];\n-        rescom.reserve -= B - prev.address;\n-      } else if (prev.state.out.type == StateType::Committed) {\n-        auto& rescom = diff.flag[NMTUtil::flag_to_index(prev.flag_out())];\n-        rescom.commit -= B - prev.address;\n-        rescom.reserve -= B - prev.address;\n-      }\n-    }\n-\n-    \/\/ Finally, we can register the new region [A, B)'s summary data.\n-    auto& rescom = diff.flag[NMTUtil::flag_to_index(metadata.flag)];\n-    if (state == StateType::Reserved) {\n-      rescom.reserve += B - A;\n-    } else if (state == StateType::Committed) {\n-      rescom.commit += B - A;\n-      rescom.reserve += B - A;\n-    }\n-    return diff;\n-  }\n-\n-  static Metadata identity_merge(Metadata& merge_into, const Metadata& existent) {\n-    return merge_into;\n-  }\n+  SummaryDiff register_mapping(size_t A, size_t B, StateType state, Metadata& metadata);\n@@ -325,1 +118,1 @@\n-    return register_mapping(from, from + sz, StateType::Reserved, metadata, identity_merge);\n+    return register_mapping(from, from + sz, StateType::Reserved, metadata);\n@@ -329,5 +122,1 @@\n-    return register_mapping(from, from + sz, StateType::Committed, metadata, [](Metadata& merge_into, const Metadata& existent) {\n-      \/\/ The committing API takes no flag, so we inherit the flag of the reserved region.\n-      merge_into.flag = existent.flag;\n-      return merge_into;\n-    });\n+    return register_mapping(from, from + sz, StateType::Committed, metadata);\n@@ -338,7 +127,1 @@\n-    return register_mapping(from, from + sz, StateType::Released, empty, [](Metadata& merge_into, const Metadata& existent) {\n-      \/\/ The releasing API takes no flag, so we inherit the flag of the reserved\/committed region.\n-      \/\/ The releasing API also has no call stack, so we inherit the callstack also.\n-      merge_into.flag = existent.flag;\n-      merge_into.stack_idx = existent.stack_idx;\n-      return merge_into;\n-    });\n+    return register_mapping(from, from + sz, StateType::Released, empty);\n@@ -369,2 +152,2 @@\n-        to_visit.push(head->left);\n-        to_visit.push(head->right);\n+        to_visit.push(head->_left);\n+        to_visit.push(head->_right);\n@@ -372,1 +155,1 @@\n-        to_visit.push(head->right);\n+        to_visit.push(head->_right);\n@@ -380,1 +163,1 @@\n-    in_order_traversal_doer(f, node->left);\n+    in_order_traversal_doer(f, node->_left);\n@@ -382,1 +165,1 @@\n-    in_order_traversal_doer(f, node->right);\n+    in_order_traversal_doer(f, node->_right);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":16,"deletions":233,"binary":false,"changes":249,"status":"modified"}]}