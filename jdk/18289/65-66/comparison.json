{"files":[{"patch":"@@ -59,7 +59,0 @@\n-  \/\/ We will need the nodes which are closest to A from the left side and closest to B from the right side.\n-  \/\/ Motivating example: reserve(0,100, mtNMT); reserve(50,75, mtTest);\n-  \/\/ This example would require the 2nd call to know which region the second reserve 'smashes' a hole into for proper summary accounting.\n-  \/\/ LEQ_A is figured out a bit later on, as we need to find it for other purposes anyway.\n-  bool LEQ_A_found = false;\n-  AddressState LEQ_A;\n-\n@@ -68,0 +61,2 @@\n+  bool LEQ_A_found = false;\n+  AddressState LEQ_A;\n@@ -70,5 +65,2 @@\n-    \/\/ No match.\n-    if (stA.is_noop()) {\n-      \/\/ nothing to do.\n-    } else {\n-      \/\/ Add new node.\n+    \/\/ No match. We add the A node directly, unless it would have no effect.\n+    if (!stA.is_noop()) {\n@@ -162,6 +154,0 @@\n-  AddressState GEQ_B;\n-  TreapNode* geqB_n = tree.closest_geq(B);\n-  if (geqB_n != nullptr) {\n-    GEQ_B = {geqB_n->key(), geqB_n->val()};\n-  }\n-\n@@ -170,1 +156,1 @@\n-    \/\/ LEQ_A - A - B - GEQ_B\n+    \/\/ LEQ_A - A - B - (some node >= B)\n@@ -184,1 +170,0 @@\n-    \/\/ Delete node in (A, B]\n@@ -186,0 +171,1 @@\n+\n@@ -197,5 +183,4 @@\n-  if (prev.address != A && prev.out().type() != StateType::Released &&\n-      GEQ_B.in().type() != StateType::Released) {\n-    \/\/ There was some node inside of (A, B) and it is connected to GEQ_B\n-    \/\/ A - prev - B - GEQ_B\n-    \/\/ It might be that prev.address == B == GEQ_B.address, this is fine.\n+  if (prev.address != A && prev.out().type() != StateType::Released) {\n+    \/\/ The last node wasn't released, so it must be connected to a node outside of (A, B)\n+    \/\/ A - prev - B - (some node >= B)\n+    \/\/ It might be that prev.address == B == (some node >= B), this is fine.\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"}]}