{"files":[{"patch":"@@ -175,1 +175,4 @@\n-    const double expected_maximum_depth = log(this->_node_count+1) * 5;\n+    \/\/ A balanced binary search tree should have a depth on the order of log(N).\n+    \/\/ We take the ceiling of log_2(N + 1) * 2.5 as our maximum bound.\n+    \/\/ For comparison, a RB-tree has a proven max depth of log_2(N + 1) * 2.\n+    const int expected_maximum_depth = ceil((log(this->_node_count+1) \/ log(2)) * 2.5);\n@@ -198,1 +201,2 @@\n-    assert(maximum_depth_found <= (int)expected_maximum_depth, \"depth unexpectedly large\");\n+    assert(maximum_depth_found <= ceil(expected_maximum_depth),\n+           \"depth unexpectedly large, was: %d, expected: %d\", maximum_depth_found, expected_maximum_depth);\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-    EXPECT_EQ(1, count);\n+    EXPECT_EQ(3, count);\n@@ -245,0 +245,1 @@\n+\n@@ -249,1 +250,1 @@\n-    EXPECT_EQ(10, seen.length());\n+    EXPECT_EQ(11, seen.length());\n@@ -320,9 +321,20 @@\n-  TreapCHeap<int, int,Cmp> treap;\n-  \/\/ Really hammer a Treap\n-  int ten_thousand = 10000;\n-  for (int i = 0; i < ten_thousand; i++) {\n-    int r = os::random();\n-    if (r >= 0) {\n-      treap.upsert(i, i);\n-    } else {\n-      treap.remove(i);\n+  { \/\/ Repeatedly verify a treap of moderate size\n+    TreapCHeap<int, int, Cmp> treap;\n+    constexpr const int ten_thousand = 10000;\n+    for (int i = 0; i < ten_thousand; i++) {\n+      int r = os::random();\n+      if (r >= 0) {\n+        treap.upsert(i, i);\n+      } else {\n+        treap.remove(i);\n+      }\n+      verify_it(treap);\n+    }\n+    for (int i = 0; i < ten_thousand; i++) {\n+      int r = os::random();\n+      if (r >= 0) {\n+        treap.upsert(i, i);\n+      } else {\n+        treap.remove(i);\n+      }\n+      verify_it(treap);\n@@ -330,1 +342,0 @@\n-    verify_it(treap);\n@@ -332,6 +343,6 @@\n-  for (int i = 0; i < ten_thousand; i++) {\n-    int r = os::random();\n-    if (r >= 0) {\n-      treap.upsert(i, i);\n-    } else {\n-      treap.remove(i);\n+  { \/\/ Make a very large treap and verify at the end\n+  struct Nothing {};\n+    TreapCHeap<int, Nothing, Cmp> treap;\n+    constexpr const int five_million = 5000000;\n+    for (int i = 0; i < five_million; i++) {\n+      treap.upsert(i, Nothing());\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_treap.cpp","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"}]}