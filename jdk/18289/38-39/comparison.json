{"files":[{"patch":"@@ -49,0 +49,1 @@\n+\n@@ -54,0 +55,1 @@\n+\n@@ -79,1 +81,1 @@\n-template<typename K, typename V, int(*CMP)(K,K), typename Allocator>\n+template<typename K, typename V, int(*CMP)(K,K), typename ALLOCATOR>\n@@ -83,0 +85,1 @@\n+\n@@ -84,0 +87,1 @@\n+\n@@ -86,0 +90,1 @@\n+\n@@ -109,1 +114,3 @@\n-  static node_pair split(Node* head, const K& key, SplitMode mode = LEQ) {\n+  static node_pair split(Node* head, const K& key, SplitMode mode = LEQ DEBUG_ONLY(COMMA int recur_count = 0)) {\n+    assert(recur_count < 200, \"Call-stack depth should never exceed 200\");\n+\n@@ -114,1 +121,1 @@\n-      node_pair p = split(head->_right, key, mode);\n+      node_pair p = split(head->_right, key, mode DEBUG_ONLY(COMMA recur_count + 1));\n@@ -118,1 +125,1 @@\n-      node_pair p = split(head->_left, key, mode);\n+      node_pair p = split(head->_left, key, mode DEBUG_ONLY(COMMA recur_count + 1));\n@@ -125,1 +132,3 @@\n-  static Node* merge(Node* left, Node* right) {\n+  static Node* merge(Node* left, Node* right DEBUG_ONLY(COMMA int recur_count = 0)) {\n+    assert(recur_count < 200, \"Call-stack depth should never exceed 200\");\n+\n@@ -135,1 +144,1 @@\n-      left->_right = merge(left->_right, right);\n+      left->_right = merge(left->_right, right DEBUG_ONLY(COMMA recur_count + 1));\n@@ -143,1 +152,1 @@\n-      right->_left = merge(left, right->_left);\n+      right->_left = merge(left, right->_left DEBUG_ONLY(COMMA recur_count + 1));\n@@ -148,1 +157,1 @@\n-  static Node* find(Node* node, const K& k) {\n+  static Node* find(Node* node, const K& k DEBUG_ONLY(COMMA int recur_count = 0)) {\n@@ -157,1 +166,1 @@\n-      return find(node->_left, k);\n+      return find(node->_left, k DEBUG_ONLY(COMMA recur_count + 1));\n@@ -159,1 +168,1 @@\n-      return find(node->_right, k);\n+      return find(node->_right, k DEBUG_ONLY(COMMA recur_count + 1));\n@@ -181,1 +190,1 @@\n-    void* node_place = Allocator::allocate(sizeof(Node));\n+    void* node_place = ALLOCATOR::allocate(sizeof(Node));\n@@ -196,1 +205,1 @@\n-      Allocator::free(snd_split.right);\n+      ALLOCATOR::free(snd_split.right);\n@@ -212,1 +221,1 @@\n-      Allocator::free(head);\n+      ALLOCATOR::free(head);\n@@ -240,0 +249,1 @@\n+\n@@ -261,1 +271,1 @@\n-class CHeapAllocator {\n+class TreapCHeapAllocator {\n@@ -266,0 +276,1 @@\n+\n@@ -272,1 +283,1 @@\n-using TreapCHeap = Treap<K, V, CMP, CHeapAllocator>;\n+using TreapCHeap = Treap<K, V, CMP, TreapCHeapAllocator>;\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -281,0 +281,17 @@\n+\n+#ifdef ASSERT\n+int cmp(int a, int b) {\n+  return a - b;\n+}\n+TEST_VM_F(VMATreeTest, CallStackDepthTest) {\n+  \/\/ Create a very large treap in order to attempt to hit the stack depth.\n+  TreapCHeap<int, int, cmp> treap;\n+  \/\/ 10**9\n+  int N = 1000000000;\n+  for (int i = 0; i < N; i++) {\n+    \/\/ upsert calls find, merge and split so a good candidate by itself\n+    treap.upsert(i, i);\n+  }\n+  \/\/ We didn't hit an assert? Then we're fine.\n+}\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}