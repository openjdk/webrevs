{"files":[{"patch":"@@ -40,1 +40,1 @@\n-  enum class InOut {\n+  enum class InOut : uint8_t {\n@@ -65,4 +65,21 @@\n-  struct State {\n-    InOut in; \/\/ Previous node active\n-    InOut out; \/\/ This node's state\n-    Metadata metadata;\n+  struct Arrow {\n+    InOut type;\n+    Metadata data;\n+\n+    void lub(const Arrow& b) {\n+      if (this->type == InOut::Released) {\n+        this->data.flag = b.data.flag;\n+        this->data.stack_idx = b.data.stack_idx;\n+      } else if (this->type == InOut::Committed) {\n+        this->data.flag = b.data.flag;\n+      }\n+    }\n+  };\n+  \/\/ A node has an arrow going into it and an arrow going out of it.\n+  struct NodeState {\n+    Arrow in;\n+    Arrow out;\n+\n+    bool is_noop() {\n+      return in.type == out.type && Metadata::equals(in.data, out.data);\n+    }\n@@ -70,3 +87,0 @@\n-  bool is_noop(State st) {\n-    return st.in == st.out;\n-  }\n@@ -74,2 +88,2 @@\n-  using VTreap = TreapNode<size_t, State, addr_cmp>;\n-  TreapCHeap<size_t, State, addr_cmp> tree;\n+  using VTreap = TreapNode<size_t, NodeState, addr_cmp>;\n+  TreapCHeap<size_t, NodeState, addr_cmp> tree;\n@@ -107,3 +121,3 @@\n-      State state;\n-      MEMFLAGS flag() const {\n-        return state.metadata.flag;\n+      NodeState state;\n+      MEMFLAGS flag_out() const {\n+        return state.out.data.flag;\n@@ -128,2 +142,2 @@\n-    State stA{InOut::Released, state, metadata};\n-    State stB{state, InOut::Released, metadata};\n+    NodeState stA{Arrow{InOut::Released, Metadata{}}, Arrow{state, metadata}};\n+    NodeState stB{Arrow{state, metadata}, Arrow{InOut::Released, Metadata{}}};\n@@ -135,1 +149,1 @@\n-      if (is_noop(stA)) {\n+      if (stA.is_noop()) {\n@@ -146,1 +160,0 @@\n-      \/\/ We must also ineherit the metadata.\n@@ -148,1 +161,0 @@\n-      stB.metadata = leqA_n->val().metadata;\n@@ -161,2 +173,2 @@\n-        stA.metadata = merge(stA.metadata, leqA_n->_value.metadata);\n-        if (is_noop(stA) && Metadata::equals(stA.metadata, leqA_n->val().metadata)) {\n+        stA.out.lub(leqA_n->val().out);\n+        if (stA.is_noop()) {\n@@ -181,2 +193,2 @@\n-        stA.in = leqA_n->val().out; \/\/ .. and the region's prior state is the incoming state\n-        if (is_noop(stA) && Metadata::equals(stA.metadata, leqA_n->val().metadata)) {\n+        stA.in.lub(leqA_n->val().out); \/\/ .. and the region's prior state is the incoming state\n+        if (stA.is_noop()) {\n@@ -225,2 +237,2 @@\n-            stB.metadata = merge(stB.metadata, head->_value.metadata);\n-            if (is_noop(stB) && Metadata::equals(stB.metadata, head->val().metadata)) {\n+            stB.out.lub(head->val().out);\n+            if (stB.is_noop()) {\n@@ -238,2 +250,2 @@\n-        (!is_noop(stB)     || \/\/ The operation is differing Or\n-         !Metadata::equals(stB.metadata, Metadata{})) \/\/ The metadata was changed from empty earlier\n+        (!stB.is_noop()     || \/\/ The operation is differing Or\n+         !Metadata::equals(stB.out.data, Metadata{})) \/\/ The metadata was changed from empty earlier\n@@ -253,2 +265,2 @@\n-      auto& rescom = diff.flag[NMTUtil::flag_to_index(LEQ_A.flag())];\n-      if (LEQ_A.state.out == InOut::Reserved) {\n+      auto& rescom = diff.flag[NMTUtil::flag_to_index(LEQ_A.flag_out())];\n+      if (LEQ_A.state.out.type == InOut::Reserved) {\n@@ -256,1 +268,1 @@\n-      } else if (LEQ_A.state.out == InOut::Committed) {\n+      } else if (LEQ_A.state.out.type == InOut::Committed) {\n@@ -263,1 +275,1 @@\n-    MEMFLAGS flag_in = LEQ_A.flag();\n+    MEMFLAGS flag_in = LEQ_A.flag_out();\n@@ -269,1 +281,1 @@\n-      if (delete_me.state.in == InOut::Reserved) {\n+      if (delete_me.state.in.type == InOut::Reserved) {\n@@ -271,1 +283,1 @@\n-      } else if (delete_me.state.in == InOut::Committed) {\n+      } else if (delete_me.state.in.type == InOut::Committed) {\n@@ -276,1 +288,1 @@\n-      flag_in = delete_me.flag();\n+      flag_in = delete_me.flag_out();\n@@ -279,2 +291,2 @@\n-        prev.state.out != InOut::Released &&\n-        GEQ_B.state.in != InOut::Released) {\n+        prev.state.out.type != InOut::Released &&\n+        GEQ_B.state.in.type != InOut::Released) {\n@@ -284,2 +296,2 @@\n-      if (prev.state.out == InOut::Reserved) {\n-        auto& rescom = diff.flag[NMTUtil::flag_to_index(prev.flag())];\n+      if (prev.state.out.type == InOut::Reserved) {\n+        auto& rescom = diff.flag[NMTUtil::flag_to_index(prev.flag_out())];\n@@ -287,2 +299,2 @@\n-      } else if (prev.state.out == InOut::Committed) {\n-        auto& rescom = diff.flag[NMTUtil::flag_to_index(prev.flag())];\n+      } else if (prev.state.out.type == InOut::Committed) {\n+        auto& rescom = diff.flag[NMTUtil::flag_to_index(prev.flag_out())];\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":51,"deletions":39,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -103,3 +103,3 @@\n-      VMATree::State v = x->val();\n-      EXPECT_TRUE((v.in == VMATree::InOut::Released && v.out == VMATree::InOut::Committed) ||\n-                  (v.in == VMATree::InOut::Committed && v.out == VMATree::InOut::Released));\n+      VMATree::NodeState v = x->val();\n+      EXPECT_TRUE((v.in.type == VMATree::InOut::Released && v.out.type == VMATree::InOut::Committed) ||\n+                  (v.in.type == VMATree::InOut::Committed && v.out.type == VMATree::InOut::Released));\n@@ -142,1 +142,1 @@\n-      EXPECT_EQ(x->val().metadata.flag, mtTest);\n+      EXPECT_EQ(x->val().out.data.flag, mtTest);\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}