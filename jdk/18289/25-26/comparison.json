{"files":[{"patch":"@@ -32,1 +32,1 @@\n-    NodeState state;\n+    IntervalChange state;\n@@ -34,1 +34,1 @@\n-      return state.out.data.flag;\n+      return state.out.mdata().flag;\n@@ -53,3 +53,3 @@\n-  NodeState stA{\n-      Arrow{StateType::Released, Metadata{}},\n-      Arrow{              state,   metadata}\n+  IntervalChange stA{\n+      IntervalState{StateType::Released, Metadata{}},\n+      IntervalState{              state,   metadata}\n@@ -57,3 +57,3 @@\n-  NodeState stB{\n-      Arrow{              state,   metadata},\n-      Arrow{StateType::Released, Metadata{}}\n+  IntervalChange stB{\n+      IntervalState{              state,   metadata},\n+      IntervalState{StateType::Released, Metadata{}}\n@@ -176,1 +176,1 @@\n-       !Metadata::equals(stB.out.data, Metadata{})) \/\/ The metadata was changed from empty earlier\n+       !Metadata::equals(stB.out.mdata(), Metadata{})) \/\/ The metadata was changed from empty earlier\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,0 +36,5 @@\n+\/\/ A VMATree stores a sequence of points on the natural number line.\n+\/\/ Each of these points stores information about a state change.\n+\/\/ For example, the state may go from released memory to committed memory,\n+\/\/ or from committed memory of a certain MEMFLAGS to committed memory of a different MEMFLAGS.\n+\/\/ The set of points is stored in a balanced binary tree for efficient querying and updating.\n@@ -66,2 +71,1 @@\n-  struct Arrow {\n-    StateType type;\n+  struct IntervalState {\n@@ -69,0 +73,1 @@\n+    StateType type;\n@@ -70,1 +75,1 @@\n-    void merge(const Arrow& b) {\n+    void merge(const IntervalState& b) {\n@@ -80,0 +85,3 @@\n+    Metadata mdata() const {\n+      return data;\n+    }\n@@ -82,4 +90,5 @@\n-  \/\/ A node has an arrow going into it and an arrow going out of it.\n-  struct NodeState {\n-    Arrow in;\n-    Arrow out;\n+  \/\/ An IntervalChange indicates a change in state between two intervals. The incoming state\n+  \/\/ is denoted by in, and the outgoing state is denoted by out.\n+  struct IntervalChange {\n+    IntervalState in;\n+    IntervalState out;\n@@ -93,2 +102,2 @@\n-  using VTreap = TreapNode<size_t, NodeState, addr_cmp>;\n-  TreapCHeap<size_t, NodeState, addr_cmp> tree;\n+  using VTreap = TreapNode<size_t, IntervalChange, addr_cmp>;\n+  TreapCHeap<size_t, IntervalChange, addr_cmp> tree;\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -21,4 +21,4 @@\n-  NativeCallStack stack1 = make_stack(size_t{0x00007bece59b89ac},\n-                                      size_t{0x00007bece59b1fdd},\n-                                      size_t{0x00007bece59b2997},\n-                                      size_t{0x00007bece59b2add});\n+  NativeCallStack stack1 = make_stack(size_t{0x7bece59b89ac},\n+                                      size_t{0x7bece59b1fdd},\n+                                      size_t{0x7bece59b2997},\n+                                      size_t{0x7bece59b2add});\n@@ -103,1 +103,1 @@\n-      VMATree::NodeState& v = x->val();\n+      VMATree::IntervalChange& v = x->val();\n@@ -144,1 +144,1 @@\n-        EXPECT_EQ(x->val().out.data.flag, mtTest);\n+        EXPECT_EQ(x->val().out.mdata().flag, mtTest);\n@@ -181,1 +181,1 @@\n-        EXPECT_EQ(mtNMT, x->val().out.data.flag);\n+        EXPECT_EQ(mtNMT, x->val().out.mdata().flag);\n@@ -184,1 +184,1 @@\n-        EXPECT_EQ(mtNMT, x->val().in.data.flag);\n+        EXPECT_EQ(mtNMT, x->val().in.mdata().flag);\n@@ -200,1 +200,1 @@\n-        EXPECT_EQ(x->val().out.data.flag, mtTest);\n+        EXPECT_EQ(x->val().out.mdata().flag, mtTest);\n@@ -203,1 +203,1 @@\n-        EXPECT_EQ(x->val().in.data.flag, mtTest);\n+        EXPECT_EQ(x->val().in.mdata().flag, mtTest);\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}