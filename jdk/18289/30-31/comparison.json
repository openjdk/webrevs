{"files":[{"patch":"@@ -54,2 +54,2 @@\n-    assert(pval.out.type == cval.in.type, \"must be\");\n-    if (pval.out.type == VMATree::StateType::Reserved) {\n+    assert(pval.out.type() == cval.in.type(), \"must be\");\n+    if (pval.out.type() == VMATree::StateType::Reserved) {\n@@ -61,2 +61,2 @@\n-                       NMTUtil::flag_to_name(pval.out.data.flag));\n-      pval.out.data.stack_idx.stack().print_on(stream, 4);\n+                       NMTUtil::flag_to_name(pval.out.metadata().flag));\n+      pval.out.metadata().stack_idx.stack().print_on(stream, 4);\n","filename":"src\/hotspot\/share\/nmt\/nmtMemoryFileTracker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include <stddef.h>\n@@ -75,1 +74,1 @@\n-         (CMP(head->_key, key) < 0 && mode == LT) ) {\n+         (CMP(head->_key, key) < 0  && mode == LT) ) {\n@@ -78,1 +77,1 @@\n-      return {head, p.right};\n+      return nd_pair{head, p.right};\n@@ -82,1 +81,1 @@\n-      return {p.left, head};\n+      return nd_pair{p.left, head};\n@@ -177,1 +176,1 @@\n-  static Nd* delete_all(Nd* tree, Free free) {\n+  static Nd* remove_all(Nd* tree, Free free) {\n@@ -197,1 +196,1 @@\n-  CTreap* tree;\n+  CTreap* root;\n@@ -199,0 +198,1 @@\n+\n@@ -200,1 +200,1 @@\n-  TreapCHeap(uint64_t seed = 1234) : tree(nullptr), prng_seed(seed) {\n+  TreapCHeap(uint64_t seed = 1234) : root(nullptr), prng_seed(seed) {\n@@ -217,1 +217,1 @@\n-    tree = CTreap::upsert(tree, k, v, [&](const K& k, const V& v) {\n+    root = CTreap::upsert(root, k, v, [&](const K& k, const V& v) {\n@@ -226,1 +226,1 @@\n-    tree = CTreap::remove(tree, k, [](void* ptr) {\n+    root = CTreap::remove(root, k, [](void* ptr) {\n@@ -232,1 +232,1 @@\n-    tree = CTreap::delete_all(tree, [](void* ptr){\n+    root = CTreap::remove_all(root, [](void* ptr){\n@@ -244,1 +244,1 @@\n-    CTreap* head = tree;\n+    CTreap* head = root;\n@@ -263,1 +263,1 @@\n-    CTreap* head = tree;\n+    CTreap* head = root;\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -89,2 +89,0 @@\n-      \/\/ We can only do this merge if the metadata is considered equivalent.\n-      stA.out.merge(leqA_n->val().out);\n@@ -132,1 +130,1 @@\n-    to_visit.push(tree.tree);\n+    to_visit.push(tree.root);\n@@ -158,1 +156,0 @@\n-          stB.out.merge(head->val().out);\n@@ -190,1 +187,1 @@\n-    if (LEQ_A.state.out.type == StateType::Reserved) {\n+    if (LEQ_A.state.out.type() == StateType::Reserved) {\n@@ -192,1 +189,1 @@\n-    } else if (LEQ_A.state.out.type == StateType::Committed) {\n+    } else if (LEQ_A.state.out.type() == StateType::Committed) {\n@@ -205,1 +202,1 @@\n-    if (delete_me.state.in.type == StateType::Reserved) {\n+    if (delete_me.state.in.type() == StateType::Reserved) {\n@@ -207,1 +204,1 @@\n-    } else if (delete_me.state.in.type == StateType::Committed) {\n+    } else if (delete_me.state.in.type() == StateType::Committed) {\n@@ -214,2 +211,2 @@\n-  if (prev.address != A && prev.state.out.type != StateType::Released &&\n-      GEQ_B.state.in.type != StateType::Released) {\n+  if (prev.address != A && prev.state.out.type() != StateType::Released &&\n+      GEQ_B.state.in.type() != StateType::Released) {\n@@ -219,1 +216,1 @@\n-    if (prev.state.out.type == StateType::Reserved) {\n+    if (prev.state.out.type() == StateType::Reserved) {\n@@ -222,1 +219,1 @@\n-    } else if (prev.state.out.type == StateType::Committed) {\n+    } else if (prev.state.out.type() == StateType::Committed) {\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -72,2 +72,12 @@\n-    StateType type;\n-    Metadata data;\n+  private:\n+    \/\/ Store the type and flag as two bytes\n+    uint8_t type_flag[2];\n+    NativeCallStackStorage::StackIndex sidx;\n+\n+  public:\n+    IntervalState() : type_flag{0,0}, sidx() {}\n+    IntervalState(StateType type, Metadata data) {\n+      type_flag[0] = static_cast<uint8_t>(type);\n+      type_flag[1] = static_cast<uint8_t>(data.flag);\n+      data.stack_idx = sidx;\n+    }\n@@ -75,5 +85,6 @@\n-    void merge(const IntervalState& b) {\n-      if (this->type == StateType::Released) {\n-        this->data.flag = b.data.flag;\n-        this->data.stack_idx = b.data.stack_idx;\n-      }\n+    StateType type() const {\n+      return static_cast<StateType>(type_flag[0]);\n+    }\n+\n+    MEMFLAGS flag() const {\n+      return static_cast<MEMFLAGS>(type_flag[1]);\n@@ -83,1 +94,1 @@\n-      return data;\n+      return Metadata{sidx, flag()};\n@@ -94,2 +105,2 @@\n-      return (in.type == StateType::Released && out.type == StateType::Released) ||\n-             (in.type == out.type && Metadata::equals(in.data, out.data));\n+      return (in.type() == StateType::Released && out.type() == StateType::Released) ||\n+             (in.type() == out.type() && Metadata::equals(in.metadata(), out.metadata()));\n@@ -101,0 +112,1 @@\n+\n@@ -113,1 +125,1 @@\n-        flag[i] = {0, 0};\n+        flag[i] = SingleDiff{0, 0};\n@@ -139,1 +151,1 @@\n-    to_visit.push(tree.tree);\n+    to_visit.push(tree.root);\n@@ -173,1 +185,1 @@\n-    in_order_traversal_doer(f, tree.tree);\n+    in_order_traversal_doer(f, tree.root);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n@@ -4,1 +28,0 @@\n-#include \"nmt\/memTracker.hpp\"\n@@ -11,1 +34,1 @@\n-    return tree.tree.tree;\n+    return tree.tree.root;\n@@ -13,0 +36,1 @@\n+\n@@ -21,0 +45,1 @@\n+\n@@ -106,2 +131,2 @@\n-      EXPECT_TRUE((v.in.type == VMATree::StateType::Released && v.out.type == VMATree::StateType::Committed) ||\n-                  (v.in.type == VMATree::StateType::Committed && v.out.type == VMATree::StateType::Released));\n+      EXPECT_TRUE((v.in.type() == VMATree::StateType::Released && v.out.type() == VMATree::StateType::Committed) ||\n+                  (v.in.type() == VMATree::StateType::Committed && v.out.type() == VMATree::StateType::Released));\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"}]}