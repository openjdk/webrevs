{"files":[{"patch":"@@ -46,2 +46,2 @@\n-  VMATree::Metadata metadata(sidx, flag);\n-  VMATree::SummaryDiff diff = device->_tree.reserve_mapping(offset, size, metadata);\n+  VMATree::RegionData regiondata(sidx, flag);\n+  VMATree::SummaryDiff diff = device->_tree.reserve_mapping(offset, size, regiondata);\n@@ -72,4 +72,2 @@\n-    const VMATree::IntervalChange& pval = prev->val();\n-    const VMATree::IntervalChange& cval = current->val();\n-    assert(pval.out.type() == cval.in.type(), \"must be\");\n-    if (pval.out.type() == VMATree::StateType::Reserved) {\n+    assert(prev->val().out.type() == current->val().in.type(), \"must be\");\n+    if (prev->val().out.type() == VMATree::StateType::Reserved) {\n@@ -82,2 +80,2 @@\n-                       NMTUtil::flag_to_name(pval.out.flag()));\n-      _stack_storage.get(pval.out.stack()).print_on(stream, 4);\n+                       NMTUtil::flag_to_name(prev->val().out.flag()));\n+      _stack_storage.get(prev->val().out.stack()).print_on(stream, 4);\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  friend class TreapTest;\n@@ -84,0 +85,1 @@\n+  ALLOCATOR _allocator;\n@@ -158,1 +160,3 @@\n-    if (COMPARATOR::cmp(node->_key, k) == 0) { \/\/ EQ\n+    int key_cmp_k = COMPARATOR::cmp(node->key(), k);\n+\n+    if (key_cmp_k == 0) { \/\/ key EQ k\n@@ -162,4 +166,4 @@\n-    if (COMPARATOR::cmp(node->_key, k) <= 0) { \/\/ LEQ\n-      return find(node->_left, k DEBUG_ONLY(COMMA recur_count + 1));\n-    } else {\n-      return find(node->_right, k DEBUG_ONLY(COMMA recur_count + 1));\n+    if (key_cmp_k < 0) { \/\/ key LT k\n+      return find(node->right(), k DEBUG_ONLY(COMMA recur_count + 1));\n+    } else { \/\/ key GT k\n+      return find(node->left(), k DEBUG_ONLY(COMMA recur_count + 1));\n@@ -171,1 +175,1 @@\n-    constexpr const double expected_maximum_depth = log(this->_node_count+1) * 5;\n+    const double expected_maximum_depth = log(this->_node_count+1) * 5;\n@@ -189,1 +193,1 @@\n-      assert(head.parent_prio <= head.n->_priority, \"broken priority invariant\");\n+      assert(head.parent_prio >= head.n->_priority, \"broken priority invariant\");\n@@ -194,1 +198,1 @@\n-    assert(maximum_depth_found > (int)expected_maximum_depth, \"depth unexpectedly large\");\n+    assert(maximum_depth_found <= (int)expected_maximum_depth, \"depth unexpectedly large\");\n@@ -218,1 +222,2 @@\n-  : _root(nullptr),\n+  : _allocator(),\n+    _root(nullptr),\n@@ -227,1 +232,1 @@\n-    assert(verify_self(), \"invariant\");\n+    verify_self();\n@@ -237,1 +242,1 @@\n-    void* node_place = ALLOCATOR::allocate(sizeof(TreapNode));\n+    void* node_place = _allocator.allocate(sizeof(TreapNode));\n@@ -248,1 +253,1 @@\n-    assert(verify_self(), \"invariant\");\n+    verify_self();\n@@ -258,1 +263,1 @@\n-      ALLOCATOR::free(second_split.right);\n+      _allocator.free(second_split.right);\n@@ -275,1 +280,1 @@\n-      ALLOCATOR::free(head);\n+      _allocator.free(head);\n@@ -349,1 +354,1 @@\n-  static void* allocate(size_t sz) {\n+  void* allocate(size_t sz) {\n@@ -357,1 +362,1 @@\n-  static void free(void* ptr) {\n+  void free(void* ptr) {\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,3 +30,2 @@\n-#ifdef ASSERT\n-\n-TEST_VM(NmtTreap, VerifyItThroughStressTest) {\n+class TreapTest : public testing::Test {\n+public:\n@@ -39,0 +37,149 @@\n+\n+#ifdef ASSERT\n+  template<typename K, typename V, typename CMP, typename ALLOC>\n+  void verify_it(Treap<K, V, CMP, ALLOC>& t) {\n+    t.verify_self();\n+  }\n+#endif \/\/ ASSERT\n+\n+public:\n+  void inserting_duplicates_results_in_one_value() {\n+    constexpr const int up_to = 10;\n+    GrowableArrayCHeap<int, mtTest> nums_seen(up_to, up_to, 0);\n+    TreapCHeap<int, int, Cmp> treap;\n+\n+    for (int i = 0; i < up_to; i++) {\n+      treap.upsert(i, i);\n+      treap.upsert(i, i);\n+      treap.upsert(i, i);\n+      treap.upsert(i, i);\n+      treap.upsert(i, i);\n+    }\n+\n+    treap.visit_in_order([&](TreapCHeap<int, int, Cmp>::TreapNode* node) {\n+      nums_seen.at(node->key())++;\n+    });\n+    for (int i = 0; i < up_to; i++) {\n+      EXPECT_EQ(1, nums_seen.at(i));\n+    }\n+  }\n+\n+  void treap_ought_not_leak() {\n+    struct LeakCheckedAllocator {\n+      struct Check {\n+        void* ptr;\n+        bool released;\n+\n+        Check(void* ptr)\n+          : ptr(ptr),\n+            released(false) {\n+        }\n+\n+        Check()\n+          : ptr(nullptr),\n+            released(false) {}\n+\n+        void release() {\n+          released = true;\n+        }\n+      };\n+      GrowableArrayCHeap<Check, mtTest> allocations;\n+\n+      LeakCheckedAllocator()\n+        : allocations() {\n+      }\n+\n+      void* allocate(size_t sz) {\n+        void* allocation = os::malloc(sz, mtTest);\n+        if (allocation == nullptr) {\n+          vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, \"treap failed allocation\");\n+        }\n+        allocations.push(Check(allocation));\n+        return allocation;\n+      }\n+\n+      void free(void* ptr) {\n+        for (int i = 0; i < allocations.length(); i++) {\n+          Check& c = allocations.at(i);\n+          EXPECT_NE(nullptr, c.ptr);\n+          if (c.ptr == ptr) {\n+            c.release();\n+          }\n+        }\n+        os::free(ptr);\n+      }\n+    };\n+\n+    constexpr const int up_to = 10;\n+    {\n+      Treap<int, int, Cmp, LeakCheckedAllocator> treap;\n+      for (int i = 0; i < 10; i++) {\n+        treap.upsert(i, i);\n+      }\n+      for (int i = 0; i < 10; i++) {\n+        treap.remove(i);\n+      }\n+      EXPECT_EQ(10, treap._allocator.allocations.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_TRUE(treap._allocator.allocations.at(i).released);\n+      }\n+    }\n+\n+    {\n+      Treap<int, int, Cmp, LeakCheckedAllocator> treap;\n+      for (int i = 0; i < 10; i++) {\n+        treap.upsert(i, i);\n+      }\n+      treap.remove_all();\n+      EXPECT_EQ(10, treap._allocator.allocations.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_TRUE(treap._allocator.allocations.at(i).released);\n+      }\n+    }\n+  }\n+};\n+\n+TEST_VM_F(TreapTest, InsertingDuplicatesResultsInOneValue) {\n+  this->inserting_duplicates_results_in_one_value();\n+}\n+\n+TEST_VM_F(TreapTest, TreapOughtNotLeak) {\n+  this->treap_ought_not_leak();\n+}\n+\n+TEST_VM_F(TreapTest, TestVisitInRange) {\n+  TreapCHeap<int, int, Cmp> treap;\n+  using Node = TreapCHeap<int, int, Cmp>::TreapNode;\n+\n+  treap.visit_range_in_order(0, 100, [&](Node* x) {\n+    EXPECT_TRUE(false) << \"Empty treap has no nodes to visit\";\n+  });\n+\n+  \/\/ Single-element set\n+  treap.upsert(1, 0);\n+  int count = 0;\n+  treap.visit_range_in_order(0, 100, [&](Node* x) {\n+    count++;\n+  });\n+  EXPECT_EQ(1, count);\n+\n+  \/\/ Add an element outside of the range that should not be visited on the right side and\n+  \/\/ one on the left side.\n+  treap.upsert(101, 0);\n+  treap.upsert(-1, 0);\n+  count = 0;\n+  treap.visit_range_in_order(0, 100, [&](Node* x) {\n+    count++;\n+  });\n+  EXPECT_EQ(1, count);\n+\n+  \/\/ Visiting empty range [0, 0) == {}\n+  treap.upsert(0, 0); \/\/ This node should not be visited.\n+  treap.visit_range_in_order(0, 0, [&](Node* x) {\n+    EXPECT_TRUE(false) << \"Empty visiting range should not visit any node\";\n+  });\n+}\n+\n+#ifdef ASSERT\n+\n+TEST_VM_F(TreapTest, VerifyItThroughStressTest) {\n@@ -49,0 +196,1 @@\n+    verify_it(treap);\n@@ -57,0 +205,1 @@\n+    verify_it(treap);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_treap.cpp","additions":153,"deletions":4,"binary":false,"changes":157,"status":"modified"}]}