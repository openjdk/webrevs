{"files":[{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-#ifdef ASSERT\n-\n-#include \"nmt\/nmtTreap.hpp\"\n-#include <math.h>\n-\n-template<typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-bool Treap<K,V,COMPARATOR,ALLOCATOR>::verify_self() {\n-  double expected_maximum_depth = log(this->_node_count) * 3;\n-  \/\/ Find the maximum depth through DFS.\n-  int maximum_depth_found = 0;\n-\n-  struct DFS {\n-    int depth;\n-    uint64_t parent_prio;\n-    TreapNode* n;\n-  };\n-  GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n-  uint64_t positive_infinity = 0xFFFFFFFFFFFFFFFF;\n-\n-  to_visit.push({0, positive_infinity, this->_root});\n-  while (!to_visit.is_empty()) {\n-    DFS head = to_visit.pop();\n-    if (head.n == nullptr) continue;\n-    if (maximum_depth_found < head.depth) {\n-      maximum_depth_found = head.depth;\n-    }\n-    if (head.parent_prio < head.n->_priority) {\n-      return false;\n-    }\n-    to_visit.push({head.depth+1, head.n->_priority, head.n->left()});\n-    to_visit.push({head.depth+1, head.n->_priority, head.n->right()});\n-  }\n-  if (maximum_depth_found > (int)expected_maximum_depth) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.cpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -170,1 +170,31 @@\n-  bool verify_self();\n+  bool verify_self() {\n+    double expected_maximum_depth = log(this->_node_count) * 3;\n+    \/\/ Find the maximum depth through DFS.\n+    int maximum_depth_found = 0;\n+\n+    struct DFS {\n+      int depth;\n+      uint64_t parent_prio;\n+      TreapNode* n;\n+    };\n+    GrowableArrayCHeap<DFS, mtNMT> to_visit;\n+    uint64_t positive_infinity = 0xFFFFFFFFFFFFFFFF;\n+\n+    to_visit.push({0, positive_infinity, this->_root});\n+    while (!to_visit.is_empty()) {\n+      DFS head = to_visit.pop();\n+      if (head.n == nullptr) continue;\n+      if (maximum_depth_found < head.depth) {\n+        maximum_depth_found = head.depth;\n+      }\n+      if (head.parent_prio < head.n->_priority) {\n+        return false;\n+      }\n+      to_visit.push({head.depth + 1, head.n->_priority, head.n->left()});\n+      to_visit.push({head.depth + 1, head.n->_priority, head.n->right()});\n+    }\n+    if (maximum_depth_found > (int)expected_maximum_depth) {\n+      return false;\n+    }\n+    return true;\n+  }\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"}]}