{"files":[{"patch":"@@ -47,2 +47,3 @@\n-  template<typename InnerK, typename InnerV, int(*CMPP)(InnerK,InnerK)>\n-  friend class TreapCHeap;\n+  template<typename InnerK, typename InnerV, int(*CMPP)(InnerK,InnerK), typename Allocator>\n+  friend class Treap;\n+  using Node = TreapNode<K,V,CMP>;\n@@ -53,3 +54,2 @@\n-  using Nd = TreapNode<K,V,CMP>;\n-  Nd* _left;\n-  Nd* _right;\n+  Node* _left;\n+  Node* _right;\n@@ -57,3 +57,43 @@\n-  struct nd_pair {\n-    Nd* left;\n-    Nd* right;\n+public:\n+  TreapNode(const K& k, const V& v, uint64_t p)\n+  : _priority(p), _key(k), _value(v), _left(nullptr), _right(nullptr) {\n+  }\n+\n+  const K& key() const {\n+    return _key;\n+  }\n+\n+  V& val() {\n+    return _value;\n+  }\n+\n+  Node* left() const {\n+    return _left;\n+  }\n+\n+  Node* right() const {\n+    return _right;\n+  }\n+};\n+\n+template<typename K, typename V, int(*CMP)(K,K), typename Allocator>\n+class Treap {\n+  friend class VMATree;\n+  friend class VMATreeTest;\n+  using Node = TreapNode<K, V, CMP>;\n+  Node* _root;\n+  uint64_t _prng_seed;\n+private:\n+  uint64_t prng_next() {\n+    \/\/ Taken directly off of JFRPrng\n+    static const uint64_t PrngMult = 0x5DEECE66DLL;\n+    static const uint64_t PrngAdd = 0xB;\n+    static const uint64_t PrngModPower = 48;\n+    static const uint64_t PrngModMask = (static_cast<uint64_t>(1) << PrngModPower) - 1;\n+    _prng_seed = (PrngMult * _prng_seed + PrngAdd) & PrngModMask;\n+    return _prng_seed;\n+  }\n+\n+  struct node_pair {\n+    Node* left;\n+    Node* right;\n@@ -69,1 +109,1 @@\n-  static nd_pair split(Nd* head, const K& key, SplitMode mode = LEQ) {\n+  static node_pair split(Node* head, const K& key, SplitMode mode = LEQ) {\n@@ -73,3 +113,2 @@\n-    if ( (CMP(head->_key, key) <= 0 && mode == LEQ) ||\n-         (CMP(head->_key, key) < 0  && mode == LT) ) {\n-      nd_pair p = split(head->_right, key, mode);\n+    if ((CMP(head->_key, key) <= 0 && mode == LEQ) || (CMP(head->_key, key) < 0 && mode == LT)) {\n+      node_pair p = split(head->_right, key, mode);\n@@ -77,1 +116,1 @@\n-      return nd_pair{head, p.right};\n+      return node_pair{head, p.right};\n@@ -79,1 +118,1 @@\n-      nd_pair p = split(head->_left, key, mode);\n+      node_pair p = split(head->_left, key, mode);\n@@ -81,1 +120,1 @@\n-      return nd_pair{p.left, head};\n+      return node_pair{p.left, head};\n@@ -86,1 +125,1 @@\n-  static Nd* merge(Nd* left, Nd* right) {\n+  static Node* merge(Node* left, Node* right) {\n@@ -109,20 +148,1 @@\n-public:\n-  TreapNode(const K& k, const V& v, uint64_t p)\n-  : _priority(p), _key(k), _value(v), _left(nullptr), _right(nullptr) {\n-  }\n-\n-  const K& key() const {\n-    return _key;\n-  }\n-  V& val() {\n-    return _value;\n-  }\n-\n-  Nd* left() const {\n-    return _left;\n-  }\n-  Nd* right() const {\n-    return _right;\n-  }\n-\n-  static Nd* find(Nd* node, const K& k) {\n+  static Node* find(Node* node, const K& k) {\n@@ -142,0 +162,8 @@\n+public:\n+  Treap(uint64_t seed = 1234)\n+    : _root(nullptr),\n+      _prng_seed(seed) {\n+  }\n+  ~Treap() {\n+    this->remove_all();\n+  }\n@@ -143,2 +171,1 @@\n-  template<typename MakeNode>\n-  static Nd* upsert(Nd* head, const K& k, const V& v, MakeNode make_node) {\n+  void upsert(const K& k, const V& v) {\n@@ -146,2 +173,2 @@\n-    nd_pair split = Nd::split(head, k);\n-    Nd* found = find(split.left, k);\n+    node_pair split = Node::split(this->_root, k);\n+    Node* found = find(split.left, k);\n@@ -151,1 +178,1 @@\n-      return merge(split.left, split.right);\n+      this->_root = merge(split.left, split.right);\n@@ -154,1 +181,3 @@\n-    Nd* node = make_node(k, v);\n+    Node* node = Allocator::allocate(sizeof(Node));\n+    uint64_t prio = prng_next();\n+    new (node) Node(k, v, prio);\n@@ -156,1 +185,1 @@\n-    return merge(merge(split.left, node), split.right);\n+    this->_root = merge(merge(split.left, node), split.right);\n@@ -159,2 +188,1 @@\n-  template<typename Free>\n-  static Nd* remove(Nd *head, const K& k, Free free) {\n+  void remove(const K& k) {\n@@ -162,1 +190,1 @@\n-    nd_pair fst_split = split(head, k, LEQ);\n+    node_pair fst_split = split(this->_root, k, LEQ);\n@@ -164,1 +192,1 @@\n-    nd_pair snd_split = split(fst_split.left, k, LT);\n+    node_pair snd_split = split(fst_split.left, k, LT);\n@@ -168,1 +196,1 @@\n-      free(snd_split.right);\n+      Allocator::free(snd_split.right);\n@@ -171,1 +199,1 @@\n-    return merge(snd_split.left, fst_split.right);\n+    this->_root = merge(snd_split.left, fst_split.right);\n@@ -175,4 +203,3 @@\n-  template<typename Free>\n-  static Nd* remove_all(Nd* tree, Free free) {\n-    GrowableArrayCHeap<Nd*, mtNMT> to_delete;\n-    to_delete.push(tree);\n+  void remove_all() {\n+    GrowableArrayCHeap<Node*, mtNMT> to_delete;\n+    to_delete.push(this->_root);\n@@ -181,1 +208,1 @@\n-      Nd* head = to_delete.pop();\n+      Node* head = to_delete.pop();\n@@ -185,1 +212,1 @@\n-      free(head);\n+      Allocator::free(head);\n@@ -187,1 +214,0 @@\n-    return nullptr;\n@@ -189,9 +215,0 @@\n-};\n-\n-template<typename K, typename V, int(*CMP)(K,K)>\n-class TreapCHeap {\n-  friend class VMATree;\n-  friend class VMATreeTest;\n-  using CTreap = TreapNode<K, V, CMP>;\n-  CTreap* root;\n-  uint64_t prng_seed;\n@@ -199,39 +216,1 @@\n-public:\n-  TreapCHeap(uint64_t seed = 1234) : root(nullptr), prng_seed(seed) {\n-  }\n-  ~TreapCHeap() {\n-    this->remove_all();\n-  }\n-\n-  uint64_t prng_next() {\n-    \/\/ Taken directly off of JFRPrng\n-    static const uint64_t PrngMult = 0x5DEECE66DLL;\n-    static const uint64_t PrngAdd = 0xB;\n-    static const uint64_t PrngModPower = 48;\n-    static const uint64_t PrngModMask = (static_cast<uint64_t>(1) << PrngModPower) - 1;\n-    prng_seed = (PrngMult * prng_seed + PrngAdd) & PrngModMask;\n-    return prng_seed;\n-  }\n-\n-  void upsert(const K& k, const V& v) {\n-    root = CTreap::upsert(root, k, v, [&](const K& k, const V& v) {\n-      uint64_t rand = this->prng_next();\n-      void* place = os::malloc(sizeof(CTreap), mtNMT);\n-      new (place) CTreap(k, v, rand);\n-      return (CTreap*)place;\n-    });\n-  }\n-\n-  void remove(const K& k) {\n-    root = CTreap::remove(root, k, [](void* ptr) {\n-      os::free(ptr);\n-    });\n-  }\n-\n-  void remove_all() {\n-    root = CTreap::remove_all(root, [](void* ptr){\n-      os::free(ptr);\n-    });\n-  }\n-\n-  CTreap* closest_geq(const K& key) {\n+  Node* closest_geq(const K& key) {\n@@ -239,1 +218,1 @@\n-    CTreap* leqB = closest_leq(key);\n+    Node* leqB = closest_leq(key);\n@@ -243,2 +222,2 @@\n-    CTreap* gtB = nullptr;\n-    CTreap* head = root;\n+    Node* gtB = nullptr;\n+    Node* head = _root;\n@@ -261,3 +240,3 @@\n-  CTreap* closest_leq(const K& key) {\n-    CTreap* leqA_n = nullptr;\n-    CTreap* head = root;\n+  Node* closest_leq(const K& key) {\n+    Node* leqA_n = nullptr;\n+    Node* head = _root;\n@@ -282,0 +261,12 @@\n+class CHeapAllocator {\n+  static void* allocate(size_t sz) {\n+    return os::malloc(sz, mtNMT);\n+  }\n+  static void free(void* ptr) {\n+    os::free(ptr);\n+  }\n+};\n+\n+template<typename K, typename V, int (*CMP)(K, K)>\n+using TreapCHeap = Treap<K, V, CMP, CHeapAllocator>;\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":101,"deletions":110,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-    to_visit.push(tree.root);\n+    to_visit.push(tree._root);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-    to_visit.push(tree.root);\n+    to_visit.push(tree._root);\n@@ -185,1 +185,1 @@\n-    in_order_traversal_doer(f, tree.root);\n+    in_order_traversal_doer(f, tree._root);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    return tree.tree.root;\n+    return tree.tree._root;\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}