{"files":[{"patch":"@@ -83,1 +83,1 @@\n-      pval.out.stack().print_on(stream, 4);\n+      _stack_storage.get(pval.out.stack()).print_on(stream, 4);\n","filename":"src\/hotspot\/share\/nmt\/nmtMemoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -40,1 +41,1 @@\n-\/\/ We achieve this by storing them in a bog-standard closed addressing hashtable and never removing any elements.\n+\/\/ We achieve this by using a closed hashtable for finding previously existing NCS:s and referring to them by an index that's smaller than a pointer.\n@@ -42,0 +43,19 @@\n+public:\n+  struct StackIndex {\n+    friend NativeCallStackStorage;\n+\n+  private:\n+    int32_t _stack_index;\n+    StackIndex(int32_t stack_index)\n+      : _stack_index(stack_index) {\n+    }\n+\n+  public:\n+    static bool equals(const StackIndex& a, const StackIndex& b) {\n+      return a._stack_index == b._stack_index;\n+    }\n+    StackIndex()\n+      : _stack_index(-1) {\n+    }\n+  };\n+\n@@ -45,2 +65,2 @@\n-    NativeCallStack stack;\n-    Link(Link* next, NativeCallStack v)\n+    StackIndex stack;\n+    Link(Link* next, StackIndex v)\n@@ -51,3 +71,3 @@\n-  NativeCallStack* put(const NativeCallStack& value) {\n-    int bucket = value.calculate_hash() % nr_buckets;\n-    Link* link = buckets.at(bucket);\n+  StackIndex put(const NativeCallStack& value) {\n+    int bucket = value.calculate_hash() % _nr_buckets;\n+    Link* link = _buckets[bucket];\n@@ -55,2 +75,2 @@\n-      if (value.equals(link->stack)) {\n-        return &link->stack;\n+      if (value.equals(get(link->stack))) {\n+        return link->stack;\n@@ -60,3 +80,4 @@\n-    Link* new_link = new Link(buckets.at(bucket), value);\n-    buckets.at_put(bucket, new_link);\n-    return &new_link->stack;\n+    int idx = _stacks.append(value);\n+    Link* new_link = new Link(_buckets[bucket], StackIndex(idx));\n+    _buckets[bucket] = new_link;\n+    return new_link->stack;\n@@ -66,4 +87,5 @@\n-  \/\/ 4099 gives a 50% probability of collisions at 76 stacks (as per birthday problem).\n-  static const constexpr int nr_buckets = 4099;\n-  GrowableArrayCHeap<Link*, mtNMT> buckets;\n-  bool is_detailed_mode;\n+  \/\/ 4099 gives a 50% probability of collisions at 76 stacks (as per birthday problem).    os::\n+  static const constexpr int _nr_buckets = 4099;\n+  Link** _buckets;\n+  GrowableArrayCHeap<NativeCallStack, mtNMT> _stacks;\n+  bool _is_detailed_mode;\n@@ -71,14 +93,0 @@\n-  struct StackIndex {\n-    friend NativeCallStackStorage;\n-  private:\n-    NativeCallStack* _stack;\n-    StackIndex(NativeCallStack* stack) : _stack(stack) {}\n-  public:\n-    static bool equals(const StackIndex& a, const StackIndex& b) {\n-      return a._stack == b._stack;\n-    }\n-    StackIndex() : _stack(nullptr) {}\n-    const NativeCallStack& stack() const {\n-      return *_stack;\n-    }\n-  };\n@@ -88,2 +96,2 @@\n-    if (!is_detailed_mode) {\n-      return StackIndex(nullptr);\n+    if (!_is_detailed_mode) {\n+      return StackIndex();\n@@ -95,1 +103,1 @@\n-    return *si._stack;\n+    return _stacks.at(si._stack_index);\n@@ -99,3 +107,3 @@\n-  :  buckets(), is_detailed_mode(is_detailed_mode) {\n-    if (is_detailed_mode) {\n-      buckets.at_grow(nr_buckets, nullptr);\n+  :  _buckets(nullptr), _stacks(), _is_detailed_mode(is_detailed_mode) {\n+    if (_is_detailed_mode) {\n+      _buckets = NEW_C_HEAP_ARRAY(Link*, _nr_buckets, mtNMT);\n@@ -104,0 +112,4 @@\n+\n+  ~NativeCallStackStorage() {\n+    FREE_C_HEAP_ARRAY(Link*, _buckets);\n+  }\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":47,"deletions":35,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -171,2 +171,2 @@\n-    double expected_maximum_depth = log(this->_node_count) * 3;\n-    \/\/ Find the maximum depth through DFS.\n+    double expected_maximum_depth = log(this->_node_count+1) * 5;\n+    \/\/ Find the maximum depth through DFS and ensure that the priority invariant holds.\n@@ -191,0 +191,1 @@\n+        tty->print_cr(\"Failed at priority\");\n@@ -197,0 +198,1 @@\n+      tty->print_cr(\"Failed at depth\");\n@@ -199,1 +201,15 @@\n-    return true;\n+    \/\/ Visit everything in order, see that the key ordering is monotonically increasing.\n+    TreapNode* last_seen = nullptr;\n+    bool failed = false;\n+    this->in_order_traversal([&](TreapNode* node) {\n+      if (last_seen == nullptr) {\n+        last_seen = node;\n+        return;\n+      }\n+      int c = COMPARATOR::cmp(last_seen->key(), node->key());\n+      if (c > 0) {\n+        failed = false;\n+      }\n+      last_seen = node;\n+    });\n+    return !failed;\n@@ -205,2 +221,2 @@\n-  _prng_seed(seed),\n-  DEBUG_ONLY(_node_count(0)) {\n+  _prng_seed(seed)\n+  DEBUG_ONLY(COMMA _node_count(0)) {\n@@ -310,0 +326,15 @@\n+\n+private:\n+  template<typename F>\n+  void in_order_traversal_doer(F f, TreapNode* node) const {\n+    if (node == nullptr) return;\n+    in_order_traversal_doer(f, node->left());\n+    f(node);\n+    in_order_traversal_doer(f, node->right());\n+  }\n+\n+public:\n+  template<typename F>\n+  void in_order_traversal(F f) const {\n+    in_order_traversal_doer(f, _root);\n+  }\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -101,2 +101,2 @@\n-   const NativeCallStack& stack() const {\n-      return sidx.stack();\n+    const NativeCallStackStorage::StackIndex stack() const {\n+     return sidx;\n@@ -180,9 +180,0 @@\n-private:\n-  template<typename F>\n-  void in_order_traversal_doer(F f, TreapNode* node) const {\n-    if (node == nullptr) return;\n-    in_order_traversal_doer(f, node->left());\n-    f(node);\n-    in_order_traversal_doer(f, node->right());\n-  }\n-\n@@ -192,1 +183,1 @@\n-    in_order_traversal_doer(f, tree._root);\n+    tree.in_order_traversal(f);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"}]}