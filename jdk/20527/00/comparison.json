{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8285932 8310913\n+ * @bug 8285932 8310913 8336390 8338060\n@@ -39,0 +39,1 @@\n+import java.util.List;\n@@ -43,0 +44,1 @@\n+import java.util.function.Function;\n@@ -44,0 +46,1 @@\n+import java.util.stream.IntStream;\n@@ -46,1 +49,11 @@\n-    static long BASE_KEY = 10_000_000L;\n+    private static String BASE_KEY = \"BASEKEY-\";\n+\n+    \/\/ Return a String (identity object) that can be a key in WeakHashMap.\n+    private static String genKey(int i) {\n+        return BASE_KEY + i;\n+    }\n+\n+    \/\/ Return a String of the letter 'a' plus the integer (0..0xffff)\n+    private static String genValue(int i) {\n+        return String.valueOf((char) ('a' + i));\n+    }\n@@ -66,3 +79,7 @@\n-    static void mapTest(boolean isSoft, Supplier<Map<ReferenceKey<Long>, String>> supplier) {\n-        Map<Long, String> map = ReferencedKeyMap.create(isSoft, supplier);\n-        populate(map);\n+    static void mapTest(boolean isSoft, Supplier<Map<ReferenceKey<String>, String>> supplier) {\n+        Map<String, String> map = ReferencedKeyMap.create(isSoft, supplier);\n+        var strongKeys = populate(map);      \/\/ Retain references to the keys\n+        methods(map);\n+        Reference.reachabilityFence(strongKeys);\n+\n+        strongKeys = null;      \/\/ drop strong key references\n@@ -74,2 +91,0 @@\n-        populate(map);\n-        methods(map);\n@@ -78,3 +93,7 @@\n-    static void setTest(boolean isSoft, Supplier<Map<ReferenceKey<Long>, ReferenceKey<Long>>> supplier) {\n-        ReferencedKeySet<Long> set = ReferencedKeySet.create(isSoft, supplier);\n-        populate(set);\n+    static void setTest(boolean isSoft, Supplier<Map<ReferenceKey<String>, ReferenceKey<String>>> supplier) {\n+        ReferencedKeySet<String> set = ReferencedKeySet.create(isSoft, supplier);\n+        var strongKeys = populate(set);      \/\/ Retain references to the keys\n+        methods(set);\n+        Reference.reachabilityFence(strongKeys);\n+\n+        strongKeys = null;          \/\/ drop strong key references\n@@ -86,2 +105,0 @@\n-        populate(set);\n-        methods(set);\n@@ -90,1 +107,1 @@\n-    static void methods(Map<Long, String> map) {\n+    static void methods(Map<String, String> map) {\n@@ -92,2 +109,2 @@\n-        assertTrue(map.containsKey(BASE_KEY + 'a' -'a'), \"missing key\");\n-        assertTrue(map.get(BASE_KEY + 'b' -'a').equals(\"b\"), \"wrong key\");\n+        assertTrue(map.containsKey(genKey('a' -'a')), \"missing key\");\n+        assertTrue(map.get(genKey('b' -'a')).equals(\"b\"), \"wrong key\");\n@@ -95,5 +112,5 @@\n-        map.remove(BASE_KEY + 'd' -'a');\n-        assertTrue(map.get(BASE_KEY + 'd' -'a') == null, \"not removed\");\n-        map.putAll(Map.of(1L, \"A\", 2L, \"B\"));\n-        assertTrue(map.get(2L).equals(\"B\"), \"collection not added\");\n-        assertTrue(map.containsKey(1L), \"key missing\");\n+        map.remove(genKey('d' -'a'));\n+        assertTrue(map.get(genKey('d' -'a')) == null, \"not removed\");\n+        map.putAll(Map.of(genKey(1), \"A\", genKey(2), \"B\"));\n+        assertTrue(map.get(genKey(2)).equals(\"B\"), \"collection not added\");\n+        assertTrue(map.containsKey(genKey(1)), \"key missing\");\n@@ -101,11 +118,11 @@\n-        assertTrue(map.entrySet().contains(Map.entry(1L, \"A\")), \"key missing\");\n-        map.putIfAbsent(3L, \"C\");\n-        assertTrue(map.get(3L).equals(\"C\"), \"key missing\");\n-        map.putIfAbsent(2L, \"D\");\n-        assertTrue(map.get(2L).equals(\"B\"), \"key replaced\");\n-        map.remove(3L);\n-        assertTrue(map.get(3L) == null, \"key not removed\");\n-        map.replace(2L, \"D\");\n-        assertTrue(map.get(2L).equals(\"D\"), \"key not replaced\");\n-        map.replace(2L, \"B\", \"E\");\n-        assertTrue(map.get(2L).equals(\"D\"), \"key replaced\");\n+        assertTrue(map.entrySet().contains(Map.entry(genKey(1), \"A\")), \"key missing\");\n+        map.putIfAbsent(genKey(3), \"C\");\n+        assertTrue(map.get(genKey(3)).equals(\"C\"), \"key missing\");\n+        map.putIfAbsent(genKey(2), \"D\");\n+        assertTrue(map.get(genKey(2)).equals(\"B\"), \"key replaced\");\n+        map.remove(genKey(3));\n+        assertTrue(map.get(genKey(3)) == null, \"key not removed\");\n+        map.replace(genKey(2), \"D\");\n+        assertTrue(map.get(genKey(2)).equals(\"D\"), \"key not replaced\");\n+        map.replace(genKey(2), \"B\", \"E\");\n+        assertTrue(map.get(genKey(2)).equals(\"D\"), \"key replaced\");\n@@ -114,1 +131,1 @@\n-    static void methods(ReferencedKeySet<Long> set) {\n+    static void methods(ReferencedKeySet<String> set) {\n@@ -116,9 +133,9 @@\n-        assertTrue(set.contains(BASE_KEY + 3), \"missing key\");\n-        set.remove(BASE_KEY + 3);\n-        assertTrue(!set.contains(BASE_KEY + 3), \"not removed\");\n-        Long element1 = set.get(BASE_KEY + 2);\n-        Long element2 = set.get(BASE_KEY + 3);\n-        Long element3 = set.get(BASE_KEY + 4);\n-        Long intern1 = set.intern(BASE_KEY + 2);\n-        Long intern2 = set.intern(BASE_KEY + 3);\n-        Long intern3 = set.intern(BASE_KEY + 4, e -> e);\n+        assertTrue(set.contains(genKey(3)), \"missing key\");\n+        set.remove(genKey(3));\n+        assertTrue(!set.contains(genKey(3)), \"not removed\");\n+        String element1 = set.get(genKey(2));\n+        String element2 = set.get(genKey(3));\n+        String element3 = set.get(genKey(4));\n+        String intern1 = set.intern(genKey(2));\n+        String intern2 = set.intern(genKey(3));\n+        String intern3 = set.intern(genKey(4), e -> e);\n@@ -131,2 +148,2 @@\n-        Long value1 = Long.valueOf(BASE_KEY + 999);\n-        Long value2 = Long.valueOf(BASE_KEY + 999);\n+        String value1 = genKey(999);\n+        String value2 = genKey(999);\n@@ -167,5 +184,5 @@\n-    static void populate(Map<Long, String> map) {\n-        for (int i = 0; i < 26; i++) {\n-            Long key = BASE_KEY + i;\n-            String value = String.valueOf((char) ('a' + i));\n-            map.put(key, value);\n+    static List<String> populate(Map<String, String> map) {\n+        var keyRefs = genStrings(0, 26, ReferencedKeyTest::genKey);\n+        var valueRefs = genStrings(0, 26, ReferencedKeyTest::genValue);\n+        for (int i = 0; i < keyRefs.size(); i++) {\n+            map.put(keyRefs.get(i), valueRefs.get(i));\n@@ -173,0 +190,1 @@\n+        return keyRefs;\n@@ -175,5 +193,9 @@\n-    static void populate(Set<Long> set) {\n-        for (int i = 0; i < 26; i++) {\n-            Long value = BASE_KEY + i;\n-            set.add(value);\n-        }\n+    static List<String> populate(Set<String> set) {\n+        var keyRefs = genStrings(0, 26, ReferencedKeyTest::genKey);\n+        set.addAll(keyRefs);\n+        return keyRefs;\n+    }\n+\n+    \/\/ Generate a List of consecutive strings using a function int -> String\n+    static List<String> genStrings(int min, int maxExclusive, Function<Integer, String> genString) {\n+        return IntStream.range(min, maxExclusive).mapToObj(i -> genString.apply(i)).toList();\n","filename":"test\/jdk\/jdk\/internal\/util\/ReferencedKeyTest.java","additions":76,"deletions":54,"binary":false,"changes":130,"status":"modified"}]}