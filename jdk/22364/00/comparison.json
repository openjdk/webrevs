{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -32,0 +33,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -159,0 +161,88 @@\n+    private static final @Stable int[] POWERS_OF_31 = new int[]{\n+            0x0000001f, 0x000003c1, 0x0000745f, 0x000e1781,\n+            0x01b4d89f, 0x34e63b41, 0x67e12cdf, 0x94446f01};\n+\n+    \/**\n+     * {@return a 32-bit hash value calculated from the content in the provided\n+     *          {@code segment} between the provided offsets}\n+     * <p>\n+     * The method is implemented as a 32-bit polynomial hash function equivalent to:\n+     * {@snippet lang=java :\n+     *     final long length = toOffset - fromOffset;\n+     *     segment.checkBounds(fromOffset, length);\n+     *     int result = 1;\n+     *     for (long i = fromOffset; i < toOffset; i++) {\n+     *         result = 31 * result + segment.get(JAVA_BYTE, i);\n+     *     }\n+     *     return result;\n+     * }\n+     * but is potentially more performant.\n+     *\n+     * @param segment    from which a content hash should be computed\n+     * @param fromOffset starting offset (inclusive) in the segment\n+     * @param toOffset   ending offset (non-inclusive) in the segment\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     *         such that {@code srcSegment.isAccessibleBy(T) == false}\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#scope() scope}\n+     *         associated with {@code segment} is not\n+     *         {@linkplain MemorySegment.Scope#isAlive() alive}\n+     * @throws IndexOutOfBoundsException if either {@code fromOffset} or {@code toOffset}\n+     *                                   are {@code > segment.byteSize}\n+     * @throws IndexOutOfBoundsException if either {@code fromOffset} or {@code toOffset}\n+     *                                   are {@code < 0}\n+     * @throws IndexOutOfBoundsException if {@code toOffset - fromOffset} is {@code < 0}\n+     *\/\n+    @ForceInline\n+    public static int contentHash(AbstractMemorySegmentImpl segment, long fromOffset, long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            \/\/ The state has to be checked explicitly for zero-length segments\n+            segment.scope.checkValidState();\n+            return 1;\n+        }\n+        int result = 1;\n+        final long longBytes = length & ((1L << 62) - 8);\n+        final long limit = fromOffset + longBytes;\n+        for (; fromOffset < limit; fromOffset += 8) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian());\n+            result = result * POWERS_OF_31[7]\n+                    + ((byte) (val >>> 56)) * POWERS_OF_31[6]\n+                    + ((byte) (val >>> 48)) * POWERS_OF_31[5]\n+                    + ((byte) (val >>> 40)) * POWERS_OF_31[4]\n+                    + ((byte) (val >>> 32)) * POWERS_OF_31[3]\n+                    + ((byte) (val >>> 24)) * POWERS_OF_31[2]\n+                    + ((byte) (val >>> 16)) * POWERS_OF_31[1]\n+                    + ((byte) (val >>> 8)) * POWERS_OF_31[0]\n+                    + ((byte) val);\n+        }\n+        int remaining = (int) (length - longBytes);\n+        \/\/ 0...0X00\n+        if (remaining >= 4) {\n+            int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian());\n+            result = result * POWERS_OF_31[3]\n+                    + ((byte) (val >>> 24)) * POWERS_OF_31[2]\n+                    + ((byte) (val >>> 16)) * POWERS_OF_31[1]\n+                    + ((byte) (val >>> 8)) * POWERS_OF_31[0]\n+                    + ((byte) val);\n+            fromOffset += 4;\n+            remaining -= 4;\n+        }\n+        \/\/ 0...00X0\n+        if (remaining >= 2) {\n+            short val = SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian());\n+            result = result * POWERS_OF_31[1]\n+                    + ((byte) (val >>> 8)) * POWERS_OF_31[0]\n+                    + ((byte) val);\n+            fromOffset += 2;\n+            remaining -= 2;\n+        }\n+        \/\/ 0...000X\n+        if (remaining == 1) {\n+            byte val = SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset);\n+            result = result * POWERS_OF_31[0]\n+                    + val;\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test SegmentBulkOperations::contentHash\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestSegmentBulkOperationsContentHash\n+ *\/\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.SegmentBulkOperations;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestSegmentBulkOperationsContentHash {\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    @Disabled\n+    void testHashValues(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE ; i++) {\n+                var segment = arena.allocate(len);\n+                segment.fill((byte) i);\n+                int hash = hash(segment);\n+                int expected = Arrays.hashCode(segment.toArray(ValueLayout.JAVA_BYTE));\n+                assertEquals(expected, hash, Arrays.toString(segment.toArray(ValueLayout.JAVA_BYTE)));\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testOffsets(int len) {\n+        if (len < 2) {\n+            return;\n+        }\n+        try (var arena = Arena.ofConfined()) {\n+            for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE ; i++) {\n+                var segment = arena.allocate(len);\n+                segment.fill((byte) i);\n+                int hash = hash(segment, 1, segment.byteSize() - 1);\n+                MemorySegment slice = segment.asSlice(1, segment.byteSize() - 2);\n+                byte[] arr = slice.toArray(ValueLayout.JAVA_BYTE);\n+                System.out.println(Arrays.toString(arr));\n+                int expected = Arrays.hashCode(arr);\n+                assertEquals(expected, hash, Arrays.toString(segment.toArray(ValueLayout.JAVA_BYTE)));\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testOutOfBounds(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(len);\n+            assertThrows(IndexOutOfBoundsException.class,\n+                    () -> hash(segment, 0, segment.byteSize() + 1));\n+            assertThrows(IndexOutOfBoundsException.class,\n+                    () -> hash(segment, 0, -1));\n+            assertThrows(IndexOutOfBoundsException.class,\n+                    () -> hash(segment, -1, 0));\n+            if (len > 2) {\n+                assertThrows(IndexOutOfBoundsException.class,\n+                        () -> hash(segment, 2, 1));\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testConfinement(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(len);\n+            AtomicReference<RuntimeException> ex = new AtomicReference<>();\n+            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+                try {\n+                    hash(segment);\n+                } catch (RuntimeException e) {\n+                    ex.set(e);\n+                }\n+            });\n+            future.join();\n+            assertInstanceOf(WrongThreadException.class, ex.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testScope(int len) {\n+        var arena = Arena.ofConfined();\n+        var segment = arena.allocate(len);\n+        arena.close();\n+        assertThrows(IllegalStateException.class, () -> hash(segment));\n+    }\n+\n+    private static int hash(MemorySegment segment) {\n+        return hash(segment, 0, segment.byteSize());\n+    }\n+\n+    private static int hash(MemorySegment segment, long fromOffset, long toOffset) {\n+        return SegmentBulkOperations.contentHash((AbstractMemorySegmentImpl) segment, fromOffset, toOffset);\n+    }\n+\n+    private static final int MAX_SIZE = 1 << 10;\n+\n+    private static Stream<Arguments> sizes() {\n+        return IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 23, 32, 63, 128, 256, 511, MAX_SIZE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentBulkOperationsContentHash.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.SegmentBulkOperations;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\"})\n+public class SegmentBulkHash {\n+\n+    @Param({\"8\", \"64\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] array;\n+    AbstractMemorySegmentImpl heapSegment;\n+    AbstractMemorySegmentImpl nativeSegment;\n+\n+    @Setup\n+    public void setup() {\n+        \/\/ Always use the same alignment regardless of size\n+        nativeSegment = (AbstractMemorySegmentImpl) Arena.ofAuto().allocate(ELEM_SIZE, 16);\n+        var rnd = new Random(42);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            nativeSegment.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+        }\n+        array = nativeSegment.toArray(JAVA_BYTE);\n+        heapSegment = (AbstractMemorySegmentImpl) MemorySegment.ofArray(array);\n+    }\n+\n+    @Benchmark\n+    public int array() {\n+        return Arrays.hashCode(array);\n+    }\n+\n+    @Benchmark\n+    public int heapSegment() {\n+        return SegmentBulkOperations.contentHash(heapSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public int nativeSegment() {\n+        return SegmentBulkOperations.contentHash(nativeSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public int nativeSegmentJava() {\n+        int result = 1;\n+        for (long i = 0; i < ELEM_SIZE; i++) {\n+            result = 31 * result + nativeSegment.get(JAVA_BYTE, i);\n+        }\n+        return result;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkHash.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}