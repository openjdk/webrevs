{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -173,1 +174,1 @@\n-        return (b[off] & 0xff) | ((b[off + 1] & 0xff) << 8);\n+        return ByteArrayLittleEndian.getUnsignedShort(b, off);\n@@ -181,1 +182,1 @@\n-        return (get16(b, off) | ((long)get16(b, off+2) << 16)) & 0xffffffffL;\n+        return ByteArrayLittleEndian.getUnsignedInt(b, off);\n@@ -189,1 +190,1 @@\n-        return get32(b, off) | (get32(b, off+4) << 32);\n+        return ByteArrayLittleEndian.getLong(b, off);\n@@ -198,1 +199,1 @@\n-        return (get16(b, off) | (get16(b, off+2) << 16));\n+        return ByteArrayLittleEndian.getInt(b, off);\n@@ -207,1 +208,1 @@\n-        return (b[n] & 0xff) | ((b[n + 1] & 0xff) << 8);\n+        return ByteArrayLittleEndian.getUnsignedShort(b, n);\n@@ -211,1 +212,1 @@\n-        return ((SH(b, n)) | (SH(b, n + 2) << 16)) & 0xffffffffL;\n+        return ByteArrayLittleEndian.getUnsignedInt(b, n);\n@@ -215,1 +216,1 @@\n-        return (LG(b, n)) | (LG(b, n + 4) << 32);\n+        return ByteArrayLittleEndian.getLong(b, n);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipUtils.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,17 @@\n+    \/**\n+     * {@return an {@code unsigned int} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @return an {@code long} representing an unsigned int from the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 2]\n+     * @see #setUnsignedShort(byte[], int, int)\n+     *\/\n+    public static long getUnsignedInt(byte[] array, int offset) {\n+        return Integer.toUnsignedLong((int) INT.get(array, offset));\n+    }\n+\n@@ -319,0 +336,17 @@\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #getUnsignedInt(byte[], int)\n+     *\/\n+    public static void setUnsignedInt(byte[] array, int offset, long value) {\n+        INT.set(array, offset, (int) value);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArray.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,17 @@\n+    \/**\n+     * {@return an {@code unsigned int} from the provided {@code array} at the given {@code offset}\n+     * using little endian order}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to get a value from.\n+     * @param offset where extraction in the array should begin\n+     * @return an {@code int} representing an unsigned short from the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #setUnsignedInt(byte[], int, long)\n+     *\/\n+    public static long getUnsignedInt(byte[] array, int offset) {\n+        return Integer.toUnsignedLong((int) INT.get(array, offset));\n+    }\n+\n@@ -319,0 +336,17 @@\n+    \/**\n+     * Sets (writes) the provided {@code value} using little endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #getUnsignedInt(byte[], int)\n+     *\/\n+    public static void setUnsignedInt(byte[] array, int offset, long value) {\n+        INT.set(array, offset, (int) value);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArrayLittleEndian.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8299576\n+ * @bug 8299576 8310837\n@@ -33,0 +33,1 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -40,0 +41,3 @@\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.ParameterizedTest;\n@@ -51,2 +55,3 @@\n-    @Test\n-    void testGetShort() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetShort(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -55,2 +60,2 @@\n-            RefImpl.putShort(BUFF, OFFSET, expected);\n-            short actual = ByteArray.getShort(BUFF, OFFSET);\n+            ref.setShort(BUFF, OFFSET, expected);\n+            short actual = ba.getShort(BUFF, OFFSET);\n@@ -61,2 +66,3 @@\n-    @Test\n-    void testPutShort() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetShort(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -65,2 +71,2 @@\n-            ByteArray.setShort(BUFF, OFFSET, expected);\n-            short actual = RefImpl.getShort(BUFF, OFFSET);\n+            ba.setShort(BUFF, OFFSET, expected);\n+            short actual = ref.getShort(BUFF, OFFSET);\n@@ -71,2 +77,3 @@\n-    @Test\n-    void testGetChar() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetChar(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -75,2 +82,2 @@\n-            RefImpl.putChar(BUFF, OFFSET, expected);\n-            char actual = ByteArray.getChar(BUFF, OFFSET);\n+            ref.setChar(BUFF, OFFSET, expected);\n+            char actual = ba.getChar(BUFF, OFFSET);\n@@ -81,2 +88,3 @@\n-    @Test\n-    void testPutChar() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetChar(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -85,2 +93,2 @@\n-            ByteArray.setChar(BUFF, OFFSET, expected);\n-            char actual = RefImpl.getChar(BUFF, OFFSET);\n+            ba.setChar(BUFF, OFFSET, expected);\n+            char actual = ref.getChar(BUFF, OFFSET);\n@@ -91,2 +99,3 @@\n-    @Test\n-    void testGetInt() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetInt(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -95,2 +104,2 @@\n-            RefImpl.putInt(BUFF, OFFSET, expected);\n-            int actual = ByteArray.getInt(BUFF, OFFSET);\n+            ref.setInt(BUFF, OFFSET, expected);\n+            int actual = ba.getInt(BUFF, OFFSET);\n@@ -101,2 +110,3 @@\n-    @Test\n-    void testPutInt() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetInt(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -105,2 +115,2 @@\n-            ByteArray.setInt(BUFF, OFFSET, expected);\n-            int actual = RefImpl.getInt(BUFF, OFFSET);\n+            ba.setInt(BUFF, OFFSET, expected);\n+            int actual = ref.getInt(BUFF, OFFSET);\n@@ -111,2 +121,3 @@\n-    @Test\n-    void testGetLong() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetLong(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -114,2 +125,2 @@\n-            RefImpl.putLong(BUFF, OFFSET, expected);\n-            long actual = ByteArray.getLong(BUFF, OFFSET);\n+            ref.setLong(BUFF, OFFSET, expected);\n+            long actual = ba.getLong(BUFF, OFFSET);\n@@ -120,2 +131,3 @@\n-    @Test\n-    void testPutLong() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetLong(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -123,2 +135,2 @@\n-            ByteArray.setLong(BUFF, OFFSET, expected);\n-            long actual = RefImpl.getLong(BUFF, OFFSET);\n+            ba.setLong(BUFF, OFFSET, expected);\n+            long actual = ref.getLong(BUFF, OFFSET);\n@@ -129,2 +141,3 @@\n-    @Test\n-    void testGetFloat() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetFloat(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -132,2 +145,2 @@\n-            RefImpl.putFloat(BUFF, OFFSET, expected);\n-            float actual = ByteArray.getFloat(BUFF, OFFSET);\n+            ref.setFloat(BUFF, OFFSET, expected);\n+            float actual = ba.getFloat(BUFF, OFFSET);\n@@ -138,2 +151,3 @@\n-    @Test\n-    void testPutFloat() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetFloat(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -141,2 +155,2 @@\n-            ByteArray.setFloat(BUFF, OFFSET, expected);\n-            float actual = RefImpl.getFloat(BUFF, OFFSET);\n+            ba.setFloat(BUFF, OFFSET, expected);\n+            float actual = ref.getFloat(BUFF, OFFSET);\n@@ -147,2 +161,3 @@\n-    @Test\n-    void testGetDouble() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetDouble(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -150,2 +165,2 @@\n-            RefImpl.putDouble(BUFF, OFFSET, expected);\n-            double actual = ByteArray.getDouble(BUFF, OFFSET);\n+            ref.setDouble(BUFF, OFFSET, expected);\n+            double actual = ba.getDouble(BUFF, OFFSET);\n@@ -156,2 +171,3 @@\n-    @Test\n-    void testPutDouble() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetDouble(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -159,2 +175,2 @@\n-            ByteArray.setDouble(BUFF, OFFSET, expected);\n-            double actual = RefImpl.getDouble(BUFF, OFFSET);\n+            ba.setDouble(BUFF, OFFSET, expected);\n+            double actual = ref.getDouble(BUFF, OFFSET);\n@@ -165,2 +181,3 @@\n-    @Test\n-    void testPutUnsignedShort() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetUnsignedShort(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -169,2 +186,35 @@\n-            ByteArray.setUnsignedShort(BUFF, OFFSET, expected);\n-            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, OFFSET));\n+            ref.setUnsignedShort(BUFF, OFFSET, expected);\n+            int actual = ba.getUnsignedShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetUnsignedShort(ByteArrayImpl ref, ByteArrayImpl ba) {\n+        longs().forEach(l -> {\n+            int expected = Short.toUnsignedInt((short) l);\n+            ba.setUnsignedShort(BUFF, OFFSET, expected);\n+            int actual = ref.getUnsignedShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetUnsignedInt(ByteArrayImpl ref, ByteArrayImpl ba) {\n+        longs().forEach(l -> {\n+            long expected = Integer.toUnsignedLong((int) l);\n+            ref.setUnsignedInt(BUFF, OFFSET, expected);\n+            long actual = ba.getUnsignedInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetUnsignedInt(ByteArrayImpl ref, ByteArrayImpl ba) {\n+        longs().forEach(l -> {\n+            long expected = Integer.toUnsignedLong((int) l);\n+            ba.setUnsignedInt(BUFF, OFFSET, expected);\n+            long actual = ref.getUnsignedInt(BUFF, OFFSET);\n@@ -177,4 +227,5 @@\n-    @Test\n-    void testNullArray() {\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.getInt(null, OFFSET));\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.setInt(null, OFFSET, 1));\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImpl\")\n+    void testNullArray(ByteArrayImpl ba) {\n+        assertThrowsOriginal(NullPointerException.class, () -> ba.getInt(null, OFFSET));\n+        assertThrowsOriginal(NullPointerException.class, () -> ba.setInt(null, OFFSET, 1));\n@@ -183,4 +234,5 @@\n-    @Test\n-    void testNegArg() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getInt(BUFF, -1));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setInt(BUFF, -1, 1));\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImpl\")\n+    void testNegArg(ByteArrayImpl ba) {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ba.getInt(BUFF, -1));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ba.setInt(BUFF, -1, 1));\n@@ -189,4 +241,5 @@\n-    @Test\n-    void testOutOfBounds() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getInt(BUFF, BUFF.length));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setInt(BUFF, BUFF.length, 1));\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImpl\")\n+    void testOutOfBounds(ByteArrayImpl ba) {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ba.getInt(BUFF, BUFF.length));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ba.setInt(BUFF, BUFF.length, 1));\n@@ -211,0 +264,1 @@\n+\n@@ -224,0 +278,10 @@\n+    static Stream<ByteArrayImpl> byteArrayImpl() {\n+        return Stream.of(UNSAFE, UNSAFE_LE);\n+    }\n+\n+    static Stream<Arguments> byteArrayImplWithRef() {\n+        return Stream.of(\n+                Arguments.of(REF, UNSAFE),\n+                Arguments.of(REF_LE, UNSAFE_LE));\n+    }\n+\n@@ -245,0 +309,55 @@\n+    private interface ByteArrayImpl {\n+        char getChar(byte[] b, int off);\n+\n+        short getShort(byte[] b, int off);\n+\n+        default int getUnsignedShort(byte[] b, int off) {\n+            return Short.toUnsignedInt(getShort(b, off));\n+        }\n+\n+        int getInt(byte[] b, int off);\n+\n+        default long getUnsignedInt(byte[] b, int off) {\n+            return Integer.toUnsignedLong(getInt(b, off));\n+        }\n+\n+        long getLong(byte[] b, int off);\n+\n+        default float getFloat(byte[] b, int off) {\n+            return Float.intBitsToFloat(getInt(b, off));\n+        }\n+\n+        default double getDouble(byte[] b, int off) {\n+            return Double.longBitsToDouble(getLong(b, off));\n+        }\n+\n+        \/*\n+         * Methods for packing primitive values into byte arrays starting at given\n+         * offsets.\n+         *\/\n+\n+        void setChar(byte[] b, int off, char val);\n+\n+        void setShort(byte[] b, int off, short val);\n+\n+        default void setUnsignedShort(byte[] b, int off, int val) {\n+            setShort(b, off, (short) val);\n+        }\n+\n+        void setInt(byte[] b, int off, int val);\n+\n+        default void setUnsignedInt(byte[] b, int off, long val) {\n+            setInt(b, off, (int) val);\n+        }\n+\n+        void setLong(byte[] b, int off, long val);\n+\n+        default void setFloat(byte[] b, int off, float val) {\n+            setInt(b, off, Float.floatToIntBits(val));\n+        }\n+\n+        default void setDouble(byte[] b, int off, double val) {\n+            setLong(b, off, Double.doubleToLongBits(val));\n+        }\n+    }\n+\n@@ -248,4 +367,2 @@\n-    private static final class RefImpl {\n-        private RefImpl() {}\n-\n-        static char getChar(byte[] b, int off) {\n+    private static final ByteArrayImpl REF = new ByteArrayImpl() {\n+        public char getChar(byte[] b, int off) {\n@@ -256,1 +373,1 @@\n-        static short getShort(byte[] b, int off) {\n+        public short getShort(byte[] b, int off) {\n@@ -261,1 +378,1 @@\n-        static int getInt(byte[] b, int off) {\n+        public int getInt(byte[] b, int off) {\n@@ -268,5 +385,1 @@\n-        static float getFloat(byte[] b, int off) {\n-            return Float.intBitsToFloat(getInt(b, off));\n-        }\n-\n-        static long getLong(byte[] b, int off) {\n+        public long getLong(byte[] b, int off) {\n@@ -283,10 +396,1 @@\n-        static double getDouble(byte[] b, int off) {\n-            return Double.longBitsToDouble(getLong(b, off));\n-        }\n-\n-        \/*\n-         * Methods for packing primitive values into byte arrays starting at given\n-         * offsets.\n-         *\/\n-\n-        static void putChar(byte[] b, int off, char val) {\n+        public void setChar(byte[] b, int off, char val) {\n@@ -297,1 +401,1 @@\n-        static void putShort(byte[] b, int off, short val) {\n+        public void setShort(byte[] b, int off, short val) {\n@@ -302,1 +406,1 @@\n-        static void putInt(byte[] b, int off, int val) {\n+        public void setInt(byte[] b, int off, int val) {\n@@ -309,5 +413,1 @@\n-        static void putFloat(byte[] b, int off, float val) {\n-            putInt(b, off, Float.floatToIntBits(val));\n-        }\n-\n-        static void putLong(byte[] b, int off, long val) {\n+        public void setLong(byte[] b, int off, long val) {\n@@ -323,0 +423,1 @@\n+    };\n@@ -324,2 +425,4 @@\n-        static void putDouble(byte[] b, int off, double val) {\n-            putLong(b, off, Double.doubleToLongBits(val));\n+    private static final ByteArrayImpl REF_LE = new ByteArrayImpl() {\n+        public char getChar(byte[] b, int off) {\n+            return (char) ((b[off] & 0xFF) +\n+                    (b[off + 1] << 8));\n@@ -327,2 +430,185 @@\n-    }\n-}\n+\n+        public short getShort(byte[] b, int off) {\n+            return (short) ((b[off] & 0xFF) +\n+                    (b[off + 1] << 8));\n+        }\n+\n+        public int getInt(byte[] b, int off) {\n+            return ((b[off] & 0xFF)) +\n+                    ((b[off + 1] & 0xFF) << 8) +\n+                    ((b[off + 2] & 0xFF) << 16) +\n+                    ((b[off + 3]) << 24);\n+        }\n+\n+        public long getLong(byte[] b, int off) {\n+            return ((b[off] & 0xFFL)) +\n+                    ((b[off + 1] & 0xFFL) << 8) +\n+                    ((b[off + 2] & 0xFFL) << 16) +\n+                    ((b[off + 3] & 0xFFL) << 24) +\n+                    ((b[off + 4] & 0xFFL) << 32) +\n+                    ((b[off + 5] & 0xFFL) << 40) +\n+                    ((b[off + 6] & 0xFFL) << 48) +\n+                    (((long) b[off + 7]) << 56);\n+        }\n+\n+        public void setChar(byte[] b, int off, char val) {\n+            b[off] = (byte) (val);\n+            b[off + 1] = (byte) (val >>> 8);\n+        }\n+\n+        public void setShort(byte[] b, int off, short val) {\n+            b[off] = (byte) (val);\n+            b[off + 1] = (byte) (val >>> 8);\n+        }\n+\n+        public void setInt(byte[] b, int off, int val) {\n+            b[off] = (byte) (val);\n+            b[off + 1] = (byte) (val >>> 8);\n+            b[off + 2] = (byte) (val >>> 16);\n+            b[off + 3] = (byte) (val >>> 24);\n+        }\n+\n+        public void setLong(byte[] b, int off, long val) {\n+            b[off] = (byte) (val);\n+            b[off + 1] = (byte) (val >>> 8);\n+            b[off + 2] = (byte) (val >>> 16);\n+            b[off + 3] = (byte) (val >>> 24);\n+            b[off + 4] = (byte) (val >>> 32);\n+            b[off + 5] = (byte) (val >>> 40);\n+            b[off + 6] = (byte) (val >>> 48);\n+            b[off + 7] = (byte) (val >>> 56);\n+        }\n+    };\n+\n+    private static final ByteArrayImpl UNSAFE = new ByteArrayImpl() {\n+        public char getChar(byte[] b, int off) {\n+            return ByteArray.getChar(b, off);\n+        }\n+\n+        public short getShort(byte[] b, int off) {\n+            return ByteArray.getShort(b, off);\n+        }\n+\n+        public int getUnsignedShort(byte[] b, int off) {\n+            return ByteArray.getUnsignedShort(b, off);\n+        }\n+\n+        public int getInt(byte[] b, int off) {\n+            return ByteArray.getInt(b, off);\n+        }\n+\n+        public long getUnsignedInt(byte[] b, int off) {\n+            return ByteArray.getUnsignedInt(b, off);\n+        }\n+\n+        public long getLong(byte[] b, int off) {\n+            return ByteArray.getLong(b, off);\n+        }\n+\n+        public float getFloat(byte[] b, int off) {\n+            return ByteArray.getFloat(b, off);\n+        }\n+\n+        public double getDouble(byte[] b, int off) {\n+            return ByteArray.getDouble(b, off);\n+        }\n+\n+        public void setChar(byte[] b, int off, char val) {\n+            ByteArray.setChar(b, off, val);\n+        }\n+\n+        public void setShort(byte[] b, int off, short val) {\n+            ByteArray.setShort(b, off, val);\n+        }\n+\n+        public void setUnsignedShort(byte[] b, int off, int val) {\n+            ByteArray.setUnsignedShort(b, off, val);\n+        }\n+\n+        public void setInt(byte[] b, int off, int val) {\n+            ByteArray.setInt(b, off, val);\n+        }\n+\n+        public void setUnsignedInt(byte[] b, int off, long val) {\n+            ByteArray.setUnsignedInt(b, off, val);\n+        }\n+\n+        public void setLong(byte[] b, int off, long val) {\n+            ByteArray.setLong(b, off, val);\n+        }\n+\n+        public void setFloat(byte[] b, int off, float val) {\n+            ByteArray.setFloat(b, off, val);\n+        }\n+\n+        public void setDouble(byte[] b, int off, double val) {\n+            ByteArray.setDouble(b, off, val);\n+        }\n+    };\n+\n+    private static final ByteArrayImpl UNSAFE_LE = new ByteArrayImpl() {\n+        public char getChar(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getChar(b, off);\n+        }\n+\n+        public short getShort(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getShort(b, off);\n+        }\n+\n+        public int getUnsignedShort(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getUnsignedShort(b, off);\n+        }\n+\n+        public int getInt(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getInt(b, off);\n+        }\n+\n+        public long getUnsignedInt(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getUnsignedInt(b, off);\n+        }\n+\n+        public long getLong(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getLong(b, off);\n+        }\n+\n+        public float getFloat(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getFloat(b, off);\n+        }\n+\n+        public double getDouble(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getDouble(b, off);\n+        }\n+\n+        public void setChar(byte[] b, int off, char val) {\n+            ByteArrayLittleEndian.setChar(b, off, val);\n+        }\n+\n+        public void setShort(byte[] b, int off, short val) {\n+            ByteArrayLittleEndian.setShort(b, off, val);\n+        }\n+\n+        public void setUnsignedShort(byte[] b, int off, int val) {\n+            ByteArrayLittleEndian.setUnsignedShort(b, off, val);\n+        }\n+\n+        public void setInt(byte[] b, int off, int val) {\n+            ByteArrayLittleEndian.setInt(b, off, val);\n+        }\n+\n+        public void setUnsignedInt(byte[] b, int off, long val) {\n+            ByteArrayLittleEndian.setUnsignedInt(b, off, val);\n+        }\n+\n+        public void setLong(byte[] b, int off, long val) {\n+            ByteArrayLittleEndian.setLong(b, off, val);\n+        }\n+\n+        public void setFloat(byte[] b, int off, float val) {\n+            ByteArrayLittleEndian.setFloat(b, off, val);\n+        }\n+\n+        public void setDouble(byte[] b, int off, double val) {\n+            ByteArrayLittleEndian.setDouble(b, off, val);\n+        }\n+    };\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/util\/ByteArray\/ReadWriteValues.java","additions":384,"deletions":98,"binary":false,"changes":482,"status":"modified"}]}