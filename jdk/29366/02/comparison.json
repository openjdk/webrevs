{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm\n+ * @run junit\/othervm\n@@ -32,1 +32,1 @@\n- *       StreamingBody\n+ *       ${test.main.class}\n@@ -43,0 +43,5 @@\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -45,0 +50,1 @@\n+import jdk.test.lib.RandomFactory;\n@@ -46,4 +52,0 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -58,1 +60,0 @@\n-import static org.testng.Assert.assertEquals;\n@@ -60,0 +61,14 @@\n+import org.junit.jupiter.api.AfterAll;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.extension.BeforeEachCallback;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.api.extension.TestWatcher;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -74,0 +89,96 @@\n+    static final AtomicLong clientCount = new AtomicLong();\n+    static final AtomicLong serverCount = new AtomicLong();\n+    static final ConcurrentMap<String, Throwable> FAILURES = new ConcurrentHashMap<>();\n+    private static boolean stopAfterFirstFailure() {\n+        return true;\n+    }\n+\n+    static final long start = System.nanoTime();\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%d s, %d ms, %d ns] \", secs, mill, nan);\n+    }\n+\n+    final static class TestStopper implements TestWatcher, BeforeEachCallback {\n+        final AtomicReference<String> failed = new AtomicReference<>();\n+        TestStopper() { }\n+        @Override\n+        public void testFailed(ExtensionContext context, Throwable cause) {\n+            if (stopAfterFirstFailure()) {\n+                String msg = \"Aborting due to: \" + cause;\n+                failed.compareAndSet(null, msg);\n+                FAILURES.putIfAbsent(context.getDisplayName(), cause);\n+                System.out.printf(\"%nTEST FAILED: %s%s%n\\tAborting due to %s%n%n\",\n+                        now(), context.getDisplayName(), cause);\n+                System.err.printf(\"%nTEST FAILED: %s%s%n\\tAborting due to %s%n%n\",\n+                        now(), context.getDisplayName(), cause);\n+            }\n+        }\n+\n+        @Override\n+        public void beforeEach(ExtensionContext context) {\n+            String msg = failed.get();\n+            Assumptions.assumeTrue(msg == null, msg);\n+        }\n+    }\n+\n+    @RegisterExtension\n+    static final TestStopper stopper = new TestStopper();\n+\n+    \/\/\/ The GCTrigger triggers GC at random intervals to\n+    \/\/\/ help garbage collecting HttpClient intances. This test\n+    \/\/\/ wants to verify that HttpClient instances which are no\n+    \/\/\/ longer strongly referenced are not garbage collected\n+    \/\/\/ before pending HTTP requests are finished. The test\n+    \/\/\/ creates many client instances (up to 500) and relies\n+    \/\/\/ on the GC to collect them, since it does not want to\n+    \/\/\/ keep a strong reference, and therefore cannot not call\n+    \/\/\/ close(). This can put extra load on the machine since\n+    \/\/\/ we can't (and don't want to) control when the GC will\n+    \/\/\/ intervene. The purpose of this class is to trigger the\n+    \/\/\/ GC at random intervals to 1. help garbage collect client\n+    \/\/\/ instances earlier, thus reducing the load on the machine,\n+    \/\/\/ and 2. potentially trigger bugs if the client gets\n+    \/\/\/ inadvertently GC'ed before the request is finished\n+    \/\/\/ (which is the bug we're testing for here).\n+    static class GCTrigger {\n+        private final long gcinterval;\n+        private final Thread runner;\n+        private volatile boolean stop;\n+        private final Random RANDOM = RandomFactory.getRandom();\n+\n+        GCTrigger(long gcinterval) {\n+            this.gcinterval = Math.clamp(gcinterval, 100, Long.MAX_VALUE\/2);\n+            runner = Thread.ofPlatform().daemon().unstarted(this::loop);\n+        }\n+\n+        private void loop() {\n+            long min = gcinterval \/ 2;\n+            long max = gcinterval + min;\n+            while (!stop) {\n+                try {\n+                    Thread.sleep(RANDOM.nextLong(min, max));\n+                } catch (InterruptedException x) {\n+                    stop = true;\n+                    break;\n+                }\n+                out.println(now() + \"triggering gc\");\n+                System.gc();\n+            }\n+        }\n+\n+        public void start() {\n+            runner.start();\n+        }\n+\n+        public void stop() throws InterruptedException {\n+            stop = true;\n+            runner.interrupt();\n+            runner.join();\n+        }\n+    }\n+\n+    static GCTrigger gcTrigger;\n@@ -77,1 +188,0 @@\n-    @DataProvider(name = \"positive\")\n@@ -97,1 +207,2 @@\n-    @Test(dataProvider = \"positive\")\n+    @ParameterizedTest\n+    @MethodSource(\"positive\")\n@@ -99,1 +210,1 @@\n-        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        out.printf(\"%n%s---- starting (%s) ----%n\", now(), uriString);\n@@ -104,17 +215,25 @@\n-            out.println(\"iteration: \" + i);\n-            var builder = uriString.contains(\"\/http3\/\")\n-                    ? newClientBuilderForH3()\n-                    : HttpClient.newBuilder();\n-            HttpResponse<InputStream> response = builder\n-                    .sslContext(sslContext)\n-                    .proxy(NO_PROXY)\n-                    .build()\n-                    .sendAsync(request, BodyHandlers.ofInputStream())\n-                    .join();\n-\n-            String body = new String(response.body().readAllBytes(), UTF_8);\n-            out.println(\"Got response: \" + response);\n-            out.println(\"Got body Path: \" + body);\n-\n-            assertEquals(response.statusCode(), 200);\n-            assertEquals(body, MESSAGE);\n+            try {\n+                out.println(now() + \"iteration: \" + i);\n+                var builder = uriString.contains(\"\/http3\/\")\n+                        ? newClientBuilderForH3()\n+                        : HttpClient.newBuilder();\n+                clientCount.incrementAndGet();\n+                HttpResponse<InputStream> response = builder\n+                        .sslContext(sslContext)\n+                        .proxy(NO_PROXY)\n+                        .build()\n+                        .sendAsync(request, BodyHandlers.ofInputStream())\n+                        .join();\n+\n+                String body = new String(response.body().readAllBytes(), UTF_8);\n+                out.println(\"Got response: \" + response);\n+                out.println(\"Got body Path: \" + body);\n+\n+                assertEquals(200, response.statusCode());\n+                assertEquals(MESSAGE, body);\n+            } catch (Throwable t) {\n+                String msg = \"%stest(%s)[%s] failed: %s\"\n+                        .formatted(now(), uriString, i, t);\n+                out.println(msg);\n+                throw new AssertionError(msg, t);\n+            }\n@@ -127,1 +246,1 @@\n-    @BeforeTest\n+    @BeforeAll\n@@ -132,0 +251,1 @@\n+        serverCount.incrementAndGet();\n@@ -136,0 +256,1 @@\n+        serverCount.incrementAndGet();\n@@ -140,0 +261,1 @@\n+        serverCount.incrementAndGet();\n@@ -144,0 +266,1 @@\n+        serverCount.incrementAndGet();\n@@ -148,0 +271,3 @@\n+        serverCount.incrementAndGet();\n+\n+        gcTrigger = new GCTrigger(500);\n@@ -154,0 +280,1 @@\n+        gcTrigger.start();\n@@ -156,1 +283,1 @@\n-    @AfterTest\n+    @AfterAll\n@@ -158,5 +285,26 @@\n-        httpTestServer.stop();\n-        httpsTestServer.stop();\n-        http2TestServer.stop();\n-        https2TestServer.stop();\n-        http3TestServer.stop();\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+            http3TestServer.stop();\n+            gcTrigger.stop();\n+        } finally {\n+            printFailedTests();\n+        }\n+    }\n+\n+    static final void printFailedTests() {\n+        out.println(\"\\n=========================\");\n+        try {\n+            out.printf(\"%n%sCreated %d servers and %d clients%n\",\n+                    now(), serverCount.get(), clientCount.get());\n+            if (FAILURES.isEmpty()) return;\n+            out.println(\"Failed tests: \");\n+            FAILURES.entrySet().forEach((e) -> {\n+                out.printf(\"\\t%s: %s%n\", e.getKey(), e.getValue());\n+                e.getValue().printStackTrace(out);\n+            });\n+        } finally {\n+            out.println(\"\\n=========================\\n\");\n+        }\n","filename":"test\/jdk\/java\/net\/httpclient\/StreamingBody.java","additions":183,"deletions":35,"binary":false,"changes":218,"status":"modified"}]}