{"files":[{"patch":"@@ -34,0 +34,2 @@\n+DEBUG_ONLY(bool AsyncLogWriter::ignore_recursive_logging = false;)\n+\n@@ -35,1 +37,3 @@\n- public:\n+  static Thread* _holder;\n+public:\n+  static Thread* current_holder() { return _holder; }\n@@ -39,0 +43,1 @@\n+    _holder = Thread::current_or_null();\n@@ -42,0 +47,2 @@\n+    assert(_holder == nullptr || _holder == Thread::current_or_null(), \"must be\");\n+    _holder = nullptr;\n@@ -44,0 +51,7 @@\n+\n+  void wait() {\n+    Thread* saved_holder = _holder;\n+    _holder = nullptr;\n+    _instance->_lock.wait(0\/* no timeout *\/);\n+    _holder = saved_holder;\n+  }\n@@ -46,0 +60,2 @@\n+Thread* AsyncLogWriter::AsyncLogLocker::_holder = nullptr;\n+\n@@ -87,1 +103,41 @@\n-void AsyncLogWriter::enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg) {\n+\/\/ This function checks for cases where continuing with asynchronous logging may lead to stability issues, such as a deadlock.\n+\/\/ If this returns true then we give up on logging asynchronously and do so synchronously instead.\n+bool AsyncLogWriter::resort_to_synchronous_logging() {\n+  AsyncLogWriter* alw = AsyncLogWriter::instance();\n+  Thread* holding_thread = AsyncLogWriter::AsyncLogLocker::current_holder();\n+  Thread* this_thread = Thread::current_or_null();\n+  if (this_thread == nullptr) {\n+    \/\/ The current thread is unattached.\n+    return true;\n+  }\n+\n+  if (holding_thread == this_thread) {\n+    \/\/ A thread, while enqueuing a message, has attempted to log something.\n+    \/\/ Do not log while holding the Async log lock.\n+    \/\/ Try to catch possible occurrences in debug builds.\n+#ifdef ASSERT\n+    if (!AsyncLogWriter::ignore_recursive_logging) {\n+      ShouldNotReachHere();\n+    }\n+#endif \/\/ ASSERT\n+    return true;\n+  }\n+\n+  if (alw == nullptr) {\n+    \/\/ There is no AsyncLogWriter instance yet.\n+    return true;\n+  }\n+\n+  if (this_thread == alw) {\n+    \/\/ The async log producer is attempting to log, leading to recursive logging.\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool AsyncLogWriter::enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg) {\n+  if (resort_to_synchronous_logging()) {\n+    return false;\n+  }\n+\n@@ -89,1 +145,4 @@\n-  enqueue_locked(&output, decorations, msg);\n+  DEBUG_ONLY(log_debug(deathtest)(\"Induce a recursive log for testing (for crashing)\");)\n+  DEBUG_ONLY(log_debug(deathtest2)(\"Induce a recursive log for testing\");)\n+  AsyncLogWriter::instance()->enqueue_locked(&output, decorations, msg);\n+  return true;\n@@ -94,2 +153,4 @@\n-void AsyncLogWriter::enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n-  AsyncLogLocker locker;\n+bool AsyncLogWriter::enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  if (resort_to_synchronous_logging()) {\n+    return false;\n+  }\n@@ -97,0 +158,4 @@\n+  \/\/ If we get here we know the AsyncLogWriter is initialized.\n+  AsyncLogLocker locker;\n+  DEBUG_ONLY(log_debug(deathtest)(\"Induce a recursive log for testing (for crashing)\");)\n+  DEBUG_ONLY(log_debug(deathtest2)(\"Induce a recursive log for testing\");)\n@@ -98,1 +163,1 @@\n-    enqueue_locked(&output, msg_iterator.decorations(), msg_iterator.message());\n+    AsyncLogWriter::instance()->enqueue_locked(&output, msg_iterator.decorations(), msg_iterator.message());\n@@ -100,0 +165,1 @@\n+  return true;\n@@ -158,1 +224,1 @@\n-        _lock.wait(0\/* no timeout *\/);\n+        locker.wait();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -198,3 +198,6 @@\n- public:\n-  void enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg);\n-  void enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+  static bool resort_to_synchronous_logging();\n+\n+public:\n+  DEBUG_ONLY(static bool ignore_recursive_logging;)\n+  static bool enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg);\n+  static bool enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -295,3 +295,1 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, decorations, msg);\n+  if (AsyncLogWriter::enqueue(*this, decorations, msg)) {\n@@ -309,4 +307,1 @@\n-\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, msg_iterator);\n+  if (AsyncLogWriter::enqueue(*this, msg_iterator)) {\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -176,3 +176,1 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, decorations, msg);\n+  if (AsyncLogWriter::enqueue(*this, decorations, msg)) {\n@@ -189,3 +187,1 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, msg_iterator);\n+  if (AsyncLogWriter::enqueue(*this, msg_iterator)) {\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+  DEBUG_ONLY(LOG_TAG(deathtest)) \/* Log Internal death test tag *\/ \\\n+  DEBUG_ONLY(LOG_TAG(deathtest2)) \/* Log Internal death test tag *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -80,1 +81,7 @@\n-\n+#ifdef ASSERT\n+  \/\/ If we log for tag deathtest2 then we're testing that recursive logging works.\n+  \/\/ In this case, do not crash when detecting recursive logging.\n+  if (this->contains(LogTagType::_deathtest2)) {\n+    AsyncLogWriter::ignore_recursive_logging = true;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/logging\/logTagSet.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349755\n+ * @summary Perform recursive logging in async UL on purpose\n+ * @requires vm.flagless\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver AsyncDeathTest\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AsyncDeathTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ For deathtest we expect the VM to reach ShouldNotReachHere() and die\n+        ProcessBuilder pb =\n+            ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:async\", \"-Xlog:os,deathtest=debug\", \"-XX:-CreateCoredumpOnCrash\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        \/\/ For deathtest2 we expect the VM to ignore that recursive logging has been detected and handle the case anyway.\n+        ProcessBuilder pb =\n+            ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:async\", \"-Xlog:os,deathtest2=debug\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/AsyncDeathTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"}]}