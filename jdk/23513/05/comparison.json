{"files":[{"patch":"@@ -35,1 +35,3 @@\n- public:\n+  static Thread* _holder;\n+public:\n+  static Thread* current_holder() { return _holder; }\n@@ -39,0 +41,1 @@\n+    _holder = Thread::current_or_null();\n@@ -42,0 +45,2 @@\n+    assert(_holder == nullptr || _holder == Thread::current_or_null(), \"must be\");\n+    _holder = nullptr;\n@@ -44,0 +49,6 @@\n+\n+  void wait() {\n+    _holder = nullptr;\n+    _instance->_lock.wait(0\/* no timeout *\/);\n+    _holder = Thread::current_or_null();\n+  }\n@@ -46,0 +57,2 @@\n+Thread* AsyncLogWriter::AsyncLogLocker::_holder = nullptr;\n+\n@@ -87,1 +100,37 @@\n-void AsyncLogWriter::enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg) {\n+\/\/ This function checks for cases where continuing with asynchronous logging may lead to stability issues, such as a deadlock.\n+\/\/ If this returns true then we give up on logging asynchronously and do so synchronously instead.\n+bool AsyncLogWriter::resort_to_synchronous_logging() {\n+  AsyncLogWriter* alw = AsyncLogWriter::instance();\n+  Thread* holding_thread = AsyncLogWriter::AsyncLogLocker::current_holder();\n+  Thread* this_thread = Thread::current_or_null();\n+  if (this_thread == nullptr) {\n+    \/\/ The current thread is unattached.\n+    return true;\n+  }\n+\n+  if (holding_thread == this_thread) {\n+    \/\/ A thread, while enqueuing a message, has attempted to log something.\n+    \/\/ Do not log while holding the Async log lock.\n+    \/\/ Try to catch possible occurrences in debug builds.\n+    DEBUG_ONLY(ShouldNotReachHere();)\n+    return true;\n+  }\n+\n+  if (alw == nullptr) {\n+    \/\/ There is no AsyncLogWriter instance yet.\n+    return true;\n+  }\n+\n+  if (this_thread == alw) {\n+    \/\/ The async log producer is attempting to log, leading to recursive logging.\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool AsyncLogWriter::enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg) {\n+  if (resort_to_synchronous_logging()) {\n+    return false;\n+  }\n+\n@@ -89,1 +138,3 @@\n-  enqueue_locked(&output, decorations, msg);\n+  NOT_PRODUCT(log_debug(deathtest)(\"Induce a recursive log for testing\");)\n+  AsyncLogWriter::instance()->enqueue_locked(&output, decorations, msg);\n+  return true;\n@@ -94,2 +145,4 @@\n-void AsyncLogWriter::enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n-  AsyncLogLocker locker;\n+bool AsyncLogWriter::enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  if (resort_to_synchronous_logging()) {\n+    return false;\n+  }\n@@ -97,0 +150,3 @@\n+  \/\/ If we get here we know the AsyncLogWriter is initialized.\n+  AsyncLogLocker locker;\n+  NOT_PRODUCT(log_debug(deathtest)(\"Induce a recursive log for testing\");)\n@@ -98,1 +154,1 @@\n-    enqueue_locked(&output, msg_iterator.decorations(), msg_iterator.message());\n+    AsyncLogWriter::instance()->enqueue_locked(&output, msg_iterator.decorations(), msg_iterator.message());\n@@ -100,0 +156,1 @@\n+  return true;\n@@ -158,1 +215,1 @@\n-        _lock.wait(0\/* no timeout *\/);\n+        locker.wait();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":64,"deletions":7,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -198,0 +198,2 @@\n+  static bool resort_to_synchronous_logging();\n+\n@@ -199,2 +201,2 @@\n-  void enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg);\n-  void enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+  static bool enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg);\n+  static bool enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -295,3 +295,1 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, decorations, msg);\n+  if (AsyncLogWriter::enqueue(*this, decorations, msg)) {\n@@ -309,4 +307,1 @@\n-\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, msg_iterator);\n+  if (AsyncLogWriter::enqueue(*this, msg_iterator)) {\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -176,3 +176,1 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, decorations, msg);\n+  if (AsyncLogWriter::enqueue(*this, decorations, msg)) {\n@@ -189,3 +187,1 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, msg_iterator);\n+  if (AsyncLogWriter::enqueue(*this, msg_iterator)) {\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  NOT_PRODUCT(LOG_TAG(deathtest)) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349755\n+ * @summary Perform recursive logging in async UL and observe a crash\n+ * @requires vm.flagless\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver AsyncDeathTestDebug\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AsyncDeathTestDebug {\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb =\n+            ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:async\", \"-Xlog:deathtest=debug\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/AsyncDeathTestDebug.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349755\n+ * @summary Perform recursive logging in async UL and do NOT observe a crash (as opposed to AsyncDeathTestDebug)\n+ * @requires vm.flagless\n+ * @requires !vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver AsyncDeathTestDebug\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AsyncDeathNonProduct {\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb =\n+            ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:async\", \"-Xlog:deathtest=debug\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/AsyncDeathTestNonProduct.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"}]}