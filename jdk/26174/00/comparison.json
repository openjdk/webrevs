{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,6 +47,5 @@\n-\/**\n- * ParserVerifier performs selected checks of the class file format according to\n- * {@jvms 4.8 Format Checking}\n- *\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/classFileParser.cpp\">hotspot\/share\/classfile\/classFileParser.cpp<\/a>\n- *\/\n+\/\/\/ ParserVerifier performs selected checks of the class file format according to\n+\/\/\/ {@jvms 4.8 Format Checking}.\n+\/\/\/\n+\/\/\/ From `classFileParser.cpp`.\n+\/\/\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.hpp\">hotspot\/share\/interpreter\/bytecodes.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.cpp\">hotspot\/share\/interpreter\/bytecodes.cpp<\/a>\n- *\/\n+\/\/\/ From `bytecodes.cpp`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationBytecodes.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.hpp\">hotspot\/share\/classfile\/stackMapFrame.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.cpp\">hotspot\/share\/classfile\/stackMapFrame.cpp<\/a>\n- *\/\n+\/\/\/ From `stackMapFrame.cpp`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationFrame.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+\/\/\/ Relevant parts from `signatures.cpp`, such as `SignatureStream`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationSignature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+\n@@ -31,4 +34,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.hpp\">hotspot\/share\/classfile\/stackMapTable.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.cpp\">hotspot\/share\/classfile\/stackMapTable.cpp<\/a>\n- *\/\n+\/\/\/ From `stackMapTable.cpp`.\n@@ -39,1 +39,1 @@\n-    private final VerificationFrame[] _frame_array;\n+    private final List<VerificationFrame> _frame_array;\n@@ -47,1 +47,1 @@\n-        return _frame_array[index].offset();\n+        return _frame_array.get(index).offset();\n@@ -79,1 +79,1 @@\n-    VerificationTable(byte[] stackmap_data, VerificationFrame init_frame, int max_locals, int max_stack, byte[] code_data, int code_len,\n+    VerificationTable(StackMapReader reader,\n@@ -82,4 +82,3 @@\n-        var reader = new StackMapReader(stackmap_data, code_data, code_len, cp, v);\n-        _code_length = code_len;\n-        _frame_count = reader.get_frame_count();\n-        _frame_array = new VerificationFrame[_frame_count];\n+        _code_length = reader.code_length();\n+        int _frame_count = reader.get_frame_count();\n+        _frame_array = new ArrayList<>(_frame_count);\n@@ -87,7 +86,4 @@\n-            VerificationFrame pre_frame = init_frame;\n-            for (int i = 0; i < _frame_count; i++) {\n-                VerificationFrame frame = reader.next(pre_frame, i == 0, max_locals, max_stack);\n-                _frame_array[i] = frame;\n-                int offset = frame.offset();\n-                if (offset >= code_len || code_data[offset] == 0) {\n-                    _verifier.verifyError(\"StackMapTable error: bad offset\");\n+            while (!reader.at_end()) {\n+                VerificationFrame frame = reader.next();\n+                if (frame != null) {\n+                    _frame_array.add(frame);\n@@ -95,1 +91,0 @@\n-                pre_frame = frame;\n@@ -99,0 +94,1 @@\n+        this._frame_count = _frame_array.size();\n@@ -104,1 +100,1 @@\n-            if (_frame_array[i].offset() == offset) {\n+            if (_frame_array.get(i).offset() == offset) {\n@@ -120,1 +116,1 @@\n-        VerificationFrame stackmap_frame = _frame_array[frame_index];\n+        VerificationFrame stackmap_frame = _frame_array.get(frame_index);\n@@ -154,0 +150,4 @@\n+        private int _parsed_frame_count;\n+        private VerificationFrame _prev_frame;\n+        char _max_locals, _max_stack;\n+        boolean _first;\n@@ -170,0 +170,27 @@\n+        public VerificationFrame prev_frame() {\n+            return _prev_frame;\n+        }\n+\n+        public byte[] code_data() {\n+            return _code_data;\n+        }\n+\n+        public int code_length() {\n+            return _code_length;\n+        }\n+\n+        public boolean at_end() {\n+            return _stream.at_end();\n+        }\n+\n+        public VerificationFrame next() {\n+            _parsed_frame_count++;\n+            check_size();\n+            VerificationFrame frame = next_helper();\n+            if (frame != null) {\n+                check_offset(frame);\n+                _prev_frame = frame;\n+            }\n+            return frame;\n+        }\n+\n@@ -171,2 +198,2 @@\n-            if (!_stream.at_end()) {\n-                _verifier.classError(\"wrong attribute size\");\n+            if (_frame_count != _parsed_frame_count) {\n+                _verifier.verifyError(\"wrong attribute size\");\n@@ -178,1 +205,3 @@\n-        public StackMapReader(byte[] stackmapData, byte[] code_data, int code_len, VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl context) {\n+        public StackMapReader(byte[] stackmapData, byte[] code_data, int code_len,\n+                              VerificationFrame init_frame, char max_locals, char max_stack,\n+                              VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl context) {\n@@ -181,0 +210,7 @@\n+            _code_data = code_data;\n+            _code_length = code_len;\n+            _parsed_frame_count = 0;\n+            _prev_frame = init_frame;\n+            _max_locals = max_locals;\n+            _max_stack = max_stack;\n+            _first = true;\n@@ -182,0 +218,1 @@\n+                _cp = cp;\n@@ -184,0 +221,1 @@\n+                _cp = null;\n@@ -186,3 +224,13 @@\n-            _code_data = code_data;\n-            _code_length = code_len;\n-            _cp = cp;\n+        }\n+\n+        void check_offset(VerificationFrame frame) {\n+            int offset = frame.offset();\n+            if (offset >= _code_length || _code_data[offset] == 0) {\n+                _verifier.verifyError(\"StackMapTable error: bad offset\");\n+            }\n+        }\n+\n+        void check_size() {\n+            if (_frame_count < _parsed_frame_count) {\n+                _verifier.verifyError(\"wrong attribute size\");\n+            }\n@@ -235,1 +283,1 @@\n-        public VerificationFrame next(VerificationFrame pre_frame, boolean first, int max_locals, int max_stack) {\n+        VerificationFrame next_helper() {\n@@ -241,1 +289,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -243,2 +291,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -247,2 +295,2 @@\n-                    offset = pre_frame.offset() + frame_type + 1;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + frame_type + 1;\n+                    locals = _prev_frame.locals();\n@@ -250,3 +298,3 @@\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), 0, max_locals, max_stack, locals, null, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), 0, _max_locals, _max_stack, locals, null, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -254,0 +302,1 @@\n+                _first = false;\n@@ -257,1 +306,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -259,2 +308,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -263,2 +312,2 @@\n-                    offset = pre_frame.offset() + frame_type - 63;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + frame_type - 63;\n+                    locals = _prev_frame.locals();\n@@ -273,4 +322,4 @@\n-                check_verification_type_array_size(stack_size, max_stack);\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                check_verification_type_array_size(stack_size, _max_stack);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -278,0 +327,1 @@\n+                _first = false;\n@@ -285,1 +335,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -287,2 +337,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -291,2 +341,2 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n+                    locals = _prev_frame.locals();\n@@ -301,4 +351,4 @@\n-                check_verification_type_array_size(stack_size, max_stack);\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                check_verification_type_array_size(stack_size, _max_stack);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -306,0 +356,1 @@\n+                _first = false;\n@@ -309,2 +360,2 @@\n-                locals = pre_frame.locals();\n-                int length = pre_frame.locals_size();\n+                locals = _prev_frame.locals();\n+                int length = _prev_frame.locals_size();\n@@ -313,1 +364,1 @@\n-                int flags = pre_frame.flags();\n+                int flags = _prev_frame.flags();\n@@ -316,1 +367,1 @@\n-                    check_verification_type_array_size(new_length, max_locals);\n+                    check_verification_type_array_size(new_length, _max_locals);\n@@ -325,1 +376,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -333,1 +384,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -335,3 +386,3 @@\n-                frame = new VerificationFrame(offset, flags, new_length, 0, max_locals, max_stack, locals, null, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                frame = new VerificationFrame(offset, flags, new_length, 0, _max_locals, _max_stack, locals, null, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -339,0 +390,1 @@\n+                _first = false;\n@@ -342,1 +394,1 @@\n-                int real_length = pre_frame.locals_size();\n+                int real_length = _prev_frame.locals_size();\n@@ -345,1 +397,1 @@\n-                VerificationType[] pre_locals = pre_frame.locals();\n+                VerificationType[] pre_locals = _prev_frame.locals();\n@@ -347,1 +399,1 @@\n-                for (i=0; i<pre_frame.locals_size(); i++) {\n+                for (i=0; i< _prev_frame.locals_size(); i++) {\n@@ -350,1 +402,1 @@\n-                int[] flags = new int[]{pre_frame.flags()};\n+                int[] flags = new int[]{_prev_frame.flags()};\n@@ -359,2 +411,2 @@\n-                check_verification_type_array_size(real_length, max_locals);\n-                if (first) {\n+                check_verification_type_array_size(real_length, _max_locals);\n+                if (_first) {\n@@ -363,1 +415,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -365,1 +417,2 @@\n-                frame = new VerificationFrame(offset, flags[0], real_length, 0, max_locals, max_stack, locals, null, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_length, 0, _max_locals, _max_stack, locals, null, _verifier);\n+                _first = false;\n@@ -380,1 +433,1 @@\n-                            locals[real_locals_size].to_category2_2nd(_verifier);\n+                                locals[real_locals_size].to_category2_2nd(_verifier);\n@@ -385,1 +438,1 @@\n-                check_verification_type_array_size(real_locals_size, max_locals);\n+                check_verification_type_array_size(real_locals_size, _max_locals);\n@@ -400,2 +453,2 @@\n-                check_verification_type_array_size(real_stack_size, max_stack);\n-                if (first) {\n+                check_verification_type_array_size(real_stack_size, _max_stack);\n+                if (_first) {\n@@ -404,1 +457,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -406,1 +459,2 @@\n-                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, max_locals, max_stack, locals, stack, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                _first = false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationTable.java","additions":132,"deletions":78,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.hpp\">hotspot\/share\/classfile\/verificationType.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.cpp\">hotspot\/share\/classfile\/verificationType.cpp<\/a>\n- *\/\n+\/\/\/ From `verificationType.cpp`.\n@@ -335,1 +332,1 @@\n-                        return is_reference_assignable_from(from, context);\n+                        return is_reference_assignable_from(from, context, null);\n@@ -382,1 +379,2 @@\n-    boolean resolve_and_check_assignability(ClassHierarchyImpl assignResolver, String name, String from_name, boolean from_is_array, boolean from_is_object) {\n+    boolean resolve_and_check_assignability(ClassHierarchyImpl assignResolver, String target_name, String from_name,\n+                                            boolean from_is_array, boolean from_is_object, boolean[] target_is_interface) {\n@@ -384,3 +382,9 @@\n-        var desc = Util.toClassDesc(name);\n-        if (assignResolver.isInterface(desc)) {\n-            return !from_is_array || \"java\/lang\/Cloneable\".equals(name) || \"java\/io\/Serializable\".equals(name);\n+        var targetClass = Util.toClassDesc(target_name);\n+        boolean isInterface = assignResolver.isInterface(targetClass);\n+\n+        if (target_is_interface != null) {\n+            target_is_interface[0] = isInterface;\n+        }\n+\n+        if (isInterface) {\n+            return !from_is_array || \"java\/lang\/Cloneable\".equals(target_name) || \"java\/io\/Serializable\".equals(target_name);\n@@ -388,1 +392,1 @@\n-            return assignResolver.isAssignableFrom(desc, Util.toClassDesc(from_name));\n+            return assignResolver.isAssignableFrom(targetClass, Util.toClassDesc(from_name));\n@@ -393,1 +397,1 @@\n-    boolean is_reference_assignable_from(VerificationType from, VerifierImpl context) {\n+    boolean is_reference_assignable_from(VerificationType from, VerifierImpl context, boolean[] target_is_interface) {\n@@ -405,1 +409,1 @@\n-            return resolve_and_check_assignability(clsTree, name(), from.name(), from.is_array(), from.is_object());\n+            return resolve_and_check_assignability(clsTree, name(), from.name(), from.is_array(), from.is_object(), target_is_interface);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationType.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,10 +45,6 @@\n-\/**\n- * VerifierImpl performs selected checks and verifications of the class file\n- * format according to {@jvms 4.8 Format Checking},\n- * {@jvms 4.9 Constraints on Java Virtual Machine code},\n- * {@jvms 4.10 Verification of class Files} and {@jvms 6.5 Instructions}\n- *\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/java.base\/share\/native\/include\/classfile_constants.h.template\">java.base\/share\/native\/include\/classfile_constants.h.template<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.hpp\">hotspot\/share\/classfile\/verifier.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.cpp\">hotspot\/share\/classfile\/verifier.cpp<\/a>\n- *\/\n+\/\/\/ VerifierImpl performs selected checks and verifications of the class file\n+\/\/\/ format according to {@jvms 4.8 Format Checking},\n+\/\/\/ {@jvms 4.9 Constraints on Java Virtual Machine code},\n+\/\/\/ {@jvms 4.10 Verification of class Files} and {@jvms 6.5 Instructions}\n+\/\/\/\n+\/\/\/ From `verifier.cpp`.\n@@ -145,5 +141,2 @@\n-        String name = klass.thisClassName();\n-        return !java_lang_Object.equals(name) &&\n-                !java_lang_Class.equals(name) &&\n-                !java_lang_String.equals(name) &&\n-                !java_lang_Throwable.equals(name);\n+        \/\/ 8330606 Not applicable here\n+        return true;\n@@ -326,1 +319,3 @@\n-        VerificationTable stackmap_table = new VerificationTable(stackmap_data, current_frame, max_locals, max_stack, code_data, code_length, cp, this);\n+        var reader = new VerificationTable.StackMapReader(stackmap_data, code_data, code_length, current_frame,\n+                (char) max_locals, (char) max_stack, cp, this);\n+        VerificationTable stackmap_table = new VerificationTable(reader, cp, this);\n@@ -1273,0 +1268,1 @@\n+                \/\/ 8267118 Not applicable here\n@@ -1356,1 +1352,1 @@\n-        if ((types & (1 << tag))== 0) {\n+        if (tag > JVM_CONSTANT_ExternalMax || (types & (1 << tag))== 0) {\n@@ -1435,2 +1431,2 @@\n-            keys = high - low + 1;\n-            if (keys < 0) {\n+            long keys64 = ((long) high - low) + 1;\n+            if (keys64 > 65535) {  \/\/ Max code length\n@@ -1439,0 +1435,1 @@\n+            keys = (int) keys64;\n@@ -1495,0 +1492,1 @@\n+                \/\/ 8270398 Not applicable here\n@@ -1646,3 +1644,16 @@\n-            boolean have_imr_indirect = cp.tagAt(index) == JVM_CONSTANT_InterfaceMethodref;\n-            boolean subtype = ref_class_type.is_assignable_from(current_type(), this);\n-            if (!subtype) {\n+\n+            \/\/ We know it is not current class, direct superinterface or immediate superclass. That means it\n+            \/\/ could be:\n+            \/\/ - a totally unrelated class or interface\n+            \/\/ - an indirect superinterface\n+            \/\/ - an indirect superclass (including Object)\n+            \/\/ We use the assignability test to see if it is a superclass, or else an interface, and keep track\n+            \/\/ of the latter. Note that subtype can be true if we are dealing with an interface that is not actually\n+            \/\/ implemented as assignability treats all interfaces as Object.\n+\n+            boolean[] is_interface = {false}; \/\/ This can only be set true if the assignability check will return true\n+                                              \/\/ and we loaded the class. For any other \"true\" returns (e.g. same class\n+                                              \/\/ or Object) we either can't get here (same class already excluded above)\n+                                              \/\/ or we know it is not an interface (i.e. Object).\n+            boolean subtype = ref_class_type.is_reference_assignable_from(current_type(), this, is_interface);\n+            if (!subtype) {  \/\/ Totally unrelated class\n@@ -1650,2 +1661,6 @@\n-            } else if (have_imr_indirect) {\n-                verifyError(\"Bad invokespecial instruction: interface method reference is in an indirect superinterface.\");\n+            } else {\n+                \/\/ Indirect superclass (including Object), indirect interface, or unrelated interface.\n+                \/\/ Any interface use is an error.\n+                if (is_interface[0]) {\n+                    verifyError(\"Bad invokespecial instruction: interface method to invoke is not in a direct superinterface.\");\n+                }\n@@ -1820,1 +1835,1 @@\n-            verifyError(\"Method expects a return value\");\n+            verifyError(\"Method does not expect a return value\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":41,"deletions":26,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+The Class-File Verifier\n+===\n+The Class-File API provides a verifier, a debug utility that reports as many\n+verification errors as possible in a class file.\n+\n+Currently, the verifier closely follows the C++ code that implements the hotspot\n+verifier. However, there are a few differences:\n+- The Class-File API verifier tries to collect as many errors as possible, while\n+  the hotspot verifier fails fast.\n+- The hotspot verifier has access to other classes and can check access control;\n+  the Class-File API verifier cannot.\n+\n+Thus, this verifier cannot serve as a complete implementation of the verifier\n+specified in the JVMS because it has no access to other class files or loaded\n+classes.  However, it is still in our interest to make this verifier up to date:\n+for example, this should not fail upon encountering new language features, and\n+should at best include all new checks hotspot has as long as the required\n+information are accessible to the Class-File API.\n+\n+Last sync: jdk-26+5, July 3rd 2025\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/verifier.md","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8333812\n+ * @bug 8333812 8361526\n@@ -34,0 +34,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.JAVA_8_VERSION;\n@@ -36,0 +38,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -45,0 +48,1 @@\n+import java.util.Map;\n@@ -416,0 +420,23 @@\n+\n+    @Test \/\/ JDK-8350029\n+    void testInvokeSpecialInterfacePatch() {\n+        var runClass = ClassDesc.of(\"Run\");\n+        var testClass = ClassDesc.of(\"Test\");\n+        var runnableClass = Runnable.class.describeConstable().orElseThrow();\n+        var chr = ClassHierarchyResolver.of(List.of(), Map.of(runClass, CD_Object))\n+                .orElse(ClassHierarchyResolver.defaultResolver()).cached();\n+        var context = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(chr));\n+\n+        for (var isInterface : new boolean[] {true, false}) {\n+            var bytes = context.build(testClass, clb -> clb\n+                    .withVersion(JAVA_8_VERSION, 0)\n+                    .withSuperclass(runClass)\n+                    .withMethodBody(\"test\", MethodTypeDesc.of(CD_void, testClass), ACC_STATIC, cob -> cob\n+                            .aload(0)\n+                            .invokespecial(runnableClass, \"run\", MTD_void, isInterface)\n+                            .return_()));\n+            var errors = context.verify(bytes);\n+            assertNotEquals(List.of(), errors, \"invokespecial, isInterface = \" + isInterface);\n+            assertTrue(errors.getFirst().getMessage().contains(\"interface method to invoke is not in a direct superinterface\"), errors.getFirst().getMessage());\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"}]}