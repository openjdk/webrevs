{"files":[{"patch":"@@ -547,0 +547,6 @@\n+    \/**\n+     * Flag indicating whether this formatter only uses ChronoField instances.\n+     * This is used to optimize the storage of parsed field values in the Parsed class.\n+     *\/\n+    final boolean onlyChronoField;\n+\n@@ -1477,0 +1483,1 @@\n+     * @param onlyChronoField  flag indicating whether this formatter only uses ChronoField instances\n@@ -1481,1 +1488,1 @@\n-            Chronology chrono, ZoneId zone) {\n+            Chronology chrono, ZoneId zone, boolean onlyChronoField) {\n@@ -1489,0 +1496,1 @@\n+        this.onlyChronoField = onlyChronoField;\n@@ -1526,1 +1534,1 @@\n-        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n+        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone, onlyChronoField);\n@@ -1572,1 +1580,1 @@\n-            return new DateTimeFormatter(printerParser, locale, ds, resolverStyle, resolverFields, c, z);\n+            return new DateTimeFormatter(printerParser, locale, ds, resolverStyle, resolverFields, c, z, onlyChronoField);\n@@ -1598,1 +1606,1 @@\n-        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n+        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone, onlyChronoField);\n@@ -1652,1 +1660,1 @@\n-        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n+        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone, onlyChronoField);\n@@ -1709,1 +1717,1 @@\n-        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n+        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone, onlyChronoField);\n@@ -1751,1 +1759,1 @@\n-        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n+        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone, onlyChronoField);\n@@ -1817,1 +1825,1 @@\n-        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, fields, chrono, zone);\n+        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, fields, chrono, zone, onlyChronoField);\n@@ -1866,1 +1874,1 @@\n-        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n+        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone, onlyChronoField);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -203,0 +203,6 @@\n+    \/**\n+     * Flag indicating whether this builder only uses ChronoField instances.\n+     * This is used to optimize the storage of parsed field values in the Parsed class.\n+     *\/\n+    private boolean onlyChronoField = true;\n+\n@@ -2374,0 +2380,3 @@\n+\n+        \/\/ Update the onlyChronoField flag if the printer\/parser uses non-ChronoField instances\n+        checkField(pp);\n@@ -2379,0 +2388,21 @@\n+    \/**\n+     * Update the onlyChronoField flag if the printer\/parser uses non-ChronoField instances\n+     * @param pp the printer-parser\n+     *\/\n+    private void checkField(DateTimePrinterParser pp) {\n+        TemporalField field;\n+        if (pp instanceof NumberPrinterParser npp) {\n+            field = npp.field;\n+        } else if (pp instanceof TextPrinterParser tpp) {\n+            field = tpp.field;\n+        } else if (pp instanceof DefaultValueParser dvp) {\n+            field = dvp.field;\n+        } else {\n+            return;\n+        }\n+\n+        if (!(field instanceof ChronoField)) {\n+            active.onlyChronoField = false;\n+        }\n+    }\n+\n@@ -2446,1 +2476,1 @@\n-                resolverStyle, null, chrono, null);\n+                resolverStyle, null, chrono, null, onlyChronoField);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-        parsed.add(new Parsed());\n+        parsed.add(new Parsed(formatter.onlyChronoField));\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeParseContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -101,0 +102,1 @@\n+import java.util.EnumMap;\n@@ -131,1 +133,1 @@\n-    final Map<TemporalField, Long> fieldValues = new HashMap<>();\n+    final Map<TemporalField, Long> fieldValues;\n@@ -172,1 +174,6 @@\n-    Parsed() {\n+    @SuppressWarnings(\"unchecked\")\n+    Parsed(boolean onlyChronoField) {\n+        \/\/ Create the EnumMap with raw types and cast it appropriately\n+        \/\/ This is safe because ChronoField implements TemporalField\n+        fieldValues = onlyChronoField ? (Map<TemporalField, Long>) (Map) new EnumMap<>(ChronoField.class)\n+                                      : new HashMap<>();\n@@ -180,1 +187,1 @@\n-        Parsed cloned = new Parsed();\n+        Parsed cloned = new Parsed(fieldValues instanceof EnumMap);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/Parsed.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.time.format;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class DateTimeFormatterParse {\n+    static final DateTimeFormatter formatterLocalTime = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n+    static final DateTimeFormatter formatterLocalTimeWithNano = DateTimeFormatter.ofPattern(\"HH:mm:ss.SSS\");\n+    static final DateTimeFormatter formatterLocalDate = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    static final DateTimeFormatter formatterLocalDateTime = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\");\n+    static final DateTimeFormatter formatterLocalDateTimeWithNano = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\");\n+    static final DateTimeFormatter formatterOffsetDateTime = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSSSSZZZZZ\");\n+    static final DateTimeFormatter formatterZonedDateTime = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSSSSZZZZZ'['VV']'\");\n+\n+    static final String STR_LOCALTIME = \"21:11:48\";\n+    static final String STR_LOCALTIME_WITH_NANO = \"21:11:48.456\";\n+    static final String STR_LOCALDATE = \"2024-08-01\";\n+    static final String STR_LOCALDATETIME = \"2024-08-01T21:11:48\";\n+    static final String STR_LOCALDATETIME_WITH_NANO = \"2024-08-01T21:11:48.456\";\n+    static final String STR_INSTANT = \"2024-08-12T03:25:54.980339Z\";\n+    static final String STR_OFFSETDATETIME = \"2024-08-12T11:50:46.731509+08:00\";\n+    static final String STR_ZONEDDATETIME = \"2024-08-12T11:50:46.731509+08:00[Asia\/Shanghai]\";\n+\n+    @Benchmark\n+    public LocalTime parseLocalTime() {\n+        return LocalTime.parse(STR_LOCALTIME, formatterLocalTime);\n+    }\n+\n+    @Benchmark\n+    public LocalTime parseLocalTimeWithNano() {\n+        return LocalTime.parse(STR_LOCALTIME_WITH_NANO, formatterLocalTimeWithNano);\n+    }\n+\n+    @Benchmark\n+    public LocalDate parseLocalDate() {\n+        return LocalDate.parse(STR_LOCALDATE, formatterLocalDate);\n+    }\n+\n+    @Benchmark\n+    public LocalDateTime parseLocalDateTime() {\n+        return LocalDateTime.parse(STR_LOCALDATETIME, formatterLocalDateTime);\n+    }\n+\n+    @Benchmark\n+    public LocalDateTime parseLocalDateTimeWithNano() {\n+        return LocalDateTime.parse(STR_LOCALDATETIME_WITH_NANO, formatterLocalDateTimeWithNano);\n+    }\n+\n+    @Benchmark\n+    public OffsetDateTime parseOffsetDateTime() {\n+        return OffsetDateTime.parse(STR_OFFSETDATETIME, formatterOffsetDateTime);\n+    }\n+\n+    @Benchmark\n+    public ZonedDateTime parseZonedDateTime() {\n+        return ZonedDateTime.parse(STR_ZONEDDATETIME, formatterZonedDateTime);\n+    }\n+\n+    @Benchmark\n+    public Instant parseInstant() {\n+        return Instant.parse(STR_INSTANT);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/format\/DateTimeFormatterParse.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}