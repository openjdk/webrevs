{"files":[{"patch":"@@ -190,1 +190,4 @@\n-  _memory_slices.find_memory_slices();\n+  VStatus slices_status = _memory_slices.find_memory_slices();\n+  if (!slices_status.is_success()) {\n+    return slices_status;\n+  }\n@@ -210,1 +213,3 @@\n-\/\/ - No memory phi: only loads. All have the same input memory state from before the loop.\n+\/\/ - No memory phi: only loads.\n+\/\/   - Usually, all loads have the same input memory state from before the loop.\n+\/\/   - Only rarely this is not the case, and we just bail out for now.\n@@ -212,1 +217,1 @@\n-void VLoopMemorySlices::find_memory_slices() {\n+VStatus VLoopMemorySlices::find_memory_slices() {\n@@ -231,2 +236,9 @@\n-        assert(_inputs.at(alias_idx) == nullptr || _inputs.at(alias_idx) == load->in(1),\n-               \"not yet touched or the same input\");\n+        \/\/ For now, we can only handle slices with a single memory input before the loop,\n+        \/\/ so if we find multiple, we bail out of auto vectorization. If this becomes\n+        \/\/ too restrictive in the fututure, we could consider tracking multiple inputs.\n+        \/\/ Different memory inputs can for example happen if one load has its memory state\n+        \/\/ optimized, and the other load fails to have it optimized, for example because\n+        \/\/ it does not end up on the IGVN worklist any more.\n+        if (_inputs.at(alias_idx) != nullptr && _inputs.at(alias_idx) != load->in(1)) {\n+          return VStatus::make_failure(FAILURE_DIFFERENT_MEMORY_INPUT);\n+        }\n@@ -246,0 +258,1 @@\n+  return VStatus::make_success();\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -507,0 +507,2 @@\n+  static constexpr char const* FAILURE_DIFFERENT_MEMORY_INPUT = \"Load only slice has multiple memory inputs\";\n+\n@@ -524,1 +526,1 @@\n-  void find_memory_slices();\n+  VStatus find_memory_slices();\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=all-flags\n+ * @summary Test a case where we can have one memory slice that has only loads,\n+ *          but the loads from the slice do not have all the same input memory\n+ *          state from before the loop. This is rather rare but it can happen.\n+ * @bug 8373453\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,${test.main.class}::test\n+ *      -Xbatch -XX:-TieredCompilation\n+ *      ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=fewer-flags\n+ * @bug 8373453\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,${test.main.class}::test\n+ *      ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8373453\n+ * @run main ${test.main.class}\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestLoadSliceWithMultipleMemoryInputStates {\n+    static void test() {\n+        \/\/ The relevant slice is the value field of the Byte Objects.\n+        Byte x = 1;\n+\n+        for (int i = 0; i < 2; i++) {\n+            if ((i & 1) == 0) {\n+                \/\/ Not sure what this loop is needed for, but it is very sensitive,\n+                \/\/ I cannot even replace N with 32.\n+                int N = 32;\n+                for (int j = 0; j < N; j++) {\n+                    if (j == 1) {\n+                        x = (byte) x;\n+                    }\n+                }\n+\n+                for (int j = 0; j < 32; j++) {\n+                    \/\/ The call below has an effect on the memory state\n+                    \/\/ If we optimize the Load for Byte::value, we can bypass\n+                    \/\/ this call, since we know that Byte::value cannot be\n+                    \/\/ modified during the call.\n+                    Object o = 1;\n+                    o.toString();\n+\n+                    for (int k = 0; k < 32; k++) { \/\/ OSR around here\n+                        \/\/ Loads of x byte field have different memory input states\n+                        \/\/ This is because some loads can split their memory state\n+                        \/\/ through a phi further up, and others are not put back on\n+                        \/\/ the IGVN worklist and are thus not optimized and keep\n+                        \/\/ the old memory state. Both are correct though.\n+                        x = (byte) (x + 1);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestLoadSliceWithMultipleMemoryInputStates.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}