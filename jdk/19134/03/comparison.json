{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -5683,12 +5683,2 @@\n-        long q1, r_tmp;\n-        if (v1 == 1) {\n-            q1 = tmp;\n-            r_tmp = 0;\n-        } else if (tmp >= 0) {\n-            q1 = tmp \/ v1;\n-            r_tmp = tmp - q1 * v1;\n-        } else {\n-            long[] rq = divRemNegativeLong(tmp, v1);\n-            q1 = rq[1];\n-            r_tmp = rq[0];\n-        }\n+        long q1 = Long.divideUnsigned(tmp, v1);\n+        long r_tmp = Long.remainderUnsigned(tmp, v1);\n@@ -5705,12 +5695,2 @@\n-        long q0;\n-        if (v1 == 1) {\n-            q0 = tmp;\n-            r_tmp = 0;\n-        } else if (tmp >= 0) {\n-            q0 = tmp \/ v1;\n-            r_tmp = tmp - q0 * v1;\n-        } else {\n-            long[] rq = divRemNegativeLong(tmp, v1);\n-            q0 = rq[1];\n-            r_tmp = rq[0];\n-        }\n+        long q0 = Long.divideUnsigned(tmp, v1);\n+        r_tmp = Long.remainderUnsigned(tmp, v1);\n@@ -5796,31 +5776,0 @@\n-    \/**\n-     * Calculate the quotient and remainder of dividing a negative long by\n-     * another long.\n-     *\n-     * @param n the numerator; must be negative\n-     * @param d the denominator; must not be unity\n-     * @return a two-element {@code long} array with the remainder and quotient in\n-     *         the initial and final elements, respectively\n-     *\/\n-    private static long[] divRemNegativeLong(long n, long d) {\n-        assert n < 0 : \"Non-negative numerator \" + n;\n-        assert d != 1 : \"Unity denominator\";\n-\n-        \/\/ Approximate the quotient and remainder\n-        long q = (n >>> 1) \/ (d >>> 1);\n-        long r = n - q * d;\n-\n-        \/\/ Correct the approximation\n-        while (r < 0) {\n-            r += d;\n-            q--;\n-        }\n-        while (r >= d) {\n-            r -= d;\n-            q++;\n-        }\n-\n-        \/\/ n - q*d == r && 0 <= r < d, hence we're done.\n-        return new long[] {r, q};\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":5,"deletions":56,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1095,3 +1095,3 @@\n-            long dividendValue = value[offset] & LONG_MASK;\n-            int q = (int) (dividendValue \/ divisorLong);\n-            int r = (int) (dividendValue - q * divisorLong);\n+            int dividendValue = value[offset];\n+            int q = Integer.divideUnsigned(dividendValue, divisor);\n+            int r = Integer.remainderUnsigned(dividendValue, divisor);\n@@ -1109,15 +1109,3 @@\n-        \/\/ Normalize the divisor\n-        int shift = Integer.numberOfLeadingZeros(divisor);\n-\n-        int rem = value[offset];\n-        long remLong = rem & LONG_MASK;\n-        if (remLong < divisorLong) {\n-            quotient.value[0] = 0;\n-        } else {\n-            quotient.value[0] = (int)(remLong \/ divisorLong);\n-            rem = (int) (remLong - (quotient.value[0] * divisorLong));\n-            remLong = rem & LONG_MASK;\n-        }\n-        int xlen = intLen;\n-        while (--xlen > 0) {\n-            long dividendEstimate = (remLong << 32) |\n+        long rem = 0;\n+        for (int xlen = intLen; xlen > 0; xlen--) {\n+            long dividendEstimate = (rem << 32) |\n@@ -1125,9 +1113,2 @@\n-            int q;\n-            if (dividendEstimate >= 0) {\n-                q = (int) (dividendEstimate \/ divisorLong);\n-                rem = (int) (dividendEstimate - q * divisorLong);\n-            } else {\n-                long tmp = divWord(dividendEstimate, divisor);\n-                q = (int) (tmp & LONG_MASK);\n-                rem = (int) (tmp >>> 32);\n-            }\n+            int q = (int) Long.divideUnsigned(dividendEstimate, divisorLong);\n+            rem = Long.remainderUnsigned(dividendEstimate, divisorLong);\n@@ -1135,1 +1116,0 @@\n-            remLong = rem & LONG_MASK;\n@@ -1139,5 +1119,1 @@\n-        \/\/ Unnormalize\n-        if (shift > 0)\n-            return rem % divisor;\n-        else\n-            return rem;\n+        return (int)rem;\n@@ -1560,8 +1536,2 @@\n-                if (nChunk >= 0) {\n-                    qhat = (int) (nChunk \/ dhLong);\n-                    qrem = (int) (nChunk - (qhat * dhLong));\n-                } else {\n-                    long tmp = divWord(nChunk, dh);\n-                    qhat = (int) (tmp & LONG_MASK);\n-                    qrem = (int) (tmp >>> 32);\n-                }\n+                qhat = (int) Long.divideUnsigned(nChunk, dhLong);\n+                qrem = (int) Long.remainderUnsigned(nChunk, dhLong);\n@@ -1619,8 +1589,2 @@\n-            if (nChunk >= 0) {\n-                qhat = (int) (nChunk \/ dhLong);\n-                qrem = (int) (nChunk - (qhat * dhLong));\n-            } else {\n-                long tmp = divWord(nChunk, dh);\n-                qhat = (int) (tmp & LONG_MASK);\n-                qrem = (int) (tmp >>> 32);\n-            }\n+            qhat = (int) Long.divideUnsigned(nChunk, dhLong);\n+            qrem = (int) Long.remainderUnsigned(nChunk, dhLong);\n@@ -1735,8 +1699,2 @@\n-                if (nChunk >= 0) {\n-                    qhat = (int) (nChunk \/ dhLong);\n-                    qrem = (int) (nChunk - (qhat * dhLong));\n-                } else {\n-                    long tmp = divWord(nChunk, dh);\n-                    qhat =(int)(tmp & LONG_MASK);\n-                    qrem = (int)(tmp>>>32);\n-                }\n+                qhat = (int) Long.divideUnsigned(nChunk, dhLong);\n+                qrem = (int) Long.remainderUnsigned(nChunk, dhLong);\n@@ -1837,34 +1795,0 @@\n-    \/**\n-     * This method divides a long quantity by an int to estimate\n-     * qhat for two multi precision numbers. It is used when\n-     * the signed value of n is less than zero.\n-     * Returns long value where high 32 bits contain remainder value and\n-     * low 32 bits contain quotient value.\n-     *\/\n-    static long divWord(long n, int d) {\n-        long dLong = d & LONG_MASK;\n-        long r;\n-        long q;\n-        if (dLong == 1) {\n-            q = (int)n;\n-            r = 0;\n-            return (r << 32) | (q & LONG_MASK);\n-        }\n-\n-        \/\/ Approximate the quotient and remainder\n-        q = (n >>> 1) \/ (dLong >>> 1);\n-        r = n - q*dLong;\n-\n-        \/\/ Correct the approximation\n-        while (r < 0) {\n-            r += dLong;\n-            q--;\n-        }\n-        while (r >= dLong) {\n-            r -= dLong;\n-            q++;\n-        }\n-        \/\/ n - q*dlong == r && 0 <= r <dLong, hence we're done.\n-        return (r << 32) | (q & LONG_MASK);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":16,"deletions":92,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,9 +136,0 @@\n-    \/** Invokes the toString method of BigDecimal with various different values. *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testToString(Blackhole bh) {\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(s.toString());\n-        }\n-    }\n-\n@@ -197,1 +188,1 @@\n-    \/** Invokes the compareTo method of BigDecimal with various different values. *\/\n+    \/** Test divide with huge\/small numbers *\/\n@@ -199,5 +190,6 @@\n-    @OperationsPerInvocation(TEST_SIZE - 1)\n-    public void testCompareTo(Blackhole bh) {\n-        BigDecimal c = bigDecimals[0];\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(c.compareTo(s));\n+    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n+    public void testHugeSmallDivide(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            for (BigDecimal t : smallArray) {\n+                bh.consume(s.divide(t, RoundingMode.DOWN));\n+            }\n@@ -207,1 +199,1 @@\n-    \/** Test BigDecimal.toString() with huge numbers larger than MAX_LONG *\/\n+    \/** Test divide with large\/small numbers *\/\n@@ -209,4 +201,6 @@\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testHugeToString(Blackhole bh) {\n-        for (BigDecimal s : hugeArray) {\n-            bh.consume(s.toString());\n+    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n+    public void testLargeSmallDivide(Blackhole bh) {\n+        for (BigDecimal s : largeArray) {\n+            for (BigDecimal t : smallArray) {\n+                bh.consume(s.divide(t, RoundingMode.DOWN));\n+            }\n@@ -216,1 +210,1 @@\n-    \/** Test BigDecimal.toString() with large numbers less than MAX_LONG but larger than MAX_INT *\/\n+    \/** Test divide with huge\/large numbers *\/\n@@ -218,4 +212,6 @@\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testLargeToString(Blackhole bh) {\n-        for (BigDecimal s : largeArray) {\n-            bh.consume(s.toString());\n+    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n+    public void testHugeLargeDivide(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            for (BigDecimal t : largeArray) {\n+                bh.consume(s.divide(t, RoundingMode.DOWN));\n+            }\n@@ -225,1 +221,1 @@\n-    \/** Test BigDecimal.toString() with small numbers less than MAX_INT *\/\n+    \/** Invokes the compareTo method of BigDecimal with various different values. *\/\n@@ -227,4 +223,5 @@\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testSmallToString(Blackhole bh) {\n-        for (BigDecimal s : smallArray) {\n-            bh.consume(s.toString());\n+    @OperationsPerInvocation(TEST_SIZE - 1)\n+    public void testCompareTo(Blackhole bh) {\n+        BigDecimal c = bigDecimals[0];\n+        for (BigDecimal s : bigDecimals) {\n+            bh.consume(c.compareTo(s));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":28,"deletions":31,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,33 @@\n+    \/** Test divide with huge\/small numbers *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE * TESTSIZE)\n+    public void testHugeSmallDivide(Blackhole bh) {\n+        for (BigInteger s : hugeArray) {\n+            for (BigInteger t : smallArray) {\n+                bh.consume(s.divide(t));\n+            }\n+        }\n+    }\n+\n+    \/** Test divide with large\/small numbers *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE * TESTSIZE)\n+    public void testLargeSmallDivide(Blackhole bh) {\n+        for (BigInteger s : largeArray) {\n+            for (BigInteger t : smallArray) {\n+                bh.consume(s.divide(t));\n+            }\n+        }\n+    }\n+\n+    \/** Test divide with huge\/large numbers *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE * TESTSIZE)\n+    public void testHugeLargeDivide(Blackhole bh) {\n+        for (BigInteger s : hugeArray) {\n+            for (BigInteger t : largeArray) {\n+                bh.consume(s.divide(t));\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegers.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}