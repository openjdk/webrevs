{"files":[{"patch":"@@ -99,0 +99,1 @@\n+public:\n@@ -224,1 +225,0 @@\n-public:\n@@ -234,1 +234,1 @@\n-    this->remove_all();\n+    this->delete_all();\n@@ -271,5 +271,4 @@\n-  \/\/ Delete all nodes.\n-  void remove_all() {\n-    _node_count = 0;\n-    GrowableArrayCHeap<TreapNode*, mtNMT> to_delete;\n-    to_delete.push(_root);\n+  \/\/ Delete all nodes in a tree\n+  void delete_tree(TreapNode* root, GrowableArrayCHeap<TreapNode*, mtNMT>& to_delete) {\n+    int nodes_removed = 0;\n+    to_delete.push(root);\n@@ -283,0 +282,1 @@\n+      nodes_removed++;\n@@ -284,0 +284,6 @@\n+    _node_count -= nodes_removed;\n+  }\n+\n+  void delete_all() {\n+    GrowableArrayCHeap<TreapNode*, mtNMT> to_delete;\n+    delete_tree(_root, to_delete);\n@@ -287,0 +293,4 @@\n+  TreapNode*& root() {\n+    return _root;\n+  }\n+\n@@ -307,1 +317,1 @@\n-  \/\/ Visit all TreapNodes in ascending key order.\n+\n@@ -309,3 +319,2 @@\n-  void visit_in_order(F f) const {\n-    GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n-    TreapNode* head = _root;\n+  static void visit_in_order(TreapNode* root, GrowableArrayCHeap<TreapNode*, mtNMT>& to_visit, F f) {\n+    TreapNode* head = root;\n@@ -323,0 +332,7 @@\n+  \/\/ Visit all TreapNodes in ascending key order.\n+  template<typename F>\n+  void visit_in_order(F f) const {\n+    GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n+    visit_in_order(_root, to_visit, f);\n+  }\n+\n@@ -325,1 +341,2 @@\n-  void visit_range_in_order(const K& from, const K& to, F f) {\n+  static void visit_range_in_order(TreapNode* root, GrowableArrayCHeap<TreapNode*, mtNMT>& to_visit,\n+                                   const K& from, const K& to, F f) {\n@@ -327,2 +344,1 @@\n-    GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n-    TreapNode* head = _root;\n+    TreapNode* head = root;\n@@ -354,0 +370,6 @@\n+\n+  template<typename F>\n+  void visit_range_in_order(const K& from, const K& to, F f) {\n+    GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n+    visit_range_in_order(_root, to_visit, from, to, f);\n+  }\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":36,"deletions":14,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-      IntervalState{              state,   metadata}\n+      IntervalState{              state, metadata}\n@@ -51,1 +51,1 @@\n-      IntervalState{              state,   metadata},\n+      IntervalState{              state, metadata},\n@@ -130,1 +130,0 @@\n-  GrowableArrayCHeap<AddressState, mtNMT> to_be_deleted_inbetween_a_b;\n@@ -133,19 +132,6 @@\n-  \/\/ Find all nodes between (A, B] and record their addresses and values. Also update B's\n-  \/\/ outgoing state.\n-  _tree.visit_range_in_order(A + 1, B + 1, [&](TreapNode* head) {\n-    int cmp_B = PositionComparator::cmp(head->key(), B);\n-    stB.out = head->val().out;\n-    if (cmp_B < 0) {\n-      \/\/ Record all nodes preceding B.\n-      to_be_deleted_inbetween_a_b.push({head->key(), head->val()});\n-    } else if (cmp_B == 0) {\n-      \/\/ Re-purpose B node, unless it would result in a noop node, in\n-      \/\/ which case record old node at B for deletion and summary accounting.\n-      if (stB.is_noop()) {\n-        to_be_deleted_inbetween_a_b.push(AddressState{B, head->val()});\n-      } else {\n-        head->val() = stB;\n-      }\n-      B_needs_insert = false;\n-    }\n-  });\n+  \/\/ Find range (A, B)\n+  \/\/ l: [0, A], r: (A, +Inf]\n+  VMATreap::node_pair a = _tree.split(_tree.root(), A, VMATreap::SplitMode::LEQ);\n+  \/\/ l: (A, B), r: [B, +Inf]\n+  VMATreap::node_pair b = _tree.split(a.right, B, VMATreap::SplitMode::LT);\n+  TreapNode* a_b_range = b.left;\n@@ -153,10 +139,0 @@\n-  \/\/ Insert B node if needed\n-  if (B_needs_insert && \/\/ Was not already inserted\n-      !stB.is_noop())   \/\/ The operation is differing\n-    {\n-    _tree.upsert(B, stB);\n-  }\n-\n-  \/\/ We now need to:\n-  \/\/ a) Delete all nodes between (A, B]. Including B in the case of a noop.\n-  \/\/ b) Perform summary accounting\n@@ -164,2 +140,1 @@\n-\n-  if (to_be_deleted_inbetween_a_b.length() == 0 && LEQ_A_found) {\n+  if (a_b_range == nullptr && LEQ_A_found) {\n@@ -179,3 +154,0 @@\n-  for (int i = 0; i < to_be_deleted_inbetween_a_b.length(); i++) {\n-    const AddressState delete_me = to_be_deleted_inbetween_a_b.at(i);\n-    _tree.remove(delete_me.address);\n@@ -183,0 +155,3 @@\n+  _worklist.clear();\n+  VMATreap::visit_in_order(a_b_range, _worklist, [&](TreapNode* head) {\n+    AddressState current{head->key(), head->val()};\n@@ -184,6 +159,6 @@\n-    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(delete_me.in().mem_tag())];\n-    if (delete_me.in().type() == StateType::Reserved) {\n-      rescom.reserve -= delete_me.address - prev.address;\n-    } else if (delete_me.in().type() == StateType::Committed) {\n-      rescom.commit -= delete_me.address - prev.address;\n-      rescom.reserve -= delete_me.address - prev.address;\n+    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(current.in().mem_tag())];\n+    if (current.in().type() == StateType::Reserved) {\n+      rescom.reserve -= current.address - prev.address;\n+    } else if (current.in().type() == StateType::Committed) {\n+      rescom.commit -= current.address - prev.address;\n+      rescom.reserve -= current.address - prev.address;\n@@ -191,1 +166,31 @@\n-    prev = delete_me;\n+    prev = current;\n+    return true;\n+  });\n+\n+  if (a_b_range != nullptr) {\n+    stB.out = prev.state.out;\n+  }\n+\n+  TreapNode* b_found = VMATreap::find(b.right, B);\n+  if (b_found != nullptr) {\n+    stB.out = b_found->val().out;\n+    if (!stB.is_noop()) {\n+      b_found->val() = stB;\n+    }\n+    B_needs_insert = false;\n+  }\n+  \/\/ Exclude (A, B), removing it\n+  _tree.root() = VMATreap::merge(a.left, b.right);\n+  \/\/ Delete the nodes of (A, B)\n+  _worklist.clear();\n+  _tree.delete_tree(b.left, _worklist);\n+\n+  \/\/ Insert B node if needed\n+  if (B_needs_insert && \/\/ Was not already inserted\n+      !stB.is_noop()) \/\/ The operation is differing\n+  {\n+    _tree.upsert(B, stB);\n+  }\n+  \/\/ B turned out to be superfluous and was found, so delete it.\n+  if (!B_needs_insert && stB.is_noop()) {\n+    _tree.remove(B);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":49,"deletions":44,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+  \/\/ Keep a re-usable worklist to minimize constantly allocating\/deallocating\n+  GrowableArrayCHeap<TreapNode*, mtNMT> _worklist;\n@@ -158,1 +160,1 @@\n-  VMATree() : _tree() {}\n+  VMATree() : _worklist(), _tree() {}\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-      treap.remove_all();\n+      treap.delete_all();\n@@ -203,1 +203,1 @@\n-    treap.remove_all();\n+    treap.delete_all();\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_treap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}