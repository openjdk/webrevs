{"files":[{"patch":"@@ -2650,0 +2650,8 @@\n+  INSN(vaesem_vs,   0b1110111, 0b010, 0b00010, 0b101001);\n+  INSN(vaesef_vs,   0b1110111, 0b010, 0b00011, 0b101001);\n+\n+  INSN(vaesdm_vs,   0b1110111, 0b010, 0b00000, 0b101001);\n+  INSN(vaesdf_vs,   0b1110111, 0b010, 0b00001, 0b101001);\n+\n+  INSN(vaesz_vs,    0b1110111, 0b010, 0b00111, 0b101001);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2610,0 +2610,188 @@\n+  \/\/ Big-endian 128-bit + 64-bit -> 128-bit addition.\n+  void be_inc_counter_128(Register counter, Register tmp1, Register tmp2) {\n+    assert_different_registers(counter, tmp1, tmp2, t0);\n+    __ ld(tmp1, Address(counter, 8)); \/\/ Load 128-bits from counter\n+    __ ld(tmp2, Address(counter));\n+    __ rev8(tmp1, tmp1);              \/\/ Convert big-endian to little-endian\n+    __ rev8(tmp2, tmp2);\n+    __ addi(tmp1, tmp1, 1);\n+    __ seqz(t0, tmp1);                \/\/ Check for result overflow\n+    __ add(tmp2, tmp2, t0);           \/\/ Add 1 if overflow otherwise 0\n+    __ rev8(tmp1, tmp1);              \/\/ Convert little-endian to big-endian\n+    __ rev8(tmp2, tmp2);\n+    __ sd(tmp1, Address(counter, 8)); \/\/ Store 128-bits to counter\n+    __ sd(tmp2, Address(counter));\n+  }\n+\n+  \/\/ CTR AES crypt.\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - source byte array address\n+  \/\/   c_rarg1   - destination byte array address\n+  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg3   - counter vector byte array address\n+  \/\/   c_rarg4   - input length\n+  \/\/   c_rarg5   - saved encryptedCounter start\n+  \/\/   c_rarg6   - saved used length\n+  \/\/\n+  \/\/ Output:\n+  \/\/   x10       - input length\n+  \/\/\n+  address generate_counterMode_AESCrypt() {\n+    assert(UseAESCTRIntrinsics, \"need AES instructions (Zvkned extension) support\");\n+    assert(UseZvbb, \"need vector bit manipulation (Zvbb extension) support\");\n+    assert(UseZbb, \"need basic bit manipulation (Zbb extension) support\");\n+\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n+\n+    const Register in                  = c_rarg0;\n+    const Register out                 = c_rarg1;\n+    const Register key                 = c_rarg2;\n+    const Register counter             = c_rarg3;\n+    const Register input_len           = c_rarg4;\n+    const Register saved_encrypted_ctr = c_rarg5;\n+    const Register used_ptr            = c_rarg6;\n+\n+    const Register keylen              = x28;\n+\n+    const address start = __ pc();\n+    __ enter();\n+\n+    Label L_EXIT;\n+    __ beqz(input_len, L_EXIT);\n+\n+    Label L_aes128, L_aes192;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lw(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    __ mv(t0, 52);\n+    __ blt(keylen, t0, L_aes128);\n+    __ beq(keylen, t0, L_aes192);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n+\n+    \/\/ Note: the following function performs crypt with key += 15*16\n+    counterMode_AESCrypt(15, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n+\n+    \/\/ Note: the following function performs crypt with key += 13*16\n+    __ bind(L_aes192);\n+    counterMode_AESCrypt(13, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n+\n+    \/\/ Note: the following function performs crypt with key += 11*16\n+    __ bind(L_aes128);\n+    counterMode_AESCrypt(11, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n+\n+    __ bind(L_EXIT);\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n+  void counterMode_AESCrypt(int round, Register in, Register out, Register key, Register counter,\n+                            Register input_len,  Register saved_encrypted_ctr, Register used_ptr) {\n+    \/\/ Algorithm:\n+    \/\/\n+    \/\/   generate_aes_loadkeys();\n+    \/\/\n+    \/\/   L_encrypt_next:\n+    \/\/     while (used < BLOCK_SIZE) {\n+    \/\/       if (len == 0) goto L_exit;\n+    \/\/       out = in ^ saved_encrypted_ctr[used]);\n+    \/\/       out++; in++; used++; len--;\n+    \/\/     }\n+    \/\/\n+    \/\/   L_main_loop:\n+    \/\/     if (len == 0) goto L_exit;\n+    \/\/     saved_encrypted_ctr = aes_encrypt(counter);\n+    \/\/     increase_counter(counter);\n+    \/\/     if (len < BLOCK_SIZE) {\n+    \/\/       used = 0;\n+    \/\/       goto L_encrypt_next;\n+    \/\/     }\n+    \/\/     v_in = load_16Byte(in);\n+    \/\/     v_out = load_16Byte(out);\n+    \/\/     v_saved_encrypted_ctr = load_16Byte(saved_encrypted_ctr);\n+    \/\/     v_out = v_in ^ v_saved_encrypted_ctr;\n+    \/\/     out += BLOCK_SIZE;\n+    \/\/     in += BLOCK_SIZE;\n+    \/\/     len -= BLOCK_SIZE;\n+    \/\/     used = BLOCK_SIZE;\n+    \/\/     goto L_main_loop;\n+    \/\/ }\n+    \/\/\n+    \/\/ L_exit:\n+    \/\/   return result;\n+\n+    const Register used                = x29;\n+    const Register len                 = x30;\n+    const Register block_size          = x31;\n+    const Register tmp1                = t1;\n+    const Register tmp2                = t2;\n+\n+    const int BLOCK_SIZE = 16;\n+\n+    VectorRegister working_vregs[] = {\n+      v1, v2, v3, v4, v5, v6, v7, v8,\n+      v9, v10, v11, v12, v13, v14, v15\n+    };\n+\n+    __ lw(used, Address(used_ptr));\n+    __ mv(len, input_len);\n+    __ mv(block_size, BLOCK_SIZE);\n+\n+    \/\/ load keys to working_vregs according to round\n+    generate_aes_loadkeys(key, working_vregs, round);\n+\n+    Label L_next, L_encrypt_next, L_main_loop, L_exit;\n+    \/\/ Encrypt bytes left with last encryptedCounter\n+    __ bind(L_next);\n+    __ bge(used, block_size, L_main_loop);\n+\n+    __ bind(L_encrypt_next);\n+    __ add(tmp1, saved_encrypted_ctr, used);\n+    __ lbu(tmp2, Address(tmp1));\n+    __ lbu(tmp1, Address(in));\n+    __ xorr(tmp2, tmp2, tmp1);\n+    __ sb(tmp2, Address(out));\n+    __ addi(in, in, 1);\n+    __ addi(out, out, 1);\n+    __ addi(used, used, 1);\n+    __ subi(len, len, 1);\n+    __ beqz(len, L_exit);\n+    __ j(L_next);\n+\n+    __ bind(L_main_loop);\n+    __ beqz(len, L_exit);\n+    __ vle32_v(v16, counter);\n+\n+    \/\/ encrypt counter according to round\n+    generate_aes_encrypt(v16, working_vregs, round);\n+\n+    __ vse32_v(v16, saved_encrypted_ctr);\n+    __ mv(used, 0);\n+\n+    \/\/ big-endian Increase counter 128\n+    be_inc_counter_128(counter, tmp1, tmp2);\n+\n+    __ blt(len, block_size, L_encrypt_next);\n+\n+    __ vle32_v(v17, in);\n+    __ vxor_vv(v16, v16, v17);\n+    __ vse32_v(v16, out);\n+    __ add(out, out, block_size);\n+    __ add(in, in, block_size);\n+    __ sub(len, len, block_size);\n+    __ mv(used, block_size);\n+    __ j(L_main_loop);\n+\n+    __ bind(L_exit);\n+    __ sw(used, Address(used_ptr));\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+  };\n+\n@@ -6830,0 +7018,4 @@\n+    if (UseAESCTRIntrinsics) {\n+      StubRoutines::_counterMode_AESCrypt = generate_counterMode_AESCrypt();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":192,"deletions":0,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+\n+    if (FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {\n+      FLAG_SET_DEFAULT(UseAESCTRIntrinsics, true);\n+    }\n+\n+    if (UseAESCTRIntrinsics) {\n+      if (!(UseZvbb && UseZbb)) {\n+        warning(\"Cannot enable UseAESCTRIntrinsics on cpu without UseZvbb and UseZbb support.\");\n+        FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n+      }\n+    }\n@@ -446,5 +457,4 @@\n-  }\n-\n-  if (UseAESCTRIntrinsics) {\n-    warning(\"AES\/CTR intrinsics are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n+    if (UseAESCTRIntrinsics) {\n+      warning(\"AES\/CTR intrinsics are not available on this CPU\");\n+      FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}