{"files":[{"patch":"@@ -2634,66 +2634,0 @@\n-  \/\/ CTR AES crypt.\n-  \/\/ Arguments:\n-  \/\/\n-  \/\/ Inputs:\n-  \/\/   c_rarg0   - source byte array address\n-  \/\/   c_rarg1   - destination byte array address\n-  \/\/   c_rarg2   - K (key) in little endian int array\n-  \/\/   c_rarg3   - counter vector byte array address\n-  \/\/   c_rarg4   - input length\n-  \/\/   c_rarg5   - saved encryptedCounter start\n-  \/\/   c_rarg6   - saved used length\n-  \/\/\n-  \/\/ Output:\n-  \/\/   x10       - input length\n-  \/\/\n-  address generate_counterMode_AESCrypt() {\n-    assert(UseAESCTRIntrinsics, \"need AES instructions (Zvkned extension) support\");\n-    assert(UseZbb, \"need basic bit manipulation (Zbb extension) support\");\n-\n-    __ align(CodeEntryAlignment);\n-    StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n-    StubCodeMark mark(this, stub_id);\n-\n-    const Register in                  = c_rarg0;\n-    const Register out                 = c_rarg1;\n-    const Register key                 = c_rarg2;\n-    const Register counter             = c_rarg3;\n-    const Register input_len           = c_rarg4;\n-    const Register saved_encrypted_ctr = c_rarg5;\n-    const Register used_ptr            = c_rarg6;\n-\n-    const Register keylen              = c_rarg7; \/\/ temporary register\n-\n-    const address start = __ pc();\n-    __ enter();\n-\n-    Label L_EXIT;\n-    __ beqz(input_len, L_EXIT);\n-\n-    Label L_aes128, L_aes192;\n-    \/\/ Compute #rounds for AES based on the length of the key array\n-    __ lwu(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n-    __ mv(t0, 52);\n-    __ bltu(keylen, t0, L_aes128);\n-    __ beq(keylen, t0, L_aes192);\n-    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n-\n-    \/\/ Note: the following function performs crypt with key += 15*16\n-    counterMode_AESCrypt(15, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n-\n-    \/\/ Note: the following function performs crypt with key += 13*16\n-    __ bind(L_aes192);\n-    counterMode_AESCrypt(13, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n-\n-    \/\/ Note: the following function performs crypt with key += 11*16\n-    __ bind(L_aes128);\n-    counterMode_AESCrypt(11, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n-\n-    __ bind(L_EXIT);\n-    __ mv(x10, input_len);\n-    __ leave();\n-    __ ret();\n-\n-    return start;\n-  }\n-\n@@ -2705,0 +2639,4 @@\n+    \/\/   load_counter_128(counter_hi, counter_lo, counter);\n+    \/\/\n+    \/\/   L_next:\n+    \/\/     if (used >= BLOCK_SIZE) goto L_main_loop;\n@@ -2707,3 +2645,1 @@\n-    \/\/     while (used < BLOCK_SIZE) {\n-    \/\/       if (len == 0) goto L_exit;\n-    \/\/       out = in ^ saved_encrypted_ctr[used]);\n+    \/\/       *out = *in ^ saved_encrypted_ctr[used]);\n@@ -2711,1 +2647,2 @@\n-    \/\/     }\n+    \/\/       if (len == 0) goto L_exit;\n+    \/\/       goto L_next;\n@@ -2716,5 +2653,7 @@\n-    \/\/     if (len < BLOCK_SIZE) {\n-    \/\/       used = 0;\n-    \/\/       goto L_encrypt_next;\n-    \/\/     }\n-    \/\/     increase(counter);\n+    \/\/\n+    \/\/     add_counter_128(counter_hi, counter_lo);\n+    \/\/     be_store_counter_128(counter_hi, counter_lo, counter);\n+    \/\/     used = 0;\n+    \/\/\n+    \/\/     if(len < BLOCK_SIZE) goto L_encrypt_next;\n+    \/\/\n@@ -2730,1 +2669,0 @@\n-    \/\/ }\n@@ -2732,2 +2670,5 @@\n-    \/\/ L_exit:\n-    \/\/   return result;\n+    \/\/\n+    \/\/   L_exit:\n+    \/\/     store(used);\n+    \/\/     result = input_len\n+    \/\/     return result;\n@@ -2818,0 +2759,67 @@\n+  \/\/ CTR AES crypt.\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - source byte array address\n+  \/\/   c_rarg1   - destination byte array address\n+  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg3   - counter vector byte array address\n+  \/\/   c_rarg4   - input length\n+  \/\/   c_rarg5   - saved encryptedCounter start\n+  \/\/   c_rarg6   - saved used length\n+  \/\/\n+  \/\/ Output:\n+  \/\/   x10       - input length\n+  \/\/\n+  address generate_counterMode_AESCrypt() {\n+    assert(UseZvkn, \"need AES instructions (Zvkned extension) support\");\n+    assert(UseAESCTRIntrinsics, \"need AES instructions (Zvkned extension) support\");\n+    assert(UseZbb, \"need basic bit manipulation (Zbb extension) support\");\n+\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n+\n+    const Register in                  = c_rarg0;\n+    const Register out                 = c_rarg1;\n+    const Register key                 = c_rarg2;\n+    const Register counter             = c_rarg3;\n+    const Register input_len           = c_rarg4;\n+    const Register saved_encrypted_ctr = c_rarg5;\n+    const Register used_len_ptr        = c_rarg6;\n+\n+    const Register keylen              = c_rarg7; \/\/ temporary register\n+\n+    const address start = __ pc();\n+    __ enter();\n+\n+    Label L_EXIT;\n+    __ beqz(input_len, L_EXIT);\n+\n+    Label L_aes128, L_aes192;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lwu(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ mv(t0, 52); \/\/ key length could be only {11, 13, 15} * 4 = {44, 52, 60}\n+    __ bltu(keylen, t0, L_aes128);\n+    __ beq(keylen, t0, L_aes192);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n+\n+    \/\/ Note: the following function performs crypt with key += 15*16\n+    counterMode_AESCrypt(15, in, out, key, counter, input_len, saved_encrypted_ctr, used_len_ptr);\n+\n+    \/\/ Note: the following function performs crypt with key += 13*16\n+    __ bind(L_aes192);\n+    counterMode_AESCrypt(13, in, out, key, counter, input_len, saved_encrypted_ctr, used_len_ptr);\n+\n+    \/\/ Note: the following function performs crypt with key += 11*16\n+    __ bind(L_aes128);\n+    counterMode_AESCrypt(11, in, out, key, counter, input_len, saved_encrypted_ctr, used_len_ptr);\n+\n+    __ bind(L_EXIT);\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":86,"deletions":78,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -438,1 +438,1 @@\n-    if (FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {\n+    if (FLAG_IS_DEFAULT(UseAESCTRIntrinsics) && UseZbb) {\n@@ -442,5 +442,3 @@\n-    if (UseAESCTRIntrinsics) {\n-      if (!UseZbb) {\n-        warning(\"Cannot enable UseAESCTRIntrinsics on cpu without UseZbb support.\");\n-        FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n-      }\n+    if (UseAESCTRIntrinsics && !UseZbb) {\n+      warning(\"Cannot enable UseAESCTRIntrinsics on cpu without UseZbb support.\");\n+      FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n@@ -458,1 +456,1 @@\n-      warning(\"AES\/CTR intrinsics are not available on this CPU\");\n+      warning(\"Cannot enable UseAESCTRIntrinsics on cpu without UseZvkn support.\");\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"}]}