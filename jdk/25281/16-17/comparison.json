{"files":[{"patch":"@@ -2659,12 +2659,0 @@\n-    const Register used                = x29;\n-    const Register len                 = x30;\n-    const Register block_size          = x31;\n-    const Register tmp1                = t1;\n-    const Register tmp2                = t2;\n-\n-    const int BLOCK_SIZE = 16;\n-\n-    VectorRegister working_vregs[] = {\n-      v1, v2, v3, v4, v5, v6, v7, v8,\n-      v9, v10, v11, v12, v13, v14, v15\n-    };\n@@ -2675,0 +2663,33 @@\n+    Label L_EXIT;\n+    __ beqz(input_len, L_EXIT);\n+\n+    Label L_aes128, L_aes192;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lw(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    __ mv(t0, 52);\n+    __ blt(keylen, t0, L_aes128);\n+    __ beq(keylen, t0, L_aes192);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n+\n+    \/\/ Note: the following function performs crypt with key += 15*16\n+    counterMode_AESCrypt(15, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n+\n+    \/\/ Note: the following function performs crypt with key += 13*16\n+    __ bind(L_aes192);\n+    counterMode_AESCrypt(13, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n+\n+    \/\/ Note: the following function performs crypt with key += 11*16\n+    __ bind(L_aes128);\n+    counterMode_AESCrypt(11, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n+\n+    __ bind(L_EXIT);\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n+  void counterMode_AESCrypt(int round, Register in, Register out, Register key, Register counter,\n+                            Register input_len,  Register saved_encrypted_ctr, Register used_ptr) {\n@@ -2677,3 +2698,0 @@\n-    \/\/ if (len == 0) {\n-    \/\/   goto L_exit;\n-    \/\/ } else {\n@@ -2685,2 +2703,2 @@\n-    \/\/       out[outOff++] = (byte)(in[inOff++] ^ saved_encrypted_ctr[used++]);\n-    \/\/       len--;\n+    \/\/       out = in ^ saved_encrypted_ctr[used]);\n+    \/\/       out++; in++; used++; len--;\n@@ -2689,1 +2707,2 @@\n-    \/\/   L_main:\n+    \/\/   L_main_loop:\n+    \/\/     if (len == 0) goto L_exit;\n@@ -2703,1 +2722,2 @@\n-    \/\/     goto L_main;\n+    \/\/     used = BLOCK_SIZE;\n+    \/\/     goto L_main_loop;\n@@ -2709,13 +2729,5 @@\n-    Label L_exit;\n-    __ lw(used, Address(used_ptr));\n-    __ beqz(input_len, L_exit);\n-    __ mv(len, input_len);\n-    __ mv(block_size, BLOCK_SIZE);\n-\n-    Label L_aes128_loadkeys, L_aes192_loadkeys, L_exit_loadkeys;\n-    \/\/ Compute #rounds for AES based on the length of the key array\n-    __ lw(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n-    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n-    __ mv(t0, 52);\n-    __ blt(keylen, t0, L_aes128_loadkeys);\n-    __ beq(keylen, t0, L_aes192_loadkeys);\n+    const Register used                = x29;\n+    const Register len                 = x30;\n+    const Register block_size          = x31;\n+    const Register tmp1                = t1;\n+    const Register tmp2                = t2;\n@@ -2723,3 +2735,1 @@\n-    \/\/ Load aes keys into working_vregs according to the keylen\n-    generate_aes_loadkeys(key, working_vregs, 15);\n-    __ j(L_exit_loadkeys);\n+    const int BLOCK_SIZE = 16;\n@@ -2727,3 +2737,4 @@\n-    __ bind(L_aes192_loadkeys);\n-    generate_aes_loadkeys(key, working_vregs, 13);\n-    __ j(L_exit_loadkeys);\n+    VectorRegister working_vregs[] = {\n+      v1, v2, v3, v4, v5, v6, v7, v8,\n+      v9, v10, v11, v12, v13, v14, v15\n+    };\n@@ -2731,3 +2742,3 @@\n-    __ bind(L_aes128_loadkeys);\n-    generate_aes_loadkeys(key, working_vregs, 11);\n-    __ bind(L_exit_loadkeys);\n+    __ lw(used, Address(used_ptr));\n+    __ mv(len, input_len);\n+    __ mv(block_size, BLOCK_SIZE);\n@@ -2735,1 +2746,2 @@\n-    Label L_next, L_encrypt_next, L_main;\n+    \/\/ load keys to working_vregs according to round\n+    generate_aes_loadkeys(key, working_vregs, round);\n@@ -2737,0 +2749,1 @@\n+    Label L_next, L_encrypt_next, L_main_loop, L_exit;\n@@ -2739,1 +2752,1 @@\n-    __ bge(used, block_size, L_main);\n+    __ bge(used, block_size, L_main_loop);\n@@ -2743,1 +2756,1 @@\n-    __ lbu(t0, Address(tmp1));\n+    __ lbu(tmp2, Address(tmp1));\n@@ -2745,2 +2758,2 @@\n-    __ xorr(t0, t0, tmp1);\n-    __ sb(t0, Address(out));\n+    __ xorr(tmp2, tmp2, tmp1);\n+    __ sb(tmp2, Address(out));\n@@ -2754,1 +2767,1 @@\n-    __ bind(L_main);\n+    __ bind(L_main_loop);\n@@ -2758,15 +2771,2 @@\n-    Label L_aes128_loop_next, L_aes192_loop_next, L_exit_aes_loop_next;\n-    __ mv(t0, 52);\n-    __ blt(keylen, t0, L_aes128_loop_next);\n-    __ beq(keylen, t0, L_aes192_loop_next);\n-\n-    generate_aes_encrypt(v16, working_vregs, 15);\n-    __ j(L_exit_aes_loop_next);\n-\n-    __ bind(L_aes192_loop_next);\n-    generate_aes_encrypt(v16, working_vregs, 13);\n-    __ j(L_exit_aes_loop_next);\n-\n-    __ bind(L_aes128_loop_next);\n-    generate_aes_encrypt(v16, working_vregs, 11);\n-    __ bind(L_exit_aes_loop_next);\n+    \/\/ encrypt counter according to round\n+    generate_aes_encrypt(v16, working_vregs, round);\n@@ -2777,1 +2777,1 @@\n-    \/\/ Increase counter\n+    \/\/ big-endian Increase counter 128\n@@ -2789,1 +2789,1 @@\n-    __ j(L_main);\n+    __ j(L_main_loop);\n@@ -2796,3 +2796,1 @@\n-\n-    return start;\n-  }\n+  };\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":65,"deletions":67,"binary":false,"changes":132,"status":"modified"}]}