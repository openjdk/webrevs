{"files":[{"patch":"@@ -2650,0 +2650,8 @@\n+  INSN(vaesem_vs,   0b1110111, 0b010, 0b00010, 0b101001);\n+  INSN(vaesef_vs,   0b1110111, 0b010, 0b00011, 0b101001);\n+\n+  INSN(vaesdm_vs,   0b1110111, 0b010, 0b00000, 0b101001);\n+  INSN(vaesdf_vs,   0b1110111, 0b010, 0b00001, 0b101001);\n+\n+  INSN(vaesz_vs,    0b1110111, 0b010, 0b00111, 0b101001);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2610,0 +2610,255 @@\n+  \/\/ CTR AES crypt.\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - source byte array address\n+  \/\/   c_rarg1   - destination byte array address\n+  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg3   - counter vector byte array address\n+  \/\/   c_rarg4   - input length\n+  \/\/   c_rarg5   - saved encryptedCounter start\n+  \/\/   c_rarg6   - saved used length\n+  \/\/\n+  \/\/ Output:\n+  \/\/   x10       - input length\n+  \/\/\n+  address generate_counterMode_AESCrypt() {\n+    assert(UseAESCTRIntrinsics, \"need AES instructions (Zvkned extension) support\");\n+    assert(UseZvbb, \"need vector bit manipulation (Zvbb extension) support\");\n+    assert(UseZbb, \"need basic bit manipulation (Zbb extension) support\");\n+\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n+\n+    const Register in                  = c_rarg0;\n+    const Register out                 = c_rarg1;\n+    const Register key                 = c_rarg2;\n+    const Register counter             = c_rarg3;\n+    const Register input_len           = c_rarg4;\n+    const Register saved_encrypted_ctr = c_rarg5;\n+    const Register used_ptr            = c_rarg6;\n+    const Register tmp                 = c_rarg7;\n+\n+    const Register keylen              = x31;\n+    const Register used                = x30;\n+    const Register len                 = x29;\n+    const Register len32               = x28;\n+    const Register vl                  = t1;\n+    const Register ctr                 = t2;\n+\n+    const unsigned char block_size = 16;\n+\n+    VectorRegister working_vregs[] = {\n+      v1, v2, v3, v4, v5, v6, v7, v8,\n+      v9, v10, v11, v12, v13, v14, v15\n+    };\n+\n+    const address start = __ pc();\n+    __ enter();\n+\n+    Label L_exit;\n+\n+    __ lw(used, Address(used_ptr));\n+    __ beqz(input_len, L_exit);\n+    __ mv(len, input_len);\n+\n+    \/\/ Init 0b01010101... v0 mask for counter increase\n+    uint64_t maskIndex = 0xaaul;\n+    __ vsetvli(t0, x0, Assembler::e8, Assembler::m1);\n+    __ mv(t0, maskIndex);\n+    __ vmv_v_x(v0, t0);\n+\n+    Label L_aes128_loadkeys, L_aes192_loadkeys, L_exit_loadkeys;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lw(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    __ mv(t0, 52);\n+    __ blt(keylen, t0, L_aes128_loadkeys);\n+    __ beq(keylen, t0, L_aes192_loadkeys);\n+\n+    \/\/ Load aes keys into working_vregs according to the keylen\n+    generate_aes_loadkeys(key, working_vregs, 15);\n+    __ j(L_exit_loadkeys);\n+\n+    __ bind(L_aes192_loadkeys);\n+    generate_aes_loadkeys(key, working_vregs, 13);\n+    __ j(L_exit_loadkeys);\n+\n+    __ bind(L_aes128_loadkeys);\n+    generate_aes_loadkeys(key, working_vregs, 11);\n+    __ bind(L_exit_loadkeys);\n+\n+    Label L_next, L_encrypt_next, L_main;\n+\n+    \/\/ Encrypt bytes left with last encryptedCounter\n+    __ bind(L_next);\n+    __ mv(t0, block_size);\n+    __ bge(used, t0, L_main);\n+\n+    __ bind(L_encrypt_next);\n+    __ add(tmp, saved_encrypted_ctr, used);\n+    __ lbu(t0, Address(tmp));\n+    __ lbu(tmp, Address(in));\n+    __ xorr(t0, t0, tmp);\n+    __ sb(t0, Address(out));\n+    __ addi(in, in, 1);\n+    __ addi(out, out, 1);\n+    __ addi(used, used, 1);\n+    __ subi(len, len, 1);\n+    __ beqz(len, L_exit);\n+    __ j(L_next);\n+\n+    Label L_first_loop, L_loop, L_calculate_one_next;\n+\n+    __ bind(L_main);\n+    \/\/ Check whether the counter increases overflow 64 bit and changes to the scalar path,\n+    \/\/ most of time the counter may not increase over 64 bit,\n+    \/\/ but when counter starts with a large init number, we may encounter overflow one time\n+    \/\/ at most, just calculate it on the scalar path, and then go back to the large block\n+    __ addi(t0, counter, 8);\n+    __ ld(tmp, Address(t0));\n+    __ rev8(tmp, tmp);\n+    __ srli(t0, len, 4);\n+    __ addi(t0, t0, 1);\n+    __ add(t0, tmp, t0);\n+    __ bltu(t0, tmp, L_calculate_one_next);\n+\n+    \/\/ Calculate the number of 16 Bytes for CTR large block as t0.\n+    \/\/ Because of zvkned need sew as e32, so we save t0 * 4 into len32.\n+    \/\/ After that we save the data length < 16 back into len,\n+    \/\/ and calculate them one by one in L_next later.\n+    __ srli(t0, len, 4);\n+    __ slli(len32, t0, 2);\n+    __ slli(t0, len32, 2);\n+    __ sub(len, len, t0);\n+\n+    \/\/ We may still have fewer than 16 Bytes data at beginning.\n+    \/\/ So we need to calculate next counter and encryptedCounter\n+    __ beqz(len32, L_calculate_one_next);\n+\n+    \/\/ AES\/CTR large block loop\n+    \/\/ Init large block counter group\n+    __ vsetivli(x0, 2, Assembler::e64, Assembler::m1);\n+    __ vle64_v(v31, counter);\n+    \/\/ Convert the big-endian counter into little-endian for increment\n+    __ vrev8_v(v31, v31, Assembler::VectorMask::v0_t);\n+    __ vsetvli(x0, len32, Assembler::e32, Assembler::m4);\n+    __ vmv_v_i(v16, 0);\n+    __ vaesz_vs(v16, v31);\n+    __ srli(t0, len32, 1);\n+    __ vsetvli(x0, t0, Assembler::e64, Assembler::m4);\n+    __ viota_m(v20, v0, Assembler::VectorMask::v0_t);\n+    __ vadd_vv(v16, v16, v20, Assembler::VectorMask::v0_t);\n+    __ j(L_first_loop);\n+\n+    __ bind(L_loop);\n+    __ srli(t0, len32, 1);\n+    __ vsetvli(x0, t0, Assembler::e64, Assembler::m4);\n+    __ vadd_vx(v16, v16, ctr, Assembler::VectorMask::v0_t);\n+\n+    __ bind(L_first_loop);\n+    __ vmv_v_v(v24, v16);\n+    \/\/ convert the little-endian back to big-endian\n+    __ vrev8_v(v24, v24, Assembler::VectorMask::v0_t);\n+    __ vsetvli(vl, len32, Assembler::e32, Assembler::m4);\n+    __ vaesz_vs(v24, working_vregs[0]);\n+\n+    Label L_aes128_loop, L_aes192_loop, L_exit_aes_loop;\n+    __ mv(t0, 52);\n+    __ blt(keylen, t0, L_aes128_loop);\n+    __ beq(keylen, t0, L_aes192_loop);\n+\n+    \/\/ Encrypt the counters aes256\n+    for (int i = 1; i < 14; i++) {\n+      __ vaesem_vs(v24, working_vregs[i]);\n+    }\n+    __ vaesef_vs(v24, working_vregs[14]);\n+    __ j(L_exit_aes_loop);\n+\n+    \/\/ Encrypt the counters aes192\n+    __ bind(L_aes192_loop);\n+    for (int i = 1; i < 12; i++) {\n+      __ vaesem_vs(v24, working_vregs[i]);\n+    }\n+    __ vaesef_vs(v24, working_vregs[12]);\n+    __ j(L_exit_aes_loop);\n+\n+    \/\/ Encrypt the counters aes128\n+    __ bind(L_aes128_loop);\n+    for (int i = 1; i < 10; i++) {\n+      __ vaesem_vs(v24, working_vregs[i]);\n+    }\n+    __ vaesef_vs(v24, working_vregs[10]);\n+    __ bind(L_exit_aes_loop);\n+\n+    \/\/ XOR the encryptedCounter with the inputs\n+    __ vle32_v(v20, in);\n+    __ slli(t0, vl, 2);\n+    __ srli(ctr, vl, 2);\n+\n+    __ sub(len32, len32, vl);\n+    __ add(in, in, t0);\n+    __ vxor_vv(v24, v24, v20);\n+    __ vse32_v(v24, out);\n+    __ add(out, out, t0);\n+    __ bnez(len32, L_loop);\n+\n+    \/\/ Save the encryptedCounter and next counter according to ctr\n+    __ mv(used, block_size);\n+    __ vsetivli(x0, 2, Assembler::e64, Assembler::m1);\n+    __ vadd_vx(v16, v16, ctr, Assembler::VectorMask::v0_t);\n+    __ vrev8_v(v16, v16, Assembler::VectorMask::v0_t);\n+    __ vse64_v(v16, counter);\n+\n+    __ bind(L_calculate_one_next);\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    __ vle32_v(v24, counter);\n+\n+    Label L_aes128_loop_next, L_aes192_loop_next, L_exit_aes_loop_next;\n+    __ mv(t0, 52);\n+    __ blt(keylen, t0, L_aes128_loop_next);\n+    __ beq(keylen, t0, L_aes192_loop_next);\n+\n+    generate_aes_encrypt(v24, working_vregs, 15);\n+    __ j(L_exit_aes_loop_next);\n+\n+    __ bind(L_aes192_loop_next);\n+    generate_aes_encrypt(v24, working_vregs, 13);\n+    __ j(L_exit_aes_loop_next);\n+\n+    __ bind(L_aes128_loop_next);\n+    generate_aes_encrypt(v24, working_vregs, 11);\n+    __ bind(L_exit_aes_loop_next);\n+\n+    __ vse32_v(v24, saved_encrypted_ctr);\n+    __ mv(used, 0);\n+\n+    \/\/ Increase counter\n+    Label L_skip_next_inc;\n+    __ addi(t0, counter, 8);\n+    __ ld(tmp, Address(t0));\n+    __ rev8(tmp, tmp);\n+    __ addi(tmp, tmp, 1);\n+    __ rev8(tmp, tmp);\n+    __ sd(tmp, Address(t0));\n+    __ mv(t0, 0x0ul);\n+    __ bne(tmp, t0, L_skip_next_inc);\n+    __ ld(tmp, Address(counter));\n+    __ rev8(tmp, tmp);\n+    __ addi(tmp, tmp, 1);\n+    __ rev8(tmp, tmp);\n+    __ sd(tmp, Address(counter));\n+    __ bind(L_skip_next_inc);\n+    __ beqz(len, L_exit);\n+    __ j(L_encrypt_next);\n+\n+    __ bind(L_exit);\n+    __ sw(used, Address(used_ptr));\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -6830,0 +7085,4 @@\n+    if (UseAESCTRIntrinsics) {\n+      StubRoutines::_counterMode_AESCrypt = generate_counterMode_AESCrypt();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":259,"deletions":0,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+\n+    if (FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {\n+      FLAG_SET_DEFAULT(UseAESCTRIntrinsics, true);\n+    }\n+\n+    if (UseAESCTRIntrinsics) {\n+      if (!(UseZvbb && UseZbb)) {\n+        warning(\"Cannot enable UseAESCTRIntrinsics on cpu without UseZvbb and UseZbb support.\");\n+        FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n+      }\n+    }\n@@ -446,5 +457,4 @@\n-  }\n-\n-  if (UseAESCTRIntrinsics) {\n-    warning(\"AES\/CTR intrinsics are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n+    if (UseAESCTRIntrinsics) {\n+      warning(\"AES\/CTR intrinsics are not available on this CPU\");\n+      FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}