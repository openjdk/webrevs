{"files":[{"patch":"@@ -2498,1 +2498,1 @@\n-    __ blt(keylen, t2, L_aes128);\n+    __ bltu(keylen, t2, L_aes128);\n@@ -2577,1 +2577,1 @@\n-    __ blt(keylen, t2, L_aes128);\n+    __ bltu(keylen, t2, L_aes128);\n@@ -2610,0 +2610,209 @@\n+  \/\/ Load big-endian 128-bit from memory.\n+  void be_load_counter_128(Register counter_hi, Register counter_lo, Register counter) {\n+    __ ld(counter_lo, Address(counter, 8)); \/\/ Load 128-bits from counter\n+    __ ld(counter_hi, Address(counter));\n+    __ rev8(counter_lo, counter_lo);        \/\/ Convert big-endian to little-endian\n+    __ rev8(counter_hi, counter_hi);\n+  }\n+\n+  \/\/ Little-endian 128-bit + 64-bit -> 128-bit addition.\n+  void add_counter_128(Register counter_hi, Register counter_lo) {\n+    assert_different_registers(counter_hi, counter_lo, t0);\n+    __ addi(counter_lo, counter_lo, 1);\n+    __ seqz(t0, counter_lo);                \/\/ Check for result overflow\n+    __ add(counter_hi, counter_hi, t0);     \/\/ Add 1 if overflow otherwise 0\n+  }\n+\n+  \/\/ Store big-endian 128-bit to memory.\n+  void be_store_counter_128(Register counter_hi, Register counter_lo, Register counter) {\n+    assert_different_registers(counter_hi, counter_lo, t0, t1);\n+    __ rev8(t0, counter_lo);                \/\/ Convert little-endian to big-endian\n+    __ rev8(t1, counter_hi);\n+    __ sd(t0, Address(counter, 8));         \/\/ Store 128-bits to counter\n+    __ sd(t1, Address(counter));\n+  }\n+\n+  \/\/ CTR AES crypt.\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - source byte array address\n+  \/\/   c_rarg1   - destination byte array address\n+  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg3   - counter vector byte array address\n+  \/\/   c_rarg4   - input length\n+  \/\/   c_rarg5   - saved encryptedCounter start\n+  \/\/   c_rarg6   - saved used length\n+  \/\/\n+  \/\/ Output:\n+  \/\/   x10       - input length\n+  \/\/\n+  address generate_counterMode_AESCrypt() {\n+    assert(UseAESCTRIntrinsics, \"need AES instructions (Zvkned extension) support\");\n+    assert(UseZbb, \"need basic bit manipulation (Zbb extension) support\");\n+\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_aescrypt_decryptBlock_id;\n+    StubCodeMark mark(this, stub_id);\n+\n+    const Register in                  = c_rarg0;\n+    const Register out                 = c_rarg1;\n+    const Register key                 = c_rarg2;\n+    const Register counter             = c_rarg3;\n+    const Register input_len           = c_rarg4;\n+    const Register saved_encrypted_ctr = c_rarg5;\n+    const Register used_ptr            = c_rarg6;\n+\n+    const Register keylen              = c_rarg7; \/\/ temporary register\n+\n+    const address start = __ pc();\n+    __ enter();\n+\n+    Label L_EXIT;\n+    __ beqz(input_len, L_EXIT);\n+\n+    Label L_aes128, L_aes192;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lwu(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ mv(t0, 52);\n+    __ bltu(keylen, t0, L_aes128);\n+    __ beq(keylen, t0, L_aes192);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n+\n+    \/\/ Note: the following function performs crypt with key += 15*16\n+    counterMode_AESCrypt(15, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n+\n+    \/\/ Note: the following function performs crypt with key += 13*16\n+    __ bind(L_aes192);\n+    counterMode_AESCrypt(13, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n+\n+    \/\/ Note: the following function performs crypt with key += 11*16\n+    __ bind(L_aes128);\n+    counterMode_AESCrypt(11, in, out, key, counter, input_len, saved_encrypted_ctr, used_ptr);\n+\n+    __ bind(L_EXIT);\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n+  void counterMode_AESCrypt(int round, Register in, Register out, Register key, Register counter,\n+                            Register input_len,  Register saved_encrypted_ctr, Register used_ptr) {\n+    \/\/ Algorithm:\n+    \/\/\n+    \/\/   generate_aes_loadkeys();\n+    \/\/\n+    \/\/   L_encrypt_next:\n+    \/\/     while (used < BLOCK_SIZE) {\n+    \/\/       if (len == 0) goto L_exit;\n+    \/\/       out = in ^ saved_encrypted_ctr[used]);\n+    \/\/       out++; in++; used++; len--;\n+    \/\/     }\n+    \/\/\n+    \/\/   L_main_loop:\n+    \/\/     if (len == 0) goto L_exit;\n+    \/\/     saved_encrypted_ctr = generate_aes_encrypt(counter);\n+    \/\/     if (len < BLOCK_SIZE) {\n+    \/\/       used = 0;\n+    \/\/       goto L_encrypt_next;\n+    \/\/     }\n+    \/\/     increase(counter);\n+    \/\/     v_in = load_16Byte(in);\n+    \/\/     v_out = load_16Byte(out);\n+    \/\/     v_saved_encrypted_ctr = load_16Byte(saved_encrypted_ctr);\n+    \/\/     v_out = v_in ^ v_saved_encrypted_ctr;\n+    \/\/     out += BLOCK_SIZE;\n+    \/\/     in += BLOCK_SIZE;\n+    \/\/     len -= BLOCK_SIZE;\n+    \/\/     used = BLOCK_SIZE;\n+    \/\/     goto L_main_loop;\n+    \/\/ }\n+    \/\/\n+    \/\/ L_exit:\n+    \/\/   return result;\n+\n+    const Register used          = x28;\n+    const Register len           = x29;\n+    const Register counter_hi    = x30;\n+    const Register counter_lo    = x31;\n+    const Register block_size    = t2;\n+\n+    const unsigned int BLOCK_SIZE = 16;\n+\n+    VectorRegister working_vregs[] = {\n+      v1, v2, v3, v4, v5, v6, v7, v8,\n+      v9, v10, v11, v12, v13, v14, v15\n+    };\n+\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+\n+    __ lwu(used, Address(used_ptr));\n+    __ mv(len, input_len);\n+    __ mv(block_size, BLOCK_SIZE);\n+\n+    \/\/ load keys to working_vregs according to round\n+    generate_aes_loadkeys(key, working_vregs, round);\n+\n+    \/\/ 128-bit big-endian load\n+    be_load_counter_128(counter_hi, counter_lo, counter);\n+\n+    Label L_next, L_encrypt_next, L_main_loop, L_exit;\n+    \/\/ Check the last saved_encrypted_ctr used value, we fall through\n+    \/\/ to L_encrypt_next when the used value lower than block_size\n+    __ bind(L_next);\n+    __ bgeu(used, block_size, L_main_loop);\n+\n+    \/\/ There is still data left fewer than block_size after L_main_loop\n+    \/\/ or last used, we encrypt them one by one.\n+    __ bind(L_encrypt_next);\n+    __ add(t0, saved_encrypted_ctr, used);\n+    __ lbu(t1, Address(t0));\n+    __ lbu(t0, Address(in));\n+    __ xorr(t1, t1, t0);\n+    __ sb(t1, Address(out));\n+    __ addi(in, in, 1);\n+    __ addi(out, out, 1);\n+    __ addi(used, used, 1);\n+    __ subi(len, len, 1);\n+    __ beqz(len, L_exit);\n+    __ j(L_next);\n+\n+    \/\/ We will calculate the next saved_encrypted_ctr and encrypt the blocks of data\n+    \/\/ one by one until there is less than a full block remaining if len not zero\n+    __ bind(L_main_loop);\n+    __ beqz(len, L_exit);\n+    __ vle32_v(v16, counter);\n+\n+    \/\/ encrypt counter according to round\n+    generate_aes_encrypt(v16, working_vregs, round);\n+\n+    __ vse32_v(v16, saved_encrypted_ctr);\n+\n+    \/\/ 128-bit little-endian increment\n+    add_counter_128(counter_hi, counter_lo);\n+    \/\/ 128-bit big-endian store\n+    be_store_counter_128(counter_hi, counter_lo, counter);\n+\n+    __ mv(used, 0);\n+    \/\/ Check if we have a full block_size\n+    __ bltu(len, block_size, L_encrypt_next);\n+\n+    \/\/ We have one full block to encrypt at least\n+    __ vle32_v(v17, in);\n+    __ vxor_vv(v16, v16, v17);\n+    __ vse32_v(v16, out);\n+    __ add(out, out, block_size);\n+    __ add(in, in, block_size);\n+    __ sub(len, len, block_size);\n+    __ mv(used, block_size);\n+    __ j(L_main_loop);\n+\n+    __ bind(L_exit);\n+    __ sw(used, Address(used_ptr));\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+  };\n+\n@@ -6830,0 +7039,4 @@\n+    if (UseAESCTRIntrinsics) {\n+      StubRoutines::_counterMode_AESCrypt = generate_counterMode_AESCrypt();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":215,"deletions":2,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+\n+    if (FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {\n+      FLAG_SET_DEFAULT(UseAESCTRIntrinsics, true);\n+    }\n+\n+    if (UseAESCTRIntrinsics) {\n+      if (!UseZbb) {\n+        warning(\"Cannot enable UseAESCTRIntrinsics on cpu without UseZbb support.\");\n+        FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n+      }\n+    }\n@@ -446,5 +457,4 @@\n-  }\n-\n-  if (UseAESCTRIntrinsics) {\n-    warning(\"AES\/CTR intrinsics are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n+    if (UseAESCTRIntrinsics) {\n+      warning(\"AES\/CTR intrinsics are not available on this CPU\");\n+      FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}