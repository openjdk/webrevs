{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,177 @@\n+    \/**\n+     * Creates a new and empty file, failing if the file already exists.\n+     *\n+     * <p>This method works in exactly the manner specified by\n+     * {@linkplain Files#createFile\n+     * Files.createFile}. If the {@code path} parameter is an {@linkplain\n+     * Path#isAbsolute absolute} path then it locates the file to create. If\n+     * the parameter is a relative path then it is located relative to this\n+     * open directory.\n+     *\n+     * <p> The {@code attrs} parameter is optional with effects as specified\n+     * for {@linkplain Files#createFile Files.createFile}.\n+     *\n+     * @param   path\n+     *          the path of the file to create\n+     * @param   attrs\n+     *          an optional list of file attributes to set atomically when\n+     *          creating the file\n+     *\n+     * @return  the file\n+     *\n+     * @throws  ClosedDirectoryStreamException\n+     *          if the directory stream is closed\n+     * @throws  UnsupportedOperationException\n+     *          if the array contains an attribute that cannot be set atomically\n+     *          when creating the directory\n+     * @throws  FileAlreadyExistsException\n+     *          if a file could not otherwise be created because a file of\n+     *          that name already exists <i>(optional specific exception)<\/i>\n+     * @throws  IOException\n+     *          if an I\/O error occurs or the parent directory does not exist\n+     *\n+     * @since 26\n+     *\/\n+    T createFile(T path, FileAttribute<?>... attrs)\n+        throws IOException;\n+\n+    \/**\n+     * Creates a new directory, failing if a file of that name already exists.\n+     *\n+     * <p>This method works in a similar manner to {@linkplain\n+     * Files#createDirectory Files.createDirectory}. If the {@code path}\n+     * parameter is an {@linkplain Path#isAbsolute absolute} path then it\n+     * locates the directory to create. If the parameter is a relative path\n+     * then it is located relative to this open directory.\n+     *\n+     * <p> The {@code attrs} parameter is optional with effects as specified\n+     * for {@linkplain Files#createDirectory Files.createDirectory}.\n+     *\n+     * @param   dir\n+     *          the path of the directory to create\n+     * @param   attrs\n+     *          an optional list of file attributes to set atomically when\n+     *          creating the directory\n+     *\n+     * @return  the directory\n+     *\n+     * @throws  ClosedDirectoryStreamException\n+     *          if the directory stream is closed\n+     * @throws  UnsupportedOperationException\n+     *          if the array contains an attribute that cannot be set atomically\n+     *          when creating the directory\n+     * @throws  FileAlreadyExistsException\n+     *          if a directory could not otherwise be created because a file of\n+     *          that name already exists <i>(optional specific exception)<\/i>\n+     * @throws  IOException\n+     *          if an I\/O error occurs or the parent directory does not exist\n+     *\n+     * @since 26\n+     *\/\n+    T createDirectory(T dir, FileAttribute<?>... attrs)\n+        throws IOException;\n+\n+    \/**\n+     * Creates a new link (directory entry) for an existing file <i>(optional\n+     * operation)<\/i>.\n+     *\n+     * <p>This method works in a similar manner to {@linkplain Files#createLink\n+     * Files.createLink}.  If the {@code link} parameter is an {@link\n+     * Path#isAbsolute absolute} path then it locates the link file. If the\n+     * {@code link} parameter is a relative path then it is located relative to\n+     * this open directory. If the {@code existing} parameter is an absolute\n+     * path then it locates the target file (the {@code targetdir} parameter is\n+     * ignored). If the {@code existing} parameter is a relative path it is\n+     * located relative to the open directory identified by the {@code\n+     * targetdir} parameter.\n+     *\n+     * @param   link\n+     *          the link (directory entry) to create\n+     * @param   targetdir\n+     *          the destination directory\n+     * @param   existing\n+     *          a path to an existing file\n+     *\n+     * @return  the path to the link (directory entry)\n+     *\n+     * @throws  ClosedDirectoryStreamException\n+     *          if the directory stream is closed\n+     * @throws  UnsupportedOperationException\n+     *          if the implementation does not support adding an existing file\n+     *          to a directory\n+     * @throws  FileAlreadyExistsException\n+     *          if the entry could not otherwise be created because a file of\n+     *          that name already exists <i>(optional specific exception)<\/i>\n+     * @throws  NoSuchFileException\n+     *          if the file specified by the combination of {@code targetdir}\n+     *          and {@code existing} does not exist\n+     * @throws  IOException\n+     *          if an I\/O error occurs\n+     *\n+     * @since 26\n+     *\/\n+    T createLink(T link, SecureDirectoryStream<T> targetdir, T existing)\n+        throws IOException;\n+\n+    \/**\n+     * Creates a symbolic link to a target <i>(optional operation)<\/i>.\n+     *\n+     * <p>This method works in a similar manner to {@linkplain Files#createSymbolicLink\n+     * Files.createSymbolicLink}.  If the {@code link} parameter is an {@link\n+     * Path#isAbsolute absolute} path then it locates the link file. If the\n+     * {@code link} parameter is a relative path then it is located relative to\n+     * this open directory. The {@code target} parameter is the target of the\n+     * link and behaves as specified for {@linkplain Files#createSymbolicLink\n+     * Files.createSymbolicLink}.\n+     *\n+     * @param   link\n+     *          the path of the symbolic link to create\n+     * @param   target\n+     *          the target of the symbolic link\n+     * @param   attrs\n+     *          the array of attributes to set atomically when creating the\n+     *          symbolic link\n+     *\n+     * @return  the path to the symbolic link\n+     *\n+     * @throws  ClosedDirectoryStreamException\n+     *          if the directory stream is closed\n+     * @throws  UnsupportedOperationException\n+     *          if the implementation does not support symbolic links or the\n+     *          array contains an attribute that cannot be set atomically when\n+     *          creating the symbolic link\n+     * @throws  FileAlreadyExistsException\n+     *          if a file with the name already exists <i>(optional specific\n+     *          exception)<\/i>\n+     * @throws  IOException\n+     *          if an I\/O error occurs\n+     *\/\n+    T createSymbolicLink(T link, T target, FileAttribute<?>... attrs)\n+        throws IOException;\n+\n+    \/**\n+     * Reads the target of a symbolic link <i>(optional operation)<\/i>.\n+     *\n+     * <p>This method works in a similar manner to {@linkplain Files#readSymbolicLink\n+     * Files.readSymbolicLink}.  If the {@code link} parameter is an {@link\n+     * Path#isAbsolute absolute} path then it locates the link file. If the\n+     * {@code link} parameter is a relative path then it is located relative to\n+     * this open directory.\n+     *\n+     * @param   link\n+     *          the path to the symbolic link\n+     *\n+     * @return  a {@code Path} object representing the target of the link\n+     *\n+     * @throws  ClosedDirectoryStreamException\n+     *          if the directory stream is closed\n+     * @throws  UnsupportedOperationException\n+     *          if the implementation does not support symbolic links\n+     * @throws  NotLinkException\n+     *          if the target could otherwise not be read because the file\n+     *          is not a symbolic link <i>(optional specific exception)<\/i>\n+     * @throws  IOException\n+     *          if an I\/O error occurs\n+     *\/\n+    T readSymbolicLink(T link) throws IOException;\n+\n@@ -188,2 +365,2 @@\n-     * <p> This method works in a similar manner to {@link Files#move move}\n-     * method when the {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} option\n+     * <p> This method works in a similar manner to {@link Files#move Files.move}\n+     * when the {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} option\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/SecureDirectoryStream.java","additions":180,"deletions":3,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -361,1 +361,0 @@\n-            UnixFileKey fileKey = attrs.fileKey();\n@@ -365,0 +364,1 @@\n+            UnixFileKey fileKey = attrs.fileKey();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,0 +136,15 @@\n+    \/**\n+     * linkat(int fd1, const char *name1, int fd2, const char *name2, int flag)\n+     *\/\n+    static void linkat(int dfd1, UnixPath path1, int dfd2, UnixPath path2)\n+        throws UnixException\n+    {\n+        try (NativeBuffer buffer1 = copyToNativeBuffer(path1);\n+             NativeBuffer buffer2 = copyToNativeBuffer(path2)) {\n+            linkat0(dfd1, buffer1.address(), dfd2, buffer2.address());\n+        }\n+    }\n+    private static native void linkat0(int dfd1, long addr1,\n+                                       int dfd2, long addr2)\n+        throws UnixException;\n+\n@@ -202,0 +217,13 @@\n+    \/**\n+     * mkdirat(int dfd, const char *path, mode_t mode)\n+     *\/\n+    static void mkdirat(int dfd, UnixPath path, int mode)\n+        throws UnixException\n+    {\n+        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n+            mkdirat0(dfd, buffer.address(), mode);\n+        }\n+    }\n+    private static native void mkdirat0(int dfd, long pathAddress, int mode)\n+        throws UnixException;\n+\n@@ -224,0 +252,12 @@\n+    \/**\n+     * readlinkat(int fd, const char* path, char* buf, size_t bufsize)\n+     *\n+     * @return  link target\n+     *\/\n+    static byte[] readlinkat(int fd, UnixPath path) throws UnixException {\n+        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n+            return readlinkat0(fd, buffer.address());\n+        }\n+    }\n+    private static native byte[] readlinkat0(int fd, long pathAddress) throws UnixException;\n+\n@@ -248,0 +288,14 @@\n+    \/**\n+     * symlinkat(const char* name1, int fd, const char* name2)\n+     *\/\n+    static void symlinkat(byte[] name1, int fd, UnixPath name2)\n+        throws UnixException\n+    {\n+        try (NativeBuffer targetBuffer = NativeBuffers.asNativeBuffer(name1);\n+             NativeBuffer linkBuffer = copyToNativeBuffer(name2)) {\n+            symlinkat0(targetBuffer.address(), fd, linkBuffer.address());\n+        }\n+    }\n+    private static native void symlinkat0(long name1, int dfd, long name2)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -30,3 +30,25 @@\n-import java.nio.file.*;\n-import java.nio.file.attribute.*;\n-import java.util.*;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.ClosedDirectoryStreamException;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.LinkOption;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.NotLinkException;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.ProviderMismatchException;\n+import java.nio.file.SecureDirectoryStream;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.BasicFileAttributeView;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileAttributeView;\n+import java.nio.file.attribute.FileOwnerAttributeView;\n+import java.nio.file.attribute.FileTime;\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.nio.file.attribute.PosixFileAttributes;\n+import java.nio.file.attribute.PosixFileAttributeView;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.UserPrincipal;\n+import java.util.Iterator;\n+import java.util.Set;\n@@ -35,0 +57,2 @@\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+import static java.nio.file.StandardOpenOption.WRITE;\n@@ -157,0 +181,123 @@\n+    @Override\n+    public  Path createFile(Path path, FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        newByteChannel(path, Set.of(CREATE_NEW, WRITE), attrs).close();\n+\n+        return path;\n+    }\n+\n+    @Override\n+    public Path createDirectory(Path dir, FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        UnixPath file = getName(dir);\n+\n+        int mode = UnixFileModeAttribute\n+            .toUnixMode(UnixFileModeAttribute.ALL_PERMISSIONS, attrs);\n+\n+        ds.readLock().lock();\n+        try {\n+            if (!ds.isOpen())\n+                throw new ClosedDirectoryStreamException();\n+            try {\n+                mkdirat(dfd, file, mode);\n+            } catch (UnixException x) {\n+                if (x.errno() == EISDIR)\n+                    throw new FileAlreadyExistsException(file.toString());\n+                x.rethrowAsIOException(file);\n+                return null; \/\/ keep compiler happy\n+            }\n+        } finally {\n+            ds.readLock().unlock();\n+        }\n+\n+        return dir;\n+    }\n+\n+    @Override\n+    public Path createLink(Path link,  SecureDirectoryStream<Path> dir,\n+                           Path target)\n+        throws IOException\n+    {\n+        UnixPath linkpath = UnixPath.toUnixPath(link);\n+        UnixPath targetpath = UnixPath.toUnixPath(target);\n+\n+        ds.readLock().lock();\n+        try {\n+            if (!ds.isOpen())\n+                throw new ClosedDirectoryStreamException();\n+            try {\n+                UnixSecureDirectoryStream that = (UnixSecureDirectoryStream)dir;\n+                linkat(that.dfd, targetpath, this.dfd, linkpath);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(linkpath, targetpath);\n+                return null; \/\/ keep compiler happy\n+            }\n+        } finally {\n+            ds.readLock().unlock();\n+        }\n+\n+        return link;\n+    }\n+\n+    @Override\n+    public Path createSymbolicLink(Path link, Path target,\n+                                   FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        UnixPath linkpath = UnixPath.toUnixPath(link);\n+        UnixPath targetpath = UnixPath.toUnixPath(target);\n+\n+        \/\/ no attributes supported when creating links\n+        if (attrs.length > 0) {\n+            UnixFileModeAttribute.toUnixMode(0, attrs);  \/\/ may throw NPE or UOE\n+            throw new UnsupportedOperationException(\"Initial file attributes\" +\n+                \" not supported when creating symbolic link\");\n+        }\n+\n+        ds.readLock().lock();\n+        try {\n+            if (!ds.isOpen())\n+                throw new ClosedDirectoryStreamException();\n+            try {\n+                symlinkat(targetpath.asByteArray(), dfd, linkpath);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(linkpath, targetpath);\n+                return null; \/\/ keep compiler happy\n+            }\n+        } finally {\n+            ds.readLock().unlock();\n+        }\n+\n+        return link;\n+    }\n+\n+    @Override\n+    public Path readSymbolicLink(Path link) throws IOException {\n+        UnixPath linkpath = getName(link);\n+\n+        ds.readLock().lock();\n+        try {\n+            if (!ds.isOpen())\n+                throw new ClosedDirectoryStreamException();\n+            try {\n+                UnixFileAttributes attrs =\n+                    UnixFileAttributes.getIfExists(linkpath, false);\n+                if (attrs != null && !attrs.isSymbolicLink())\n+                    throw new NotLinkException(linkpath.toString());\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(linkpath);\n+            }\n+            try {\n+                byte[] target = readlinkat(dfd, linkpath);\n+                return new UnixPath(linkpath.getFileSystem(), target);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(linkpath);\n+                return null; \/\/ keep compiler happy\n+            }\n+        } finally {\n+            ds.readLock().unlock();\n+        }\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixSecureDirectoryStream.java","additions":150,"deletions":3,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -992,0 +992,12 @@\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_mkdirat0(JNIEnv* env, jclass this,\n+    jint dfd, jlong pathAddress, jint mode)\n+{\n+    const char* path = (const char*)jlong_to_ptr(pathAddress);\n+\n+    \/* EINTR not listed as a possible error *\/\n+    if (mkdirat(dfd, path, (mode_t)mode) == -1) {\n+        throwUnixException(env, errno);\n+    }\n+}\n+\n@@ -1018,0 +1030,14 @@\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_linkat0(JNIEnv* env, jclass this,\n+                                             int dfd1, long addr1,\n+                                             int dfd2, long addr2)\n+{\n+    int err;\n+    const char* name1 = (const char*)jlong_to_ptr(addr1);\n+    const char* name2 = (const char*)jlong_to_ptr(addr2);\n+\n+    RESTARTABLE(linkat(dfd1, name1, dfd2, name2, AT_SYMLINK_FOLLOW), err);\n+    if (err == -1) {\n+        throwUnixException(env, errno);\n+    }\n+}\n@@ -1092,0 +1118,13 @@\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_symlinkat0(JNIEnv* env, jclass this,\n+    jlong targetAddress, jint dfd, jlong linkAddress)\n+{\n+    const char* target = (const char*)jlong_to_ptr(targetAddress);\n+    const char* link = (const char*)jlong_to_ptr(linkAddress);\n+\n+    \/* EINTR not listed as a possible error *\/\n+    if (symlinkat(target, dfd, link) == -1) {\n+        throwUnixException(env, errno);\n+    }\n+}\n+\n@@ -1117,0 +1156,30 @@\n+        }\n+    }\n+    return result;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_readlinkat0(JNIEnv* env, jclass this,\n+    jint fd, jlong pathAddress)\n+{\n+    jbyteArray result = NULL;\n+    char target[PATH_MAX+1];\n+    const char* path = (const char*)jlong_to_ptr(pathAddress);\n+\n+    \/* EINTR not listed as a possible error *\/\n+    int n = readlinkat(fd, path, target, sizeof(target));\n+    if (n == -1) {\n+        throwUnixException(env, errno);\n+    } else {\n+        jsize len;\n+        if (n == sizeof(target)) {\n+            \/* Traditionally readlink(2) should not return more than *\/\n+            \/* PATH_MAX bytes (no terminating null byte is appended). *\/\n+            throwUnixException(env, ENAMETOOLONG);\n+            return NULL;\n+        }\n+        target[n] = '\\0';\n+        len = (jsize)strlen(target);\n+        result = (*env)->NewByteArray(env, len);\n+        if (result != NULL) {\n+            (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)target);\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 8343020 8357425\n+ * @bug 4313887 6838333 8343020 8357425 8356493\n@@ -34,3 +34,0 @@\n-import static java.nio.file.Files.*;\n-import static java.nio.file.StandardOpenOption.*;\n-import static java.nio.file.LinkOption.*;\n@@ -42,0 +39,4 @@\n+import static java.nio.file.Files.*;\n+import static java.nio.file.StandardOpenOption.*;\n+import static java.nio.file.LinkOption.*;\n+\n@@ -48,1 +49,3 @@\n-        Path dir = TestUtil.createTemporaryDirectory();\n+        String cwd = System.getProperty(\"user.dir\");\n+        Path dir = TestUtil.createTemporaryDirectory(cwd);\n+        System.err.println(\"Top level test directory: \" + dir);\n@@ -167,0 +170,135 @@\n+        \/\/ Test: createFile\n+        Path somefile = Path.of(\"somefile\");\n+        \/\/ - absolute -\n+        Path absfile = dir.resolve(somefile);\n+        stream.createFile(absfile);\n+        assertTrue(exists(absfile));\n+        assertTrue(isRegularFile(absfile));\n+        try {\n+            stream.createFile(absfile);\n+            shouldNotGetHere();\n+        } catch (FileAlreadyExistsException x) {\n+        }\n+        stream.deleteFile(absfile);\n+        \/\/ - relative -\n+        Path relfile = dir2.resolve(somefile);\n+        stream.createFile(relfile);\n+        assertTrue(exists(relfile));\n+        assertTrue(isRegularFile(relfile));\n+        try {\n+            stream.createFile(relfile);\n+            shouldNotGetHere();\n+        } catch (FileAlreadyExistsException x) {\n+        }\n+        stream.deleteFile(relfile);\n+\n+        \/\/ Test: createDirectory\n+        Path somedir = Path.of(\"somedir\");\n+        \/\/ - absolute -\n+        Path absdir = dir.resolve(somedir);\n+        stream.createDirectory(absdir);\n+        assertTrue(exists(absdir));\n+        assertTrue(isDirectory(absdir));\n+        try {\n+            stream.createDirectory(absdir);\n+            shouldNotGetHere();\n+        } catch (FileAlreadyExistsException x) {\n+        }\n+        stream.deleteDirectory(absdir);\n+        \/\/ - relative -\n+        Path reldir = dir2.resolve(somedir);\n+        stream.createDirectory(somedir);\n+        assertTrue(exists(reldir));\n+        assertTrue(isDirectory(reldir));\n+        try {\n+            stream.createDirectory(reldir);\n+            shouldNotGetHere();\n+        } catch (FileAlreadyExistsException x) {\n+        }\n+        stream.deleteDirectory(reldir);\n+\n+        \/\/ Test: createLink\n+        Path somehardlink = Path.of(\"somehardlink\");\n+        Path someexisting = Path.of(\"someexisting\");\n+\n+        \/\/ - absolute -\n+        Path abshardlink = dir.resolve(somehardlink);\n+        Path absexisting = dir.resolve(someexisting);\n+        createFile(absexisting);\n+        String text1 = \"I simply don't know what to say.\";\n+        writeString(absexisting, text1);\n+        stream.createLink(abshardlink, stream, absexisting);\n+        assertTrue(exists(abshardlink));\n+        assertTrue(text1.equals(readString(abshardlink)));\n+        try {\n+            stream.createLink(abshardlink, stream, absexisting);\n+            shouldNotGetHere();\n+        } catch (FileAlreadyExistsException x) {\n+        }\n+        stream.deleteFile(absexisting);\n+        try {\n+            stream.createLink(abshardlink, stream, absexisting);\n+            shouldNotGetHere();\n+        } catch (NoSuchFileException x) {\n+        }\n+        stream.deleteFile(abshardlink);\n+        \/\/ - relative -\n+        Path relhardlink = dir2.resolve(somehardlink);\n+        Path relexisting = dir2.resolve(someexisting);\n+        createFile(relexisting);\n+        String text2 = \"I still don't know what to say.\";\n+        writeString(relexisting, text2);\n+        stream.createLink(somehardlink, stream, someexisting);\n+        assertTrue(exists(relhardlink));\n+        assertTrue(text2.equals(readString(relhardlink)));\n+        try {\n+            stream.createLink(somehardlink, stream, someexisting);\n+            shouldNotGetHere();\n+        } catch (FileAlreadyExistsException x) {\n+        }\n+        stream.deleteFile(relexisting);\n+        try {\n+            stream.createLink(somehardlink, stream, someexisting);\n+            shouldNotGetHere();\n+        } catch (NoSuchFileException x) {\n+        }\n+        stream.deleteFile(relhardlink);\n+\n+        if (supportsSymbolicLinks) {\n+            \/\/ Tests: createSymbolicLink and readSymbolicLink\n+            Path target = dir.resolve(Path.of(\"target\"));\n+            assertTrue(exists(createFile(target)));\n+            Path somesymlink = Path.of(\"somesymlink\");\n+\n+            \/\/ - absolute -\n+            Path abssymlink = dir.resolve(somesymlink);\n+            stream.createSymbolicLink(abssymlink, target);\n+            assertTrue(exists(abssymlink, NOFOLLOW_LINKS));\n+            assertTrue(isSymbolicLink(abssymlink));\n+            try {\n+                stream.createSymbolicLink(abssymlink, target);\n+                shouldNotGetHere();\n+            } catch (FileAlreadyExistsException x) {\n+            }\n+            assertTrue(target.equals(stream.readSymbolicLink(abssymlink)));\n+            try {\n+                stream.readSymbolicLink(target);\n+                shouldNotGetHere();\n+            } catch (NotLinkException x) {\n+            }\n+            delete(target);\n+            stream.deleteFile(abssymlink);\n+            \/\/ - relative -\n+            Path relsymlink = dir2.resolve(somesymlink);\n+            stream.createSymbolicLink(somesymlink, target);\n+            assertTrue(exists(relsymlink, NOFOLLOW_LINKS));\n+            assertTrue(isSymbolicLink(relsymlink));\n+            try {\n+                stream.createSymbolicLink(relsymlink, target);\n+                shouldNotGetHere();\n+            } catch (FileAlreadyExistsException x) {\n+            }\n+            assertTrue(target.equals(stream.readSymbolicLink(relsymlink)));\n+            stream.deleteFile(relsymlink);\n+        }\n+\n@@ -349,0 +487,36 @@\n+        try {\n+            stream.createFile(null);\n+            shouldNotGetHere();\n+        } catch (NullPointerException x) { }\n+        try {\n+            stream.createDirectory(null);\n+            shouldNotGetHere();\n+        } catch (NullPointerException x) { }\n+        Path link = Path.of(\"link\");\n+        try {\n+            stream.createLink(null, stream, file);\n+            shouldNotGetHere();\n+        } catch (NullPointerException x) { }\n+        try {\n+            stream.createLink(link, null, file);\n+            shouldNotGetHere();\n+        } catch (NullPointerException x) { }\n+        try {\n+            stream.createLink(link, stream, null);\n+            shouldNotGetHere();\n+        } catch (NullPointerException x) { }\n+        if (supportsSymbolicLinks) {\n+            Path symlink = Path.of(\"symlink\");\n+            try {\n+                stream.createSymbolicLink(null, file);\n+                shouldNotGetHere();\n+            } catch (NullPointerException x) { }\n+            try {\n+                stream.createSymbolicLink(symlink, null);\n+                shouldNotGetHere();\n+            } catch (NullPointerException x) { }\n+            try {\n+                stream.readSymbolicLink(null);\n+                shouldNotGetHere();\n+            } catch (NullPointerException x) { }\n+        }\n@@ -375,0 +549,26 @@\n+        try {\n+            stream.createFile(Path.of(\"nofile\"));\n+            shouldNotGetHere();\n+        } catch (ClosedDirectoryStreamException x) { }\n+        try {\n+            stream.createDirectory(Path.of(\"nodir\"));\n+            shouldNotGetHere();\n+        } catch (ClosedDirectoryStreamException x) { }\n+        link = Path.of(\"nohardlink\");\n+        Path target = Path.of(\"nohardtarget\");\n+        try {\n+            stream.createLink(link, null, target);\n+            shouldNotGetHere();\n+        } catch (ClosedDirectoryStreamException x) { }\n+        if (supportsSymbolicLinks) {\n+            link = Path.of(\"nosymlink\");\n+            target = Path.of(\"nosofttarget\");\n+            try {\n+                stream.createSymbolicLink(link, target);\n+                shouldNotGetHere();\n+            } catch (ClosedDirectoryStreamException x) { }\n+            try {\n+                stream.readSymbolicLink(link);\n+                shouldNotGetHere();\n+            } catch (ClosedDirectoryStreamException x) { }\n+        }\n@@ -388,0 +588,4 @@\n+    static void assertFalse(boolean b) {\n+        if (b) throw new RuntimeException(\"Assertion failed\");\n+    }\n+\n","filename":"test\/jdk\/java\/nio\/file\/DirectoryStream\/SecureDS.java","additions":209,"deletions":5,"binary":false,"changes":214,"status":"modified"}]}