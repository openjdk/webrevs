{"files":[{"patch":"@@ -60,0 +60,1 @@\n+enum class AssertionPredicateType;\n@@ -321,0 +322,13 @@\n+ public:\n+  float _prob;                           \/\/ Probability of true path being taken.\n+  float _fcnt;                           \/\/ Frequency counter\n+\n+ private:\n+  NOT_PRODUCT(AssertionPredicateType _assertion_predicate_type;)\n+\n+  void init_node(Node* control, Node* bol) {\n+    init_class_id(Class_If);\n+    init_req(0, control);\n+    init_req(1, bol);\n+  }\n+\n@@ -325,1 +339,0 @@\n-private:\n@@ -416,8 +429,2 @@\n-  float _prob;                  \/\/ Probability of true path being taken.\n-  float _fcnt;                  \/\/ Frequency counter\n-  IfNode( Node *control, Node *b, float p, float fcnt )\n-    : MultiBranchNode(2), _prob(p), _fcnt(fcnt) {\n-    init_class_id(Class_If);\n-    init_req(0,control);\n-    init_req(1,b);\n-  }\n+  IfNode(Node* control, Node* bol, float p, float fcnt);\n+  NOT_PRODUCT(IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);)\n@@ -453,1 +460,1 @@\n-  int is_range_check(Node* &range, Node* &index, jint &offset);\n+  int is_range_check(Node*& range, Node*& index, jint& offset);\n@@ -456,2 +463,7 @@\n-  RangeCheckNode(Node* control, Node *b, float p, float fcnt)\n-    : IfNode(control, b, p, fcnt) {\n+  RangeCheckNode(Node* control, Node* bol, float p, float fcnt) : IfNode(control, bol, p, fcnt) {\n+    init_class_id(Class_RangeCheck);\n+  }\n+\n+#ifndef PRODUCT\n+  RangeCheckNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type)\n+      : IfNode(control, bol, p, fcnt, assertion_predicate_type) {\n@@ -460,0 +472,1 @@\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -50,0 +50,18 @@\n+IfNode::IfNode(Node* control, Node* bol, float p, float fcnt)\n+    : MultiBranchNode(2),\n+      _prob(p),\n+      _fcnt(fcnt)\n+      NOT_PRODUCT(COMMA _assertion_predicate_type(AssertionPredicateType::None)) {\n+  init_node(control, bol);\n+}\n+\n+#ifndef PRODUCT\n+IfNode::IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type)\n+    : MultiBranchNode(2),\n+      _prob(p),\n+      _fcnt(fcnt),\n+      _assertion_predicate_type(assertion_predicate_type) {\n+  init_node(control, bol);\n+}\n+#endif \/\/ NOT_PRODUCT\n+\n@@ -1825,3 +1843,15 @@\n-\/\/------------------------------dump_spec--------------------------------------\n-void IfNode::dump_spec(outputStream *st) const {\n-  st->print(\"P=%f, C=%f\",_prob,_fcnt);\n+void IfNode::dump_spec(outputStream* st) const {\n+  switch (_assertion_predicate_type) {\n+    case AssertionPredicateType::Init_value:\n+      st->print(\"#Init Value Assertion Predicate  \");\n+      break;\n+    case AssertionPredicateType::Last_value:\n+      st->print(\"#Last Value Assertion Predicate  \");\n+      break;\n+    case AssertionPredicateType::None:\n+      \/\/ No Assertion Predicate\n+      break;\n+    default:\n+      fatal(\"Unknown Assertion Predicate type\");\n+  }\n+  st->print(\"P=%f, C=%f\", _prob, _fcnt);\n@@ -1829,1 +1859,1 @@\n-#endif\n+#endif \/\/ NOT PRODUCT\n@@ -2184,0 +2214,3 @@\n+  if (_useless) {\n+    st->print(\"#useless \");\n+  }\n@@ -2185,1 +2218,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs) {\n+                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs\n+                                                        NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type)) {\n@@ -146,1 +147,2 @@\n-      new_iff = new IfNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n+      new_iff = new IfNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt\n+                           NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -149,1 +151,2 @@\n-      new_iff = new RangeCheckNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n+      new_iff = new RangeCheckNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt\n+                                   NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -1323,1 +1326,2 @@\n-  IfTrueNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  IfTrueNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n+                                                     false NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n@@ -1348,1 +1352,2 @@\n-  new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n+                                         false NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2772,4 +2772,3 @@\n-Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* ctrl,\n-                                                                      const int scale_con, Node* offset, Node* limit,\n-                                                                      jint stride_con, Node* value,\n-                                                                      const bool is_template) {\n+Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(\n+    IdealLoopTree* loop, Node* ctrl, const int scale_con, Node* offset, Node* limit, jint stride_con, Node* value,\n+    const bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n@@ -2996,2 +2995,3 @@\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, opaque_init, true);\n+          loop_entry = add_range_check_elimination_assertion_predicate(\n+              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, opaque_init, true\n+              NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n@@ -3009,2 +3009,3 @@\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, max_value, true);\n+          loop_entry = add_range_check_elimination_assertion_predicate(\n+              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, max_value, true\n+              NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1342,3 +1342,4 @@\n-  IfTrueNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                          Deoptimization::DeoptReason reason, int opcode,\n-                                          bool rewire_uncommon_proj_phi_inputs = false);\n+  IfTrueNode* create_new_if_for_predicate(\n+      ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason, int opcode,\n+      bool rewire_uncommon_proj_phi_inputs = false\n+      NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n@@ -1385,3 +1386,3 @@\n-  Node* add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* predicate_proj, int scale_con,\n-                                                        Node* offset, Node* limit, int stride_con, Node* value,\n-                                                        bool is_template);\n+  Node* add_range_check_elimination_assertion_predicate(\n+      IdealLoopTree* loop, Node* predicate_proj, int scale_con, Node* offset, Node* limit, int stride_con, Node* value,\n+      bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -196,0 +196,9 @@\n+#ifndef PRODUCT\n+\/\/ Assertion Predicates are either emitted to check the initial value of a range check in the first iteration or the last\n+\/\/ value of a range check in the last iteration of a loop.\n+enum class AssertionPredicateType {\n+  None, \/\/ Not an Assertion Predicate\n+  Init_value,\n+  Last_value\n+};\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}