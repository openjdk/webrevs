{"files":[{"patch":"@@ -3949,4 +3949,9 @@\n-\/\/    int a = init2\n-\/\/    for (int phi = init; phi < limit; phi += stride_con) {\n-\/\/      a = init2 + (phi - init) * (stride_con2 \/ stride_con)\n-\/\/    }\n+\/\/    int iv2 = init2\n+\/\/    int iv = init\n+\/\/    loop:\n+\/\/      if ( phi >= limit ) goto exit\n+\/\/      phi += stride_con\n+\/\/      iv2 = init2 + (iv - init) * (stride_con2 \/ stride_con)\n+\/\/      goto loop\n+\/\/    exit:\n+\/\/    ...\n@@ -3960,1 +3965,1 @@\n-\/\/     int a = (phi * stride_con2 \/ stride_con) + (init2 - (init * stride_con2 \/ stride_con))\n+\/\/     int iv2 = (phi * stride_con2 \/ stride_con) + (init2 - (init * stride_con2 \/ stride_con))\n@@ -3968,1 +3973,1 @@\n-\/\/     long a = ((long) phi * stride_con2 \/ stride_con) + (init2 - ((long) init * stride_con2 \/ stride_con))\n+\/\/     long iv2 = ((long) phi * stride_con2 \/ stride_con) + (init2 - ((long) init * stride_con2 \/ stride_con))\n@@ -4036,1 +4041,4 @@\n-    if ((ratio_con * stride_con) == stride_con2) { \/\/ Check for exact\n+    if ((ratio_con * stride_con) != stride_con2) { \/\/ Check for exact (no remainder)\n+        continue;\n+    }\n+\n@@ -4038,4 +4046,4 @@\n-      if (TraceLoopOpts) {\n-        tty->print(\"Parallel IV: %d \", phi2->_idx);\n-        loop->dump_head();\n-      }\n+    if (TraceLoopOpts) {\n+      tty->print(\"Parallel IV: %d \", phi2->_idx);\n+      loop->dump_head();\n+    }\n@@ -4043,33 +4051,31 @@\n-      \/\/ Convert to using the trip counter.  The parallel induction\n-      \/\/ variable differs from the trip counter by a loop-invariant\n-      \/\/ amount, the difference between their respective initial values.\n-      \/\/ It is scaled by the 'ratio_con'.\n-      Node* ratio = _igvn.integercon(ratio_con, stride_con2_bt);\n-      set_ctrl(ratio, C->root());\n-\n-      Node* init_converted = insert_convert_node_if_needed(stride_con2_bt, init);\n-      Node* phi_converted = insert_convert_node_if_needed(stride_con2_bt, phi);\n-\n-      Node* ratio_init = MulNode::make(init_converted, ratio, stride_con2_bt);\n-      _igvn.register_new_node_with_optimizer(ratio_init, init_converted);\n-      set_early_ctrl(ratio_init, false);\n-\n-      Node* diff = SubNode::make(init2, ratio_init, stride_con2_bt);\n-      _igvn.register_new_node_with_optimizer(diff, init2);\n-      set_early_ctrl(diff, false);\n-\n-      Node* ratio_idx = MulNode::make(phi_converted, ratio, stride_con2_bt);\n-      _igvn.register_new_node_with_optimizer(ratio_idx, phi_converted);\n-      set_ctrl(ratio_idx, cl);\n-\n-      Node* add = AddNode::make(ratio_idx, diff, stride_con2_bt);\n-      _igvn.register_new_node_with_optimizer(add);\n-      set_ctrl(add, cl);\n-\n-      _igvn.replace_node( phi2, add );\n-      \/\/ Sometimes an induction variable is unused\n-      if (add->outcnt() == 0) {\n-        _igvn.remove_dead_node(add);\n-      }\n-      --i; \/\/ deleted this phi; rescan starting with next position\n-      continue;\n+\n+    \/\/ Convert to using the trip counter.  The parallel induction\n+    \/\/ variable differs from the trip counter by a loop-invariant\n+    \/\/ amount, the difference between their respective initial values.\n+    \/\/ It is scaled by the 'ratio_con'.\n+    Node* ratio = _igvn.integercon(ratio_con, stride_con2_bt);\n+    set_ctrl(ratio, C->root());\n+\n+    Node* init_converted = insert_convert_node_if_needed(stride_con2_bt, init);\n+    Node* phi_converted = insert_convert_node_if_needed(stride_con2_bt, phi);\n+\n+    Node* ratio_init = MulNode::make(init_converted, ratio, stride_con2_bt);\n+    _igvn.register_new_node_with_optimizer(ratio_init, init_converted);\n+    set_early_ctrl(ratio_init, false);\n+\n+    Node* diff = SubNode::make(init2, ratio_init, stride_con2_bt);\n+    _igvn.register_new_node_with_optimizer(diff, init2);\n+    set_early_ctrl(diff, false);\n+\n+    Node* ratio_idx = MulNode::make(phi_converted, ratio, stride_con2_bt);\n+    _igvn.register_new_node_with_optimizer(ratio_idx, phi_converted);\n+    set_ctrl(ratio_idx, cl);\n+\n+    Node* add = AddNode::make(ratio_idx, diff, stride_con2_bt);\n+    _igvn.register_new_node_with_optimizer(add);\n+    set_ctrl(add, cl);\n+\n+    _igvn.replace_node( phi2, add );\n+    \/\/ Sometimes an induction variable is unused\n+    if (add->outcnt() == 0) {\n+      _igvn.remove_dead_node(add);\n@@ -4077,0 +4083,1 @@\n+    --i; \/\/ deleted this phi; rescan starting with next position\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":51,"deletions":44,"binary":false,"changes":95,"status":"modified"}]}