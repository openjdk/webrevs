{"files":[{"patch":"@@ -2342,6 +2342,9 @@\n-  \/\/ All file descriptors that are opened in the JVM and not\n-  \/\/ specifically destined for a subprocess should have the\n-  \/\/ close-on-exec flag set. If we don't set it, then careless 3rd\n-  \/\/ party native code might fork and exec without closing all\n-  \/\/ appropriate file descriptors (e.g. as we do in closeDescriptors in\n-  \/\/ UNIXProcess.c), and this in turn might:\n+  \/\/ All file descriptors that are opened in the JVM and not specifically destined\n+  \/\/ for a subprocess should have the close-on-exec flag set. Doing so prevents\n+  \/\/ leaking file descriptors to child processes. Note that there is an overlapping\n+  \/\/ failsafe mechanism in UNIXProcess.c that sets all file descriptors to CLOEXEC\n+  \/\/ in the child process before exec(); that failsafe exists mainly to handle\n+  \/\/ descriptors that have been not been opened via os::open() (e.g., third-party\n+  \/\/ native code).\n+  \/\/ Leaking file descriptors can lead to errors that are hard to analyze,\n+  \/\/ e.g.:\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2250,6 +2250,9 @@\n-  \/\/ All file descriptors that are opened in the JVM and not\n-  \/\/ specifically destined for a subprocess should have the\n-  \/\/ close-on-exec flag set.  If we don't set it, then careless 3rd\n-  \/\/ party native code might fork and exec without closing all\n-  \/\/ appropriate file descriptors (e.g. as we do in closeDescriptors in\n-  \/\/ UNIXProcess.c), and this in turn might:\n+  \/\/ All file descriptors that are opened in the JVM and not specifically destined\n+  \/\/ for a subprocess should have the close-on-exec flag set. Doing so prevents\n+  \/\/ leaking file descriptors to child processes. Note that there is an overlapping\n+  \/\/ failsafe mechanism in UNIXProcess.c that sets all file descriptors to CLOEXEC\n+  \/\/ in the child process before exec(); that failsafe exists mainly to handle\n+  \/\/ descriptors that have been not been opened via os::open() (e.g., third-party\n+  \/\/ native code).\n+  \/\/ Leaking file descriptors can lead to errors that are hard to analyze,\n+  \/\/ e.g.:\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4872,6 +4872,9 @@\n-  \/\/ All file descriptors that are opened in the Java process and not\n-  \/\/ specifically destined for a subprocess should have the close-on-exec\n-  \/\/ flag set.  If we don't set it, then careless 3rd party native code\n-  \/\/ might fork and exec without closing all appropriate file descriptors\n-  \/\/ (e.g. as we do in closeDescriptors in UNIXProcess.c), and this in\n-  \/\/ turn might:\n+  \/\/ All file descriptors that are opened in the JVM and not specifically destined\n+  \/\/ for a subprocess should have the close-on-exec flag set. Doing so prevents\n+  \/\/ leaking file descriptors to child processes. Note that there is an overlapping\n+  \/\/ failsafe mechanism in UNIXProcess.c that sets all file descriptors to CLOEXEC\n+  \/\/ in the child process before exec(); that failsafe exists mainly to handle\n+  \/\/ descriptors that have been not been opened via os::open() (e.g., third-party\n+  \/\/ native code).\n+  \/\/ Leaking file descriptors can lead to errors that are hard to analyze,\n+  \/\/ e.g.:\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -375,2 +375,2 @@\n-       Closing pipe fds here is redundant, since closeDescriptors()\n-       would do it anyways, but a little paranoia is a good thing. *\/\n+       Closing pipe fds here is redundant, since markDescriptorsCloseOnExec()\n+       would take care of them anyway, but a little paranoia is a good thing. *\/\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}