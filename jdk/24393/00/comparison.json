{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -42,1 +43,0 @@\n-import sun.security.ssl.HKDF;\n@@ -156,1 +156,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_256, \"SHA-256\"),\n+                \"ECDH\", \"EC\", CurveDB.P_256, \"HKDF-SHA256\"),\n@@ -159,1 +159,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_384, \"SHA-384\"),\n+                \"ECDH\", \"EC\", CurveDB.P_384, \"HKDF-SHA384\"),\n@@ -162,1 +162,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_521, \"SHA-512\"),\n+                \"ECDH\", \"EC\", CurveDB.P_521, \"HKDF-SHA512\"),\n@@ -165,1 +165,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"SHA-256\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"HKDF-SHA256\"),\n@@ -168,1 +168,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"SHA-512\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"HKDF-SHA512\"),\n@@ -250,3 +250,3 @@\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey eae_prk = LabeledExtract(kdf, suiteId, null, EAE_PRK, dh);\n-            return LabeledExpand(kdf, suiteId, eae_prk, SHARED_SECRET,\n+            KDF hkdf = KDF.getInstance(hkdfAlgorithm);\n+            SecretKey eae_prk = LabeledExtract(hkdf, suiteId, EAE_PRK, dh);\n+            return LabeledExpand(hkdf, suiteId, eae_prk, SHARED_SECRET,\n@@ -280,2 +280,2 @@\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey dkp_prk = LabeledExtract(kdf, suiteId, null, DKP_PRK, ikm);\n+            KDF hkdf = KDF.getInstance(hkdfAlgorithm);\n+            SecretKey dkp_prk = LabeledExtract(hkdf, suiteId, DKP_PRK, ikm);\n@@ -290,1 +290,1 @@\n-                    byte[] bytes = LabeledExpand(kdf, suiteId, dkp_prk,\n+                    byte[] bytes = LabeledExpand(hkdf, suiteId, dkp_prk,\n@@ -302,1 +302,1 @@\n-                byte[] sk = LabeledExpand(kdf, suiteId, dkp_prk, SK, EMPTY, Nsk);\n+                byte[] sk = LabeledExpand(hkdf, suiteId, dkp_prk, SK, EMPTY, Nsk);\n@@ -383,5 +383,12 @@\n-    private static SecretKey LabeledExtract(HKDF kdf, byte[] suite_id,\n-            byte[] salt, byte[] label, byte[] ikm) throws InvalidKeyException {\n-        return kdf.extract(salt,\n-                new SecretKeySpec(concat(HPKE_V1, suite_id, label, ikm), \"IKM\"),\n-                    \"HKDF-PRK\");\n+    private static SecretKey LabeledExtract(KDF hkdf, byte[] suite_id,\n+            byte[] label, byte[] ikm) throws InvalidKeyException {\n+        SecretKey s = new SecretKeySpec(concat(HPKE_V1, suite_id, label, ikm),\n+                \"IKM\");\n+        try {\n+            HKDFParameterSpec spec =\n+                    HKDFParameterSpec.ofExtract().addIKM(s).extractOnly();\n+            return hkdf.deriveKey(\"HKDF-PRK\", spec);\n+        } catch (InvalidAlgorithmParameterException |\n+                 NoSuchAlgorithmException e) {\n+            throw new InvalidKeyException(e.getMessage(), e);\n+        }\n@@ -390,1 +397,1 @@\n-    private static byte[] LabeledExpand(HKDF kdf, byte[] suite_id,\n+    private static byte[] LabeledExpand(KDF hkdf, byte[] suite_id,\n@@ -393,3 +400,8 @@\n-        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1,\n-                suite_id, label, info);\n-        return kdf.expand(prk, labeled_info, L, \"NONE\").getEncoded();\n+        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1, suite_id, label,\n+                info);\n+        try {\n+            return hkdf.deriveData(HKDFParameterSpec.expandOnly(\n+                    prk, labeled_info, L));\n+        } catch (InvalidAlgorithmParameterException iape) {\n+            throw new InvalidKeyException(iape.getMessage(), iape);\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":35,"deletions":23,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import javax.crypto.KDF;\n@@ -41,0 +42,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -812,1 +814,1 @@\n-                HKDF hkdf = new HKDF(hashAlg.name);\n+                KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(hashAlg.name));\n@@ -816,2 +818,4 @@\n-                SecretKey masterSecret =\n-                    hkdf.extract(saltSecret, sharedSecret, \"TlsMasterSecret\");\n+                SecretKey masterSecret = hkdf.deriveKey(\"TlsMasterSecret\",\n+                        HKDFParameterSpec.ofExtract()\n+                                         .addSalt(saltSecret)\n+                                         .addIKM(sharedSecret).extractOnly());\n@@ -970,1 +974,1 @@\n-                HKDF hkdf = new HKDF(hashAlg.name);\n+                KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(hashAlg.name));\n@@ -974,3 +978,4 @@\n-                SecretKey masterSecret =\n-                    hkdf.extract(saltSecret, sharedSecret, \"TlsMasterSecret\");\n-\n+                SecretKey masterSecret = hkdf.deriveKey(\"TlsMasterSecret\",\n+                        HKDFParameterSpec.ofExtract()\n+                                         .addSalt(saltSecret)\n+                                         .addIKM(sharedSecret).extractOnly());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,185 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.ssl;\n-\n-import java.security.NoSuchAlgorithmException;\n-import java.security.InvalidKeyException;\n-import javax.crypto.Mac;\n-import javax.crypto.SecretKey;\n-import javax.crypto.ShortBufferException;\n-import javax.crypto.spec.SecretKeySpec;\n-import java.util.Objects;\n-\n-\/**\n- * An implementation of the HKDF key derivation algorithm outlined in RFC 5869,\n- * specific to the needs of TLS 1.3 key derivation in JSSE.  This is not a\n- * general purpose HKDF implementation and is suited only to single-key output\n- * derivations.\n- *\n- * HKDF objects are created by specifying a message digest algorithm.  That\n- * digest algorithm will be used by the HMAC function as part of the HKDF\n- * derivation process.\n- *\/\n-public final class HKDF {\n-    private final Mac hmacObj;\n-    private final int hmacLen;\n-\n-    \/**\n-     * Create an HDKF object, specifying the underlying message digest\n-     * algorithm.\n-     *\n-     * @param hashAlg a standard name corresponding to a supported message\n-     * digest algorithm.\n-     *\n-     * @throws NoSuchAlgorithmException if that message digest algorithm does\n-     * not have an HMAC variant supported on any available provider.\n-     *\/\n-    public HKDF(String hashAlg) throws NoSuchAlgorithmException {\n-        Objects.requireNonNull(hashAlg,\n-                \"Must provide underlying HKDF Digest algorithm.\");\n-        String hmacAlg = \"Hmac\" + hashAlg.replace(\"-\", \"\");\n-        hmacObj = Mac.getInstance(hmacAlg);\n-        hmacLen = hmacObj.getMacLength();\n-    }\n-\n-    \/**\n-     * Perform the HMAC-Extract derivation.\n-     *\n-     * @param salt a salt value, implemented as a {@code SecretKey}.  A\n-     * {@code null} value is allowed, which will internally use an array of\n-     * zero bytes the same size as the underlying hash output length.\n-     * @param inputKey the input keying material provided as a\n-     * {@code SecretKey}.\n-     * @param keyAlg the algorithm name assigned to the resulting\n-     * {@code SecretKey} object.\n-     *\n-     * @return a {@code SecretKey} that is the result of the HKDF extract\n-     * operation.\n-     *\n-     * @throws InvalidKeyException if the {@code salt} parameter cannot be\n-     * used to initialize the underlying HMAC.\n-     *\/\n-    public SecretKey extract(SecretKey salt, SecretKey inputKey, String keyAlg)\n-            throws InvalidKeyException {\n-        if (salt == null) {\n-            salt = new SecretKeySpec(new byte[hmacLen], \"HKDF-Salt\");\n-        }\n-        hmacObj.init(salt);\n-\n-        return new SecretKeySpec(hmacObj.doFinal(inputKey.getEncoded()),\n-                keyAlg);\n-    }\n-\n-    \/**\n-     * Perform the HMAC-Extract derivation.\n-     *\n-     * @param salt a salt value as cleartext bytes.  A {@code null} value is\n-     * allowed, which will internally use an array of zero bytes the same\n-     * size as the underlying hash output length.\n-     * @param inputKey the input keying material provided as a\n-     * {@code SecretKey}.\n-     * @param keyAlg the algorithm name assigned to the resulting\n-     * {@code SecretKey} object.\n-     *\n-     * @return a {@code SecretKey} that is the result of the HKDF extract\n-     * operation.\n-     *\n-     * @throws InvalidKeyException if the {@code salt} parameter cannot be\n-     * used to initialize the underlying HMAC.\n-     *\/\n-    public SecretKey extract(byte[] salt, SecretKey inputKey, String keyAlg)\n-            throws InvalidKeyException {\n-        if (salt == null) {\n-            salt = new byte[hmacLen];\n-        }\n-        return extract(new SecretKeySpec(salt, \"HKDF-Salt\"), inputKey, keyAlg);\n-    }\n-\n-    \/**\n-     * Perform the HKDF-Expand derivation for a single-key output.\n-     *\n-     * @param pseudoRandKey the pseudo random key (PRK).\n-     * @param info optional context-specific info.  A {@code null} value is\n-     * allowed in which case a zero-length byte array will be used.\n-     * @param outLen the length of the resulting {@code SecretKey}\n-     * @param keyAlg the algorithm name applied to the resulting\n-     * {@code SecretKey}\n-     *\n-     * @return the resulting key derivation as a {@code SecretKey} object\n-     *\n-     * @throws InvalidKeyException if the underlying HMAC operation cannot\n-     * be initialized using the provided {@code pseudoRandKey} object.\n-     *\/\n-    public SecretKey expand(SecretKey pseudoRandKey, byte[] info, int outLen,\n-            String keyAlg) throws InvalidKeyException {\n-        byte[] kdfOutput;\n-\n-        \/\/ Calculate the number of rounds of HMAC that are needed to\n-        \/\/ meet the requested data.  Then set up the buffers we will need.\n-        Objects.requireNonNull(pseudoRandKey, \"A null PRK is not allowed.\");\n-\n-        \/\/ Output from the expand operation must be <= 255 * hmac length\n-        if (outLen > 255 * hmacLen) {\n-            throw new IllegalArgumentException(\"Requested output length \" +\n-                    \"exceeds maximum length allowed for HKDF expansion\");\n-        }\n-        hmacObj.init(pseudoRandKey);\n-        if (info == null) {\n-            info = new byte[0];\n-        }\n-        int rounds = (outLen + hmacLen - 1) \/ hmacLen;\n-        kdfOutput = new byte[rounds * hmacLen];\n-        int offset = 0;\n-        int tLength = 0;\n-\n-        for (int i = 0; i < rounds ; i++) {\n-\n-            \/\/ Calculate this round\n-            try {\n-                 \/\/ Add T(i).  This will be an empty string on the first\n-                 \/\/ iteration since tLength starts at zero.  After the first\n-                 \/\/ iteration, tLength is changed to the HMAC length for the\n-                 \/\/ rest of the loop.\n-                hmacObj.update(kdfOutput,\n-                        Math.max(0, offset - hmacLen), tLength);\n-                hmacObj.update(info);                       \/\/ Add info\n-                hmacObj.update((byte)(i + 1));              \/\/ Add round number\n-                hmacObj.doFinal(kdfOutput, offset);\n-\n-                tLength = hmacLen;\n-                offset += hmacLen;                       \/\/ For next iteration\n-            } catch (ShortBufferException sbe) {\n-                \/\/ This really shouldn't happen given that we've\n-                \/\/ sized the buffers to their largest possible size up-front,\n-                \/\/ but just in case...\n-                throw new RuntimeException(sbe);\n-            }\n-        }\n-\n-        return new SecretKeySpec(kdfOutput, 0, outLen, keyAlg);\n-    }\n-}\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HKDF.java","additions":0,"deletions":185,"binary":false,"changes":185,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import javax.crypto.KDF;\n@@ -29,0 +30,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -109,1 +111,1 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n+            KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(hashAlg.name));\n@@ -111,1 +113,1 @@\n-                \/\/ If PSK is not in use Early Secret will still be\n+                \/\/ If PSK is not in use, Early Secret will still be\n@@ -116,2 +118,3 @@\n-                SecretKey earlySecret\n-                        = hkdf.extract(zeros, ikm, \"TlsEarlySecret\");\n+                SecretKey earlySecret = hkdf.deriveKey(\"TlsEarlySecret\",\n+                        HKDFParameterSpec.ofExtract().addSalt(zeros)\n+                        .addIKM(ikm).extractOnly());\n@@ -125,1 +128,3 @@\n-            return hkdf.extract(saltSecret, sharedSecret, algorithm);\n+            return hkdf.deriveKey(algorithm, HKDFParameterSpec.ofExtract()\n+                    .addSalt(saltSecret).addIKM(sharedSecret).extractOnly());\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KAKeyDerivation.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import javax.crypto.KDF;\n@@ -35,0 +36,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -289,1 +291,1 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n+            KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(hashAlg.name));\n@@ -292,2 +294,3 @@\n-            return hkdf.expand(resumptionMasterSecret, hkdfInfo,\n-                    hashAlg.hashLength, \"TlsPreSharedKey\");\n+            return hkdf.deriveKey(\"TlsPreSharedKey\",\n+                    HKDFParameterSpec.expandOnly(resumptionMasterSecret,\n+                    hkdfInfo, hashAlg.hashLength));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import javax.crypto.KDF;\n@@ -34,0 +35,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -790,1 +792,1 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n+            KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(hashAlg.name));\n@@ -794,2 +796,3 @@\n-            SecretKey finishedKey = hkdf.expand(\n-                    binderKey, hkdfInfo, hashAlg.hashLength, \"TlsBinderKey\");\n+            SecretKey finishedKey = hkdf.deriveKey(\"TlsBinderKey\",\n+                    HKDFParameterSpec.expandOnly(binderKey, hkdfInfo,\n+                    hashAlg.hashLength));\n@@ -815,1 +818,1 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n+            KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(hashAlg.name));\n@@ -817,2 +820,3 @@\n-            SecretKey earlySecret = hkdf.extract(zeros, psk, \"TlsEarlySecret\");\n-\n+            SecretKey earlySecret = hkdf.deriveKey(\"TlsEarlySecret\",\n+                    HKDFParameterSpec.ofExtract().addSalt(zeros).addIKM(psk)\n+                    .extractOnly());\n@@ -823,2 +827,3 @@\n-            return hkdf.expand(earlySecret,\n-                    hkdfInfo, hashAlg.hashLength, \"TlsBinderKey\");\n+            return hkdf.deriveKey(\"TlsBinderKey\",\n+                    HKDFParameterSpec.expandOnly(earlySecret, hkdfInfo,\n+                    hashAlg.hashLength));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javax.crypto.KDF;\n@@ -33,0 +34,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -51,3 +53,4 @@\n-            HKDF hkdf = new HKDF(hashAlg);\n-            return hkdf.expand(secret, hkdfInfo,\n-                    ((SecretSizeSpec)keySpec).length, algorithm);\n+            KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(hashAlg));\n+            return hkdf.deriveKey(algorithm,\n+                    HKDFParameterSpec.expandOnly(secret, hkdfInfo,\n+                    ((SecretSizeSpec)keySpec).length));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLBasicKeyDerivation.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javax.crypto.KDF;\n@@ -33,0 +34,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -110,0 +112,1 @@\n+            KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(hashAlg.name));\n@@ -112,3 +115,2 @@\n-\n-            HKDF hkdf = new HKDF(hashAlg.name);\n-            return hkdf.expand(secret, hkdfInfo, hashAlg.hashLength, algorithm);\n+            return hkdf.deriveKey(algorithm, HKDFParameterSpec.expandOnly(\n+                    secret, hkdfInfo, hashAlg.hashLength));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSecretDerivation.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import javax.crypto.KDF;\n@@ -35,0 +36,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -150,6 +152,6 @@\n-                HKDF hkdf = new HKDF(cs.hashAlg.name);\n-                byte[] hkdfInfo =\n-                        createHkdfInfo(ks.label, ks.getKeyLength(cs));\n-                return hkdf.expand(secret, hkdfInfo,\n-                        ks.getKeyLength(cs),\n-                        ks.getAlgorithm(cs, algorithm));\n+                KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(\n+                        cs.hashAlg.name));\n+                byte[] hkdfInfo = createHkdfInfo(ks.label, ks.getKeyLength(cs));\n+                return hkdf.deriveKey(ks.getAlgorithm(cs, algorithm),\n+                        HKDFParameterSpec.expandOnly(secret, hkdfInfo,\n+                        ks.getKeyLength(cs)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTrafficKeyDerivation.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import javax.crypto.KDF;\n@@ -39,0 +40,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -1225,1 +1227,1 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n+            KDF hkdf = KDF.getInstance(Utilities.digest2HKDF(hashAlg.name));\n@@ -1227,1 +1229,3 @@\n-            SecretKey earlySecret = hkdf.extract(zeros, psk, \"TlsEarlySecret\");\n+            SecretKey earlySecret = hkdf.deriveKey(\"TlsEarlySecret\",\n+                    HKDFParameterSpec.ofExtract().addSalt(zeros).addIKM(psk)\n+                    .extractOnly());\n@@ -1230,1 +1234,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,10 @@\n+    \/\/ return the HKDF algorithm name using the specified digest algorithm\n+    static String digest2HKDF(String digestAlg) throws SSLHandshakeException {\n+        String sanitizedAlg = digestAlg.replace(\"-\", \"\");\n+        return switch (sanitizedAlg) {\n+            case \"SHA256\", \"SHA384\", \"SHA512\" -> \"HKDF-\" + sanitizedAlg;\n+            default -> throw new SSLHandshakeException(\"No HKDF support for \" +\n+                    digestAlg);\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Utilities.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-modules = \\\n-    java.base\/sun.security.ssl\n-bootclasspath.dirs=.\n","filename":"test\/jdk\/sun\/security\/ssl\/internal\/TEST.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8145255\n- * @run main\/othervm java.base\/sun.security.ssl.TestHkdf\n- * @summary HKDF for Sun JSSE\n- *\/\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/internal\/TestRun.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * Actual test code for the package private HKDF implementation\n- *\/\n-\n-package sun.security.ssl;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.LinkedList;\n-import java.util.Objects;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.InvalidKeyException;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.SecretKeySpec;\n-\n-public class TestHkdf {\n-    public static class TestData {\n-        public TestData(String name, String algStr, String ikmStr,\n-                String saltStr, String infoStr, int oLen, String expPrkStr,\n-                String expOkmStr) {\n-            testName = Objects.requireNonNull(name);\n-            algName = Objects.requireNonNull(algStr);\n-            IKM = hex2bin(Objects.requireNonNull(ikmStr));\n-            if ((outLen = oLen) <= 0) {\n-                throw new IllegalArgumentException(\n-                        \"Output length must be greater than 0\");\n-            }\n-            expectedPRK = hex2bin(Objects.requireNonNull(expPrkStr));\n-            expectedOKM = hex2bin(Objects.requireNonNull(expOkmStr));\n-\n-            \/\/ Non-mandatory fields - may be null\n-            salt = (saltStr != null) ? hex2bin(saltStr) : null;\n-            info = (infoStr != null) ? hex2bin(infoStr) : null;\n-        }\n-\n-        public final String testName;\n-        public final String algName;\n-        public final byte[] IKM;\n-        public final byte[] salt;\n-        public final byte[] info;\n-        public final int outLen;\n-        public final byte[] expectedPRK;\n-        public final byte[] expectedOKM;\n-    }\n-\n-    public static final List<TestData> testList = new LinkedList<TestData>() {{\n-        add(new TestData(\"RFC 5689 Test Case 1\", \"SHA-256\",\n-            \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n-            \"000102030405060708090a0b0c\",\n-            \"f0f1f2f3f4f5f6f7f8f9\",\n-            42,\n-            \"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\",\n-            \"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf\" +\n-            \"34007208d5b887185865\"));\n-        add(new TestData(\"RFC 5689 Test Case 2\", \"SHA-256\",\n-            \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\" +\n-            \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\" +\n-            \"404142434445464748494a4b4c4d4e4f\",\n-            \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\" +\n-            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\" +\n-            \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n-            \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\" +\n-            \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\" +\n-            \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n-            82,\n-            \"06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244\",\n-            \"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c\" +\n-            \"59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71\" +\n-            \"cc30c58179ec3e87c14c01d5c1f3434f1d87\"));\n-        add(new TestData(\"RFC 5689 Test Case 3\", \"SHA-256\",\n-            \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n-            null, null, 42,\n-            \"19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04\",\n-            \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\" +\n-            \"9d201395faa4b61a96c8\"));\n-        add(new TestData(\"RFC 5689 Test Case 4\", \"SHA-1\",\n-            \"0b0b0b0b0b0b0b0b0b0b0b\",\n-            \"000102030405060708090a0b0c\",\n-            \"f0f1f2f3f4f5f6f7f8f9\",\n-            42,\n-            \"9b6c18c432a7bf8f0e71c8eb88f4b30baa2ba243\",\n-            \"085a01ea1b10f36933068b56efa5ad81a4f14b822f5b091568a9cdd4f155fda2\" +\n-            \"c22e422478d305f3f896\"));\n-        add(new TestData(\"RFC 5689 Test Case 5\", \"SHA-1\",\n-            \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\" +\n-            \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\" +\n-            \"404142434445464748494a4b4c4d4e4f\",\n-            \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\" +\n-            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\" +\n-            \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n-            \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\" +\n-            \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\" +\n-            \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n-            82,\n-            \"8adae09a2a307059478d309b26c4115a224cfaf6\",\n-            \"0bd770a74d1160f7c9f12cd5912a06ebff6adcae899d92191fe4305673ba2ffe\" +\n-            \"8fa3f1a4e5ad79f3f334b3b202b2173c486ea37ce3d397ed034c7f9dfeb15c5e\" +\n-            \"927336d0441f4c4300e2cff0d0900b52d3b4\"));\n-        add(new TestData(\"RFC 5689 Test Case 6\", \"SHA-1\",\n-            \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n-            null, null, 42,\n-            \"da8c8a73c7fa77288ec6f5e7c297786aa0d32d01\",\n-            \"0ac1af7002b3d761d1e55298da9d0506b9ae52057220a306e07b6b87e8df21d0\" +\n-            \"ea00033de03984d34918\"));\n-        add(new TestData(\"RFC 5689 Test Case 7\", \"SHA-1\",\n-            \"0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c\",\n-            null, null, 42,\n-            \"2adccada18779e7c2077ad2eb19d3f3e731385dd\",\n-            \"2c91117204d745f3500d636a62f64f0ab3bae548aa53d423b0d1f27ebba6f5e5\" +\n-            \"673a081d70cce7acfc48\"));\n-    }};\n-\n-    public static void main(String args[]) throws Exception {\n-        int testsPassed = 0;\n-\n-        int testNo = 0;\n-        for (TestData test : testList) {\n-            System.out.println(\"*** Test \" + ++testNo + \": \" +\n-                    test.testName);\n-            if (runVector(test)) {\n-                testsPassed++;\n-            }\n-        }\n-\n-        System.out.println(\"Total tests: \" + testList.size() +\n-                \", Passed: \" + testsPassed + \", Failed: \" +\n-                (testList.size() - testsPassed));\n-        if (testsPassed != testList.size()) {\n-            throw new RuntimeException(\"One or more tests failed.  \" +\n-                    \"Check output for details\");\n-        }\n-    }\n-\n-    private static boolean runVector(TestData testData)\n-            throws NoSuchAlgorithmException, InvalidKeyException {\n-        String kdfName, prfName;\n-        HKDF kdfHkdf;\n-        boolean result = true;\n-        SecretKey actualPRK;\n-        SecretKey actualOKM;\n-        byte[] deriveData;\n-\n-        \/\/ Get an instance of the HKDF derivation engine\n-        kdfHkdf = new HKDF(testData.algName);\n-\n-        \/\/ Set up the input keying material and the salt as a secret\n-        SecretKey ikmKey = new SecretKeySpec(testData.IKM, \"HKDF-IKM\");\n-        SecretKey saltKey = (testData.salt != null) ?\n-                new SecretKeySpec(testData.salt, \"HKDF-Salt\") : null;\n-\n-        \/\/ *** HKDF-Extract-only testing\n-        System.out.println(\"* HKDF-Extract-Only:\");\n-        actualPRK = kdfHkdf.extract(saltKey, ikmKey, \"HKDF-PRK\");\n-        result &= compareKeyAndData(actualPRK, testData.expectedPRK);\n-\n-        \/\/ *** HKDF Expand-Only testing\n-        \/\/ For these tests, we'll use the actualPRK as the input key\n-        System.out.println(\"* HKDF-Expand-Only:\");\n-        actualOKM = kdfHkdf.expand(actualPRK, testData.info, testData.outLen,\n-                \"HKDF-OKM\");\n-        result &= compareKeyAndData(actualOKM, testData.expectedOKM);\n-\n-        \/\/ *** HKDF Extract-then-Expand testing\n-        \/\/ System.out.println(\"* HKDF-Extract-then-Expand:\");\n-        \/\/ actualOKM = kdfHkdf.extractExpand(ikmKey, saltKey, testData.info,\n-        \/\/         testData.outLen, \"HKDF-OKM2\");\n-        \/\/ result &= compareKeyAndData(actualOKM, testData.expectedOKM);\n-\n-        return result;\n-    }\n-\n-    \/**\n-     * Compare actual key output from HKDF against an expected output value.\n-     *\n-     * @param outKey the KDF output in key form\n-     * @param expectedOut the expected value\n-     *\n-     * @return true if the underlying data for outKey, outData and\n-     * expectedOut are the same.\n-     *\/\n-    private static boolean compareKeyAndData(SecretKey outKey,\n-            byte[] expectedOut) {\n-        boolean result = false;\n-\n-        if (Arrays.equals(outKey.getEncoded(), expectedOut)) {\n-            System.out.println(\"\\t* Key output: Pass\");\n-            result = true;\n-        } else {\n-            System.out.println(\"\\t* Key output: FAIL\");\n-            System.out.println(\"Expected:\\n\" +\n-                    dumpHexBytes(expectedOut, 16, \"\\n\", \" \"));\n-            System.out.println(\"Actual:\\n\" +\n-                    dumpHexBytes(outKey.getEncoded(), 16, \"\\n\", \" \"));\n-            System.out.println();\n-        }\n-\n-        return result;\n-    }\n-\n-    \/**\n-     * Dump the hex bytes of a buffer into string form.\n-     *\n-     * @param data The array of bytes to dump to stdout.\n-     * @param itemsPerLine The number of bytes to display per line\n-     *      if the {@code lineDelim} character is blank then all bytes\n-     *      will be printed on a single line.\n-     * @param lineDelim The delimiter between lines\n-     * @param itemDelim The delimiter between bytes\n-     *\n-     * @return The hexdump of the byte array\n-     *\/\n-    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n-            String lineDelim, String itemDelim) {\n-        StringBuilder sb = new StringBuilder();\n-        if (data != null) {\n-            for (int i = 0; i < data.length; i++) {\n-                if (i % itemsPerLine == 0 && i != 0) {\n-                    sb.append(lineDelim);\n-                }\n-                sb.append(String.format(\"%02X\", data[i])).append(itemDelim);\n-            }\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    private static byte[] hex2bin(String hex) {\n-        int i;\n-        int len = hex.length();\n-        byte[] data = new byte [len \/ 2];\n-        for (i = 0; i < len; i += 2) {\n-            data[i \/ 2] = (byte)((Character.digit(hex.charAt(i), 16) << 4) +\n-                    Character.digit(hex.charAt(i + 1), 16));\n-        }\n-        return data;\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/ssl\/internal\/java.base\/sun\/security\/ssl\/TestHkdf.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"}]}