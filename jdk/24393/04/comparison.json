{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -42,1 +43,0 @@\n-import sun.security.ssl.HKDF;\n@@ -45,0 +45,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -156,1 +158,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_256, \"SHA-256\"),\n+                \"ECDH\", \"EC\", CurveDB.P_256, \"HKDF-SHA256\"),\n@@ -159,1 +161,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_384, \"SHA-384\"),\n+                \"ECDH\", \"EC\", CurveDB.P_384, \"HKDF-SHA384\"),\n@@ -162,1 +164,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_521, \"SHA-512\"),\n+                \"ECDH\", \"EC\", CurveDB.P_521, \"HKDF-SHA512\"),\n@@ -165,1 +167,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"SHA-256\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"HKDF-SHA256\"),\n@@ -168,1 +170,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"SHA-512\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"HKDF-SHA512\"),\n@@ -250,4 +252,11 @@\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey eae_prk = LabeledExtract(kdf, suiteId, null, EAE_PRK, dh);\n-            return LabeledExpand(kdf, suiteId, eae_prk, SHARED_SECRET,\n-                    kem_context, Nsecret);\n+            KDF hkdf = KDF.getInstance(hkdfAlgorithm);\n+            SecretKey eae_prk = LabeledExtract(hkdf, suiteId, EAE_PRK, dh);\n+            try {\n+                return LabeledExpand(hkdf, suiteId, eae_prk, SHARED_SECRET,\n+                        kem_context, Nsecret);\n+            } finally {\n+                if (eae_prk instanceof SecretKeySpec s) {\n+                    SharedSecrets.getJavaxCryptoSpecAccess()\n+                            .clearSecretKeySpec(s);\n+                }\n+            }\n@@ -280,15 +289,21 @@\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey dkp_prk = LabeledExtract(kdf, suiteId, null, DKP_PRK, ikm);\n-            if (isEC()) {\n-                NamedCurve curve = (NamedCurve) spec;\n-                BigInteger sk = BigInteger.ZERO;\n-                int counter = 0;\n-                while (sk.signum() == 0 || sk.compareTo(curve.getOrder()) >= 0) {\n-                    if (counter > 255) {\n-                        throw new RuntimeException();\n-                    }\n-                    byte[] bytes = LabeledExpand(kdf, suiteId, dkp_prk,\n-                            CANDIDATE, I2OSP(counter, 1), Nsk);\n-                    \/\/ bitmask is defined to be 0xFF for P-256 and P-384, and 0x01 for P-521\n-                    if (this == Params.P521) {\n-                        bytes[0] = (byte) (bytes[0] & 0x01);\n+            KDF hkdf = KDF.getInstance(hkdfAlgorithm);\n+            SecretKey dkp_prk = LabeledExtract(hkdf, suiteId, DKP_PRK, ikm);\n+            try {\n+                if (isEC()) {\n+                    NamedCurve curve = (NamedCurve) spec;\n+                    BigInteger sk = BigInteger.ZERO;\n+                    int counter = 0;\n+                    while (sk.signum() == 0 ||\n+                            sk.compareTo(curve.getOrder()) >= 0) {\n+                        if (counter > 255) {\n+                            throw new RuntimeException();\n+                        }\n+                        byte[] bytes = LabeledExpand(hkdf, suiteId, dkp_prk,\n+                                CANDIDATE, I2OSP(counter, 1), Nsk);\n+                        \/\/ bitmask is defined to be 0xFF for P-256 and P-384,\n+                        \/\/ and 0x01 for P-521\n+                        if (this == Params.P521) {\n+                            bytes[0] = (byte) (bytes[0] & 0x01);\n+                        }\n+                        sk = new BigInteger(1, (bytes));\n+                        counter = counter + 1;\n@@ -296,2 +311,12 @@\n-                    sk = new BigInteger(1, (bytes));\n-                    counter = counter + 1;\n+                    PrivateKey k = DeserializePrivateKey(sk.toByteArray());\n+                    return new KeyPair(getPublicKey(k), k);\n+                } else {\n+                    byte[] sk = LabeledExpand(hkdf, suiteId, dkp_prk, SK, EMPTY,\n+                            Nsk);\n+                    PrivateKey k = DeserializePrivateKey(sk);\n+                    return new KeyPair(getPublicKey(k), k);\n+                }\n+            } finally {\n+                if (dkp_prk instanceof SecretKeySpec s) {\n+                    SharedSecrets.getJavaxCryptoSpecAccess()\n+                            .clearSecretKeySpec(s);\n@@ -299,6 +324,0 @@\n-                PrivateKey k = DeserializePrivateKey(sk.toByteArray());\n-                return new KeyPair(getPublicKey(k), k);\n-            } else {\n-                byte[] sk = LabeledExpand(kdf, suiteId, dkp_prk, SK, EMPTY, Nsk);\n-                PrivateKey k = DeserializePrivateKey(sk);\n-                return new KeyPair(getPublicKey(k), k);\n@@ -383,5 +402,14 @@\n-    private static SecretKey LabeledExtract(HKDF kdf, byte[] suite_id,\n-            byte[] salt, byte[] label, byte[] ikm) throws InvalidKeyException {\n-        return kdf.extract(salt,\n-                new SecretKeySpec(concat(HPKE_V1, suite_id, label, ikm), \"IKM\"),\n-                    \"HKDF-PRK\");\n+    private static SecretKey LabeledExtract(KDF hkdf, byte[] suite_id,\n+            byte[] label, byte[] ikm) throws InvalidKeyException {\n+        SecretKeySpec s = new SecretKeySpec(concat(HPKE_V1, suite_id, label,\n+                ikm), \"IKM\");\n+        try {\n+            HKDFParameterSpec spec =\n+                    HKDFParameterSpec.ofExtract().addIKM(s).extractOnly();\n+            return hkdf.deriveKey(\"Generic\", spec);\n+        } catch (InvalidAlgorithmParameterException |\n+                 NoSuchAlgorithmException e) {\n+            throw new InvalidKeyException(e.getMessage(), e);\n+        } finally {\n+            SharedSecrets.getJavaxCryptoSpecAccess().clearSecretKeySpec(s);\n+        }\n@@ -390,1 +418,1 @@\n-    private static byte[] LabeledExpand(HKDF kdf, byte[] suite_id,\n+    private static byte[] LabeledExpand(KDF hkdf, byte[] suite_id,\n@@ -393,3 +421,8 @@\n-        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1,\n-                suite_id, label, info);\n-        return kdf.expand(prk, labeled_info, L, \"NONE\").getEncoded();\n+        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1, suite_id, label,\n+                info);\n+        try {\n+            return hkdf.deriveData(HKDFParameterSpec.expandOnly(\n+                    prk, labeled_info, L));\n+        } catch (InvalidAlgorithmParameterException iape) {\n+            throw new InvalidKeyException(iape.getMessage(), iape);\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":76,"deletions":43,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                            tkd.getTrafficKey(hc.sslConfig.isClientMode ?\n+                            tkd.deriveKey(hc.sslConfig.isClientMode ?\n@@ -87,7 +87,4 @@\n-\n-            SecretKey writeKey =\n-                    tkd.getTrafficKey(hc.sslConfig.isClientMode ?\n-                                    \"clientWriteKey\" : \"serverWriteKey\");\n-            SecretKey writeIv =\n-                    tkd.getTrafficKey(hc.sslConfig.isClientMode ?\n-                                    \"clientWriteIv\" : \"serverWriteIv\");\n+            SecretKey writeKey = tkd.deriveKey(hc.sslConfig.isClientMode ?\n+                    \"clientWriteKey\" : \"serverWriteKey\");\n+            byte[] writeIv = tkd.deriveData(hc.sslConfig.isClientMode ?\n+                    \"clientWriteIv\" : \"serverWriteIv\");\n@@ -95,1 +92,2 @@\n-                    new IvParameterSpec(writeIv.getEncoded());\n+                    new IvParameterSpec(writeIv);\n+\n@@ -176,1 +174,1 @@\n-                                tkd.getTrafficKey(hc.sslConfig.isClientMode ?\n+                                tkd.deriveKey(hc.sslConfig.isClientMode ?\n@@ -184,6 +182,4 @@\n-                SecretKey readKey =\n-                        tkd.getTrafficKey(hc.sslConfig.isClientMode ?\n-                                        \"serverWriteKey\" : \"clientWriteKey\");\n-                SecretKey readIv =\n-                        tkd.getTrafficKey(hc.sslConfig.isClientMode ?\n-                                        \"serverWriteIv\" : \"clientWriteIv\");\n+                SecretKey readKey = tkd.deriveKey(hc.sslConfig.isClientMode ?\n+                        \"serverWriteKey\" : \"clientWriteKey\");\n+                byte[] readIv = tkd.deriveData(hc.sslConfig.isClientMode ?\n+                        \"serverWriteIv\" : \"clientWriteIv\");\n@@ -191,1 +187,1 @@\n-                        new IvParameterSpec(readIv.getEncoded());\n+                        new IvParameterSpec(readIv);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ChangeCipherSpec.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1202,0 +1202,1 @@\n+        final String hkdfAlgorithm;\n@@ -1207,0 +1208,1 @@\n+            this.hkdfAlgorithm = \"HKDF-\" + hashAlg.replace(\"-\", \"\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CipherSuite.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,2 +209,1 @@\n-                SecretKey masterSecret =\n-                        masterKD.deriveKey(\"MasterSecret\", null);\n+                SecretKey masterSecret = masterKD.deriveKey(\"MasterSecret\");\n@@ -305,2 +304,1 @@\n-            SecretKey masterSecret =\n-                    masterKD.deriveKey(\"MasterSecret\", null);\n+            SecretKey masterSecret = masterKD.deriveKey(\"MasterSecret\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHClientKeyExchange.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,2 +221,1 @@\n-                SecretKey masterSecret =\n-                        masterKD.deriveKey(\"MasterSecret\", null);\n+                SecretKey masterSecret = masterKD.deriveKey(\"MasterSecret\");\n@@ -341,2 +340,1 @@\n-            SecretKey masterSecret =\n-                    masterKD.deriveKey(\"MasterSecret\", null);\n+            SecretKey masterSecret = masterKD.deriveKey(\"MasterSecret\");\n@@ -421,2 +419,1 @@\n-                SecretKey masterSecret =\n-                        masterKD.deriveKey(\"MasterSecret\", null);\n+                SecretKey masterSecret = masterKD.deriveKey(\"MasterSecret\");\n@@ -525,2 +522,1 @@\n-            SecretKey masterSecret =\n-                    masterKD.deriveKey(\"MasterSecret\", null);\n+            SecretKey masterSecret = masterKD.deriveKey(\"MasterSecret\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHClientKeyExchange.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import javax.crypto.KDF;\n@@ -41,0 +42,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -50,1 +52,0 @@\n-import sun.security.ssl.SSLBasicKeyDerivation.SecretSizeSpec;\n@@ -56,0 +57,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -341,6 +344,2 @@\n-                    secret, hashAlg.name,\n-                    hkdfLabel, hkdfContext, hashAlg.hashLength);\n-            AlgorithmParameterSpec keySpec =\n-                    new SecretSizeSpec(hashAlg.hashLength);\n-            SecretKey finishedSecret =\n-                    kdf.deriveKey(\"TlsFinishedSecret\", keySpec);\n+                    secret, hashAlg, hkdfLabel, hkdfContext);\n+            SecretKey finishedSecret = kdf.deriveKey(\"TlsFinishedSecret\");\n@@ -357,0 +356,5 @@\n+            } finally {\n+                if (finishedSecret instanceof SecretKeySpec s) {\n+                    SharedSecrets.getJavaxCryptoSpecAccess()\n+                            .clearSecretKeySpec(s);\n+                }\n@@ -720,2 +724,2 @@\n-                SecretKey writeSecret = kd.deriveKey(\n-                        \"TlsClientAppTrafficSecret\", null);\n+                SecretKey writeSecret =\n+                        kd.deriveKey(\"TlsClientAppTrafficSecret\");\n@@ -725,4 +729,1 @@\n-                SecretKey writeKey = writeKD.deriveKey(\n-                        \"TlsKey\", null);\n-                SecretKey writeIvSecret = writeKD.deriveKey(\n-                        \"TlsIv\", null);\n+                SecretKey writeKey = writeKD.deriveKey(\"TlsKey\");\n@@ -730,1 +731,1 @@\n-                        new IvParameterSpec(writeIvSecret.getEncoded());\n+                        new IvParameterSpec(writeKD.deriveData(\"TlsIv\"));\n@@ -757,1 +758,1 @@\n-                    \"TlsResumptionMasterSecret\", null);\n+                    \"TlsResumptionMasterSecret\");\n@@ -806,1 +807,1 @@\n-            \/\/ derive salt secret\n+            SecretKey saltSecret = null;\n@@ -808,1 +809,2 @@\n-                SecretKey saltSecret = kd.deriveKey(\"TlsSaltSecret\", null);\n+                \/\/ derive salt secret\n+                saltSecret = kd.deriveKey(\"TlsSaltSecret\");\n@@ -812,1 +814,1 @@\n-                HKDF hkdf = new HKDF(hashAlg.name);\n+                KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n@@ -814,5 +816,3 @@\n-                SecretKeySpec sharedSecret =\n-                        new SecretKeySpec(zeros, \"TlsZeroSecret\");\n-                SecretKey masterSecret =\n-                    hkdf.extract(saltSecret, sharedSecret, \"TlsMasterSecret\");\n-\n+                SecretKey masterSecret = hkdf.deriveKey(\"TlsMasterSecret\",\n+                        HKDFParameterSpec.ofExtract().addSalt(saltSecret)\n+                        .addIKM(zeros).extractOnly());\n@@ -824,1 +824,1 @@\n-                        \"TlsServerAppTrafficSecret\", null);\n+                        \"TlsServerAppTrafficSecret\");\n@@ -827,4 +827,1 @@\n-                SecretKey writeKey = writeKD.deriveKey(\n-                        \"TlsKey\", null);\n-                SecretKey writeIvSecret = writeKD.deriveKey(\n-                        \"TlsIv\", null);\n+                SecretKey writeKey = writeKD.deriveKey(\"TlsKey\");\n@@ -832,1 +829,1 @@\n-                        new IvParameterSpec(writeIvSecret.getEncoded());\n+                        new IvParameterSpec(writeKD.deriveData(\"TlsIv\"));\n@@ -855,0 +852,5 @@\n+            } finally {\n+                if (saltSecret instanceof SecretKeySpec s) {\n+                    SharedSecrets.getJavaxCryptoSpecAccess()\n+                            .clearSecretKeySpec(s);\n+                }\n@@ -963,2 +965,1 @@\n-\n-            \/\/ derive salt secret\n+            SecretKey saltSecret = null;\n@@ -966,1 +967,2 @@\n-                SecretKey saltSecret = kd.deriveKey(\"TlsSaltSecret\", null);\n+                \/\/ derive salt secret\n+                saltSecret = kd.deriveKey(\"TlsSaltSecret\");\n@@ -970,1 +972,1 @@\n-                HKDF hkdf = new HKDF(hashAlg.name);\n+                KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n@@ -972,4 +974,4 @@\n-                SecretKeySpec sharedSecret =\n-                        new SecretKeySpec(zeros, \"TlsZeroSecret\");\n-                SecretKey masterSecret =\n-                    hkdf.extract(saltSecret, sharedSecret, \"TlsMasterSecret\");\n+                SecretKey masterSecret = hkdf.deriveKey(\"TlsMasterSecret\",\n+                        HKDFParameterSpec.ofExtract()\n+                                         .addSalt(saltSecret)\n+                                         .addIKM(zeros).extractOnly());\n@@ -982,1 +984,1 @@\n-                        \"TlsServerAppTrafficSecret\", null);\n+                        \"TlsServerAppTrafficSecret\");\n@@ -985,4 +987,1 @@\n-                SecretKey readKey = writeKD.deriveKey(\n-                        \"TlsKey\", null);\n-                SecretKey readIvSecret = writeKD.deriveKey(\n-                        \"TlsIv\", null);\n+                SecretKey readKey = writeKD.deriveKey(\"TlsKey\");\n@@ -990,1 +989,1 @@\n-                        new IvParameterSpec(readIvSecret.getEncoded());\n+                        new IvParameterSpec(writeKD.deriveData(\"TlsIv\"));\n@@ -1012,0 +1011,5 @@\n+            } finally {\n+                if (saltSecret instanceof SecretKeySpec s) {\n+                    SharedSecrets.getJavaxCryptoSpecAccess()\n+                            .clearSecretKeySpec(s);\n+                }\n@@ -1087,1 +1091,1 @@\n-                        \"TlsClientAppTrafficSecret\", null);\n+                        \"TlsClientAppTrafficSecret\");\n@@ -1091,4 +1095,1 @@\n-                SecretKey readKey = readKD.deriveKey(\n-                        \"TlsKey\", null);\n-                SecretKey readIvSecret = readKD.deriveKey(\n-                        \"TlsIv\", null);\n+                SecretKey readKey = readKD.deriveKey(\"TlsKey\");\n@@ -1096,1 +1097,1 @@\n-                        new IvParameterSpec(readIvSecret.getEncoded());\n+                        new IvParameterSpec(readKD.deriveData(\"TlsIv\"));\n@@ -1118,2 +1119,2 @@\n-                SecretKey resumptionMasterSecret = sd.deriveKey(\n-                \"TlsResumptionMasterSecret\", null);\n+                SecretKey resumptionMasterSecret =\n+                        sd.deriveKey(\"TlsResumptionMasterSecret\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":53,"deletions":52,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -1,185 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.ssl;\n-\n-import java.security.NoSuchAlgorithmException;\n-import java.security.InvalidKeyException;\n-import javax.crypto.Mac;\n-import javax.crypto.SecretKey;\n-import javax.crypto.ShortBufferException;\n-import javax.crypto.spec.SecretKeySpec;\n-import java.util.Objects;\n-\n-\/**\n- * An implementation of the HKDF key derivation algorithm outlined in RFC 5869,\n- * specific to the needs of TLS 1.3 key derivation in JSSE.  This is not a\n- * general purpose HKDF implementation and is suited only to single-key output\n- * derivations.\n- *\n- * HKDF objects are created by specifying a message digest algorithm.  That\n- * digest algorithm will be used by the HMAC function as part of the HKDF\n- * derivation process.\n- *\/\n-public final class HKDF {\n-    private final Mac hmacObj;\n-    private final int hmacLen;\n-\n-    \/**\n-     * Create an HDKF object, specifying the underlying message digest\n-     * algorithm.\n-     *\n-     * @param hashAlg a standard name corresponding to a supported message\n-     * digest algorithm.\n-     *\n-     * @throws NoSuchAlgorithmException if that message digest algorithm does\n-     * not have an HMAC variant supported on any available provider.\n-     *\/\n-    public HKDF(String hashAlg) throws NoSuchAlgorithmException {\n-        Objects.requireNonNull(hashAlg,\n-                \"Must provide underlying HKDF Digest algorithm.\");\n-        String hmacAlg = \"Hmac\" + hashAlg.replace(\"-\", \"\");\n-        hmacObj = Mac.getInstance(hmacAlg);\n-        hmacLen = hmacObj.getMacLength();\n-    }\n-\n-    \/**\n-     * Perform the HMAC-Extract derivation.\n-     *\n-     * @param salt a salt value, implemented as a {@code SecretKey}.  A\n-     * {@code null} value is allowed, which will internally use an array of\n-     * zero bytes the same size as the underlying hash output length.\n-     * @param inputKey the input keying material provided as a\n-     * {@code SecretKey}.\n-     * @param keyAlg the algorithm name assigned to the resulting\n-     * {@code SecretKey} object.\n-     *\n-     * @return a {@code SecretKey} that is the result of the HKDF extract\n-     * operation.\n-     *\n-     * @throws InvalidKeyException if the {@code salt} parameter cannot be\n-     * used to initialize the underlying HMAC.\n-     *\/\n-    public SecretKey extract(SecretKey salt, SecretKey inputKey, String keyAlg)\n-            throws InvalidKeyException {\n-        if (salt == null) {\n-            salt = new SecretKeySpec(new byte[hmacLen], \"HKDF-Salt\");\n-        }\n-        hmacObj.init(salt);\n-\n-        return new SecretKeySpec(hmacObj.doFinal(inputKey.getEncoded()),\n-                keyAlg);\n-    }\n-\n-    \/**\n-     * Perform the HMAC-Extract derivation.\n-     *\n-     * @param salt a salt value as cleartext bytes.  A {@code null} value is\n-     * allowed, which will internally use an array of zero bytes the same\n-     * size as the underlying hash output length.\n-     * @param inputKey the input keying material provided as a\n-     * {@code SecretKey}.\n-     * @param keyAlg the algorithm name assigned to the resulting\n-     * {@code SecretKey} object.\n-     *\n-     * @return a {@code SecretKey} that is the result of the HKDF extract\n-     * operation.\n-     *\n-     * @throws InvalidKeyException if the {@code salt} parameter cannot be\n-     * used to initialize the underlying HMAC.\n-     *\/\n-    public SecretKey extract(byte[] salt, SecretKey inputKey, String keyAlg)\n-            throws InvalidKeyException {\n-        if (salt == null) {\n-            salt = new byte[hmacLen];\n-        }\n-        return extract(new SecretKeySpec(salt, \"HKDF-Salt\"), inputKey, keyAlg);\n-    }\n-\n-    \/**\n-     * Perform the HKDF-Expand derivation for a single-key output.\n-     *\n-     * @param pseudoRandKey the pseudo random key (PRK).\n-     * @param info optional context-specific info.  A {@code null} value is\n-     * allowed in which case a zero-length byte array will be used.\n-     * @param outLen the length of the resulting {@code SecretKey}\n-     * @param keyAlg the algorithm name applied to the resulting\n-     * {@code SecretKey}\n-     *\n-     * @return the resulting key derivation as a {@code SecretKey} object\n-     *\n-     * @throws InvalidKeyException if the underlying HMAC operation cannot\n-     * be initialized using the provided {@code pseudoRandKey} object.\n-     *\/\n-    public SecretKey expand(SecretKey pseudoRandKey, byte[] info, int outLen,\n-            String keyAlg) throws InvalidKeyException {\n-        byte[] kdfOutput;\n-\n-        \/\/ Calculate the number of rounds of HMAC that are needed to\n-        \/\/ meet the requested data.  Then set up the buffers we will need.\n-        Objects.requireNonNull(pseudoRandKey, \"A null PRK is not allowed.\");\n-\n-        \/\/ Output from the expand operation must be <= 255 * hmac length\n-        if (outLen > 255 * hmacLen) {\n-            throw new IllegalArgumentException(\"Requested output length \" +\n-                    \"exceeds maximum length allowed for HKDF expansion\");\n-        }\n-        hmacObj.init(pseudoRandKey);\n-        if (info == null) {\n-            info = new byte[0];\n-        }\n-        int rounds = (outLen + hmacLen - 1) \/ hmacLen;\n-        kdfOutput = new byte[rounds * hmacLen];\n-        int offset = 0;\n-        int tLength = 0;\n-\n-        for (int i = 0; i < rounds ; i++) {\n-\n-            \/\/ Calculate this round\n-            try {\n-                 \/\/ Add T(i).  This will be an empty string on the first\n-                 \/\/ iteration since tLength starts at zero.  After the first\n-                 \/\/ iteration, tLength is changed to the HMAC length for the\n-                 \/\/ rest of the loop.\n-                hmacObj.update(kdfOutput,\n-                        Math.max(0, offset - hmacLen), tLength);\n-                hmacObj.update(info);                       \/\/ Add info\n-                hmacObj.update((byte)(i + 1));              \/\/ Add round number\n-                hmacObj.doFinal(kdfOutput, offset);\n-\n-                tLength = hmacLen;\n-                offset += hmacLen;                       \/\/ For next iteration\n-            } catch (ShortBufferException sbe) {\n-                \/\/ This really shouldn't happen given that we've\n-                \/\/ sized the buffers to their largest possible size up-front,\n-                \/\/ but just in case...\n-                throw new RuntimeException(sbe);\n-            }\n-        }\n-\n-        return new SecretKeySpec(kdfOutput, 0, outLen, keyAlg);\n-    }\n-}\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HKDF.java","additions":0,"deletions":185,"binary":false,"changes":185,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import javax.crypto.KDF;\n@@ -29,0 +30,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -37,0 +39,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -58,2 +62,1 @@\n-    public SecretKey deriveKey(String algorithm,\n-            AlgorithmParameterSpec params) throws IOException {\n+    public SecretKey deriveKey(String type) throws IOException {\n@@ -61,1 +64,1 @@\n-            return t12DeriveKey(algorithm, params);\n+            return t12DeriveKey();\n@@ -63,1 +66,1 @@\n-            return t13DeriveKey(algorithm, params);\n+            return t13DeriveKey(type);\n@@ -70,2 +73,2 @@\n-    private SecretKey t12DeriveKey(String algorithm,\n-            AlgorithmParameterSpec params) throws IOException {\n+    private SecretKey t12DeriveKey() throws IOException {\n+        SecretKey preMasterSecret = null;\n@@ -76,5 +79,3 @@\n-            SecretKey preMasterSecret\n-                    = ka.generateSecret(\"TlsPremasterSecret\");\n-            SSLMasterKeyDerivation mskd\n-                    = SSLMasterKeyDerivation.valueOf(\n-                            context.negotiatedProtocol);\n+            preMasterSecret = ka.generateSecret(\"TlsPremasterSecret\");\n+            SSLMasterKeyDerivation mskd =\n+                    SSLMasterKeyDerivation.valueOf(context.negotiatedProtocol);\n@@ -89,1 +90,1 @@\n-            return kd.deriveKey(\"MasterSecret\", params);\n+            return kd.deriveKey(\"MasterSecret\");\n@@ -92,0 +93,4 @@\n+        } finally {\n+            if (preMasterSecret instanceof SecretKeySpec s) {\n+                SharedSecrets.getJavaxCryptoSpecAccess().clearSecretKeySpec(s);\n+            }\n@@ -98,2 +103,5 @@\n-    private SecretKey t13DeriveKey(String algorithm,\n-            AlgorithmParameterSpec params) throws IOException {\n+    private SecretKey t13DeriveKey(String type)\n+            throws IOException {\n+        SecretKey sharedSecret = null;\n+        SecretKey earlySecret = null;\n+        SecretKey saltSecret = null;\n@@ -104,2 +112,1 @@\n-            SecretKey sharedSecret\n-                    = ka.generateSecret(\"TlsPremasterSecret\");\n+            sharedSecret = ka.generateSecret(\"TlsPremasterSecret\");\n@@ -109,1 +116,0 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n@@ -111,1 +117,1 @@\n-                \/\/ If PSK is not in use Early Secret will still be\n+                \/\/ If PSK is not in use, Early Secret will still be\n@@ -114,4 +120,4 @@\n-                SecretKeySpec ikm\n-                        = new SecretKeySpec(zeros, \"TlsPreSharedSecret\");\n-                SecretKey earlySecret\n-                        = hkdf.extract(zeros, ikm, \"TlsEarlySecret\");\n+                KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n+                earlySecret = hkdf.deriveKey(\"TlsEarlySecret\",\n+                        HKDFParameterSpec.ofExtract().addSalt(zeros)\n+                        .addIKM(zeros).extractOnly());\n@@ -122,1 +128,1 @@\n-            SecretKey saltSecret = kd.deriveKey(\"TlsSaltSecret\", null);\n+            saltSecret = kd.deriveKey(\"TlsSaltSecret\");\n@@ -125,1 +131,3 @@\n-            return hkdf.extract(saltSecret, sharedSecret, algorithm);\n+            KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n+            return hkdf.deriveKey(type, HKDFParameterSpec.ofExtract()\n+                    .addSalt(saltSecret).addIKM(sharedSecret).extractOnly());\n@@ -128,0 +136,8 @@\n+        } finally {\n+            SecretKey tbcKeys[] = { sharedSecret, earlySecret, saltSecret };\n+            for (SecretKey key : tbcKeys) {\n+                if (key instanceof SecretKeySpec s) {\n+                    SharedSecrets.getJavaxCryptoSpecAccess()\n+                            .clearSecretKeySpec(s);\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KAKeyDerivation.java","additions":41,"deletions":25,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,1 +217,1 @@\n-            SecretKey nplus1 = skd.deriveKey(\"TlsUpdateNplus1\", null);\n+            SecretKey nplus1 = skd.deriveKey(\"TlsUpdateNplus1\");\n@@ -219,3 +219,3 @@\n-            SecretKey key = kd.deriveKey(\"TlsKey\", null);\n-            IvParameterSpec ivSpec = new IvParameterSpec(\n-                    kd.deriveKey(\"TlsIv\", null).getEncoded());\n+            SecretKey key = kd.deriveKey(\"TlsKey\");\n+            IvParameterSpec ivSpec =\n+                    new IvParameterSpec(kd.deriveData(\"TlsIv\"));\n@@ -296,1 +296,1 @@\n-            SecretKey nplus1 = skd.deriveKey(\"TlsUpdateNplus1\", null);\n+            SecretKey nplus1 = skd.deriveKey(\"TlsUpdateNplus1\");\n@@ -298,3 +298,3 @@\n-            SecretKey key = kd.deriveKey(\"TlsKey\", null);\n-            IvParameterSpec ivSpec = new IvParameterSpec(\n-                    kd.deriveKey(\"TlsIv\", null).getEncoded());\n+            SecretKey key = kd.deriveKey(\"TlsKey\");\n+            IvParameterSpec ivSpec =\n+                     new IvParameterSpec(kd.deriveData(\"TlsIv\"));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KeyUpdate.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import javax.crypto.KDF;\n@@ -35,0 +36,2 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -289,1 +292,2 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n+            KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n+\n@@ -292,2 +296,6 @@\n-            return hkdf.expand(resumptionMasterSecret, hkdfInfo,\n-                    hashAlg.hashLength, \"TlsPreSharedKey\");\n+            \/\/ SSLSessionImpl.write() uses the PreSharedKey encoding for\n+            \/\/ the stateless session ticket; use SecretKeySpec instead of opaque\n+            \/\/ Key objects\n+            return new SecretKeySpec(hkdf.deriveData(\n+                    HKDFParameterSpec.expandOnly(resumptionMasterSecret,\n+                    hkdfInfo, hashAlg.hashLength)), \"TlsPreSharedKey\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import javax.crypto.KDF;\n@@ -34,0 +35,2 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -44,0 +47,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -569,5 +574,11 @@\n-        byte[] computedBinder =\n-                computeBinder(shc, binderKey, session, pskBinderHash);\n-        if (!MessageDigest.isEqual(binder, computedBinder)) {\n-            throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,\n-                    \"Incorrect PSK binder value\");\n+        try {\n+            byte[] computedBinder =\n+                    computeBinder(shc, binderKey, session, pskBinderHash);\n+            if (!MessageDigest.isEqual(binder, computedBinder)) {\n+                throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,\n+                        \"Incorrect PSK binder value\");\n+            }\n+        } finally {\n+            if (binderKey instanceof SecretKeySpec s) {\n+                SharedSecrets.getJavaxCryptoSpecAccess().clearSecretKeySpec(s);\n+            }\n@@ -722,4 +733,5 @@\n-            ClientHelloMessage clientHello = (ClientHelloMessage)message;\n-            CHPreSharedKeySpec pskPrototype = createPskPrototype(\n-                chc.resumingSession.getSuite().hashAlg.hashLength, identities);\n-            HandshakeHash pskBinderHash = chc.handshakeHash.copy();\n+            try {\n+                ClientHelloMessage clientHello = (ClientHelloMessage)message;\n+                CHPreSharedKeySpec pskPrototype = createPskPrototype(\n+                    chc.resumingSession.getSuite().hashAlg.hashLength, identities);\n+                HandshakeHash pskBinderHash = chc.handshakeHash.copy();\n@@ -727,2 +739,2 @@\n-            byte[] binder = computeBinder(chc, binderKey, pskBinderHash,\n-                    chc.resumingSession, chc, clientHello, pskPrototype);\n+                byte[] binder = computeBinder(chc, binderKey, pskBinderHash,\n+                        chc.resumingSession, chc, clientHello, pskPrototype);\n@@ -730,2 +742,2 @@\n-            List<byte[]> binders = new ArrayList<>();\n-            binders.add(binder);\n+                List<byte[]> binders = new ArrayList<>();\n+                binders.add(binder);\n@@ -733,4 +745,10 @@\n-            CHPreSharedKeySpec pskMessage =\n-                    new CHPreSharedKeySpec(identities, binders);\n-            chc.handshakeExtensions.put(CH_PRE_SHARED_KEY, pskMessage);\n-            return pskMessage.getEncoded();\n+                CHPreSharedKeySpec pskMessage =\n+                        new CHPreSharedKeySpec(identities, binders);\n+                chc.handshakeExtensions.put(CH_PRE_SHARED_KEY, pskMessage);\n+                return pskMessage.getEncoded();\n+            } finally {\n+                if (binderKey instanceof SecretKeySpec s) {\n+                    SharedSecrets.getJavaxCryptoSpecAccess()\n+                            .clearSecretKeySpec(s);\n+                }\n+            }\n@@ -790,1 +808,1 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n+            KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n@@ -794,2 +812,3 @@\n-            SecretKey finishedKey = hkdf.expand(\n-                    binderKey, hkdfInfo, hashAlg.hashLength, \"TlsBinderKey\");\n+            SecretKey finishedKey = hkdf.deriveKey(\"TlsBinderKey\",\n+                    HKDFParameterSpec.expandOnly(binderKey, hkdfInfo,\n+                    hashAlg.hashLength));\n@@ -805,0 +824,5 @@\n+            } finally {\n+                if (finishedKey instanceof SecretKeySpec s) {\n+                    SharedSecrets.getJavaxCryptoSpecAccess()\n+                            .clearSecretKeySpec(s);\n+                }\n@@ -813,0 +837,1 @@\n+        SecretKey earlySecret = null;\n@@ -815,1 +840,0 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n@@ -817,2 +841,0 @@\n-            SecretKey earlySecret = hkdf.extract(zeros, psk, \"TlsEarlySecret\");\n-\n@@ -823,2 +845,5 @@\n-            return hkdf.expand(earlySecret,\n-                    hkdfInfo, hashAlg.hashLength, \"TlsBinderKey\");\n+            KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n+            HKDFParameterSpec spec = HKDFParameterSpec.ofExtract()\n+                    .addSalt(zeros).addIKM(psk)\n+                    .thenExpand(hkdfInfo, hashAlg.hashLength);\n+            return hkdf.deriveKey(\"TlsBinderKey\", spec);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":50,"deletions":25,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,2 +211,1 @@\n-                SecretKey masterSecret =\n-                        masterKD.deriveKey(\"MasterSecret\", null);\n+                SecretKey masterSecret = masterKD.deriveKey(\"MasterSecret\");\n@@ -299,2 +298,1 @@\n-                SecretKey masterSecret =\n-                        masterKD.deriveKey(\"MasterSecret\", null);\n+                SecretKey masterSecret = masterKD.deriveKey(\"MasterSecret\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/RSAClientKeyExchange.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,2 +295,1 @@\n-            public SecretKey deriveKey(String algorithm,\n-                    AlgorithmParameterSpec params) throws IOException {\n+            public SecretKey deriveKey(String typeNotUsed) throws IOException {\n@@ -308,1 +307,1 @@\n-                return kd.deriveKey(\"MasterSecret\", params);\n+                return kd.deriveKey(\"MasterSecret\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/RSAKeyExchange.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javax.crypto.KDF;\n@@ -33,0 +34,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -35,0 +37,2 @@\n+import sun.security.ssl.CipherSuite.HashAlg;\n+\n@@ -36,1 +40,1 @@\n-    private final String hashAlg;\n+    private final String hkdfAlg;\n@@ -39,0 +43,1 @@\n+    private final int keyLen;\n@@ -40,3 +45,3 @@\n-    SSLBasicKeyDerivation(SecretKey secret, String hashAlg,\n-            byte[] label, byte[] context, int length) {\n-        this.hashAlg = hashAlg.replace(\"-\", \"\");\n+    SSLBasicKeyDerivation(SecretKey secret, HashAlg hashAlg, byte[] label,\n+            byte[] context) {\n+        this.hkdfAlg = hashAlg.hkdfAlgorithm;\n@@ -44,1 +49,2 @@\n-        this.hkdfInfo = createHkdfInfo(label, context, length);\n+        this.hkdfInfo = createHkdfInfo(label, context, hashAlg.hashLength);\n+        this.keyLen = hashAlg.hashLength;\n@@ -48,2 +54,1 @@\n-    public SecretKey deriveKey(String algorithm,\n-            AlgorithmParameterSpec keySpec) throws IOException {\n+    public SecretKey deriveKey(String type) throws IOException {\n@@ -51,3 +56,3 @@\n-            HKDF hkdf = new HKDF(hashAlg);\n-            return hkdf.expand(secret, hkdfInfo,\n-                    ((SecretSizeSpec)keySpec).length, algorithm);\n+            KDF hkdf = KDF.getInstance(hkdfAlg);\n+            return hkdf.deriveKey(type,\n+                    HKDFParameterSpec.expandOnly(secret, hkdfInfo, keyLen));\n@@ -72,8 +77,0 @@\n-\n-    static class SecretSizeSpec implements AlgorithmParameterSpec {\n-        final int length;\n-\n-        SecretSizeSpec(int length) {\n-            this.length = length;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLBasicKeyDerivation.java","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,5 @@\n-    SecretKey deriveKey(String algorithm,\n-            AlgorithmParameterSpec params) throws IOException;\n+    SecretKey deriveKey(String purpose) throws IOException;\n+\n+    default byte[] deriveData(String purpose) throws IOException {\n+        throw new UnsupportedOperationException(\"No support for deriveData!\");\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLKeyDerivation.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,3 +87,1 @@\n-        public SecretKey deriveKey(String algorithm,\n-                AlgorithmParameterSpec params) throws IOException {\n-\n+        public SecretKey deriveKey(String typeNotUsed) throws IOException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLMasterKeyDerivation.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javax.crypto.KDF;\n@@ -33,0 +34,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -90,3 +92,2 @@\n-    public SecretKey deriveKey(String algorithm,\n-            AlgorithmParameterSpec params) throws IOException {\n-        SecretSchedule ks = SecretSchedule.valueOf(algorithm);\n+    public SecretKey deriveKey(String type) throws IOException {\n+        SecretSchedule ks = SecretSchedule.valueOf(type);\n@@ -105,1 +106,1 @@\n-                            algorithm);\n+                            hashAlg);\n@@ -110,0 +111,1 @@\n+            KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n@@ -112,3 +114,2 @@\n-\n-            HKDF hkdf = new HKDF(hashAlg.name);\n-            return hkdf.expand(secret, hkdfInfo, hashAlg.hashLength, algorithm);\n+            return hkdf.deriveKey(type, HKDFParameterSpec.expandOnly(\n+                    secret, hkdfInfo, hashAlg.hashLength));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSecretDerivation.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import javax.crypto.KDF;\n@@ -35,0 +36,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -72,1 +74,0 @@\n-\n@@ -146,3 +147,17 @@\n-        public SecretKey deriveKey(String algorithm,\n-                AlgorithmParameterSpec params) throws IOException {\n-            KeySchedule ks = KeySchedule.valueOf(algorithm);\n+        public SecretKey deriveKey(String type) throws IOException {\n+            KeySchedule ks = KeySchedule.valueOf(type);\n+            try {\n+                KDF hkdf = KDF.getInstance(cs.hashAlg.hkdfAlgorithm);\n+                byte[] hkdfInfo = createHkdfInfo(ks.label, ks.getKeyLength(cs));\n+                HKDFParameterSpec spec = HKDFParameterSpec.expandOnly(secret,\n+                        hkdfInfo, ks.getKeyLength(cs));\n+                return hkdf.deriveKey(ks.getAlgorithm(cs, type), spec);\n+            } catch (GeneralSecurityException gse) {\n+                throw new SSLHandshakeException(\n+                        \"Could not generate secret\", gse);\n+            }\n+        }\n+\n+        @Override\n+        public byte[] deriveData(String type) throws IOException {\n+            KeySchedule ks = KeySchedule.valueOf(type);\n@@ -150,6 +165,5 @@\n-                HKDF hkdf = new HKDF(cs.hashAlg.name);\n-                byte[] hkdfInfo =\n-                        createHkdfInfo(ks.label, ks.getKeyLength(cs));\n-                return hkdf.expand(secret, hkdfInfo,\n-                        ks.getKeyLength(cs),\n-                        ks.getAlgorithm(cs, algorithm));\n+                KDF hkdf = KDF.getInstance(cs.hashAlg.hkdfAlgorithm);\n+                byte[] hkdfInfo = createHkdfInfo(ks.label, ks.getKeyLength(cs));\n+                HKDFParameterSpec spec = HKDFParameterSpec.expandOnly(secret,\n+                        hkdfInfo, ks.getKeyLength(cs));\n+                return hkdf.deriveData(spec);\n@@ -174,1 +188,0 @@\n-\n@@ -180,1 +193,1 @@\n-        \/\/ Note that we use enum name as the key\/ name.\n+        \/\/ Note that we use enum name as the key name.\n@@ -288,2 +301,3 @@\n-        SecretKey getTrafficKey(String algorithm) {\n-            switch (algorithm) {\n+        @Override\n+        public SecretKey deriveKey(String type) throws IOException {\n+            switch (type) {\n@@ -298,0 +312,9 @@\n+                default:\n+                    throw new SSLHandshakeException(\n+                            \"Cannot deriveKey for \" + type);\n+            }\n+        }\n+\n+        @Override\n+        public byte[] deriveData(String type) throws IOException {\n+            switch (type) {\n@@ -300,2 +323,1 @@\n-                    return  (cliIvSpec == null) ? null :\n-                            new SecretKeySpec(cliIvSpec.getIV(), \"TlsIv\");\n+                    return  (cliIvSpec == null) ? null : cliIvSpec.getIV();\n@@ -304,2 +326,4 @@\n-                    return  (srvIvSpec == null) ? null :\n-                            new SecretKeySpec(srvIvSpec.getIV(), \"TlsIv\");\n+                    return  (srvIvSpec == null) ? null : srvIvSpec.getIV();\n+                default:\n+                    throw new SSLHandshakeException(\n+                            \"Cannot deriveData for \" + type);\n@@ -307,8 +331,0 @@\n-\n-            return null;\n-        }\n-\n-        @Override\n-        public SecretKey deriveKey(String algorithm,\n-                AlgorithmParameterSpec params) throws IOException {\n-            return getTrafficKey(algorithm);\n@@ -318,1 +334,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTrafficKeyDerivation.java","additions":43,"deletions":28,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import javax.crypto.KDF;\n@@ -39,0 +40,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -623,1 +625,1 @@\n-                    \"TlsHandshakeSecret\", null);\n+                    \"TlsHandshakeSecret\");\n@@ -639,1 +641,1 @@\n-                    \"TlsClientHandshakeTrafficSecret\", null);\n+                    \"TlsClientHandshakeTrafficSecret\");\n@@ -642,4 +644,1 @@\n-            SecretKey readKey = readKD.deriveKey(\n-                    \"TlsKey\", null);\n-            SecretKey readIvSecret = readKD.deriveKey(\n-                    \"TlsIv\", null);\n+            SecretKey readKey = readKD.deriveKey(\"TlsKey\");\n@@ -647,1 +646,1 @@\n-                    new IvParameterSpec(readIvSecret.getEncoded());\n+                    new IvParameterSpec(readKD.deriveData(\"TlsIv\"));\n@@ -673,1 +672,1 @@\n-                    \"TlsServerHandshakeTrafficSecret\", null);\n+                    \"TlsServerHandshakeTrafficSecret\");\n@@ -676,4 +675,1 @@\n-            SecretKey writeKey = writeKD.deriveKey(\n-                    \"TlsKey\", null);\n-            SecretKey writeIvSecret = writeKD.deriveKey(\n-                    \"TlsIv\", null);\n+            SecretKey writeKey = writeKD.deriveKey(\"TlsKey\");\n@@ -681,1 +677,1 @@\n-                    new IvParameterSpec(writeIvSecret.getEncoded());\n+                    new IvParameterSpec(writeKD.deriveData(\"TlsIv\"));\n@@ -1225,3 +1221,4 @@\n-            HKDF hkdf = new HKDF(hashAlg.name);\n-            byte[] zeros = new byte[hashAlg.hashLength];\n-            SecretKey earlySecret = hkdf.extract(zeros, psk, \"TlsEarlySecret\");\n+            KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n+            SecretKey earlySecret = hkdf.deriveKey(\"TlsEarlySecret\",\n+                    HKDFParameterSpec.ofExtract().addIKM(psk)\n+                    .extractOnly());\n@@ -1230,1 +1227,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n@@ -1314,1 +1311,1 @@\n-                    \"TlsHandshakeSecret\", null);\n+                    \"TlsHandshakeSecret\");\n@@ -1329,1 +1326,1 @@\n-                    \"TlsServerHandshakeTrafficSecret\", null);\n+                    \"TlsServerHandshakeTrafficSecret\");\n@@ -1333,4 +1330,1 @@\n-            SecretKey readKey = readKD.deriveKey(\n-                    \"TlsKey\", null);\n-            SecretKey readIvSecret = readKD.deriveKey(\n-                    \"TlsIv\", null);\n+            SecretKey readKey = readKD.deriveKey(\"TlsKey\");\n@@ -1338,1 +1332,1 @@\n-                    new IvParameterSpec(readIvSecret.getEncoded());\n+                    new IvParameterSpec(readKD.deriveData(\"TlsIv\"));\n@@ -1364,1 +1358,1 @@\n-                    \"TlsClientHandshakeTrafficSecret\", null);\n+                    \"TlsClientHandshakeTrafficSecret\");\n@@ -1367,4 +1361,1 @@\n-            SecretKey writeKey = writeKD.deriveKey(\n-                    \"TlsKey\", null);\n-            SecretKey writeIvSecret = writeKD.deriveKey(\n-                    \"TlsIv\", null);\n+            SecretKey writeKey = writeKD.deriveKey(\"TlsKey\");\n@@ -1372,1 +1363,1 @@\n-                    new IvParameterSpec(writeIvSecret.getEncoded());\n+                    new IvParameterSpec(writeKD.deriveData(\"TlsIv\"));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-modules = \\\n-    java.base\/sun.security.ssl\n-bootclasspath.dirs=.\n","filename":"test\/jdk\/sun\/security\/ssl\/internal\/TEST.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8145255\n- * @run main\/othervm java.base\/sun.security.ssl.TestHkdf\n- * @summary HKDF for Sun JSSE\n- *\/\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/internal\/TestRun.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * Actual test code for the package private HKDF implementation\n- *\/\n-\n-package sun.security.ssl;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.LinkedList;\n-import java.util.Objects;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.InvalidKeyException;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.SecretKeySpec;\n-\n-public class TestHkdf {\n-    public static class TestData {\n-        public TestData(String name, String algStr, String ikmStr,\n-                String saltStr, String infoStr, int oLen, String expPrkStr,\n-                String expOkmStr) {\n-            testName = Objects.requireNonNull(name);\n-            algName = Objects.requireNonNull(algStr);\n-            IKM = hex2bin(Objects.requireNonNull(ikmStr));\n-            if ((outLen = oLen) <= 0) {\n-                throw new IllegalArgumentException(\n-                        \"Output length must be greater than 0\");\n-            }\n-            expectedPRK = hex2bin(Objects.requireNonNull(expPrkStr));\n-            expectedOKM = hex2bin(Objects.requireNonNull(expOkmStr));\n-\n-            \/\/ Non-mandatory fields - may be null\n-            salt = (saltStr != null) ? hex2bin(saltStr) : null;\n-            info = (infoStr != null) ? hex2bin(infoStr) : null;\n-        }\n-\n-        public final String testName;\n-        public final String algName;\n-        public final byte[] IKM;\n-        public final byte[] salt;\n-        public final byte[] info;\n-        public final int outLen;\n-        public final byte[] expectedPRK;\n-        public final byte[] expectedOKM;\n-    }\n-\n-    public static final List<TestData> testList = new LinkedList<TestData>() {{\n-        add(new TestData(\"RFC 5689 Test Case 1\", \"SHA-256\",\n-            \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n-            \"000102030405060708090a0b0c\",\n-            \"f0f1f2f3f4f5f6f7f8f9\",\n-            42,\n-            \"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\",\n-            \"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf\" +\n-            \"34007208d5b887185865\"));\n-        add(new TestData(\"RFC 5689 Test Case 2\", \"SHA-256\",\n-            \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\" +\n-            \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\" +\n-            \"404142434445464748494a4b4c4d4e4f\",\n-            \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\" +\n-            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\" +\n-            \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n-            \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\" +\n-            \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\" +\n-            \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n-            82,\n-            \"06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244\",\n-            \"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c\" +\n-            \"59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71\" +\n-            \"cc30c58179ec3e87c14c01d5c1f3434f1d87\"));\n-        add(new TestData(\"RFC 5689 Test Case 3\", \"SHA-256\",\n-            \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n-            null, null, 42,\n-            \"19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04\",\n-            \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\" +\n-            \"9d201395faa4b61a96c8\"));\n-        add(new TestData(\"RFC 5689 Test Case 4\", \"SHA-1\",\n-            \"0b0b0b0b0b0b0b0b0b0b0b\",\n-            \"000102030405060708090a0b0c\",\n-            \"f0f1f2f3f4f5f6f7f8f9\",\n-            42,\n-            \"9b6c18c432a7bf8f0e71c8eb88f4b30baa2ba243\",\n-            \"085a01ea1b10f36933068b56efa5ad81a4f14b822f5b091568a9cdd4f155fda2\" +\n-            \"c22e422478d305f3f896\"));\n-        add(new TestData(\"RFC 5689 Test Case 5\", \"SHA-1\",\n-            \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\" +\n-            \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\" +\n-            \"404142434445464748494a4b4c4d4e4f\",\n-            \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\" +\n-            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\" +\n-            \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n-            \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\" +\n-            \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\" +\n-            \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n-            82,\n-            \"8adae09a2a307059478d309b26c4115a224cfaf6\",\n-            \"0bd770a74d1160f7c9f12cd5912a06ebff6adcae899d92191fe4305673ba2ffe\" +\n-            \"8fa3f1a4e5ad79f3f334b3b202b2173c486ea37ce3d397ed034c7f9dfeb15c5e\" +\n-            \"927336d0441f4c4300e2cff0d0900b52d3b4\"));\n-        add(new TestData(\"RFC 5689 Test Case 6\", \"SHA-1\",\n-            \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n-            null, null, 42,\n-            \"da8c8a73c7fa77288ec6f5e7c297786aa0d32d01\",\n-            \"0ac1af7002b3d761d1e55298da9d0506b9ae52057220a306e07b6b87e8df21d0\" +\n-            \"ea00033de03984d34918\"));\n-        add(new TestData(\"RFC 5689 Test Case 7\", \"SHA-1\",\n-            \"0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c\",\n-            null, null, 42,\n-            \"2adccada18779e7c2077ad2eb19d3f3e731385dd\",\n-            \"2c91117204d745f3500d636a62f64f0ab3bae548aa53d423b0d1f27ebba6f5e5\" +\n-            \"673a081d70cce7acfc48\"));\n-    }};\n-\n-    public static void main(String args[]) throws Exception {\n-        int testsPassed = 0;\n-\n-        int testNo = 0;\n-        for (TestData test : testList) {\n-            System.out.println(\"*** Test \" + ++testNo + \": \" +\n-                    test.testName);\n-            if (runVector(test)) {\n-                testsPassed++;\n-            }\n-        }\n-\n-        System.out.println(\"Total tests: \" + testList.size() +\n-                \", Passed: \" + testsPassed + \", Failed: \" +\n-                (testList.size() - testsPassed));\n-        if (testsPassed != testList.size()) {\n-            throw new RuntimeException(\"One or more tests failed.  \" +\n-                    \"Check output for details\");\n-        }\n-    }\n-\n-    private static boolean runVector(TestData testData)\n-            throws NoSuchAlgorithmException, InvalidKeyException {\n-        String kdfName, prfName;\n-        HKDF kdfHkdf;\n-        boolean result = true;\n-        SecretKey actualPRK;\n-        SecretKey actualOKM;\n-        byte[] deriveData;\n-\n-        \/\/ Get an instance of the HKDF derivation engine\n-        kdfHkdf = new HKDF(testData.algName);\n-\n-        \/\/ Set up the input keying material and the salt as a secret\n-        SecretKey ikmKey = new SecretKeySpec(testData.IKM, \"HKDF-IKM\");\n-        SecretKey saltKey = (testData.salt != null) ?\n-                new SecretKeySpec(testData.salt, \"HKDF-Salt\") : null;\n-\n-        \/\/ *** HKDF-Extract-only testing\n-        System.out.println(\"* HKDF-Extract-Only:\");\n-        actualPRK = kdfHkdf.extract(saltKey, ikmKey, \"HKDF-PRK\");\n-        result &= compareKeyAndData(actualPRK, testData.expectedPRK);\n-\n-        \/\/ *** HKDF Expand-Only testing\n-        \/\/ For these tests, we'll use the actualPRK as the input key\n-        System.out.println(\"* HKDF-Expand-Only:\");\n-        actualOKM = kdfHkdf.expand(actualPRK, testData.info, testData.outLen,\n-                \"HKDF-OKM\");\n-        result &= compareKeyAndData(actualOKM, testData.expectedOKM);\n-\n-        \/\/ *** HKDF Extract-then-Expand testing\n-        \/\/ System.out.println(\"* HKDF-Extract-then-Expand:\");\n-        \/\/ actualOKM = kdfHkdf.extractExpand(ikmKey, saltKey, testData.info,\n-        \/\/         testData.outLen, \"HKDF-OKM2\");\n-        \/\/ result &= compareKeyAndData(actualOKM, testData.expectedOKM);\n-\n-        return result;\n-    }\n-\n-    \/**\n-     * Compare actual key output from HKDF against an expected output value.\n-     *\n-     * @param outKey the KDF output in key form\n-     * @param expectedOut the expected value\n-     *\n-     * @return true if the underlying data for outKey, outData and\n-     * expectedOut are the same.\n-     *\/\n-    private static boolean compareKeyAndData(SecretKey outKey,\n-            byte[] expectedOut) {\n-        boolean result = false;\n-\n-        if (Arrays.equals(outKey.getEncoded(), expectedOut)) {\n-            System.out.println(\"\\t* Key output: Pass\");\n-            result = true;\n-        } else {\n-            System.out.println(\"\\t* Key output: FAIL\");\n-            System.out.println(\"Expected:\\n\" +\n-                    dumpHexBytes(expectedOut, 16, \"\\n\", \" \"));\n-            System.out.println(\"Actual:\\n\" +\n-                    dumpHexBytes(outKey.getEncoded(), 16, \"\\n\", \" \"));\n-            System.out.println();\n-        }\n-\n-        return result;\n-    }\n-\n-    \/**\n-     * Dump the hex bytes of a buffer into string form.\n-     *\n-     * @param data The array of bytes to dump to stdout.\n-     * @param itemsPerLine The number of bytes to display per line\n-     *      if the {@code lineDelim} character is blank then all bytes\n-     *      will be printed on a single line.\n-     * @param lineDelim The delimiter between lines\n-     * @param itemDelim The delimiter between bytes\n-     *\n-     * @return The hexdump of the byte array\n-     *\/\n-    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n-            String lineDelim, String itemDelim) {\n-        StringBuilder sb = new StringBuilder();\n-        if (data != null) {\n-            for (int i = 0; i < data.length; i++) {\n-                if (i % itemsPerLine == 0 && i != 0) {\n-                    sb.append(lineDelim);\n-                }\n-                sb.append(String.format(\"%02X\", data[i])).append(itemDelim);\n-            }\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    private static byte[] hex2bin(String hex) {\n-        int i;\n-        int len = hex.length();\n-        byte[] data = new byte [len \/ 2];\n-        for (i = 0; i < len; i += 2) {\n-            data[i \/ 2] = (byte)((Character.digit(hex.charAt(i), 16) << 4) +\n-                    Character.digit(hex.charAt(i + 1), 16));\n-        }\n-        return data;\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/ssl\/internal\/java.base\/sun\/security\/ssl\/TestHkdf.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"}]}