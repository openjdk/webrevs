{"files":[{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/stackWatermark.hpp\"\n@@ -259,0 +260,5 @@\n+  \/\/ Process the oops in the thread head before calling into code that wants to\n+  \/\/ stack walk over Loom continuations. The stack walking code will otherwise\n+  \/\/ skip frames in stack chunks on the Java heap.\n+  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+\n@@ -277,0 +283,5 @@\n+  \/\/ Process the oops in the thread head before calling into code that wants to\n+  \/\/ stack walk over Loom continuations. The stack walking code will otherwise\n+  \/\/ skip frames in stack chunks on the Java heap.\n+  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -151,0 +151,12 @@\n+static RegisterMap::WalkContinuation walk_continuation(JavaThread* jt) {\n+  \/\/ NOTE: WalkContinuation::skip, because of interactions with ZGC relocation\n+  \/\/       and load barriers. This code is run while generating stack traces for\n+  \/\/       the ZPage allocation event, even when ZGC is relocating  objects.\n+  \/\/       When ZGC is relocating, it is forbidden to run code that performs\n+  \/\/       load barriers. With WalkContinuation::include, we visit heap stack\n+  \/\/       chunks and could be using load barriers.\n+  return (UseZGC && !StackWatermarkSet::processing_started(jt))\n+      ? RegisterMap::WalkContinuation::skip\n+      : RegisterMap::WalkContinuation::include;\n+}\n+\n@@ -155,1 +167,1 @@\n-                                 RegisterMap::WalkContinuation::include)),\n+                                 walk_continuation(jt))),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}