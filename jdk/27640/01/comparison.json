{"files":[{"patch":"@@ -292,0 +292,17 @@\n+     * <p>\n+     * {@code BufferedImage} is a type that supports only one tile.\n+     * The pixels are stored in a {@code DataBuffer}.\n+     * A {@code DataBuffer} is a container for one or more banks of\n+     * Java primitive arrays so the number of samples that can be\n+     * stored are limited by the maximum size of a Java array.\n+     * This is at most {@code Integer.MAX_VALUE}.\n+     * The number of samples per-pixel for an {@code imageType} affect\n+     * the maximum. For example, if an image format uses bytes to store\n+     * separately each of the four samples in an ARGB pixel format image,\n+     * it will only be able to hold one fourth as many pixels as an image\n+     * that uses an int to store all four samples.\n+     * For example, {@code TYPE_4BYTE_ABGR} may use 4 bytes to store a pixel\n+     * whereas {@code TYPE_INT_ARGB} may use a single int.\n+     * So the maximum number of pixels in a {@code BufferedImage} is\n+     * format dependent.\n+     *\n@@ -295,0 +312,7 @@\n+     * @throws IllegalArgumentException if {@code width} or {@code height} is\n+     *          not greater than zero.\n+     * @throws IllegalArgumentException if the multiplication product of\n+     *          {@code width}, {@code height}, and the number of samples per pixel\n+     *          for the specified format exceeds the maximum length of a Java array.\n+     * @throws IllegalArgumentException if the {@code imageType} is not one of\n+     *         the pre-defined recognized image types.\n@@ -313,0 +337,31 @@\n+\n+        if (width <= 0 || height <= 0) {\n+            throw new IllegalArgumentException(\n+                     \"width \" + width + \" height \" + height + \" must both be > 0\");\n+        }\n+        long lsz = (long)width * height;\n+        if (lsz > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\n+                     \"width \" + width + \" * height \" + height + \" overflow int\");\n+        }\n+        \/* most BufferedImage formats use one data buffer element per pixel.\n+         * But for the NBYTE formats the BufferedImage implementation\n+         * uses an interleaved raster which has a ByteDataBuffer of a single bank,\n+         * so either 3 or 4 bytes is used for each pixel.\n+         *\/\n+        int spp = 1;\n+        switch (imageType) {\n+           case TYPE_3BYTE_BGR:\n+               spp = 3;\n+               break;\n+           case TYPE_4BYTE_ABGR:\n+           case TYPE_4BYTE_ABGR_PRE:\n+               spp = 4;\n+               break;\n+        }\n+        if ((spp != 1) && (lsz * spp > Integer.MAX_VALUE)) {\n+            throw new IllegalArgumentException(\n+                    \"width \" + width + \" height \" + height + \" * \" +\n+                     spp + \" samples per pixel overflow int\");\n+        }\n+\n@@ -523,0 +578,5 @@\n+     * @throws IllegalArgumentException if {@code width} or {@code height} is\n+     *          not greater than zero.\n+     * @throws IllegalArgumentException if the multiplication product of\n+     *          {@code width} and {@code height}\n+     *          exceeds the maximum length of a Java array.\n@@ -533,0 +593,11 @@\n+\n+         if (width <= 0 || height <= 0) {\n+             throw new IllegalArgumentException(\n+                      \"width \" + width + \" height \" + height + \" must both be > 0\");\n+         }\n+         long lsz = (long)width * height;\n+         if (lsz > Integer.MAX_VALUE) {\n+             throw new IllegalArgumentException(\n+                      \"width \" + width + \" height \" + height + \" overflow int\");\n+         }\n+\n@@ -602,0 +673,2 @@\n+     * @throws IllegalArgumentException if\n+     *          {@code raster}, {@code minX} or {@code minY} is not zero\n@@ -606,8 +679,0 @@\n-\n-\n-\/*\n- *\n- *  FOR NOW THE CODE WHICH DEFINES THE RASTER TYPE IS DUPLICATED BY DVF\n- *  SEE THE METHOD DEFINERASTERTYPE @ RASTEROUTPUTMANAGER\n- *\n- *\/\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/BufferedImage.java","additions":73,"deletions":8,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.WritableRaster;\n+import static java.awt.image.BufferedImage.*;\n+\n+\/**\n+ * @test\n+ * @bug 4617681\n+ * @summary Verify BufferedImage Constructor behaviour with\n+ *          invalid image size and type parameters.\n+ *\/\n+\n+public class CreateBufferedImageTest {\n+\n+    static byte[] s = new byte[16];\n+    static IndexColorModel icm = new IndexColorModel(8, 16, s, s, s);\n+\n+    public static void main(String args[]) {\n+\n+        test(TYPE_CUSTOM, 10); \/\/ TYPE_CUSTOM is not a valid parameter.\n+        test(-1, 10);\n+        test(10001, 10);\n+\n+        for (int t = TYPE_INT_RGB; t <= TYPE_BYTE_INDEXED; t++) {\n+           test(t, 50_000); \/\/ 50_000 ^ 2 will overflow int.\n+        }\n+        test(TYPE_3BYTE_BGR, 30_000); \/\/ 3 * (30_000 ^ 2) will overflow int\n+        test(TYPE_4BYTE_ABGR, 25_000); \/\/ 4 * (25_000 ^ 2) will overflow int\n+        test(TYPE_4BYTE_ABGR_PRE, 25_000);\n+\n+        testIndexed(TYPE_INT_RGB, 10);\n+        testIndexed(TYPE_CUSTOM, 10);\n+        testIndexed(-1, 10);\n+        testIndexed(10001, 10);\n+        testIndexed(TYPE_BYTE_BINARY, 50_000);\n+        testIndexed(TYPE_BYTE_INDEXED, 50_000);\n+\n+        \/\/ Verify that IAE is thrown if constructing using a raster with x\/y != 0\n+        BufferedImage bi = new BufferedImage(TYPE_INT_RGB, 10, 10);\n+        WritableRaster raster = bi.getRaster().createCompatibleWritableRaster(20, 20, 1, 1);\n+        try {\n+            bi = new BufferedImage(bi.getColorModel(), raster, true, null);\n+            throw new RuntimeException(\"No expected exception for invalid min x\/y\");\n+        } catch (IllegalArgumentException e) {\n+           System.out.println(\"Expected exception thrown for invalid raster min x\/y\");\n+           System.out.println(e);\n+        }\n+    }\n+\n+    static void test(int t, int sz) {\n+        try {\n+            new BufferedImage(sz, sz, t);\n+            throw new RuntimeException(\"No expected exception for type = \" + t);\n+        } catch (IllegalArgumentException e) {\n+            System.out.println(\"Expected exception thrown\");\n+            System.out.println(e);\n+        } catch (NegativeArraySizeException n) {\n+            checkIsOldVersion(26, n);\n+        }\n+    }\n+\n+    static void testIndexed(int t, int sz) {\n+        try {\n+            new BufferedImage(sz, sz, t, icm);\n+            throw new RuntimeException(\"No expected exception for type = \" + t);\n+        } catch (IllegalArgumentException e) {\n+            System.out.println(\"Expected exception thrown\");\n+            System.out.println(e);\n+        }\n+    }\n+\n+    \/**\n+      * If running on a JDK of the targetVersion or later, throw\n+      * a RuntimeException becuase the exception argument\n+      * should not have occured. However it is expected on\n+      * prior versions because that was the previous behaviour.\n+      * @param targetVersion to check\n+      * @param t the thrown exception to print\n+      *\/\n+    static void checkIsOldVersion(int targetVersion, Throwable t) {\n+        String version = System.getProperty(\"java.version\");\n+        version = version.split(\"\\\\D\")[0];\n+        int v = Integer.parseInt(version);\n+        if (v >= targetVersion) {\n+            t.printStackTrace();\n+            throw new RuntimeException(\n+                           \"Unexpected exception for version \" + v);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/image\/BufferedImage\/CreateBufferedImageTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}