{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.util.Arrays;\n-\n@@ -32,1 +30,1 @@\n-import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n@@ -36,0 +34,2 @@\n+import sun.security.util.PBEUtil;\n+\n@@ -111,24 +111,1 @@\n-        char[] passwdChars;\n-        byte[] salt = null;\n-        int iCount = 0;\n-        if (key instanceof javax.crypto.interfaces.PBEKey) {\n-            javax.crypto.interfaces.PBEKey pbeKey =\n-                (javax.crypto.interfaces.PBEKey) key;\n-            passwdChars = pbeKey.getPassword();\n-            salt = pbeKey.getSalt(); \/\/ maybe null if unspecified\n-            iCount = pbeKey.getIterationCount(); \/\/ maybe 0 if unspecified\n-        } else if (key instanceof SecretKey) {\n-            byte[] passwdBytes;\n-            if (!(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0, 3)) ||\n-                    (passwdBytes = key.getEncoded()) == null) {\n-                throw new InvalidKeyException(\"Missing password\");\n-            }\n-            passwdChars = new char[passwdBytes.length];\n-            for (int i=0; i<passwdChars.length; i++) {\n-                passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n-            }\n-            Arrays.fill(passwdBytes, (byte)0x00);\n-        } else {\n-            throw new InvalidKeyException(\"SecretKey of PBE type required\");\n-        }\n-\n+        PBEKeySpec keySpec = PBEUtil.getPBAKeySpec(key, params);\n@@ -137,45 +114,4 @@\n-            if (params == null) {\n-                \/\/ should not auto-generate default values since current\n-                \/\/ javax.crypto.Mac api does not have any method for caller to\n-                \/\/ retrieve the generated defaults.\n-                if ((salt == null) || (iCount == 0)) {\n-                    throw new InvalidAlgorithmParameterException\n-                            (\"PBEParameterSpec required for salt and iteration count\");\n-                }\n-            } else if (!(params instanceof PBEParameterSpec)) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"PBEParameterSpec type required\");\n-            } else {\n-                PBEParameterSpec pbeParams = (PBEParameterSpec) params;\n-                \/\/ make sure the parameter values are consistent\n-                if (salt != null) {\n-                    if (!Arrays.equals(salt, pbeParams.getSalt())) {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Inconsistent value of salt between key and params\");\n-                    }\n-                } else {\n-                    salt = pbeParams.getSalt();\n-                }\n-                if (iCount != 0) {\n-                    if (iCount != pbeParams.getIterationCount()) {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Different iteration count between key and params\");\n-                    }\n-                } else {\n-                    iCount = pbeParams.getIterationCount();\n-                }\n-            }\n-            \/\/ For security purpose, we need to enforce a minimum length\n-            \/\/ for salt; just require the minimum salt length to be 8-byte\n-            \/\/ which is what PKCS#5 recommends and openssl does.\n-            if (salt.length < 8) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"Salt must be at least 8 bytes long\");\n-            }\n-            if (iCount <= 0) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"IterationCount must be a positive number\");\n-            }\n-            derivedKey = PKCS12PBECipherCore.derive(passwdChars, salt,\n-                    iCount, engineGetMacLength(), PKCS12PBECipherCore.MAC_KEY,\n-                    algorithm, bl);\n+            derivedKey = PKCS12PBECipherCore.derive(\n+                    keySpec.getPassword(), keySpec.getSalt(),\n+                    keySpec.getIterationCount(), engineGetMacLength(),\n+                    PKCS12PBECipherCore.MAC_KEY, algorithm, bl);\n@@ -183,1 +119,1 @@\n-            Arrays.fill(passwdChars, '\\0');\n+            keySpec.clearPassword();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacPKCS12PBECore.java","additions":10,"deletions":74,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Arrays;\n@@ -34,0 +33,2 @@\n+import sun.security.util.PBEUtil;\n+\n@@ -46,4 +47,0 @@\n-\n-    private static final int DEFAULT_SALT_LENGTH = 20;\n-    private static final int DEFAULT_COUNT = 4096;\n-\n@@ -57,3 +54,1 @@\n-    private int iCount = DEFAULT_COUNT;\n-    private byte[] salt = null;\n-    private IvParameterSpec ivSpec = null;\n+    private final PBEUtil.PBES2Params pbes2Params = new PBEUtil.PBES2Params();\n@@ -138,26 +133,2 @@\n-        AlgorithmParameters params = null;\n-        if (salt == null) {\n-            \/\/ generate random salt and use default iteration count\n-            salt = new byte[DEFAULT_SALT_LENGTH];\n-            SunJCE.getRandom().nextBytes(salt);\n-            iCount = DEFAULT_COUNT;\n-        }\n-        if (ivSpec == null) {\n-            \/\/ generate random IV\n-            byte[] ivBytes = new byte[blkSize];\n-            SunJCE.getRandom().nextBytes(ivBytes);\n-            ivSpec = new IvParameterSpec(ivBytes);\n-        }\n-        PBEParameterSpec pbeSpec = new PBEParameterSpec(salt, iCount, ivSpec);\n-        try {\n-            params = AlgorithmParameters.getInstance(pbeAlgo,\n-                SunJCE.getInstance());\n-            params.init(pbeSpec);\n-        } catch (NoSuchAlgorithmException nsae) {\n-            \/\/ should never happen\n-            throw new RuntimeException(\"SunJCE called, but not configured\");\n-        } catch (InvalidParameterSpecException ipse) {\n-            \/\/ should never happen\n-            throw new RuntimeException(\"PBEParameterSpec not supported\");\n-        }\n-        return params;\n+        return pbes2Params.getAlgorithmParameters(\n+                blkSize, pbeAlgo, SunJCE.getInstance(), SunJCE.getRandom());\n@@ -175,18 +146,0 @@\n-    private static byte[] check(byte[] salt)\n-        throws InvalidAlgorithmParameterException {\n-        if (salt != null && salt.length < 8) {\n-            throw new InvalidAlgorithmParameterException(\n-                    \"Salt must be at least 8 bytes long\");\n-        }\n-        return salt;\n-    }\n-\n-    private static int check(int iCount)\n-        throws InvalidAlgorithmParameterException {\n-        if (iCount < 0) {\n-            throw new InvalidAlgorithmParameterException(\n-                    \"Iteration count must be a positive number\");\n-        }\n-        return iCount == 0 ? DEFAULT_COUNT : iCount;\n-    }\n-\n@@ -198,72 +151,2 @@\n-        if (key == null) {\n-            throw new InvalidKeyException(\"Null key\");\n-        }\n-\n-        byte[] passwdBytes = key.getEncoded();\n-        char[] passwdChars = null;\n-        salt = null;\n-        iCount = 0;\n-        ivSpec = null;\n-\n-        PBEKeySpec pbeSpec;\n-        try {\n-            if ((passwdBytes == null) ||\n-                    !(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0, 3))) {\n-                throw new InvalidKeyException(\"Missing password\");\n-            }\n-\n-            boolean doEncrypt = ((opmode == Cipher.ENCRYPT_MODE) ||\n-                        (opmode == Cipher.WRAP_MODE));\n-\n-            \/\/ Extract from the supplied PBE params, if present\n-            if (params instanceof PBEParameterSpec pbeParams) {\n-                \/\/ salt should be non-null per PBEParameterSpec\n-                salt = check(pbeParams.getSalt());\n-                iCount = check(pbeParams.getIterationCount());\n-                AlgorithmParameterSpec ivParams = pbeParams.getParameterSpec();\n-                if (ivParams instanceof IvParameterSpec iv) {\n-                    ivSpec = iv;\n-                } else if (ivParams == null && doEncrypt) {\n-                    \/\/ generate random IV\n-                    byte[] ivBytes = new byte[blkSize];\n-                    random.nextBytes(ivBytes);\n-                    ivSpec = new IvParameterSpec(ivBytes);\n-                } else {\n-                    throw new InvalidAlgorithmParameterException(\n-                            \"Wrong parameter type: IV expected\");\n-                }\n-            } else if (params == null && doEncrypt) {\n-                \/\/ Try extracting from the key if present. If unspecified,\n-                \/\/ PBEKey returns null and 0 respectively.\n-                if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n-                    salt = check(pbeKey.getSalt());\n-                    iCount = check(pbeKey.getIterationCount());\n-                }\n-                if (salt == null) {\n-                    \/\/ generate random salt\n-                    salt = new byte[DEFAULT_SALT_LENGTH];\n-                    random.nextBytes(salt);\n-                }\n-                if (iCount == 0) {\n-                    \/\/ use default iteration count\n-                    iCount = DEFAULT_COUNT;\n-                }\n-                \/\/ generate random IV\n-                byte[] ivBytes = new byte[blkSize];\n-                random.nextBytes(ivBytes);\n-                ivSpec = new IvParameterSpec(ivBytes);\n-            } else {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"Wrong parameter type: PBE expected\");\n-            }\n-            passwdChars = new char[passwdBytes.length];\n-            for (int i = 0; i < passwdChars.length; i++)\n-                passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n-\n-            pbeSpec = new PBEKeySpec(passwdChars, salt, iCount, keyLength);\n-        } finally {\n-            \/\/ password char[] was cloned in PBEKeySpec constructor,\n-            \/\/ so we can zero it out here\n-            if (passwdChars != null) Arrays.fill(passwdChars, '\\0');\n-            if (passwdBytes != null) Arrays.fill(passwdBytes, (byte)0x00);\n-        }\n+        PBEKeySpec pbeSpec = pbes2Params.getPBEKeySpec(blkSize, keyLength,\n+                opmode, key, params, random);\n@@ -285,1 +168,1 @@\n-        cipher.init(opmode, cipherKey, ivSpec, random);\n+        cipher.init(opmode, cipherKey, pbes2Params.getIvSpec(), random);\n@@ -291,10 +174,2 @@\n-        AlgorithmParameterSpec pbeSpec = null;\n-        if (params != null) {\n-            try {\n-                pbeSpec = params.getParameterSpec(PBEParameterSpec.class);\n-            } catch (InvalidParameterSpecException ipse) {\n-                throw new InvalidAlgorithmParameterException(\n-                    \"Wrong parameter type: PBE expected\");\n-            }\n-        }\n-        engineInit(opmode, key, pbeSpec, random);\n+        engineInit(opmode, key, PBEUtil.PBES2Params.getParameterSpec(params),\n+                random);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Core.java","additions":11,"deletions":136,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+public final class PBEUtil {\n+\n+    \/*\n+     * PBES2Params is an auxiliary class that represents the state needed for\n+     * PBES2 operations (iterations count, salt and IV) and its (re)\n+     * initialization logic. Users of this class are CipherSpi implementors that\n+     * support PBES2 cryptography (RFC #8018), such as PBES2Core (SunJCE) and\n+     * P11PBECipher (SunPKCS11).\n+     *\n+     * CipherSpi implementors must call ::getPBEKeySpec in every engine\n+     * initialization (CipherSpi::engineInit override) to reset the state and\n+     * get new values in a PBEKeySpec instance. These new values are taken\n+     * from parameters, defaults or generated randomly.\n+     *\n+     * After engine initialization, values in effect can be extracted with\n+     * ::getAlgorithmParameters (as AlgorithmParameters) or ::getIvSpec (as\n+     * IvParameterSpec).\n+     *\/\n+    public final static class PBES2Params {\n+        private static final int DEFAULT_SALT_LENGTH = 20;\n+        private static final int DEFAULT_ITERATIONS = 4096;\n+\n+        private int iCount;\n+        private byte[] salt;\n+        private IvParameterSpec ivSpec;\n+\n+        \/*\n+         * Obtain an IvParameterSpec for Cipher services. This method returns\n+         * null when the state is not initialized. Used by PBES2Core (SunJCE)\n+         * and P11PBECipher (SunPKCS11).\n+         *\/\n+        public IvParameterSpec getIvSpec() {\n+            return ivSpec;\n+        }\n+\n+        \/*\n+         * Obtain AlgorithmParameters for Cipher services. If the state is not\n+         * initialized, this method will generate new values randomly or assign\n+         * from defaults. If the state is initialized, existing values will be\n+         * returned. Used by PBES2Core (SunJCE) and P11PBECipher (SunPKCS11).\n+         *\/\n+        public AlgorithmParameters getAlgorithmParameters(int blkSize,\n+                String pbeAlgo, Provider algParamsProv, SecureRandom random) {\n+            AlgorithmParameters params = null;\n+            if (salt == null) {\n+                \/\/ generate random salt and use default iteration count\n+                salt = new byte[DEFAULT_SALT_LENGTH];\n+                random.nextBytes(salt);\n+                iCount = DEFAULT_ITERATIONS;\n+            }\n+            if (ivSpec == null) {\n+                \/\/ generate random IV\n+                byte[] ivBytes = new byte[blkSize];\n+                random.nextBytes(ivBytes);\n+                ivSpec = new IvParameterSpec(ivBytes);\n+            }\n+            PBEParameterSpec pbeSpec = new PBEParameterSpec(\n+                    salt, iCount, ivSpec);\n+            try {\n+                params = AlgorithmParameters.getInstance(pbeAlgo,\n+                        algParamsProv);\n+                params.init(pbeSpec);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"AlgorithmParameters for \"\n+                        + pbeAlgo + \" not configured\");\n+            } catch (InvalidParameterSpecException ipse) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"PBEParameterSpec not supported\");\n+            }\n+            return params;\n+        }\n+\n+        \/*\n+         * Obtain a PBEKeySpec for Cipher services, after key and parameters\n+         * validation, random generation or assignment from defaults. Used by\n+         * PBES2Core (SunJCE) and P11PBECipher (SunPKCS11).\n+         *\/\n+        public PBEKeySpec getPBEKeySpec(int blkSize, int keyLength, int opmode,\n+                Key key, AlgorithmParameterSpec params, SecureRandom random)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            if (key == null) {\n+                throw new InvalidKeyException(\"Null key\");\n+            }\n+\n+            byte[] passwdBytes = key.getEncoded();\n+            char[] passwdChars = null;\n+            salt = null;\n+            iCount = 0;\n+            ivSpec = null;\n+\n+            PBEKeySpec pbeSpec;\n+            try {\n+                if ((passwdBytes == null) ||\n+                        !(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0,\n+                                3))) {\n+                    throw new InvalidKeyException(\"Missing password\");\n+                }\n+\n+                boolean doEncrypt = ((opmode == Cipher.ENCRYPT_MODE) ||\n+                            (opmode == Cipher.WRAP_MODE));\n+\n+                \/\/ Extract from the supplied PBE params, if present\n+                if (params instanceof PBEParameterSpec pbeParams) {\n+                    \/\/ salt should be non-null per PBEParameterSpec\n+                    salt = check(pbeParams.getSalt());\n+                    iCount = check(pbeParams.getIterationCount());\n+                    AlgorithmParameterSpec ivParams =\n+                            pbeParams.getParameterSpec();\n+                    if (ivParams instanceof IvParameterSpec iv) {\n+                        ivSpec = iv;\n+                    } else if (ivParams == null && doEncrypt) {\n+                        \/\/ generate random IV\n+                        byte[] ivBytes = new byte[blkSize];\n+                        random.nextBytes(ivBytes);\n+                        ivSpec = new IvParameterSpec(ivBytes);\n+                    } else {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Wrong parameter type: IV expected\");\n+                    }\n+                } else if (params == null && doEncrypt) {\n+                    \/\/ Try extracting from the key if present. If unspecified,\n+                    \/\/ PBEKey returns null and 0 respectively.\n+                    if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n+                        salt = check(pbeKey.getSalt());\n+                        iCount = check(pbeKey.getIterationCount());\n+                    }\n+                    if (salt == null) {\n+                        \/\/ generate random salt\n+                        salt = new byte[DEFAULT_SALT_LENGTH];\n+                        random.nextBytes(salt);\n+                    }\n+                    if (iCount == 0) {\n+                        \/\/ use default iteration count\n+                        iCount = DEFAULT_ITERATIONS;\n+                    }\n+                    \/\/ generate random IV\n+                    byte[] ivBytes = new byte[blkSize];\n+                    random.nextBytes(ivBytes);\n+                    ivSpec = new IvParameterSpec(ivBytes);\n+                } else {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Wrong parameter type: PBE expected\");\n+                }\n+                passwdChars = new char[passwdBytes.length];\n+                for (int i = 0; i < passwdChars.length; i++) {\n+                    passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n+                }\n+\n+                pbeSpec = new PBEKeySpec(passwdChars, salt, iCount, keyLength);\n+            } finally {\n+                \/\/ password char[] was cloned in PBEKeySpec constructor,\n+                \/\/ so we can zero it out here\n+                if (passwdChars != null) Arrays.fill(passwdChars, '\\0');\n+                if (passwdBytes != null) Arrays.fill(passwdBytes, (byte)0x00);\n+            }\n+            return pbeSpec;\n+        }\n+\n+        \/*\n+         * Obtain an AlgorithmParameterSpec from an AlgorithmParameters\n+         * instance, for Cipher services. Used by PBES2Core (SunJCE) and\n+         * P11PBECipher (SunPKCS11).\n+         *\/\n+        public static AlgorithmParameterSpec getParameterSpec(\n+                AlgorithmParameters params)\n+                throws InvalidAlgorithmParameterException {\n+            AlgorithmParameterSpec pbeSpec = null;\n+            if (params != null) {\n+                try {\n+                    pbeSpec = params.getParameterSpec(PBEParameterSpec.class);\n+                } catch (InvalidParameterSpecException ipse) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Wrong parameter type: PBE expected\");\n+                }\n+            }\n+            return pbeSpec;\n+        }\n+\n+        private static byte[] check(byte[] salt)\n+                throws InvalidAlgorithmParameterException {\n+            if (salt != null && salt.length < 8) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"Salt must be at least 8 bytes long\");\n+            }\n+            return salt;\n+        }\n+\n+        private static int check(int iCount)\n+                throws InvalidAlgorithmParameterException {\n+            if (iCount < 0) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"Iteration count must be a positive number\");\n+            }\n+            return iCount == 0 ? DEFAULT_ITERATIONS : iCount;\n+        }\n+    }\n+\n+    \/*\n+     * Obtain a PBEKeySpec for Mac services, after key and parameters\n+     * validation. Used by HmacPKCS12PBECore (SunJCE) and P11Mac (SunPKCS11).\n+     *\/\n+    public static PBEKeySpec getPBAKeySpec(Key key,\n+            AlgorithmParameterSpec params)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        char[] passwdChars;\n+        byte[] salt = null;\n+        int iCount = 0;\n+        if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n+            passwdChars = pbeKey.getPassword();\n+            salt = pbeKey.getSalt(); \/\/ maybe null if unspecified\n+            iCount = pbeKey.getIterationCount(); \/\/ maybe 0 if unspecified\n+        } else if (key instanceof SecretKey) {\n+            byte[] passwdBytes;\n+            if (!(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0, 3)) ||\n+                    (passwdBytes = key.getEncoded()) == null) {\n+                throw new InvalidKeyException(\"Missing password\");\n+            }\n+            passwdChars = new char[passwdBytes.length];\n+            for (int i = 0; i < passwdChars.length; i++) {\n+                passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n+            }\n+            Arrays.fill(passwdBytes, (byte)0x00);\n+        } else {\n+            throw new InvalidKeyException(\"SecretKey of PBE type required\");\n+        }\n+\n+        try {\n+            if (params == null) {\n+                \/\/ should not auto-generate default values since current\n+                \/\/ javax.crypto.Mac api does not have any method for caller to\n+                \/\/ retrieve the generated defaults.\n+                if ((salt == null) || (iCount == 0)) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"PBEParameterSpec required for salt \" +\n+                            \"and iteration count\");\n+                }\n+            } else if (!(params instanceof PBEParameterSpec)) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"PBEParameterSpec type required\");\n+            } else {\n+                PBEParameterSpec pbeParams = (PBEParameterSpec) params;\n+                \/\/ make sure the parameter values are consistent\n+                if (salt != null) {\n+                    if (!Arrays.equals(salt, pbeParams.getSalt())) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Inconsistent value of salt \" +\n+                                \"between key and params\");\n+                    }\n+                } else {\n+                    salt = pbeParams.getSalt();\n+                }\n+                if (iCount != 0) {\n+                    if (iCount != pbeParams.getIterationCount()) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Different iteration count \" +\n+                                \"between key and params\");\n+                    }\n+                } else {\n+                    iCount = pbeParams.getIterationCount();\n+                }\n+            }\n+            \/\/ For security purpose, we need to enforce a minimum length\n+            \/\/ for salt; just require the minimum salt length to be 8-byte\n+            \/\/ which is what PKCS#5 recommends and openssl does.\n+            if (salt.length < 8) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"Salt must be at least 8 bytes long\");\n+            }\n+            if (iCount <= 0) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"IterationCount must be a positive number\");\n+            }\n+            return new PBEKeySpec(passwdChars, salt, iCount);\n+        } finally {\n+            Arrays.fill(passwdChars, '\\0');\n+        }\n+    }\n+\n+    \/*\n+     * Check that the key implements the PBEKey interface. If params is an\n+     * instance of PBEParameterSpec, validate consistency with the key's\n+     * derivation data. Used by P11Mac and P11PBECipher (SunPKCS11).\n+     *\/\n+    public static void checkKeyAndParams(Key key,\n+            AlgorithmParameterSpec params, String algorithm)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n+            if (params instanceof PBEParameterSpec pbeParams) {\n+                if (pbeParams.getIterationCount() !=\n+                        pbeKey.getIterationCount() ||\n+                        !Arrays.equals(pbeParams.getSalt(), pbeKey.getSalt())) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Salt or iteration count parameters are \" +\n+                            \"not consistent with PBE key\");\n+                }\n+            }\n+        } else {\n+            throw new InvalidKeyException(\n+                    \"Cannot use a \" + algorithm + \" service with a key that \" +\n+                    \"does not implement javax.crypto.interfaces.PBEKey\");\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PBEUtil.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -265,1 +265,0 @@\n-                char[] tokenLabel = token.tokenInfo.label;\n@@ -267,2 +266,1 @@\n-                reqBlockUpdates = ((tokenLabel[0] == 'N' && tokenLabel[1] == 'S'\n-                        && tokenLabel[2] == 'S') ? true : false);\n+                reqBlockUpdates = P11Util.isNSS(token);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,3 +144,1 @@\n-        char[] tokenLabel = this.token.tokenInfo.label;\n-        isNSS = (tokenLabel[0] == 'N' && tokenLabel[1] == 'S'\n-                && tokenLabel[2] == 'S');\n+        isNSS = P11Util.isNSS(this.token);\n@@ -357,0 +355,12 @@\n+    static SecretKey pbeKey(Session session, long keyID, String algorithm,\n+            int keyLength, CK_ATTRIBUTE[] attrs, char[] password, byte[] salt,\n+            int iterationCount) {\n+        attrs = getAttributes(session, keyID, attrs, new CK_ATTRIBUTE[] {\n+            new CK_ATTRIBUTE(CKA_TOKEN),\n+            new CK_ATTRIBUTE(CKA_SENSITIVE),\n+            new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n+        });\n+        return new P11PBEKey(session, keyID, algorithm, keyLength,\n+                attrs, password, salt, iterationCount);\n+    }\n+\n@@ -490,0 +500,31 @@\n+    private static final class P11PBEKey extends P11SecretKey\n+            implements PBEKey {\n+        private static final long serialVersionUID = 6847576994253634876L;\n+        private final char[] password;\n+        private final byte[] salt;\n+        private final int iterationCount;\n+        P11PBEKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                char[] password, byte[] salt, int iterationCount) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            this.password = password;\n+            this.salt = salt;\n+            this.iterationCount = iterationCount;\n+        }\n+\n+        @Override\n+        public char[] getPassword() {\n+            return password.clone();\n+        }\n+\n+        @Override\n+        public byte[] getSalt() {\n+            return salt.clone();\n+        }\n+\n+        @Override\n+        public int getIterationCount() {\n+            return iterationCount;\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":45,"deletions":4,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.security.spec.InvalidKeySpecException;\n@@ -34,0 +35,1 @@\n+import javax.crypto.spec.PBEParameterSpec;\n@@ -42,0 +44,1 @@\n+import sun.security.util.PBEUtil;\n@@ -68,0 +71,3 @@\n+    \/\/ PBEKeyInfo if algorithm is PBE-related, otherwise null\n+    private final P11SecretKeyFactory.PBEKeyInfo svcPbeKi;\n+\n@@ -91,0 +97,1 @@\n+        this.svcPbeKi = P11SecretKeyFactory.getPBEKeyInfo(algorithm);\n@@ -195,0 +202,28 @@\n+        reset(true);\n+        p11Key = null;\n+        if (svcPbeKi != null) {\n+            if (key instanceof P11Key) {\n+                \/\/ If the key is a P11Key, it must come from a PBE derivation\n+                \/\/ because this is a PBE Mac service. In addition to checking\n+                \/\/ the key, check that params (if passed) are consistent.\n+                PBEUtil.checkKeyAndParams(key, params, algorithm);\n+            } else {\n+                \/\/ If the key is not a P11Key, a derivation is needed. Data for\n+                \/\/ derivation has to be carried either as part of the key or\n+                \/\/ params. Use SunPKCS11 PBE key derivation to obtain a P11Key.\n+                \/\/ Assign the derived key to p11Key because conversion is never\n+                \/\/ needed for this case.\n+                try {\n+                    p11Key = P11SecretKeyFactory.derivePBEKey(token,\n+                            PBEUtil.getPBAKeySpec(key, params), svcPbeKi);\n+                } catch (InvalidKeySpecException e) {\n+                    throw new InvalidKeyException(e);\n+                }\n+            }\n+            if (params instanceof PBEParameterSpec pbeParams) {\n+                \/\/ For PBE services, reassign params to the underlying\n+                \/\/ service params. Notice that Mac services expect this\n+                \/\/ value to be null.\n+                params = pbeParams.getParameterSpec();\n+            }\n+        }\n@@ -196,2 +231,7 @@\n-            throw new InvalidAlgorithmParameterException\n-                (\"Parameters not supported\");\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Parameters not supported\");\n+        }\n+        \/\/ In non-PBE cases and PBE cases where we didn't derive,\n+        \/\/ a key conversion might be needed.\n+        if (p11Key == null) {\n+            p11Key = P11SecretKeyFactory.convertKey(token, key, algorithm);\n@@ -199,2 +239,0 @@\n-        reset(true);\n-        p11Key = P11SecretKeyFactory.convertKey(token, key, algorithm);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.CipherSpi;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import com.sun.crypto.provider.SunJCE;\n+import sun.security.jca.JCAUtil;\n+import static sun.security.pkcs11.wrapper.PKCS11Constants.*;\n+import sun.security.pkcs11.wrapper.PKCS11Exception;\n+import sun.security.util.PBEUtil;\n+\n+final class P11PBECipher extends CipherSpi {\n+    private final Token token;\n+    private final String pbeAlg;\n+    private final P11Cipher cipher;\n+    private final int blkSize;\n+    private final P11SecretKeyFactory.PBEKeyInfo svcPbeKi;\n+    private final PBEUtil.PBES2Params pbes2Params = new PBEUtil.PBES2Params();\n+\n+    P11PBECipher(Token token, String pbeAlg, long cipherMech)\n+                    throws PKCS11Exception, NoSuchAlgorithmException {\n+        super();\n+        String cipherTrans;\n+        if (cipherMech == CKM_AES_CBC_PAD || cipherMech == CKM_AES_CBC) {\n+            cipherTrans = \"AES\/CBC\/PKCS5Padding\";\n+        } else {\n+            throw new NoSuchAlgorithmException(\n+                    \"Cipher transformation not supported.\");\n+        }\n+        cipher = new P11Cipher(token, cipherTrans, cipherMech);\n+        blkSize = cipher.engineGetBlockSize();\n+        this.pbeAlg = pbeAlg;\n+        svcPbeKi = P11SecretKeyFactory.getPBEKeyInfo(pbeAlg);\n+        assert svcPbeKi != null : \"algorithm must be in KeyInfo map\";\n+        this.token = token;\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineSetMode(String mode)\n+            throws NoSuchAlgorithmException {\n+        cipher.engineSetMode(mode);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineSetPadding(String padding)\n+            throws NoSuchPaddingException {\n+        cipher.engineSetPadding(padding);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineGetBlockSize() {\n+        return cipher.engineGetBlockSize();\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineGetOutputSize(int inputLen) {\n+        return cipher.engineGetOutputSize(inputLen);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return cipher.engineGetIV();\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return pbes2Params.getAlgorithmParameters(\n+                blkSize, pbeAlg, P11Util.getSunJceProvider(),\n+                JCAUtil.getSecureRandom());\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            SecureRandom random) throws InvalidKeyException {\n+        try {\n+            engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new InvalidKeyException(\"requires PBE parameters\", e);\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameterSpec params, SecureRandom random)\n+                    throws InvalidKeyException,\n+                    InvalidAlgorithmParameterException {\n+        if (key instanceof P11Key) {\n+            \/\/ If the key is a P11Key, it must come from a PBE derivation\n+            \/\/ because this is a PBE Cipher service. In addition to checking the\n+            \/\/ key, check that params (if passed) are consistent.\n+            PBEUtil.checkKeyAndParams(key, params, pbeAlg);\n+            if (params instanceof PBEParameterSpec pbeParams) {\n+                \/\/ Reassign params to the underlying service params.\n+                params = pbeParams.getParameterSpec();\n+            }\n+        } else {\n+            \/\/ If the key is not a P11Key, a derivation is needed. Data for\n+            \/\/ derivation has to be carried either as part of the key or params.\n+            \/\/ Use SunPKCS11 PBE key derivation to obtain a P11Key.\n+            PBEKeySpec pbeSpec = pbes2Params.getPBEKeySpec(\n+                    blkSize, svcPbeKi.keyLen, opmode, key, params, random);\n+            try {\n+                key = P11SecretKeyFactory.derivePBEKey(\n+                        token, pbeSpec, svcPbeKi);\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(e);\n+            }\n+            params = pbes2Params.getIvSpec();\n+        }\n+        cipher.engineInit(opmode, key, params, random);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameters params, SecureRandom random)\n+                    throws InvalidKeyException,\n+                    InvalidAlgorithmParameterException {\n+        engineInit(opmode, key, PBEUtil.PBES2Params.getParameterSpec(params),\n+                random);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected byte[] engineUpdate(byte[] input, int inputOffset,\n+            int inputLen) {\n+        return cipher.engineUpdate(input, inputOffset, inputLen);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineUpdate(byte[] input, int inputOffset,\n+            int inputLen, byte[] output, int outputOffset)\n+                    throws ShortBufferException {\n+        return cipher.engineUpdate(input, inputOffset, inputLen,\n+                output, outputOffset);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected byte[] engineDoFinal(byte[] input, int inputOffset,\n+            int inputLen)\n+                    throws IllegalBlockSizeException, BadPaddingException {\n+        return cipher.engineDoFinal(input, inputOffset, inputLen);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineDoFinal(byte[] input, int inputOffset,\n+            int inputLen, byte[] output, int outputOffset)\n+                    throws ShortBufferException, IllegalBlockSizeException,\n+                    BadPaddingException {\n+        return cipher.engineDoFinal(input, inputOffset, inputLen, output,\n+                outputOffset);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineGetKeySize(Key key)\n+            throws InvalidKeyException {\n+        return cipher.engineGetKeySize(key);\n+    }\n+\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PBECipher.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -34,0 +35,1 @@\n+import javax.crypto.interfaces.PBEKey;\n@@ -55,0 +57,3 @@\n+    \/\/ PBEKeyInfo if algorithm is PBE-related, otherwise null\n+    private final PBEKeyInfo svcPbeKi;\n+\n@@ -59,0 +64,1 @@\n+        this.svcPbeKi = getPBEKeyInfo(algorithm);\n@@ -61,1 +67,108 @@\n-    private static final Map<String,Long> keyTypes;\n+    private static final Map<String, KeyInfo> keyInfo = new HashMap<>();\n+    private static final KeyInfo HMAC = new KeyInfo(\"HMAC\", PCKK_HMAC);\n+    private static final KeyInfo SSLMAC = new KeyInfo(\"SSLMAC\", PCKK_SSLMAC);\n+\n+    static KeyInfo getKeyInfo(String algo) {\n+        KeyInfo ki = keyInfo.get(algo);\n+        if (ki == null) {\n+            String algoUpper = algo.toUpperCase(Locale.ENGLISH);\n+            ki = keyInfo.get(algoUpper);\n+            if (ki == null) {\n+                if (algoUpper.startsWith(\"HMAC\")) {\n+                    return HMAC;\n+                } else if (algoUpper.startsWith(\"SSLMAC\")) {\n+                    return SSLMAC;\n+                }\n+            }\n+        }\n+        return ki;\n+    }\n+\n+    static PBEKeyInfo getPBEKeyInfo(String algo) {\n+        if (getKeyInfo(algo) instanceof PBEKeyInfo pbeKi) {\n+            return pbeKi;\n+        }\n+        return null;\n+    }\n+\n+    private static void putKeyInfo(KeyInfo ki) {\n+        keyInfo.put(ki.algo, ki);\n+        keyInfo.put(ki.algo.toUpperCase(Locale.ENGLISH), ki);\n+    }\n+\n+    static sealed class KeyInfo permits PBEKeyInfo {\n+        public final String algo;\n+        public final long keyType;\n+\n+        KeyInfo(String algo, long keyType) {\n+            this.algo = algo;\n+            this.keyType = keyType;\n+        }\n+\n+        \/\/ The P11SecretKeyFactory::convertKey method needs to know if a service\n+        \/\/ type and a key are compatible. Trivial cases such as having the same\n+        \/\/ algorithm names are handled directly. KeyInfo::checkUse helps with\n+        \/\/ cases that require to retrieve the key's KeyInfo (ki), in addition to\n+        \/\/ the service's KeyInfo (si), to make a decision.\n+        static boolean checkUse(KeyInfo ki, KeyInfo si) {\n+            if (si instanceof PBEKeyInfo && !si.algo.equals(ki.algo)) {\n+                \/\/ PBE services require a PBE key of the same algorithm.\n+                return false;\n+            }\n+            if (ki instanceof PBKDF2KeyInfo) {\n+                \/\/ We cannot tell what the PBE key was derived for,\n+                \/\/ so any service is allowed in principle.\n+                return true;\n+            }\n+            \/\/ This path handles non-PBE cases where aliases are used (i.e:\n+            \/\/ RC4 vs ARCFOUR) and mixed PBE - non-PBE cases (i.e.: a\n+            \/\/ PBE-derived AES key used in an AES Cipher service).\n+            return ki.keyType == si.keyType;\n+        }\n+    }\n+\n+    static abstract sealed class PBEKeyInfo extends KeyInfo\n+            permits AESPBEKeyInfo, PBKDF2KeyInfo, P12MacPBEKeyInfo {\n+        public static final long INVALID_PRF = -1;\n+        public final long kdfMech;\n+        public final long prfMech;\n+        public final int keyLen;\n+        public final CK_ATTRIBUTE[] extraAttrs;\n+\n+        protected PBEKeyInfo(String algo, long kdfMech, long prfMech,\n+                long keyType, int keyLen, CK_ATTRIBUTE[] extraAttrs) {\n+            super(algo, keyType);\n+            this.kdfMech = kdfMech;\n+            this.prfMech = prfMech;\n+            this.keyLen = keyLen;\n+            this.extraAttrs = extraAttrs;\n+        }\n+    }\n+\n+    static final class AESPBEKeyInfo extends PBEKeyInfo {\n+        private static final CK_ATTRIBUTE[] attr = new CK_ATTRIBUTE[] {\n+                CK_ATTRIBUTE.ENCRYPT_TRUE};\n+\n+        AESPBEKeyInfo(String algo, long prfMech, int keyLen) {\n+            super(algo, CKM_PKCS5_PBKD2, prfMech, CKK_AES, keyLen, attr);\n+        }\n+    }\n+\n+    static final class PBKDF2KeyInfo extends PBEKeyInfo {\n+        private static final CK_ATTRIBUTE[] attr = new CK_ATTRIBUTE[] {\n+                CK_ATTRIBUTE.ENCRYPT_TRUE, CK_ATTRIBUTE.SIGN_TRUE};\n+\n+        PBKDF2KeyInfo(String algo, long prfMech) {\n+            super(algo, CKM_PKCS5_PBKD2, prfMech, CKK_GENERIC_SECRET, -1, attr);\n+        }\n+    }\n+\n+    static final class P12MacPBEKeyInfo extends PBEKeyInfo {\n+        private static final CK_ATTRIBUTE[] attr = new CK_ATTRIBUTE[] {\n+                CK_ATTRIBUTE.SIGN_TRUE};\n+\n+        P12MacPBEKeyInfo(String algo, long kdfMech, int keyLen) {\n+            super(algo, kdfMech, PBEKeyInfo.INVALID_PRF,\n+                    CKK_GENERIC_SECRET, keyLen, attr);\n+        }\n+    }\n@@ -64,9 +177,8 @@\n-        keyTypes = new HashMap<String,Long>();\n-        addKeyType(\"RC4\",      CKK_RC4);\n-        addKeyType(\"ARCFOUR\",  CKK_RC4);\n-        addKeyType(\"DES\",      CKK_DES);\n-        addKeyType(\"DESede\",   CKK_DES3);\n-        addKeyType(\"AES\",      CKK_AES);\n-        addKeyType(\"Blowfish\", CKK_BLOWFISH);\n-        addKeyType(\"ChaCha20\", CKK_CHACHA20);\n-        addKeyType(\"ChaCha20-Poly1305\", CKK_CHACHA20);\n+        putKeyInfo(new KeyInfo(\"RC4\", CKK_RC4));\n+        putKeyInfo(new KeyInfo(\"ARCFOUR\", CKK_RC4));\n+        putKeyInfo(new KeyInfo(\"DES\", CKK_DES));\n+        putKeyInfo(new KeyInfo(\"DESede\", CKK_DES3));\n+        putKeyInfo(new KeyInfo(\"AES\", CKK_AES));\n+        putKeyInfo(new KeyInfo(\"Blowfish\", CKK_BLOWFISH));\n+        putKeyInfo(new KeyInfo(\"ChaCha20\", CKK_CHACHA20));\n+        putKeyInfo(new KeyInfo(\"ChaCha20-Poly1305\", CKK_CHACHA20));\n@@ -76,2 +188,2 @@\n-        addKeyType(\"RC2\",      CKK_RC2);\n-        addKeyType(\"IDEA\",     CKK_IDEA);\n+        putKeyInfo(new KeyInfo(\"RC2\", CKK_RC2));\n+        putKeyInfo(new KeyInfo(\"IDEA\", CKK_IDEA));\n@@ -79,5 +191,4 @@\n-        addKeyType(\"TlsPremasterSecret\",    PCKK_TLSPREMASTER);\n-        addKeyType(\"TlsRsaPremasterSecret\", PCKK_TLSRSAPREMASTER);\n-        addKeyType(\"TlsMasterSecret\",       PCKK_TLSMASTER);\n-        addKeyType(\"Generic\",               CKK_GENERIC_SECRET);\n-    }\n+        putKeyInfo(new KeyInfo(\"TlsPremasterSecret\", PCKK_TLSPREMASTER));\n+        putKeyInfo(new KeyInfo(\"TlsRsaPremasterSecret\", PCKK_TLSRSAPREMASTER));\n+        putKeyInfo(new KeyInfo(\"TlsMasterSecret\", PCKK_TLSMASTER));\n+        putKeyInfo(new KeyInfo(\"Generic\", CKK_GENERIC_SECRET));\n@@ -85,4 +196,42 @@\n-    private static void addKeyType(String name, long id) {\n-        Long l = Long.valueOf(id);\n-        keyTypes.put(name, l);\n-        keyTypes.put(name.toUpperCase(Locale.ENGLISH), l);\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA1AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA1, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA224AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA224, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA256AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA256, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA384AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA384, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA512AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA512, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA1AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA1, 256));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA224AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA224, 256));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA256AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA256, 256));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA384AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA384, 256));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA512AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA512, 256));\n+\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA1\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA1));\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA224\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA224));\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA256));\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA384\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA384));\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA512\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA512));\n+\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA1\",\n+                CKM_PBA_SHA1_WITH_SHA1_HMAC, 160));\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA224\",\n+                CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN, 224));\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA256\",\n+                CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN, 256));\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA384\",\n+                CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN, 384));\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA512\",\n+                CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN, 512));\n@@ -91,2 +240,1 @@\n-    \/\/ returns the PKCS11 key type of the specified algorithm\n-    \/\/ no pseudo KeyTypes\n+    \/\/ No pseudo key types\n@@ -101,1 +249,0 @@\n-    \/\/ returns direct lookup result of keyTypes using algorithm\n@@ -103,13 +250,2 @@\n-        Long l = keyTypes.get(algorithm);\n-        if (l == null) {\n-            algorithm = algorithm.toUpperCase(Locale.ENGLISH);\n-            l = keyTypes.get(algorithm);\n-            if (l == null) {\n-                if (algorithm.startsWith(\"HMAC\")) {\n-                    return PCKK_HMAC;\n-                } else if (algorithm.startsWith(\"SSLMAC\")) {\n-                    return PCKK_SSLMAC;\n-                }\n-            }\n-        }\n-        return (l != null) ? l.longValue() : -1;\n+        KeyInfo ki = getKeyInfo(algorithm);\n+        return ki == null ? -1 : ki.keyType;\n@@ -122,1 +258,1 @@\n-    static P11Key convertKey(Token token, Key key, String algo)\n+    static P11Key convertKey(Token token, Key key, String svcAlgo)\n@@ -124,1 +260,1 @@\n-        return convertKey(token, key, algo, null);\n+        return convertKey(token, key, svcAlgo, null);\n@@ -132,1 +268,1 @@\n-    static P11Key convertKey(Token token, Key key, String algo,\n+    static P11Key convertKey(Token token, Key key, String svcAlgo,\n@@ -136,3 +272,0 @@\n-        if (key == null) {\n-            throw new InvalidKeyException(\"Key must not be null\");\n-        }\n@@ -142,14 +275,20 @@\n-        long algoType;\n-        if (algo == null) {\n-            algo = key.getAlgorithm();\n-            algoType = getKeyType(algo);\n-        } else {\n-            algoType = getKeyType(algo);\n-            long keyAlgorithmType = getKeyType(key.getAlgorithm());\n-            if (algoType != keyAlgorithmType) {\n-                if ((algoType == PCKK_HMAC) || (algoType == PCKK_SSLMAC)) {\n-                    \/\/ ignore key algorithm for MACs\n-                } else {\n-                    throw new InvalidKeyException\n-                            (\"Key algorithm must be \" + algo);\n-                }\n+        final String keyAlgo = key.getAlgorithm();\n+        if (keyAlgo == null) {\n+            throw new InvalidKeyException(\"Key must specify its algorithm\");\n+        }\n+        if (svcAlgo == null) {\n+            svcAlgo = keyAlgo;\n+        }\n+        KeyInfo ki = null;\n+        KeyInfo si = getKeyInfo(svcAlgo);\n+        if (si == null) {\n+            throw new InvalidKeyException(\"Unknown algorithm \" + svcAlgo);\n+        }\n+        \/\/ Check if the key can be used for the service.\n+        \/\/ Any key can be used for a MAC service.\n+        if (svcAlgo != keyAlgo &&\n+                si.keyType != PCKK_HMAC && si.keyType != PCKK_SSLMAC) {\n+            ki = getKeyInfo(keyAlgo);\n+            if (ki == null || !KeyInfo.checkUse(ki, si)) {\n+                throw new InvalidKeyException(\"Cannot use a \" + keyAlgo +\n+                        \" key for a \" + svcAlgo + \" service\");\n@@ -187,2 +326,21 @@\n-        if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n-            throw new InvalidKeyException(\"Encoded format must be RAW\");\n+        if (key instanceof PBEKey pbeKey) {\n+            ki = ki == null ? getKeyInfo(keyAlgo) : ki;\n+            if (ki instanceof PBEKeyInfo pbeKi) {\n+                try {\n+                    p11Key = derivePBEKey(token, getPbeKeySpec(pbeKey), pbeKi);\n+                } catch (InvalidKeySpecException e) {\n+                    throw new InvalidKeyException(e);\n+                }\n+            } else {\n+                throw new InvalidKeyException(\"Cannot derive unknown \" +\n+                        keyAlgo + \" algorithm\");\n+            }\n+        } else {\n+            if (si instanceof PBEKeyInfo) {\n+                throw new InvalidKeyException(\"PBE service requires a PBE key\");\n+            }\n+            if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n+                throw new InvalidKeyException(\"Encoded format must be RAW\");\n+            }\n+            byte[] encoded = key.getEncoded();\n+            p11Key = createKey(token, encoded, svcAlgo, si.keyType, extraAttrs);\n@@ -190,2 +348,0 @@\n-        byte[] encoded = key.getEncoded();\n-        p11Key = createKey(token, encoded, algo, algoType, extraAttrs);\n@@ -196,0 +352,105 @@\n+    static P11Key derivePBEKey(Token token, PBEKeySpec keySpec,\n+            PBEKeyInfo pbeKi) throws InvalidKeySpecException {\n+        token.ensureValid();\n+        if (keySpec == null) {\n+            throw new InvalidKeySpecException(\"PBEKeySpec must not be null\");\n+        }\n+        Session session = null;\n+        try {\n+            session = token.getObjSession();\n+            CK_MECHANISM ckMech;\n+            char[] password = keySpec.getPassword();\n+            byte[] salt = keySpec.getSalt();\n+            int itCount = keySpec.getIterationCount();\n+            int keySize = keySpec.getKeyLength();\n+            assert password != null :\n+                    \"PBEKeySpec does not allow a null password\";\n+            if (salt == null) {\n+                throw new InvalidKeySpecException(\"Salt not found\");\n+            }\n+            assert salt.length > 0 : \"PBEKeySpec does not allow an empty salt\";\n+            if (itCount < 1) {\n+                throw new InvalidKeySpecException(\"Iteration count must be \" +\n+                        \"a non-zero positive integer\");\n+            }\n+            if (pbeKi.keyLen > 0) {\n+                if (keySize == 0) {\n+                    keySize = pbeKi.keyLen;\n+                } else if (keySize != pbeKi.keyLen) {\n+                    throw new InvalidKeySpecException(\n+                            \"Key length is invalid for \" + pbeKi.algo + \" (\" +\n+                            \"expecting \" + pbeKi.keyLen + \" but was \" +\n+                            keySize + \")\");\n+                }\n+            }\n+            if (keySize < 1 || keySize % 8 != 0) {\n+                throw new InvalidKeySpecException(\"Key length must be \" +\n+                        \"multiple of 8 and greater than zero\");\n+            }\n+\n+            char[] encPassword;\n+            if (pbeKi.kdfMech == CKM_PKCS5_PBKD2) {\n+                encPassword = P11Util.encodePassword(password,\n+                        StandardCharsets.UTF_8, 0);\n+                CK_VERSION p11Ver = token.p11.getVersion();\n+                if (P11Util.isNSS(token) || p11Ver.major < 2 ||\n+                        p11Ver.major == 2 && p11Ver.minor < 40) {\n+                    \/\/ NSS keeps using the old structure beyond PKCS #11 v2.40.\n+                    ckMech = new CK_MECHANISM(pbeKi.kdfMech,\n+                            new CK_PKCS5_PBKD2_PARAMS(encPassword, salt,\n+                                    itCount, pbeKi.prfMech));\n+                } else {\n+                    ckMech = new CK_MECHANISM(pbeKi.kdfMech,\n+                            new CK_PKCS5_PBKD2_PARAMS2(encPassword, salt,\n+                                    itCount, pbeKi.prfMech));\n+                }\n+            } else {\n+                \/*\n+                 * PKCS #12 \"General Method\" PBKD (RFC 7292, Appendix B.2).\n+                 *\n+                 * According to PKCS #11, \"password\" in CK_PBE_PARAMS is of\n+                 * CK_UTF8CHAR_PTR type. While this suggests a UTF-8 encoding,\n+                 * RFC 7292 Appendix B.1 indicates that the password has to be\n+                 * encoded as a BMPString with a 2-bytes NULL terminator.\n+                 *\/\n+                encPassword = P11Util.encodePassword(password,\n+                        StandardCharsets.UTF_16BE, 2);\n+                ckMech = new CK_MECHANISM(pbeKi.kdfMech,\n+                        new CK_PBE_PARAMS(encPassword, salt, itCount));\n+            }\n+\n+            CK_ATTRIBUTE[] attrs =\n+                    new CK_ATTRIBUTE[3 + pbeKi.extraAttrs.length];\n+            attrs[0] = new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY);\n+            attrs[1] = new CK_ATTRIBUTE(CKA_VALUE_LEN, keySize >> 3);\n+            attrs[2] = new CK_ATTRIBUTE(CKA_KEY_TYPE, pbeKi.keyType);\n+            System.arraycopy(pbeKi.extraAttrs, 0, attrs, 3,\n+                    pbeKi.extraAttrs.length);\n+            CK_ATTRIBUTE[] attr = token.getAttributes(\n+                    O_GENERATE, CKO_SECRET_KEY, pbeKi.keyType, attrs);\n+            long keyID = token.p11.C_GenerateKey(session.id(), ckMech, attr);\n+            return (P11Key) P11Key.pbeKey(session, keyID, pbeKi.algo,\n+                    keySize, attr, password, salt, itCount);\n+        } catch (PKCS11Exception e) {\n+            throw new InvalidKeySpecException(\"Could not create key\", e);\n+        } finally {\n+            token.releaseSession(session);\n+        }\n+    }\n+\n+    private static PBEKeySpec getPbeKeySpec(PBEKey pbeKey) {\n+        int keyLength = 0;\n+        if (\"RAW\".equalsIgnoreCase(pbeKey.getFormat())) {\n+            byte[] encoded = pbeKey.getEncoded();\n+            if (encoded != null) {\n+                keyLength = encoded.length << 3;\n+            }\n+        }\n+        int ic = pbeKey.getIterationCount();\n+        char[] pwd = pbeKey.getPassword();\n+        byte[] salt = pbeKey.getSalt();\n+        return keyLength == 0 ?\n+                new PBEKeySpec(pwd, salt, ic) :\n+                new PBEKeySpec(pwd, salt, ic, keyLength);\n+    }\n+\n@@ -289,1 +550,1 @@\n-        if (keySpec instanceof SecretKeySpec) {\n+        if (keySpec instanceof SecretKeySpec secretKeySpec) {\n@@ -291,1 +552,1 @@\n-                Key key = convertKey(token, (SecretKey)keySpec, algorithm);\n+                Key key = convertKey(token, secretKeySpec, algorithm);\n@@ -296,0 +557,3 @@\n+        } else if (keySpec instanceof PBEKeySpec pbeKeySpec &&\n+                svcPbeKi != null) {\n+            return (SecretKey) derivePBEKey(token, pbeKeySpec, svcPbeKi);\n@@ -297,2 +561,2 @@\n-            if (keySpec instanceof DESKeySpec) {\n-                byte[] keyBytes = ((DESKeySpec)keySpec).getKey();\n+            if (keySpec instanceof DESKeySpec desKeySpec) {\n+                byte[] keyBytes = desKeySpec.getKey();\n@@ -303,2 +567,2 @@\n-            if (keySpec instanceof DESedeKeySpec) {\n-                byte[] keyBytes = ((DESedeKeySpec)keySpec).getKey();\n+            if (keySpec instanceof DESedeKeySpec desEdeKeySpec) {\n+                byte[] keyBytes = desEdeKeySpec.getKey();\n@@ -317,2 +581,1 @@\n-                throw new InvalidKeySpecException\n-                    (\"Could not obtain key bytes\");\n+                throw new InvalidKeySpecException(\"Could not obtain key bytes\");\n@@ -337,0 +600,3 @@\n+        } else if (keySpec.isAssignableFrom(PBEKeySpec.class) &&\n+                key instanceof PBEKey pbeKey && svcPbeKi != null) {\n+            return getPbeKeySpec(pbeKey);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":336,"deletions":70,"binary":false,"changes":406,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n@@ -54,0 +57,39 @@\n+    static boolean isNSS(Token token) {\n+        char[] tokenLabel = token.tokenInfo.label;\n+        if (tokenLabel != null && tokenLabel.length >= 3) {\n+            return (tokenLabel[0] == 'N' && tokenLabel[1] == 'S'\n+                    && tokenLabel[2] == 'S');\n+        }\n+        return false;\n+    }\n+\n+    static char[] encodePassword(char[] password, Charset cs,\n+            int nullTermBytes) {\n+        \/*\n+         * When a Java char (2 bytes) is converted to CK_UTF8CHAR (1 byte) for\n+         * a PKCS #11 (native) call, the high-order byte is discarded (see\n+         * jCharArrayToCKUTF8CharArray in p11_util.c). In order to have an\n+         * encoded string passed to C_GenerateKey, we need to account for\n+         * truncation and expand beforehand: high and low parts of each char\n+         * are split into 2 chars. As an example, this is the transformation\n+         * for a NULL terminated password \"a\" that has to be encoded in\n+         * UTF-16 BE:\n+         *     char[] password       => [    0x0061,         0x0000    ]\n+         *                                   \/    \\          \/    \\\n+         * ByteBuffer passwordBytes  => [ 0x00,   0x61,   0x00,   0x00 ]\n+         *                                  |       |       |       |\n+         *     char[] encPassword    => [0x0000, 0x0061, 0x0000, 0x0000]\n+         *                                  |       |       |       |\n+         *     PKCS #11 call (bytes) => [ 0x00,   0x61,   0x00,   0x00 ]\n+         *\/\n+        ByteBuffer passwordBytes = cs.encode(\n+                CharBuffer.allocate(password.length).put(password).rewind());\n+        char[] encPassword =\n+                new char[passwordBytes.remaining() + nullTermBytes];\n+        int i = 0;\n+        while (passwordBytes.hasRemaining()) {\n+            encPassword[i++] = (char) (passwordBytes.get() & 0xFF);\n+        }\n+        return encPassword;\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Util.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -424,0 +424,1 @@\n+        final int[] requiredMechs;\n@@ -426,1 +427,8 @@\n-                List<String> aliases, int[] mechanisms) {\n+                           List<String> aliases, int[] mechanisms) {\n+            this(type, algorithm, className, aliases, mechanisms, null);\n+        }\n+        \/\/ mechanisms is a list of possible mechanisms that implement the\n+        \/\/ algorithm, at least one of them must be available. requiredMechs\n+        \/\/ is a list of auxiliary mechanisms, all of them must be available\n+        private Descriptor(String type, String algorithm, String className,\n+                List<String> aliases, int[] mechanisms, int[] requiredMechs) {\n@@ -432,0 +440,1 @@\n+            this.requiredMechs = requiredMechs;\n@@ -473,0 +482,6 @@\n+    private static void d(String type, String algorithm, String className,\n+            int[] m, int[] requiredMechs) {\n+        register(new Descriptor(type, algorithm, className, null, m,\n+                requiredMechs));\n+    }\n+\n@@ -479,0 +494,6 @@\n+    private static void dA(String type, String algorithm, String className,\n+            int[] m, int[] requiredMechs) {\n+        register(new Descriptor(type, algorithm, className,\n+                getAliases(algorithm), m, requiredMechs));\n+    }\n+\n@@ -529,0 +550,1 @@\n+        String P11PBECipher        = \"sun.security.pkcs11.P11PBECipher\";\n@@ -591,0 +613,18 @@\n+        \/*\n+        * PBA HMacs\n+        *\n+        * KeyDerivationMech must be supported\n+        * for these services to be available.\n+        *\n+        *\/\n+        d(MAC, \"HmacPBESHA1\",       P11Mac, m(CKM_SHA_1_HMAC),\n+                m(CKM_PBA_SHA1_WITH_SHA1_HMAC));\n+        d(MAC, \"HmacPBESHA224\",     P11Mac, m(CKM_SHA224_HMAC),\n+                m(CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN));\n+        d(MAC, \"HmacPBESHA256\",     P11Mac, m(CKM_SHA256_HMAC),\n+                m(CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN));\n+        d(MAC, \"HmacPBESHA384\",     P11Mac, m(CKM_SHA384_HMAC),\n+                m(CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN));\n+        d(MAC, \"HmacPBESHA512\",     P11Mac, m(CKM_SHA512_HMAC),\n+                m(CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN));\n+\n@@ -689,0 +729,54 @@\n+        \/*\n+         * PBE Secret Key Factories\n+         *\n+         * KeyDerivationPrf must be supported for these services\n+         * to be available.\n+         *\n+        *\/\n+        d(SKF, \"PBEWithHmacSHA1AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n+        d(SKF, \"PBEWithHmacSHA224AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n+        d(SKF, \"PBEWithHmacSHA256AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n+        d(SKF, \"PBEWithHmacSHA384AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n+        d(SKF, \"PBEWithHmacSHA512AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n+        d(SKF, \"PBEWithHmacSHA1AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n+        d(SKF, \"PBEWithHmacSHA224AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n+        d(SKF, \"PBEWithHmacSHA256AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n+        d(SKF, \"PBEWithHmacSHA384AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n+        d(SKF, \"PBEWithHmacSHA512AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n+        \/*\n+         * PBA Secret Key Factories\n+         *\/\n+        d(SKF, \"HmacPBESHA1\",       P11SecretKeyFactory,\n+                m(CKM_PBA_SHA1_WITH_SHA1_HMAC));\n+        d(SKF, \"HmacPBESHA224\",     P11SecretKeyFactory,\n+                m(CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN));\n+        d(SKF, \"HmacPBESHA256\",     P11SecretKeyFactory,\n+                m(CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN));\n+        d(SKF, \"HmacPBESHA384\",     P11SecretKeyFactory,\n+                m(CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN));\n+        d(SKF, \"HmacPBESHA512\",     P11SecretKeyFactory,\n+                m(CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN));\n+        \/*\n+         * PBKDF2 Secret Key Factories\n+         *\/\n+        dA(SKF, \"PBKDF2WithHmacSHA1\",  P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n+        d(SKF, \"PBKDF2WithHmacSHA224\", P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n+        d(SKF, \"PBKDF2WithHmacSHA256\", P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n+        d(SKF, \"PBKDF2WithHmacSHA384\", P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n+        d(SKF, \"PBKDF2WithHmacSHA512\", P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n+\n@@ -782,0 +876,38 @@\n+        \/*\n+         * PBE Ciphers\n+         *\n+         * KeyDerivationMech and KeyDerivationPrf must be supported\n+         * for these services to be available.\n+         *\n+        *\/\n+        d(CIP, \"PBEWithHmacSHA1AndAES_128\",   P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA_1_HMAC));\n+        d(CIP, \"PBEWithHmacSHA224AndAES_128\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA224_HMAC));\n+        d(CIP, \"PBEWithHmacSHA256AndAES_128\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA256_HMAC));\n+        d(CIP, \"PBEWithHmacSHA384AndAES_128\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA384_HMAC));\n+        d(CIP, \"PBEWithHmacSHA512AndAES_128\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA512_HMAC));\n+        d(CIP, \"PBEWithHmacSHA1AndAES_256\",   P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA_1_HMAC));\n+        d(CIP, \"PBEWithHmacSHA224AndAES_256\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA224_HMAC));\n+        d(CIP, \"PBEWithHmacSHA256AndAES_256\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA256_HMAC));\n+        d(CIP, \"PBEWithHmacSHA384AndAES_256\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA384_HMAC));\n+        d(CIP, \"PBEWithHmacSHA512AndAES_256\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA512_HMAC));\n+\n@@ -1172,0 +1304,1 @@\n+            descLoop:\n@@ -1175,0 +1308,11 @@\n+                    if (d.requiredMechs != null) {\n+                        \/\/ Check that other mechanisms required for the\n+                        \/\/ service are supported before listing it as\n+                        \/\/ available for the first time.\n+                        for (int requiredMech : d.requiredMechs) {\n+                            if (token.getMechanismInfo(\n+                                    requiredMech & 0xFFFFFFFFL) == null) {\n+                                continue descLoop;\n+                            }\n+                        }\n+                    }\n@@ -1275,0 +1419,2 @@\n+                } else if (algorithm.startsWith(\"PBE\")) {\n+                    return new P11PBECipher(token, algorithm, mechanism);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":148,"deletions":2,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-     * Returns the string representation of CK_PKCS5_PBKD2_PARAMS.\n+     * Returns the string representation of CK_ECDH1_DERIVE_PARAMS.\n@@ -105,1 +105,1 @@\n-     * @return the string representation of CK_PKCS5_PBKD2_PARAMS\n+     * @return the string representation of CK_ECDH1_DERIVE_PARAMS\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_ECDH1_DERIVE_PARAMS.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,12 @@\n+    public CK_MECHANISM(long mechanism, CK_PBE_PARAMS params) {\n+        init(mechanism, params);\n+    }\n+\n+    public CK_MECHANISM(long mechanism, CK_PKCS5_PBKD2_PARAMS params) {\n+        init(mechanism, params);\n+    }\n+\n+    public CK_MECHANISM(long mechanism, CK_PKCS5_PBKD2_PARAMS2 params) {\n+        init(mechanism, params);\n+    }\n+\n@@ -196,1 +208,1 @@\n-        sb.append(mechanism);\n+        sb.append(Functions.getMechanismName(mechanism));\n@@ -200,1 +212,2 @@\n-        sb.append(\"pParameter: \");\n+        sb.append(\"pParameter:\");\n+        sb.append(Constants.NEWLINE);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_MECHANISM.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * class CK_PBE_PARAMS provides all of the necessary information required byte\n+ * class CK_PBE_PARAMS provides all the necessary information required by\n@@ -58,2 +58,2 @@\n- *   CK_CHAR_PTR pInitVector;\n- *   CK_CHAR_PTR pPassword;\n+ *   CK_BYTE_PTR pInitVector;\n+ *   CK_UTF8CHAR_PTR pPassword;\n@@ -61,1 +61,1 @@\n- *   CK_CHAR_PTR pSalt;\n+ *   CK_BYTE_PTR pSalt;\n@@ -75,1 +75,1 @@\n-     *   CK_CHAR_PTR pInitVector;\n+     *   CK_BYTE_PTR pInitVector;\n@@ -78,1 +78,1 @@\n-    public char[] pInitVector;\n+    public byte[] pInitVector;\n@@ -83,1 +83,1 @@\n-     *   CK_CHAR_PTR pPassword;\n+     *   CK_UTF8CHAR_PTR pPassword;\n@@ -92,1 +92,1 @@\n-     *   CK_CHAR_PTR pSalt\n+     *   CK_BYTE_PTR pSalt\n@@ -96,1 +96,1 @@\n-    public char[] pSalt;\n+    public byte[] pSalt;\n@@ -106,0 +106,6 @@\n+    public CK_PBE_PARAMS(char[] pPassword, byte[] pSalt, long ulIteration) {\n+         this.pPassword = pPassword;\n+         this.pSalt = pSalt;\n+         this.ulIteration = ulIteration;\n+     }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_PBE_PARAMS.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-\n+import static sun.security.pkcs11.wrapper.PKCS11Constants.*;\n@@ -58,1 +58,1 @@\n- *   CK_PKCS5_PBKD2_SALT_SOURCE_TYPE saltSource;\n+ *   CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE saltSource;\n@@ -65,0 +65,2 @@\n+ *   CK_UTF8CHAR_PTR pPassword;\n+ *   CK_ULONG_PTR ulPasswordLen;\n@@ -115,0 +117,18 @@\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_UTF8CHAR_PTR pPassword\n+     *   CK_ULONG_PTR ulPasswordLen;\n+     * <\/pre>\n+     *\/\n+    public char[] pPassword;\n+\n+    public CK_PKCS5_PBKD2_PARAMS(char[] pPassword, byte[] pSalt,\n+            long iterations, long prf) {\n+        this.pPassword = pPassword;\n+        this.pSaltSourceData = pSalt;\n+        this.iterations = iterations;\n+        this.prf = prf;\n+        this.saltSource = CKZ_SALT_SPECIFIED;\n+    }\n+\n@@ -125,1 +145,1 @@\n-        sb.append(saltSource);\n+        sb.append(Functions.getParamSourcesName(saltSource));\n@@ -135,1 +155,1 @@\n-        sb.append(pSaltSourceData.length);\n+        sb.append(Functions.getLength(pSaltSourceData));\n@@ -145,1 +165,1 @@\n-        sb.append(prf);\n+        sb.append(Functions.getPrfName(prf));\n@@ -155,1 +175,1 @@\n-        sb.append(pPrfData.length);\n+        sb.append(Functions.getLength(pPrfData));\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_PKCS5_PBKD2_PARAMS.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11.wrapper;\n+\n+import static sun.security.pkcs11.wrapper.PKCS11Constants.*;\n+\n+\/**\n+ * class CK_PKCS5_PBKD2_PARAMS2 provides the parameters to the CKM_PKCS5_PBKD2\n+ * mechanism.<p>\n+ * <b>PKCS#11 structure:<\/b>\n+ * <pre>\n+ * typedef struct CK_PKCS5_PBKD2_PARAMS2 {\n+ *   CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE saltSource;\n+ *   CK_VOID_PTR pSaltSourceData;\n+ *   CK_ULONG ulSaltSourceDataLen;\n+ *   CK_ULONG iterations;\n+ *   CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE prf;\n+ *   CK_VOID_PTR pPrfData;\n+ *   CK_ULONG ulPrfDataLen;\n+ *   CK_UTF8CHAR_PTR pPassword;\n+ *   CK_ULONG ulPasswordLen;\n+ * } CK_PKCS5_PBKD2_PARAMS2;\n+ * <\/pre>\n+ *\n+ *\/\n+public class CK_PKCS5_PBKD2_PARAMS2 {\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE saltSource;\n+     * <\/pre>\n+     *\/\n+    public long saltSource;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_VOID_PTR pSaltSourceData;\n+     *   CK_ULONG ulSaltSourceDataLen;\n+     * <\/pre>\n+     *\/\n+    public byte[] pSaltSourceData;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_ULONG iterations;\n+     * <\/pre>\n+     *\/\n+    public long iterations;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE prf;\n+     * <\/pre>\n+     *\/\n+    public long prf;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_VOID_PTR pPrfData;\n+     *   CK_ULONG ulPrfDataLen;\n+     * <\/pre>\n+     *\/\n+    public byte[] pPrfData;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_UTF8CHAR_PTR pPassword\n+     *   CK_ULONG ulPasswordLen;\n+     * <\/pre>\n+     *\/\n+    public char[] pPassword;\n+\n+    public CK_PKCS5_PBKD2_PARAMS2(char[] pPassword, byte[] pSalt,\n+            long iterations, long prf) {\n+        this.pPassword = pPassword;\n+        this.pSaltSourceData = pSalt;\n+        this.iterations = iterations;\n+        this.prf = prf;\n+        this.saltSource = CKZ_SALT_SPECIFIED;\n+    }\n+\n+    \/**\n+     * Returns the string representation of CK_PKCS5_PBKD2_PARAMS2.\n+     *\n+     * @return the string representation of CK_PKCS5_PBKD2_PARAMS2\n+     *\/\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"saltSource: \");\n+        sb.append(Functions.getParamSourcesName(saltSource));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"pSaltSourceData: \");\n+        sb.append(Functions.toHexString(pSaltSourceData));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"ulSaltSourceDataLen: \");\n+        sb.append(Functions.getLength(pSaltSourceData));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"iterations: \");\n+        sb.append(iterations);\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"prf: \");\n+        sb.append(Functions.getPrfName(prf));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"pPrfData: \");\n+        sb.append(Functions.toHexString(pPrfData));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"ulPrfDataLen: \");\n+        sb.append(Functions.getLength(pPrfData));\n+\n+        return sb.toString();\n+    }\n+\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_PKCS5_PBKD2_PARAMS2.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -97,1 +97,1 @@\n-     * Returns the string representation of CK_PKCS5_PBKD2_PARAMS.\n+     * Returns the string representation of CK_X9_42_DH1_DERIVE_PARAMS.\n@@ -99,1 +99,1 @@\n-     * @return the string representation of CK_PKCS5_PBKD2_PARAMS\n+     * @return the string representation of CK_X9_42_DH1_DERIVE_PARAMS\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_X9_42_DH1_DERIVE_PARAMS.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,0 +107,14 @@\n+    \/\/ Pseudo-random functions (CKP_*)\n+    private static final Map<Integer,String> prfNames =\n+            new HashMap<Integer,String>();\n+\n+    private static final Map<String,Integer> prfIds =\n+            new HashMap<String,Integer>();\n+\n+    \/\/ Salt\/Encoding parameter sources (CKZ_*)\n+    private static final Map<Integer,String> paramSourcesNames =\n+            new HashMap<Integer,String>();\n+\n+    private static final Map<String,Integer> paramSourcesIds =\n+            new HashMap<String,Integer>();\n+\n@@ -211,0 +225,10 @@\n+    \/**\n+     * get a byte array length as int\n+     *\n+     * @param value the byte array to get its length\n+     * @return the byte array length as int or 0 if null\n+     *\/\n+    public static int getLength(byte[] value) {\n+        return value == null ? 0 : value.length;\n+    }\n+\n@@ -486,0 +510,16 @@\n+    public static String getPrfName(long id) {\n+        return getName(prfNames, id);\n+    }\n+\n+    public static long getPrfId(String name) {\n+        return getId(prfIds, name);\n+    }\n+\n+    public static String getParamSourcesName(long id) {\n+        return getName(paramSourcesNames, id);\n+    }\n+\n+    public static long getParamSourcesId(String name) {\n+        return getId(paramSourcesIds, name);\n+    }\n+\n@@ -641,0 +681,8 @@\n+    private static void addPrf(long id, String name) {\n+        addMapping(prfNames, prfIds, id, name);\n+    }\n+\n+    private static void addParamSources(long id, String name) {\n+        addMapping(paramSourcesNames, paramSourcesIds, id, name);\n+    }\n+\n@@ -1101,0 +1149,8 @@\n+        addMech(CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN,\n+                                    \"CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN\");\n+        addMech(CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN,\n+                                    \"CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN\");\n+        addMech(CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN,\n+                                    \"CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN\");\n+        addMech(CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN,\n+                                    \"CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN\");\n@@ -1355,0 +1411,14 @@\n+\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA1,    \"CKP_PKCS5_PBKD2_HMAC_SHA1\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_GOSTR3411,\n+                                             \"CKP_PKCS5_PBKD2_HMAC_GOSTR3411\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA224,  \"CKP_PKCS5_PBKD2_HMAC_SHA224\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA256,  \"CKP_PKCS5_PBKD2_HMAC_SHA256\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA384,  \"CKP_PKCS5_PBKD2_HMAC_SHA384\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA512,  \"CKP_PKCS5_PBKD2_HMAC_SHA512\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA512_224,\n+                                             \"CKP_PKCS5_PBKD2_HMAC_SHA512_224\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA512_256,\n+                                             \"CKP_PKCS5_PBKD2_HMAC_SHA512_256\");\n+\n+        addParamSources(CKZ_SALT_SPECIFIED,  \"CKZ_SALT_SPECIFIED\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/Functions.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1002,0 +1002,9 @@\n+    \/\/ Additional PKCS #12 PBE key derivation algorithms defined in NSS v3.29\n+    public static final long  CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN\n+                                        \/* (CKM_NSS + 29) *\/ = 0xCE53436DL;\n+    public static final long  CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN\n+                                        \/* (CKM_NSS + 30) *\/ = 0xCE53436EL;\n+    public static final long  CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN\n+                                        \/* (CKM_NSS + 31) *\/ = 0xCE53436FL;\n+    public static final long  CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN\n+                                        \/* (CKM_NSS + 32) *\/ = 0xCE534370L;\n@@ -1106,0 +1115,1 @@\n+    *\/\n@@ -1107,0 +1117,1 @@\n+    \/\/ PBKDF2 support, used in P11Util\n@@ -1118,0 +1129,1 @@\n+    \/*\n@@ -1156,3 +1168,3 @@\n-    \/\/ base number of NSS private attributes\n-    public static final long  CKA_NETSCAPE_BASE \/*0x80000000L + 0x4E534350L*\/\n-                                                      = 0xCE534350L;\n+    \/\/ base number of NSS private attributes. CKA_NETSCAPE_BASE is now known as\n+    \/\/ CKM_NSS = CKM_VENDOR_DEFINED | NSSCK_VENDOR_NSS = 0x80000000 | 0x4E534350\n+    public static final long  CKA_NETSCAPE_BASE       = 0xCE534350L;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11Constants.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1515,2 +1515,0 @@\n-        case CKM_PBE_SHA1_DES3_EDE_CBC:\n-        case CKM_PBE_SHA1_DES2_EDE_CBC:\n@@ -1518,0 +1516,4 @@\n+        case CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN:\n+        case CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN:\n+        case CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN:\n+        case CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN:\n@@ -1661,1 +1663,1 @@\n-    fieldID = (*env)->GetFieldID(env, jPbeParamsClass, \"pInitVector\", \"[C\");\n+    fieldID = (*env)->GetFieldID(env, jPbeParamsClass, \"pInitVector\", \"[B\");\n@@ -1667,1 +1669,1 @@\n-    fieldID = (*env)->GetFieldID(env, jPbeParamsClass, \"pSalt\", \"[C\");\n+    fieldID = (*env)->GetFieldID(env, jPbeParamsClass, \"pSalt\", \"[B\");\n@@ -1683,1 +1685,1 @@\n-    jCharArrayToCKCharArray(env, jInitVector, &(ckParamPtr->pInitVector), &ckTemp);\n+    jByteArrayToCKByteArray(env, jInitVector, &(ckParamPtr->pInitVector), &ckTemp);\n@@ -1687,1 +1689,1 @@\n-    jCharArrayToCKCharArray(env, jPassword, &(ckParamPtr->pPassword), &(ckParamPtr->ulPasswordLen));\n+    jCharArrayToCKUTF8CharArray(env, jPassword, &(ckParamPtr->pPassword), &(ckParamPtr->ulPasswordLen));\n@@ -1691,1 +1693,1 @@\n-    jCharArrayToCKCharArray(env, jSalt, &(ckParamPtr->pSalt), &(ckParamPtr->ulSaltLen));\n+    jByteArrayToCKByteArray(env, jSalt, &(ckParamPtr->pSalt), &(ckParamPtr->ulSaltLen));\n@@ -1770,0 +1772,16 @@\n+#define PBKD2_PARAM_SET(member, value)                              \\\n+    do {                                                            \\\n+        if(ckParamPtr->version == PARAMS) {                         \\\n+            ckParamPtr->params.v1.member = value;                   \\\n+        } else {                                                    \\\n+            ckParamPtr->params.v2.member = value;                   \\\n+        }                                                           \\\n+    } while(0)\n+\n+#define PBKD2_PARAM_ADDR(member)                                    \\\n+    (                                                               \\\n+        (ckParamPtr->version == PARAMS) ?                           \\\n+        (void*) &ckParamPtr->params.v1.member :                     \\\n+        (void*) &ckParamPtr->params.v2.member                       \\\n+    )\n+\n@@ -1771,1 +1789,2 @@\n- * converts the Java CK_PKCS5_PBKD2_PARAMS object to a CK_PKCS5_PBKD2_PARAMS\n+ * converts a Java CK_PKCS5_PBKD2_PARAMS object to a CK_PKCS5_PBKD2_PARAMS\n+ * pointer, or a Java CK_PKCS5_PBKD2_PARAMS2 object to a CK_PKCS5_PBKD2_PARAMS2\n@@ -1774,2 +1793,2 @@\n- * @param env - used to call JNI funktions to get the Java classes and objects\n- * @param jParam - the Java CK_PKCS5_PBKD2_PARAMS object to convert\n+ * @param env - used to call JNI functions to get the Java classes and objects\n+ * @param jParam - the Java object to convert\n@@ -1777,1 +1796,1 @@\n- * @return pointer to the new CK_PKCS5_PBKD2_PARAMS structure\n+ * @return pointer to the new structure\n@@ -1779,1 +1798,1 @@\n-CK_PKCS5_PBKD2_PARAMS_PTR\n+CK_VOID_PTR\n@@ -1782,1 +1801,3 @@\n-    CK_PKCS5_PBKD2_PARAMS_PTR ckParamPtr;\n+    VersionedPbkd2ParamsPtr ckParamPtr;\n+    ParamVersion paramVersion;\n+    CK_ULONG_PTR pUlPasswordLen;\n@@ -1786,1 +1807,1 @@\n-    jobject jSaltSourceData, jPrfData;\n+    jobject jSaltSourceData, jPrfData, jPassword;\n@@ -1793,2 +1814,12 @@\n-    jPkcs5Pbkd2ParamsClass = (*env)->FindClass(env, CLASS_PKCS5_PBKD2_PARAMS);\n-    if (jPkcs5Pbkd2ParamsClass == NULL) { return NULL; }\n+    if ((jPkcs5Pbkd2ParamsClass =\n+            (*env)->FindClass(env, CLASS_PKCS5_PBKD2_PARAMS)) != NULL\n+            && (*env)->IsInstanceOf(env, jParam, jPkcs5Pbkd2ParamsClass)) {\n+        paramVersion = PARAMS;\n+    } else if ((jPkcs5Pbkd2ParamsClass =\n+            (*env)->FindClass(env, CLASS_PKCS5_PBKD2_PARAMS2)) != NULL\n+            && (*env)->IsInstanceOf(env, jParam, jPkcs5Pbkd2ParamsClass)) {\n+        paramVersion = PARAMS2;\n+    } else {\n+        throwPKCS11RuntimeException(env, \"Unknown PBKD2 mechanism parameters class.\");\n+        return NULL;\n+    }\n@@ -1810,0 +1841,3 @@\n+    fieldID = (*env)->GetFieldID(env, jPkcs5Pbkd2ParamsClass, \"pPassword\", \"[C\");\n+    if (fieldID == NULL) { return NULL; }\n+    jPassword = (*env)->GetObjectField(env, jParam, fieldID);\n@@ -1811,2 +1845,2 @@\n-    \/\/ allocate memory for CK_PKCS5_PBKD2_PARAMS pointer\n-    ckParamPtr = calloc(1, sizeof(CK_PKCS5_PBKD2_PARAMS));\n+    \/\/ allocate memory for VersionedPbkd2Params and store the structure version\n+    ckParamPtr = calloc(1, sizeof(VersionedPbkd2Params));\n@@ -1817,0 +1851,1 @@\n+    ckParamPtr->version = paramVersion;\n@@ -1819,3 +1854,4 @@\n-    ckParamPtr->saltSource = jLongToCKULong(jSaltSource);\n-    jByteArrayToCKByteArray(env, jSaltSourceData, (CK_BYTE_PTR *)\n-            &(ckParamPtr->pSaltSourceData), &(ckParamPtr->ulSaltSourceDataLen));\n+    PBKD2_PARAM_SET(saltSource, jLongToCKULong(jSaltSource));\n+    jByteArrayToCKByteArray(env, jSaltSourceData,\n+            (CK_BYTE_PTR *) PBKD2_PARAM_ADDR(pSaltSourceData),\n+            PBKD2_PARAM_ADDR(ulSaltSourceDataLen));\n@@ -1825,4 +1861,21 @@\n-    ckParamPtr->iterations = jLongToCKULong(jIteration);\n-    ckParamPtr->prf = jLongToCKULong(jPrf);\n-    jByteArrayToCKByteArray(env, jPrfData, (CK_BYTE_PTR *)\n-            &(ckParamPtr->pPrfData), &(ckParamPtr->ulPrfDataLen));\n+    PBKD2_PARAM_SET(iterations, jLongToCKULong(jIteration));\n+    PBKD2_PARAM_SET(prf, jLongToCKULong(jPrf));\n+    jByteArrayToCKByteArray(env, jPrfData,\n+            (CK_BYTE_PTR *) PBKD2_PARAM_ADDR(pPrfData),\n+            PBKD2_PARAM_ADDR(ulPrfDataLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+    if (ckParamPtr->version == PARAMS) {\n+        pUlPasswordLen = calloc(1, sizeof(CK_ULONG));\n+        if (pUlPasswordLen == NULL) {\n+            throwOutOfMemoryError(env, 0);\n+            goto cleanup;\n+        }\n+        ckParamPtr->params.v1.ulPasswordLen = pUlPasswordLen;\n+    } else {\n+        pUlPasswordLen = &ckParamPtr->params.v2.ulPasswordLen;\n+    }\n+    jCharArrayToCKUTF8CharArray(env, jPassword,\n+            (CK_CHAR_PTR *) PBKD2_PARAM_ADDR(pPassword),\n+            pUlPasswordLen);\n@@ -1834,1 +1887,3 @@\n-        *pLength = sizeof(CK_PKCS5_PBKD2_PARAMS);\n+        *pLength = (ckParamPtr->version == PARAMS ?\n+            sizeof(ckParamPtr->params.v1) :\n+            sizeof(ckParamPtr->params.v2));\n@@ -1836,0 +1891,1 @@\n+    \/\/ VersionedPbkd2ParamsPtr is equivalent to CK_PKCS5_PBKD2_PARAMS[2]_PTR\n@@ -1838,2 +1894,1 @@\n-    free(ckParamPtr->pSaltSourceData);\n-    free(ckParamPtr->pPrfData);\n+    FREE_VERSIONED_PBKD2_MEMBERS(ckParamPtr);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":84,"deletions":29,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,0 +412,17 @@\n+                 case CKM_PKCS5_PBKD2:\n+                     \/\/ get the versioned structure from behind memory\n+                     TRACE0(((VersionedPbkd2ParamsPtr)tmp)->version == PARAMS ?\n+                             \"[ CK_PKCS5_PBKD2_PARAMS ]\\n\" :\n+                             \"[ CK_PKCS5_PBKD2_PARAMS2 ]\\n\");\n+                     FREE_VERSIONED_PBKD2_MEMBERS((VersionedPbkd2ParamsPtr)tmp);\n+                     break;\n+                 case CKM_PBA_SHA1_WITH_SHA1_HMAC:\n+                 case CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN:\n+                 case CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN:\n+                 case CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN:\n+                 case CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN:\n+                     TRACE0(\"[ CK_PBE_PARAMS ]\\n\");\n+                     free(((CK_PBE_PARAMS_PTR)tmp)->pInitVector);\n+                     free(((CK_PBE_PARAMS_PTR)tmp)->pPassword);\n+                     free(((CK_PBE_PARAMS_PTR)tmp)->pSalt);\n+                     break;\n@@ -416,1 +433,1 @@\n-                     \/\/ CKM_SKIPJACK_*, CKM_KEY_WRAP_SET_OAEP, CKM_PKCS5_PBKD2,\n+                     \/\/ CKM_SKIPJACK_*, CKM_KEY_WRAP_SET_OAEP,\n@@ -519,1 +536,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -521,1 +539,0 @@\n-        *ckpLength = 0L;\n@@ -524,1 +541,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n@@ -561,1 +577,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -563,1 +580,0 @@\n-        *ckpLength = 0L;\n@@ -566,1 +582,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n@@ -608,1 +623,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -610,1 +626,0 @@\n-        *ckpLength = 0L;\n@@ -613,1 +628,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n@@ -650,1 +664,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -652,1 +667,0 @@\n-        *ckpLength = 0L;\n@@ -655,1 +669,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n@@ -692,1 +705,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -694,1 +708,0 @@\n-        *ckpLength = 0L;\n@@ -697,1 +710,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+\/* CKA_NETSCAPE_BASE is now known as CKM_NSS (CKM_VENDOR_DEFINED | NSSCK_VENDOR_NSS) *\/\n@@ -74,1 +75,1 @@\n-#define CKA_NETSCAPE_TRUST_CODE_SIGNING (CKA_NETSCAPE_TRUST_BASE + 10)\n+#define CKA_NETSCAPE_TRUST_CODE_SIGNING         (CKA_NETSCAPE_TRUST_BASE + 10)\n@@ -79,0 +80,6 @@\n+\/* additional PKCS #12 PBE key derivation algorithms defined in NSS v3.29 *\/\n+#define CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN  (CKA_NETSCAPE_BASE + 29)\n+#define CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN  (CKA_NETSCAPE_BASE + 30)\n+#define CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN  (CKA_NETSCAPE_BASE + 31)\n+#define CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN  (CKA_NETSCAPE_BASE + 32)\n+\n@@ -274,0 +281,1 @@\n+#define CLASS_PKCS5_PBKD2_PARAMS2 \"sun\/security\/pkcs11\/wrapper\/CK_PKCS5_PBKD2_PARAMS2\"\n@@ -387,1 +395,1 @@\n-CK_PKCS5_PBKD2_PARAMS_PTR jPkcs5Pbkd2ParamToCKPkcs5Pbkd2ParamPtr(JNIEnv *env, jobject jParam, CK_ULONG* pLength);\n+CK_VOID_PTR jPkcs5Pbkd2ParamToCKPkcs5Pbkd2ParamPtr(JNIEnv *env, jobject jParam, CK_ULONG* pLength);\n@@ -397,0 +405,25 @@\n+\/* handling of CK_PKCS5_PBKD2_PARAMS and CK_PKCS5_PBKD2_PARAMS2 *\/\n+typedef enum {PARAMS=0, PARAMS2} ParamVersion;\n+\n+typedef struct {\n+    union {\n+        CK_PKCS5_PBKD2_PARAMS v1;\n+        CK_PKCS5_PBKD2_PARAMS2 v2;\n+    } params;\n+    ParamVersion version;\n+} VersionedPbkd2Params, *VersionedPbkd2ParamsPtr;\n+\n+#define FREE_VERSIONED_PBKD2_MEMBERS(verParamsPtr)                  \\\n+    do {                                                            \\\n+        if ((verParamsPtr)->version == PARAMS) {                    \\\n+            free((verParamsPtr)->params.v1.pSaltSourceData);        \\\n+            free((verParamsPtr)->params.v1.pPrfData);               \\\n+            free((verParamsPtr)->params.v1.pPassword);              \\\n+            free((verParamsPtr)->params.v1.ulPasswordLen);          \\\n+        } else {                                                    \\\n+            free((verParamsPtr)->params.v2.pSaltSourceData);        \\\n+            free((verParamsPtr)->params.v2.pPrfData);               \\\n+            free((verParamsPtr)->params.v2.pPassword);              \\\n+        }                                                           \\\n+    } while(0)\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.security.AlgorithmParameters;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.interfaces.PBEKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+\/*\n+ * @test\n+ * @bug 8301553\n+ * @summary test password based encryption on SunPKCS11's Cipher service\n+ * @library \/test\/lib ..\n+ * @run main\/othervm\/timeout=30 PBECipher\n+ *\/\n+\n+public final class PBECipher extends PKCS11Test {\n+    private static final char[] password = \"123456\".toCharArray();\n+    private static final byte[] salt = \"abcdefgh\".getBytes();\n+    private static final int iterations = 1000;\n+    private static final int AES_BLOCK_SIZE = 16;\n+    private static final PBEParameterSpec pbeSpec = new PBEParameterSpec(salt,\n+            iterations, new IvParameterSpec(new byte[AES_BLOCK_SIZE]));\n+    private static final String plainText = \"This is a known plain text!\";\n+    private static final String sep = \"======================================\" +\n+            \"===================================\";\n+\n+    private enum Configuration {\n+        \/\/ Pass salt and iterations to a Cipher through a PBEParameterSpec.\n+        PBEParameterSpec,\n+\n+        \/\/ Derive a key using SunPKCS11's SecretKeyFactory (wrapping password,\n+        \/\/ salt and iterations in a PBEKeySpec), and pass it to a Cipher.\n+        SecretKeyFactoryDerivedKey,\n+\n+        \/\/ Pass salt and iterations to a Cipher through an AlgorithmParameters.\n+        AlgorithmParameters,\n+\n+        \/\/ Pass password, salt and iterations and iterations to\n+        \/\/ a Cipher through an anonymous class implementing the\n+        \/\/ javax.crypto.interfaces.PBEKey interface.\n+        AnonymousPBEKey,\n+    }\n+\n+    private static Provider sunJCE = Security.getProvider(\"SunJCE\");\n+\n+    private record AssertionData(String pbeCipherAlgo, String cipherAlgo,\n+            BigInteger expectedCiphertext) {}\n+\n+    private static AssertionData cipherAssertionData(String pbeCipherAlgo,\n+            String cipherAlgo, String staticExpectedCiphertextString) {\n+        BigInteger staticExpectedCiphertext =\n+                new BigInteger(staticExpectedCiphertextString, 16);\n+        BigInteger expectedCiphertext = null;\n+        if (sunJCE != null) {\n+            try {\n+                expectedCiphertext = computeCipherText(sunJCE, pbeCipherAlgo,\n+                        pbeCipherAlgo, Configuration.PBEParameterSpec);\n+                checkAssertionValues(expectedCiphertext,\n+                        staticExpectedCiphertext);\n+            } catch (GeneralSecurityException e) {\n+                \/\/ Move to staticExpectedCiphertext as it's unlikely\n+                \/\/ that any of the algorithms are available.\n+                sunJCE = null;\n+            }\n+        }\n+        if (expectedCiphertext == null) {\n+            expectedCiphertext = staticExpectedCiphertext;\n+        }\n+        return new AssertionData(pbeCipherAlgo, cipherAlgo, expectedCiphertext);\n+    }\n+\n+    private static void checkAssertionValues(BigInteger expectedValue,\n+            BigInteger staticExpectedValue) {\n+        if (!expectedValue.equals(staticExpectedValue)) {\n+            printHex(\"SunJCE value\", expectedValue);\n+            printHex(\"Static value\", staticExpectedValue);\n+            throw new Error(\"Static and SunJCE values do not match.\");\n+        }\n+    }\n+\n+    \/\/ Generated with SunJCE.\n+    private static final AssertionData[] assertionData = new AssertionData[]{\n+            cipherAssertionData(\"PBEWithHmacSHA1AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"ba1c9614d550912925d99e0bc8969032\" +\n+                    \"7ac6258b72117dcf750c19ee6ca73dd4\"),\n+            cipherAssertionData(\"PBEWithHmacSHA224AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"41960c43ca99cf2184511aaf2f0508a9\" +\n+                    \"7da3762ee6c2b7e2027c8076811f2e52\"),\n+            cipherAssertionData(\"PBEWithHmacSHA256AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"6bb6a3dc3834e81e5ca6b5e70073ff46\" +\n+                    \"903b188940a269ed26db2ffe622b8e16\"),\n+            cipherAssertionData(\"PBEWithHmacSHA384AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"22aabf7a6a059415dc4ca7d985f3de06\" +\n+                    \"8f8300ca48d8de585d802670f4c1d9bd\"),\n+            cipherAssertionData(\"PBEWithHmacSHA512AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"b523e7c462a0b7fd74e492b3a6550464\" +\n+                    \"ceebe81f08649ae163673afc242ad8a2\"),\n+            cipherAssertionData(\"PBEWithHmacSHA1AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"1e7c25e166afae069cec68ef9affca61\" +\n+                    \"aea02ab1c3dc7471cb767ed7d6e37af0\"),\n+            cipherAssertionData(\"PBEWithHmacSHA224AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"6701f1cc75b6494ec4bd27158aa2c15d\" +\n+                    \"7d10bc2f1fbb7d92d8277c7edfd1dd57\"),\n+            cipherAssertionData(\"PBEWithHmacSHA256AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"f82eb2fc016505baeb23ecdf85163933\" +\n+                    \"5e8d6d48b48631185641febb75898a1d\"),\n+            cipherAssertionData(\"PBEWithHmacSHA384AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"ee9528022e58cdd9be80cd88443e03b3\" +\n+                    \"de13376cf97c53d946d5c5dfc88097be\"),\n+            cipherAssertionData(\"PBEWithHmacSHA512AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"18f472912ffaa31824e20a5486324e14\" +\n+                    \"0225e20cb158762e8647b1216fe0ab7e\"),\n+    };\n+\n+    private static final class NoRandom extends SecureRandom {\n+        @Override\n+        public void nextBytes(byte[] bytes) {}\n+    }\n+\n+    public void main(Provider sunPKCS11) throws Exception {\n+        System.out.println(\"SunPKCS11: \" + sunPKCS11.getName());\n+        for (Configuration conf : Configuration.values()) {\n+            for (AssertionData data : assertionData) {\n+                testWith(sunPKCS11, data, true, conf);\n+                if (conf != Configuration.PBEParameterSpec &&\n+                        conf != Configuration.AlgorithmParameters) {\n+                    testWith(sunPKCS11, data, false, conf);\n+                }\n+            }\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    private static void testWith(Provider sunPKCS11, AssertionData data,\n+            boolean testPBEService, Configuration conf) throws Exception {\n+        String svcAlgo = testPBEService ? data.pbeCipherAlgo : data.cipherAlgo;\n+        System.out.println(sep + System.lineSeparator() + svcAlgo\n+                + \" (with \" + conf.name() + \")\");\n+\n+        BigInteger cipherText = computeCipherText(sunPKCS11, svcAlgo,\n+                data.pbeCipherAlgo, conf);\n+        printHex(\"Cipher Text\", cipherText);\n+\n+        if (!cipherText.equals(data.expectedCiphertext)) {\n+            printHex(\"Expected Cipher Text\", data.expectedCiphertext);\n+            throw new Exception(\"Expected Cipher Text did not match\");\n+        }\n+    }\n+\n+    private static BigInteger computeCipherText(Provider p, String svcAlgo,\n+            String keyAlgo, Configuration conf)\n+            throws GeneralSecurityException {\n+        Cipher cipher = Cipher.getInstance(svcAlgo, p);\n+        switch (conf) {\n+            case PBEParameterSpec, AlgorithmParameters -> {\n+                SecretKey key = getPasswordOnlyPBEKey();\n+                switch (conf) {\n+                    case PBEParameterSpec -> {\n+                        cipher.init(Cipher.ENCRYPT_MODE, key, pbeSpec);\n+                    }\n+                    case AlgorithmParameters -> {\n+                        AlgorithmParameters algoParams =\n+                                AlgorithmParameters.getInstance(\"PBES2\");\n+                        algoParams.init(pbeSpec);\n+                        cipher.init(Cipher.ENCRYPT_MODE, key, algoParams);\n+                    }\n+                }\n+            }\n+            case SecretKeyFactoryDerivedKey -> {\n+                SecretKey key = getDerivedSecretKey(p, keyAlgo);\n+                cipher.init(Cipher.ENCRYPT_MODE, key,\n+                        pbeSpec.getParameterSpec());\n+            }\n+            case AnonymousPBEKey -> {\n+                SecretKey key = getAnonymousPBEKey(keyAlgo,\n+                        svcAlgo.equals(keyAlgo));\n+                cipher.init(Cipher.ENCRYPT_MODE, key, new NoRandom());\n+            }\n+        }\n+        return new BigInteger(1, cipher.doFinal(plainText.getBytes()));\n+    }\n+\n+    private static SecretKey getPasswordOnlyPBEKey()\n+            throws GeneralSecurityException {\n+        return SecretKeyFactory.getInstance(\"PBE\")\n+                .generateSecret(new PBEKeySpec(password));\n+    }\n+\n+    private static SecretKey getDerivedSecretKey(Provider sunPKCS11,\n+            String algorithm) throws GeneralSecurityException {\n+        return SecretKeyFactory.getInstance(algorithm, sunPKCS11)\n+                .generateSecret(new PBEKeySpec(password, salt, iterations));\n+    }\n+\n+    private static SecretKey getAnonymousPBEKey(String algorithm,\n+            boolean isPbeCipherSvc) {\n+        return new PBEKey() {\n+            public byte[] getSalt() { return salt.clone(); }\n+            public int getIterationCount() { return iterations; }\n+            public String getAlgorithm() { return algorithm; }\n+            public String getFormat() { return \"RAW\"; }\n+            public char[] getPassword() { return password.clone(); }\n+            public byte[] getEncoded() {\n+                byte[] encodedKey = null;\n+                if (isPbeCipherSvc) {\n+                    encodedKey = new byte[password.length];\n+                    for (int i = 0; i < password.length; i++) {\n+                        encodedKey[i] = (byte) (password[i] & 0x7f);\n+                    }\n+                }\n+                return encodedKey;\n+            }\n+        };\n+    }\n+\n+    private static void printHex(String title, BigInteger b) {\n+        String repr = (b == null) ? \"buffer is null\" : b.toString(16);\n+        System.out.println(title + \": \" + repr + System.lineSeparator());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new PBECipher());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/PBECipher.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.MessageDigest;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+\/*\n+ * @test\n+ * @bug 8301553\n+ * @summary test SunPKCS11's password based privacy and integrity\n+ *          applied to PKCS #12 keystores\n+ * @library \/test\/lib ..\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm\/timeout=30 ImportKeyToP12\n+ *\/\n+\n+public final class ImportKeyToP12 extends PKCS11Test {\n+    private static final String alias = \"alias\";\n+    private static final char[] password = \"123456\".toCharArray();\n+    private static final Key key = new SecretKeySpec(new byte[] {\n+            0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,\n+            0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf }, \"AES\");\n+    private static final String[] pbeCipherAlgs = new String[] {\n+            \"PBEWithHmacSHA1AndAES_128\", \"PBEWithHmacSHA224AndAES_128\",\n+            \"PBEWithHmacSHA256AndAES_128\", \"PBEWithHmacSHA384AndAES_128\",\n+            \"PBEWithHmacSHA512AndAES_128\", \"PBEWithHmacSHA1AndAES_256\",\n+            \"PBEWithHmacSHA224AndAES_256\", \"PBEWithHmacSHA256AndAES_256\",\n+            \"PBEWithHmacSHA384AndAES_256\", \"PBEWithHmacSHA512AndAES_256\"\n+    };\n+    private static final String[] pbeMacAlgs = new String[] {\n+            \"HmacPBESHA1\", \"HmacPBESHA224\", \"HmacPBESHA256\",\n+            \"HmacPBESHA384\", \"HmacPBESHA512\"\n+    };\n+    private static final KeyStore p12;\n+    private static final String sep = \"======================================\" +\n+            \"===================================\";\n+\n+    static {\n+        KeyStore tP12 = null;\n+        try {\n+            tP12 = KeyStore.getInstance(\"PKCS12\");\n+        } catch (KeyStoreException e) {}\n+        p12 = tP12;\n+    }\n+\n+    public void main(Provider sunPKCS11) throws Exception {\n+        System.out.println(\"SunPKCS11: \" + sunPKCS11.getName());\n+        \/\/ Test all privacy PBE algorithms with an integrity algorithm fixed\n+        for (String pbeCipherAlg : pbeCipherAlgs) {\n+            \/\/ Make sure that SunPKCS11 implements the Cipher algorithm\n+            Cipher.getInstance(pbeCipherAlg, sunPKCS11);\n+            testWith(sunPKCS11, pbeCipherAlg, pbeMacAlgs[0]);\n+        }\n+        \/\/ Test all integrity PBE algorithms with a privacy algorithm fixed\n+        for (String pbeMacAlg : pbeMacAlgs) {\n+            \/\/ Make sure that SunPKCS11 implements the Mac algorithm\n+            Mac.getInstance(pbeMacAlg, sunPKCS11);\n+            testWith(sunPKCS11, pbeCipherAlgs[0], pbeMacAlg);\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    \/*\n+     * Consistency test: 1) store a secret key in a PKCS #12 keystore using\n+     * PBE algorithms from SunPKCS11 and, 2) read the secret key from the\n+     * PKCS #12 keystore using PBE algorithms from other security providers\n+     * such as SunJCE.\n+     *\/\n+    private void testWith(Provider sunPKCS11, String pbeCipherAlg,\n+            String pbeMacAlg) throws Exception {\n+        System.out.println(sep + System.lineSeparator() +\n+                \"Cipher PBE: \" + pbeCipherAlg + System.lineSeparator() +\n+                \"Mac PBE: \" + pbeMacAlg);\n+\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", pbeMacAlg);\n+        System.setProperty(\"keystore.pkcs12.keyProtectionAlgorithm\",\n+                pbeCipherAlg);\n+\n+        \/\/ Create an empty PKCS #12 keystore\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        p12.load(null, password);\n+\n+        \/\/ Use PBE privacy and integrity algorithms from SunPKCS11 to store\n+        \/\/ the secret key\n+        Security.insertProviderAt(sunPKCS11, 1);\n+        p12.setKeyEntry(alias, key, password, null);\n+        p12.store(baos, password);\n+\n+        \/\/ Use PBE privacy and integrity algorithms from other security\n+        \/\/ providers, such as SunJCE, to read the secret key\n+        Security.removeProvider(sunPKCS11.getName());\n+        p12.load(new ByteArrayInputStream(baos.toByteArray()), password);\n+        Key k = p12.getKey(alias, password);\n+\n+        if (!MessageDigest.isEqual(key.getEncoded(), k.getEncoded())) {\n+            throw new Exception(\"Keys differ. Consistency check failed.\");\n+        }\n+        System.out.println(\"Secret key import successful\"\n+                + System.lineSeparator() + sep);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new ImportKeyToP12());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/ImportKeyToP12.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import java.security.SecureRandom;\n@@ -45,1 +44,0 @@\n-import javax.crypto.spec.SecretKeySpec;\n@@ -72,1 +70,0 @@\n-        SecureRandom srdm = new SecureRandom();\n@@ -76,4 +73,1 @@\n-            byte[] keyVal = new byte[KEY_SIZE];\n-            srdm.nextBytes(keyVal);\n-            SecretKey skey = new SecretKeySpec(keyVal, alg);\n-\n+            SecretKey skey = generateKey(alg, KEY_SIZE);\n@@ -89,0 +83,1 @@\n+                \/\/ No KeyGenerator support for PBE\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/MacSameTest.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.interfaces.PBEKey;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+\/*\n+ * @test\n+ * @bug 8301553\n+ * @summary test password based authentication on SunPKCS11's Mac service\n+ * @library \/test\/lib ..\n+ * @run main\/othervm\/timeout=30 PBAMac\n+ *\/\n+\n+public final class PBAMac extends PKCS11Test {\n+    private static final char[] password = \"123456\".toCharArray();\n+    private static final byte[] salt = \"abcdefgh\".getBytes();\n+    private static final int iterations = 1000;\n+    private static final String plainText = \"This is a known plain text!\";\n+    private static final String sep = \"======================================\" +\n+            \"===================================\";\n+\n+    private enum Configuration {\n+        \/\/ Pass salt and iterations to a Mac through a PBEParameterSpec.\n+        PBEParameterSpec,\n+\n+        \/\/ Derive a key using SunPKCS11's SecretKeyFactory (wrapping password,\n+        \/\/ salt and iterations in a PBEKeySpec), and pass it to a Mac.\n+        SecretKeyFactoryDerivedKey,\n+\n+        \/\/ Pass password, salt and iterations and iterations to\n+        \/\/ a Mac through an anonymous class implementing the\n+        \/\/ javax.crypto.interfaces.PBEKey interface.\n+        AnonymousPBEKey,\n+    }\n+\n+    private static Provider sunJCE = Security.getProvider(\"SunJCE\");\n+\n+    private record AssertionData(String pbeHmacAlgo, String hmacAlgo,\n+            BigInteger expectedMac) {}\n+\n+    private static AssertionData macAssertionData(String pbeHmacAlgo,\n+            String hmacAlgo, String staticExpectedMacString) {\n+        BigInteger staticExpectedMac = new BigInteger(staticExpectedMacString,\n+                16);\n+        BigInteger expectedMac = null;\n+        if (sunJCE != null) {\n+            try {\n+                expectedMac = computeMac(sunJCE, pbeHmacAlgo,\n+                        pbeHmacAlgo, Configuration.PBEParameterSpec);\n+                checkAssertionValues(expectedMac, staticExpectedMac);\n+            } catch (GeneralSecurityException e) {\n+                \/\/ Move to staticExpectedMac as it's unlikely\n+                \/\/ that any of the algorithms are available.\n+                sunJCE = null;\n+            }\n+        }\n+        if (expectedMac == null) {\n+            expectedMac = staticExpectedMac;\n+        }\n+        return new AssertionData(pbeHmacAlgo, hmacAlgo, expectedMac);\n+    }\n+\n+    private static void checkAssertionValues(BigInteger expectedValue,\n+            BigInteger staticExpectedValue) {\n+        if (!expectedValue.equals(staticExpectedValue)) {\n+            printHex(\"SunJCE value\", expectedValue);\n+            printHex(\"Static value\", staticExpectedValue);\n+            throw new Error(\"Static and SunJCE values do not match.\");\n+        }\n+    }\n+\n+    \/\/ Generated with SunJCE.\n+    private static final AssertionData[] assertionData = new AssertionData[]{\n+            macAssertionData(\"HmacPBESHA1\", \"HmacSHA1\",\n+                    \"707606929395e4297adc63d520ac7d22f3f5fa66\"),\n+            macAssertionData(\"HmacPBESHA224\", \"HmacSHA224\",\n+                    \"4ffb5ad4974a7a9fca5a36ebe3e34dd443c07fb68c392f8b611657e6\"),\n+            macAssertionData(\"HmacPBESHA256\", \"HmacSHA256\",\n+                    \"9e8c102c212d2fd1334dc497acb4e002b04e84713b7eda5a63807af2\" +\n+                    \"989d3e50\"),\n+            macAssertionData(\"HmacPBESHA384\", \"HmacSHA384\",\n+                    \"77f31a785d4f2220251143a4ba80f5610d9d0aeaebb4a278b8a7535c\" +\n+                    \"8cea8e8211809ba450458e351c5b66d691839c23\"),\n+            macAssertionData(\"HmacPBESHA512\", \"HmacSHA512\",\n+                    \"a53f942a844b234a69c1f92cba20ef272c4394a3cf4024dc16d9dbac\" +\n+                    \"1969870b1c2b28b897149a1a3b9ad80a7ca8c547dfabf3ed5f144c6b\" +\n+                    \"593900b62e120c45\"),\n+    };\n+\n+    public void main(Provider sunPKCS11) throws Exception {\n+        System.out.println(\"SunPKCS11: \" + sunPKCS11.getName());\n+        for (Configuration conf : Configuration.values()) {\n+            for (AssertionData data : assertionData) {\n+                testWith(sunPKCS11, data, true, conf);\n+                if (conf != Configuration.PBEParameterSpec) {\n+                    testWith(sunPKCS11, data, false, conf);\n+                }\n+            }\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    private static void testWith(Provider sunPKCS11, AssertionData data,\n+            boolean testPBEService, Configuration conf) throws Exception {\n+        String svcAlgo = testPBEService ? data.pbeHmacAlgo : data.hmacAlgo;\n+        System.out.println(sep + System.lineSeparator() + svcAlgo\n+                + \" (with \" + conf.name() + \")\");\n+\n+        BigInteger mac = computeMac(sunPKCS11, svcAlgo, data.pbeHmacAlgo, conf);\n+        printHex(\"HMAC\", mac);\n+\n+        if (!mac.equals(data.expectedMac)) {\n+            printHex(\"Expected HMAC\", data.expectedMac);\n+            throw new Exception(\"Expected HMAC did not match\");\n+        }\n+    }\n+\n+    private static BigInteger computeMac(Provider p, String svcAlgo,\n+            String keyAlgo, Configuration conf)\n+            throws GeneralSecurityException {\n+        Mac mac = Mac.getInstance(svcAlgo, p);\n+        switch (conf) {\n+            case PBEParameterSpec -> {\n+                SecretKey key = getPasswordOnlyPBEKey();\n+                mac.init(key, new PBEParameterSpec(salt, iterations));\n+            }\n+            case SecretKeyFactoryDerivedKey -> {\n+                SecretKey key = getDerivedSecretKey(p, keyAlgo);\n+                mac.init(key);\n+            }\n+            case AnonymousPBEKey -> {\n+                SecretKey key = getAnonymousPBEKey(keyAlgo);\n+                mac.init(key);\n+            }\n+        }\n+        return new BigInteger(1, mac.doFinal(plainText.getBytes()));\n+    }\n+\n+    private static SecretKey getPasswordOnlyPBEKey()\n+            throws GeneralSecurityException {\n+        return SecretKeyFactory.getInstance(\"PBE\")\n+                .generateSecret(new PBEKeySpec(password));\n+    }\n+\n+    private static SecretKey getDerivedSecretKey(Provider sunPKCS11,\n+            String algorithm) throws GeneralSecurityException {\n+        return SecretKeyFactory.getInstance(algorithm, sunPKCS11)\n+                .generateSecret(new PBEKeySpec(password, salt, iterations));\n+    }\n+\n+    private static SecretKey getAnonymousPBEKey(String algorithm) {\n+        return new PBEKey() {\n+            public byte[] getSalt() { return salt.clone(); }\n+            public int getIterationCount() { return iterations; }\n+            public String getAlgorithm() { return algorithm; }\n+            public String getFormat() { return \"RAW\"; }\n+            public char[] getPassword() { return password.clone(); }\n+            public byte[] getEncoded() { return null; }\n+        };\n+    }\n+\n+    private static void printHex(String title, BigInteger b) {\n+        String repr = (b == null) ? \"buffer is null\" : b.toString(16);\n+        System.out.println(title + \": \" + repr + System.lineSeparator());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new PBAMac());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/PBAMac.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.SecretKey;\n@@ -54,2 +54,0 @@\n-        byte[] keyVal = new byte[16];\n-        random.nextBytes(keyVal);\n@@ -59,0 +57,1 @@\n+            SecretKey skey = generateKey(alg, 16);\n@@ -60,1 +59,1 @@\n-                doTest(alg, p, keyVal, data);\n+                doTest(alg, p, skey, data);\n@@ -75,1 +74,1 @@\n-    private void doTest(String alg, Provider p, byte[] keyVal, byte[] data)\n+    private void doTest(String alg, Provider p, SecretKey key, byte[] data)\n@@ -78,1 +77,0 @@\n-        SecretKeySpec key = new SecretKeySpec(keyVal, alg);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/ReinitMac.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.security.SecureRandom;\n@@ -58,0 +59,3 @@\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n@@ -831,0 +835,52 @@\n+    private static final SecureRandom srdm = new SecureRandom();\n+\n+    static SecretKey generateKey(String alg, int keySize) {\n+        if (alg.contains(\"PBE\")) {\n+            return generateKeyPBE(alg, keySize);\n+        } else {\n+            return generateKeyNonPBE(alg, keySize);\n+        }\n+    }\n+\n+    private static SecretKey generateKeyNonPBE(String alg, int keySize) {\n+        byte[] keyVal = new byte[keySize];\n+        srdm.nextBytes(keyVal);\n+        return new SecretKeySpec(keyVal, alg);\n+    }\n+\n+    private static SecretKey generateKeyPBE(String alg, int keySize) {\n+        char[] pass = new char[keySize];\n+        for (int i = 0; i < pass.length; i++) {\n+            pass[i] = (char) ('0' + srdm.nextInt(74));\n+        }\n+        byte[] salt = new byte[srdm.nextInt(8, 16)];\n+        srdm.nextBytes(salt);\n+        int iterations = srdm.nextInt(1, 1000);\n+        return new javax.crypto.interfaces.PBEKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"PBE\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return null;\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                return new byte[0];\n+            }\n+            @Override\n+            public char[] getPassword() {\n+                return pass;\n+            }\n+            @Override\n+            public byte[] getSalt() {\n+                return salt;\n+            }\n+            @Override\n+            public int getIterationCount() {\n+                return iterations;\n+            }\n+        };\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,515 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.ReflectiveOperationException;\n+import java.math.BigInteger;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.interfaces.PBEKey;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+\/*\n+ * @test\n+ * @bug 8301553\n+ * @summary test key derivation on a SunPKCS11 SecretKeyFactory service\n+ * @library \/test\/lib ..\n+ * @modules java.base\/com.sun.crypto.provider:open\n+ * @run main\/othervm\/timeout=30 TestPBKD\n+ *\/\n+\n+public final class TestPBKD extends PKCS11Test {\n+    private static final String sep = \"======================================\" +\n+            \"===================================\";\n+\n+    private enum Configuration {\n+        \/\/ Pass password, salt and iterations to a\n+        \/\/ SecretKeyFactory through a PBEKeySpec.\n+        PBEKeySpec,\n+\n+        \/\/ Pass password, salt and iterations and iterations to a\n+        \/\/ SecretKeyFactory through an anonymous class implementing\n+        \/\/ the javax.crypto.interfaces.PBEKey interface.\n+        AnonymousPBEKey,\n+    }\n+\n+    private static Provider sunJCE = Security.getProvider(\"SunJCE\");\n+\n+    private static BigInteger i(byte[] data) {\n+        return new BigInteger(1, data);\n+    }\n+\n+    private record AssertionData(String algo, PBEKeySpec keySpec,\n+            BigInteger expectedKey) {}\n+\n+    private static AssertionData p12PBKDAssertionData(String algo,\n+            char[] password, int keyLen, String hashAlgo, int blockLen,\n+            String staticExpectedKeyString) {\n+        PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterations, keyLen);\n+        BigInteger staticExpectedKey = new BigInteger(staticExpectedKeyString,\n+                16);\n+        BigInteger expectedKey;\n+        try {\n+            \/\/ Since we need to access an internal\n+            \/\/ SunJCE API, we use reflection.\n+            Class<?> PKCS12PBECipherCore = Class.forName(\n+                    \"com.sun.crypto.provider.PKCS12PBECipherCore\");\n+\n+            Field macKeyField = PKCS12PBECipherCore.getDeclaredField(\"MAC_KEY\");\n+            macKeyField.setAccessible(true);\n+            int MAC_KEY = (int) macKeyField.get(null);\n+\n+            Method deriveMethod = PKCS12PBECipherCore.getDeclaredMethod(\n+                    \"derive\", char[].class, byte[].class, int.class,\n+                    int.class, int.class, String.class, int.class);\n+            deriveMethod.setAccessible(true);\n+            expectedKey = i((byte[]) deriveMethod.invoke(null,\n+                    keySpec.getPassword(), keySpec.getSalt(),\n+                    keySpec.getIterationCount(), keySpec.getKeyLength() \/ 8,\n+                    MAC_KEY, hashAlgo, blockLen));\n+            checkAssertionValues(expectedKey, staticExpectedKey);\n+        } catch (ReflectiveOperationException ignored) {\n+            expectedKey = staticExpectedKey;\n+        }\n+        return new AssertionData(algo, keySpec, expectedKey);\n+    }\n+\n+    private static AssertionData pbkd2AssertionData(String algo,\n+            char[] password, int keyLen, String kdfAlgo,\n+            String staticExpectedKeyString) {\n+        PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterations, keyLen);\n+        BigInteger staticExpectedKey = new BigInteger(staticExpectedKeyString,\n+                16);\n+        BigInteger expectedKey = null;\n+        if (sunJCE != null) {\n+            try {\n+                expectedKey = i(SecretKeyFactory.getInstance(kdfAlgo, sunJCE)\n+                        .generateSecret(keySpec).getEncoded());\n+                checkAssertionValues(expectedKey, staticExpectedKey);\n+            } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+                \/\/ Move to staticExpectedKey as it's unlikely\n+                \/\/ that any of the algorithms are available.\n+                sunJCE = null;\n+            }\n+        }\n+        if (expectedKey == null) {\n+            expectedKey = staticExpectedKey;\n+        }\n+        return new AssertionData(algo, keySpec, expectedKey);\n+    }\n+\n+    private static void checkAssertionValues(BigInteger expectedValue,\n+            BigInteger staticExpectedValue) {\n+        if (!expectedValue.equals(staticExpectedValue)) {\n+            printHex(\"SunJCE value\", expectedValue);\n+            printHex(\"Static value\", staticExpectedValue);\n+            throw new Error(\"Static and SunJCE values do not match.\");\n+        }\n+    }\n+\n+    private static final char[] pwd = \"123456\\uA4F7\".toCharArray();\n+    private static final char[] emptyPwd = new char[0];\n+    private static final byte[] salt = \"abcdefgh\".getBytes();\n+    private static final int iterations = 1000;\n+\n+    \/\/ Generated with SunJCE. Keep a reference to some\n+    \/\/ entries for tests executing invalid conditions.\n+    private static final AssertionData hmacPBESHA1Data =\n+            p12PBKDAssertionData(\"HmacPBESHA1\", pwd, 160, \"SHA-1\", 64,\n+                    \"13156c6bee8e13ef568231e0174651afa5a358b0\");\n+    private static final AssertionData hmacPBESHA224Data =\n+            p12PBKDAssertionData(\"HmacPBESHA224\", pwd, 224, \"SHA-224\", 64,\n+                    \"d93acf4b3bea8a89d098e290928840c0b693a30cad0117f70ace50c2\");\n+    private static final AssertionData pbeWithHmacSHA512AndAES256Data =\n+            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\" +\n+                    \"7e3077595f90b60ab96d4f29203927b0\");\n+    private static final AssertionData pbkdf2WithHmacSHA256Data =\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA256\", pwd, 384,\n+                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\" +\n+                    \"44984e3e9b619488a42b93dd6453f630ae3e2ad7ed809fa9e98a7921\" +\n+                    \"87d62e84\");\n+    private static final AssertionData[] assertionData = new AssertionData[]{\n+            hmacPBESHA1Data,\n+            hmacPBESHA224Data,\n+            p12PBKDAssertionData(\"HmacPBESHA256\", pwd, 256, \"SHA-256\", 64,\n+                    \"1bb3ed1ffb784ed32f59b4d7515971699af99cf67a2e574000964c8e\" +\n+                    \"1eba1c45\"),\n+            p12PBKDAssertionData(\"HmacPBESHA384\", pwd, 384, \"SHA-384\", 128,\n+                    \"d4ce121d3cec88a8c8b0c6225f7f996b72d76017c2d91bc51fd47985\" +\n+                    \"86d1012d1ad03a39fdcd0fdc438d164ab50259fc\"),\n+            p12PBKDAssertionData(\"HmacPBESHA512\", pwd, 512, \"SHA-512\", 128,\n+                    \"5f80b350986e5156669193eaa42a107e7d6636d82fb550f67af5b2c2\" +\n+                    \"f546d977b70e52bbbcb6bb8976f9d3f0eaf9bfef5306c50ee5ccda3e\" +\n+                    \"e4c4c7c8421fe4d\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA1AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA224AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA256AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA384AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA1AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d40\" +\n+                    \"b5552da5e645dad4b5911ce0f2f06b\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA224AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\" +\n+                    \"7daa2119fee8c64aef7c1f4c1871724e\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA256AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\" +\n+                    \"44984e3e9b619488a42b93dd6453f630\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA384AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\" +\n+                    \"d7d0ad3a18912086f80d974f2acc2efb\"),\n+            pbeWithHmacSHA512AndAES256Data,\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA1\", pwd, 240,\n+                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d40\" +\n+                    \"b5552da5e645dad4b5911ce0f2\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA224\", pwd, 336,\n+                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\" +\n+                    \"7daa2119fee8c64aef7c1f4c1871724e0ea628577e0ab54fa7c6\"),\n+            pbkdf2WithHmacSHA256Data,\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA384\", pwd, 576,\n+                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\" +\n+                    \"d7d0ad3a18912086f80d974f2acc2efba52650d4bf872455820f24c8\" +\n+                    \"46742161da84a1b4c3f197f4347308e8841a8971cf686aef29107396\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA512\", pwd, 768,\n+                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\" +\n+                    \"7e3077595f90b60ab96d4f29203927b00aa1a11e4d19d4f275a7f453\" +\n+                    \"14be500dacc3c1de9f704827b396463ccaa8957344d41bd64d9d09ff\" +\n+                    \"474e776469d326b1ee6ee5a5d854b86d3d7a25084afd6d6f\"),\n+            p12PBKDAssertionData(\"HmacPBESHA512\", emptyPwd, 512, \"SHA-512\",\n+                    128, \"90b6e088490c6c5e6b6e81209bd769d27df3868cae79591577a\" +\n+                    \"c35b46e4c6ebcc4b90f4943e3cb165f9d1789d938235f4b35ba74df9\" +\n+                    \"e509fbbb7aa329a432445\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_256\", emptyPwd, 256,\n+                    \"PBKDF2WithHmacSHA512\", \"3a5c5fd11e4d381b32e11baa93d7b128\" +\n+                    \"09e016e48e0542c5d3453fc240a0fa76\"),\n+    };\n+\n+    public void main(Provider sunPKCS11) throws Exception {\n+        System.out.println(\"SunPKCS11: \" + sunPKCS11.getName());\n+\n+        \/\/ Test valid cases.\n+        for (Configuration conf : Configuration.values()) {\n+            for (AssertionData data : assertionData) {\n+                testValidWith(sunPKCS11, data, conf);\n+            }\n+        }\n+\n+        \/\/ Test invalid cases.\n+        testInvalidTranslateKey(sunPKCS11);\n+        testInvalidGenerateSecret(sunPKCS11);\n+        testInvalidGetKeySpec(sunPKCS11);\n+\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    private static void testValidWith(Provider sunPKCS11, AssertionData data,\n+            Configuration conf) throws Exception {\n+        System.out.println(sep + System.lineSeparator() + data.algo\n+                + \" (with \" + conf.name() + \")\");\n+\n+        SecretKeyFactory skf = SecretKeyFactory.getInstance(data.algo,\n+                sunPKCS11);\n+        SecretKey derivedKey = switch (conf) {\n+            case PBEKeySpec -> skf.generateSecret(data.keySpec);\n+            case AnonymousPBEKey -> skf.translateKey(getAnonymousPBEKey(\n+                    data.algo, data.keySpec));\n+        };\n+        BigInteger derivedKeyValue = i(derivedKey.getEncoded());\n+        printHex(\"Derived Key\", derivedKeyValue);\n+\n+        if (!derivedKeyValue.equals(data.expectedKey)) {\n+            printHex(\"Expected Derived Key\", data.expectedKey);\n+            throw new Exception(\"Expected Derived Key did not match\");\n+        }\n+\n+        if (skf.translateKey(derivedKey) != derivedKey) {\n+            throw new Exception(\"SecretKeyFactory::translateKey must return \" +\n+                    \"the same key when a P11PBEKey from the same token is \" +\n+                    \"passed\");\n+        }\n+\n+        testGetKeySpec(data, skf, derivedKey);\n+        if (sunJCE != null && data.algo.startsWith(\"PBKDF2\")) {\n+            testTranslateP11PBEKeyToSunJCE(data.algo, (PBEKey) derivedKey);\n+        }\n+    }\n+\n+    private static SecretKey getAnonymousPBEKey(String algorithm,\n+            PBEKeySpec keySpec) {\n+        return new PBEKey() {\n+            public byte[] getSalt() { return keySpec.getSalt(); }\n+            public int getIterationCount() {\n+                return keySpec.getIterationCount();\n+            }\n+            public String getAlgorithm() { return algorithm; }\n+            public String getFormat() { return \"RAW\"; }\n+            public char[] getPassword() { return keySpec.getPassword(); }\n+            public byte[] getEncoded() {\n+                return new byte[keySpec.getKeyLength() \/ 8];\n+            }\n+        };\n+    }\n+\n+    private static void printHex(String title, BigInteger b) {\n+        String repr = (b == null) ? \"buffer is null\" : b.toString(16);\n+        System.out.println(title + \": \" + repr + System.lineSeparator());\n+    }\n+\n+    private static void testGetKeySpec(AssertionData data,\n+            SecretKeyFactory skf, SecretKey derivedKey) throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"SecretKeyFactory::getKeySpec() (for \" + data.algo + \")\");\n+        KeySpec skfKeySpec = skf.getKeySpec(derivedKey, PBEKeySpec.class);\n+        if (skfKeySpec instanceof PBEKeySpec skfPBEKeySpec) {\n+            char[] specPassword = skfPBEKeySpec.getPassword();\n+            byte[] specSalt = skfPBEKeySpec.getSalt();\n+            int specIterations = skfPBEKeySpec.getIterationCount();\n+            int specKeyLength = skfPBEKeySpec.getKeyLength();\n+            System.out.println(\"  spec key length (bits): \" + specKeyLength);\n+            System.out.println(\"           spec password: \"\n+                    + String.valueOf(specPassword));\n+            System.out.println(\"    spec iteration count: \" + specIterations);\n+            printHex(\"               spec salt\", i(specSalt));\n+\n+            if (!Arrays.equals(specPassword, data.keySpec.getPassword())) {\n+                throw new Exception(\"Password differs\");\n+            }\n+            if (!Arrays.equals(specSalt, data.keySpec.getSalt())) {\n+                throw new Exception(\"Salt differs\");\n+            }\n+            if (specIterations != data.keySpec.getIterationCount()) {\n+                throw new Exception(\"Iteration count differs\");\n+            }\n+            if (specKeyLength != data.keySpec.getKeyLength()) {\n+                throw new Exception(\"Key length differs\");\n+            }\n+        } else {\n+            throw new Exception(\"Invalid key spec type: \" + skfKeySpec);\n+        }\n+\n+        \/\/ Test extracting key bytes with a SecretKeySpec.\n+        SecretKeySpec secretKeySpec = (SecretKeySpec)\n+                skf.getKeySpec(derivedKey, SecretKeySpec.class);\n+        if (!Arrays.equals(secretKeySpec.getEncoded(),\n+                derivedKey.getEncoded())) {\n+            throw new Exception(\"Unable to extract key bytes with a \" +\n+                    \"SecretKeySpec\");\n+        }\n+    }\n+\n+    private static void testTranslateP11PBEKeyToSunJCE(String algorithm,\n+            PBEKey p11PbeK) throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"Translate P11PBEKey to SunJCE (for \" + algorithm + \")\");\n+        SecretKey jceK = SecretKeyFactory.getInstance(algorithm, sunJCE)\n+                .translateKey(p11PbeK);\n+        BigInteger jceEncoded = i(jceK.getEncoded());\n+        printHex(\"    translated to SunJCE\", jceEncoded);\n+        if (jceK instanceof PBEKey jcePbeK) {\n+            if (!Arrays.equals(jcePbeK.getPassword(), p11PbeK.getPassword())) {\n+                throw new Exception(\"Password differs\");\n+            }\n+            if (!Arrays.equals(jcePbeK.getSalt(), p11PbeK.getSalt())) {\n+                throw new Exception(\"Salt differs\");\n+            }\n+            if (jcePbeK.getIterationCount() != p11PbeK.getIterationCount()) {\n+                throw new Exception(\"Iteration count differs\");\n+            }\n+            if (!jceEncoded.equals(i(p11PbeK.getEncoded()))) {\n+                throw new Exception(\"Encoded key differs\");\n+            }\n+        } else {\n+            throw new Exception(\"Unexpected key type for SunJCE key: \"\n+                    + jceK.getClass().getName());\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface Action {\n+        void run() throws Exception;\n+    }\n+\n+    private static void assertThrows(Class<?> expectedExc, String expectedMsg,\n+            Action action) throws Exception {\n+        String shtExpected = \"Should have thrown '\"\n+                + expectedExc.getSimpleName() + \": \" + expectedMsg + \"'\";\n+        try {\n+            action.run();\n+        } catch (Exception e) {\n+            if (expectedExc.isAssignableFrom(e.getClass()) &&\n+                    e.getMessage().equals(expectedMsg)) {\n+                return;\n+            }\n+            e.printStackTrace();\n+            throw new Exception(shtExpected + \", but threw '\" +\n+                    e.getClass().getSimpleName() + \": \" + e.getMessage() + \"'\");\n+        }\n+        throw new Exception(shtExpected + \", but it didn't throw\");\n+    }\n+\n+    private static void testInvalidTranslateKey(Provider sunPKCS11)\n+            throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"Invalid SecretKeyFactory::translateKey tests\");\n+\n+        SecretKeyFactory skf1 = SecretKeyFactory.getInstance(\n+                hmacPBESHA1Data.algo, sunPKCS11);\n+        SecretKeyFactory skf2 = SecretKeyFactory.getInstance(\"AES\", sunPKCS11);\n+        SecretKeyFactory skf3 = SecretKeyFactory.getInstance(\n+                pbkdf2WithHmacSHA256Data.algo, sunPKCS11);\n+        PBEKey p11PbeKey = (PBEKey) skf1.translateKey(getAnonymousPBEKey(\n+                skf1.getAlgorithm(), hmacPBESHA1Data.keySpec));\n+        Class<?> e = InvalidKeyException.class;\n+\n+        System.out.println(\" * Non-PBEKey key to PBE SecretKeyFactory\");\n+        assertThrows(e, \"PBE service requires a PBE key\",\n+                () -> skf1.translateKey(new SecretKeySpec(\n+                        new byte[10], hmacPBESHA1Data.algo)));\n+\n+        System.out.println(\" * PBEKey key to PBE SecretKeyFactory of a \" +\n+                \"different algorithm\");\n+        assertThrows(e, \"Cannot use a \" + hmacPBESHA1Data.algo + \" key for a \" +\n+                hmacPBESHA224Data.algo + \" service\",\n+                () -> SecretKeyFactory.getInstance(hmacPBESHA224Data.algo,\n+                        sunPKCS11).translateKey(p11PbeKey));\n+\n+        System.out.println(\" * Non-AES PBEKey key to AES SecretKeyFactory\");\n+        assertThrows(e, \"Cannot use a \" + hmacPBESHA1Data.algo + \" key for a \" +\n+                skf2.getAlgorithm() + \" service\",\n+                () -> skf2.translateKey(p11PbeKey));\n+\n+        System.out.println(\" * Inconsistent key length between key and \" +\n+                \"algorithm\");\n+        PBEKeySpec kSpec1 = new PBEKeySpec(pwd, salt, 1, 16);\n+        assertThrows(e, InvalidKeySpecException.class.getName() + \": Key \" +\n+                \"length is invalid for \" + skf1.getAlgorithm() + \" (expecting\" +\n+                \" \" + hmacPBESHA1Data.keySpec.getKeyLength() + \" but was \" +\n+                kSpec1.getKeyLength() + \")\",\n+                () -> skf1.translateKey(getAnonymousPBEKey(\n+                        skf1.getAlgorithm(), kSpec1)));\n+\n+        System.out.println(\" * Invalid key length in bits\");\n+        PBEKeySpec kSpec2 = new PBEKeySpec(pwd, salt, 1);\n+        assertThrows(e, InvalidKeySpecException.class.getName() + \": Key \" +\n+                \"length must be multiple of 8 and greater than zero\",\n+                () -> skf3.translateKey(getAnonymousPBEKey(\n+                        skf3.getAlgorithm(), kSpec2)));\n+\n+        System.out.println();\n+    }\n+\n+    private static void testInvalidGenerateSecret(Provider sunPKCS11)\n+            throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"Invalid SecretKeyFactory::generateSecret tests\");\n+\n+        SecretKeyFactory skf1 = SecretKeyFactory.getInstance(\n+                hmacPBESHA1Data.algo, sunPKCS11);\n+        SecretKeyFactory skf2 = SecretKeyFactory.getInstance(\n+                pbeWithHmacSHA512AndAES256Data.algo, sunPKCS11);\n+        SecretKeyFactory skf3 = SecretKeyFactory.getInstance(\n+                \"PBKDF2WithHmacSHA512\", sunPKCS11);\n+        SecretKeyFactory skf4 = SecretKeyFactory.getInstance(\"AES\", sunPKCS11);\n+        Class<?> e = InvalidKeySpecException.class;\n+\n+        System.out.println(\" * Missing salt and iteration count\");\n+        assertThrows(e, \"Salt not found\",\n+                () -> skf1.generateSecret(new PBEKeySpec(pwd)));\n+\n+        System.out.println(\" * Inconsistent key length between spec and \" +\n+                \"algorithm\");\n+        PBEKeySpec kSpec = new PBEKeySpec(pwd, salt, 1, 16);\n+        assertThrows(e, \"Key length is invalid for \" + skf1.getAlgorithm() +\n+                \" (expecting \" + hmacPBESHA1Data.keySpec.getKeyLength() +\n+                \" but was \" + kSpec.getKeyLength() + \")\",\n+                () -> skf1.generateSecret(kSpec));\n+        assertThrows(e, \"Key length is invalid for \" + skf2.getAlgorithm() +\n+                \" (expecting \" + pbeWithHmacSHA512AndAES256Data.keySpec\n+                .getKeyLength() + \" but was \" + kSpec.getKeyLength() + \")\",\n+                () -> skf2.generateSecret(kSpec));\n+\n+        System.out.println(\" * Invalid key length in bits\");\n+        String msg = \"Key length must be multiple of 8 and greater than zero\";\n+        assertThrows(e, msg,\n+                () -> skf3.generateSecret(new PBEKeySpec(pwd, salt, 1)));\n+        assertThrows(e, msg,\n+                () -> skf3.generateSecret(new PBEKeySpec(pwd, salt, 1, 3)));\n+\n+        System.out.println(\" * PBEKeySpec to non-PBE SecretKeyFactory\");\n+        assertThrows(e, \"Unsupported spec: javax.crypto.spec.PBEKeySpec\",\n+                () -> skf4.generateSecret(kSpec));\n+\n+        System.out.println();\n+    }\n+\n+    private static void testInvalidGetKeySpec(Provider sunPKCS11)\n+            throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"Invalid SecretKeyFactory::getKeySpec tests\");\n+\n+        SecretKeyFactory skf1 = SecretKeyFactory.getInstance(\n+                hmacPBESHA1Data.algo, sunPKCS11);\n+        SecretKeyFactory skf2 = SecretKeyFactory.getInstance(\n+                \"AES\", sunPKCS11);\n+        PBEKey p11PbeKey = (PBEKey) skf1.translateKey(getAnonymousPBEKey(\n+                skf1.getAlgorithm(), hmacPBESHA1Data.keySpec));\n+        Class<?> e = InvalidKeySpecException.class;\n+\n+        System.out.println(\" * null KeySpec class\");\n+        assertThrows(e, \"key and keySpec must not be null\",\n+                () -> skf1.getKeySpec(p11PbeKey, null));\n+\n+        System.out.println(\" * Invalid key type for PBEKeySpec\");\n+        assertThrows(e, \"Unsupported spec: \" + PBEKeySpec.class.getName(),\n+                () -> skf1.getKeySpec(new SecretKeySpec(new byte[16],\n+                        skf1.getAlgorithm()), PBEKeySpec.class));\n+\n+        System.out.println(\" * Invalid PBE key and PBEKeySpec for \" +\n+                skf2.getAlgorithm() + \" SecretKeyFactory\");\n+        assertThrows(e, \"Unsupported spec: \" + PBEKeySpec.class.getName(),\n+                () -> skf2.getKeySpec(p11PbeKey, PBEKeySpec.class));\n+\n+        System.out.println();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestPBKD());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/SecretKeyFactory\/TestPBKD.java","additions":515,"deletions":0,"binary":false,"changes":515,"status":"added"}]}