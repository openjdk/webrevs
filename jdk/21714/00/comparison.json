{"files":[{"patch":"@@ -1698,0 +1698,8 @@\n+  if (use->Opcode() == Op_AddX) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == Op_CastX2P) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+package compiler.c2;\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.internal.misc.Unsafe;\n+\n+\/*\n+ * @test\n+ * @bug 8343068\n+ * @summary C2: CastX2P Ideal transformation not always applied\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestCastX2NotProcessedIGVN\n+ *\/\n+\n+public class TestCastX2NotProcessedIGVN {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static int size = 1024;\n+    static long base = UNSAFE.allocateMemory(4 * size);\n+\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L, counts = {IRNode.ADD_P, \"1\"})\n+    public static byte test1(long base) {\n+        int offset = 0;\n+        do {\n+            offset++;\n+        } while (offset < 100);\n+        long longOffset = ((long) offset) * 2;\n+        return UNSAFE.getByte(null, base + longOffset);\n+    }\n+\n+    @Run(test = \"test1\")\n+    public static void test1Runner() {\n+        test1(base);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 1\"})\n+    public static int test2(int stop, int[] array) {\n+        int v = 0;\n+        stop = Math.min(stop, Integer.MAX_VALUE \/ 4);\n+        for (int i = 0; i < stop; i++) {\n+            long offset = ((long)i) * 4;\n+            array[i] = UNSAFE.getInt(null, offset + base);\n+        }\n+        return v;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public static void test2Runner() {\n+        test2(size, new int[size]);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCastX2NotProcessedIGVN.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -222,0 +222,5 @@\n+    public static final String ADD_P = PREFIX + \"ADD_P\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_P, \"AddP\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}