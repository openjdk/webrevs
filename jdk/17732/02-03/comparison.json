{"files":[{"patch":"@@ -442,0 +442,26 @@\n+\n+    \/**\n+     * Attempt to add key to map if absent.\n+     *\n+     * @param setMap    {@link ReferencedKeyMap} where interning takes place\n+     * @param key       key to add\n+     *\n+     * @param <T> type of key\n+     *\n+     * @return true if the key was added\n+     *\/\n+    static <T> boolean internAddKey(ReferencedKeyMap<T, ReferenceKey<T>> setMap, T key) {\n+        ReferenceKey<T> entryKey = setMap.entryKey(key);\n+        setMap.removeStaleReferences();\n+        ReferenceKey<T> existing = setMap.map.putIfAbsent(entryKey, entryKey);\n+        if (existing == null) {\n+            return true;\n+        } else {\n+            \/\/ If {@code putIfAbsent} returns non-null then was actually a\n+            \/\/ {@code replace} and older key was used. In that case the new\n+            \/\/ key was not used and the reference marked stale.\n+            entryKey.unused();\n+            return false;\n+        }\n+     }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-        return intern(e) == e;\n+        return ReferencedKeyMap.internAddKey(map, e);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeySet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-        Long value1 = new Long(BASE_KEY + 999);\n-        Long value2 = new Long(BASE_KEY + 999);\n+        Long value1 = Long.valueOf(BASE_KEY + 999);\n+        Long value2 = Long.valueOf(BASE_KEY + 999);\n@@ -134,1 +134,1 @@\n-        assertTrue(set.add(value1), \"key not added after second attempt\");\n+        assertTrue(!set.add(value1), \"key added after second attempt\");\n","filename":"test\/jdk\/jdk\/internal\/util\/ReferencedKeyTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}