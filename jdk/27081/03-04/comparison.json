{"files":[{"patch":"@@ -36,0 +36,2 @@\n+import javax.crypto.spec.SecretKeySpec;\n+import java.lang.foreign.MemorySegment;\n@@ -37,0 +39,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -39,1 +42,1 @@\n-import java.util.Objects;\n+import java.util.HexFormat;\n@@ -44,0 +47,15 @@\n+    private static final HexFormat HEX = HexFormat.of();\n+\n+    private static final byte[] TEST_KEY_BYTES = HEX.parseHex(\n+            \"3cb1283912536e4108c3094dc2940d0d020afbd7701de267bbfb359bc7d54dd7\");\n+    private static final byte[] TEST_NONCE_BYTES = HEX.parseHex(\n+            \"9bd647a43b6fa7826e2cc26d\");\n+    private static final byte[] TEST_AAD_BYTES =\n+            \"This is a bunch of additional data to throw into the mix.\".\n+                    getBytes(StandardCharsets.UTF_8);\n+    private static final byte[] TEST_INPUT_BYTES =\n+        \"This is a plaintext message\".getBytes(StandardCharsets.UTF_8);\n+    private static final byte[] TEST_CT_BYTES = HEX.parseHex(\n+            \"8536c999809f4b9d6a1594ee1084c751d1bd8a991e6a4b4ac26386f04b9a1303\" +\n+            \"f40cbe6788d72af2d0c617\");\n+    private static final ByteBuffer EXPOUTBUF = ByteBuffer.wrap(TEST_CT_BYTES);\n@@ -55,0 +73,4 @@\n+    public interface TestAction {\n+        void runTest(ByteBuffer buffer);\n+    }\n+\n@@ -63,1 +85,1 @@\n-        new AADUpdateTest(twoKBuf, true).run();\n+        aadUpdateTest.runTest(twoKBuf);\n@@ -68,1 +90,1 @@\n-        new AADUpdateTest(twoKBuf.position(395), true).run();\n+        aadUpdateTest.runTest(twoKBuf.position(395));\n@@ -74,1 +96,1 @@\n-        new AADUpdateTest(nonBABuf.position(602), true).run();\n+        aadUpdateTest.runTest(nonBABuf.position(602));\n@@ -80,2 +102,1 @@\n-        new AADUpdateTest(twoKBuf.rewind().slice(1024,1024).position(42),\n-                true).run();\n+        aadUpdateTest.runTest(twoKBuf.rewind().slice(1024,1024).position(42));\n@@ -86,2 +107,38 @@\n-        new AADUpdateTest(nonBABuf.rewind().slice(347, 347).position(86),\n-                true).run();\n+        aadUpdateTest.runTest(nonBABuf.rewind().slice(347, 347).position(86));\n+\n+        System.out.println(\"----- Test 6: MemorySegment Buffer -----\");\n+        System.out.println(\"Make a ByteBuffer from an array-backed \" +\n+                           \"MemorySegment, and try updating\");\n+        MemorySegment mseg = MemorySegment.ofArray(new byte[2048]);\n+        ByteBuffer msegBuf = mseg.asByteBuffer();\n+        aadUpdateTest.runTest(msegBuf.position(55));\n+\n+        System.out.println(\"----- Test 7: Buffer of MemorySegment Slice -----\");\n+        System.out.println(\"Use a slice from the MemorySegment and create a \" +\n+                           \"buffer from that for testing\");\n+        MemorySegment msegSlice = mseg.asSlice(1024);\n+        aadUpdateTest.runTest(msegSlice.asByteBuffer().position(55));\n+\n+        System.out.println(\"----- Test 8: MemorySegment Buffer Slice -----\");\n+        System.out.println(\"Create a slice from the ByteBuffer from the \" +\n+                           \"original MemorySegment.\");\n+        aadUpdateTest.runTest(msegBuf.rewind().slice(1024, 1024));\n+\n+        System.out.println(\"Test vector processing\");\n+        System.out.println(\"----------------------\");\n+        System.out.println(\"----- Test 9: AAD + Plaintext on buffer ------\");\n+        System.out.println(\"Place the AAD, followed by plaintext and verify \" +\n+                           \"the ciphertext\");\n+        \/\/ Create a ByteBuffer where the AAD and plaintext actually sit\n+        \/\/ somewhere in the middle of the underlying array, with non-test-vector\n+        \/\/ memory on either side of the data.\n+        ByteBuffer vectorBuf = ByteBuffer.allocate(1024).position(600).\n+                put(TEST_AAD_BYTES).put(TEST_INPUT_BYTES).flip().position(600);\n+        vectorTest.runTest(vectorBuf);\n+\n+        System.out.println(\"----- Test 10: AAD + Plaintext on slice -----\");\n+        System.out.println(\"Perform the same test, this time on a slice\" +\n+                           \"of the test vector buffer\");\n+        ByteBuffer vectorSlice = vectorBuf.slice(600,\n+                TEST_AAD_BYTES.length + TEST_INPUT_BYTES.length);\n+        vectorTest.runTest(vectorSlice);\n@@ -90,22 +147,18 @@\n-    public static class AADUpdateTest implements Runnable {\n-        private final ByteBuffer buffer;\n-        private final boolean expectedPass;\n-\n-        AADUpdateTest(ByteBuffer buf, boolean expPass) {\n-            buffer = Objects.requireNonNull(buf);\n-            expectedPass = expPass;\n-        }\n-\n-        @Override\n-        public void run() {\n-            Cipher cipher;\n-            try {\n-                SecretKey key = CC20GEN.generateKey();\n-                byte[] nonce = new byte[12];\n-                RAND.nextBytes(nonce);\n-\n-                cipher = Cipher.getInstance(\"ChaCha20-Poly1305\");\n-                cipher.init(Cipher.ENCRYPT_MODE, key,\n-                        new IvParameterSpec(nonce));\n-            } catch (GeneralSecurityException gse) {\n-                throw new RuntimeException(\"Failed during test setup\", gse);\n+    \/\/ Simple test callback for taking a ByteBuffer and throwing all\n+    \/\/ remaining bytes into an updateAAD call.\n+    public static TestAction aadUpdateTest = buffer -> {\n+        try {\n+            SecretKey key = CC20GEN.generateKey();\n+            byte[] nonce = new byte[12];\n+            RAND.nextBytes(nonce);\n+\n+            Cipher cipher = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+            cipher.init(Cipher.ENCRYPT_MODE, key,\n+                    new IvParameterSpec(nonce));\n+\n+            cipher.updateAAD(buffer);\n+            \/\/ Per the API the buffer's position and limit should be equal\n+            if (buffer.position() != buffer.limit()) {\n+                throw new RuntimeException(\"Buffer position and limit \" +\n+                        \"should be equal but are not: p = \" +\n+                        buffer.position() + \", l = \" + buffer.limit());\n@@ -113,0 +166,4 @@\n+        } catch (GeneralSecurityException gse) {\n+            throw new RuntimeException(\"Failed during test setup\", gse);\n+        }\n+    };\n@@ -114,17 +171,20 @@\n-            try {\n-                cipher.updateAAD(buffer);\n-                \/\/ Per the API the buffer's position and limit should be equal\n-                if (buffer.position() != buffer.limit()) {\n-                    throw new RuntimeException(\"Buffer position and limit \" +\n-                            \"should be equal but are not: p = \" +\n-                            buffer.position() + \", l = \" + buffer.limit());\n-                }\n-                if (!expectedPass) {\n-                    throw new RuntimeException(\n-                            \"Expected failing test did not throw exception\");\n-                }\n-            } catch (Exception exc) {\n-                if (expectedPass) {\n-                    throw new RuntimeException(\n-                            \"FAIL: Expected passing test failed\", exc);\n-                }\n+    \/\/ Test callback for making sure that the updateAAD method, when\n+    \/\/ put in with a complete encryption operation still gets the\n+    \/\/ expected answer.\n+    public static TestAction vectorTest = buffer -> {\n+        try {\n+            Cipher cipher = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+            cipher.init(Cipher.ENCRYPT_MODE,\n+                    new SecretKeySpec(TEST_KEY_BYTES, \"ChaCha20\"),\n+                    new IvParameterSpec(TEST_NONCE_BYTES));\n+            ByteBuffer outbuf = ByteBuffer.allocate(\n+                    cipher.getOutputSize(TEST_INPUT_BYTES.length));\n+\n+            \/\/ Adjust the limit to be the end of the aad\n+            int origLim = buffer.limit();\n+            buffer.limit(buffer.position() + TEST_AAD_BYTES.length);\n+            cipher.updateAAD(buffer);\n+            buffer.limit(origLim);\n+            cipher.doFinal(buffer, outbuf);\n+            if (!outbuf.flip().equals(EXPOUTBUF)) {\n+                throw new RuntimeException(\"Output data mismatch\");\n@@ -132,0 +192,2 @@\n+        } catch (GeneralSecurityException gse) {\n+            throw new RuntimeException(\"Failed during test setup\", gse);\n@@ -133,1 +195,1 @@\n-    }\n+    };\n@@ -135,1 +197,0 @@\n-\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/UpdateAADTest.java","additions":110,"deletions":49,"binary":false,"changes":159,"status":"modified"}]}