{"files":[{"patch":"@@ -2126,1 +2126,1 @@\n-void os::abort(bool dump_core, void* siginfo, const void* context) {\n+void os::abort(bool dump_core, const void* siginfo, const void* context) {\n@@ -2201,0 +2201,40 @@\n+\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+static ucontext_t _saved_assert_context;\n+static bool _has_saved_context = false;\n+#endif \/\/ CAN_SHOW_REGISTERS_ON_ASSERT\n+\n+void os::save_assert_context(const void* ucVoid) {\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  assert(ucVoid != nullptr, \"invariant\");\n+  assert(!_has_saved_context, \"invariant\");\n+  memcpy(&_saved_assert_context, ucVoid, sizeof(ucontext_t));\n+  \/\/ on Linux ppc64, ucontext_t contains pointers into itself which have to be patched up\n+  \/\/  after copying the context (see comment in sys\/ucontext.h):\n+#if defined(PPC64)\n+  *((void**)&_saved_assert_context.uc_mcontext.regs) = &(_saved_assert_context.uc_mcontext.gp_regs);\n+#elif defined(AMD64)\n+  \/\/ In the copied version, fpregs should point to the copied contents.\n+  \/\/ Sanity check: fpregs should point into the context.\n+  if ((address)((const ucontext_t*)ucVoid)->uc_mcontext.fpregs > (address)ucVoid) {\n+    size_t fpregs_offset = pointer_delta(((const ucontext_t*)ucVoid)->uc_mcontext.fpregs, ucVoid, 1);\n+    if (fpregs_offset < sizeof(ucontext_t)) {\n+      \/\/ Preserve the offset.\n+      *((void**)&_saved_assert_context.uc_mcontext.fpregs) = (void*)((address)(void*)&_saved_assert_context + fpregs_offset);\n+    }\n+  }\n+#endif\n+  _has_saved_context = true;\n+#endif \/\/ CAN_SHOW_REGISTERS_ON_ASSERT\n+}\n+\n+const void* os::get_saved_assert_context(const void** sigInfo) {\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  assert(sigInfo != nullptr, \"invariant\");\n+  *sigInfo = nullptr;\n+  return _has_saved_context ? &_saved_assert_context : nullptr;\n+#endif\n+  *sigInfo = nullptr;\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -581,3 +581,2 @@\n-  if (!signal_was_handled &&\n-      ((sig == SIGSEGV || sig == SIGBUS) && info != nullptr && info->si_addr == g_assert_poison)) {\n-    signal_was_handled = handle_assert_poison_fault(ucVoid, info->si_addr);\n+  if (VMError::was_assert_poison_crash(info)) {\n+    signal_was_handled = handle_assert_poison_fault(ucVoid);\n@@ -1139,0 +1138,8 @@\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  \/\/ If we are here because of an assert\/guarantee, we suppress\n+  \/\/ printing the siginfo, because it is only an implementation\n+  \/\/ detail capturing the context for said assert\/guarantee.\n+  if (VMError::was_assert_poison_crash(si0)) {\n+    return;\n+  }\n+#endif\n@@ -1140,1 +1147,1 @@\n-  const siginfo_t* const si = (const siginfo_t*) si0;\n+  const siginfo_t* const si = (const siginfo_t*)si0;\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-  if ((sig == SIGSEGV || sig == SIGBUS) && info != nullptr && info->si_addr == g_assert_poison) {\n-    if (handle_assert_poison_fault(context, info->si_addr)) {\n+  if (VMError::was_assert_poison_crash(info)) {\n+    if (handle_assert_poison_fault(context)) {\n@@ -130,0 +130,11 @@\n+\n+bool VMError::was_assert_poison_crash(const void* siginfo) {\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  if (siginfo == nullptr) {\n+    return false;\n+  }\n+  const siginfo_t* const si = (siginfo_t*)siginfo;\n+  return (si->si_signo == SIGSEGV || si->si_signo == SIGBUS) && si->si_addr == g_assert_poison_read_only;\n+#endif\n+  return false;\n+}\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -1336,1 +1337,1 @@\n-void os::abort(bool dump_core, void* siginfo, const void* context) {\n+void os::abort(bool dump_core, const void* siginfo, const void* context) {\n@@ -2142,0 +2143,9 @@\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  \/\/ If we are here because of an assert\/guarantee, we suppress\n+  \/\/ printing the siginfo, because it is only an implementation\n+  \/\/ detail capturing the context for said assert\/guarantee.\n+  if (VMError::was_assert_poison_crash(siginfo)) {\n+    return;\n+  }\n+#endif\n+\n@@ -2143,0 +2153,1 @@\n+\n@@ -2787,0 +2798,8 @@\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  if (VMError::was_assert_poison_crash(exception_record)) {\n+    if (handle_assert_poison_fault(exceptionInfo)) {\n+      return EXCEPTION_CONTINUE_EXECUTION;\n+    }\n+  }\n+#endif\n+\n@@ -6488,0 +6507,23 @@\n+\n+static CONTEXT _saved_assert_context;\n+static EXCEPTION_RECORD _saved_exception_record;\n+static bool _has_saved_context = false;\n+\n+void os::save_assert_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  assert(!_has_saved_context, \"invariant\");\n+  const EXCEPTION_POINTERS* ep = static_cast<const EXCEPTION_POINTERS*>(ucVoid);\n+  memcpy(&_saved_assert_context, ep->ContextRecord, sizeof(CONTEXT));\n+  memcpy(&_saved_exception_record, ep->ExceptionRecord, sizeof(EXCEPTION_RECORD));\n+  _has_saved_context = true;\n+}\n+\n+const void* os::get_saved_assert_context(const void** sigInfo) {\n+  assert(sigInfo != nullptr, \"invariant\");\n+  if (_has_saved_context) {\n+    *sigInfo = &_saved_exception_record;\n+    return &_saved_assert_context;\n+  }\n+  *sigInfo = nullptr;\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -70,1 +71,1 @@\n-void VMError::raise_fail_fast(void* exrecord, void* context) {\n+void VMError::raise_fail_fast(const void* exrecord, const void* context) {\n@@ -72,3 +73,3 @@\n-  RaiseFailFastException(static_cast<PEXCEPTION_RECORD>(exrecord),\n-                         static_cast<PCONTEXT>(context),\n-                         flags);\n+  PEXCEPTION_RECORD exception_record = static_cast<PEXCEPTION_RECORD>(const_cast<void*>(exrecord));\n+  PCONTEXT ctx = static_cast<PCONTEXT>(const_cast<void*>(context));\n+  RaiseFailFastException(exception_record, ctx, flags);\n@@ -77,0 +78,13 @@\n+\n+bool VMError::was_assert_poison_crash(const void* siginfo) {\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  if (siginfo == nullptr) {\n+    return false;\n+  }\n+  const EXCEPTION_RECORD* const er = (EXCEPTION_RECORD*)siginfo;\n+  if (er->ExceptionCode == EXCEPTION_ACCESS_VIOLATION && er->NumberParameters >= 2) {\n+    return (void*)er->ExceptionInformation[1] == g_assert_poison_read_only;\n+  }\n+#endif\n+  return false;\n+}\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -620,0 +620,4 @@\n+  \/\/ For saving an os specific context generated by an assert or guarantee.\n+  static void       save_assert_context(const void* ucVoid);\n+  static const void* get_saved_assert_context(const void** sigInfo);\n+\n@@ -646,1 +650,1 @@\n-  [[noreturn]] static void abort(bool dump_core, void *siginfo, const void *context);\n+  [[noreturn]] static void abort(bool dump_core, const void *siginfo, const void *context);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+const char* g_assert_poison_read_only = &g_dummy;\n@@ -78,1 +79,0 @@\n-static void* g_assertion_context = nullptr;\n@@ -184,1 +184,6 @@\n-  void* context = nullptr;\n+\n+  print_error_for_unit_test(error_msg, detail_fmt, detail_args);\n+\n+  const void* context = nullptr;\n+  const void* siginfo = nullptr;\n+\n@@ -186,2 +191,2 @@\n-  if (g_assertion_context != nullptr && os::current_thread_id() == g_asserting_thread) {\n-    context = g_assertion_context;\n+  if (os::current_thread_id() == g_asserting_thread) {\n+    context = os::get_saved_assert_context(&siginfo);\n@@ -191,3 +196,3 @@\n-  print_error_for_unit_test(error_msg, detail_fmt, detail_args);\n-\n-  VMError::report_and_die(Thread::current_or_null(), context, file, line, error_msg, detail_fmt, detail_args);\n+  VMError::report_and_die(INTERNAL_ERROR, error_msg, detail_fmt, detail_args,\n+                          Thread::current_or_null(), nullptr, siginfo, context,\n+                          file, line, 0);\n@@ -205,1 +210,7 @@\n-  void* context = nullptr;\n+\n+\n+  print_error_for_unit_test(\"fatal error\", detail_fmt, detail_args);\n+\n+  const void* context = nullptr;\n+  const void* siginfo = nullptr;\n+\n@@ -207,2 +218,2 @@\n-  if (g_assertion_context != nullptr && os::current_thread_id() == g_asserting_thread) {\n-    context = g_assertion_context;\n+  if (os::current_thread_id() == g_asserting_thread) {\n+    context = os::get_saved_assert_context(&siginfo);\n@@ -212,2 +223,0 @@\n-  print_error_for_unit_test(\"fatal error\", detail_fmt, detail_args);\n-\n@@ -215,1 +224,1 @@\n-                          Thread::current_or_null(), nullptr, nullptr, context,\n+                          Thread::current_or_null(), nullptr, siginfo, context,\n@@ -708,3 +717,0 @@\n-\n-static ucontext_t g_stored_assertion_context;\n-\n@@ -718,0 +724,1 @@\n+      g_assert_poison_read_only = page;\n@@ -726,25 +733,0 @@\n-static void store_context(const void* context) {\n-  memcpy(&g_stored_assertion_context, context, sizeof(ucontext_t));\n-#if defined(LINUX)\n-  \/\/ on Linux ppc64, ucontext_t contains pointers into itself which have to be patched up\n-  \/\/  after copying the context (see comment in sys\/ucontext.h):\n-#if defined(PPC64)\n-  *((void**) &g_stored_assertion_context.uc_mcontext.regs) = &(g_stored_assertion_context.uc_mcontext.gp_regs);\n-#elif defined(AMD64)\n-  \/\/ In the copied version, fpregs should point to the copied contents.\n-  \/\/ Sanity check: fpregs should point into the context.\n-  if ((address)((const ucontext_t*)context)->uc_mcontext.fpregs > (address)context) {\n-    size_t fpregs_offset = pointer_delta(((const ucontext_t*)context)->uc_mcontext.fpregs, context, 1);\n-    if (fpregs_offset < sizeof(ucontext_t)) {\n-      \/\/ Preserve the offset.\n-      *((void**) &g_stored_assertion_context.uc_mcontext.fpregs) = (void*)((address)(void*)&g_stored_assertion_context + fpregs_offset);\n-    }\n-  }\n-#endif\n-#endif\n-}\n-\n-bool handle_assert_poison_fault(const void* ucVoid, const void* faulting_address) {\n-  if (faulting_address == g_assert_poison) {\n-    \/\/ Disarm poison page.\n-    if (os::protect_memory((char*)g_assert_poison, os::vm_page_size(), os::MEM_PROT_RWX) == false) {\n@@ -752,3 +734,5 @@\n-      fprintf(stderr, \"Assertion poison page cannot be unprotected - mprotect failed with %d (%s)\",\n-              errno, os::strerror(errno));\n-      fflush(stderr);\n+static void print_unprotect_error() {\n+  fprintf(stderr, \"Assertion poison page cannot be unprotected - mprotect failed with %d (%s)\",\n+          errno, os::strerror(errno));\n+  fflush(stderr);\n+}\n@@ -756,9 +740,14 @@\n-      return false; \/\/ unprotecting memory may fail in OOM situations, as surprising as this sounds.\n-    }\n-    \/\/ Store Context away.\n-    if (ucVoid) {\n-      const intx my_tid = os::current_thread_id();\n-      if (Atomic::cmpxchg(&g_asserting_thread, (intx)0, my_tid) == 0) {\n-        store_context(ucVoid);\n-        g_assertion_context = &g_stored_assertion_context;\n-      }\n+\n+\/\/ TOUCH_ASSERT_POISON writes to the protected g_assert_poison page, which faults\n+\/\/ and enters platform signal handlers which in turn invokes this routine.\n+bool handle_assert_poison_fault(const void* ucVoid) {\n+  \/\/ Disarm poison page.\n+  if (!os::protect_memory((char*)g_assert_poison, os::vm_page_size(), os::MEM_PROT_RWX)) {\n+    DEBUG_ONLY(print_unprotect_error();)\n+    return false; \/\/ unprotecting memory may fail in OOM situations, as surprising as this sounds.\n+  }\n+  if (ucVoid != nullptr) {\n+    \/\/ Save context.\n+    const intx my_tid = os::current_thread_id();\n+    if (Atomic::cmpxchg(&g_asserting_thread, (intx)0, my_tid) == 0) {\n+      os::save_assert_context(ucVoid);\n@@ -766,1 +755,0 @@\n-    return true;\n@@ -768,1 +756,1 @@\n-  return false;\n+  return true;\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":43,"deletions":55,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-\/\/ ShowRegistersOnAssert support (for now Linux only)\n-#if defined(LINUX) && !defined(ZERO)\n+\/\/ ShowRegistersOnAssert support (for now Linux and Windows only)\n+#if (defined(LINUX) || defined(_WINDOWS)) && !defined(ZERO)\n@@ -41,0 +41,1 @@\n+extern const char* g_assert_poison_read_only;\n@@ -44,1 +45,1 @@\n-bool handle_assert_poison_fault(const void* ucVoid, const void* faulting_address);\n+bool handle_assert_poison_fault(const void* ucVoid);\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -98,2 +98,2 @@\n-void*             VMError::_siginfo;\n-void*             VMError::_context;\n+const void*       VMError::_siginfo;\n+const void*       VMError::_context;\n@@ -535,1 +535,1 @@\n-static void print_stack_location(outputStream* st, void* context, int& continuation) {\n+static void print_stack_location(outputStream* st, const void* context, int& continuation) {\n@@ -1590,2 +1590,2 @@\n-void VMError::report_and_die(Thread* thread, unsigned int sig, address pc, void* siginfo,\n-                             void* context, const char* detail_fmt, ...)\n+void VMError::report_and_die(Thread* thread, unsigned int sig, address pc, const void* siginfo,\n+                             const void* context, const char* detail_fmt, ...)\n@@ -1599,1 +1599,1 @@\n-void VMError::report_and_die(Thread* thread, void* context, const char* filename, int lineno, const char* message,\n+void VMError::report_and_die(Thread* thread, const void* context, const char* filename, int lineno, const char* message,\n@@ -1607,1 +1607,1 @@\n-void VMError::report_and_die(Thread* thread, unsigned int sig, address pc, void* siginfo, void* context)\n+void VMError::report_and_die(Thread* thread, unsigned int sig, address pc, const void* siginfo, const void* context)\n@@ -1612,1 +1612,1 @@\n-void VMError::report_and_die(Thread* thread, void* context, const char* filename, int lineno, const char* message,\n+void VMError::report_and_die(Thread* thread, const void* context, const char* filename, int lineno, const char* message,\n@@ -1624,1 +1624,1 @@\n-                             Thread* thread, address pc, void* siginfo, void* context, const char* filename,\n+                             Thread* thread, address pc, const void* siginfo, const void* context, const char* filename,\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  static void*       _siginfo;          \/\/ ExceptionRecord on Windows,\n+  static const void* _siginfo;          \/\/ ExceptionRecord on Windows,\n@@ -51,1 +51,1 @@\n-  static void*       _context;          \/\/ ContextRecord on Windows,\n+  static const void* _context;          \/\/ ContextRecord on Windows,\n@@ -147,1 +147,1 @@\n-  WINDOWS_ONLY([[noreturn]] static void raise_fail_fast(void* exrecord, void* context);)\n+  WINDOWS_ONLY([[noreturn]] static void raise_fail_fast(const void* exrecord, const void* context);)\n@@ -169,2 +169,2 @@\n-  static void report_and_die(Thread* thread, unsigned int sig, address pc, void* siginfo,\n-                             void* context, const char* detail_fmt, ...);\n+  static void report_and_die(Thread* thread, unsigned int sig, address pc, const void* siginfo,\n+                             const void* context, const char* detail_fmt, ...);\n@@ -174,2 +174,2 @@\n-  static void report_and_die(Thread* thread, void* context, const char* filename, int lineno, const char* message,\n-                             const char* detail_fmt, ...);\n+  static void report_and_die(Thread* thread, const void* context, const char* filename,\n+                             int lineno, const char* message, const char* detail_fmt, ...);\n@@ -180,1 +180,1 @@\n-                             Thread* thread, address pc, void* siginfo, void* context,\n+                             Thread* thread, address pc, const void* siginfo, const void* context,\n@@ -185,1 +185,1 @@\n-                             void* siginfo, void* context);\n+                             const void* siginfo, const void* context);\n@@ -189,2 +189,2 @@\n-  static void report_and_die(Thread* thread, void* context, const char* filename, int lineno, const char* message,\n-                             const char* detail_fmt, va_list detail_args);\n+  static void report_and_die(Thread* thread, const void* context, const char* filename,\n+                             int lineno, const char* message, const char* detail_fmt, va_list detail_args);\n@@ -228,0 +228,1 @@\n+  static bool was_assert_poison_crash(const void* sigInfo);\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @requires (vm.debug == true) & (os.family == \"linux\")\n+ * @requires vm.debug == true & (os.family == \"linux\" | os.family == \"windows\")\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ShowRegistersOnAssertTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}