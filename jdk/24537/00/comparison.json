{"files":[{"patch":"@@ -57,19 +57,0 @@\n-\/\/ 4810578: varargs unsafe on 32-bit integer\/64-bit pointer architectures\n-\/\/ When __cplusplus is defined, NULL is defined as 0 (32-bit constant) in\n-\/\/ system header files.  On 32-bit architectures, there is no problem.\n-\/\/ On 64-bit architectures, defining NULL as a 32-bit constant can cause\n-\/\/ problems with varargs functions: C++ integral promotion rules say for\n-\/\/ varargs, we pass the argument 0 as an int.  So, if NULL was passed to a\n-\/\/ varargs function it will remain 32-bits.  Depending on the calling\n-\/\/ convention of the machine, if the argument is passed on the stack then\n-\/\/ only 32-bits of the \"NULL\" pointer may be initialized to zero.  The\n-\/\/ other 32-bits will be garbage.  If the varargs function is expecting a\n-\/\/ pointer when it extracts the argument, then we may have a problem.\n-\/\/\n-\/\/ Solution: For 64-bit architectures, redefine NULL as 64-bit constant 0.\n-#undef NULL\n-\/\/ 64-bit Windows uses a P64 data model (not LP64, although we define _LP64)\n-\/\/ Since longs are 32-bit we cannot use 0L here.  Use the Visual C++ specific\n-\/\/ 64-bit integer-suffix (LL) instead.\n-#define NULL 0LL\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -77,2 +77,1 @@\n-                \"src\/hotspot\/share\/prims\/jvmti.xsl\",\n-                \"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp\"\n+                \"src\/hotspot\/share\/prims\/jvmti.xsl\"\n","filename":"test\/hotspot\/jtreg\/sources\/TestNoNULL.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}