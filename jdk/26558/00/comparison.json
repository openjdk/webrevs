{"files":[{"patch":"@@ -1,417 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp\"\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrThreadGroup.hpp\"\n-#include \"jfr\/utilities\/jfrTypes.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/jniHandles.inline.hpp\"\n-#include \"runtime\/safepoint.hpp\"\n-#include \"runtime\/semaphore.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-static const int initial_array_size = 30;\n-\n-class ThreadGroupExclusiveAccess : public StackObj {\n- private:\n-  static Semaphore _mutex_semaphore;\n- public:\n-  ThreadGroupExclusiveAccess() { _mutex_semaphore.wait(); }\n-  ~ThreadGroupExclusiveAccess() { _mutex_semaphore.signal(); }\n-};\n-\n-Semaphore ThreadGroupExclusiveAccess::_mutex_semaphore(1);\n-JfrThreadGroup* JfrThreadGroup::_instance = nullptr;\n-\n-class JfrThreadGroupPointers : public ResourceObj {\n- private:\n-  const Handle _thread_group_handle;\n-  jweak _thread_group_weak_ref;\n- public:\n-  JfrThreadGroupPointers(Handle thread_group_handle, jweak thread_group_weak_ref);\n-  Handle thread_group_handle() const;\n-  jweak thread_group_weak_ref() const;\n-  oopDesc* thread_group_oop() const;\n-  jweak transfer_weak_global_handle_ownership();\n-  void clear_weak_ref();\n-};\n-\n-JfrThreadGroupPointers::JfrThreadGroupPointers(Handle thread_group_handle, jweak thread_group_weak_ref) :\n-  _thread_group_handle(thread_group_handle),\n-  _thread_group_weak_ref(thread_group_weak_ref) {}\n-\n-Handle JfrThreadGroupPointers::thread_group_handle() const {\n-  return _thread_group_handle;\n-}\n-\n-jweak JfrThreadGroupPointers::thread_group_weak_ref() const {\n-  return _thread_group_weak_ref;\n-}\n-\n-oopDesc* JfrThreadGroupPointers::thread_group_oop() const {\n-  assert(_thread_group_weak_ref == nullptr ||\n-         JNIHandles::resolve_non_null(_thread_group_weak_ref) == _thread_group_handle(), \"invariant\");\n-  return _thread_group_handle();\n-}\n-\n-jweak JfrThreadGroupPointers::transfer_weak_global_handle_ownership() {\n-  jweak temp = _thread_group_weak_ref;\n-  _thread_group_weak_ref = nullptr;\n-  return temp;\n-}\n-\n-void JfrThreadGroupPointers::clear_weak_ref() {\n-  if (nullptr != _thread_group_weak_ref) {\n-    JNIHandles::destroy_weak_global(_thread_group_weak_ref);\n-  }\n-}\n-\n-class JfrThreadGroupsHelper : public ResourceObj {\n- private:\n-  static const int invalid_iterator_pos = -1;\n-  GrowableArray<JfrThreadGroupPointers*>* _thread_group_hierarchy;\n-  int _current_iterator_pos;\n-\n-  int populate_thread_group_hierarchy(const JavaThread* jt, Thread* current);\n-  JfrThreadGroupPointers& at(int index);\n-\n- public:\n-  JfrThreadGroupsHelper(const JavaThread* jt, Thread* current);\n-  ~JfrThreadGroupsHelper();\n-  JfrThreadGroupPointers& next();\n-  bool is_valid() const;\n-  bool has_next() const;\n-};\n-\n-JfrThreadGroupsHelper::JfrThreadGroupsHelper(const JavaThread* jt, Thread* current) {\n-  _thread_group_hierarchy = new GrowableArray<JfrThreadGroupPointers*>(10);\n-  _current_iterator_pos = populate_thread_group_hierarchy(jt, current) - 1;\n-}\n-\n-JfrThreadGroupsHelper::~JfrThreadGroupsHelper() {\n-  assert(_current_iterator_pos == invalid_iterator_pos, \"invariant\");\n-  for (int i = 0; i < _thread_group_hierarchy->length(); ++i) {\n-    _thread_group_hierarchy->at(i)->clear_weak_ref();\n-  }\n-}\n-\n-JfrThreadGroupPointers& JfrThreadGroupsHelper::at(int index) {\n-  assert(_thread_group_hierarchy != nullptr, \"invariant\");\n-  assert(index > invalid_iterator_pos && index < _thread_group_hierarchy->length(), \"invariant\");\n-  return *(_thread_group_hierarchy->at(index));\n-}\n-\n-bool JfrThreadGroupsHelper::has_next() const {\n-  return _current_iterator_pos > invalid_iterator_pos;\n-}\n-\n-bool JfrThreadGroupsHelper::is_valid() const {\n-  return (_thread_group_hierarchy != nullptr && _thread_group_hierarchy->length() > 0);\n-}\n-\n-JfrThreadGroupPointers& JfrThreadGroupsHelper::next() {\n-  assert(is_valid(), \"invariant\");\n-  return at(_current_iterator_pos--);\n-}\n-\n-\/*\n- * If not at a safepoint, we create global weak references for\n- * all reachable threadgroups for this thread.\n- * If we are at a safepoint, the caller is the VMThread during\n- * JFR checkpointing. It can use naked oops, because nothing\n- * will move before the list of threadgroups is cleared and\n- * mutator threads restarted. The threadgroup list is cleared\n- * later by the VMThread as one of the final steps in JFR checkpointing\n- * (not here).\n- *\/\n-int JfrThreadGroupsHelper::populate_thread_group_hierarchy(const JavaThread* jt, Thread* current) {\n-  assert(jt != nullptr && jt->is_Java_thread(), \"invariant\");\n-  assert(current != nullptr, \"invariant\");\n-  assert(_thread_group_hierarchy != nullptr, \"invariant\");\n-\n-  oop thread_oop = jt->threadObj();\n-  if (thread_oop == nullptr) {\n-    return 0;\n-  }\n-  \/\/ immediate thread group\n-  Handle thread_group_handle(current, java_lang_Thread::threadGroup(thread_oop));\n-  if (thread_group_handle == nullptr) {\n-    return 0;\n-  }\n-\n-  const bool use_weak_handles = !SafepointSynchronize::is_at_safepoint();\n-  jweak thread_group_weak_ref = use_weak_handles ? JNIHandles::make_weak_global(thread_group_handle) : nullptr;\n-\n-  JfrThreadGroupPointers* thread_group_pointers = new JfrThreadGroupPointers(thread_group_handle, thread_group_weak_ref);\n-  _thread_group_hierarchy->append(thread_group_pointers);\n-  \/\/ immediate parent thread group\n-  oop parent_thread_group_obj = java_lang_ThreadGroup::parent(thread_group_handle());\n-  Handle parent_thread_group_handle(current, parent_thread_group_obj);\n-\n-  \/\/ and check parents parents...\n-  while (parent_thread_group_handle != nullptr) {\n-    const jweak parent_group_weak_ref = use_weak_handles ? JNIHandles::make_weak_global(parent_thread_group_handle) : nullptr;\n-    thread_group_pointers = new JfrThreadGroupPointers(parent_thread_group_handle, parent_group_weak_ref);\n-    _thread_group_hierarchy->append(thread_group_pointers);\n-    parent_thread_group_obj = java_lang_ThreadGroup::parent(parent_thread_group_handle());\n-    parent_thread_group_handle = Handle(current, parent_thread_group_obj);\n-  }\n-  return _thread_group_hierarchy->length();\n-}\n-\n-static traceid next_id() {\n-  static traceid _current_threadgroup_id = 1; \/\/ 1 is reserved for thread group \"VirtualThreads\"\n-  return ++_current_threadgroup_id;\n-}\n-\n-class JfrThreadGroup::JfrThreadGroupEntry : public JfrCHeapObj {\n-  friend class JfrThreadGroup;\n- private:\n-  traceid _thread_group_id;\n-  traceid _parent_group_id;\n-  char* _thread_group_name; \/\/ utf8 format\n-  \/\/ If an entry is created during a safepoint, the\n-  \/\/ _thread_group_oop contains a direct oop to\n-  \/\/ the java.lang.ThreadGroup object.\n-  \/\/ If an entry is created on javathread exit time (not at safepoint),\n-  \/\/ _thread_group_weak_ref contains a JNI weak global handle\n-  \/\/ indirection to the java.lang.ThreadGroup object.\n-  \/\/ Note: we cannot use a union here since CHECK_UNHANDLED_OOPS makes oop have\n-  \/\/       a ctor which isn't allowed in a union by the SunStudio compiler\n-  oop _thread_group_oop;\n-  jweak _thread_group_weak_ref;\n-\n-  JfrThreadGroupEntry(const char* tgstr, JfrThreadGroupPointers& ptrs);\n-  ~JfrThreadGroupEntry();\n-\n-  traceid thread_group_id() const { return _thread_group_id; }\n-  void set_thread_group_id(traceid tgid) { _thread_group_id = tgid; }\n-\n-  const char* thread_group_name() const { return _thread_group_name; }\n-  void set_thread_group_name(const char* tgname);\n-\n-  traceid parent_group_id() const { return _parent_group_id; }\n-  void set_parent_group_id(traceid pgid) { _parent_group_id = pgid; }\n-\n-  void set_thread_group(JfrThreadGroupPointers& ptrs);\n-  bool is_equal(const JfrThreadGroupPointers& ptrs) const;\n-  oop thread_group() const;\n-};\n-\n-JfrThreadGroup::JfrThreadGroupEntry::JfrThreadGroupEntry(const char* tgname, JfrThreadGroupPointers& ptrs) :\n-  _thread_group_id(0),\n-  _parent_group_id(0),\n-  _thread_group_name(nullptr),\n-  _thread_group_oop(nullptr),\n-  _thread_group_weak_ref(nullptr) {\n-  set_thread_group_name(tgname);\n-  set_thread_group(ptrs);\n-}\n-\n-JfrThreadGroup::JfrThreadGroupEntry::~JfrThreadGroupEntry() {\n-  if (_thread_group_name != nullptr) {\n-    JfrCHeapObj::free(_thread_group_name, strlen(_thread_group_name) + 1);\n-  }\n-  if (_thread_group_weak_ref != nullptr) {\n-    JNIHandles::destroy_weak_global(_thread_group_weak_ref);\n-  }\n-}\n-\n-void JfrThreadGroup::JfrThreadGroupEntry::set_thread_group_name(const char* tgname) {\n-  assert(_thread_group_name == nullptr, \"invariant\");\n-  if (tgname != nullptr) {\n-    size_t len = strlen(tgname);\n-    _thread_group_name = JfrCHeapObj::new_array<char>(len + 1);\n-    strncpy(_thread_group_name, tgname, len + 1);\n-  }\n-}\n-\n-oop JfrThreadGroup::JfrThreadGroupEntry::thread_group() const {\n-  return _thread_group_weak_ref != nullptr ? JNIHandles::resolve(_thread_group_weak_ref) : _thread_group_oop;\n-}\n-\n-void JfrThreadGroup::JfrThreadGroupEntry::set_thread_group(JfrThreadGroupPointers& ptrs) {\n-  _thread_group_weak_ref = ptrs.transfer_weak_global_handle_ownership();\n-  if (_thread_group_weak_ref == nullptr) {\n-    _thread_group_oop = ptrs.thread_group_oop();\n-    assert(_thread_group_oop != nullptr, \"invariant\");\n-  } else {\n-    _thread_group_oop = nullptr;\n-  }\n-}\n-\n-JfrThreadGroup::JfrThreadGroup() :\n-  _list(new (mtTracing) GrowableArray<JfrThreadGroupEntry*>(initial_array_size, mtTracing)) {}\n-\n-JfrThreadGroup::~JfrThreadGroup() {\n-  if (_list != nullptr) {\n-    for (int i = 0; i < _list->length(); i++) {\n-      JfrThreadGroupEntry* e = _list->at(i);\n-      delete e;\n-    }\n-    delete _list;\n-  }\n-}\n-\n-JfrThreadGroup* JfrThreadGroup::instance() {\n-  return _instance;\n-}\n-\n-void JfrThreadGroup::set_instance(JfrThreadGroup* new_instance) {\n-  _instance = new_instance;\n-}\n-\n-traceid JfrThreadGroup::thread_group_id(const JavaThread* jt, Thread* current) {\n-  HandleMark hm(current);\n-  JfrThreadGroupsHelper helper(jt, current);\n-  return helper.is_valid() ? thread_group_id_internal(helper) : 0;\n-}\n-\n-traceid JfrThreadGroup::thread_group_id(JavaThread* const jt) {\n-  return thread_group_id(jt, jt);\n-}\n-\n-traceid JfrThreadGroup::thread_group_id_internal(JfrThreadGroupsHelper& helper) {\n-  ThreadGroupExclusiveAccess lock;\n-  JfrThreadGroup* tg_instance = instance();\n-  if (tg_instance == nullptr) {\n-    tg_instance = new JfrThreadGroup();\n-    if (tg_instance == nullptr) {\n-      return 0;\n-    }\n-    set_instance(tg_instance);\n-  }\n-\n-  JfrThreadGroupEntry* tge = nullptr;\n-  traceid parent_thread_group_id = 0;\n-  while (helper.has_next()) {\n-    JfrThreadGroupPointers& ptrs = helper.next();\n-    tge = tg_instance->find_entry(ptrs);\n-    if (nullptr == tge) {\n-      tge = tg_instance->new_entry(ptrs);\n-      assert(tge != nullptr, \"invariant\");\n-      tge->set_parent_group_id(parent_thread_group_id);\n-    }\n-    parent_thread_group_id = tge->thread_group_id();\n-  }\n-  \/\/ the last entry in the hierarchy is the immediate thread group\n-  return tge->thread_group_id();\n-}\n-\n-bool JfrThreadGroup::JfrThreadGroupEntry::is_equal(const JfrThreadGroupPointers& ptrs) const {\n-  return ptrs.thread_group_oop() == thread_group();\n-}\n-\n-JfrThreadGroup::JfrThreadGroupEntry*\n-JfrThreadGroup::find_entry(const JfrThreadGroupPointers& ptrs) const {\n-  for (int index = 0; index < _list->length(); ++index) {\n-    JfrThreadGroupEntry* curtge = _list->at(index);\n-    if (curtge->is_equal(ptrs)) {\n-      return curtge;\n-    }\n-  }\n-  return (JfrThreadGroupEntry*) nullptr;\n-}\n-\n-\/\/ Assumes you already searched for the existence\n-\/\/ of a corresponding entry in find_entry().\n-JfrThreadGroup::JfrThreadGroupEntry*\n-JfrThreadGroup::new_entry(JfrThreadGroupPointers& ptrs) {\n-  JfrThreadGroupEntry* const tge = new JfrThreadGroupEntry(java_lang_ThreadGroup::name(ptrs.thread_group_oop()), ptrs);\n-  add_entry(tge);\n-  return tge;\n-}\n-\n-int JfrThreadGroup::add_entry(JfrThreadGroupEntry* tge) {\n-  assert(tge != nullptr, \"attempting to add a null entry!\");\n-  assert(0 == tge->thread_group_id(), \"id must be unassigned!\");\n-  tge->set_thread_group_id(next_id());\n-  return _list->append(tge);\n-}\n-\n-void JfrThreadGroup::write_thread_group_entries(JfrCheckpointWriter& writer) const {\n-  assert(_list != nullptr && !_list->is_empty(), \"should not need be here!\");\n-  const int number_of_tg_entries = _list->length();\n-  writer.write_count(number_of_tg_entries + 1); \/\/ + VirtualThread group\n-  writer.write_key(1);      \/\/ 1 is reserved for VirtualThread group\n-  writer.write<traceid>(0); \/\/ parent\n-  const oop vgroup = java_lang_Thread_Constants::get_VTHREAD_GROUP();\n-  assert(vgroup != (oop)nullptr, \"invariant\");\n-  const char* const vgroup_name = java_lang_ThreadGroup::name(vgroup);\n-  assert(vgroup_name != nullptr, \"invariant\");\n-  writer.write(vgroup_name);\n-  for (int index = 0; index < number_of_tg_entries; ++index) {\n-    const JfrThreadGroupEntry* const curtge = _list->at(index);\n-    writer.write_key(curtge->thread_group_id());\n-    writer.write(curtge->parent_group_id());\n-    writer.write(curtge->thread_group_name());\n-  }\n-}\n-\n-void JfrThreadGroup::write_selective_thread_group(JfrCheckpointWriter* writer, traceid thread_group_id) const {\n-  assert(writer != nullptr, \"invariant\");\n-  assert(_list != nullptr && !_list->is_empty(), \"should not need be here!\");\n-  assert(thread_group_id != 1, \"should not need be here!\");\n-  const int number_of_tg_entries = _list->length();\n-\n-  \/\/ save context\n-  const JfrCheckpointContext ctx = writer->context();\n-  writer->write_type(TYPE_THREADGROUP);\n-  const jlong count_offset = writer->reserve(sizeof(u4)); \/\/ Don't know how many yet\n-  int number_of_entries_written = 0;\n-  for (int index = number_of_tg_entries - 1; index >= 0; --index) {\n-    const JfrThreadGroupEntry* const curtge = _list->at(index);\n-    if (thread_group_id == curtge->thread_group_id()) {\n-      writer->write_key(curtge->thread_group_id());\n-      writer->write(curtge->parent_group_id());\n-      writer->write(curtge->thread_group_name());\n-      ++number_of_entries_written;\n-      thread_group_id = curtge->parent_group_id();\n-    }\n-  }\n-  if (number_of_entries_written == 0) {\n-    \/\/ nothing to write, restore context\n-    writer->set_context(ctx);\n-    return;\n-  }\n-  assert(number_of_entries_written > 0, \"invariant\");\n-  writer->write_count(number_of_entries_written, count_offset);\n-}\n-\n-\/\/ Write out JfrThreadGroup instance and then delete it\n-void JfrThreadGroup::serialize(JfrCheckpointWriter& writer) {\n-  ThreadGroupExclusiveAccess lock;\n-  JfrThreadGroup* tg_instance = instance();\n-  assert(tg_instance != nullptr, \"invariant\");\n-  tg_instance->write_thread_group_entries(writer);\n-}\n-\n-\/\/ for writing a particular thread group\n-void JfrThreadGroup::serialize(JfrCheckpointWriter* writer, traceid thread_group_id) {\n-  assert(writer != nullptr, \"invariant\");\n-  ThreadGroupExclusiveAccess lock;\n-  JfrThreadGroup* const tg_instance = instance();\n-  assert(tg_instance != nullptr, \"invariant\");\n-  tg_instance->write_selective_thread_group(writer, thread_group_id);\n-}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadGroup.cpp","additions":0,"deletions":417,"binary":false,"changes":417,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTHREADGROUP_HPP\n-#define SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTHREADGROUP_HPP\n-\n-#include \"jfr\/utilities\/jfrAllocation.hpp\"\n-#include \"jfr\/utilities\/jfrTypes.hpp\"\n-#include \"jni.h\"\n-\n-class JfrCheckpointWriter;\n-template <typename>\n-class GrowableArray;\n-class JfrThreadGroupsHelper;\n-class JfrThreadGroupPointers;\n-\n-class JfrThreadGroup : public JfrCHeapObj {\n-  friend class JfrCheckpointThreadClosure;\n- private:\n-  static JfrThreadGroup* _instance;\n-  class JfrThreadGroupEntry;\n-  GrowableArray<JfrThreadGroupEntry*>* _list;\n-\n-  JfrThreadGroup();\n-  JfrThreadGroupEntry* find_entry(const JfrThreadGroupPointers& ptrs) const;\n-  JfrThreadGroupEntry* new_entry(JfrThreadGroupPointers& ptrs);\n-  int add_entry(JfrThreadGroupEntry* const tge);\n-\n-  void write_thread_group_entries(JfrCheckpointWriter& writer) const;\n-  void write_selective_thread_group(JfrCheckpointWriter* writer, traceid thread_group_id) const;\n-\n-  static traceid thread_group_id_internal(JfrThreadGroupsHelper& helper);\n-  static JfrThreadGroup* instance();\n-  static void set_instance(JfrThreadGroup* new_instance);\n-\n- public:\n-  ~JfrThreadGroup();\n-  static void serialize(JfrCheckpointWriter& w);\n-  static void serialize(JfrCheckpointWriter* w, traceid thread_group_id);\n-  static traceid thread_group_id(JavaThread* thread);\n-  static traceid thread_group_id(const JavaThread* thread, Thread* current);\n-};\n-\n-#endif \/\/ SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTHREADGROUP_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadGroup.hpp","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/jfrThreadGroupManager.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+#include \"jfr\/utilities\/jfrLinkedList.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/semaphore.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ThreadGroupExclusiveAccess : public StackObj {\n+ private:\n+  static Semaphore _mutex_semaphore;\n+ public:\n+  ThreadGroupExclusiveAccess() { _mutex_semaphore.wait(); }\n+  ~ThreadGroupExclusiveAccess() { _mutex_semaphore.signal(); }\n+};\n+\n+Semaphore ThreadGroupExclusiveAccess::_mutex_semaphore(1);\n+\n+static traceid next_id() {\n+  static traceid _tgid = 1; \/\/ 1 is reserved for thread group \"VirtualThreads\"\n+  return ++_tgid;\n+}\n+\n+class JfrThreadGroup : public JfrCHeapObj {\n+  template <typename, typename>\n+  friend class JfrLinkedList;\n+ private:\n+  mutable const JfrThreadGroup* _next;\n+  const JfrThreadGroup* _parent;\n+  traceid _tgid;\n+  char* _tg_name; \/\/ utf8 format\n+  jweak _tg_handle;\n+  mutable u2 _generation;\n+\n+ public:\n+  JfrThreadGroup(Handle tg, const JfrThreadGroup* parent) :\n+    _next(nullptr), _parent(parent), _tgid(next_id()), _tg_name(nullptr),\n+    _tg_handle(JNIHandles::make_weak_global(tg)), _generation(0) {\n+    const char* name = java_lang_ThreadGroup::name(tg());\n+    if (name != nullptr) {\n+      const size_t len = strlen(name);\n+      _tg_name = JfrCHeapObj::new_array<char>(len + 1);\n+      strncpy(_tg_name, name, len + 1);\n+    }\n+  }\n+\n+  ~JfrThreadGroup() {\n+    JNIHandles::destroy_weak_global(_tg_handle);\n+    if (_tg_name != nullptr) {\n+      JfrCHeapObj::free(_tg_name, strlen(_tg_name) + 1);\n+    }\n+  }\n+\n+  const JfrThreadGroup* next() const { return _next; }\n+  void set_next(const JfrThreadGroup* tg) const { _next = tg; }\n+\n+  traceid id() const { return _tgid; }\n+\n+  const char* name() const {\n+    return _tg_name;\n+  }\n+\n+  const JfrThreadGroup* parent() const { return _parent; }\n+\n+  traceid parent_id() const {\n+    return _parent != nullptr ? _parent->id() : 0;\n+  }\n+\n+  bool is_dead() const {\n+    return JNIHandles::resolve(_tg_handle) == nullptr;\n+  }\n+\n+  bool operator==(oop tg) const {\n+    assert(tg != nullptr, \"invariant\");\n+    return tg == JNIHandles::resolve(_tg_handle);\n+  }\n+\n+  bool should_write() const {\n+    return !JfrTraceIdEpoch::is_current_epoch_generation(_generation);\n+  }\n+\n+  void set_written() const {\n+    assert(should_write(), \"invariant\");\n+    _generation = JfrTraceIdEpoch::epoch_generation();\n+  }\n+};\n+\n+typedef JfrLinkedList<const JfrThreadGroup> JfrThreadGroupList;\n+\n+static JfrThreadGroupList* _list = nullptr;\n+\n+static JfrThreadGroupList& list() {\n+  assert(_list != nullptr, \"invariant\");\n+  return *_list;\n+}\n+\n+bool JfrThreadGroupManager::create() {\n+  assert(_list == nullptr, \"invariant\");\n+  _list = new JfrThreadGroupList();\n+  return _list != nullptr;\n+}\n+\n+void JfrThreadGroupManager::destroy() {\n+  delete _list;\n+  _list = nullptr;\n+}\n+\n+static int populate(GrowableArray<Handle>* hierarchy, const JavaThread* jt, Thread* current) {\n+  assert(hierarchy != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(current == Thread::current(), \"invariant\");\n+\n+  oop thread_oop = jt->threadObj();\n+  if (thread_oop == nullptr) {\n+    return 0;\n+  }\n+  \/\/ Immediate thread group.\n+  const Handle tg_handle(current, java_lang_Thread::threadGroup(thread_oop));\n+  if (tg_handle.is_null()) {\n+    return 0;\n+  }\n+  hierarchy->append(tg_handle);\n+\n+  \/\/ Thread group parent and then its parents...\n+  Handle parent_tg_handle(current, java_lang_ThreadGroup::parent(tg_handle()));\n+\n+  while (parent_tg_handle != nullptr) {\n+    hierarchy->append(parent_tg_handle);\n+    parent_tg_handle = Handle(current, java_lang_ThreadGroup::parent(parent_tg_handle()));\n+  }\n+\n+  return hierarchy->length();\n+}\n+\n+class JfrThreadGroupLookup : public ResourceObj {\n+  static const int invalid_iterator = -1;\n+ private:\n+  GrowableArray<Handle>* _hierarchy;\n+  mutable int _iterator;\n+\n+ public:\n+  JfrThreadGroupLookup(const JavaThread* jt, Thread* current) :\n+    _hierarchy(new GrowableArray<Handle>(16)),\n+    _iterator(populate(_hierarchy, jt, current) - 1) {}\n+\n+  bool has_next() const {\n+    return _iterator > invalid_iterator;\n+  }\n+\n+  Handle& next() const {\n+    assert(has_next(), \"invariant\");\n+    return _hierarchy->at(_iterator--);\n+  }\n+};\n+\n+static const JfrThreadGroup* find_or_add(Handle& tg_oop, const JfrThreadGroup* parent) {\n+  assert(parent == nullptr || list().in_list(parent), \"invariant\");\n+  const JfrThreadGroup* tg = list().head();\n+  const JfrThreadGroup* result = nullptr;\n+  while (tg != nullptr) {\n+    if (*tg == tg_oop()) {\n+      assert(tg->parent() == parent, \"invariant\");\n+      result = tg;\n+      tg = nullptr;\n+      continue;\n+    }\n+    tg = tg->next();\n+  }\n+  if (result == nullptr) {\n+    result = new JfrThreadGroup(tg_oop, parent);\n+    list().add(result);\n+  }\n+  return result;\n+}\n+\n+static traceid find_tgid(const JfrThreadGroupLookup& lookup) {\n+  const JfrThreadGroup* tg = nullptr;\n+  const JfrThreadGroup* ptg = nullptr;\n+  while (lookup.has_next()) {\n+    tg = find_or_add(lookup.next(), ptg);\n+    ptg = tg;\n+  }\n+  return tg->id();\n+}\n+\n+static traceid find(const JfrThreadGroupLookup& lookup) {\n+  ThreadGroupExclusiveAccess lock;\n+  return find_tgid(lookup);\n+}\n+\n+traceid JfrThreadGroupManager::thread_group_id(JavaThread* jt) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt);)\n+  ResourceMark rm(jt);\n+  HandleMark hm(jt);\n+  const JfrThreadGroupLookup lookup(jt, jt);\n+  return find(lookup);\n+}\n+\n+traceid JfrThreadGroupManager::thread_group_id(const JavaThread* jt, Thread* current) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(current != nullptr, \"invariant\");\n+  assert(!current->is_Java_thread() || JavaThread::cast(current)->thread_state() == _thread_in_vm, \"invariant\");\n+  ResourceMark rm(current);\n+  HandleMark hm(current);\n+  const JfrThreadGroupLookup lookup(jt, current);\n+  return find(lookup);\n+}\n+\n+static void write_virtual_thread_group(JfrCheckpointWriter& writer) {\n+  writer.write_key(1);      \/\/ 1 is reserved for VirtualThread group\n+  writer.write<traceid>(0); \/\/ parent\n+  const oop vgroup = java_lang_Thread_Constants::get_VTHREAD_GROUP();\n+  assert(vgroup != (oop)nullptr, \"invariant\");\n+  const char* const vgroup_name = java_lang_ThreadGroup::name(vgroup);\n+  assert(vgroup_name != nullptr, \"invariant\");\n+  writer.write(vgroup_name);\n+}\n+\n+static int write_thread_group(JfrCheckpointWriter& writer, const JfrThreadGroup* tg, bool to_blob = false) {\n+  assert(tg != nullptr, \"invariant\");\n+  if (tg->should_write() || to_blob) {\n+    writer.write_key(tg->id());\n+    writer.write(tg->parent_id());\n+    writer.write(tg->name());\n+    if (!to_blob) {\n+      tg->set_written();\n+    }\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+\/\/ For writing all live thread groups while removing and deleting dead thread groups.\n+void JfrThreadGroupManager::serialize(JfrCheckpointWriter& writer) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(JavaThread::current());)\n+\n+  const uint64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n+\n+  \/\/ First write the pre-defined ThreadGroup for virtual threads.\n+  write_virtual_thread_group(writer);\n+  int number_of_groups_written = 1;\n+\n+  const JfrThreadGroup* next = nullptr;\n+  const JfrThreadGroup* prev = nullptr;\n+\n+  {\n+    ThreadGroupExclusiveAccess lock;\n+    const JfrThreadGroup* tg = list().head();\n+    while (tg != nullptr) {\n+      next = tg->next();\n+      if (tg->is_dead()) {\n+        prev = list().excise(prev, tg);\n+        assert(!list().in_list(tg), \"invariant\");\n+        delete tg;\n+        tg = next;\n+        continue;\n+      }\n+      number_of_groups_written += write_thread_group(writer, tg);\n+      prev = tg;\n+      tg = next;\n+    }\n+  }\n+\n+  assert(number_of_groups_written > 0, \"invariant\");\n+  writer.write_count(number_of_groups_written, count_offset);\n+}\n+\n+\/\/ For writing a specific thread group and its ancestry.\n+void JfrThreadGroupManager::serialize(JfrCheckpointWriter& writer, traceid tgid, bool to_blob) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(JavaThread::current());)\n+  \/\/ save context\n+  const JfrCheckpointContext ctx = writer.context();\n+\n+  writer.write_type(TYPE_THREADGROUP);\n+  const uint64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n+\n+  int number_of_groups_written = 0;\n+\n+  {\n+    ThreadGroupExclusiveAccess lock;\n+    const JfrThreadGroup* tg = list().head();\n+    while (tg != nullptr) {\n+      if (tgid == tg->id()) {\n+        while (tg != nullptr) {\n+          number_of_groups_written += write_thread_group(writer, tg, to_blob);\n+          tg = tg->parent();\n+        }\n+        break;\n+      }\n+      tg = tg->next();\n+    }\n+  }\n+\n+  if (number_of_groups_written == 0) {\n+    \/\/ nothing to write, restore context\n+    writer.set_context(ctx);\n+    return;\n+  }\n+\n+  assert(number_of_groups_written > 0, \"invariant\");\n+  writer.write_count(number_of_groups_written, count_offset);\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadGroupManager.cpp","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTHREADGROUPMANAGER_HPP\n+#define SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTHREADGROUPMANAGER_HPP\n+\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+\n+class JfrCheckpointWriter;\n+\n+class JfrThreadGroupManager : public AllStatic {\n+  friend class JfrRecorder;\n+\n+ private:\n+  static bool create();\n+  static void destroy();\n+\n+ public:\n+  static void serialize(JfrCheckpointWriter& w);\n+  static void serialize(JfrCheckpointWriter& w, traceid tgid, bool is_blob);\n+\n+  static traceid thread_group_id(JavaThread* thread);\n+  static traceid thread_group_id(const JavaThread* thread, Thread* current);\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTHREADGROUPMANAGER_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadGroupManager.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrThreadGroup.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/jfrThreadGroupManager.hpp\"\n@@ -109,1 +109,1 @@\n-    _writer.write(JfrThreadGroup::thread_group_id(JavaThread::cast(t), _curthread));\n+    _writer.write(JfrThreadGroupManager::thread_group_id(JavaThread::cast(t), _curthread));\n@@ -127,1 +127,1 @@\n-  JfrThreadGroup::serialize(writer);\n+  JfrThreadGroupManager::serialize(writer);\n@@ -306,1 +306,1 @@\n-    JfrThreadGroup::thread_group_id(JavaThread::cast(_thread), Thread::current());\n+    JfrThreadGroupManager::thread_group_id(JavaThread::cast(_thread), Thread::current());\n@@ -310,1 +310,1 @@\n-    JfrThreadGroup::serialize(&writer, thread_group_id);\n+    JfrThreadGroupManager::serialize(writer, thread_group_id, _to_blob);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,1 @@\n+  const bool _to_blob;\n@@ -115,2 +116,2 @@\n-  JfrThreadConstant(Thread* t, traceid tid, oop vthread = nullptr) :\n-    _thread(t), _tid(tid), _vthread(vthread), _name(nullptr), _length(-1) {}\n+  JfrThreadConstant(Thread* t, traceid tid, bool to_blob, oop vthread = nullptr) :\n+    _thread(t), _tid(tid), _vthread(vthread), _name(nullptr), _length(-1), _to_blob(to_blob) {}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  JfrThreadConstant type_thread(jt, tid, vthread);\n+  JfrThreadConstant type_thread(jt, tid, true, vthread);\n@@ -131,1 +131,1 @@\n-  JfrThreadConstant type_thread(t, tid, vthread);\n+  JfrThreadConstant type_thread(t, tid, false, vthread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/jfrThreadGroupManager.hpp\"\n@@ -314,0 +315,3 @@\n+  if (!create_thread_group_manager()) {\n+    return false;\n+  }\n@@ -408,0 +412,4 @@\n+bool JfrRecorder::create_thread_group_manager() {\n+  return JfrThreadGroupManager::create();\n+}\n+\n@@ -447,0 +455,1 @@\n+  JfrThreadGroupManager::destroy();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  static bool create_thread_group_manager();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,1 +139,3 @@\n-  assign_thread_id(t, t->jfr_thread_local());\n+  JfrThreadLocal* const tl = t->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n+  assign_thread_id(t, tl);\n@@ -141,3 +143,6 @@\n-    JfrCheckpointManager::write_checkpoint(t);\n-    if (t->is_Java_thread()) {\n-      JavaThread *const jt = JavaThread::cast(t);\n+    if (!t->is_Java_thread()) {\n+      JfrCheckpointManager::write_checkpoint(t);\n+      return;\n+    }\n+    JavaThread* const jt = JavaThread::cast(t);\n+    if (jt->thread_state() == _thread_new) {\n@@ -145,0 +150,3 @@\n+    } else {\n+      assert(jt->thread_state() == _thread_in_vm, \"invariant\");\n+      JfrCheckpointManager::write_checkpoint(t);\n@@ -146,0 +154,4 @@\n+      if (tl->has_cached_stack_trace()) {\n+        tl->clear_cached_stack_trace();\n+      }\n+      return;\n@@ -148,2 +160,4 @@\n-  if (t->jfr_thread_local()->has_cached_stack_trace()) {\n-    t->jfr_thread_local()->clear_cached_stack_trace();\n+  if (t->is_Java_thread() && JavaThread::cast(t)->thread_state() == _thread_in_vm) {\n+    if (tl->has_cached_stack_trace()) {\n+      tl->clear_cached_stack_trace();\n+    }\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -741,0 +741,2 @@\n+  JFR_ONLY(Jfr::on_thread_start(this);)\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}