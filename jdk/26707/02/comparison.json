{"files":[{"patch":"@@ -49,0 +49,1 @@\n+import jdk.jpackage.internal.model.LauncherShortcut;\n@@ -240,0 +241,17 @@\n+        data.put(\"STARTUP_DIRECTORY\", launcher.shortcut()\n+                .flatMap(LauncherShortcut::startupDirectory)\n+                .map(startupDirectory -> {\n+                    switch (startupDirectory) {\n+                        case DEFAULT -> {\n+                            return (Path)null;\n+                        }\n+                        case APP_DIR -> {\n+                            return installedLayout.appDirectory();\n+                        }\n+                        default -> {\n+                            throw new AssertionError();\n+                        }\n+                    }\n+                }).map(str -> {\n+                    return \"Path=\" + str;\n+                }).orElse(null));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -112,6 +112,2 @@\n-    private static final BundlerParamInfo<Boolean> LINUX_SHORTCUT_HINT = new BundlerParamInfo<>(\n-            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n-            Boolean.class,\n-            params -> false,\n-            (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ? false : Boolean.valueOf(s)\n-    );\n+    private static final BundlerParamInfo<String> LINUX_SHORTCUT_HINT = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId());\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+STARTUP_DIRECTORY\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.desktop","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -351,3 +352,2 @@\n-        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-menu\", true);\n-        }),\n+        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN,\n+                createArgumentWithOptionalValueAction(\"win-menu\")),\n@@ -357,4 +357,2 @@\n-        WIN_SHORTCUT_HINT (\"win-shortcut\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-shortcut\", true);\n-        }),\n+        WIN_SHORTCUT_HINT (\"win-shortcut\", OptionCategories.PLATFORM_WIN,\n+                createArgumentWithOptionalValueAction(\"win-shortcut\")),\n@@ -399,4 +397,2 @@\n-        LINUX_SHORTCUT_HINT (\"linux-shortcut\",\n-                OptionCategories.PLATFORM_LINUX, () -> {\n-            setOptionValue(\"linux-shortcut\", true);\n-        }),\n+        LINUX_SHORTCUT_HINT (\"linux-shortcut\", OptionCategories.PLATFORM_LINUX,\n+                createArgumentWithOptionalValueAction(\"linux-shortcut\")),\n@@ -481,0 +477,5 @@\n+        private static void prevArg() {\n+            Objects.checkIndex(context().pos, context().argList.size());\n+            context().pos--;\n+        }\n+\n@@ -484,0 +485,18 @@\n+\n+        private static Runnable createArgumentWithOptionalValueAction(String option) {\n+            Objects.requireNonNull(option);\n+            return () -> {\n+                nextArg();\n+                if (hasNextArg()) {\n+                    var value = getArg();\n+                    if (value.startsWith(\"-\")) {\n+                        prevArg();\n+                        setOptionValue(option, true);\n+                    } else {\n+                        setOptionValue(option, value);\n+                    }\n+                } else {\n+                    setOptionValue(option, true);\n+                }\n+            };\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -72,0 +73,1 @@\n+import jdk.jpackage.internal.model.ParseUtils;\n@@ -174,1 +176,1 @@\n-            BundlerParamInfo<Boolean> shortcutParam,\n+            BundlerParamInfo<String> shortcutParam,\n@@ -178,1 +180,1 @@\n-        Optional<Boolean> launcherValue;\n+        Optional<String> launcherValue;\n@@ -186,11 +188,13 @@\n-        return launcherValue.map(withShortcut -> {\n-            if (withShortcut) {\n-                return Optional.of(LauncherShortcutStartupDirectory.DEFAULT);\n-            } else {\n-                return Optional.<LauncherShortcutStartupDirectory>empty();\n-            }\n-        }).or(() -> {\n-            return shortcutParam.findIn(mainParams).map(_ -> {\n-                return Optional.of(LauncherShortcutStartupDirectory.DEFAULT);\n-            });\n-        }).map(LauncherShortcut::new);\n+        return launcherValue.map(ParseUtils::parseLauncherShortcutForAddLauncher).or(() -> {\n+            return Optional.ofNullable(mainParams.get(shortcutParam.getID())).map(toFunction(value -> {\n+                if (value instanceof Boolean) {\n+                    return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n+                } else {\n+                    try {\n+                        return ParseUtils.parseLauncherShortcutForMainLauncher((String)value);\n+                    } catch (IllegalArgumentException ex) {\n+                        throw I18N.buildConfigException(\"error.invalid-option-value\", value, \"--\" + shortcutParam.getID()).create();\n+                    }\n+                }\n+            }));\n+        });\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,1 +44,8 @@\n-    DEFAULT(\"true\");\n+    DEFAULT(\"true\"),\n+\n+    \/**\n+     * The 'app' directory in the installed application app image. This is the\n+     * directory that is referenced with {@link ApplicationLayout#appDirectory()}\n+     * method.\n+     *\/\n+    APP_DIR(\"app-dir\");\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherShortcutStartupDirectory.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Collection of functions to create instances of types defined in this package from strings.\n+ *\/\n+public final class ParseUtils {\n+\n+    private ParseUtils() {\n+    }\n+\n+    public static LauncherShortcut parseLauncherShortcutForMainLauncher(String str) {\n+        return parse(str, LauncherShortcutStartupDirectory.APP_DIR).map(LauncherShortcut::new).orElseThrow(IllegalArgumentException::new);\n+    }\n+\n+    public static LauncherShortcut parseLauncherShortcutForAddLauncher(String str) {\n+        return parse(str, LauncherShortcutStartupDirectory.values()).map(LauncherShortcut::new).orElseGet(() -> {\n+            if (Boolean.valueOf(str)) {\n+                return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n+            } else {\n+                return new LauncherShortcut();\n+            }\n+        });\n+    }\n+\n+    private static Optional<LauncherShortcutStartupDirectory> parse(String str, LauncherShortcutStartupDirectory... recognizedValues) {\n+        Objects.requireNonNull(str);\n+        return Stream.of(recognizedValues).filter(v -> {\n+            return str.equals(v.asStringValue());\n+        }).findFirst();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ParseUtils.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -85,0 +85,2 @@\n+error.invalid-option-value=Invalid value \"{0}\" of option {1}\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    private static final BundlerParamInfo<Boolean> WIN_MENU_HINT = createBooleanBundlerParam(\n+    private static final BundlerParamInfo<String> WIN_MENU_HINT = createStringBundlerParam(\n@@ -111,1 +111,1 @@\n-    private static final BundlerParamInfo<Boolean> WIN_SHORTCUT_HINT = createBooleanBundlerParam(\n+    private static final BundlerParamInfo<String> WIN_SHORTCUT_HINT = createStringBundlerParam(\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -477,0 +477,3 @@\n+                            case APP_DIR -> {\n+                                return installedAppImage.appDirectory();\n+                            }\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+    public String name() {\n+        return name;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+        APP_DIR(\"app-dir\"),\n@@ -82,1 +83,1 @@\n-        private final static Map<String, StartupDirectory> VALUE_MAP =\n+        private static final Map<String, StartupDirectory> VALUE_MAP =\n@@ -150,1 +151,8 @@\n-            return Optional.of(StartupDirectory.DEFAULT);\n+            var value = Optional.ofNullable(cmd.getArgumentValue(optionName())).filter(optionValue -> {\n+                return !optionValue.startsWith(\"-\");\n+            });\n+            if (value.isPresent()) {\n+                return value.flatMap(StartupDirectory::parse);\n+            } else {\n+                return Optional.of(StartupDirectory.DEFAULT);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -517,0 +517,3 @@\n+                case APP_DIR -> {\n+                    return cmd.pathToPackageFile(appLayout.appDirectory());\n+                }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -216,1 +216,11 @@\n-            return installDir;\n+            switch (startupDirectory) {\n+                case DEFAULT -> {\n+                    return installDir;\n+                }\n+                case APP_DIR -> {\n+                    return ApplicationLayout.windowsAppImage().resolveAt(installDir).appDirectory();\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WinShortcutVerifier.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.LinkedHashMap;\n@@ -32,0 +33,1 @@\n+import java.util.Map;\n@@ -34,0 +36,1 @@\n+import java.util.stream.Collectors;\n@@ -40,0 +43,1 @@\n+import jdk.jpackage.test.HelloApp;\n@@ -41,0 +45,1 @@\n+import jdk.jpackage.test.JavaAppDesc;\n@@ -66,0 +71,1 @@\n+ * @requires (os.family != \"mac\")\n@@ -79,0 +85,1 @@\n+ * @requires (os.family != \"mac\")\n@@ -88,1 +95,1 @@\n-    @Test\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n@@ -96,0 +103,2 @@\n+        final var packageName = MethodHandles.lookup().lookupClass().getSimpleName();\n+\n@@ -105,0 +114,5 @@\n+\n+            cmd.setArgumentValue(\"--name\", packageName);\n+\n+            var addLauncherApp = TKit.TEST_SRC_ROOT.resolve(\"apps\/PrintEnv.java\");\n+            HelloApp.createBundle(JavaAppDesc.parse(addLauncherApp + \"*another.jar:Welcome\"), cmd.inputDir());\n@@ -107,3 +121,1 @@\n-        new FileAssociations(\n-                MethodHandles.lookup().lookupClass().getSimpleName()).applyTo(\n-                packageTest);\n+        new FileAssociations(packageName).applyTo(packageTest);\n@@ -134,2 +146,2 @@\n-        new AdditionalLauncher(\"Launcher5\")\n-                .setDefaultArguments()\n+        var launcher5 = new AdditionalLauncher(\"Launcher5\")\n+                .setDefaultArguments(\"--print-workdir\")\n@@ -137,2 +149,7 @@\n-                .setShortcuts(false, true)\n-                .applyTo(packageTest);\n+                .setShortcut(LauncherShortcut.LINUX_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_DESKTOP_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_START_MENU_SHORTCUT, null)\n+                .setProperty(\"main-jar\", \"another.jar\")\n+                .setProperty(\"main-class\", \"Welcome\");\n+\n+        new ShortcutStartupDirectoryVerifier(packageName).add(launcher5).applyTo(packageTest);\n@@ -193,0 +210,1 @@\n+            cfgs[0].applyToMainLauncher(cmd);\n@@ -196,1 +214,40 @@\n-            cfgs[0].applyToMainLauncher(cmd);\n+        }).run(RunnablePackageTest.Action.CREATE_AND_UNPACK);\n+    }\n+\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @Parameter(value = \"DEFAULT\")\n+    @Parameter(value = \"APP_DIR\")\n+    public void testLastArg(StartupDirectory startupDirectory) {\n+        final List<String> shortcutArgs = new ArrayList<>();\n+        if (TKit.isLinux()) {\n+            shortcutArgs.add(\"--linux-shortcut\");\n+        } else if (TKit.isWindows()) {\n+            shortcutArgs.add(\"--win-shortcut\");\n+        } else {\n+            TKit.assertUnexpected(\"Unsupported platform\");\n+        }\n+\n+        if (startupDirectory == StartupDirectory.APP_DIR) {\n+            shortcutArgs.add(startupDirectory.asStringValue());\n+        }\n+\n+        Path[] predefinedAppImage = new Path[1];\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            var cmd = JPackageCommand.helloAppImage()\n+                    .setArgumentValue(\"--name\", \"foo\")\n+                    .setFakeRuntime();\n+\n+            cmd.execute();\n+\n+            predefinedAppImage[0] = cmd.outputBundle();\n+        }).addInitializer(cmd -> {\n+            cmd.removeArgumentWithValue(\"--input\");\n+            cmd.setArgumentValue(\"--name\", \"AddLShortcutDir3Test\");\n+            cmd.addArguments(\"--app-image\", predefinedAppImage[0]);\n+            cmd.ignoreDefaultVerbose(true);\n+        }).addInitializer(cmd -> {\n+            cmd.addArguments(shortcutArgs);\n+        }).addBundleVerifier(cmd -> {\n+            TKit.assertEquals(shortcutArgs.getLast(), cmd.getAllArguments().getLast(),\n+                    \"Check the last argument of jpackage command line\");\n@@ -210,0 +267,1 @@\n+    @Parameter(value = \"APP_DIR\")\n@@ -222,17 +280,1 @@\n-        var shortcutStartupDirectoryVerifier = new ShortcutStartupDirectoryVerifier(name, \"a\");\n-\n-        shortcutStartupDirectoryVerifier.applyTo(test, startupDirectory);\n-\n-        test.addInstallVerifier(cmd -> {\n-            if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n-                Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n-                if (TKit.isLinux()) {\n-                    invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n-                } else if (TKit.isWindows()) {\n-                    invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n-                } else {\n-                    throw new UnsupportedOperationException();\n-                }\n-                shortcutStartupDirectoryVerifier.verify(invokeShortcutSpecs);\n-            }\n-        });\n+        new ShortcutStartupDirectoryVerifier(name).add(\"a\", startupDirectory).applyTo(test);\n@@ -244,4 +286,4 @@\n-    private record ShortcutStartupDirectoryVerifier(String packageName, String launcherName) {\n-        ShortcutStartupDirectoryVerifier {\n-            Objects.requireNonNull(packageName);\n-            Objects.requireNonNull(launcherName);\n+    private static final class ShortcutStartupDirectoryVerifier {\n+\n+        ShortcutStartupDirectoryVerifier(String packageName) {\n+            this.packageName = Objects.requireNonNull(packageName);\n@@ -250,6 +292,22 @@\n-        void applyTo(PackageTest test, StartupDirectory startupDirectory) {\n-            var al = new AdditionalLauncher(launcherName);\n-            al.setShortcut(shortcut(), Objects.requireNonNull(startupDirectory));\n-            al.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n-                    outputDirVarName(), expectedOutputFilename()));\n-            al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+        void applyTo(PackageTest test) {\n+            verifiers.values().forEach(verifier -> {\n+                verifier.applyTo(test);\n+            });\n+            test.addInstallVerifier(cmd -> {\n+                if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n+                    Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n+                    if (TKit.isLinux()) {\n+                        invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n+                    } else if (TKit.isWindows()) {\n+                        invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+\n+                    var invokeShortcutSpecsMap = invokeShortcutSpecs.stream().collect(Collectors.groupingBy(InvokeShortcutSpec::launcherName));\n+\n+                    for (var e : verifiers.entrySet()) {\n+                        e.getValue().verify(invokeShortcutSpecsMap.get(e.getKey()));\n+                    }\n+                }\n+            });\n@@ -258,1 +316,4 @@\n-        void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n+        ShortcutStartupDirectoryVerifier add(String launcherName, StartupDirectory startupDirectory) {\n+            return add(new AdditionalLauncher(launcherName)\n+                    .setShortcut(shortcut(), Objects.requireNonNull(Objects.requireNonNull(startupDirectory))));\n+        }\n@@ -260,1 +321,5 @@\n-            TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName));\n+        ShortcutStartupDirectoryVerifier add(AdditionalLauncher addLauncher) {\n+            var launcherVerifier = new LauncherVerifier(addLauncher);\n+            verifiers.put(launcherVerifier.launcherName(), launcherVerifier);\n+            return this;\n+        }\n@@ -262,1 +327,0 @@\n-            var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n@@ -264,1 +328,1 @@\n-            TKit.deleteIfExists(expectedOutputFile);\n+        private final class LauncherVerifier {\n@@ -266,3 +330,3 @@\n-            var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n-                return launcherName.equals(v.launcherName());\n-            }).findAny().orElseThrow();\n+            private LauncherVerifier(AdditionalLauncher addLauncher) {\n+                this.addLauncher = Objects.requireNonNull(addLauncher);\n+            }\n@@ -270,1 +334,3 @@\n-            invokeShortcutSpec.execute();\n+            private String launcherName() {\n+                return addLauncher.name();\n+            }\n@@ -272,3 +338,5 @@\n-            \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n-            \/\/ way to make it wait for exit of a process it triggers.\n-            TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n+            private void applyTo(PackageTest test) {\n+                addLauncher.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n+                        outputDirVarName(), expectedOutputFilename()));\n+                addLauncher.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+            }\n@@ -276,2 +344,5 @@\n-            TKit.assertFileExists(expectedOutputFile);\n-            var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n+            private void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n+                Objects.requireNonNull(invokeShortcutSpecs);\n+                if (invokeShortcutSpecs.isEmpty()) {\n+                    throw new IllegalArgumentException();\n+                }\n@@ -279,1 +350,1 @@\n-            var outputPrefix = \"$CD=\";\n+                TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName()));\n@@ -281,1 +352,1 @@\n-            TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+                var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n@@ -283,9 +354,16 @@\n-            invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n-                TKit.assertEquals(\n-                        expectedWorkDirectory,\n-                        Path.of(actualStr.substring(outputPrefix.length())),\n-                        String.format(\"Check work directory of %s of launcher [%s]\",\n-                                invokeShortcutSpec.shortcut().propertyName(),\n-                                invokeShortcutSpec.launcherName()));\n-            });\n-        }\n+                TKit.deleteIfExists(expectedOutputFile);\n+\n+                var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n+                    return launcherName().equals(v.launcherName());\n+                }).findAny().orElseThrow();\n+\n+                invokeShortcutSpec.execute();\n+\n+                \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n+                \/\/ way to make it wait for exit of a process it triggers.\n+                TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n+\n+                TKit.assertFileExists(expectedOutputFile);\n+                var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n+\n+                var outputPrefix = \"$CD=\";\n@@ -293,2 +371,17 @@\n-        private String expectedOutputFilename() {\n-            return String.format(\"%s-%s.out\", packageName, launcherName);\n+                TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+\n+                invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n+                    TKit.assertEquals(\n+                            expectedWorkDirectory,\n+                            Path.of(actualStr.substring(outputPrefix.length())),\n+                            String.format(\"Check work directory of %s of launcher [%s]\",\n+                                    invokeShortcutSpec.shortcut().propertyName(),\n+                                    invokeShortcutSpec.launcherName()));\n+                });\n+            }\n+\n+            private String expectedOutputFilename() {\n+                return String.format(\"%s-%s.out\", packageName, launcherName());\n+            }\n+\n+            private final AdditionalLauncher addLauncher;\n@@ -297,1 +390,2 @@\n-        private String outputDirVarName() {\n+\n+        private static String outputDirVarName() {\n@@ -307,1 +401,1 @@\n-        private LauncherShortcut shortcut() {\n+        private static LauncherShortcut shortcut() {\n@@ -316,0 +410,4 @@\n+\n+        private final String packageName;\n+        \/\/ Keep the order\n+        private final Map<String, LauncherVerifier> verifiers = new LinkedHashMap<>();\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":162,"deletions":64,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -579,0 +579,3 @@\n+        invalidShortcut(testCases::add, \"--win-menu\");\n+        invalidShortcut(testCases::add, \"--win-shortcut\");\n+\n@@ -645,0 +648,2 @@\n+        invalidShortcut(testCases::add, \"--linux-shortcut\");\n+\n@@ -700,0 +705,7 @@\n+    private static void invalidShortcut(Consumer<TestSpec> accumulator, String shortcutOption) {\n+        Objects.requireNonNull(shortcutOption);\n+        Stream.of(\"true\", \"false\", \"\").map(value -> {\n+            return testSpec().nativeType().addArgs(shortcutOption, value).error(\"error.invalid-option-value\", value, shortcutOption).create();\n+        }).forEach(accumulator);\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}