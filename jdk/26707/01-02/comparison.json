{"files":[{"patch":"@@ -57,0 +57,4 @@\n+    public String name() {\n+        return name;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        private final static Map<String, StartupDirectory> VALUE_MAP =\n+        private static final Map<String, StartupDirectory> VALUE_MAP =\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.LinkedHashMap;\n@@ -32,0 +33,1 @@\n+import java.util.Map;\n@@ -34,0 +36,1 @@\n+import java.util.stream.Collectors;\n@@ -40,0 +43,1 @@\n+import jdk.jpackage.test.HelloApp;\n@@ -41,0 +45,1 @@\n+import jdk.jpackage.test.JavaAppDesc;\n@@ -66,0 +71,1 @@\n+ * @requires (os.family != \"mac\")\n@@ -79,0 +85,1 @@\n+ * @requires (os.family != \"mac\")\n@@ -88,1 +95,1 @@\n-    @Test\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n@@ -96,0 +103,2 @@\n+        final var packageName = MethodHandles.lookup().lookupClass().getSimpleName();\n+\n@@ -105,0 +114,5 @@\n+\n+            cmd.setArgumentValue(\"--name\", packageName);\n+\n+            var addLauncherApp = TKit.TEST_SRC_ROOT.resolve(\"apps\/PrintEnv.java\");\n+            HelloApp.createBundle(JavaAppDesc.parse(addLauncherApp + \"*another.jar:Welcome\"), cmd.inputDir());\n@@ -107,3 +121,1 @@\n-        new FileAssociations(\n-                MethodHandles.lookup().lookupClass().getSimpleName()).applyTo(\n-                packageTest);\n+        new FileAssociations(packageName).applyTo(packageTest);\n@@ -134,2 +146,2 @@\n-        new AdditionalLauncher(\"Launcher5\")\n-                .setDefaultArguments()\n+        var launcher5 = new AdditionalLauncher(\"Launcher5\")\n+                .setDefaultArguments(\"--print-workdir\")\n@@ -137,2 +149,7 @@\n-                .setShortcuts(false, true)\n-                .applyTo(packageTest);\n+                .setShortcut(LauncherShortcut.LINUX_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_DESKTOP_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_START_MENU_SHORTCUT, null)\n+                .setProperty(\"main-jar\", \"another.jar\")\n+                .setProperty(\"main-class\", \"Welcome\");\n+\n+        new ShortcutStartupDirectoryVerifier(packageName).add(launcher5).applyTo(packageTest);\n@@ -263,17 +280,1 @@\n-        var shortcutStartupDirectoryVerifier = new ShortcutStartupDirectoryVerifier(name, \"a\");\n-\n-        shortcutStartupDirectoryVerifier.applyTo(test, startupDirectory);\n-\n-        test.addInstallVerifier(cmd -> {\n-            if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n-                Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n-                if (TKit.isLinux()) {\n-                    invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n-                } else if (TKit.isWindows()) {\n-                    invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n-                } else {\n-                    throw new UnsupportedOperationException();\n-                }\n-                shortcutStartupDirectoryVerifier.verify(invokeShortcutSpecs);\n-            }\n-        });\n+        new ShortcutStartupDirectoryVerifier(name).add(\"a\", startupDirectory).applyTo(test);\n@@ -285,4 +286,4 @@\n-    private record ShortcutStartupDirectoryVerifier(String packageName, String launcherName) {\n-        ShortcutStartupDirectoryVerifier {\n-            Objects.requireNonNull(packageName);\n-            Objects.requireNonNull(launcherName);\n+    private static final class ShortcutStartupDirectoryVerifier {\n+\n+        ShortcutStartupDirectoryVerifier(String packageName) {\n+            this.packageName = Objects.requireNonNull(packageName);\n@@ -291,6 +292,22 @@\n-        void applyTo(PackageTest test, StartupDirectory startupDirectory) {\n-            var al = new AdditionalLauncher(launcherName);\n-            al.setShortcut(shortcut(), Objects.requireNonNull(startupDirectory));\n-            al.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n-                    outputDirVarName(), expectedOutputFilename()));\n-            al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+        void applyTo(PackageTest test) {\n+            verifiers.values().forEach(verifier -> {\n+                verifier.applyTo(test);\n+            });\n+            test.addInstallVerifier(cmd -> {\n+                if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n+                    Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n+                    if (TKit.isLinux()) {\n+                        invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n+                    } else if (TKit.isWindows()) {\n+                        invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+\n+                    var invokeShortcutSpecsMap = invokeShortcutSpecs.stream().collect(Collectors.groupingBy(InvokeShortcutSpec::launcherName));\n+\n+                    for (var e : verifiers.entrySet()) {\n+                        e.getValue().verify(invokeShortcutSpecsMap.get(e.getKey()));\n+                    }\n+                }\n+            });\n@@ -299,1 +316,4 @@\n-        void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n+        ShortcutStartupDirectoryVerifier add(String launcherName, StartupDirectory startupDirectory) {\n+            return add(new AdditionalLauncher(launcherName)\n+                    .setShortcut(shortcut(), Objects.requireNonNull(Objects.requireNonNull(startupDirectory))));\n+        }\n@@ -301,1 +321,5 @@\n-            TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName));\n+        ShortcutStartupDirectoryVerifier add(AdditionalLauncher addLauncher) {\n+            var launcherVerifier = new LauncherVerifier(addLauncher);\n+            verifiers.put(launcherVerifier.launcherName(), launcherVerifier);\n+            return this;\n+        }\n@@ -303,1 +327,0 @@\n-            var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n@@ -305,1 +328,1 @@\n-            TKit.deleteIfExists(expectedOutputFile);\n+        private final class LauncherVerifier {\n@@ -307,3 +330,3 @@\n-            var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n-                return launcherName.equals(v.launcherName());\n-            }).findAny().orElseThrow();\n+            private LauncherVerifier(AdditionalLauncher addLauncher) {\n+                this.addLauncher = Objects.requireNonNull(addLauncher);\n+            }\n@@ -311,1 +334,3 @@\n-            invokeShortcutSpec.execute();\n+            private String launcherName() {\n+                return addLauncher.name();\n+            }\n@@ -313,3 +338,5 @@\n-            \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n-            \/\/ way to make it wait for exit of a process it triggers.\n-            TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n+            private void applyTo(PackageTest test) {\n+                addLauncher.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n+                        outputDirVarName(), expectedOutputFilename()));\n+                addLauncher.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+            }\n@@ -317,2 +344,5 @@\n-            TKit.assertFileExists(expectedOutputFile);\n-            var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n+            private void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n+                Objects.requireNonNull(invokeShortcutSpecs);\n+                if (invokeShortcutSpecs.isEmpty()) {\n+                    throw new IllegalArgumentException();\n+                }\n@@ -320,1 +350,1 @@\n-            var outputPrefix = \"$CD=\";\n+                TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName()));\n@@ -322,1 +352,1 @@\n-            TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+                var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n@@ -324,9 +354,11 @@\n-            invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n-                TKit.assertEquals(\n-                        expectedWorkDirectory,\n-                        Path.of(actualStr.substring(outputPrefix.length())),\n-                        String.format(\"Check work directory of %s of launcher [%s]\",\n-                                invokeShortcutSpec.shortcut().propertyName(),\n-                                invokeShortcutSpec.launcherName()));\n-            });\n-        }\n+                TKit.deleteIfExists(expectedOutputFile);\n+\n+                var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n+                    return launcherName().equals(v.launcherName());\n+                }).findAny().orElseThrow();\n+\n+                invokeShortcutSpec.execute();\n+\n+                \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n+                \/\/ way to make it wait for exit of a process it triggers.\n+                TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n@@ -334,2 +366,22 @@\n-        private String expectedOutputFilename() {\n-            return String.format(\"%s-%s.out\", packageName, launcherName);\n+                TKit.assertFileExists(expectedOutputFile);\n+                var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n+\n+                var outputPrefix = \"$CD=\";\n+\n+                TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+\n+                invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n+                    TKit.assertEquals(\n+                            expectedWorkDirectory,\n+                            Path.of(actualStr.substring(outputPrefix.length())),\n+                            String.format(\"Check work directory of %s of launcher [%s]\",\n+                                    invokeShortcutSpec.shortcut().propertyName(),\n+                                    invokeShortcutSpec.launcherName()));\n+                });\n+            }\n+\n+            private String expectedOutputFilename() {\n+                return String.format(\"%s-%s.out\", packageName, launcherName());\n+            }\n+\n+            private final AdditionalLauncher addLauncher;\n@@ -338,1 +390,2 @@\n-        private String outputDirVarName() {\n+\n+        private static String outputDirVarName() {\n@@ -348,1 +401,1 @@\n-        private LauncherShortcut shortcut() {\n+        private static LauncherShortcut shortcut() {\n@@ -357,0 +410,4 @@\n+\n+        private final String packageName;\n+        \/\/ Keep the order\n+        private final Map<String, LauncherVerifier> verifiers = new LinkedHashMap<>();\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":120,"deletions":63,"binary":false,"changes":183,"status":"modified"}]}