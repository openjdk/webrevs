{"files":[{"patch":"@@ -64,4 +64,3 @@\n- * <p> The version field holds a value that describes the type of this {@code\n- * UUID}.  There are four different basic types of UUIDs: time-based, DCE\n- * security, name-based, and randomly generated UUIDs.  These types have a\n- * version value of 1, 2, 3 and 4, respectively.\n+ * <p> See <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html\">\n+ * <i>RFC 9562: Universally Unique Identifiers (UUIDs)<\/i><\/a> for the complete specification,\n+ * including algorithms used to create {@code UUID}s.\n@@ -69,4 +68,4 @@\n- * <p> For more information including algorithms used to create {@code UUID}s,\n- * see <a href=\"http:\/\/www.ietf.org\/rfc\/rfc4122.txt\"> <i>RFC&nbsp;4122: A\n- * Universally Unique IDentifier (UUID) URN Namespace<\/i><\/a>, section 4.2\n- * &quot;Algorithms for Creating a Time-Based UUID&quot;.\n+ * <p> There are eight defined types of UUIDs, each identified by a version number:\n+ * time-based (version 1), DCE security (version 2), name-based with MD5 (version 3),\n+ * randomly generated (version 4), name-based with SHA-1 (version 5), reordered time-based (version 6),\n+ * Unix epoch time-based (version 7), and custom-defined layout (version 8).\n@@ -74,2 +73,2 @@\n- * @spec https:\/\/www.rfc-editor.org\/info\/rfc4122\n- *      RFC 4122: A Universally Unique IDentifier (UUID) URN Namespace\n+ * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html\n+ *      RFC 9562 Universally Unique IDentifiers (UUIDs)\n@@ -79,0 +78,1 @@\n+\n@@ -183,0 +183,60 @@\n+    \/**\n+     * Creates a {@code UUIDv7} {@code UUID} from the given Unix Epoch timestamp.\n+     *\n+     * The returned {@code UUID} will have the given {@code timestamp} in\n+     * the first 6 bytes, followed by the version and variant bits representing {@code UUIDv7},\n+     * and the remaining bytes will contain random data from a cryptographically strong\n+     * pseudo-random number generator.\n+     *\n+     * @apiNote {@code UUIDv7} values are created by allocating a Unix timestamp in milliseconds\n+     * in the most significant 48 bits and filling the remaining 74 bits, excluding the required\n+     * version and variant bits, with random bits. As such, this method rejects {@code timestamp}\n+     * values that do not fit into 48 bits.\n+     * <p>\n+     * Monotonicity (each subsequent value being greater than the last) is a primary characteristic\n+     * of {@code UUIDv7} values. This is due to the {@code timestamp} value being part of the {@code UUID}.\n+     * Callers of this method that wish to generate monotonic {@code UUIDv7} values are expected to\n+     * ensure that the given {@code timestamp} value is monotonic.\n+     *\n+     *\n+     * @param timestamp the number of milliseconds since midnight 1 Jan 1970 UTC,\n+     *                 leap seconds excluded.\n+     *\n+     * @return a {@code UUID} constructed using the given {@code timestamp}\n+     *\n+     * @throws IllegalArgumentException if the timestamp is negative or greater than {@code 281474976710655L}\n+     *\n+     * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html\n+     *       RFC 9562 Universally Unique IDentifiers (UUIDs)\n+     *\n+     * @since 26\n+     *\n+     *\/\n+    public static UUID epochMillis(long timestamp) {\n+        if ((timestamp >> 48) != 0) {\n+            throw new IllegalArgumentException(\"Supplied timestamp: \" + timestamp + \"does not fit within 48 bits\");\n+        }\n+\n+        SecureRandom ng = Holder.numberGenerator;\n+        byte[] randomBytes = new byte[16];\n+        ng.nextBytes(randomBytes);\n+\n+        \/\/ Embed the timestamp into the first 6 bytes\n+        randomBytes[0] = (byte)(timestamp >>> 40);\n+        randomBytes[1] = (byte)(timestamp >>> 32);\n+        randomBytes[2] = (byte)(timestamp >>> 24);\n+        randomBytes[3] = (byte)(timestamp >>> 16);\n+        randomBytes[4] = (byte)(timestamp >>> 8);\n+        randomBytes[5] = (byte)(timestamp);\n+\n+        \/\/ Set version to 7\n+        randomBytes[6] &= 0x0f;\n+        randomBytes[6] |= 0x70;\n+\n+        \/\/ Set variant to IETF\n+        randomBytes[8] &= 0x3f;\n+        randomBytes[8] |= (byte) 0x80;\n+\n+        return new UUID(randomBytes);\n+    }\n+\n@@ -325,0 +385,1 @@\n+     * <li>7    Unix Epoch time-based UUID\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":71,"deletions":10,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+        epochMillisTest();\n+        epochMillisTest_Multi();\n+        epochMillis_userInputTest();\n@@ -149,0 +152,38 @@\n+    private static void epochMillis_userInputTest() {\n+        \/\/ Should not throw for valid currentTimeMillis() timestamp\n+        long timestamp = System.currentTimeMillis();\n+        try {\n+            UUID u = UUID.epochMillis(timestamp);\n+            if (u == null) {\n+                throw new AssertionError(\"Generated UUID should not be null for timestamp: \" + timestamp);\n+            }\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Unexpected exception with timestamp \" + timestamp + \": \" + e);\n+        }\n+\n+        \/\/ Should not throw for the 48-bit long\n+        long value = 0xFEDCBA987654L;\n+        try {\n+            UUID u = UUID.epochMillis(value);\n+            if (u == null) {\n+                throw new AssertionError(\"Generated UUID should not be null for 48-bit long: \" + value);\n+            }\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Unexpected exception with 48-bit long \" + value + \": \" + e);\n+        }\n+\n+        \/\/ Should throw for negative timestamp\n+        value = -0xFEDCBA987654L;\n+        try {\n+            UUID.epochMillis(value);\n+            throw new AssertionError(\"Expected IllegalArgumentException with negative timestamp: \" + value);\n+        } catch (IllegalArgumentException expected) {}\n+\n+        \/\/ Should throw for timestamp > 48 bits\n+        value = 1L << 48;\n+        try {\n+            UUID.epochMillis(value);\n+            throw new AssertionError(\"Expected IllegalArgumentException with timestamp > 48 bits: \" + value);\n+        } catch (IllegalArgumentException expected) {}\n+    }\n+\n@@ -190,0 +231,9 @@\n+        long timestamp = System.currentTimeMillis();\n+        test = UUID.epochMillis(timestamp);\n+        if (test.version() != 7) {\n+            throw new Exception(\"epochMillis not type 7: \" + test);\n+        }\n+        if (test.variant() != 2) {\n+            throw new Exception(\"epochMillis not variant 2: \" + test);\n+        }\n+\n","filename":"test\/jdk\/java\/util\/UUID\/UUIDTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"}]}