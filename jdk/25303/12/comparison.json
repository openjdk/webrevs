{"files":[{"patch":"@@ -64,4 +64,4 @@\n- * <p> The version field holds a value that describes the type of this {@code\n- * UUID}.  There are four different basic types of UUIDs: time-based, DCE\n- * security, name-based, and randomly generated UUIDs.  These types have a\n- * version value of 1, 2, 3 and 4, respectively.\n+ * <p> There are eight defined types of UUIDs, each identified by a version number:\n+ * time-based (version 1), DCE security (version 2), name-based with MD5 (version 3),\n+ * randomly generated (version 4), name-based with SHA-1 (version 5), reordered time-based (version 6),\n+ * Unix epoch time-based (version 7), and custom-defined layout (version 8).\n@@ -74,2 +74,2 @@\n- * @spec https:\/\/www.rfc-editor.org\/info\/rfc4122\n- *      RFC 4122: A Universally Unique IDentifier (UUID) URN Namespace\n+ * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html\n+ *      RFC 9562 Universally Unique IDentifiers (UUIDs)\n@@ -79,0 +79,1 @@\n+\n@@ -97,0 +98,12 @@\n+    \/**\n+     * Record a fixed point in nano-time corresponding to a fix point in System.currentTimeMillis()\n+     * and use the delta from the current nano-time as the current nano-time.\n+     *\/\n+    private static final long ORIGIN_MS = System.currentTimeMillis();\n+\n+    private static final long ORIGIN_NS = System.nanoTime();\n+\n+    private static long monotonicMS() {\n+        return ORIGIN_MS + (System.nanoTime() - ORIGIN_NS) \/ 1_000_000;\n+    }\n+\n@@ -183,0 +196,73 @@\n+    \/**\n+     * Static factory to create a version 7 (Unix epoch time-based) {@code UUID} with the current\n+     * Unix timestamp in milliseconds.\n+     *\n+     * The {@code UUID} embeds the current Unix Epoch timestamp in milliseconds using\n+     * {@link System#currentTimeMillis()} into the first 6 bytes, sets the version and\n+     * variant bits as per the specification and fills the remaining bytes with random\n+     * data from a cryptographically strong pseudo-random number generator.\n+     *\n+     * @return a {@code UUID} generated with the current Unix timestamp\n+     *\n+     * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html\n+     *       RFC 9562 Universally Unique IDentifiers (UUIDs)\n+     *\n+     * @since 26\n+     *\/\n+    public static UUID unixEpochTimeMillis() {\n+        long timestamp = monotonicMS();\n+        return unixEpochTimeMillis(timestamp);\n+    }\n+\n+    \/**\n+     * Static factory to create a version 7 (time-based) {@code UUID} with a user-supplied\n+     * Unix timestamp in milliseconds.\n+     *\n+     * The {@code UUID} embeds the provided Unix Epoch timestamp in milliseconds into\n+     * the first 6 bytes, sets the version and variant bits as per the specification,\n+     * and fills the remaining bytes with random data from a cryptographically strong\n+     * pseudo-random number generator.\n+     *\n+     * @apiNote The timestamp must be a Unix Epoch timestamp in milliseconds in order\n+     * to be compliant with <a href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc9562\">RFC 9562<\/a>.\n+     *\n+     * @param timestamp\n+     *        A Unix epoch timestamp in milliseconds which must fit in to 48 bits\n+     *\n+     * @return a {@code UUID} generated using the provided timestamp\n+     *\n+     * @throws IllegalArgumentException if the timestamp is negative or exceeds 48 bits\n+     *\n+     * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html\n+     *       RFC 9562 Universally Unique IDentifiers (UUIDs)\n+     *\n+     * @since 26\n+     * *\/\n+    public static UUID unixEpochTimeMillis(long timestamp) {\n+        if ((timestamp >> 48) != 0) {\n+            throw new IllegalArgumentException(\"Timestamp must be an unsigned 48-bit Unix Epoch time in milliseconds.\");\n+        }\n+\n+        SecureRandom ng = Holder.numberGenerator;\n+        byte[] randomBytes = new byte[16];\n+        ng.nextBytes(randomBytes);\n+\n+        \/\/ Embed the timestamp into the first 6 bytes\n+        randomBytes[0] = (byte)(timestamp >>> 40);\n+        randomBytes[1] = (byte)(timestamp >>> 32);\n+        randomBytes[2] = (byte)(timestamp >>> 24);\n+        randomBytes[3] = (byte)(timestamp >>> 16);\n+        randomBytes[4] = (byte)(timestamp >>> 8);\n+        randomBytes[5] = (byte)(timestamp);\n+\n+        \/\/ Set version to 7\n+        randomBytes[6] &= 0x0f;\n+        randomBytes[6] |= 0x70;\n+\n+        \/\/ Set variant to IETF\n+        randomBytes[8] &= 0x3f;\n+        randomBytes[8] |= (byte) 0x80;\n+\n+        return new UUID(randomBytes);\n+    }\n+\n@@ -325,0 +411,1 @@\n+     * <li>7    Unix Epoch time-based UUID\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":93,"deletions":6,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+        unixEpochTimeMillisTest();\n+        unixEpochTimeMillisTest_Multi();\n+        unixEpochTimeMillis_userInputTest();\n@@ -149,0 +152,75 @@\n+    private static void unixEpochTimeMillisTest() throws Exception {\n+        List<UUID> collisions = new ArrayList<>();\n+\n+        Set<UUID> set = new HashSet<>();\n+        for (int i = 0; i < COUNT; i++) {\n+            UUID u = UUID.unixEpochTimeMillis();\n+            if (u.version() != 7) {\n+                throw new Exception(\"Bad version: \" + u);\n+            }\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n+            }\n+            if (!set.add(u)) {\n+                collisions.add(u);\n+            }\n+        }\n+\n+        if (!collisions.isEmpty()) {\n+            \/\/ This is extremely unlikely to happen. If you see this failure,\n+            \/\/ this highly likely points to the implementation bug, rather than\n+            \/\/ the odd chance.\n+            throw new Exception(\"UUID collisions detected: \" + collisions);\n+        }\n+    }\n+\n+    private static void unixEpochTimeMillisTest_Multi() throws Exception {\n+        List<UUID> uuids = IntStream.range(0, COUNT).parallel()\n+                .mapToObj(i -> UUID.unixEpochTimeMillis())\n+                .toList();\n+\n+        List<UUID> collisions = new ArrayList<>();\n+\n+        Set<UUID> set = new HashSet<>();\n+        for (UUID u : uuids) {\n+            if (u.version() != 7) {\n+                throw new Exception(\"Bad version: \" + u);\n+            }\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n+            }\n+            if (!set.add(u)) {\n+                collisions.add(u);\n+            }\n+        }\n+\n+        if (!collisions.isEmpty()) {\n+            \/\/ This is extremely unlikely to happen. If you see this failure,\n+            \/\/ this highly likely points to the implementation bug, rather than\n+            \/\/ the odd chance.\n+            throw new Exception(\"UUID collisions detected: \" + collisions);\n+        }\n+    }\n+\n+    private static void unixEpochTimeMillis_userInputTest() {\n+        \/\/ Should not throw for valid timestamp\n+        try {\n+            long now = System.currentTimeMillis();\n+            UUID u = UUID.unixEpochTimeMillis(now);\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Unexpected exception with valid timestamp: \" + e);\n+        }\n+\n+        \/\/ Should throw for negative timestamp\n+        try {\n+            UUID.unixEpochTimeMillis(-1);\n+            throw new AssertionError(\"Expected IllegalArgumentException with negative timestamp\");\n+        } catch (IllegalArgumentException expected) {}\n+\n+        \/\/ Should throw for timestamp > 48 bits\n+        try {\n+            UUID.unixEpochTimeMillis(1L << 48);\n+            throw new AssertionError(\"Expected IllegalArgumentException with timestamp > 48 bits\");\n+        } catch (IllegalArgumentException expected) {}\n+    }\n+\n@@ -190,0 +268,5 @@\n+        test = UUID.unixEpochTimeMillis();\n+        if (test.version() != 7) {\n+            throw new Exception(\"timestampUUID not type 7: \" + test);\n+        }\n+\n@@ -242,0 +325,5 @@\n+        }\n+\n+        test = UUID.unixEpochTimeMillis();\n+        if (test.variant() != 2) {\n+            throw new Exception(\"timestampUUID not variant 2\");\n","filename":"test\/jdk\/java\/util\/UUID\/UUIDTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"}]}