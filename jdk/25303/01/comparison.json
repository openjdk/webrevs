{"files":[{"patch":"@@ -64,4 +64,4 @@\n- * <p> The version field holds a value that describes the type of this {@code\n- * UUID}.  There are four different basic types of UUIDs: time-based, DCE\n- * security, name-based, and randomly generated UUIDs.  These types have a\n- * version value of 1, 2, 3 and 4, respectively.\n+ * <p> There are eight defined types of UUIDs, each identified by a version number:\n+ * time-based (version 1), DCE security (version 2), name-based with MD5 (version 3),\n+ * randomly generated (version 4), name-based with SHA-1 (version 5), reordered time-based (version 6),\n+ * Unix epoch time-based (version 7), and custom-defined layout (version 8).\n@@ -74,2 +74,2 @@\n- * @spec https:\/\/www.rfc-editor.org\/info\/rfc4122\n- *      RFC 4122: A Universally Unique IDentifier (UUID) URN Namespace\n+ * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html\n+ *      RFC 9562 Universally Unique IDentifiers (UUIDs)\n@@ -184,0 +184,40 @@\n+    \/**\n+     * Static factory to retrieve a type 7 (time based) {@code UUID} based on\n+     * the current timestamp, enhanced with sub-millisecond precision.\n+     *\n+     * The {@code UUID} embeds the current Unix timestamp in milliseconds into\n+     * the first 6 bytes, sets the version and variant bits as per RFC 9562,\n+     * replaces the first 12 random bits with a value derived from the current\n+     * system clock's sub-millisecond precision, and fills the\n+     * remaining bytes with cryptographically strong random data.\n+     *\n+     * @return A {@code UUID} generated from the current system time\n+     *\n+     * @spec RFC 9562\n+     *\/\n+    public static UUID timestampUUID() {\n+        long msTime = System.currentTimeMillis();\n+        long nsTime = System.nanoTime();\n+        SecureRandom ng = Holder.numberGenerator;\n+        byte[] randomBytes = new byte[16];\n+        ng.nextBytes(randomBytes);\n+\n+        \/\/ Set the first 6 bytes to the ms time\n+        for (int i = 0; i < 6; i++) {\n+            randomBytes[i] = (byte) (msTime >>> (40 - 8 * i));\n+        }\n+\n+        \/\/ Scale sub-ms nanoseconds to a 12-bit value\n+        int nsBits = (int) ((nsTime % 1_000_000) \/ 1_000_000.0 * 4096);\n+\n+        \/\/ Set version and increased percision time bits\n+        randomBytes[6] = (byte) (0x70 | ((nsBits >>> 8) & 0x0F));\n+        randomBytes[7] = (byte) (nsBits & 0xFF);\n+\n+        \/\/ Set variant to 2\n+        randomBytes[8] &= 0x3F;\n+        randomBytes[8] |= (byte) 0x80;\n+\n+        return new UUID(randomBytes);\n+    }\n+\n@@ -326,0 +366,1 @@\n+     * <li>7    Unix timestamp-based UUID\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":47,"deletions":6,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+        timestampUUIDTest();\n+        timestampUUIDTest_Multi();\n@@ -149,0 +151,53 @@\n+    private static void timestampUUIDTest() throws Exception {\n+        List<UUID> collisions = new ArrayList<>();\n+\n+        Set<UUID> set = new HashSet<>();\n+        for (int i = 0; i < COUNT; i++) {\n+            UUID u = UUID.timestampUUID();\n+            if (u.version() != 7) {\n+                throw new Exception(\"Bad version: \" + u);\n+            }\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n+            }\n+            if (!set.add(u)) {\n+                collisions.add(u);\n+            }\n+        }\n+\n+        if (!collisions.isEmpty()) {\n+            \/\/ This is extremely unlikely to happen. If you see this failure,\n+            \/\/ this highly likely points to the implementation bug, rather than\n+            \/\/ the odd chance.\n+            throw new Exception(\"UUID collisions detected: \" + collisions);\n+        }\n+    }\n+\n+    private static void timestampUUIDTest_Multi() throws Exception {\n+        List<UUID> uuids = IntStream.range(0, COUNT).parallel()\n+                .mapToObj(i -> UUID.timestampUUID())\n+                .toList();\n+\n+        List<UUID> collisions = new ArrayList<>();\n+\n+        Set<UUID> set = new HashSet<>();\n+        for (UUID u : uuids) {\n+            if (u.version() != 7) {\n+                throw new Exception(\"Bad version: \" + u);\n+            }\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n+            }\n+            if (!set.add(u)) {\n+                collisions.add(u);\n+            }\n+        }\n+\n+        if (!collisions.isEmpty()) {\n+            \/\/ This is extremely unlikely to happen. If you see this failure,\n+            \/\/ this highly likely points to the implementation bug, rather than\n+            \/\/ the odd chance.\n+            throw new Exception(\"UUID collisions detected: \" + collisions);\n+        }\n+    }\n+\n@@ -190,0 +245,5 @@\n+        test = UUID.timestampUUID();\n+        if (test.version() != 7) {\n+            throw new Exception(\"timestampUUID not type 7: \" + test);\n+        }\n+\n@@ -242,0 +302,5 @@\n+        }\n+\n+        test = UUID.timestampUUID();\n+        if (test.variant() != 2) {\n+            throw new Exception(\"timestampUUID not variant 2\");\n","filename":"test\/jdk\/java\/util\/UUID\/UUIDTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"}]}