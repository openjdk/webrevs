{"files":[{"patch":"@@ -185,2 +185,2 @@\n-     * Static factory to retrieve a type 7 (time based) {@code UUID} based on\n-     * the current timestamp, enhanced with sub-millisecond precision.\n+     * Static factory to create a version 7 (time-based) {@code UUID} with the current\n+     * Unix timestamp in milliseconds.\n@@ -188,5 +188,4 @@\n-     * The {@code UUID} embeds the current Unix timestamp in milliseconds into\n-     * the first 6 bytes, sets the version and variant bits as per RFC 9562,\n-     * replaces the first 12 random bits with a value derived from the current\n-     * system clock's sub-millisecond precision, and fills the\n-     * remaining bytes with cryptographically strong random data.\n+     * The {@code UUID} embeds the current Unix Epoch timestamp in milliseconds using\n+     * {@link System#currentTimeMillis()} into the first 6 bytes, sets the version and\n+     * variant bits as per the specification and fills the remaining bytes with random\n+     * data from a cryptographically strong pseudo-random number generator.\n@@ -194,1 +193,1 @@\n-     * @return A {@code UUID} generated from the current system time\n+     * @return a {@code UUID} generated with the current Unix timestamp\n@@ -198,3 +197,31 @@\n-    public static UUID timestampUUID() {\n-        long msTime = System.currentTimeMillis();\n-        long nsTime = System.nanoTime();\n+    public static UUID unixEpochTimeMillis() {\n+        long timestamp = System.currentTimeMillis();\n+        return unixEpochTimeMillis(timestamp);\n+    }\n+\n+    \/**\n+     * Static factory to create a version 7 (time-based) {@code UUID} with a user-supplied\n+     * Unix timestamp in milliseconds.\n+     *\n+     * The {@code UUID} embeds the provided Unix Epoch timestamp in milliseconds into\n+     * the first 6 bytes, sets the version and variant bits as per the specification,\n+     * and fills the remaining bytes with random data from a cryptographically strong\n+     * pseudo-random number generator.\n+     *\n+     * <p><strong>Note:<\/strong> The timestamp must be a Unix Epoch timestamp in milliseconds in order\n+     * to be compliant with <a href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc9562\">RFC 9562<\/a>.\n+     *\n+     * @param timestamp\n+     *        A Unix epoch timestamp in milliseconds which must fit in to 48 bits\n+     *\n+     * @return a {@code UUID} generated using the provided timestamp\n+     *\n+     * @throws IllegalArgumentException if the timestamp is negative or exceeds 48 bits\n+     *\n+     * @spec RFC 9562\n+     *\/\n+    public static UUID unixEpochTimeMillis(long timestamp) {\n+        if (timestamp < 0 || (timestamp >>> 48) != 0) {\n+            throw new IllegalArgumentException(\"Timestamp must be a 48-bit Unix Epoch time in milliseconds.\");\n+        }\n+\n@@ -205,1 +232,1 @@\n-        \/\/ Set the first 6 bytes to the ms time\n+        \/\/ Embed the timestamp into the first 6 bytes\n@@ -207,1 +234,1 @@\n-            randomBytes[i] = (byte) (msTime >>> (40 - 8 * i));\n+            randomBytes[i] = (byte) (timestamp >>> (40 - 8 * i));\n@@ -210,6 +237,3 @@\n-        \/\/ Scale sub-ms nanoseconds to a 12-bit value\n-        int nsBits = (int) ((nsTime % 1_000_000) \/ 1_000_000.0 * 4096);\n-\n-        \/\/ Set version and increased precision time bits\n-        randomBytes[6] = (byte) (0x70 | ((nsBits >>> 8) & 0x0F));\n-        randomBytes[7] = (byte) (nsBits & 0xFF);\n+        \/\/ Set version to 7\n+        randomBytes[6] &= 0x0f;\n+        randomBytes[6] |= 0x70;\n@@ -217,2 +241,2 @@\n-        \/\/ Set variant to 2\n-        randomBytes[8] &= 0x3F;\n+        \/\/ Set variant to IETF\n+        randomBytes[8] &= 0x3f;\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":45,"deletions":21,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -50,2 +50,3 @@\n-        timestampUUIDTest();\n-        timestampUUIDTest_Multi();\n+        unixEpochTimeMillisTest();\n+        unixEpochTimeMillisTest_Multi();\n+        unixEpochTimeMillis_userInputTest();\n@@ -151,1 +152,1 @@\n-    private static void timestampUUIDTest() throws Exception {\n+    private static void unixEpochTimeMillisTest() throws Exception {\n@@ -156,1 +157,1 @@\n-            UUID u = UUID.timestampUUID();\n+            UUID u = UUID.unixEpochTimeMillis();\n@@ -176,1 +177,1 @@\n-    private static void timestampUUIDTest_Multi() throws Exception {\n+    private static void unixEpochTimeMillisTest_Multi() throws Exception {\n@@ -178,1 +179,1 @@\n-                .mapToObj(i -> UUID.timestampUUID())\n+                .mapToObj(i -> UUID.unixEpochTimeMillis())\n@@ -204,0 +205,22 @@\n+    private static void unixEpochTimeMillis_userInputTest() {\n+        \/\/ Should not throw for valid timestamp\n+        try {\n+            long now = System.currentTimeMillis();\n+            UUID u = UUID.unixEpochTimeMillis(now);\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Unexpected exception with valid timestamp: \" + e);\n+        }\n+\n+        \/\/ Should throw for negative timestamp\n+        try {\n+            UUID.unixEpochTimeMillis(-1);\n+            throw new AssertionError(\"Expected IllegalArgumentException with negative timestamp\");\n+        } catch (IllegalArgumentException expected) {}\n+\n+        \/\/ Should throw for timestamp > 48 bits\n+        try {\n+            UUID.unixEpochTimeMillis(1L << 48);\n+            throw new AssertionError(\"Expected IllegalArgumentException with timestamp > 48 bits\");\n+        } catch (IllegalArgumentException expected) {}\n+    }\n+\n@@ -245,1 +268,1 @@\n-        test = UUID.timestampUUID();\n+        test = UUID.unixEpochTimeMillis();\n@@ -304,1 +327,1 @@\n-        test = UUID.timestampUUID();\n+        test = UUID.unixEpochTimeMillis();\n","filename":"test\/jdk\/java\/util\/UUID\/UUIDTest.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"}]}