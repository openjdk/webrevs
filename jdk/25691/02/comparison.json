{"files":[{"patch":"@@ -1123,3 +1123,1 @@\n-     * unspecified exceptions being thrown. Examples of such problematic operations are\n-     * {@link java.nio.channels.AsynchronousSocketChannel#read(ByteBuffer)} and\n-     * {@link java.nio.channels.AsynchronousSocketChannel#write(ByteBuffer)}.\n+     * unspecified exceptions being thrown.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n@@ -100,1 +102,2 @@\n-     *          If the buffer is read-only\n+     *          If the buffer is read-only or a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -131,1 +134,2 @@\n-     *          If the buffer is read-only\n+     *          If the buffer is read-only or a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -180,0 +184,3 @@\n+     * @throws  IllegalArgumentException\n+     *          If the buffer is a view of a {@link MemorySegment} allocated from a\n+     *          {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -208,0 +215,3 @@\n+     * @throws  IllegalArgumentException\n+     *          If the buffer is a view of a {@link MemorySegment} allocated from a\n+     *          {@linkplain Arena#ofConfined() thread-confined arena}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/AsynchronousByteChannel.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n@@ -696,1 +698,3 @@\n-     *          If the position is negative or the buffer is read-only\n+     *          If the position is negative, or the buffer is read-only or a view of a\n+     *          {@link MemorySegment} allocated from a {@linkplain Arena#ofConfined()\n+     *          thread-confined arena}\n@@ -731,1 +735,3 @@\n-     *          If the position is negative or the buffer is read-only\n+     *          If the position is negative, or the buffer is read-only or a view of a\n+     *          {@link MemorySegment} allocated from a {@linkplain Arena#ofConfined()\n+     *          thread-confined arena}\n@@ -762,1 +768,3 @@\n-     *          If the position is negative\n+     *          If the position is negative or the buffer is a view of a {@link\n+     *          MemorySegment} allocated from a {@linkplain Arena#ofConfined()\n+     *          thread-confined arena}\n@@ -798,1 +806,3 @@\n-     *          If the position is negative\n+     *          If the position is negative or the buffer is a view of a {@link\n+     *          MemorySegment} allocated from a {@linkplain Arena#ofConfined()\n+     *          thread-confined arena}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/AsynchronousFileChannel.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n@@ -382,1 +384,2 @@\n-     *          If the buffer is read-only\n+     *          If the buffer is read-only or a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -491,1 +494,2 @@\n-     *          If the buffer is read-only\n+     *          If any of the buffers is read-only or a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -541,0 +545,3 @@\n+     * @throws  IllegalArgumentException\n+     *          If the buffer is a view of a {@link MemorySegment} allocated from\n+     *          a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -555,0 +562,1 @@\n+     * @throws  IllegalArgumentException       {@inheritDoc}\n@@ -571,0 +579,1 @@\n+     * @throws  IllegalArgumentException    {@inheritDoc}\n@@ -641,0 +650,3 @@\n+     * @throws  IllegalArgumentException\n+     *          If any of the buffers is a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/AsynchronousSocketChannel.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -43,0 +45,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -218,0 +222,4 @@\n+        if (dst.isReadOnly())\n+            throw new IllegalArgumentException(\"Read-only buffer\");\n+        if (NIO_ACCESS.isThreadConfined(dst))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -229,0 +237,4 @@\n+        if (dst.isReadOnly())\n+            throw new IllegalArgumentException(\"Read-only buffer\");\n+        if (NIO_ACCESS.isThreadConfined(dst))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -240,0 +252,2 @@\n+        if (NIO_ACCESS.isThreadConfined(src))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -251,0 +265,2 @@\n+        if (NIO_ACCESS.isThreadConfined(src))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousFileChannelImpl.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -53,0 +55,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -284,0 +288,2 @@\n+        if (NIO_ACCESS.isThreadConfined(dst))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -298,0 +304,2 @@\n+        if (NIO_ACCESS.isThreadConfined(dst))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -313,3 +321,3 @@\n-        ByteBuffer[] bufs = Util.subsequence(dsts, offset, length);\n-        for (int i=0; i<bufs.length; i++) {\n-            if (bufs[i].isReadOnly())\n+        dsts = Util.subsequence(dsts, offset, length);\n+        for (ByteBuffer dst : dsts) {\n+            if (dst.isReadOnly())\n@@ -317,0 +325,2 @@\n+            if (NIO_ACCESS.isThreadConfined(dst))\n+                throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -318,1 +328,1 @@\n-        read(true, null, bufs, timeout, unit, attachment, handler);\n+        read(true, null, dsts, timeout, unit, attachment, handler);\n@@ -387,0 +397,2 @@\n+        if (NIO_ACCESS.isThreadConfined(src))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -399,0 +411,2 @@\n+        if (NIO_ACCESS.isThreadConfined(src))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -415,0 +429,5 @@\n+        for (ByteBuffer src : srcs) {\n+            if (NIO_ACCESS.isThreadConfined(src)) {\n+                throw new IllegalArgumentException(\"Buffer is thread confined\");\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-            throw new IllegalStateException(\"Confined session not supported\");\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n@@ -82,2 +83,2 @@\n-                    handler -> handler.propagateHandlerFromFuture(channel.write(bb)),\n-                    handler -> handler.propagateHandlerFromFuture(channel.read(bb)),\n+                    handler -> channel.write(bb),\n+                    handler -> channel.read(bb),\n@@ -94,4 +95,1 @@\n-                ioOp.accept(handler);\n-                handler.await()\n-                        .assertFailedWith(ISE)\n-                        .assertExceptionMessage(\"Confined session not supported\");\n+                expectThrows(IAE, () -> ioOp.accept(handler));\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,3 @@\n- * @bug 8333849\n- * @summary Test ByteChannel implementations of read and write with ByteBuffers that are\n- *    backed by MemorySegments allocated from an Arena\n+ * @bug 8333849 8358958\n+ * @summary Test ByteChannel and AsycnhronousByteChannel implementations with ByteBuffers\n+ *    that are views of a MemorySegment\n@@ -38,0 +38,4 @@\n+import java.nio.channels.AsynchronousFileChannel;\n+import java.nio.channels.AsynchronousServerSocketChannel;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.CompletionHandler;\n@@ -45,0 +49,4 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n@@ -49,0 +57,4 @@\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.RepeatedTest;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n@@ -328,0 +340,171 @@\n+    \/**\n+     * AsynchronousSocketChannel read\/write(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testAsyncSocketChannelReadWrite(Supplier<Arena> arenaSupplier) throws Exception {\n+        boolean shared = isShared(arenaSupplier);\n+        boolean confined = isConfined(arenaSupplier);\n+        Arena arena = arenaSupplier.get();\n+\n+        try (var listener = AsynchronousServerSocketChannel.open();\n+             AsynchronousSocketChannel ch1 = AsynchronousSocketChannel.open()) {\n+            listener.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            ch1.connect(listener.getLocalAddress()).get();\n+            try (AsynchronousSocketChannel ch2 = listener.accept().get()) {\n+                ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+                ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                fillRandom(src);\n+\n+                if (confined) {\n+                    \/\/ read and write should fail with IAE\n+                    assertThrows(IllegalArgumentException.class, () -> ch1.read(dst));\n+                    assertThrows(IllegalArgumentException.class, () -> ch2.write(src));\n+                } else {\n+                    \/\/ async read\n+                    Future<Integer> readTask = ch1.read(dst);\n+\n+                    \/\/ shared arena cannot be closed while read in progress\n+                    if (shared) {\n+                        assertThrows(IllegalStateException.class, arena::close);\n+                    }\n+\n+                    \/\/ async write\n+                    Future<Integer> writeTask = ch2.write(src);\n+\n+                    \/\/ finish write\n+                    int nwritten = writeTask.get();\n+                    assertTrue(nwritten > 0);\n+                    assertTrue(nwritten <= SIZE);\n+                    assertEquals(nwritten, src.position());\n+\n+                    \/\/ finish read\n+                    int nread = readTask.get();\n+                    assertTrue(nread > 0);\n+                    assertTrue(nread <= nwritten);\n+                    assertEquals(nread, dst.position());\n+\n+                    \/\/ check contents\n+                    dst.flip();\n+                    assertEquals(src.slice(0, nread), dst);\n+                }\n+            }\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * AsynchronousSocketChannel write(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testAsyncSocketChannelGatheringWrite(Supplier<Arena> arenaSupplier) throws Throwable {\n+        boolean confined = isConfined(arenaSupplier);\n+        Arena arena = arenaSupplier.get();\n+\n+        try (var listener = AsynchronousServerSocketChannel.open();\n+             AsynchronousSocketChannel ch1 = AsynchronousSocketChannel.open()) {\n+            listener.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            ch1.connect(listener.getLocalAddress()).get();\n+            try (AsynchronousSocketChannel ch2 = listener.accept().get()) {\n+\n+                ByteBuffer src = arena.allocate(SIZE * 2).asByteBuffer();\n+                fillRandom(src);\n+                ByteBuffer src1 = src.slice(0, SIZE);\n+                ByteBuffer src2 = src.slice(SIZE, SIZE);\n+                var srcs = new ByteBuffer[] { src1, src2 };\n+\n+                var writeHandler = new Handler<Long>();\n+                if (confined) {\n+                    assertThrows(IllegalArgumentException.class,\n+                            () -> ch1.write(srcs, 0, 2, 0, TimeUnit.SECONDS, null, writeHandler));\n+                } else {\n+                    \/\/ async gathering write\n+                    ch1.write(srcs, 0, 2, 0, TimeUnit.SECONDS, null, writeHandler);\n+\n+                    \/\/ finish gathering write\n+                    int nwritten = (int) (long) writeHandler.join();\n+                    assertTrue(nwritten > 0);\n+                    assertEquals(Math.min(nwritten, SIZE), src1.position());\n+                    assertEquals(nwritten, src1.position() + src2.position());\n+\n+                    \/\/ async read + finish read\n+                    ByteBuffer dst = arena.allocate(SIZE * 2 + 50).asByteBuffer();\n+                    int nread = ch2.read(dst).get();\n+                    assertTrue(nread > 0);\n+                    assertTrue(nread <= nwritten);\n+                    assertEquals(nread, dst.position());\n+\n+                    \/\/ check contents\n+                    dst.flip();\n+                    assertEquals(src.slice(0, nread), dst);\n+                }\n+            }\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * AsynchronousSocketChannel read(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testAsyncSocketChannelScatteringRead(Supplier<Arena> arenaSupplier) throws Throwable {\n+        boolean shared = isShared(arenaSupplier);\n+        boolean confined = isConfined(arenaSupplier);\n+        Arena arena = arenaSupplier.get();\n+\n+        try (var listener = AsynchronousServerSocketChannel.open();\n+             AsynchronousSocketChannel ch1 = AsynchronousSocketChannel.open()) {\n+            listener.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            ch1.connect(listener.getLocalAddress()).get();\n+            try (AsynchronousSocketChannel ch2 = listener.accept().get()) {\n+\n+                ByteBuffer dst = arena.allocate(SIZE + 50).asByteBuffer();\n+                ByteBuffer dst1 = dst.slice(0, 50);\n+                ByteBuffer dst2 = dst.slice(50, dst.capacity() - 50);\n+                var dsts = new ByteBuffer[]{dst1, dst2};\n+                var readHandler = new Handler<Long>();\n+\n+                if (confined) {\n+                    assertThrows(IllegalArgumentException.class,\n+                            () -> ch1.read(dsts, 0, 2, 0, TimeUnit.SECONDS, null, readHandler));\n+                } else {\n+                    \/\/ async scattering read\n+                    ch1.read(dsts, 0, 2, 0, TimeUnit.SECONDS, null, readHandler);\n+\n+                    \/\/ shared arena cannot be closed while read in progress\n+                    if (shared) {\n+                        assertThrows(IllegalStateException.class, arena::close);\n+                    }\n+\n+                    \/\/ async write + finish write\n+                    ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                    fillRandom(src);\n+                    int nwritten = ch2.write(src).get();\n+                    assertTrue(nwritten > 0);\n+                    assertTrue(nwritten <= SIZE);\n+                    assertEquals(nwritten, src.position());\n+\n+                    \/\/ finish scattering read\n+                    int nread = (int) (long) readHandler.join();\n+                    assertTrue(nread > 0);\n+                    assertTrue(nread <= nwritten);\n+                    assertTrue(dst1.position() > 0);\n+                    assertEquals(nread, dst1.position() + dst2.position());\n+\n+                    \/\/ check contents\n+                    src.flip();\n+                    assertEquals(src, dst.slice(0, nread));\n+                }\n+            }\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n@@ -470,0 +653,123 @@\n+    \/**\n+     * AsynchronousFileChannel read\/write(ByteBuffer).\n+     *\/\n+    @DisabledOnOs(OS.WINDOWS)\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testAsyncFileChannelReadWrite(Supplier<Arena> arenaSupplier) throws Throwable {\n+        boolean confined = isConfined(arenaSupplier);\n+        Arena arena = arenaSupplier.get();\n+\n+        Path file = Files.createTempFile(Path.of(\"\"), \"foo\", \".dat\");\n+        try (AsynchronousFileChannel ch = AsynchronousFileChannel.open(file, READ, WRITE)) {\n+            ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+\n+            if (confined) {\n+                \/\/ read and write should fail with IAE\n+                assertThrows(IllegalArgumentException.class, () -> ch.read(dst, 0L));\n+                assertThrows(IllegalArgumentException.class, () -> ch.write(src, 0L));\n+            } else {\n+                \/\/ async write\n+                Future<Integer> writeTask = ch.write(src, 0L);\n+\n+                \/\/ finish write\n+                int nwritten = writeTask.get();\n+                assertTrue(nwritten > 0);\n+                assertTrue(nwritten <= SIZE);\n+                assertEquals(nwritten, src.position());\n+\n+                \/\/ async read\n+                Future<Integer> readTask = ch.read(dst, 0L);\n+\n+                \/\/ finish read\n+                int nread = readTask.get();\n+                assertTrue(nread > 0);\n+                assertTrue(nread <= nwritten);\n+                assertEquals(nread, dst.position());\n+\n+                \/\/ check contents\n+                dst.flip();\n+                assertEquals(src.slice(0, nread), dst);\n+            }\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a shared arena while AsynchronousFileChannel.write in progress.\n+     *\/\n+    @Disabled\n+    @RepeatedTest(20)\n+    void testAsyncFileChannelWriteRacingArenaClose() throws Exception {\n+        Path file = Files.createTempFile(Path.of(\"\"), \"foo\", \".dat\");\n+\n+        \/\/ use SYNC option to cause write operation to be slow\n+        try (AsynchronousFileChannel ch = AsynchronousFileChannel.open(file, READ, WRITE, SYNC)) {\n+            Arena arena = Arena.ofShared();\n+            boolean closed = false;\n+            try {\n+                ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                fillRandom(src);\n+\n+                \/\/ need copy of source buffer so that writing can be tested after arena is closed\n+                ByteBuffer srcCopy = copyOf(src);\n+\n+                \/\/ async write\n+                Future<Integer> writeTask = ch.write(src, 0L);\n+\n+                \/\/ attempt to close arena, races with write operation\n+                try {\n+                    arena.close();\n+                    closed = true;\n+                } catch (IllegalStateException e) {\n+                    \/\/ in use\n+                }\n+\n+                \/\/ finish write\n+                int nwritten = writeTask.get();\n+                assertTrue(nwritten > 0);\n+                assertTrue(nwritten <= SIZE);\n+\n+                \/\/ read and check contents\n+                ByteBuffer dst = ByteBuffer.allocate(SIZE + 100);\n+                int nread = ch.read(dst, 0L).get();\n+                dst.flip();\n+                assertEquals(srcCopy.slice(0, nread), dst);\n+            } finally {\n+                if (!closed) {\n+                    arena.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * CompletionHandler with a join method to wait for operation to complete.\n+     *\/\n+    private static class Handler<V> implements CompletionHandler<V, Void> {\n+        volatile V result;\n+        volatile Throwable ex;\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        @Override\n+        public void completed(V result, Void att) {\n+            this.result = result;\n+            latch.countDown();\n+        }\n+        @Override\n+        public void failed(Throwable ex, Void att) {\n+            this.ex = ex;\n+            latch.countDown();\n+        }\n+        V join() throws ExecutionException, InterruptedException {\n+            latch.await();\n+            Throwable ex = this.ex;\n+            if (ex != null) {\n+                throw new ExecutionException(ex);\n+            }\n+            return result;\n+        }\n+    }\n+\n@@ -482,0 +788,36 @@\n+    \/**\n+     * Return a copy of a buffer.\n+     *\/\n+    private ByteBuffer copyOf(ByteBuffer buf) {\n+        ByteBuffer copy = ByteBuffer.allocate(buf.capacity());\n+        buf.put(copy);\n+        buf.flip();\n+        copy.flip();\n+        assertEquals(buf, copy);\n+        return copy;\n+    }\n+\n+    \/**\n+     * Returns true if the supplier produces shared arenas.\n+     *\/\n+    private boolean isShared(Supplier<Arena> arenaSupplier) {\n+        if (!isConfined(arenaSupplier)) {\n+            try {\n+                arenaSupplier.get().close();\n+                return true;\n+            } catch (UnsupportedOperationException e) { }\n+        }\n+        \/\/ confined or non-closeable\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns true if the supplier produces thread-confined arenas.\n+     *\/\n+    private boolean isConfined(Supplier<Arena> arenaSupplier) {\n+        Arena arena = arenaSupplier.get();\n+        boolean confined = !arena.allocate(0).isAccessibleBy(new Thread());\n+        tryClose(arena);\n+        return confined;\n+    }\n+\n@@ -493,1 +835,0 @@\n-\n","filename":"test\/jdk\/java\/nio\/channels\/etc\/MemorySegments.java","additions":346,"deletions":5,"binary":false,"changes":351,"status":"modified"}]}