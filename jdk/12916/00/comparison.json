{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,1 @@\n+          $(SUPPORT_OUTPUTDIR)\/native\/java.base\/$(LIBRARY_PREFIX)fdlibm$(STATIC_LIBRARY_SUFFIX) \\\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,37 @@\n+##########################################################################################\n+# libfdlibm is statically linked with libjava below and not delivered into the\n+# product on its own.\n+\n+BUILD_LIBFDLIBM_OPTIMIZATION := NONE\n+\n+# If FDLIBM_CFLAGS is non-empty we know that we can optimize\n+# fdlibm when adding those extra C flags. Currently GCC,\n+# and clang only.\n+ifneq ($(FDLIBM_CFLAGS), )\n+  BUILD_LIBFDLIBM_OPTIMIZATION := LOW\n+endif\n+\n+LIBFDLIBM_SRC := $(TOPDIR)\/src\/java.base\/share\/native\/libfdlibm\n+LIBFDLIBM_CFLAGS := -I$(LIBFDLIBM_SRC) $(FDLIBM_CFLAGS)\n+\n+$(eval $(call SetupNativeCompilation, BUILD_LIBFDLIBM, \\\n+    NAME := fdlibm, \\\n+    TYPE := STATIC_LIBRARY, \\\n+    OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE), \\\n+    SRC := $(LIBFDLIBM_SRC), \\\n+    OPTIMIZATION := $(BUILD_LIBFDLIBM_OPTIMIZATION), \\\n+    CFLAGS := $(CFLAGS_JDKLIB) $(LIBFDLIBM_CFLAGS), \\\n+    CFLAGS_windows_debug := -DLOGGING, \\\n+    CFLAGS_aix := -qfloat=nomaf, \\\n+    DISABLED_WARNINGS_gcc := sign-compare, \\\n+    DISABLED_WARNINGS_gcc_k_rem_pio2.c := maybe-uninitialized, \\\n+    DISABLED_WARNINGS_clang := sign-compare, \\\n+    DISABLED_WARNINGS_microsoft := 4146, \\\n+    DISABLED_WARNINGS_microsoft_e_exp.c := 4244, \\\n+    DISABLED_WARNINGS_microsoft_s_ceil.c := 4018, \\\n+    DISABLED_WARNINGS_microsoft_s_expm1.c := 4244, \\\n+    DISABLED_WARNINGS_microsoft_s_floor.c := 4018, \\\n+    ARFLAGS := $(ARFLAGS), \\\n+    OBJECT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libfdlibm, \\\n+))\n+\n@@ -62,0 +99,1 @@\n+    EXTRA_HEADER_DIRS := libfdlibm, \\\n@@ -68,0 +106,1 @@\n+    LIBS := $(BUILD_LIBFDLIBM_TARGET), \\\n@@ -83,0 +122,1 @@\n+$(BUILD_LIBJAVA): $(BUILD_LIBFDLIBM)\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n-\/\/ These are copied defines originally from fdlibm.h.\n+\/\/ These are copied defines from fdlibm.h, this allows us to keep the code\n+\/\/ the same as in the JDK, for easier maintenance.\n@@ -34,1 +35,1 @@\n-\/\/ This code is a copy of __ieee754_fmod() formerly from the JDK's libfdlibm and is\n+\/\/ This code is a copy of __ieee754_fmod() from the JDK's libfdlibm and is\n","filename":"src\/hotspot\/os\/windows\/sharedRuntimeRem.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,8 @@\n-\/\/ This file contains copies of the C fdlibm routines originally used\n-\/\/ by StrictMath. The StrictMath sin, cos, and tan methods now use a\n-\/\/ Java port of the algorithm in java.lang.Fdlibm.java.\n+\/\/ This file contains copies of the fdlibm routines used by\n+\/\/ StrictMath. It turns out that it is almost always required to use\n+\/\/ these runtime routines; the Intel CPU doesn't meet the Java\n+\/\/ specification for sin\/cos outside a certain limited argument range,\n+\/\/ and the SPARC CPU doesn't appear to have sin\/cos instructions. It\n+\/\/ also turns out that avoiding the indirect call through function\n+\/\/ pointer out to libjava.so in SharedRuntime speeds these routines up\n+\/\/ by roughly 15% on both Win32\/x86 and Solaris\/SPARC.\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntimeTrig.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,22 +45,2 @@\n- * then to be understood to be transliterated into Java and executed\n- * with all floating-point and integer operations following the rules\n- * of Java arithmetic. The following transformations are used in the\n- * transliteration:\n- *\n- * <ul>\n- * <li>Extraction and setting of the high and low halves of a 64-bit\n- * {@code double} in C is expressed using Java platform methods that\n- * perform bit-wise conversions {@linkplain\n- * Double#doubleToRawLongBits(double) from {@code double} to {@code\n- * long}} and {@linkplain Double#longBitsToDouble(long) {@code long}\n- * to {@code double}}.\n- *\n- * <li>Unsigned {@code int} values in C are mapped to signed {@code\n- * int} values in Java with updates to operations to replicate\n- * unsigned semantics where the results on the same textual operation\n- * would differ. For example, {@code >>} shifts on unsigned C values\n- * are replaced with {@code >>>} shifts on signed Java values. Sized\n- * comparisons on unsigned C values ({@code <}, {@code <=}, {@code >},\n- * {@code >=}) are replaced with semantically equivalent calls to\n- * {@link Integer#compareUnsigned(int, int) compareUnsigned}.\n- * <\/ul>\n+ * then to be understood as executed with all floating-point\n+ * operations following the rules of Java floating-point arithmetic.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_acos(x)\n+ * Method :\n+ *      acos(x)  = pi\/2 - asin(x)\n+ *      acos(-x) = pi\/2 + asin(x)\n+ * For |x|<=0.5\n+ *      acos(x) = pi\/2 - (x + x*x^2*R(x^2))     (see asin.c)\n+ * For x>0.5\n+ *      acos(x) = pi\/2 - (pi\/2 - 2asin(sqrt((1-x)\/2)))\n+ *              = 2asin(sqrt((1-x)\/2))\n+ *              = 2s + 2s*z*R(z)        ...z=(1-x)\/2, s=sqrt(z)\n+ *              = 2f + (2c + 2s*z*R(z))\n+ *     where f=hi part of s, and c = (z-f*f)\/(s+f) is the correction term\n+ *     for f so that f+c ~ sqrt(z).\n+ * For x<-0.5\n+ *      acos(x) = pi - 2asin(sqrt((1-|x|)\/2))\n+ *              = pi - 0.5*(s+s*z*R(z)), where z=(1-|x|)\/2,s=sqrt(z)\n+ *\n+ * Special cases:\n+ *      if x is NaN, return x itself;\n+ *      if |x|>1, return NaN with invalid signal.\n+ *\n+ * Function needed: sqrt\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+one=  1.00000000000000000000e+00, \/* 0x3FF00000, 0x00000000 *\/\n+pi =  3.14159265358979311600e+00, \/* 0x400921FB, 0x54442D18 *\/\n+pio2_hi =  1.57079632679489655800e+00, \/* 0x3FF921FB, 0x54442D18 *\/\n+pio2_lo =  6.12323399573676603587e-17, \/* 0x3C91A626, 0x33145C07 *\/\n+pS0 =  1.66666666666666657415e-01, \/* 0x3FC55555, 0x55555555 *\/\n+pS1 = -3.25565818622400915405e-01, \/* 0xBFD4D612, 0x03EB6F7D *\/\n+pS2 =  2.01212532134862925881e-01, \/* 0x3FC9C155, 0x0E884455 *\/\n+pS3 = -4.00555345006794114027e-02, \/* 0xBFA48228, 0xB5688F3B *\/\n+pS4 =  7.91534994289814532176e-04, \/* 0x3F49EFE0, 0x7501B288 *\/\n+pS5 =  3.47933107596021167570e-05, \/* 0x3F023DE1, 0x0DFDF709 *\/\n+qS1 = -2.40339491173441421878e+00, \/* 0xC0033A27, 0x1C8A2D4B *\/\n+qS2 =  2.02094576023350569471e+00, \/* 0x40002AE5, 0x9C598AC8 *\/\n+qS3 = -6.88283971605453293030e-01, \/* 0xBFE6066C, 0x1B8D0159 *\/\n+qS4 =  7.70381505559019352791e-02; \/* 0x3FB3B8C5, 0xB12E9282 *\/\n+\n+#ifdef __STDC__\n+        double __ieee754_acos(double x)\n+#else\n+        double __ieee754_acos(x)\n+        double x;\n+#endif\n+{\n+        double z,p,q,r,w,s,c,df;\n+        int hx,ix;\n+        hx = __HI(x);\n+        ix = hx&0x7fffffff;\n+        if(ix>=0x3ff00000) {    \/* |x| >= 1 *\/\n+            if(((ix-0x3ff00000)|__LO(x))==0) {  \/* |x|==1 *\/\n+                if(hx>0) return 0.0;            \/* acos(1) = 0  *\/\n+                else return pi+2.0*pio2_lo;     \/* acos(-1)= pi *\/\n+            }\n+            return (x-x)\/(x-x);         \/* acos(|x|>1) is NaN *\/\n+        }\n+        if(ix<0x3fe00000) {     \/* |x| < 0.5 *\/\n+            if(ix<=0x3c600000) return pio2_hi+pio2_lo;\/*if|x|<2**-57*\/\n+            z = x*x;\n+            p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));\n+            q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));\n+            r = p\/q;\n+            return pio2_hi - (x - (pio2_lo-x*r));\n+        } else  if (hx<0) {             \/* x < -0.5 *\/\n+            z = (one+x)*0.5;\n+            p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));\n+            q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));\n+            s = sqrt(z);\n+            r = p\/q;\n+            w = r*s-pio2_lo;\n+            return pi - 2.0*(s+w);\n+        } else {                        \/* x > 0.5 *\/\n+            z = (one-x)*0.5;\n+            s = sqrt(z);\n+            df = s;\n+            __LO(df) = 0;\n+            c  = (z-df*df)\/(s+df);\n+            p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));\n+            q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));\n+            r = p\/q;\n+            w = r*s+c;\n+            return 2.0*(df+w);\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_acos.c","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_asin(x)\n+ * Method :\n+ *      Since  asin(x) = x + x^3\/6 + x^5*3\/40 + x^7*15\/336 + ...\n+ *      we approximate asin(x) on [0,0.5] by\n+ *              asin(x) = x + x*x^2*R(x^2)\n+ *      where\n+ *              R(x^2) is a rational approximation of (asin(x)-x)\/x^3\n+ *      and its remez error is bounded by\n+ *              |(asin(x)-x)\/x^3 - R(x^2)| < 2^(-58.75)\n+ *\n+ *      For x in [0.5,1]\n+ *              asin(x) = pi\/2-2*asin(sqrt((1-x)\/2))\n+ *      Let y = (1-x), z = y\/2, s := sqrt(z), and pio2_hi+pio2_lo=pi\/2;\n+ *      then for x>0.98\n+ *              asin(x) = pi\/2 - 2*(s+s*z*R(z))\n+ *                      = pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)\n+ *      For x<=0.98, let pio4_hi = pio2_hi\/2, then\n+ *              f = hi part of s;\n+ *              c = sqrt(z) - f = (z-f*f)\/(s+f)         ...f+c=sqrt(z)\n+ *      and\n+ *              asin(x) = pi\/2 - 2*(s+s*z*R(z))\n+ *                      = pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)\n+ *                      = pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))\n+ *\n+ * Special cases:\n+ *      if x is NaN, return x itself;\n+ *      if |x|>1, return NaN with invalid signal.\n+ *\n+ *\/\n+\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+one =  1.00000000000000000000e+00, \/* 0x3FF00000, 0x00000000 *\/\n+huge =  1.000e+300,\n+pio2_hi =  1.57079632679489655800e+00, \/* 0x3FF921FB, 0x54442D18 *\/\n+pio2_lo =  6.12323399573676603587e-17, \/* 0x3C91A626, 0x33145C07 *\/\n+pio4_hi =  7.85398163397448278999e-01, \/* 0x3FE921FB, 0x54442D18 *\/\n+        \/* coefficient for R(x^2) *\/\n+pS0 =  1.66666666666666657415e-01, \/* 0x3FC55555, 0x55555555 *\/\n+pS1 = -3.25565818622400915405e-01, \/* 0xBFD4D612, 0x03EB6F7D *\/\n+pS2 =  2.01212532134862925881e-01, \/* 0x3FC9C155, 0x0E884455 *\/\n+pS3 = -4.00555345006794114027e-02, \/* 0xBFA48228, 0xB5688F3B *\/\n+pS4 =  7.91534994289814532176e-04, \/* 0x3F49EFE0, 0x7501B288 *\/\n+pS5 =  3.47933107596021167570e-05, \/* 0x3F023DE1, 0x0DFDF709 *\/\n+qS1 = -2.40339491173441421878e+00, \/* 0xC0033A27, 0x1C8A2D4B *\/\n+qS2 =  2.02094576023350569471e+00, \/* 0x40002AE5, 0x9C598AC8 *\/\n+qS3 = -6.88283971605453293030e-01, \/* 0xBFE6066C, 0x1B8D0159 *\/\n+qS4 =  7.70381505559019352791e-02; \/* 0x3FB3B8C5, 0xB12E9282 *\/\n+\n+#ifdef __STDC__\n+        double __ieee754_asin(double x)\n+#else\n+        double __ieee754_asin(x)\n+        double x;\n+#endif\n+{\n+        double t=0,w,p,q,c,r,s;\n+        int hx,ix;\n+        hx = __HI(x);\n+        ix = hx&0x7fffffff;\n+        if(ix>= 0x3ff00000) {           \/* |x|>= 1 *\/\n+            if(((ix-0x3ff00000)|__LO(x))==0)\n+                    \/* asin(1)=+-pi\/2 with inexact *\/\n+                return x*pio2_hi+x*pio2_lo;\n+            return (x-x)\/(x-x);         \/* asin(|x|>1) is NaN *\/\n+        } else if (ix<0x3fe00000) {     \/* |x|<0.5 *\/\n+            if(ix<0x3e400000) {         \/* if |x| < 2**-27 *\/\n+                if(huge+x>one) return x;\/* return x with inexact if x!=0*\/\n+            } else\n+                t = x*x;\n+            p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));\n+            q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));\n+            w = p\/q;\n+            return x+x*w;\n+        }\n+        \/* 1> |x|>= 0.5 *\/\n+        w = one-fabs(x);\n+        t = w*0.5;\n+        p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));\n+        q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));\n+        s = sqrt(t);\n+        if(ix>=0x3FEF3333) {    \/* if |x| > 0.975 *\/\n+            w = p\/q;\n+            t = pio2_hi-(2.0*(s+s*w)-pio2_lo);\n+        } else {\n+            w  = s;\n+            __LO(w) = 0;\n+            c  = (t-w*w)\/(s+w);\n+            r  = p\/q;\n+            p  = 2.0*s*r-(pio2_lo-2.0*c);\n+            q  = pio4_hi-2.0*w;\n+            t  = pio4_hi-(p-q);\n+        }\n+        if(hx>0) return t; else return -t;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_asin.c","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 1998, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_atan2(y,x)\n+ * Method :\n+ *      1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).\n+ *      2. Reduce x to positive by (if x and y are unexceptional):\n+ *              ARG (x+iy) = arctan(y\/x)           ... if x > 0,\n+ *              ARG (x+iy) = pi - arctan[y\/(-x)]   ... if x < 0,\n+ *\n+ * Special cases:\n+ *\n+ *      ATAN2((anything), NaN ) is NaN;\n+ *      ATAN2(NAN , (anything) ) is NaN;\n+ *      ATAN2(+-0, +(anything but NaN)) is +-0  ;\n+ *      ATAN2(+-0, -(anything but NaN)) is +-pi ;\n+ *      ATAN2(+-(anything but 0 and NaN), 0) is +-pi\/2;\n+ *      ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;\n+ *      ATAN2(+-(anything but INF and NaN), -INF) is +-pi;\n+ *      ATAN2(+-INF,+INF ) is +-pi\/4 ;\n+ *      ATAN2(+-INF,-INF ) is +-3pi\/4;\n+ *      ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi\/2;\n+ *\n+ * Constants:\n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n+ * to produce the hexadecimal values shown.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+tiny  = 1.0e-300,\n+zero  = 0.0,\n+pi_o_4  = 7.8539816339744827900E-01, \/* 0x3FE921FB, 0x54442D18 *\/\n+pi_o_2  = 1.5707963267948965580E+00, \/* 0x3FF921FB, 0x54442D18 *\/\n+pi      = 3.1415926535897931160E+00, \/* 0x400921FB, 0x54442D18 *\/\n+pi_lo   = 1.2246467991473531772E-16; \/* 0x3CA1A626, 0x33145C07 *\/\n+\n+#ifdef __STDC__\n+        double __ieee754_atan2(double y, double x)\n+#else\n+        double __ieee754_atan2(y,x)\n+        double  y,x;\n+#endif\n+{\n+        double z;\n+        int k,m,hx,hy,ix,iy;\n+        unsigned lx,ly;\n+\n+        hx = __HI(x); ix = hx&0x7fffffff;\n+        lx = __LO(x);\n+        hy = __HI(y); iy = hy&0x7fffffff;\n+        ly = __LO(y);\n+        if(((ix|((lx|-lx)>>31))>0x7ff00000)||\n+           ((iy|((ly|-ly)>>31))>0x7ff00000))    \/* x or y is NaN *\/\n+           return x+y;\n+        if(((hx-0x3ff00000)|lx)==0) return atan(y);   \/* x=1.0 *\/\n+        m = ((hy>>31)&1)|((hx>>30)&2);  \/* 2*sign(x)+sign(y) *\/\n+\n+    \/* when y = 0 *\/\n+        if((iy|ly)==0) {\n+            switch(m) {\n+                case 0:\n+                case 1: return y;       \/* atan(+-0,+anything)=+-0 *\/\n+                case 2: return  pi+tiny;\/* atan(+0,-anything) = pi *\/\n+                case 3: return -pi-tiny;\/* atan(-0,-anything) =-pi *\/\n+            }\n+        }\n+    \/* when x = 0 *\/\n+        if((ix|lx)==0) return (hy<0)?  -pi_o_2-tiny: pi_o_2+tiny;\n+\n+    \/* when x is INF *\/\n+        if(ix==0x7ff00000) {\n+            if(iy==0x7ff00000) {\n+                switch(m) {\n+                    case 0: return  pi_o_4+tiny;\/* atan(+INF,+INF) *\/\n+                    case 1: return -pi_o_4-tiny;\/* atan(-INF,+INF) *\/\n+                    case 2: return  3.0*pi_o_4+tiny;\/*atan(+INF,-INF)*\/\n+                    case 3: return -3.0*pi_o_4-tiny;\/*atan(-INF,-INF)*\/\n+                }\n+            } else {\n+                switch(m) {\n+                    case 0: return  zero  ;     \/* atan(+...,+INF) *\/\n+                    case 1: return -1.0*zero  ; \/* atan(-...,+INF) *\/\n+                    case 2: return  pi+tiny  ;  \/* atan(+...,-INF) *\/\n+                    case 3: return -pi-tiny  ;  \/* atan(-...,-INF) *\/\n+                }\n+            }\n+        }\n+    \/* when y is INF *\/\n+        if(iy==0x7ff00000) return (hy<0)? -pi_o_2-tiny: pi_o_2+tiny;\n+\n+    \/* compute y\/x *\/\n+        k = (iy-ix)>>20;\n+        if(k > 60) z=pi_o_2+0.5*pi_lo;  \/* |y\/x| >  2**60 *\/\n+        else if(hx<0&&k<-60) z=0.0;     \/* |y|\/x < -2**60 *\/\n+        else z=atan(fabs(y\/x));         \/* safe to do y\/x *\/\n+        switch (m) {\n+            case 0: return       z  ;   \/* atan(+,+) *\/\n+            case 1: __HI(z) ^= 0x80000000;\n+                    return       z  ;   \/* atan(-,+) *\/\n+            case 2: return  pi-(z-pi_lo);\/* atan(+,-) *\/\n+            default: \/* case 3 *\/\n+                    return  (z-pi_lo)-pi;\/* atan(-,-) *\/\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_atan2.c","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_atanh(x)\n+ * Method :\n+ *    1.Reduced x to positive by atanh(-x) = -atanh(x)\n+ *    2.For x>=0.5\n+ *                  1              2x                          x\n+ *      atanh(x) = --- * log(1 + -------) = 0.5 * log1p(2 * --------)\n+ *                  2             1 - x                      1 - x\n+ *\n+ *      For x<0.5\n+ *      atanh(x) = 0.5*log1p(2x+2x*x\/(1-x))\n+ *\n+ * Special cases:\n+ *      atanh(x) is NaN if |x| > 1 with signal;\n+ *      atanh(NaN) is that NaN with no signal;\n+ *      atanh(+-1) is +-INF with signal.\n+ *\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double one = 1.0, huge = 1e300;\n+#else\n+static double one = 1.0, huge = 1e300;\n+#endif\n+\n+static double zero = 0.0;\n+\n+#ifdef __STDC__\n+        double __ieee754_atanh(double x)\n+#else\n+        double __ieee754_atanh(x)\n+        double x;\n+#endif\n+{\n+        double t;\n+        int hx,ix;\n+        unsigned lx;\n+        hx = __HI(x);           \/* high word *\/\n+        lx = __LO(x);           \/* low word *\/\n+        ix = hx&0x7fffffff;\n+        if ((ix|((lx|(-lx))>>31))>0x3ff00000) \/* |x|>1 *\/\n+            return (x-x)\/(x-x);\n+        if(ix==0x3ff00000)\n+            return x\/zero;\n+        if(ix<0x3e300000&&(huge+x)>zero) return x;      \/* x<2**-28 *\/\n+        __HI(x) = ix;           \/* x <- |x| *\/\n+        if(ix<0x3fe00000) {             \/* x < 0.5 *\/\n+            t = x+x;\n+            t = 0.5*log1p(t+t*x\/(one-x));\n+        } else\n+            t = 0.5*log1p((x+x)\/(one-x));\n+        if(hx>=0) return t; else return -t;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_atanh.c","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_cosh(x)\n+ * Method :\n+ * mathematically cosh(x) if defined to be (exp(x)+exp(-x))\/2\n+ *      1. Replace x by |x| (cosh(x) = cosh(-x)).\n+ *      2.\n+ *                                                      [ exp(x) - 1 ]^2\n+ *          0        <= x <= ln2\/2  :  cosh(x) := 1 + -------------------\n+ *                                                         2*exp(x)\n+ *\n+ *                                                exp(x) +  1\/exp(x)\n+ *          ln2\/2    <= x <= 22     :  cosh(x) := -------------------\n+ *                                                        2\n+ *          22       <= x <= lnovft :  cosh(x) := exp(x)\/2\n+ *          lnovft   <= x <= ln2ovft:  cosh(x) := exp(x\/2)\/2 * exp(x\/2)\n+ *          ln2ovft  <  x           :  cosh(x) := huge*huge (overflow)\n+ *\n+ * Special cases:\n+ *      cosh(x) is |x| if x is +INF, -INF, or NaN.\n+ *      only cosh(0)=1 is exact for finite x.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double one = 1.0, half=0.5, huge = 1.0e300;\n+#else\n+static double one = 1.0, half=0.5, huge = 1.0e300;\n+#endif\n+\n+#ifdef __STDC__\n+        double __ieee754_cosh(double x)\n+#else\n+        double __ieee754_cosh(x)\n+        double x;\n+#endif\n+{\n+        double t,w;\n+        int ix;\n+        unsigned lx;\n+\n+    \/* High word of |x|. *\/\n+        ix = __HI(x);\n+        ix &= 0x7fffffff;\n+\n+    \/* x is INF or NaN *\/\n+        if(ix>=0x7ff00000) return x*x;\n+\n+    \/* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2\/(2*exp(|x|)) *\/\n+        if(ix<0x3fd62e43) {\n+            t = expm1(fabs(x));\n+            w = one+t;\n+            if (ix<0x3c800000) return w;        \/* cosh(tiny) = 1 *\/\n+            return one+(t*t)\/(w+w);\n+        }\n+\n+    \/* |x| in [0.5*ln2,22], return (exp(|x|)+1\/exp(|x|)\/2; *\/\n+        if (ix < 0x40360000) {\n+                t = __ieee754_exp(fabs(x));\n+                return half*t+half\/t;\n+        }\n+\n+    \/* |x| in [22, log(maxdouble)] return half*exp(|x|) *\/\n+        if (ix < 0x40862E42)  return half*__ieee754_exp(fabs(x));\n+\n+    \/* |x| in [log(maxdouble), overflowthresold] *\/\n+        lx = *( (((*(unsigned*)&one)>>29)) + (unsigned*)&x);\n+        if (ix<0x408633CE ||\n+              ((ix==0x408633ce)&&(lx<=(unsigned)0x8fb9f87d))) {\n+            w = __ieee754_exp(half*fabs(x));\n+            t = half*w;\n+            return t*w;\n+        }\n+\n+    \/* |x| > overflowthresold, cosh(x) overflow *\/\n+        return huge*huge;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_cosh.c","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_exp(x)\n+ * Returns the exponential of x.\n+ *\n+ * Method\n+ *   1. Argument reduction:\n+ *      Reduce x to an r so that |r| <= 0.5*ln2 ~ 0.34658.\n+ *      Given x, find r and integer k such that\n+ *\n+ *               x = k*ln2 + r,  |r| <= 0.5*ln2.\n+ *\n+ *      Here r will be represented as r = hi-lo for better\n+ *      accuracy.\n+ *\n+ *   2. Approximation of exp(r) by a special rational function on\n+ *      the interval [0,0.34658]:\n+ *      Write\n+ *          R(r**2) = r*(exp(r)+1)\/(exp(r)-1) = 2 + r*r\/6 - r**4\/360 + ...\n+ *      We use a special Reme algorithm on [0,0.34658] to generate\n+ *      a polynomial of degree 5 to approximate R. The maximum error\n+ *      of this polynomial approximation is bounded by 2**-59. In\n+ *      other words,\n+ *          R(z) ~ 2.0 + P1*z + P2*z**2 + P3*z**3 + P4*z**4 + P5*z**5\n+ *      (where z=r*r, and the values of P1 to P5 are listed below)\n+ *      and\n+ *          |                  5          |     -59\n+ *          | 2.0+P1*z+...+P5*z   -  R(z) | <= 2\n+ *          |                             |\n+ *      The computation of exp(r) thus becomes\n+ *                             2*r\n+ *              exp(r) = 1 + -------\n+ *                            R - r\n+ *                                 r*R1(r)\n+ *                     = 1 + r + ----------- (for better accuracy)\n+ *                                2 - R1(r)\n+ *      where\n+ *                               2       4             10\n+ *              R1(r) = r - (P1*r  + P2*r  + ... + P5*r   ).\n+ *\n+ *   3. Scale back to obtain exp(x):\n+ *      From step 1, we have\n+ *         exp(x) = 2^k * exp(r)\n+ *\n+ * Special cases:\n+ *      exp(INF) is INF, exp(NaN) is NaN;\n+ *      exp(-INF) is 0, and\n+ *      for finite argument, only exp(0)=1 is exact.\n+ *\n+ * Accuracy:\n+ *      according to an error analysis, the error is always less than\n+ *      1 ulp (unit in the last place).\n+ *\n+ * Misc. info.\n+ *      For IEEE double\n+ *          if x >  7.09782712893383973096e+02 then exp(x) overflow\n+ *          if x < -7.45133219101941108420e+02 then exp(x) underflow\n+ *\n+ * Constants:\n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n+ * to produce the hexadecimal values shown.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+one     = 1.0,\n+halF[2] = {0.5,-0.5,},\n+huge    = 1.0e+300,\n+twom1000= 9.33263618503218878990e-302,     \/* 2**-1000=0x01700000,0*\/\n+o_threshold=  7.09782712893383973096e+02,  \/* 0x40862E42, 0xFEFA39EF *\/\n+u_threshold= -7.45133219101941108420e+02,  \/* 0xc0874910, 0xD52D3051 *\/\n+ln2HI[2]   ={ 6.93147180369123816490e-01,  \/* 0x3fe62e42, 0xfee00000 *\/\n+             -6.93147180369123816490e-01,},\/* 0xbfe62e42, 0xfee00000 *\/\n+ln2LO[2]   ={ 1.90821492927058770002e-10,  \/* 0x3dea39ef, 0x35793c76 *\/\n+             -1.90821492927058770002e-10,},\/* 0xbdea39ef, 0x35793c76 *\/\n+invln2 =  1.44269504088896338700e+00, \/* 0x3ff71547, 0x652b82fe *\/\n+P1   =  1.66666666666666019037e-01, \/* 0x3FC55555, 0x5555553E *\/\n+P2   = -2.77777777770155933842e-03, \/* 0xBF66C16C, 0x16BEBD93 *\/\n+P3   =  6.61375632143793436117e-05, \/* 0x3F11566A, 0xAF25DE2C *\/\n+P4   = -1.65339022054652515390e-06, \/* 0xBEBBBD41, 0xC5D26BF1 *\/\n+P5   =  4.13813679705723846039e-08; \/* 0x3E663769, 0x72BEA4D0 *\/\n+\n+\n+#ifdef __STDC__\n+        double __ieee754_exp(double x)  \/* default IEEE double exp *\/\n+#else\n+        double __ieee754_exp(x) \/* default IEEE double exp *\/\n+        double x;\n+#endif\n+{\n+        double y,hi=0,lo=0,c,t;\n+        int k=0,xsb;\n+        unsigned hx;\n+\n+        hx  = __HI(x);  \/* high word of x *\/\n+        xsb = (hx>>31)&1;               \/* sign bit of x *\/\n+        hx &= 0x7fffffff;               \/* high word of |x| *\/\n+\n+    \/* filter out non-finite argument *\/\n+        if(hx >= 0x40862E42) {                  \/* if |x|>=709.78... *\/\n+            if(hx>=0x7ff00000) {\n+                if(((hx&0xfffff)|__LO(x))!=0)\n+                     return x+x;                \/* NaN *\/\n+                else return (xsb==0)? x:0.0;    \/* exp(+-inf)={inf,0} *\/\n+            }\n+            if(x > o_threshold) return huge*huge; \/* overflow *\/\n+            if(x < u_threshold) return twom1000*twom1000; \/* underflow *\/\n+        }\n+\n+    \/* argument reduction *\/\n+        if(hx > 0x3fd62e42) {           \/* if  |x| > 0.5 ln2 *\/\n+            if(hx < 0x3FF0A2B2) {       \/* and |x| < 1.5 ln2 *\/\n+                hi = x-ln2HI[xsb]; lo=ln2LO[xsb]; k = 1-xsb-xsb;\n+            } else {\n+                k  = invln2*x+halF[xsb];\n+                t  = k;\n+                hi = x - t*ln2HI[0];    \/* t*ln2HI is exact here *\/\n+                lo = t*ln2LO[0];\n+            }\n+            x  = hi - lo;\n+        }\n+        else if(hx < 0x3e300000)  {     \/* when |x|<2**-28 *\/\n+            if(huge+x>one) return one+x;\/* trigger inexact *\/\n+        }\n+        else k = 0;\n+\n+    \/* x is now in primary range *\/\n+        t  = x*x;\n+        c  = x - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));\n+        if(k==0)        return one-((x*c)\/(c-2.0)-x);\n+        else            y = one-((lo-(x*c)\/(2.0-c))-hi);\n+        if(k >= -1021) {\n+            __HI(y) += (k<<20); \/* add k to y's exponent *\/\n+            return y;\n+        } else {\n+            __HI(y) += ((k+1000)<<20);\/* add k to y's exponent *\/\n+            return y*twom1000;\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_exp.c","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * __ieee754_fmod(x,y)\n+ * Return x mod y in exact arithmetic\n+ * Method: shift and subtract\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double one = 1.0, Zero[] = {0.0, -0.0,};\n+#else\n+static double one = 1.0, Zero[] = {0.0, -0.0,};\n+#endif\n+\n+#ifdef __STDC__\n+        double __ieee754_fmod(double x, double y)\n+#else\n+        double __ieee754_fmod(x,y)\n+        double x,y ;\n+#endif\n+{\n+        int n,hx,hy,hz,ix,iy,sx,i;\n+        unsigned lx,ly,lz;\n+\n+        hx = __HI(x);           \/* high word of x *\/\n+        lx = __LO(x);           \/* low  word of x *\/\n+        hy = __HI(y);           \/* high word of y *\/\n+        ly = __LO(y);           \/* low  word of y *\/\n+        sx = hx&0x80000000;             \/* sign of x *\/\n+        hx ^=sx;                \/* |x| *\/\n+        hy &= 0x7fffffff;       \/* |y| *\/\n+\n+    \/* purge off exception values *\/\n+        if((hy|ly)==0||(hx>=0x7ff00000)||       \/* y=0,or x not finite *\/\n+          ((hy|((ly|-ly)>>31))>0x7ff00000))     \/* or y is NaN *\/\n+            return (x*y)\/(x*y);\n+        if(hx<=hy) {\n+            if((hx<hy)||(lx<ly)) return x;      \/* |x|<|y| return x *\/\n+            if(lx==ly)\n+                return Zero[(unsigned)sx>>31];  \/* |x|=|y| return x*0*\/\n+        }\n+\n+    \/* determine ix = ilogb(x) *\/\n+        if(hx<0x00100000) {     \/* subnormal x *\/\n+            if(hx==0) {\n+                for (ix = -1043, i=lx; i>0; i<<=1) ix -=1;\n+            } else {\n+                for (ix = -1022,i=(hx<<11); i>0; i<<=1) ix -=1;\n+            }\n+        } else ix = (hx>>20)-1023;\n+\n+    \/* determine iy = ilogb(y) *\/\n+        if(hy<0x00100000) {     \/* subnormal y *\/\n+            if(hy==0) {\n+                for (iy = -1043, i=ly; i>0; i<<=1) iy -=1;\n+            } else {\n+                for (iy = -1022,i=(hy<<11); i>0; i<<=1) iy -=1;\n+            }\n+        } else iy = (hy>>20)-1023;\n+\n+    \/* set up {hx,lx}, {hy,ly} and align y to x *\/\n+        if(ix >= -1022)\n+            hx = 0x00100000|(0x000fffff&hx);\n+        else {          \/* subnormal x, shift x to normal *\/\n+            n = -1022-ix;\n+            if(n<=31) {\n+                hx = (hx<<n)|(lx>>(32-n));\n+                lx <<= n;\n+            } else {\n+                hx = lx<<(n-32);\n+                lx = 0;\n+            }\n+        }\n+        if(iy >= -1022)\n+            hy = 0x00100000|(0x000fffff&hy);\n+        else {          \/* subnormal y, shift y to normal *\/\n+            n = -1022-iy;\n+            if(n<=31) {\n+                hy = (hy<<n)|(ly>>(32-n));\n+                ly <<= n;\n+            } else {\n+                hy = ly<<(n-32);\n+                ly = 0;\n+            }\n+        }\n+\n+    \/* fix point fmod *\/\n+        n = ix - iy;\n+        while(n--) {\n+            hz=hx-hy;lz=lx-ly; if(lx<ly) hz -= 1;\n+            if(hz<0){hx = hx+hx+(lx>>31); lx = lx+lx;}\n+            else {\n+                if((hz|lz)==0)          \/* return sign(x)*0 *\/\n+                    return Zero[(unsigned)sx>>31];\n+                hx = hz+hz+(lz>>31); lx = lz+lz;\n+            }\n+        }\n+        hz=hx-hy;lz=lx-ly; if(lx<ly) hz -= 1;\n+        if(hz>=0) {hx=hz;lx=lz;}\n+\n+    \/* convert back to floating value and restore the sign *\/\n+        if((hx|lx)==0)                  \/* return sign(x)*0 *\/\n+            return Zero[(unsigned)sx>>31];\n+        while(hx<0x00100000) {          \/* normalize x *\/\n+            hx = hx+hx+(lx>>31); lx = lx+lx;\n+            iy -= 1;\n+        }\n+        if(iy>= -1022) {        \/* normalize output *\/\n+            hx = ((hx-0x00100000)|((iy+1023)<<20));\n+            __HI(x) = hx|sx;\n+            __LO(x) = lx;\n+        } else {                \/* subnormal output *\/\n+            n = -1022 - iy;\n+            if(n<=20) {\n+                lx = (lx>>n)|((unsigned)hx<<(32-n));\n+                hx >>= n;\n+            } else if (n<=31) {\n+                lx = (hx<<(32-n))|(lx>>n); hx = sx;\n+            } else {\n+                lx = hx>>(n-32); hx = sx;\n+            }\n+            __HI(x) = hx|sx;\n+            __LO(x) = lx;\n+            x *= one;           \/* create necessary signal *\/\n+        }\n+        return x;               \/* exact output *\/\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_fmod.c","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_log(x)\n+ * Return the logarithm of x\n+ *\n+ * Method :\n+ *   1. Argument Reduction: find k and f such that\n+ *                      x = 2^k * (1+f),\n+ *         where  sqrt(2)\/2 < 1+f < sqrt(2) .\n+ *\n+ *   2. Approximation of log(1+f).\n+ *      Let s = f\/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)\n+ *               = 2s + 2\/3 s**3 + 2\/5 s**5 + .....,\n+ *               = 2s + s*R\n+ *      We use a special Reme algorithm on [0,0.1716] to generate\n+ *      a polynomial of degree 14 to approximate R The maximum error\n+ *      of this polynomial approximation is bounded by 2**-58.45. In\n+ *      other words,\n+ *                      2      4      6      8      10      12      14\n+ *          R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s\n+ *      (the values of Lg1 to Lg7 are listed in the program)\n+ *      and\n+ *          |      2          14          |     -58.45\n+ *          | Lg1*s +...+Lg7*s    -  R(z) | <= 2\n+ *          |                             |\n+ *      Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f\/2.\n+ *      In order to guarantee error in log below 1ulp, we compute log\n+ *      by\n+ *              log(1+f) = f - s*(f - R)        (if f is not too large)\n+ *              log(1+f) = f - (hfsq - s*(hfsq+R)).     (better accuracy)\n+ *\n+ *      3. Finally,  log(x) = k*ln2 + log(1+f).\n+ *                          = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))\n+ *         Here ln2 is split into two floating point number:\n+ *                      ln2_hi + ln2_lo,\n+ *         where n*ln2_hi is always exact for |n| < 2000.\n+ *\n+ * Special cases:\n+ *      log(x) is NaN with signal if x < 0 (including -INF) ;\n+ *      log(+INF) is +INF; log(0) is -INF with signal;\n+ *      log(NaN) is that NaN with no signal.\n+ *\n+ * Accuracy:\n+ *      according to an error analysis, the error is always less than\n+ *      1 ulp (unit in the last place).\n+ *\n+ * Constants:\n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n+ * to produce the hexadecimal values shown.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+ln2_hi  =  6.93147180369123816490e-01,  \/* 3fe62e42 fee00000 *\/\n+ln2_lo  =  1.90821492927058770002e-10,  \/* 3dea39ef 35793c76 *\/\n+two54   =  1.80143985094819840000e+16,  \/* 43500000 00000000 *\/\n+Lg1 = 6.666666666666735130e-01,  \/* 3FE55555 55555593 *\/\n+Lg2 = 3.999999999940941908e-01,  \/* 3FD99999 9997FA04 *\/\n+Lg3 = 2.857142874366239149e-01,  \/* 3FD24924 94229359 *\/\n+Lg4 = 2.222219843214978396e-01,  \/* 3FCC71C5 1D8E78AF *\/\n+Lg5 = 1.818357216161805012e-01,  \/* 3FC74664 96CB03DE *\/\n+Lg6 = 1.531383769920937332e-01,  \/* 3FC39A09 D078C69F *\/\n+Lg7 = 1.479819860511658591e-01;  \/* 3FC2F112 DF3E5244 *\/\n+\n+static double zero   =  0.0;\n+\n+#ifdef __STDC__\n+        double __ieee754_log(double x)\n+#else\n+        double __ieee754_log(x)\n+        double x;\n+#endif\n+{\n+        double hfsq,f,s,z,R,w,t1,t2,dk;\n+        int k,hx,i,j;\n+        unsigned lx;\n+\n+        hx = __HI(x);           \/* high word of x *\/\n+        lx = __LO(x);           \/* low  word of x *\/\n+\n+        k=0;\n+        if (hx < 0x00100000) {                  \/* x < 2**-1022  *\/\n+            if (((hx&0x7fffffff)|lx)==0)\n+                return -two54\/zero;             \/* log(+-0)=-inf *\/\n+            if (hx<0) return (x-x)\/zero;        \/* log(-#) = NaN *\/\n+            k -= 54; x *= two54; \/* subnormal number, scale up x *\/\n+            hx = __HI(x);               \/* high word of x *\/\n+        }\n+        if (hx >= 0x7ff00000) return x+x;\n+        k += (hx>>20)-1023;\n+        hx &= 0x000fffff;\n+        i = (hx+0x95f64)&0x100000;\n+        __HI(x) = hx|(i^0x3ff00000);    \/* normalize x or x\/2 *\/\n+        k += (i>>20);\n+        f = x-1.0;\n+        if((0x000fffff&(2+hx))<3) {     \/* |f| < 2**-20 *\/\n+            if(f==zero) {\n+                if (k==0) return zero;\n+                else {dk=(double)k; return dk*ln2_hi+dk*ln2_lo;}\n+            }\n+            R = f*f*(0.5-0.33333333333333333*f);\n+            if(k==0) return f-R; else {dk=(double)k;\n+                     return dk*ln2_hi-((R-dk*ln2_lo)-f);}\n+        }\n+        s = f\/(2.0+f);\n+        dk = (double)k;\n+        z = s*s;\n+        i = hx-0x6147a;\n+        w = z*z;\n+        j = 0x6b851-hx;\n+        t1= w*(Lg2+w*(Lg4+w*Lg6));\n+        t2= z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));\n+        i |= j;\n+        R = t2+t1;\n+        if(i>0) {\n+            hfsq=0.5*f*f;\n+            if(k==0) return f-(hfsq-s*(hfsq+R)); else\n+                     return dk*ln2_hi-((hfsq-(s*(hfsq+R)+dk*ln2_lo))-f);\n+        } else {\n+            if(k==0) return f-s*(f-R); else\n+                     return dk*ln2_hi-((s*(f-R)-dk*ln2_lo)-f);\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_log.c","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_log10(x)\n+ * Return the base 10 logarithm of x\n+ *\n+ * Method :\n+ *      Let log10_2hi = leading 40 bits of log10(2) and\n+ *          log10_2lo = log10(2) - log10_2hi,\n+ *          ivln10   = 1\/log(10) rounded.\n+ *      Then\n+ *              n = ilogb(x),\n+ *              if(n<0)  n = n+1;\n+ *              x = scalbn(x,-n);\n+ *              log10(x) := n*log10_2hi + (n*log10_2lo + ivln10*log(x))\n+ *\n+ * Note 1:\n+ *      To guarantee log10(10**n)=n, where 10**n is normal, the rounding\n+ *      mode must set to Round-to-Nearest.\n+ * Note 2:\n+ *      [1\/log(10)] rounded to 53 bits has error  .198   ulps;\n+ *      log10 is monotonic at all binary break points.\n+ *\n+ * Special cases:\n+ *      log10(x) is NaN with signal if x < 0;\n+ *      log10(+INF) is +INF with no signal; log10(0) is -INF with signal;\n+ *      log10(NaN) is that NaN with no signal;\n+ *      log10(10**N) = N  for N=0,1,...,22.\n+ *\n+ * Constants:\n+ * The hexadecimal values are the intended ones for the following constants.\n+ * The decimal values may be used, provided that the compiler will convert\n+ * from decimal to binary accurately enough to produce the hexadecimal values\n+ * shown.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+two54      =  1.80143985094819840000e+16, \/* 0x43500000, 0x00000000 *\/\n+ivln10     =  4.34294481903251816668e-01, \/* 0x3FDBCB7B, 0x1526E50E *\/\n+log10_2hi  =  3.01029995663611771306e-01, \/* 0x3FD34413, 0x509F6000 *\/\n+log10_2lo  =  3.69423907715893078616e-13; \/* 0x3D59FEF3, 0x11F12B36 *\/\n+\n+static double zero   =  0.0;\n+\n+#ifdef __STDC__\n+        double __ieee754_log10(double x)\n+#else\n+        double __ieee754_log10(x)\n+        double x;\n+#endif\n+{\n+        double y,z;\n+        int i,k,hx;\n+        unsigned lx;\n+\n+        hx = __HI(x);   \/* high word of x *\/\n+        lx = __LO(x);   \/* low word of x *\/\n+\n+        k=0;\n+        if (hx < 0x00100000) {                  \/* x < 2**-1022  *\/\n+            if (((hx&0x7fffffff)|lx)==0)\n+                return -two54\/zero;             \/* log(+-0)=-inf *\/\n+            if (hx<0) return (x-x)\/zero;        \/* log(-#) = NaN *\/\n+            k -= 54; x *= two54; \/* subnormal number, scale up x *\/\n+            hx = __HI(x);                \/* high word of x *\/\n+        }\n+        if (hx >= 0x7ff00000) return x+x;\n+        k += (hx>>20)-1023;\n+        i  = ((unsigned)k&0x80000000)>>31;\n+        hx = (hx&0x000fffff)|((0x3ff-i)<<20);\n+        y  = (double)(k+i);\n+        __HI(x) = hx;\n+        z  = y*log10_2lo + ivln10*__ieee754_log(x);\n+        return  z+y*log10_2hi;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_log10.c","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_rem_pio2(x,y)\n+ *\n+ * return the remainder of x rem pi\/2 in y[0]+y[1]\n+ * use __kernel_rem_pio2()\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+\/*\n+ * Table of constants for 2\/pi, 396 Hex digits (476 decimal) of 2\/pi\n+ *\/\n+#ifdef __STDC__\n+static const int two_over_pi[] = {\n+#else\n+static int two_over_pi[] = {\n+#endif\n+0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,\n+0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A,\n+0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129,\n+0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41,\n+0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8,\n+0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF,\n+0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5,\n+0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08,\n+0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3,\n+0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880,\n+0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B,\n+};\n+\n+#ifdef __STDC__\n+static const int npio2_hw[] = {\n+#else\n+static int npio2_hw[] = {\n+#endif\n+0x3FF921FB, 0x400921FB, 0x4012D97C, 0x401921FB, 0x401F6A7A, 0x4022D97C,\n+0x4025FDBB, 0x402921FB, 0x402C463A, 0x402F6A7A, 0x4031475C, 0x4032D97C,\n+0x40346B9C, 0x4035FDBB, 0x40378FDB, 0x403921FB, 0x403AB41B, 0x403C463A,\n+0x403DD85A, 0x403F6A7A, 0x40407E4C, 0x4041475C, 0x4042106C, 0x4042D97C,\n+0x4043A28C, 0x40446B9C, 0x404534AC, 0x4045FDBB, 0x4046C6CB, 0x40478FDB,\n+0x404858EB, 0x404921FB,\n+};\n+\n+\/*\n+ * invpio2:  53 bits of 2\/pi\n+ * pio2_1:   first  33 bit of pi\/2\n+ * pio2_1t:  pi\/2 - pio2_1\n+ * pio2_2:   second 33 bit of pi\/2\n+ * pio2_2t:  pi\/2 - (pio2_1+pio2_2)\n+ * pio2_3:   third  33 bit of pi\/2\n+ * pio2_3t:  pi\/2 - (pio2_1+pio2_2+pio2_3)\n+ *\/\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+zero =  0.00000000000000000000e+00, \/* 0x00000000, 0x00000000 *\/\n+half =  5.00000000000000000000e-01, \/* 0x3FE00000, 0x00000000 *\/\n+two24 =  1.67772160000000000000e+07, \/* 0x41700000, 0x00000000 *\/\n+invpio2 =  6.36619772367581382433e-01, \/* 0x3FE45F30, 0x6DC9C883 *\/\n+pio2_1  =  1.57079632673412561417e+00, \/* 0x3FF921FB, 0x54400000 *\/\n+pio2_1t =  6.07710050650619224932e-11, \/* 0x3DD0B461, 0x1A626331 *\/\n+pio2_2  =  6.07710050630396597660e-11, \/* 0x3DD0B461, 0x1A600000 *\/\n+pio2_2t =  2.02226624879595063154e-21, \/* 0x3BA3198A, 0x2E037073 *\/\n+pio2_3  =  2.02226624871116645580e-21, \/* 0x3BA3198A, 0x2E000000 *\/\n+pio2_3t =  8.47842766036889956997e-32; \/* 0x397B839A, 0x252049C1 *\/\n+\n+#ifdef __STDC__\n+        int __ieee754_rem_pio2(double x, double *y)\n+#else\n+        int __ieee754_rem_pio2(x,y)\n+        double x,y[];\n+#endif\n+{\n+        double z,w,t,r,fn;\n+        double tx[3];\n+        int e0,i,j,nx,n,ix,hx;\n+\n+        hx = __HI(x);           \/* high word of x *\/\n+        ix = hx&0x7fffffff;\n+        if(ix<=0x3fe921fb)   \/* |x| ~<= pi\/4 , no need for reduction *\/\n+            {y[0] = x; y[1] = 0; return 0;}\n+        if(ix<0x4002d97c) {  \/* |x| < 3pi\/4, special case with n=+-1 *\/\n+            if(hx>0) {\n+                z = x - pio2_1;\n+                if(ix!=0x3ff921fb) {    \/* 33+53 bit pi is good enough *\/\n+                    y[0] = z - pio2_1t;\n+                    y[1] = (z-y[0])-pio2_1t;\n+                } else {                \/* near pi\/2, use 33+33+53 bit pi *\/\n+                    z -= pio2_2;\n+                    y[0] = z - pio2_2t;\n+                    y[1] = (z-y[0])-pio2_2t;\n+                }\n+                return 1;\n+            } else {    \/* negative x *\/\n+                z = x + pio2_1;\n+                if(ix!=0x3ff921fb) {    \/* 33+53 bit pi is good enough *\/\n+                    y[0] = z + pio2_1t;\n+                    y[1] = (z-y[0])+pio2_1t;\n+                } else {                \/* near pi\/2, use 33+33+53 bit pi *\/\n+                    z += pio2_2;\n+                    y[0] = z + pio2_2t;\n+                    y[1] = (z-y[0])+pio2_2t;\n+                }\n+                return -1;\n+            }\n+        }\n+        if(ix<=0x413921fb) { \/* |x| ~<= 2^19*(pi\/2), medium size *\/\n+            t  = fabs(x);\n+            n  = (int) (t*invpio2+half);\n+            fn = (double)n;\n+            r  = t-fn*pio2_1;\n+            w  = fn*pio2_1t;    \/* 1st round good to 85 bit *\/\n+            if(n<32&&ix!=npio2_hw[n-1]) {\n+                y[0] = r-w;     \/* quick check no cancellation *\/\n+            } else {\n+                j  = ix>>20;\n+                y[0] = r-w;\n+                i = j-(((__HI(y[0]))>>20)&0x7ff);\n+                if(i>16) {  \/* 2nd iteration needed, good to 118 *\/\n+                    t  = r;\n+                    w  = fn*pio2_2;\n+                    r  = t-w;\n+                    w  = fn*pio2_2t-((t-r)-w);\n+                    y[0] = r-w;\n+                    i = j-(((__HI(y[0]))>>20)&0x7ff);\n+                    if(i>49)  { \/* 3rd iteration need, 151 bits acc *\/\n+                        t  = r; \/* will cover all possible cases *\/\n+                        w  = fn*pio2_3;\n+                        r  = t-w;\n+                        w  = fn*pio2_3t-((t-r)-w);\n+                        y[0] = r-w;\n+                    }\n+                }\n+            }\n+            y[1] = (r-y[0])-w;\n+            if(hx<0)    {y[0] = -y[0]; y[1] = -y[1]; return -n;}\n+            else         return n;\n+        }\n+    \/*\n+     * all other (large) arguments\n+     *\/\n+        if(ix>=0x7ff00000) {            \/* x is inf or NaN *\/\n+            y[0]=y[1]=x-x; return 0;\n+        }\n+    \/* set z = scalbn(|x|,ilogb(x)-23) *\/\n+        __LO(z) = __LO(x);\n+        e0      = (ix>>20)-1046;        \/* e0 = ilogb(z)-23; *\/\n+        __HI(z) = ix - (e0<<20);\n+        for(i=0;i<2;i++) {\n+                tx[i] = (double)((int)(z));\n+                z     = (z-tx[i])*two24;\n+        }\n+        tx[2] = z;\n+        nx = 3;\n+        while(tx[nx-1]==zero) nx--;     \/* skip zero term *\/\n+        n  =  __kernel_rem_pio2(tx,y,e0,nx,2,two_over_pi);\n+        if(hx<0) {y[0] = -y[0]; y[1] = -y[1]; return -n;}\n+        return n;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_rem_pio2.c","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_remainder(x,p)\n+ * Return :\n+ *      returns  x REM p  =  x - [x\/p]*p as if in infinite\n+ *      precise arithmetic, where [x\/p] is the (infinite bit)\n+ *      integer nearest x\/p (in half way case choose the even one).\n+ * Method :\n+ *      Based on fmod() return x-[x\/p]chopped*p exactlp.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double zero = 0.0;\n+#else\n+static double zero = 0.0;\n+#endif\n+\n+\n+#ifdef __STDC__\n+        double __ieee754_remainder(double x, double p)\n+#else\n+        double __ieee754_remainder(x,p)\n+        double x,p;\n+#endif\n+{\n+        int hx,hp;\n+        unsigned sx,lx,lp;\n+        double p_half;\n+\n+        hx = __HI(x);           \/* high word of x *\/\n+        lx = __LO(x);           \/* low  word of x *\/\n+        hp = __HI(p);           \/* high word of p *\/\n+        lp = __LO(p);           \/* low  word of p *\/\n+        sx = hx&0x80000000;\n+        hp &= 0x7fffffff;\n+        hx &= 0x7fffffff;\n+\n+    \/* purge off exception values *\/\n+        if((hp|lp)==0) return (x*p)\/(x*p);      \/* p = 0 *\/\n+        if((hx>=0x7ff00000)||                   \/* x not finite *\/\n+          ((hp>=0x7ff00000)&&                   \/* p is NaN *\/\n+          (((hp-0x7ff00000)|lp)!=0)))\n+            return (x*p)\/(x*p);\n+\n+\n+        if (hp<=0x7fdfffff) x = __ieee754_fmod(x,p+p);  \/* now x < 2p *\/\n+        if (((hx-hp)|(lx-lp))==0) return zero*x;\n+        x  = fabs(x);\n+        p  = fabs(p);\n+        if (hp<0x00200000) {\n+            if(x+x>p) {\n+                x-=p;\n+                if(x+x>=p) x -= p;\n+            }\n+        } else {\n+            p_half = 0.5*p;\n+            if(x>p_half) {\n+                x-=p;\n+                if(x>=p_half) x -= p;\n+            }\n+        }\n+        __HI(x) ^= sx;\n+        return x;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_remainder.c","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * __ieee754_scalb(x, fn) is provide for\n+ * passing various standard test suite. One\n+ * should use scalbn() instead.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef _SCALB_INT\n+#ifdef __STDC__\n+        double __ieee754_scalb(double x, int fn)\n+#else\n+        double __ieee754_scalb(x,fn)\n+        double x; int fn;\n+#endif\n+#else\n+#ifdef __STDC__\n+        double __ieee754_scalb(double x, double fn)\n+#else\n+        double __ieee754_scalb(x,fn)\n+        double x, fn;\n+#endif\n+#endif\n+{\n+#ifdef _SCALB_INT\n+        return scalbn(x,fn);\n+#else\n+        if (isnan(x)||isnan(fn)) return x*fn;\n+        if (!finite(fn)) {\n+            if(fn>0.0) return x*fn;\n+            else       return x\/(-fn);\n+        }\n+        if (rint(fn)!=fn) return (fn-fn)\/(fn-fn);\n+        if ( fn > 65000.0) return scalbn(x, 65000);\n+        if (-fn > 65000.0) return scalbn(x,-65000);\n+        return scalbn(x,(int)fn);\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_scalb.c","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_sinh(x)\n+ * Method :\n+ * mathematically sinh(x) if defined to be (exp(x)-exp(-x))\/2\n+ *      1. Replace x by |x| (sinh(-x) = -sinh(x)).\n+ *      2.\n+ *                                                  E + E\/(E+1)\n+ *          0        <= x <= 22     :  sinh(x) := --------------, E=expm1(x)\n+ *                                                      2\n+ *\n+ *          22       <= x <= lnovft :  sinh(x) := exp(x)\/2\n+ *          lnovft   <= x <= ln2ovft:  sinh(x) := exp(x\/2)\/2 * exp(x\/2)\n+ *          ln2ovft  <  x           :  sinh(x) := x*shuge (overflow)\n+ *\n+ * Special cases:\n+ *      sinh(x) is |x| if x is +INF, -INF, or NaN.\n+ *      only sinh(0)=0 is exact for finite x.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double one = 1.0, shuge = 1.0e307;\n+#else\n+static double one = 1.0, shuge = 1.0e307;\n+#endif\n+\n+#ifdef __STDC__\n+        double __ieee754_sinh(double x)\n+#else\n+        double __ieee754_sinh(x)\n+        double x;\n+#endif\n+{\n+        double t,w,h;\n+        int ix,jx;\n+        unsigned lx;\n+\n+    \/* High word of |x|. *\/\n+        jx = __HI(x);\n+        ix = jx&0x7fffffff;\n+\n+    \/* x is INF or NaN *\/\n+        if(ix>=0x7ff00000) return x+x;\n+\n+        h = 0.5;\n+        if (jx<0) h = -h;\n+    \/* |x| in [0,22], return sign(x)*0.5*(E+E\/(E+1))) *\/\n+        if (ix < 0x40360000) {          \/* |x|<22 *\/\n+            if (ix<0x3e300000)          \/* |x|<2**-28 *\/\n+                if(shuge+x>one) return x;\/* sinh(tiny) = tiny with inexact *\/\n+            t = expm1(fabs(x));\n+            if(ix<0x3ff00000) return h*(2.0*t-t*t\/(t+one));\n+            return h*(t+t\/(t+one));\n+        }\n+\n+    \/* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) *\/\n+        if (ix < 0x40862E42)  return h*__ieee754_exp(fabs(x));\n+\n+    \/* |x| in [log(maxdouble), overflowthresold] *\/\n+        lx = *( (((*(unsigned*)&one)>>29)) + (unsigned*)&x);\n+        if (ix<0x408633CE || ((ix==0x408633ce)&&(lx<=(unsigned)0x8fb9f87d))) {\n+            w = __ieee754_exp(0.5*fabs(x));\n+            t = h*w;\n+            return t*w;\n+        }\n+\n+    \/* |x| > overflowthresold, sinh(x) overflow *\/\n+        return x*shuge;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_sinh.c","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,462 @@\n+\/*\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __ieee754_sqrt(x)\n+ * Return correctly rounded sqrt.\n+ *           ------------------------------------------\n+ *           |  Use the hardware sqrt if you have one |\n+ *           ------------------------------------------\n+ * Method:\n+ *   Bit by bit method using integer arithmetic. (Slow, but portable)\n+ *   1. Normalization\n+ *      Scale x to y in [1,4) with even powers of 2:\n+ *      find an integer k such that  1 <= (y=x*2^(2k)) < 4, then\n+ *              sqrt(x) = 2^k * sqrt(y)\n+ *   2. Bit by bit computation\n+ *      Let q  = sqrt(y) truncated to i bit after binary point (q = 1),\n+ *           i                                                   0\n+ *                                     i+1         2\n+ *          s  = 2*q , and      y  =  2   * ( y - q  ).         (1)\n+ *           i      i            i                 i\n+ *\n+ *      To compute q    from q , one checks whether\n+ *                  i+1       i\n+ *\n+ *                            -(i+1) 2\n+ *                      (q + 2      ) <= y.                     (2)\n+ *                        i\n+ *                                                            -(i+1)\n+ *      If (2) is false, then q   = q ; otherwise q   = q  + 2      .\n+ *                             i+1   i             i+1   i\n+ *\n+ *      With some algebraic manipulation, it is not difficult to see\n+ *      that (2) is equivalent to\n+ *                             -(i+1)\n+ *                      s  +  2       <= y                      (3)\n+ *                       i                i\n+ *\n+ *      The advantage of (3) is that s  and y  can be computed by\n+ *                                    i      i\n+ *      the following recurrence formula:\n+ *          if (3) is false\n+ *\n+ *          s     =  s  ,       y    = y   ;                    (4)\n+ *           i+1      i          i+1    i\n+ *\n+ *          otherwise,\n+ *                         -i                     -(i+1)\n+ *          s     =  s  + 2  ,  y    = y  -  s  - 2             (5)\n+ *           i+1      i          i+1    i     i\n+ *\n+ *      One may easily use induction to prove (4) and (5).\n+ *      Note. Since the left hand side of (3) contain only i+2 bits,\n+ *            it does not necessary to do a full (53-bit) comparison\n+ *            in (3).\n+ *   3. Final rounding\n+ *      After generating the 53 bits result, we compute one more bit.\n+ *      Together with the remainder, we can decide whether the\n+ *      result is exact, bigger than 1\/2ulp, or less than 1\/2ulp\n+ *      (it will never equal to 1\/2ulp).\n+ *      The rounding mode can be detected by checking whether\n+ *      huge + tiny is equal to huge, and whether huge - tiny is\n+ *      equal to huge for some floating point number \"huge\" and \"tiny\".\n+ *\n+ * Special cases:\n+ *      sqrt(+-0) = +-0         ... exact\n+ *      sqrt(inf) = inf\n+ *      sqrt(-ve) = NaN         ... with invalid signal\n+ *      sqrt(NaN) = NaN         ... with invalid signal for signaling NaN\n+ *\n+ * Other methods : see the appended file at the end of the program below.\n+ *---------------\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static  const double    one     = 1.0, tiny=1.0e-300;\n+#else\n+static  double  one     = 1.0, tiny=1.0e-300;\n+#endif\n+\n+#ifdef __STDC__\n+        double __ieee754_sqrt(double x)\n+#else\n+        double __ieee754_sqrt(x)\n+        double x;\n+#endif\n+{\n+        double z;\n+        int     sign = (int)0x80000000;\n+        unsigned r,t1,s1,ix1,q1;\n+        int ix0,s0,q,m,t,i;\n+\n+        ix0 = __HI(x);                  \/* high word of x *\/\n+        ix1 = __LO(x);          \/* low word of x *\/\n+\n+    \/* take care of Inf and NaN *\/\n+        if((ix0&0x7ff00000)==0x7ff00000) {\n+            return x*x+x;               \/* sqrt(NaN)=NaN, sqrt(+inf)=+inf\n+                                           sqrt(-inf)=sNaN *\/\n+        }\n+    \/* take care of zero *\/\n+        if(ix0<=0) {\n+            if(((ix0&(~sign))|ix1)==0) return x;\/* sqrt(+-0) = +-0 *\/\n+            else if(ix0<0)\n+                return (x-x)\/(x-x);             \/* sqrt(-ve) = sNaN *\/\n+        }\n+    \/* normalize x *\/\n+        m = (ix0>>20);\n+        if(m==0) {                              \/* subnormal x *\/\n+            while(ix0==0) {\n+                m -= 21;\n+                ix0 |= (ix1>>11); ix1 <<= 21;\n+            }\n+            for(i=0;(ix0&0x00100000)==0;i++) ix0<<=1;\n+            m -= i-1;\n+            ix0 |= (ix1>>(32-i));\n+            ix1 <<= i;\n+        }\n+        m -= 1023;      \/* unbias exponent *\/\n+        ix0 = (ix0&0x000fffff)|0x00100000;\n+        if(m&1){        \/* odd m, double x to make it even *\/\n+            ix0 += ix0 + ((ix1&sign)>>31);\n+            ix1 += ix1;\n+        }\n+        m >>= 1;        \/* m = [m\/2] *\/\n+\n+    \/* generate sqrt(x) bit by bit *\/\n+        ix0 += ix0 + ((ix1&sign)>>31);\n+        ix1 += ix1;\n+        q = q1 = s0 = s1 = 0;   \/* [q,q1] = sqrt(x) *\/\n+        r = 0x00200000;         \/* r = moving bit from right to left *\/\n+\n+        while(r!=0) {\n+            t = s0+r;\n+            if(t<=ix0) {\n+                s0   = t+r;\n+                ix0 -= t;\n+                q   += r;\n+            }\n+            ix0 += ix0 + ((ix1&sign)>>31);\n+            ix1 += ix1;\n+            r>>=1;\n+        }\n+\n+        r = sign;\n+        while(r!=0) {\n+            t1 = s1+r;\n+            t  = s0;\n+            if((t<ix0)||((t==ix0)&&(t1<=ix1))) {\n+                s1  = t1+r;\n+                if(((t1&sign)==sign)&&(s1&sign)==0) s0 += 1;\n+                ix0 -= t;\n+                if (ix1 < t1) ix0 -= 1;\n+                ix1 -= t1;\n+                q1  += r;\n+            }\n+            ix0 += ix0 + ((ix1&sign)>>31);\n+            ix1 += ix1;\n+            r>>=1;\n+        }\n+\n+    \/* use floating add to find out rounding direction *\/\n+        if((ix0|ix1)!=0) {\n+            z = one-tiny; \/* trigger inexact flag *\/\n+            if (z>=one) {\n+                z = one+tiny;\n+                if (q1==(unsigned)0xffffffff) { q1=0; q += 1;}\n+                else if (z>one) {\n+                    if (q1==(unsigned)0xfffffffe) q+=1;\n+                    q1+=2;\n+                } else\n+                    q1 += (q1&1);\n+            }\n+        }\n+        ix0 = (q>>1)+0x3fe00000;\n+        ix1 =  q1>>1;\n+        if ((q&1)==1) ix1 |= sign;\n+        ix0 += (m <<20);\n+        __HI(z) = ix0;\n+        __LO(z) = ix1;\n+        return z;\n+}\n+\n+\/*\n+Other methods  (use floating-point arithmetic)\n+-------------\n+(This is a copy of a drafted paper by Prof W. Kahan\n+and K.C. Ng, written in May, 1986)\n+\n+        Two algorithms are given here to implement sqrt(x)\n+        (IEEE double precision arithmetic) in software.\n+        Both supply sqrt(x) correctly rounded. The first algorithm (in\n+        Section A) uses newton iterations and involves four divisions.\n+        The second one uses reciproot iterations to avoid division, but\n+        requires more multiplications. Both algorithms need the ability\n+        to chop results of arithmetic operations instead of round them,\n+        and the INEXACT flag to indicate when an arithmetic operation\n+        is executed exactly with no roundoff error, all part of the\n+        standard (IEEE 754-1985). The ability to perform shift, add,\n+        subtract and logical AND operations upon 32-bit words is needed\n+        too, though not part of the standard.\n+\n+A.  sqrt(x) by Newton Iteration\n+\n+   (1)  Initial approximation\n+\n+        Let x0 and x1 be the leading and the trailing 32-bit words of\n+        a floating point number x (in IEEE double format) respectively\n+\n+            1    11                  52                           ...widths\n+           ------------------------------------------------------\n+        x: |s|    e     |             f                         |\n+           ------------------------------------------------------\n+              msb    lsb  msb                                 lsb ...order\n+\n+\n+             ------------------------        ------------------------\n+        x0:  |s|   e    |    f1     |    x1: |          f2           |\n+             ------------------------        ------------------------\n+\n+        By performing shifts and subtracts on x0 and x1 (both regarded\n+        as integers), we obtain an 8-bit approximation of sqrt(x) as\n+        follows.\n+\n+                k  := (x0>>1) + 0x1ff80000;\n+                y0 := k - T1[31&(k>>15)].       ... y ~ sqrt(x) to 8 bits\n+        Here k is a 32-bit integer and T1[] is an integer array containing\n+        correction terms. Now magically the floating value of y (y's\n+        leading 32-bit word is y0, the value of its trailing word is 0)\n+        approximates sqrt(x) to almost 8-bit.\n+\n+        Value of T1:\n+        static int T1[32]= {\n+        0,      1024,   3062,   5746,   9193,   13348,  18162,  23592,\n+        29598,  36145,  43202,  50740,  58733,  67158,  75992,  85215,\n+        83599,  71378,  60428,  50647,  41945,  34246,  27478,  21581,\n+        16499,  12183,  8588,   5674,   3403,   1742,   661,    130,};\n+\n+    (2) Iterative refinement\n+\n+        Apply Heron's rule three times to y, we have y approximates\n+        sqrt(x) to within 1 ulp (Unit in the Last Place):\n+\n+                y := (y+x\/y)\/2          ... almost 17 sig. bits\n+                y := (y+x\/y)\/2          ... almost 35 sig. bits\n+                y := y-(y-x\/y)\/2        ... within 1 ulp\n+\n+\n+        Remark 1.\n+            Another way to improve y to within 1 ulp is:\n+\n+                y := (y+x\/y)            ... almost 17 sig. bits to 2*sqrt(x)\n+                y := y - 0x00100006     ... almost 18 sig. bits to sqrt(x)\n+\n+                                2\n+                            (x-y )*y\n+                y := y + 2* ----------  ...within 1 ulp\n+                               2\n+                             3y  + x\n+\n+\n+        This formula has one division fewer than the one above; however,\n+        it requires more multiplications and additions. Also x must be\n+        scaled in advance to avoid spurious overflow in evaluating the\n+        expression 3y*y+x. Hence it is not recommended uless division\n+        is slow. If division is very slow, then one should use the\n+        reciproot algorithm given in section B.\n+\n+    (3) Final adjustment\n+\n+        By twiddling y's last bit it is possible to force y to be\n+        correctly rounded according to the prevailing rounding mode\n+        as follows. Let r and i be copies of the rounding mode and\n+        inexact flag before entering the square root program. Also we\n+        use the expression y+-ulp for the next representable floating\n+        numbers (up and down) of y. Note that y+-ulp = either fixed\n+        point y+-1, or multiply y by nextafter(1,+-inf) in chopped\n+        mode.\n+\n+                I := FALSE;     ... reset INEXACT flag I\n+                R := RZ;        ... set rounding mode to round-toward-zero\n+                z := x\/y;       ... chopped quotient, possibly inexact\n+                If(not I) then {        ... if the quotient is exact\n+                    if(z=y) {\n+                        I := i;  ... restore inexact flag\n+                        R := r;  ... restore rounded mode\n+                        return sqrt(x):=y.\n+                    } else {\n+                        z := z - ulp;   ... special rounding\n+                    }\n+                }\n+                i := TRUE;              ... sqrt(x) is inexact\n+                If (r=RN) then z=z+ulp  ... rounded-to-nearest\n+                If (r=RP) then {        ... round-toward-+inf\n+                    y = y+ulp; z=z+ulp;\n+                }\n+                y := y+z;               ... chopped sum\n+                y0:=y0-0x00100000;      ... y := y\/2 is correctly rounded.\n+                I := i;                 ... restore inexact flag\n+                R := r;                 ... restore rounded mode\n+                return sqrt(x):=y.\n+\n+    (4) Special cases\n+\n+        Square root of +inf, +-0, or NaN is itself;\n+        Square root of a negative number is NaN with invalid signal.\n+\n+\n+B.  sqrt(x) by Reciproot Iteration\n+\n+   (1)  Initial approximation\n+\n+        Let x0 and x1 be the leading and the trailing 32-bit words of\n+        a floating point number x (in IEEE double format) respectively\n+        (see section A). By performing shifs and subtracts on x0 and y0,\n+        we obtain a 7.8-bit approximation of 1\/sqrt(x) as follows.\n+\n+            k := 0x5fe80000 - (x0>>1);\n+            y0:= k - T2[63&(k>>14)].    ... y ~ 1\/sqrt(x) to 7.8 bits\n+\n+        Here k is a 32-bit integer and T2[] is an integer array\n+        containing correction terms. Now magically the floating\n+        value of y (y's leading 32-bit word is y0, the value of\n+        its trailing word y1 is set to zero) approximates 1\/sqrt(x)\n+        to almost 7.8-bit.\n+\n+        Value of T2:\n+        static int T2[64]= {\n+        0x1500, 0x2ef8, 0x4d67, 0x6b02, 0x87be, 0xa395, 0xbe7a, 0xd866,\n+        0xf14a, 0x1091b,0x11fcd,0x13552,0x14999,0x15c98,0x16e34,0x17e5f,\n+        0x18d03,0x19a01,0x1a545,0x1ae8a,0x1b5c4,0x1bb01,0x1bfde,0x1c28d,\n+        0x1c2de,0x1c0db,0x1ba73,0x1b11c,0x1a4b5,0x1953d,0x18266,0x16be0,\n+        0x1683e,0x179d8,0x18a4d,0x19992,0x1a789,0x1b445,0x1bf61,0x1c989,\n+        0x1d16d,0x1d77b,0x1dddf,0x1e2ad,0x1e5bf,0x1e6e8,0x1e654,0x1e3cd,\n+        0x1df2a,0x1d635,0x1cb16,0x1be2c,0x1ae4e,0x19bde,0x1868e,0x16e2e,\n+        0x1527f,0x1334a,0x11051,0xe951, 0xbe01, 0x8e0d, 0x5924, 0x1edd,};\n+\n+    (2) Iterative refinement\n+\n+        Apply Reciproot iteration three times to y and multiply the\n+        result by x to get an approximation z that matches sqrt(x)\n+        to about 1 ulp. To be exact, we will have\n+                -1ulp < sqrt(x)-z<1.0625ulp.\n+\n+        ... set rounding mode to Round-to-nearest\n+           y := y*(1.5-0.5*x*y*y)       ... almost 15 sig. bits to 1\/sqrt(x)\n+           y := y*((1.5-2^-30)+0.5*x*y*y)... about 29 sig. bits to 1\/sqrt(x)\n+        ... special arrangement for better accuracy\n+           z := x*y                     ... 29 bits to sqrt(x), with z*y<1\n+           z := z + 0.5*z*(1-z*y)       ... about 1 ulp to sqrt(x)\n+\n+        Remark 2. The constant 1.5-2^-30 is chosen to bias the error so that\n+        (a) the term z*y in the final iteration is always less than 1;\n+        (b) the error in the final result is biased upward so that\n+                -1 ulp < sqrt(x) - z < 1.0625 ulp\n+            instead of |sqrt(x)-z|<1.03125ulp.\n+\n+    (3) Final adjustment\n+\n+        By twiddling y's last bit it is possible to force y to be\n+        correctly rounded according to the prevailing rounding mode\n+        as follows. Let r and i be copies of the rounding mode and\n+        inexact flag before entering the square root program. Also we\n+        use the expression y+-ulp for the next representable floating\n+        numbers (up and down) of y. Note that y+-ulp = either fixed\n+        point y+-1, or multiply y by nextafter(1,+-inf) in chopped\n+        mode.\n+\n+        R := RZ;                ... set rounding mode to round-toward-zero\n+        switch(r) {\n+            case RN:            ... round-to-nearest\n+               if(x<= z*(z-ulp)...chopped) z = z - ulp; else\n+               if(x<= z*(z+ulp)...chopped) z = z; else z = z+ulp;\n+               break;\n+            case RZ:case RM:    ... round-to-zero or round-to--inf\n+               R:=RP;           ... reset rounding mod to round-to-+inf\n+               if(x<z*z ... rounded up) z = z - ulp; else\n+               if(x>=(z+ulp)*(z+ulp) ...rounded up) z = z+ulp;\n+               break;\n+            case RP:            ... round-to-+inf\n+               if(x>(z+ulp)*(z+ulp)...chopped) z = z+2*ulp; else\n+               if(x>z*z ...chopped) z = z+ulp;\n+               break;\n+        }\n+\n+        Remark 3. The above comparisons can be done in fixed point. For\n+        example, to compare x and w=z*z chopped, it suffices to compare\n+        x1 and w1 (the trailing parts of x and w), regarding them as\n+        two's complement integers.\n+\n+        ...Is z an exact square root?\n+        To determine whether z is an exact square root of x, let z1 be the\n+        trailing part of z, and also let x0 and x1 be the leading and\n+        trailing parts of x.\n+\n+        If ((z1&0x03ffffff)!=0) ... not exact if trailing 26 bits of z!=0\n+            I := 1;             ... Raise Inexact flag: z is not exact\n+        else {\n+            j := 1 - [(x0>>20)&1]       ... j = logb(x) mod 2\n+            k := z1 >> 26;              ... get z's 25-th and 26-th\n+                                            fraction bits\n+            I := i or (k&j) or ((k&(j+j+1))!=(x1&3));\n+        }\n+        R:= r           ... restore rounded mode\n+        return sqrt(x):=z.\n+\n+        If multiplication is cheaper then the foregoing red tape, the\n+        Inexact flag can be evaluated by\n+\n+            I := i;\n+            I := (z*z!=x) or I.\n+\n+        Note that z*z can overwrite I; this value must be sensed if it is\n+        True.\n+\n+        Remark 4. If z*z = x exactly, then bit 25 to bit 0 of z1 must be\n+        zero.\n+\n+                    --------------------\n+                z1: |        f2        |\n+                    --------------------\n+                bit 31             bit 0\n+\n+        Further more, bit 27 and 26 of z1, bit 0 and 1 of x1, and the odd\n+        or even of logb(x) have the following relations:\n+\n+        -------------------------------------------------\n+        bit 27,26 of z1         bit 1,0 of x1   logb(x)\n+        -------------------------------------------------\n+        00                      00              odd and even\n+        01                      01              even\n+        10                      10              odd\n+        10                      00              even\n+        11                      01              even\n+        -------------------------------------------------\n+\n+    (4) Special cases (see (4) of Section A).\n+\n+ *\/\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_sqrt.c","additions":462,"deletions":0,"binary":false,"changes":462,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _ALLBSD_SOURCE\n+#include <machine\/endian.h>\n+#elif defined(__linux__)\n+#define __USE_BSD 1\n+#include <endian.h>\n+#endif\n+#include \"jfdlibm.h\"\n+\n+#ifdef __NEWVALID       \/* special setup for Sun test regime *\/\n+#if defined(i386) || defined(i486) || \\\n+    defined(intel) || defined(x86) || defined(arm) || \\\n+    defined(i86pc) || defined(ia64)\n+#define _LITTLE_ENDIAN\n+#endif\n+#endif\n+\n+#ifdef _LITTLE_ENDIAN\n+#define __HI(x) *(1+(int*)&x)\n+#define __LO(x) *(int*)&x\n+#define __HIp(x) *(1+(int*)x)\n+#define __LOp(x) *(int*)x\n+#else\n+#define __HI(x) *(int*)&x\n+#define __LO(x) *(1+(int*)&x)\n+#define __HIp(x) *(int*)x\n+#define __LOp(x) *(1+(int*)x)\n+#endif\n+\n+#ifndef __P\n+#ifdef __STDC__\n+#define __P(p)  p\n+#else\n+#define __P(p)  ()\n+#endif\n+#endif\n+\n+\/*\n+ * ANSI\/POSIX\n+ *\/\n+\n+extern int signgam;\n+\n+#define MAXFLOAT        ((float)3.40282346638528860e+38)\n+\n+enum fdversion {fdlibm_ieee = -1, fdlibm_svid, fdlibm_xopen, fdlibm_posix};\n+\n+#define _LIB_VERSION_TYPE enum fdversion\n+#define _LIB_VERSION _fdlib_version\n+\n+\/* if global variable _LIB_VERSION is not desirable, one may\n+ * change the following to be a constant by:\n+ *      #define _LIB_VERSION_TYPE const enum version\n+ * In that case, after one initializes the value _LIB_VERSION (see\n+ * s_lib_version.c) during compile time, it cannot be modified\n+ * in the middle of a program\n+ *\/\n+extern  _LIB_VERSION_TYPE  _LIB_VERSION;\n+\n+#define _IEEE_  fdlibm_ieee\n+#define _SVID_  fdlibm_svid\n+#define _XOPEN_ fdlibm_xopen\n+#define _POSIX_ fdlibm_posix\n+\n+struct exception {\n+        int type;\n+        char *name;\n+        double arg1;\n+        double arg2;\n+        double retval;\n+};\n+\n+#define HUGE            MAXFLOAT\n+\n+\/*\n+ * set X_TLOSS = pi*2**52, which is possibly defined in <values.h>\n+ * (one may replace the following line by \"#include <values.h>\")\n+ *\/\n+\n+#define X_TLOSS         1.41484755040568800000e+16\n+\n+#define DOMAIN          1\n+#define SING            2\n+#define OVERFLOW        3\n+#define UNDERFLOW       4\n+#define TLOSS           5\n+#define PLOSS           6\n+\n+\/*\n+ * ANSI\/POSIX\n+ *\/\n+extern double acos __P((double));\n+extern double asin __P((double));\n+extern double atan __P((double));\n+extern double atan2 __P((double, double));\n+extern double cos __P((double));\n+extern double sin __P((double));\n+extern double tan __P((double));\n+\n+extern double cosh __P((double));\n+extern double sinh __P((double));\n+extern double tanh __P((double));\n+\n+extern double exp __P((double));\n+extern double frexp __P((double, int *));\n+extern double ldexp __P((double, int));\n+extern double log __P((double));\n+extern double log10 __P((double));\n+extern double modf __P((double, double *));\n+\n+extern double sqrt __P((double));\n+\n+extern double ceil __P((double));\n+extern double fabs __P((double));\n+extern double floor __P((double));\n+extern double fmod __P((double, double));\n+\n+extern double hypot __P((double, double));\n+extern int isnan __P((double));\n+extern int finite __P((double));\n+\n+extern double atanh __P((double));\n+extern double cbrt __P((double));\n+extern double logb __P((double));\n+extern double nextafter __P((double, double));\n+extern double remainder __P((double, double));\n+#ifdef _SCALB_INT\n+extern double scalb __P((double, int));\n+#else\n+extern double scalb __P((double, double));\n+#endif\n+\n+extern int matherr __P((struct exception *));\n+\n+\/*\n+ * IEEE Test Vector\n+ *\/\n+extern double significand __P((double));\n+\n+\/*\n+ * Functions callable from C, intended to support IEEE arithmetic.\n+ *\/\n+extern double copysign __P((double, double));\n+extern int ilogb __P((double));\n+extern double rint __P((double));\n+extern double scalbn __P((double, int));\n+\n+\/*\n+ * BSD math library entry points\n+ *\/\n+extern double expm1 __P((double));\n+extern double log1p __P((double));\n+\n+\/* ieee style elementary functions *\/\n+extern double __ieee754_sqrt __P((double));\n+extern double __ieee754_acos __P((double));\n+extern double __ieee754_log __P((double));\n+extern double __ieee754_atanh __P((double));\n+extern double __ieee754_asin __P((double));\n+extern double __ieee754_atan2 __P((double,double));\n+extern double __ieee754_exp __P((double));\n+extern double __ieee754_cosh __P((double));\n+extern double __ieee754_fmod __P((double,double));\n+extern double __ieee754_log10 __P((double));\n+extern double __ieee754_sinh __P((double));\n+extern double __ieee754_hypot __P((double,double));\n+extern double __ieee754_remainder __P((double,double));\n+extern int    __ieee754_rem_pio2 __P((double,double*));\n+#ifdef _SCALB_INT\n+extern double __ieee754_scalb __P((double,int));\n+#else\n+extern double __ieee754_scalb __P((double,double));\n+#endif\n+\n+\/* fdlibm kernel function *\/\n+extern double __kernel_standard __P((double,double,int));\n+extern double __kernel_sin __P((double,double,int));\n+extern double __kernel_cos __P((double,double));\n+extern double __kernel_tan __P((double,double,int));\n+extern int    __kernel_rem_pio2 __P((double*,double*,int,int,int,const int*));\n","filename":"src\/java.base\/share\/native\/libfdlibm\/fdlibm.h","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef _JFDLIBM_H\n+#define _JFDLIBM_H\n+\n+#define _IEEE_LIBM\n+\n+\/*\n+ * In order to resolve the conflict between fdlibm and compilers\n+ * (such as keywords and built-in functions), the following\n+ * function names have to be re-mapped.\n+ *\/\n+\n+#define huge    HUGE_NUMBER\n+#define acos    jacos\n+#define asin    jasin\n+#define atan    jatan\n+#define atan2   jatan2\n+#define cos     jcos\n+#define exp     jexp\n+#define log     jlog\n+#define log10   jlog10\n+#define pow     jpow\n+#define sin     jsin\n+#define sqrt    jsqrt\n+#define cbrt    jcbrt\n+#define tan     jtan\n+#define floor   jfloor\n+#define ceil    jceil\n+#define cosh    jcosh\n+#define fmod    jmod\n+#define log10   jlog10\n+#define sinh    jsinh\n+#define fabs    jfabs\n+#define tanh    jtanh\n+#define remainder jremainder\n+#define hypot   jhypot\n+#define log1p   jlog1p\n+#define expm1   jexpm1\n+\n+#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n+#define __ieee754_sqrt          __j__ieee754_sqrt\n+#define __ieee754_acos          __j__ieee754_acos\n+#define __ieee754_log           __j__ieee754_log\n+#define __ieee754_atanh         __j__ieee754_atanh\n+#define __ieee754_asin          __j__ieee754_asin\n+#define __ieee754_atan2         __j__ieee754_atan2\n+#define __ieee754_exp           __j__ieee754_exp\n+#define __ieee754_cosh          __j__ieee754_cosh\n+#define __ieee754_fmod          __j__ieee754_fmod\n+#define __ieee754_pow           __j__ieee754_pow\n+#define __ieee754_log10         __j__ieee754_log10\n+#define __ieee754_sinh          __j__ieee754_sinh\n+#define __ieee754_hypot         __j__ieee754_hypot\n+#define __ieee754_remainder     __j__ieee754_remainder\n+#define __ieee754_rem_pio2      __j__ieee754_rem_pio2\n+#define __ieee754_scalb         __j__ieee754_scalb\n+#define __kernel_standard       __j__kernel_standard\n+#define __kernel_sin            __j__kernel_sin\n+#define __kernel_cos            __j__kernel_cos\n+#define __kernel_tan            __j__kernel_tan\n+#define __kernel_rem_pio2       __j__kernel_rem_pio2\n+#define __ieee754_log1p         __j__ieee754_log1p\n+#define __ieee754_expm1         __j__ieee754_expm1\n+#endif\n+#endif\/*_JFDLIBM_H*\/\n","filename":"src\/java.base\/share\/native\/libfdlibm\/jfdlibm.h","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * __kernel_cos( x,  y )\n+ * kernel cos function on [-pi\/4, pi\/4], pi\/4 ~ 0.785398164\n+ * Input x is assumed to be bounded by ~pi\/4 in magnitude.\n+ * Input y is the tail of x.\n+ *\n+ * Algorithm\n+ *      1. Since cos(-x) = cos(x), we need only to consider positive x.\n+ *      2. if x < 2^-27 (hx<0x3e400000 0), return 1 with inexact if x!=0.\n+ *      3. cos(x) is approximated by a polynomial of degree 14 on\n+ *         [0,pi\/4]\n+ *                                       4            14\n+ *              cos(x) ~ 1 - x*x\/2 + C1*x + ... + C6*x\n+ *         where the remez error is\n+ *\n+ *      |              2     4     6     8     10    12     14 |     -58\n+ *      |cos(x)-(1-.5*x +C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  )| <= 2\n+ *      |                                                      |\n+ *\n+ *                     4     6     8     10    12     14\n+ *      4. let r = C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  , then\n+ *             cos(x) = 1 - x*x\/2 + r\n+ *         since cos(x+y) ~ cos(x) - sin(x)*y\n+ *                        ~ cos(x) - x*y,\n+ *         a correction term is necessary in cos(x) and hence\n+ *              cos(x+y) = 1 - (x*x\/2 - (r - x*y))\n+ *         For better accuracy when x > 0.3, let qx = |x|\/4 with\n+ *         the last 32 bits mask off, and if x > 0.78125, let qx = 0.28125.\n+ *         Then\n+ *              cos(x+y) = (1-qx) - ((x*x\/2-qx) - (r-x*y)).\n+ *         Note that 1-qx and (x*x\/2-qx) is EXACT here, and the\n+ *         magnitude of the latter is at least a quarter of x*x\/2,\n+ *         thus, reducing the rounding error in the subtraction.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+one =  1.00000000000000000000e+00, \/* 0x3FF00000, 0x00000000 *\/\n+C1  =  4.16666666666666019037e-02, \/* 0x3FA55555, 0x5555554C *\/\n+C2  = -1.38888888888741095749e-03, \/* 0xBF56C16C, 0x16C15177 *\/\n+C3  =  2.48015872894767294178e-05, \/* 0x3EFA01A0, 0x19CB1590 *\/\n+C4  = -2.75573143513906633035e-07, \/* 0xBE927E4F, 0x809C52AD *\/\n+C5  =  2.08757232129817482790e-09, \/* 0x3E21EE9E, 0xBDB4B1C4 *\/\n+C6  = -1.13596475577881948265e-11; \/* 0xBDA8FAE9, 0xBE8838D4 *\/\n+\n+#ifdef __STDC__\n+        double __kernel_cos(double x, double y)\n+#else\n+        double __kernel_cos(x, y)\n+        double x,y;\n+#endif\n+{\n+        double a,hz,z,r,qx;\n+        int ix;\n+        ix = __HI(x)&0x7fffffff;        \/* ix = |x|'s high word*\/\n+        if(ix<0x3e400000) {                     \/* if x < 2**27 *\/\n+            if(((int)x)==0) return one;         \/* generate inexact *\/\n+        }\n+        z  = x*x;\n+        r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));\n+        if(ix < 0x3FD33333)                     \/* if |x| < 0.3 *\/\n+            return one - (0.5*z - (z*r - x*y));\n+        else {\n+            if(ix > 0x3fe90000) {               \/* x > 0.78125 *\/\n+                qx = 0.28125;\n+            } else {\n+                __HI(qx) = ix-0x00200000;       \/* x\/4 *\/\n+                __LO(qx) = 0;\n+            }\n+            hz = 0.5*z-qx;\n+            a  = one-qx;\n+            return a - (hz - (z*r-x*y));\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/k_cos.c","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,329 @@\n+\/*\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)\n+ * double x[],y[]; int e0,nx,prec; int ipio2[];\n+ *\n+ * __kernel_rem_pio2 return the last three digits of N with\n+ *              y = x - N*pi\/2\n+ * so that |y| < pi\/2.\n+ *\n+ * The method is to compute the integer (mod 8) and fraction parts of\n+ * (2\/pi)*x without doing the full multiplication. In general we\n+ * skip the part of the product that are known to be a huge integer (\n+ * more accurately, = 0 mod 8 ). Thus the number of operations are\n+ * independent of the exponent of the input.\n+ *\n+ * (2\/pi) is represented by an array of 24-bit integers in ipio2[].\n+ *\n+ * Input parameters:\n+ *      x[]     The input value (must be positive) is broken into nx\n+ *              pieces of 24-bit integers in double precision format.\n+ *              x[i] will be the i-th 24 bit of x. The scaled exponent\n+ *              of x[0] is given in input parameter e0 (i.e., x[0]*2^e0\n+ *              match x's up to 24 bits.\n+ *\n+ *              Example of breaking a double positive z into x[0]+x[1]+x[2]:\n+ *                      e0 = ilogb(z)-23\n+ *                      z  = scalbn(z,-e0)\n+ *              for i = 0,1,2\n+ *                      x[i] = floor(z)\n+ *                      z    = (z-x[i])*2**24\n+ *\n+ *\n+ *      y[]     output result in an array of double precision numbers.\n+ *              The dimension of y[] is:\n+ *                      24-bit  precision       1\n+ *                      53-bit  precision       2\n+ *                      64-bit  precision       2\n+ *                      113-bit precision       3\n+ *              The actual value is the sum of them. Thus for 113-bit\n+ *              precision, one may have to do something like:\n+ *\n+ *              long double t,w,r_head, r_tail;\n+ *              t = (long double)y[2] + (long double)y[1];\n+ *              w = (long double)y[0];\n+ *              r_head = t+w;\n+ *              r_tail = w - (r_head - t);\n+ *\n+ *      e0      The exponent of x[0]\n+ *\n+ *      nx      dimension of x[]\n+ *\n+ *      prec    an integer indicating the precision:\n+ *                      0       24  bits (single)\n+ *                      1       53  bits (double)\n+ *                      2       64  bits (extended)\n+ *                      3       113 bits (quad)\n+ *\n+ *      ipio2[]\n+ *              integer array, contains the (24*i)-th to (24*i+23)-th\n+ *              bit of 2\/pi after binary point. The corresponding\n+ *              floating value is\n+ *\n+ *                      ipio2[i] * 2^(-24(i+1)).\n+ *\n+ * External function:\n+ *      double scalbn(), floor();\n+ *\n+ *\n+ * Here is the description of some local variables:\n+ *\n+ *      jk      jk+1 is the initial number of terms of ipio2[] needed\n+ *              in the computation. The recommended value is 2,3,4,\n+ *              6 for single, double, extended,and quad.\n+ *\n+ *      jz      local integer variable indicating the number of\n+ *              terms of ipio2[] used.\n+ *\n+ *      jx      nx - 1\n+ *\n+ *      jv      index for pointing to the suitable ipio2[] for the\n+ *              computation. In general, we want\n+ *                      ( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )\/8\n+ *              is an integer. Thus\n+ *                      e0-3-24*jv >= 0 or (e0-3)\/24 >= jv\n+ *              Hence jv = max(0,(e0-3)\/24).\n+ *\n+ *      jp      jp+1 is the number of terms in PIo2[] needed, jp = jk.\n+ *\n+ *      q[]     double array with integral value, representing the\n+ *              24-bits chunk of the product of x and 2\/pi.\n+ *\n+ *      q0      the corresponding exponent of q[0]. Note that the\n+ *              exponent for q[i] would be q0-24*i.\n+ *\n+ *      PIo2[]  double precision array, obtained by cutting pi\/2\n+ *              into 24 bits chunks.\n+ *\n+ *      f[]     ipio2[] in floating point\n+ *\n+ *      iq[]    integer array by breaking up q[] in 24-bits chunk.\n+ *\n+ *      fq[]    final product of x*(2\/pi) in fq[0],..,fq[jk]\n+ *\n+ *      ih      integer. If >0 it indicates q[] is >= 0.5, hence\n+ *              it also indicates the *sign* of the result.\n+ *\n+ *\/\n+\n+\n+\/*\n+ * Constants:\n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n+ * to produce the hexadecimal values shown.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const int init_jk[] = {2,3,4,6}; \/* initial value for jk *\/\n+#else\n+static int init_jk[] = {2,3,4,6};\n+#endif\n+\n+#ifdef __STDC__\n+static const double PIo2[] = {\n+#else\n+static double PIo2[] = {\n+#endif\n+  1.57079625129699707031e+00, \/* 0x3FF921FB, 0x40000000 *\/\n+  7.54978941586159635335e-08, \/* 0x3E74442D, 0x00000000 *\/\n+  5.39030252995776476554e-15, \/* 0x3CF84698, 0x80000000 *\/\n+  3.28200341580791294123e-22, \/* 0x3B78CC51, 0x60000000 *\/\n+  1.27065575308067607349e-29, \/* 0x39F01B83, 0x80000000 *\/\n+  1.22933308981111328932e-36, \/* 0x387A2520, 0x40000000 *\/\n+  2.73370053816464559624e-44, \/* 0x36E38222, 0x80000000 *\/\n+  2.16741683877804819444e-51, \/* 0x3569F31D, 0x00000000 *\/\n+};\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+zero   = 0.0,\n+one    = 1.0,\n+two24   =  1.67772160000000000000e+07, \/* 0x41700000, 0x00000000 *\/\n+twon24  =  5.96046447753906250000e-08; \/* 0x3E700000, 0x00000000 *\/\n+\n+#ifdef __STDC__\n+        int __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec, const int *ipio2)\n+#else\n+        int __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)\n+        double x[], y[]; int e0,nx,prec; int ipio2[];\n+#endif\n+{\n+        int jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;\n+        double z,fw,f[20],fq[20],q[20];\n+\n+    \/* initialize jk*\/\n+        jk = init_jk[prec];\n+        jp = jk;\n+\n+    \/* determine jx,jv,q0, note that 3>q0 *\/\n+        jx =  nx-1;\n+        jv = (e0-3)\/24; if(jv<0) jv=0;\n+        q0 =  e0-24*(jv+1);\n+\n+    \/* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] *\/\n+        j = jv-jx; m = jx+jk;\n+        for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];\n+\n+    \/* compute q[0],q[1],...q[jk] *\/\n+        for (i=0;i<=jk;i++) {\n+            for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];\n+            q[i] = fw;\n+        }\n+\n+        jz = jk;\n+recompute:\n+    \/* distill q[] into iq[] reversingly *\/\n+        for(i=0,j=jz,z=q[jz];j>0;i++,j--) {\n+            fw    =  (double)((int)(twon24* z));\n+            iq[i] =  (int)(z-two24*fw);\n+            z     =  q[j-1]+fw;\n+        }\n+\n+    \/* compute n *\/\n+        z  = scalbn(z,q0);              \/* actual value of z *\/\n+        z -= 8.0*floor(z*0.125);                \/* trim off integer >= 8 *\/\n+        n  = (int) z;\n+        z -= (double)n;\n+        ih = 0;\n+        if(q0>0) {      \/* need iq[jz-1] to determine n *\/\n+            i  = (iq[jz-1]>>(24-q0)); n += i;\n+            iq[jz-1] -= i<<(24-q0);\n+            ih = iq[jz-1]>>(23-q0);\n+        }\n+        else if(q0==0) ih = iq[jz-1]>>23;\n+        else if(z>=0.5) ih=2;\n+\n+        if(ih>0) {      \/* q > 0.5 *\/\n+            n += 1; carry = 0;\n+            for(i=0;i<jz ;i++) {        \/* compute 1-q *\/\n+                j = iq[i];\n+                if(carry==0) {\n+                    if(j!=0) {\n+                        carry = 1; iq[i] = 0x1000000- j;\n+                    }\n+                } else  iq[i] = 0xffffff - j;\n+            }\n+            if(q0>0) {          \/* rare case: chance is 1 in 12 *\/\n+                switch(q0) {\n+                case 1:\n+                   iq[jz-1] &= 0x7fffff; break;\n+                case 2:\n+                   iq[jz-1] &= 0x3fffff; break;\n+                }\n+            }\n+            if(ih==2) {\n+                z = one - z;\n+                if(carry!=0) z -= scalbn(one,q0);\n+            }\n+        }\n+\n+    \/* check if recomputation is needed *\/\n+        if(z==zero) {\n+            j = 0;\n+            for (i=jz-1;i>=jk;i--) j |= iq[i];\n+            if(j==0) { \/* need recomputation *\/\n+                for(k=1;iq[jk-k]==0;k++);   \/* k = no. of terms needed *\/\n+\n+                for(i=jz+1;i<=jz+k;i++) {   \/* add q[jz+1] to q[jz+k] *\/\n+                    f[jx+i] = (double) ipio2[jv+i];\n+                    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];\n+                    q[i] = fw;\n+                }\n+                jz += k;\n+                goto recompute;\n+            }\n+        }\n+\n+    \/* chop off zero terms *\/\n+        if(z==0.0) {\n+            jz -= 1; q0 -= 24;\n+            while(iq[jz]==0) { jz--; q0-=24;}\n+        } else { \/* break z into 24-bit if necessary *\/\n+            z = scalbn(z,-q0);\n+            if(z>=two24) {\n+                fw = (double)((int)(twon24*z));\n+                iq[jz] = (int)(z-two24*fw);\n+                jz += 1; q0 += 24;\n+                iq[jz] = (int) fw;\n+            } else iq[jz] = (int) z ;\n+        }\n+\n+    \/* convert integer \"bit\" chunk to floating-point value *\/\n+        fw = scalbn(one,q0);\n+        for(i=jz;i>=0;i--) {\n+            q[i] = fw*(double)iq[i]; fw*=twon24;\n+        }\n+\n+    \/* compute PIo2[0,...,jp]*q[jz,...,0] *\/\n+        for(i=jz;i>=0;i--) {\n+            for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];\n+            fq[jz-i] = fw;\n+        }\n+\n+    \/* compress fq[] into y[] *\/\n+        switch(prec) {\n+            case 0:\n+                fw = 0.0;\n+                for (i=jz;i>=0;i--) fw += fq[i];\n+                y[0] = (ih==0)? fw: -fw;\n+                break;\n+            case 1:\n+            case 2:\n+                fw = 0.0;\n+                for (i=jz;i>=0;i--) fw += fq[i];\n+                y[0] = (ih==0)? fw: -fw;\n+                fw = fq[0]-fw;\n+                for (i=1;i<=jz;i++) fw += fq[i];\n+                y[1] = (ih==0)? fw: -fw;\n+                break;\n+            case 3:     \/* painful *\/\n+                for (i=jz;i>0;i--) {\n+                    fw      = fq[i-1]+fq[i];\n+                    fq[i]  += fq[i-1]-fw;\n+                    fq[i-1] = fw;\n+                }\n+                for (i=jz;i>1;i--) {\n+                    fw      = fq[i-1]+fq[i];\n+                    fq[i]  += fq[i-1]-fw;\n+                    fq[i-1] = fw;\n+                }\n+                for (fw=0.0,i=jz;i>=2;i--) fw += fq[i];\n+                if(ih==0) {\n+                    y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;\n+                } else {\n+                    y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;\n+                }\n+        }\n+        return n&7;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/k_rem_pio2.c","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __kernel_sin( x, y, iy)\n+ * kernel sin function on [-pi\/4, pi\/4], pi\/4 ~ 0.7854\n+ * Input x is assumed to be bounded by ~pi\/4 in magnitude.\n+ * Input y is the tail of x.\n+ * Input iy indicates whether y is 0. (if iy=0, y assume to be 0).\n+ *\n+ * Algorithm\n+ *      1. Since sin(-x) = -sin(x), we need only to consider positive x.\n+ *      2. if x < 2^-27 (hx<0x3e400000 0), return x with inexact if x!=0.\n+ *      3. sin(x) is approximated by a polynomial of degree 13 on\n+ *         [0,pi\/4]\n+ *                               3            13\n+ *              sin(x) ~ x + S1*x + ... + S6*x\n+ *         where\n+ *\n+ *      |sin(x)         2     4     6     8     10     12  |     -58\n+ *      |----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| <= 2\n+ *      |  x                                               |\n+ *\n+ *      4. sin(x+y) = sin(x) + sin'(x')*y\n+ *                  ~ sin(x) + (1-x*x\/2)*y\n+ *         For better accuracy, let\n+ *                   3      2      2      2      2\n+ *              r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))\n+ *         then                   3    2\n+ *              sin(x) = x + (S1*x + (x *(r-y\/2)+y))\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+half =  5.00000000000000000000e-01, \/* 0x3FE00000, 0x00000000 *\/\n+S1  = -1.66666666666666324348e-01, \/* 0xBFC55555, 0x55555549 *\/\n+S2  =  8.33333333332248946124e-03, \/* 0x3F811111, 0x1110F8A6 *\/\n+S3  = -1.98412698298579493134e-04, \/* 0xBF2A01A0, 0x19C161D5 *\/\n+S4  =  2.75573137070700676789e-06, \/* 0x3EC71DE3, 0x57B1FE7D *\/\n+S5  = -2.50507602534068634195e-08, \/* 0xBE5AE5E6, 0x8A2B9CEB *\/\n+S6  =  1.58969099521155010221e-10; \/* 0x3DE5D93A, 0x5ACFD57C *\/\n+\n+#ifdef __STDC__\n+        double __kernel_sin(double x, double y, int iy)\n+#else\n+        double __kernel_sin(x, y, iy)\n+        double x,y; int iy;             \/* iy=0 if y is zero *\/\n+#endif\n+{\n+        double z,r,v;\n+        int ix;\n+        ix = __HI(x)&0x7fffffff;        \/* high word of x *\/\n+        if(ix<0x3e400000)                       \/* |x| < 2**-27 *\/\n+           {if((int)x==0) return x;}            \/* generate inexact *\/\n+        z       =  x*x;\n+        v       =  z*x;\n+        r       =  S2+z*(S3+z*(S4+z*(S5+z*S6)));\n+        if(iy==0) return x+v*(S1+z*r);\n+        else      return x-((z*(half*y-v*r)-y)-v*S1);\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/k_sin.c","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,748 @@\n+\/*\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+#include <errno.h>\n+\n+#ifndef _USE_WRITE\n+#include <stdio.h>                      \/* fputs(), stderr *\/\n+#define WRITE2(u,v)     fputs(u, stderr)\n+#else   \/* !defined(_USE_WRITE) *\/\n+#include <unistd.h>                     \/* write *\/\n+#define WRITE2(u,v)     write(2, u, v)\n+#undef fflush\n+#endif  \/* !defined(_USE_WRITE) *\/\n+\n+static double zero = 0.0;       \/* used as const *\/\n+\n+\/*\n+ * Standard conformance (non-IEEE) on exception cases.\n+ * Mapping:\n+ *      1 -- acos(|x|>1)\n+ *      2 -- asin(|x|>1)\n+ *      3 -- atan2(+-0,+-0)\n+ *      4 -- hypot overflow\n+ *      5 -- cosh overflow\n+ *      6 -- exp overflow\n+ *      7 -- exp underflow\n+ *      8 -- y0(0)\n+ *      9 -- y0(-ve)\n+ *      10-- y1(0)\n+ *      11-- y1(-ve)\n+ *      12-- yn(0)\n+ *      13-- yn(-ve)\n+ *      14-- lgamma(finite) overflow\n+ *      15-- lgamma(-integer)\n+ *      16-- log(0)\n+ *      17-- log(x<0)\n+ *      18-- log10(0)\n+ *      19-- log10(x<0)\n+ *      20-- pow(0.0,0.0)\n+ *      21-- pow(x,y) overflow\n+ *      22-- pow(x,y) underflow\n+ *      23-- pow(0,negative)\n+ *      24-- pow(neg,non-integral)\n+ *      25-- sinh(finite) overflow\n+ *      26-- sqrt(negative)\n+ *      27-- fmod(x,0)\n+ *      28-- remainder(x,0)\n+ *      29-- acosh(x<1)\n+ *      30-- atanh(|x|>1)\n+ *      31-- atanh(|x|=1)\n+ *      32-- scalb overflow\n+ *      33-- scalb underflow\n+ *      34-- j0(|x|>X_TLOSS)\n+ *      35-- y0(x>X_TLOSS)\n+ *      36-- j1(|x|>X_TLOSS)\n+ *      37-- y1(x>X_TLOSS)\n+ *      38-- jn(|x|>X_TLOSS, n)\n+ *      39-- yn(x>X_TLOSS, n)\n+ *      40-- gamma(finite) overflow\n+ *      41-- gamma(-integer)\n+ *      42-- pow(NaN,0.0)\n+ *\/\n+\n+\n+#ifdef __STDC__\n+        double __kernel_standard(double x, double y, int type)\n+#else\n+        double __kernel_standard(x,y,type)\n+        double x,y; int type;\n+#endif\n+{\n+        struct exception exc;\n+#ifndef HUGE_VAL        \/* this is the only routine that uses HUGE_VAL *\/\n+#define HUGE_VAL inf\n+        double inf = 0.0;\n+\n+        __HI(inf) = 0x7ff00000; \/* set inf to infinite *\/\n+#endif\n+\n+#ifdef _USE_WRITE\n+        (void) fflush(stdout);\n+#endif\n+        exc.arg1 = x;\n+        exc.arg2 = y;\n+        switch(type) {\n+            case 1:\n+                \/* acos(|x|>1) *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"acos\";\n+                exc.retval = zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if(_LIB_VERSION == _SVID_) {\n+                    (void) WRITE2(\"acos: DOMAIN error\\n\", 19);\n+                  }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 2:\n+                \/* asin(|x|>1) *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"asin\";\n+                exc.retval = zero;\n+                if(_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if(_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"asin: DOMAIN error\\n\", 19);\n+                  }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 3:\n+                \/* atan2(+-0,+-0) *\/\n+                exc.arg1 = y;\n+                exc.arg2 = x;\n+                exc.type = DOMAIN;\n+                exc.name = \"atan2\";\n+                exc.retval = zero;\n+                if(_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if(_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"atan2: DOMAIN error\\n\", 20);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 4:\n+                \/* hypot(finite,finite) overflow *\/\n+                exc.type = OVERFLOW;\n+                exc.name = \"hypot\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = HUGE;\n+                else\n+                  exc.retval = HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 5:\n+                \/* cosh(finite) overflow *\/\n+                exc.type = OVERFLOW;\n+                exc.name = \"cosh\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = HUGE;\n+                else\n+                  exc.retval = HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 6:\n+                \/* exp(finite) overflow *\/\n+                exc.type = OVERFLOW;\n+                exc.name = \"exp\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = HUGE;\n+                else\n+                  exc.retval = HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 7:\n+                \/* exp(finite) underflow *\/\n+                exc.type = UNDERFLOW;\n+                exc.name = \"exp\";\n+                exc.retval = zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 8:\n+                \/* y0(0) = -inf *\/\n+                exc.type = DOMAIN;      \/* should be SING for IEEE *\/\n+                exc.name = \"y0\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"y0: DOMAIN error\\n\", 17);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 9:\n+                \/* y0(x<0) = NaN *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"y0\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"y0: DOMAIN error\\n\", 17);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 10:\n+                \/* y1(0) = -inf *\/\n+                exc.type = DOMAIN;      \/* should be SING for IEEE *\/\n+                exc.name = \"y1\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"y1: DOMAIN error\\n\", 17);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 11:\n+                \/* y1(x<0) = NaN *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"y1\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"y1: DOMAIN error\\n\", 17);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 12:\n+                \/* yn(n,0) = -inf *\/\n+                exc.type = DOMAIN;      \/* should be SING for IEEE *\/\n+                exc.name = \"yn\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"yn: DOMAIN error\\n\", 17);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 13:\n+                \/* yn(x<0) = NaN *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"yn\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"yn: DOMAIN error\\n\", 17);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 14:\n+                \/* lgamma(finite) overflow *\/\n+                exc.type = OVERFLOW;\n+                exc.name = \"lgamma\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = HUGE;\n+                else\n+                  exc.retval = HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                        errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 15:\n+                \/* lgamma(-integer) or lgamma(0) *\/\n+                exc.type = SING;\n+                exc.name = \"lgamma\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = HUGE;\n+                else\n+                  exc.retval = HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"lgamma: SING error\\n\", 19);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 16:\n+                \/* log(0) *\/\n+                exc.type = SING;\n+                exc.name = \"log\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"log: SING error\\n\", 16);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 17:\n+                \/* log(x<0) *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"log\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"log: DOMAIN error\\n\", 18);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 18:\n+                \/* log10(0) *\/\n+                exc.type = SING;\n+                exc.name = \"log10\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"log10: SING error\\n\", 18);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 19:\n+                \/* log10(x<0) *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"log10\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = -HUGE;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"log10: DOMAIN error\\n\", 20);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 20:\n+                \/* pow(0.0,0.0) *\/\n+                \/* error only if _LIB_VERSION == _SVID_ *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"pow\";\n+                exc.retval = zero;\n+                if (_LIB_VERSION != _SVID_) exc.retval = 1.0;\n+                else if (!matherr(&exc)) {\n+                        (void) WRITE2(\"pow(0,0): DOMAIN error\\n\", 23);\n+                        errno = EDOM;\n+                }\n+                break;\n+            case 21:\n+                \/* pow(x,y) overflow *\/\n+                exc.type = OVERFLOW;\n+                exc.name = \"pow\";\n+                if (_LIB_VERSION == _SVID_) {\n+                  exc.retval = HUGE;\n+                  y *= 0.5;\n+                  if(x<zero&&rint(y)!=y) exc.retval = -HUGE;\n+                } else {\n+                  exc.retval = HUGE_VAL;\n+                  y *= 0.5;\n+                  if(x<zero&&rint(y)!=y) exc.retval = -HUGE_VAL;\n+                }\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 22:\n+                \/* pow(x,y) underflow *\/\n+                exc.type = UNDERFLOW;\n+                exc.name = \"pow\";\n+                exc.retval =  zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 23:\n+                \/* 0**neg *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"pow\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = zero;\n+                else\n+                  exc.retval = -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"pow(0,neg): DOMAIN error\\n\", 25);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 24:\n+                \/* neg**non-integral *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"pow\";\n+                if (_LIB_VERSION == _SVID_)\n+                    exc.retval = zero;\n+                else\n+                    exc.retval = zero\/zero;     \/* X\/Open allow NaN *\/\n+                if (_LIB_VERSION == _POSIX_)\n+                   errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"neg**non-integral: DOMAIN error\\n\", 32);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 25:\n+                \/* sinh(finite) overflow *\/\n+                exc.type = OVERFLOW;\n+                exc.name = \"sinh\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = ( (x>zero) ? HUGE : -HUGE);\n+                else\n+                  exc.retval = ( (x>zero) ? HUGE_VAL : -HUGE_VAL);\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 26:\n+                \/* sqrt(x<0) *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"sqrt\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = zero;\n+                else\n+                  exc.retval = zero\/zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"sqrt: DOMAIN error\\n\", 19);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 27:\n+                \/* fmod(x,0) *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"fmod\";\n+                if (_LIB_VERSION == _SVID_)\n+                    exc.retval = x;\n+                else\n+                    exc.retval = zero\/zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                    (void) WRITE2(\"fmod:  DOMAIN error\\n\", 20);\n+                  }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 28:\n+                \/* remainder(x,0) *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"remainder\";\n+                exc.retval = zero\/zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                    (void) WRITE2(\"remainder: DOMAIN error\\n\", 24);\n+                  }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 29:\n+                \/* acosh(x<1) *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"acosh\";\n+                exc.retval = zero\/zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                    (void) WRITE2(\"acosh: DOMAIN error\\n\", 20);\n+                  }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 30:\n+                \/* atanh(|x|>1) *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"atanh\";\n+                exc.retval = zero\/zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                    (void) WRITE2(\"atanh: DOMAIN error\\n\", 20);\n+                  }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 31:\n+                \/* atanh(|x|=1) *\/\n+                exc.type = SING;\n+                exc.name = \"atanh\";\n+                exc.retval = x\/zero;    \/* sign(x)*inf *\/\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                    (void) WRITE2(\"atanh: SING error\\n\", 18);\n+                  }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 32:\n+                \/* scalb overflow; SVID also returns +-HUGE_VAL *\/\n+                exc.type = OVERFLOW;\n+                exc.name = \"scalb\";\n+                exc.retval = x > zero ? HUGE_VAL : -HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 33:\n+                \/* scalb underflow *\/\n+                exc.type = UNDERFLOW;\n+                exc.name = \"scalb\";\n+                exc.retval = copysign(zero,x);\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 34:\n+                \/* j0(|x|>X_TLOSS) *\/\n+                exc.type = TLOSS;\n+                exc.name = \"j0\";\n+                exc.retval = zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                        errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        if (_LIB_VERSION == _SVID_) {\n+                                (void) WRITE2(exc.name, 2);\n+                                (void) WRITE2(\": TLOSS error\\n\", 14);\n+                        }\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 35:\n+                \/* y0(x>X_TLOSS) *\/\n+                exc.type = TLOSS;\n+                exc.name = \"y0\";\n+                exc.retval = zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                        errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        if (_LIB_VERSION == _SVID_) {\n+                                (void) WRITE2(exc.name, 2);\n+                                (void) WRITE2(\": TLOSS error\\n\", 14);\n+                        }\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 36:\n+                \/* j1(|x|>X_TLOSS) *\/\n+                exc.type = TLOSS;\n+                exc.name = \"j1\";\n+                exc.retval = zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                        errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        if (_LIB_VERSION == _SVID_) {\n+                                (void) WRITE2(exc.name, 2);\n+                                (void) WRITE2(\": TLOSS error\\n\", 14);\n+                        }\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 37:\n+                \/* y1(x>X_TLOSS) *\/\n+                exc.type = TLOSS;\n+                exc.name = \"y1\";\n+                exc.retval = zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                        errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        if (_LIB_VERSION == _SVID_) {\n+                                (void) WRITE2(exc.name, 2);\n+                                (void) WRITE2(\": TLOSS error\\n\", 14);\n+                        }\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 38:\n+                \/* jn(|x|>X_TLOSS) *\/\n+                exc.type = TLOSS;\n+                exc.name = \"jn\";\n+                exc.retval = zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                        errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        if (_LIB_VERSION == _SVID_) {\n+                                (void) WRITE2(exc.name, 2);\n+                                (void) WRITE2(\": TLOSS error\\n\", 14);\n+                        }\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 39:\n+                \/* yn(x>X_TLOSS) *\/\n+                exc.type = TLOSS;\n+                exc.name = \"yn\";\n+                exc.retval = zero;\n+                if (_LIB_VERSION == _POSIX_)\n+                        errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                        if (_LIB_VERSION == _SVID_) {\n+                                (void) WRITE2(exc.name, 2);\n+                                (void) WRITE2(\": TLOSS error\\n\", 14);\n+                        }\n+                        errno = ERANGE;\n+                }\n+                break;\n+            case 40:\n+                \/* gamma(finite) overflow *\/\n+                exc.type = OVERFLOW;\n+                exc.name = \"gamma\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = HUGE;\n+                else\n+                  exc.retval = HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = ERANGE;\n+                else if (!matherr(&exc)) {\n+                  errno = ERANGE;\n+                }\n+                break;\n+            case 41:\n+                \/* gamma(-integer) or gamma(0) *\/\n+                exc.type = SING;\n+                exc.name = \"gamma\";\n+                if (_LIB_VERSION == _SVID_)\n+                  exc.retval = HUGE;\n+                else\n+                  exc.retval = HUGE_VAL;\n+                if (_LIB_VERSION == _POSIX_)\n+                  errno = EDOM;\n+                else if (!matherr(&exc)) {\n+                  if (_LIB_VERSION == _SVID_) {\n+                        (void) WRITE2(\"gamma: SING error\\n\", 18);\n+                      }\n+                  errno = EDOM;\n+                }\n+                break;\n+            case 42:\n+                \/* pow(NaN,0.0) *\/\n+                \/* error only if _LIB_VERSION == _SVID_ & _XOPEN_ *\/\n+                exc.type = DOMAIN;\n+                exc.name = \"pow\";\n+                exc.retval = x;\n+                if (_LIB_VERSION == _IEEE_ ||\n+                    _LIB_VERSION == _POSIX_) exc.retval = 1.0;\n+                else if (!matherr(&exc)) {\n+                        errno = EDOM;\n+                }\n+                break;\n+            default:\n+                exc.retval = zero \/ zero;\n+                errno = EINVAL;\n+                break;\n+        }\n+        return exc.retval;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/k_standard.c","additions":748,"deletions":0,"binary":false,"changes":748,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 1998, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* __kernel_tan( x, y, k )\n+ * kernel tan function on [-pi\/4, pi\/4], pi\/4 ~ 0.7854\n+ * Input x is assumed to be bounded by ~pi\/4 in magnitude.\n+ * Input y is the tail of x.\n+ * Input k indicates whether tan (if k=1) or\n+ * -1\/tan (if k= -1) is returned.\n+ *\n+ * Algorithm\n+ *      1. Since tan(-x) = -tan(x), we need only to consider positive x.\n+ *      2. if x < 2^-28 (hx<0x3e300000 0), return x with inexact if x!=0.\n+ *      3. tan(x) is approximated by a odd polynomial of degree 27 on\n+ *         [0,0.67434]\n+ *                               3             27\n+ *              tan(x) ~ x + T1*x + ... + T13*x\n+ *         where\n+ *\n+ *              |tan(x)         2     4            26   |     -59.2\n+ *              |----- - (1+T1*x +T2*x +.... +T13*x    )| <= 2\n+ *              |  x                                    |\n+ *\n+ *         Note: tan(x+y) = tan(x) + tan'(x)*y\n+ *                        ~ tan(x) + (1+x*x)*y\n+ *         Therefore, for better accuracy in computing tan(x+y), let\n+ *                   3      2      2       2       2\n+ *              r = x *(T2+x *(T3+x *(...+x *(T12+x *T13))))\n+ *         then\n+ *                                  3    2\n+ *              tan(x+y) = x + (T1*x + (x *(r+y)+y))\n+ *\n+ *      4. For x in [0.67434,pi\/4],  let y = pi\/4 - x, then\n+ *              tan(x) = tan(pi\/4-y) = (1-tan(y))\/(1+tan(y))\n+ *                     = 1 - 2*(tan(y) - (tan(y)^2)\/(1+tan(y)))\n+ *\/\n+\n+#include \"fdlibm.h\"\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+one   =  1.00000000000000000000e+00, \/* 0x3FF00000, 0x00000000 *\/\n+pio4  =  7.85398163397448278999e-01, \/* 0x3FE921FB, 0x54442D18 *\/\n+pio4lo=  3.06161699786838301793e-17, \/* 0x3C81A626, 0x33145C07 *\/\n+T[] =  {\n+  3.33333333333334091986e-01, \/* 0x3FD55555, 0x55555563 *\/\n+  1.33333333333201242699e-01, \/* 0x3FC11111, 0x1110FE7A *\/\n+  5.39682539762260521377e-02, \/* 0x3FABA1BA, 0x1BB341FE *\/\n+  2.18694882948595424599e-02, \/* 0x3F9664F4, 0x8406D637 *\/\n+  8.86323982359930005737e-03, \/* 0x3F8226E3, 0xE96E8493 *\/\n+  3.59207910759131235356e-03, \/* 0x3F6D6D22, 0xC9560328 *\/\n+  1.45620945432529025516e-03, \/* 0x3F57DBC8, 0xFEE08315 *\/\n+  5.88041240820264096874e-04, \/* 0x3F4344D8, 0xF2F26501 *\/\n+  2.46463134818469906812e-04, \/* 0x3F3026F7, 0x1A8D1068 *\/\n+  7.81794442939557092300e-05, \/* 0x3F147E88, 0xA03792A6 *\/\n+  7.14072491382608190305e-05, \/* 0x3F12B80F, 0x32F0A7E9 *\/\n+ -1.85586374855275456654e-05, \/* 0xBEF375CB, 0xDB605373 *\/\n+  2.59073051863633712884e-05, \/* 0x3EFB2A70, 0x74BF7AD4 *\/\n+};\n+\n+#ifdef __STDC__\n+        double __kernel_tan(double x, double y, int iy)\n+#else\n+        double __kernel_tan(x, y, iy)\n+        double x,y; int iy;\n+#endif\n+{\n+        double z,r,v,w,s;\n+        int ix,hx;\n+        hx = __HI(x);   \/* high word of x *\/\n+        ix = hx&0x7fffffff;     \/* high word of |x| *\/\n+        if(ix<0x3e300000) {                     \/* x < 2**-28 *\/\n+          if((int)x==0) {                       \/* generate inexact *\/\n+            if (((ix | __LO(x)) | (iy + 1)) == 0)\n+              return one \/ fabs(x);\n+            else {\n+              if (iy == 1)\n+                return x;\n+              else {    \/* compute -1 \/ (x+y) carefully *\/\n+                double a, t;\n+\n+                z = w = x + y;\n+                __LO(z) = 0;\n+                v = y - (z - x);\n+                t = a = -one \/ w;\n+                __LO(t) = 0;\n+                s = one + t * z;\n+                return t + a * (s + t * v);\n+                }\n+              }\n+          }\n+        }\n+        if(ix>=0x3FE59428) {                    \/* |x|>=0.6744 *\/\n+            if(hx<0) {x = -x; y = -y;}\n+            z = pio4-x;\n+            w = pio4lo-y;\n+            x = z+w; y = 0.0;\n+        }\n+        z       =  x*x;\n+        w       =  z*z;\n+    \/* Break x^5*(T[1]+x^2*T[2]+...) into\n+     *    x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +\n+     *    x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))\n+     *\/\n+        r = T[1]+w*(T[3]+w*(T[5]+w*(T[7]+w*(T[9]+w*T[11]))));\n+        v = z*(T[2]+w*(T[4]+w*(T[6]+w*(T[8]+w*(T[10]+w*T[12])))));\n+        s = z*x;\n+        r = y + z*(s*(r+v)+y);\n+        r += T[0]*s;\n+        w = x+r;\n+        if(ix>=0x3FE59428) {\n+            v = (double)iy;\n+            return (double)(1-((hx>>30)&2))*(v-2.0*(x-(w*w\/(w+v)-r)));\n+        }\n+        if(iy==1) return w;\n+        else {          \/* if allow error up to 2 ulp,\n+                           simply return -1.0\/(x+r) here *\/\n+     \/*  compute -1.0\/(x+r) accurately *\/\n+            double a,t;\n+            z  = w;\n+            __LO(z) = 0;\n+            v  = r-(z - x);     \/* z+v = r+x *\/\n+            t = a  = -1.0\/w;    \/* a = -1.0\/w *\/\n+            __LO(t) = 0;\n+            s  = 1.0+t*z;\n+            return t+a*(s+t*v);\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/k_tan.c","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* atan(x)\n+ * Method\n+ *   1. Reduce x to positive by atan(x) = -atan(-x).\n+ *   2. According to the integer k=4t+0.25 chopped, t=x, the argument\n+ *      is further reduced to one of the following intervals and the\n+ *      arctangent of t is evaluated by the corresponding formula:\n+ *\n+ *      [0,7\/16]      atan(x) = t-t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)\n+ *      [7\/16,11\/16]  atan(x) = atan(1\/2) + atan( (t-0.5)\/(1+t\/2) )\n+ *      [11\/16.19\/16] atan(x) = atan( 1 ) + atan( (t-1)\/(1+t) )\n+ *      [19\/16,39\/16] atan(x) = atan(3\/2) + atan( (t-1.5)\/(1+1.5t) )\n+ *      [39\/16,INF]   atan(x) = atan(INF) + atan( -1\/t )\n+ *\n+ * Constants:\n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n+ * to produce the hexadecimal values shown.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double atanhi[] = {\n+#else\n+static double atanhi[] = {\n+#endif\n+  4.63647609000806093515e-01, \/* atan(0.5)hi 0x3FDDAC67, 0x0561BB4F *\/\n+  7.85398163397448278999e-01, \/* atan(1.0)hi 0x3FE921FB, 0x54442D18 *\/\n+  9.82793723247329054082e-01, \/* atan(1.5)hi 0x3FEF730B, 0xD281F69B *\/\n+  1.57079632679489655800e+00, \/* atan(inf)hi 0x3FF921FB, 0x54442D18 *\/\n+};\n+\n+#ifdef __STDC__\n+static const double atanlo[] = {\n+#else\n+static double atanlo[] = {\n+#endif\n+  2.26987774529616870924e-17, \/* atan(0.5)lo 0x3C7A2B7F, 0x222F65E2 *\/\n+  3.06161699786838301793e-17, \/* atan(1.0)lo 0x3C81A626, 0x33145C07 *\/\n+  1.39033110312309984516e-17, \/* atan(1.5)lo 0x3C700788, 0x7AF0CBBD *\/\n+  6.12323399573676603587e-17, \/* atan(inf)lo 0x3C91A626, 0x33145C07 *\/\n+};\n+\n+#ifdef __STDC__\n+static const double aT[] = {\n+#else\n+static double aT[] = {\n+#endif\n+  3.33333333333329318027e-01, \/* 0x3FD55555, 0x5555550D *\/\n+ -1.99999999998764832476e-01, \/* 0xBFC99999, 0x9998EBC4 *\/\n+  1.42857142725034663711e-01, \/* 0x3FC24924, 0x920083FF *\/\n+ -1.11111104054623557880e-01, \/* 0xBFBC71C6, 0xFE231671 *\/\n+  9.09088713343650656196e-02, \/* 0x3FB745CD, 0xC54C206E *\/\n+ -7.69187620504482999495e-02, \/* 0xBFB3B0F2, 0xAF749A6D *\/\n+  6.66107313738753120669e-02, \/* 0x3FB10D66, 0xA0D03D51 *\/\n+ -5.83357013379057348645e-02, \/* 0xBFADDE2D, 0x52DEFD9A *\/\n+  4.97687799461593236017e-02, \/* 0x3FA97B4B, 0x24760DEB *\/\n+ -3.65315727442169155270e-02, \/* 0xBFA2B444, 0x2C6A6C2F *\/\n+  1.62858201153657823623e-02, \/* 0x3F90AD3A, 0xE322DA11 *\/\n+};\n+\n+#ifdef __STDC__\n+        static const double\n+#else\n+        static double\n+#endif\n+one   = 1.0,\n+huge   = 1.0e300;\n+\n+#ifdef __STDC__\n+        double atan(double x)\n+#else\n+        double atan(x)\n+        double x;\n+#endif\n+{\n+        double w,s1,s2,z;\n+        int ix,hx,id;\n+\n+        hx = __HI(x);\n+        ix = hx&0x7fffffff;\n+        if(ix>=0x44100000) {    \/* if |x| >= 2^66 *\/\n+            if(ix>0x7ff00000||\n+                (ix==0x7ff00000&&(__LO(x)!=0)))\n+                return x+x;             \/* NaN *\/\n+            if(hx>0) return  atanhi[3]+atanlo[3];\n+            else     return -atanhi[3]-atanlo[3];\n+        } if (ix < 0x3fdc0000) {        \/* |x| < 0.4375 *\/\n+            if (ix < 0x3e200000) {      \/* |x| < 2^-29 *\/\n+                if(huge+x>one) return x;        \/* raise inexact *\/\n+            }\n+            id = -1;\n+        } else {\n+        x = fabs(x);\n+        if (ix < 0x3ff30000) {          \/* |x| < 1.1875 *\/\n+            if (ix < 0x3fe60000) {      \/* 7\/16 <=|x|<11\/16 *\/\n+                id = 0; x = (2.0*x-one)\/(2.0+x);\n+            } else {                    \/* 11\/16<=|x|< 19\/16 *\/\n+                id = 1; x  = (x-one)\/(x+one);\n+            }\n+        } else {\n+            if (ix < 0x40038000) {      \/* |x| < 2.4375 *\/\n+                id = 2; x  = (x-1.5)\/(one+1.5*x);\n+            } else {                    \/* 2.4375 <= |x| < 2^66 *\/\n+                id = 3; x  = -1.0\/x;\n+            }\n+        }}\n+    \/* end of argument reduction *\/\n+        z = x*x;\n+        w = z*z;\n+    \/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly *\/\n+        s1 = z*(aT[0]+w*(aT[2]+w*(aT[4]+w*(aT[6]+w*(aT[8]+w*aT[10])))));\n+        s2 = w*(aT[1]+w*(aT[3]+w*(aT[5]+w*(aT[7]+w*aT[9]))));\n+        if (id<0) return x - x*(s1+s2);\n+        else {\n+            z = atanhi[id] - ((x*(s1+s2) - atanlo[id]) - x);\n+            return (hx<0)? -z:z;\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_atan.c","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * ceil(x)\n+ * Return x rounded toward -inf to integral value\n+ * Method:\n+ *      Bit twiddling.\n+ * Exception:\n+ *      Inexact flag raised if x not equal to ceil(x).\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double huge = 1.0e300;\n+#else\n+static double huge = 1.0e300;\n+#endif\n+\n+#ifdef __STDC__\n+        double ceil(double x)\n+#else\n+        double ceil(x)\n+        double x;\n+#endif\n+{\n+        int i0,i1,j0;\n+        unsigned i,j;\n+        i0 =  __HI(x);\n+        i1 =  __LO(x);\n+        j0 = ((i0>>20)&0x7ff)-0x3ff;\n+        if(j0<20) {\n+            if(j0<0) {  \/* raise inexact if x != 0 *\/\n+                if(huge+x>0.0) {\/* return 0*sign(x) if |x|<1 *\/\n+                    if(i0<0) {i0=0x80000000;i1=0;}\n+                    else if((i0|i1)!=0) { i0=0x3ff00000;i1=0;}\n+                }\n+            } else {\n+                i = (0x000fffff)>>j0;\n+                if(((i0&i)|i1)==0) return x; \/* x is integral *\/\n+                if(huge+x>0.0) {        \/* raise inexact flag *\/\n+                    if(i0>0) i0 += (0x00100000)>>j0;\n+                    i0 &= (~i); i1=0;\n+                }\n+            }\n+        } else if (j0>51) {\n+            if(j0==0x400) return x+x;   \/* inf or NaN *\/\n+            else return x;              \/* x is integral *\/\n+        } else {\n+            i = ((unsigned)(0xffffffff))>>(j0-20);\n+            if((i1&i)==0) return x;     \/* x is integral *\/\n+            if(huge+x>0.0) {            \/* raise inexact flag *\/\n+                if(i0>0) {\n+                    if(j0==20) i0+=1;\n+                    else {\n+                        j = i1 + (1<<(52-j0));\n+                        if(j<i1) i0+=1; \/* got a carry *\/\n+                        i1 = j;\n+                    }\n+                }\n+                i1 &= (~i);\n+            }\n+        }\n+        __HI(x) = i0;\n+        __LO(x) = i1;\n+        return x;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_ceil.c","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * copysign(double x, double y)\n+ * copysign(x,y) returns a value with the magnitude of x and\n+ * with the sign bit of y.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double copysign(double x, double y)\n+#else\n+        double copysign(x,y)\n+        double x,y;\n+#endif\n+{\n+        __HI(x) = (__HI(x)&0x7fffffff)|(__HI(y)&0x80000000);\n+        return x;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_copysign.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* cos(x)\n+ * Return cosine function of x.\n+ *\n+ * kernel function:\n+ *      __kernel_sin            ... sine function on [-pi\/4,pi\/4]\n+ *      __kernel_cos            ... cosine function on [-pi\/4,pi\/4]\n+ *      __ieee754_rem_pio2      ... argument reduction routine\n+ *\n+ * Method.\n+ *      Let S,C and T denote the sin, cos and tan respectively on\n+ *      [-PI\/4, +PI\/4]. Reduce the argument x to y1+y2 = x-k*pi\/2\n+ *      in [-pi\/4 , +pi\/4], and let n = k mod 4.\n+ *      We have\n+ *\n+ *          n        sin(x)      cos(x)        tan(x)\n+ *     ----------------------------------------------------------\n+ *          0          S           C             T\n+ *          1          C          -S            -1\/T\n+ *          2         -S          -C             T\n+ *          3         -C           S            -1\/T\n+ *     ----------------------------------------------------------\n+ *\n+ * Special cases:\n+ *      Let trig be any of sin, cos, or tan.\n+ *      trig(+-INF)  is NaN, with signals;\n+ *      trig(NaN)    is that NaN;\n+ *\n+ * Accuracy:\n+ *      TRIG(x) returns trig(x) nearly rounded\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double cos(double x)\n+#else\n+        double cos(x)\n+        double x;\n+#endif\n+{\n+        double y[2],z=0.0;\n+        int n, ix;\n+\n+    \/* High word of x. *\/\n+        ix = __HI(x);\n+\n+    \/* |x| ~< pi\/4 *\/\n+        ix &= 0x7fffffff;\n+        if(ix <= 0x3fe921fb) return __kernel_cos(x,z);\n+\n+    \/* cos(Inf or NaN) is NaN *\/\n+        else if (ix>=0x7ff00000) return x-x;\n+\n+    \/* argument reduction needed *\/\n+        else {\n+            n = __ieee754_rem_pio2(x,y);\n+            switch(n&3) {\n+                case 0: return  __kernel_cos(y[0],y[1]);\n+                case 1: return -__kernel_sin(y[0],y[1],1);\n+                case 2: return -__kernel_cos(y[0],y[1]);\n+                default:\n+                        return  __kernel_sin(y[0],y[1],1);\n+            }\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_cos.c","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* expm1(x)\n+ * Returns exp(x)-1, the exponential of x minus 1.\n+ *\n+ * Method\n+ *   1. Argument reduction:\n+ *      Given x, find r and integer k such that\n+ *\n+ *               x = k*ln2 + r,  |r| <= 0.5*ln2 ~ 0.34658\n+ *\n+ *      Here a correction term c will be computed to compensate\n+ *      the error in r when rounded to a floating-point number.\n+ *\n+ *   2. Approximating expm1(r) by a special rational function on\n+ *      the interval [0,0.34658]:\n+ *      Since\n+ *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 - r^4\/360 + ...\n+ *      we define R1(r*r) by\n+ *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 * R1(r*r)\n+ *      That is,\n+ *          R1(r**2) = 6\/r *((exp(r)+1)\/(exp(r)-1) - 2\/r)\n+ *                   = 6\/r * ( 1 + 2.0*(1\/(exp(r)-1) - 1\/r))\n+ *                   = 1 - r^2\/60 + r^4\/2520 - r^6\/100800 + ...\n+ *      We use a special Reme algorithm on [0,0.347] to generate\n+ *      a polynomial of degree 5 in r*r to approximate R1. The\n+ *      maximum error of this polynomial approximation is bounded\n+ *      by 2**-61. In other words,\n+ *          R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5\n+ *      where   Q1  =  -1.6666666666666567384E-2,\n+ *              Q2  =   3.9682539681370365873E-4,\n+ *              Q3  =  -9.9206344733435987357E-6,\n+ *              Q4  =   2.5051361420808517002E-7,\n+ *              Q5  =  -6.2843505682382617102E-9;\n+ *      (where z=r*r, and the values of Q1 to Q5 are listed below)\n+ *      with error bounded by\n+ *          |                  5           |     -61\n+ *          | 1.0+Q1*z+...+Q5*z   -  R1(z) | <= 2\n+ *          |                              |\n+ *\n+ *      expm1(r) = exp(r)-1 is then computed by the following\n+ *      specific way which minimize the accumulation rounding error:\n+ *                             2     3\n+ *                            r     r    [ 3 - (R1 + R1*r\/2)  ]\n+ *            expm1(r) = r + --- + --- * [--------------------]\n+ *                            2     2    [ 6 - r*(3 - R1*r\/2) ]\n+ *\n+ *      To compensate the error in the argument reduction, we use\n+ *              expm1(r+c) = expm1(r) + c + expm1(r)*c\n+ *                         ~ expm1(r) + c + r*c\n+ *      Thus c+r*c will be added in as the correction terms for\n+ *      expm1(r+c). Now rearrange the term to avoid optimization\n+ *      screw up:\n+ *                      (      2                                    2 )\n+ *                      ({  ( r    [ R1 -  (3 - R1*r\/2) ]  )  }    r  )\n+ *       expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )\n+ *                      ({  ( 2    [ 6 - r*(3 - R1*r\/2) ]  )  }    2  )\n+ *                      (                                             )\n+ *\n+ *                 = r - E\n+ *   3. Scale back to obtain expm1(x):\n+ *      From step 1, we have\n+ *         expm1(x) = either 2^k*[expm1(r)+1] - 1\n+ *                  = or     2^k*[expm1(r) + (1-2^-k)]\n+ *   4. Implementation notes:\n+ *      (A). To save one multiplication, we scale the coefficient Qi\n+ *           to Qi*2^i, and replace z by (x^2)\/2.\n+ *      (B). To achieve maximum accuracy, we compute expm1(x) by\n+ *        (i)   if x < -56*ln2, return -1.0, (raise inexact if x!=inf)\n+ *        (ii)  if k=0, return r-E\n+ *        (iii) if k=-1, return 0.5*(r-E)-0.5\n+ *        (iv)  if k=1 if r < -0.25, return 2*((r+0.5)- E)\n+ *                     else          return  1.0+2.0*(r-E);\n+ *        (v)   if (k<-2||k>56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)\n+ *        (vi)  if k <= 20, return 2^k((1-2^-k)-(E-r)), else\n+ *        (vii) return 2^k(1-((E+2^-k)-r))\n+ *\n+ * Special cases:\n+ *      expm1(INF) is INF, expm1(NaN) is NaN;\n+ *      expm1(-INF) is -1, and\n+ *      for finite argument, only expm1(0)=0 is exact.\n+ *\n+ * Accuracy:\n+ *      according to an error analysis, the error is always less than\n+ *      1 ulp (unit in the last place).\n+ *\n+ * Misc. info.\n+ *      For IEEE double\n+ *          if x >  7.09782712893383973096e+02 then expm1(x) overflow\n+ *\n+ * Constants:\n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n+ * to produce the hexadecimal values shown.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+one             = 1.0,\n+huge            = 1.0e+300,\n+tiny            = 1.0e-300,\n+o_threshold     = 7.09782712893383973096e+02,\/* 0x40862E42, 0xFEFA39EF *\/\n+ln2_hi          = 6.93147180369123816490e-01,\/* 0x3fe62e42, 0xfee00000 *\/\n+ln2_lo          = 1.90821492927058770002e-10,\/* 0x3dea39ef, 0x35793c76 *\/\n+invln2          = 1.44269504088896338700e+00,\/* 0x3ff71547, 0x652b82fe *\/\n+        \/* scaled coefficients related to expm1 *\/\n+Q1  =  -3.33333333333331316428e-02, \/* BFA11111 111110F4 *\/\n+Q2  =   1.58730158725481460165e-03, \/* 3F5A01A0 19FE5585 *\/\n+Q3  =  -7.93650757867487942473e-05, \/* BF14CE19 9EAADBB7 *\/\n+Q4  =   4.00821782732936239552e-06, \/* 3ED0CFCA 86E65239 *\/\n+Q5  =  -2.01099218183624371326e-07; \/* BE8AFDB7 6E09C32D *\/\n+\n+#ifdef __STDC__\n+        double expm1(double x)\n+#else\n+        double expm1(x)\n+        double x;\n+#endif\n+{\n+        double y,hi,lo,c=0,t,e,hxs,hfx,r1;\n+        int k,xsb;\n+        unsigned hx;\n+\n+        hx  = __HI(x);  \/* high word of x *\/\n+        xsb = hx&0x80000000;            \/* sign bit of x *\/\n+        if(xsb==0) y=x; else y= -x;     \/* y = |x| *\/\n+        hx &= 0x7fffffff;               \/* high word of |x| *\/\n+\n+    \/* filter out huge and non-finite argument *\/\n+        if(hx >= 0x4043687A) {                  \/* if |x|>=56*ln2 *\/\n+            if(hx >= 0x40862E42) {              \/* if |x|>=709.78... *\/\n+                if(hx>=0x7ff00000) {\n+                    if(((hx&0xfffff)|__LO(x))!=0)\n+                         return x+x;     \/* NaN *\/\n+                    else return (xsb==0)? x:-1.0;\/* exp(+-inf)={inf,-1} *\/\n+                }\n+                if(x > o_threshold) return huge*huge; \/* overflow *\/\n+            }\n+            if(xsb!=0) { \/* x < -56*ln2, return -1.0 with inexact *\/\n+                if(x+tiny<0.0)          \/* raise inexact *\/\n+                return tiny-one;        \/* return -1 *\/\n+            }\n+        }\n+\n+    \/* argument reduction *\/\n+        if(hx > 0x3fd62e42) {           \/* if  |x| > 0.5 ln2 *\/\n+            if(hx < 0x3FF0A2B2) {       \/* and |x| < 1.5 ln2 *\/\n+                if(xsb==0)\n+                    {hi = x - ln2_hi; lo =  ln2_lo;  k =  1;}\n+                else\n+                    {hi = x + ln2_hi; lo = -ln2_lo;  k = -1;}\n+            } else {\n+                k  = invln2*x+((xsb==0)?0.5:-0.5);\n+                t  = k;\n+                hi = x - t*ln2_hi;      \/* t*ln2_hi is exact here *\/\n+                lo = t*ln2_lo;\n+            }\n+            x  = hi - lo;\n+            c  = (hi-x)-lo;\n+        }\n+        else if(hx < 0x3c900000) {      \/* when |x|<2**-54, return x *\/\n+            t = huge+x; \/* return x with inexact flags when x!=0 *\/\n+            return x - (t-(huge+x));\n+        }\n+        else k = 0;\n+\n+    \/* x is now in primary range *\/\n+        hfx = 0.5*x;\n+        hxs = x*hfx;\n+        r1 = one+hxs*(Q1+hxs*(Q2+hxs*(Q3+hxs*(Q4+hxs*Q5))));\n+        t  = 3.0-r1*hfx;\n+        e  = hxs*((r1-t)\/(6.0 - x*t));\n+        if(k==0) return x - (x*e-hxs);          \/* c is 0 *\/\n+        else {\n+            e  = (x*(e-c)-c);\n+            e -= hxs;\n+            if(k== -1) return 0.5*(x-e)-0.5;\n+            if(k==1) {\n+                if(x < -0.25) return -2.0*(e-(x+0.5));\n+                else          return  one+2.0*(x-e);\n+            }\n+            if (k <= -2 || k>56) {   \/* suffice to return exp(x)-1 *\/\n+                y = one-(e-x);\n+                __HI(y) += (k<<20);     \/* add k to y's exponent *\/\n+                return y-one;\n+            }\n+            t = one;\n+            if(k<20) {\n+                __HI(t) = 0x3ff00000 - (0x200000>>k);  \/* t=1-2^-k *\/\n+                y = t-(e-x);\n+                __HI(y) += (k<<20);     \/* add k to y's exponent *\/\n+           } else {\n+                __HI(t)  = ((0x3ff-k)<<20);     \/* 2^-k *\/\n+                y = x-(e+t);\n+                y += one;\n+                __HI(y) += (k<<20);     \/* add k to y's exponent *\/\n+            }\n+        }\n+        return y;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_expm1.c","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * fabs(x) returns the absolute value of x.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double fabs(double x)\n+#else\n+        double fabs(x)\n+        double x;\n+#endif\n+{\n+        __HI(x) &= 0x7fffffff;\n+        return x;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_fabs.c","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * finite(x) returns 1 is x is finite, else 0;\n+ * no branching!\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        int finite(double x)\n+#else\n+        int finite(x)\n+        double x;\n+#endif\n+{\n+        int hx;\n+        hx = __HI(x);\n+        return  (unsigned)((hx&0x7fffffff)-0x7ff00000)>>31;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_finite.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * floor(x)\n+ * Return x rounded toward -inf to integral value\n+ * Method:\n+ *      Bit twiddling.\n+ * Exception:\n+ *      Inexact flag raised if x not equal to floor(x).\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double huge = 1.0e300;\n+#else\n+static double huge = 1.0e300;\n+#endif\n+\n+#ifdef __STDC__\n+        double floor(double x)\n+#else\n+        double floor(x)\n+        double x;\n+#endif\n+{\n+        int i0,i1,j0;\n+        unsigned i,j;\n+        i0 =  __HI(x);\n+        i1 =  __LO(x);\n+        j0 = ((i0>>20)&0x7ff)-0x3ff;\n+        if(j0<20) {\n+            if(j0<0) {  \/* raise inexact if x != 0 *\/\n+                if(huge+x>0.0) {\/* return 0*sign(x) if |x|<1 *\/\n+                    if(i0>=0) {i0=i1=0;}\n+                    else if(((i0&0x7fffffff)|i1)!=0)\n+                        { i0=0xbff00000;i1=0;}\n+                }\n+            } else {\n+                i = (0x000fffff)>>j0;\n+                if(((i0&i)|i1)==0) return x; \/* x is integral *\/\n+                if(huge+x>0.0) {        \/* raise inexact flag *\/\n+                    if(i0<0) i0 += (0x00100000)>>j0;\n+                    i0 &= (~i); i1=0;\n+                }\n+            }\n+        } else if (j0>51) {\n+            if(j0==0x400) return x+x;   \/* inf or NaN *\/\n+            else return x;              \/* x is integral *\/\n+        } else {\n+            i = ((unsigned)(0xffffffff))>>(j0-20);\n+            if((i1&i)==0) return x;     \/* x is integral *\/\n+            if(huge+x>0.0) {            \/* raise inexact flag *\/\n+                if(i0<0) {\n+                    if(j0==20) i0+=1;\n+                    else {\n+                        j = i1+(1<<(52-j0));\n+                        if(j<i1) i0 +=1 ;       \/* got a carry *\/\n+                        i1=j;\n+                    }\n+                }\n+                i1 &= (~i);\n+            }\n+        }\n+        __HI(x) = i0;\n+        __LO(x) = i1;\n+        return x;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_floor.c","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * for non-zero x\n+ *      x = frexp(arg,&exp);\n+ * return a double fp quantity x such that 0.5 <= |x| <1.0\n+ * and the corresponding binary exponent \"exp\". That is\n+ *      arg = x*2^exp.\n+ * If arg is inf, 0.0, or NaN, then frexp(arg,&exp) returns arg\n+ * with *exp=0.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+two54 =  1.80143985094819840000e+16; \/* 0x43500000, 0x00000000 *\/\n+\n+#ifdef __STDC__\n+        double frexp(double x, int *eptr)\n+#else\n+        double frexp(x, eptr)\n+        double x; int *eptr;\n+#endif\n+{\n+        int  hx, ix, lx;\n+        hx = __HI(x);\n+        ix = 0x7fffffff&hx;\n+        lx = __LO(x);\n+        *eptr = 0;\n+        if(ix>=0x7ff00000||((ix|lx)==0)) return x;      \/* 0,inf,nan *\/\n+        if (ix<0x00100000) {            \/* subnormal *\/\n+            x *= two54;\n+            hx = __HI(x);\n+            ix = hx&0x7fffffff;\n+            *eptr = -54;\n+        }\n+        *eptr += (ix>>20)-1022;\n+        hx = (hx&0x800fffff)|0x3fe00000;\n+        __HI(x) = hx;\n+        return x;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_frexp.c","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* ilogb(double x)\n+ * return the binary exponent of non-zero x\n+ * ilogb(0) = 0x80000001\n+ * ilogb(inf\/NaN) = 0x7fffffff (no signal is raised)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        int ilogb(double x)\n+#else\n+        int ilogb(x)\n+        double x;\n+#endif\n+{\n+        int hx,lx,ix;\n+\n+        hx  = (__HI(x))&0x7fffffff;     \/* high word of x *\/\n+        if(hx<0x00100000) {\n+            lx = __LO(x);\n+            if((hx|lx)==0)\n+                return 0x80000001;      \/* ilogb(0) = 0x80000001 *\/\n+            else                        \/* subnormal x *\/\n+                if(hx==0) {\n+                    for (ix = -1043; lx>0; lx<<=1) ix -=1;\n+                } else {\n+                    for (ix = -1022,hx<<=11; hx>0; hx<<=1) ix -=1;\n+                }\n+            return ix;\n+        }\n+        else if (hx<0x7ff00000) return (hx>>20)-1023;\n+        else return 0x7fffffff;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_ilogb.c","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * isnan(x) returns 1 is x is nan, else 0;\n+ * no branching!\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        int isnan(double x)\n+#else\n+        int isnan(x)\n+        double x;\n+#endif\n+{\n+        int hx,lx;\n+        hx = (__HI(x)&0x7fffffff);\n+        lx = __LO(x);\n+        hx |= (unsigned)(lx|(-lx))>>31;\n+        hx = 0x7ff00000 - hx;\n+        return ((unsigned)(hx))>>31;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_isnan.c","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+#include <errno.h>\n+\n+#ifdef __STDC__\n+        double ldexp(double value, int exp)\n+#else\n+        double ldexp(value, exp)\n+        double value; int exp;\n+#endif\n+{\n+        if(!finite(value)||value==0.0) return value;\n+        value = scalbn(value,exp);\n+        if(!finite(value)||value==0.0) errno = ERANGE;\n+        return value;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_ldexp.c","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * MACRO for standards\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+\/*\n+ * define and initialize _LIB_VERSION\n+ *\/\n+#ifdef _POSIX_MODE\n+_LIB_VERSION_TYPE _LIB_VERSION = _POSIX_;\n+#else\n+#ifdef _XOPEN_MODE\n+_LIB_VERSION_TYPE _LIB_VERSION = _XOPEN_;\n+#else\n+#ifdef _SVID3_MODE\n+_LIB_VERSION_TYPE _LIB_VERSION = _SVID_;\n+#else                                   \/* default _IEEE_MODE *\/\n+_LIB_VERSION_TYPE _LIB_VERSION = _IEEE_;\n+#endif\n+#endif\n+#endif\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_lib_version.c","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 1998, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* double log1p(double x)\n+ *\n+ * Method :\n+ *   1. Argument Reduction: find k and f such that\n+ *                      1+x = 2^k * (1+f),\n+ *         where  sqrt(2)\/2 < 1+f < sqrt(2) .\n+ *\n+ *      Note. If k=0, then f=x is exact. However, if k!=0, then f\n+ *      may not be representable exactly. In that case, a correction\n+ *      term is need. Let u=1+x rounded. Let c = (1+x)-u, then\n+ *      log(1+x) - log(u) ~ c\/u. Thus, we proceed to compute log(u),\n+ *      and add back the correction term c\/u.\n+ *      (Note: when x > 2**53, one can simply return log(x))\n+ *\n+ *   2. Approximation of log1p(f).\n+ *      Let s = f\/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)\n+ *               = 2s + 2\/3 s**3 + 2\/5 s**5 + .....,\n+ *               = 2s + s*R\n+ *      We use a special Reme algorithm on [0,0.1716] to generate\n+ *      a polynomial of degree 14 to approximate R The maximum error\n+ *      of this polynomial approximation is bounded by 2**-58.45. In\n+ *      other words,\n+ *                      2      4      6      8      10      12      14\n+ *          R(z) ~ Lp1*s +Lp2*s +Lp3*s +Lp4*s +Lp5*s  +Lp6*s  +Lp7*s\n+ *      (the values of Lp1 to Lp7 are listed in the program)\n+ *      and\n+ *          |      2          14          |     -58.45\n+ *          | Lp1*s +...+Lp7*s    -  R(z) | <= 2\n+ *          |                             |\n+ *      Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f\/2.\n+ *      In order to guarantee error in log below 1ulp, we compute log\n+ *      by\n+ *              log1p(f) = f - (hfsq - s*(hfsq+R)).\n+ *\n+ *      3. Finally, log1p(x) = k*ln2 + log1p(f).\n+ *                           = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))\n+ *         Here ln2 is split into two floating point number:\n+ *                      ln2_hi + ln2_lo,\n+ *         where n*ln2_hi is always exact for |n| < 2000.\n+ *\n+ * Special cases:\n+ *      log1p(x) is NaN with signal if x < -1 (including -INF) ;\n+ *      log1p(+INF) is +INF; log1p(-1) is -INF with signal;\n+ *      log1p(NaN) is that NaN with no signal.\n+ *\n+ * Accuracy:\n+ *      according to an error analysis, the error is always less than\n+ *      1 ulp (unit in the last place).\n+ *\n+ * Constants:\n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n+ * to produce the hexadecimal values shown.\n+ *\n+ * Note: Assuming log() return accurate answer, the following\n+ *       algorithm can be used to compute log1p(x) to within a few ULP:\n+ *\n+ *              u = 1+x;\n+ *              if(u==1.0) return x ; else\n+ *                         return log(u)*(x\/(u-1.0));\n+ *\n+ *       See HP-15C Advanced Functions Handbook, p.193.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+ln2_hi  =  6.93147180369123816490e-01,  \/* 3fe62e42 fee00000 *\/\n+ln2_lo  =  1.90821492927058770002e-10,  \/* 3dea39ef 35793c76 *\/\n+two54   =  1.80143985094819840000e+16,  \/* 43500000 00000000 *\/\n+Lp1 = 6.666666666666735130e-01,  \/* 3FE55555 55555593 *\/\n+Lp2 = 3.999999999940941908e-01,  \/* 3FD99999 9997FA04 *\/\n+Lp3 = 2.857142874366239149e-01,  \/* 3FD24924 94229359 *\/\n+Lp4 = 2.222219843214978396e-01,  \/* 3FCC71C5 1D8E78AF *\/\n+Lp5 = 1.818357216161805012e-01,  \/* 3FC74664 96CB03DE *\/\n+Lp6 = 1.531383769920937332e-01,  \/* 3FC39A09 D078C69F *\/\n+Lp7 = 1.479819860511658591e-01;  \/* 3FC2F112 DF3E5244 *\/\n+\n+static double zero = 0.0;\n+\n+#ifdef __STDC__\n+        double log1p(double x)\n+#else\n+        double log1p(x)\n+        double x;\n+#endif\n+{\n+        double hfsq,f=0,c=0,s,z,R,u;\n+        int k,hx,hu=0,ax;\n+\n+        hx = __HI(x);           \/* high word of x *\/\n+        ax = hx&0x7fffffff;\n+\n+        k = 1;\n+        if (hx < 0x3FDA827A) {                  \/* x < 0.41422  *\/\n+            if(ax>=0x3ff00000) {                \/* x <= -1.0 *\/\n+                \/*\n+                 * Added redundant test against hx to work around VC++\n+                 * code generation problem.\n+                 *\/\n+                if(x==-1.0 && (hx==0xbff00000)) \/* log1p(-1)=-inf *\/\n+                  return -two54\/zero;\n+                else\n+                  return (x-x)\/(x-x);           \/* log1p(x<-1)=NaN *\/\n+            }\n+            if(ax<0x3e200000) {                 \/* |x| < 2**-29 *\/\n+                if(two54+x>zero                 \/* raise inexact *\/\n+                    &&ax<0x3c900000)            \/* |x| < 2**-54 *\/\n+                    return x;\n+                else\n+                    return x - x*x*0.5;\n+            }\n+            if(hx>0||hx<=((int)0xbfd2bec3)) {\n+                k=0;f=x;hu=1;}  \/* -0.2929<x<0.41422 *\/\n+        }\n+        if (hx >= 0x7ff00000) return x+x;\n+        if(k!=0) {\n+            if(hx<0x43400000) {\n+                u  = 1.0+x;\n+                hu = __HI(u);           \/* high word of u *\/\n+                k  = (hu>>20)-1023;\n+                c  = (k>0)? 1.0-(u-x):x-(u-1.0);\/* correction term *\/\n+                c \/= u;\n+            } else {\n+                u  = x;\n+                hu = __HI(u);           \/* high word of u *\/\n+                k  = (hu>>20)-1023;\n+                c  = 0;\n+            }\n+            hu &= 0x000fffff;\n+            if(hu<0x6a09e) {\n+                __HI(u) = hu|0x3ff00000;        \/* normalize u *\/\n+            } else {\n+                k += 1;\n+                __HI(u) = hu|0x3fe00000;        \/* normalize u\/2 *\/\n+                hu = (0x00100000-hu)>>2;\n+            }\n+            f = u-1.0;\n+        }\n+        hfsq=0.5*f*f;\n+        if(hu==0) {     \/* |f| < 2**-20 *\/\n+            if(f==zero) { if(k==0) return zero;\n+                          else {c += k*ln2_lo; return k*ln2_hi+c;}}\n+            R = hfsq*(1.0-0.66666666666666666*f);\n+            if(k==0) return f-R; else\n+                     return k*ln2_hi-((R-(k*ln2_lo+c))-f);\n+        }\n+        s = f\/(2.0+f);\n+        z = s*s;\n+        R = z*(Lp1+z*(Lp2+z*(Lp3+z*(Lp4+z*(Lp5+z*(Lp6+z*Lp7))))));\n+        if(k==0) return f-(hfsq-s*(hfsq+R)); else\n+                 return k*ln2_hi-((hfsq-(s*(hfsq+R)+(k*ln2_lo+c)))-f);\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_log1p.c","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * double logb(x)\n+ * IEEE 754 logb. Included to pass IEEE test suite. Not recommend.\n+ * Use ilogb instead.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double logb(double x)\n+#else\n+        double logb(x)\n+        double x;\n+#endif\n+{\n+        int lx,ix;\n+        ix = (__HI(x))&0x7fffffff;      \/* high |x| *\/\n+        lx = __LO(x);                   \/* low x *\/\n+        if((ix|lx)==0) return -1.0\/fabs(x);\n+        if(ix>=0x7ff00000) return x*x;\n+        if((ix>>=20)==0)                        \/* IEEE 754 logb *\/\n+                return -1022.0;\n+        else\n+                return (double) (ix-1023);\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_logb.c","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        int matherr(struct exception *x)\n+#else\n+        int matherr(x)\n+        struct exception *x;\n+#endif\n+{\n+        int n=0;\n+        if(x->arg1!=x->arg1) return 0;\n+        return n;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_matherr.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * modf(double x, double *iptr)\n+ * return fraction part of x, and return x's integral part in *iptr.\n+ * Method:\n+ *      Bit twiddling.\n+ *\n+ * Exception:\n+ *      No exception.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double one = 1.0;\n+#else\n+static double one = 1.0;\n+#endif\n+\n+#ifdef __STDC__\n+        double modf(double x, double *iptr)\n+#else\n+        double modf(x, iptr)\n+        double x,*iptr;\n+#endif\n+{\n+        int i0,i1,j0;\n+        unsigned i;\n+        i0 =  __HI(x);          \/* high x *\/\n+        i1 =  __LO(x);          \/* low  x *\/\n+        j0 = ((i0>>20)&0x7ff)-0x3ff;    \/* exponent of x *\/\n+        if(j0<20) {                     \/* integer part in high x *\/\n+            if(j0<0) {                  \/* |x|<1 *\/\n+                __HIp(iptr) = i0&0x80000000;\n+                __LOp(iptr) = 0;                \/* *iptr = +-0 *\/\n+                return x;\n+            } else {\n+                i = (0x000fffff)>>j0;\n+                if(((i0&i)|i1)==0) {            \/* x is integral *\/\n+                    *iptr = x;\n+                    __HI(x) &= 0x80000000;\n+                    __LO(x)  = 0;       \/* return +-0 *\/\n+                    return x;\n+                } else {\n+                    __HIp(iptr) = i0&(~i);\n+                    __LOp(iptr) = 0;\n+                    return x - *iptr;\n+                }\n+            }\n+        } else if (j0>51) {             \/* no fraction part *\/\n+            *iptr = x*one;\n+            __HI(x) &= 0x80000000;\n+            __LO(x)  = 0;       \/* return +-0 *\/\n+            return x;\n+        } else {                        \/* fraction part in low x *\/\n+            i = ((unsigned)(0xffffffff))>>(j0-20);\n+            if((i1&i)==0) {             \/* x is integral *\/\n+                *iptr = x;\n+                __HI(x) &= 0x80000000;\n+                __LO(x)  = 0;   \/* return +-0 *\/\n+                return x;\n+            } else {\n+                __HIp(iptr) = i0;\n+                __LOp(iptr) = i1&(~i);\n+                return x - *iptr;\n+            }\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_modf.c","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* IEEE functions\n+ *      nextafter(x,y)\n+ *      return the next machine floating-point number of x in the\n+ *      direction toward y.\n+ *   Special cases:\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double nextafter(double x, double y)\n+#else\n+        double nextafter(x,y)\n+        double x,y;\n+#endif\n+{\n+        int     hx,hy,ix,iy;\n+        unsigned lx,ly;\n+\n+        hx = __HI(x);           \/* high word of x *\/\n+        lx = __LO(x);           \/* low  word of x *\/\n+        hy = __HI(y);           \/* high word of y *\/\n+        ly = __LO(y);           \/* low  word of y *\/\n+        ix = hx&0x7fffffff;             \/* |x| *\/\n+        iy = hy&0x7fffffff;             \/* |y| *\/\n+\n+        if(((ix>=0x7ff00000)&&((ix-0x7ff00000)|lx)!=0) ||   \/* x is nan *\/\n+           ((iy>=0x7ff00000)&&((iy-0x7ff00000)|ly)!=0))     \/* y is nan *\/\n+           return x+y;\n+        if(x==y) return x;              \/* x=y, return x *\/\n+        if((ix|lx)==0) {                        \/* x == 0 *\/\n+            __HI(x) = hy&0x80000000;    \/* return +-minsubnormal *\/\n+            __LO(x) = 1;\n+            y = x*x;\n+            if(y==x) return y; else return x;   \/* raise underflow flag *\/\n+        }\n+        if(hx>=0) {                             \/* x > 0 *\/\n+            if(hx>hy||((hx==hy)&&(lx>ly))) {    \/* x > y, x -= ulp *\/\n+                if(lx==0) hx -= 1;\n+                lx -= 1;\n+            } else {                            \/* x < y, x += ulp *\/\n+                lx += 1;\n+                if(lx==0) hx += 1;\n+            }\n+        } else {                                \/* x < 0 *\/\n+            if(hy>=0||hx>hy||((hx==hy)&&(lx>ly))){\/* x < y, x -= ulp *\/\n+                if(lx==0) hx -= 1;\n+                lx -= 1;\n+            } else {                            \/* x > y, x += ulp *\/\n+                lx += 1;\n+                if(lx==0) hx += 1;\n+            }\n+        }\n+        hy = hx&0x7ff00000;\n+        if(hy>=0x7ff00000) return x+x;  \/* overflow  *\/\n+        if(hy<0x00100000) {             \/* underflow *\/\n+            y = x*x;\n+            if(y!=x) {          \/* raise underflow flag *\/\n+                __HI(y) = hx; __LO(y) = lx;\n+                return y;\n+            }\n+        }\n+        __HI(x) = hx; __LO(x) = lx;\n+        return x;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_nextafter.c","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * rint(x)\n+ * Return x rounded to integral value according to the prevailing\n+ * rounding mode.\n+ * Method:\n+ *      Using floating addition.\n+ * Exception:\n+ *      Inexact flag raised if x not equal to rint(x).\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+TWO52[2]={\n+  4.50359962737049600000e+15, \/* 0x43300000, 0x00000000 *\/\n+ -4.50359962737049600000e+15, \/* 0xC3300000, 0x00000000 *\/\n+};\n+\n+#ifdef __STDC__\n+        double rint(double x)\n+#else\n+        double rint(x)\n+        double x;\n+#endif\n+{\n+        int i0,j0,sx;\n+        unsigned i,i1;\n+        double w,t;\n+        i0 =  __HI(x);\n+        sx = (i0>>31)&1;\n+        i1 =  __LO(x);\n+        j0 = ((i0>>20)&0x7ff)-0x3ff;\n+        if(j0<20) {\n+            if(j0<0) {\n+                if(((i0&0x7fffffff)|i1)==0) return x;\n+                i1 |= (i0&0x0fffff);\n+                i0 &= 0xfffe0000;\n+                i0 |= ((i1|-i1)>>12)&0x80000;\n+                __HI(x)=i0;\n+                w = TWO52[sx]+x;\n+                t =  w-TWO52[sx];\n+                i0 = __HI(t);\n+                __HI(t) = (i0&0x7fffffff)|(sx<<31);\n+                return t;\n+            } else {\n+                i = (0x000fffff)>>j0;\n+                if(((i0&i)|i1)==0) return x; \/* x is integral *\/\n+                i>>=1;\n+                if(((i0&i)|i1)!=0) {\n+                    if(j0==19) i1 = 0x40000000; else\n+                    i0 = (i0&(~i))|((0x20000)>>j0);\n+                }\n+            }\n+        } else if (j0>51) {\n+            if(j0==0x400) return x+x;   \/* inf or NaN *\/\n+            else return x;              \/* x is integral *\/\n+        } else {\n+            i = ((unsigned)(0xffffffff))>>(j0-20);\n+            if((i1&i)==0) return x;     \/* x is integral *\/\n+            i>>=1;\n+            if((i1&i)!=0) i1 = (i1&(~i))|((0x40000000)>>(j0-20));\n+        }\n+        __HI(x) = i0;\n+        __LO(x) = i1;\n+        w = TWO52[sx]+x;\n+        return w-TWO52[sx];\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_rint.c","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * scalbn (double x, int n)\n+ * scalbn(x,n) returns x* 2**n  computed by  exponent\n+ * manipulation rather than by actually performing an\n+ * exponentiation or a multiplication.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+two54   =  1.80143985094819840000e+16, \/* 0x43500000, 0x00000000 *\/\n+twom54  =  5.55111512312578270212e-17, \/* 0x3C900000, 0x00000000 *\/\n+huge   = 1.0e+300,\n+tiny   = 1.0e-300;\n+\n+#ifdef __STDC__\n+        double scalbn (double x, int n)\n+#else\n+        double scalbn (x,n)\n+        double x; int n;\n+#endif\n+{\n+        int  k,hx,lx;\n+        hx = __HI(x);\n+        lx = __LO(x);\n+        k = (hx&0x7ff00000)>>20;                \/* extract exponent *\/\n+        if (k==0) {                             \/* 0 or subnormal x *\/\n+            if ((lx|(hx&0x7fffffff))==0) return x; \/* +-0 *\/\n+            x *= two54;\n+            hx = __HI(x);\n+            k = ((hx&0x7ff00000)>>20) - 54;\n+            if (n< -50000) return tiny*x;       \/*underflow*\/\n+            }\n+        if (k==0x7ff) return x+x;               \/* NaN or Inf *\/\n+        k = k+n;\n+        if (k >  0x7fe) return huge*copysign(huge,x); \/* overflow  *\/\n+        if (k > 0)                              \/* normal result *\/\n+            {__HI(x) = (hx&0x800fffff)|(k<<20); return x;}\n+        if (k <= -54) {\n+            if (n > 50000)      \/* in case integer overflow in n+k *\/\n+                return huge*copysign(huge,x);   \/*overflow*\/\n+            else return tiny*copysign(tiny,x);  \/*underflow*\/\n+        }\n+        k += 54;                                \/* subnormal result *\/\n+        __HI(x) = (hx&0x800fffff)|(k<<20);\n+        return x*twom54;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_scalbn.c","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+int signgam = 0;\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_signgam.c","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * significand(x) computes just\n+ *      scalb(x, (double) -ilogb(x)),\n+ * for exercising the fraction-part(F) IEEE 754-1985 test vector.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double significand(double x)\n+#else\n+        double significand(x)\n+        double x;\n+#endif\n+{\n+        return __ieee754_scalb(x,(double) -ilogb(x));\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_significand.c","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* sin(x)\n+ * Return sine function of x.\n+ *\n+ * kernel function:\n+ *      __kernel_sin            ... sine function on [-pi\/4,pi\/4]\n+ *      __kernel_cos            ... cose function on [-pi\/4,pi\/4]\n+ *      __ieee754_rem_pio2      ... argument reduction routine\n+ *\n+ * Method.\n+ *      Let S,C and T denote the sin, cos and tan respectively on\n+ *      [-PI\/4, +PI\/4]. Reduce the argument x to y1+y2 = x-k*pi\/2\n+ *      in [-pi\/4 , +pi\/4], and let n = k mod 4.\n+ *      We have\n+ *\n+ *          n        sin(x)      cos(x)        tan(x)\n+ *     ----------------------------------------------------------\n+ *          0          S           C             T\n+ *          1          C          -S            -1\/T\n+ *          2         -S          -C             T\n+ *          3         -C           S            -1\/T\n+ *     ----------------------------------------------------------\n+ *\n+ * Special cases:\n+ *      Let trig be any of sin, cos, or tan.\n+ *      trig(+-INF)  is NaN, with signals;\n+ *      trig(NaN)    is that NaN;\n+ *\n+ * Accuracy:\n+ *      TRIG(x) returns trig(x) nearly rounded\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double sin(double x)\n+#else\n+        double sin(x)\n+        double x;\n+#endif\n+{\n+        double y[2],z=0.0;\n+        int n, ix;\n+\n+    \/* High word of x. *\/\n+        ix = __HI(x);\n+\n+    \/* |x| ~< pi\/4 *\/\n+        ix &= 0x7fffffff;\n+        if(ix <= 0x3fe921fb) return __kernel_sin(x,z,0);\n+\n+    \/* sin(Inf or NaN) is NaN *\/\n+        else if (ix>=0x7ff00000) return x-x;\n+\n+    \/* argument reduction needed *\/\n+        else {\n+            n = __ieee754_rem_pio2(x,y);\n+            switch(n&3) {\n+                case 0: return  __kernel_sin(y[0],y[1],1);\n+                case 1: return  __kernel_cos(y[0],y[1]);\n+                case 2: return -__kernel_sin(y[0],y[1],1);\n+                default:\n+                        return -__kernel_cos(y[0],y[1]);\n+            }\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_sin.c","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* tan(x)\n+ * Return tangent function of x.\n+ *\n+ * kernel function:\n+ *      __kernel_tan            ... tangent function on [-pi\/4,pi\/4]\n+ *      __ieee754_rem_pio2      ... argument reduction routine\n+ *\n+ * Method.\n+ *      Let S,C and T denote the sin, cos and tan respectively on\n+ *      [-PI\/4, +PI\/4]. Reduce the argument x to y1+y2 = x-k*pi\/2\n+ *      in [-pi\/4 , +pi\/4], and let n = k mod 4.\n+ *      We have\n+ *\n+ *          n        sin(x)      cos(x)        tan(x)\n+ *     ----------------------------------------------------------\n+ *          0          S           C             T\n+ *          1          C          -S            -1\/T\n+ *          2         -S          -C             T\n+ *          3         -C           S            -1\/T\n+ *     ----------------------------------------------------------\n+ *\n+ * Special cases:\n+ *      Let trig be any of sin, cos, or tan.\n+ *      trig(+-INF)  is NaN, with signals;\n+ *      trig(NaN)    is that NaN;\n+ *\n+ * Accuracy:\n+ *      TRIG(x) returns trig(x) nearly rounded\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double tan(double x)\n+#else\n+        double tan(x)\n+        double x;\n+#endif\n+{\n+        double y[2],z=0.0;\n+        int n, ix;\n+\n+    \/* High word of x. *\/\n+        ix = __HI(x);\n+\n+    \/* |x| ~< pi\/4 *\/\n+        ix &= 0x7fffffff;\n+        if(ix <= 0x3fe921fb) return __kernel_tan(x,z,1);\n+\n+    \/* tan(Inf or NaN) is NaN *\/\n+        else if (ix>=0x7ff00000) return x-x;            \/* NaN *\/\n+\n+    \/* argument reduction needed *\/\n+        else {\n+            n = __ieee754_rem_pio2(x,y);\n+            return __kernel_tan(y[0],y[1],1-((n&1)<<1)); \/*   1 -- n even\n+                                                        -1 -- n odd *\/\n+        }\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_tan.c","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* Tanh(x)\n+ * Return the Hyperbolic Tangent of x\n+ *\n+ * Method :\n+ *                                     x    -x\n+ *                                    e  - e\n+ *      0. tanh(x) is defined to be -----------\n+ *                                     x    -x\n+ *                                    e  + e\n+ *      1. reduce x to non-negative by tanh(-x) = -tanh(x).\n+ *      2.  0      <= x <= 2**-55 : tanh(x) := x*(one+x)\n+ *                                              -t\n+ *          2**-55 <  x <=  1     : tanh(x) := -----; t = expm1(-2x)\n+ *                                             t + 2\n+ *                                                   2\n+ *          1      <= x <=  22.0  : tanh(x) := 1-  ----- ; t=expm1(2x)\n+ *                                                 t + 2\n+ *          22.0   <  x <= INF    : tanh(x) := 1.\n+ *\n+ * Special cases:\n+ *      tanh(NaN) is NaN;\n+ *      only tanh(0)=0 is exact for finite argument.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double one=1.0, two=2.0, tiny = 1.0e-300;\n+#else\n+static double one=1.0, two=2.0, tiny = 1.0e-300;\n+#endif\n+\n+#ifdef __STDC__\n+        double tanh(double x)\n+#else\n+        double tanh(x)\n+        double x;\n+#endif\n+{\n+        double t,z;\n+        int jx,ix;\n+\n+    \/* High word of |x|. *\/\n+        jx = __HI(x);\n+        ix = jx&0x7fffffff;\n+\n+    \/* x is INF or NaN *\/\n+        if(ix>=0x7ff00000) {\n+            if (jx>=0) return one\/x+one;    \/* tanh(+-inf)=+-1 *\/\n+            else       return one\/x-one;    \/* tanh(NaN) = NaN *\/\n+        }\n+\n+    \/* |x| < 22 *\/\n+        if (ix < 0x40360000) {          \/* |x|<22 *\/\n+            if (ix<0x3c800000)          \/* |x|<2**-55 *\/\n+                return x*(one+x);       \/* tanh(small) = small *\/\n+            if (ix>=0x3ff00000) {       \/* |x|>=1  *\/\n+                t = expm1(two*fabs(x));\n+                z = one - two\/(t+two);\n+            } else {\n+                t = expm1(-two*fabs(x));\n+                z= -t\/(t+two);\n+            }\n+    \/* |x| > 22, return +-1 *\/\n+        } else {\n+            z = one - tiny;             \/* raised inexact flag *\/\n+        }\n+        return (jx>=0)? z: -z;\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/s_tanh.c","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrap_acos(x)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+\n+#ifdef __STDC__\n+        double acos(double x)           \/* wrapper acos *\/\n+#else\n+        double acos(x)                  \/* wrapper acos *\/\n+        double x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_acos(x);\n+#else\n+        double z;\n+        z = __ieee754_acos(x);\n+        if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;\n+        if(fabs(x)>1.0) {\n+                return __kernel_standard(x,x,1); \/* acos(|x|>1) *\/\n+        } else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_acos.c","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper asin(x)\n+ *\/\n+\n+\n+#include \"fdlibm.h\"\n+\n+\n+#ifdef __STDC__\n+        double asin(double x)           \/* wrapper asin *\/\n+#else\n+        double asin(x)                  \/* wrapper asin *\/\n+        double x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_asin(x);\n+#else\n+        double z;\n+        z = __ieee754_asin(x);\n+        if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;\n+        if(fabs(x)>1.0) {\n+                return __kernel_standard(x,x,2); \/* asin(|x|>1) *\/\n+        } else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_asin.c","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper atan2(y,x)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+\n+#ifdef __STDC__\n+        double atan2(double y, double x)        \/* wrapper atan2 *\/\n+#else\n+        double atan2(y,x)                       \/* wrapper atan2 *\/\n+        double y,x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_atan2(y,x);\n+#else\n+        double z;\n+        z = __ieee754_atan2(y,x);\n+        if(_LIB_VERSION == _IEEE_||isnan(x)||isnan(y)) return z;\n+        if(x==0.0&&y==0.0) {\n+                return __kernel_standard(y,x,3); \/* atan2(+-0,+-0) *\/\n+        } else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_atan2.c","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * wrapper atanh(x)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+\n+#ifdef __STDC__\n+        double atanh(double x)          \/* wrapper atanh *\/\n+#else\n+        double atanh(x)                 \/* wrapper atanh *\/\n+        double x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_atanh(x);\n+#else\n+        double z,y;\n+        z = __ieee754_atanh(x);\n+        if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;\n+        y = fabs(x);\n+        if(y>=1.0) {\n+            if(y>1.0)\n+                return __kernel_standard(x,x,30); \/* atanh(|x|>1) *\/\n+            else\n+                return __kernel_standard(x,x,31); \/* atanh(|x|==1) *\/\n+        } else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_atanh.c","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper cosh(x)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double cosh(double x)           \/* wrapper cosh *\/\n+#else\n+        double cosh(x)                  \/* wrapper cosh *\/\n+        double x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_cosh(x);\n+#else\n+        double z;\n+        z = __ieee754_cosh(x);\n+        if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;\n+        if(fabs(x)>7.10475860073943863426e+02) {\n+                return __kernel_standard(x,x,5); \/* cosh overflow *\/\n+        } else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_cosh.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper exp(x)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+static const double\n+#else\n+static double\n+#endif\n+o_threshold=  7.09782712893383973096e+02,  \/* 0x40862E42, 0xFEFA39EF *\/\n+u_threshold= -7.45133219101941108420e+02;  \/* 0xc0874910, 0xD52D3051 *\/\n+\n+#ifdef __STDC__\n+        double exp(double x)            \/* wrapper exp *\/\n+#else\n+        double exp(x)                   \/* wrapper exp *\/\n+        double x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_exp(x);\n+#else\n+        double z;\n+        z = __ieee754_exp(x);\n+        if(_LIB_VERSION == _IEEE_) return z;\n+        if(finite(x)) {\n+            if(x>o_threshold)\n+                return __kernel_standard(x,x,6); \/* exp overflow *\/\n+            else if(x<u_threshold)\n+                return __kernel_standard(x,x,7); \/* exp underflow *\/\n+        }\n+        return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_exp.c","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper fmod(x,y)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+\n+#ifdef __STDC__\n+        double fmod(double x, double y) \/* wrapper fmod *\/\n+#else\n+        double fmod(x,y)                \/* wrapper fmod *\/\n+        double x,y;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_fmod(x,y);\n+#else\n+        double z;\n+        z = __ieee754_fmod(x,y);\n+        if(_LIB_VERSION == _IEEE_ ||isnan(y)||isnan(x)) return z;\n+        if(y==0.0) {\n+                return __kernel_standard(x,y,27); \/* fmod(x,0) *\/\n+        } else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_fmod.c","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper log(x)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+\n+#ifdef __STDC__\n+        double log(double x)            \/* wrapper log *\/\n+#else\n+        double log(x)                   \/* wrapper log *\/\n+        double x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_log(x);\n+#else\n+        double z;\n+        z = __ieee754_log(x);\n+        if(_LIB_VERSION == _IEEE_ || isnan(x) || x > 0.0) return z;\n+        if(x==0.0)\n+            return __kernel_standard(x,x,16); \/* log(0) *\/\n+        else\n+            return __kernel_standard(x,x,17); \/* log(x<0) *\/\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_log.c","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper log10(X)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+\n+#ifdef __STDC__\n+        double log10(double x)          \/* wrapper log10 *\/\n+#else\n+        double log10(x)                 \/* wrapper log10 *\/\n+        double x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_log10(x);\n+#else\n+        double z;\n+        z = __ieee754_log10(x);\n+        if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;\n+        if(x<=0.0) {\n+            if(x==0.0)\n+                return __kernel_standard(x,x,18); \/* log10(0) *\/\n+            else\n+                return __kernel_standard(x,x,19); \/* log10(x<0) *\/\n+        } else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_log10.c","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper remainder(x,p)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double remainder(double x, double y)    \/* wrapper remainder *\/\n+#else\n+        double remainder(x,y)                   \/* wrapper remainder *\/\n+        double x,y;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_remainder(x,y);\n+#else\n+        double z;\n+        z = __ieee754_remainder(x,y);\n+        if(_LIB_VERSION == _IEEE_ || isnan(y)) return z;\n+        if(y==0.0)\n+            return __kernel_standard(x,y,28); \/* remainder(x,0) *\/\n+        else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_remainder.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper scalb(double x, double fn) is provide for\n+ * passing various standard test suite. One\n+ * should use scalbn() instead.\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#include <errno.h>\n+\n+#ifdef __STDC__\n+#ifdef _SCALB_INT\n+        double scalb(double x, int fn)          \/* wrapper scalb *\/\n+#else\n+        double scalb(double x, double fn)       \/* wrapper scalb *\/\n+#endif\n+#else\n+        double scalb(x,fn)                      \/* wrapper scalb *\/\n+#ifdef _SCALB_INT\n+        double x; int fn;\n+#else\n+        double x,fn;\n+#endif\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_scalb(x,fn);\n+#else\n+        double z;\n+        z = __ieee754_scalb(x,fn);\n+        if(_LIB_VERSION == _IEEE_) return z;\n+        if(!(finite(z)||isnan(z))&&finite(x)) {\n+            return __kernel_standard(x,(double)fn,32); \/* scalb overflow *\/\n+        }\n+        if(z==0.0&&z!=x) {\n+            return __kernel_standard(x,(double)fn,33); \/* scalb underflow *\/\n+        }\n+#ifndef _SCALB_INT\n+        if(!finite(fn)) errno = ERANGE;\n+#endif\n+        return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_scalb.c","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper sinh(x)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double sinh(double x)           \/* wrapper sinh *\/\n+#else\n+        double sinh(x)                  \/* wrapper sinh *\/\n+        double x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_sinh(x);\n+#else\n+        double z;\n+        z = __ieee754_sinh(x);\n+        if(_LIB_VERSION == _IEEE_) return z;\n+        if(!finite(z)&&finite(x)) {\n+            return __kernel_standard(x,x,25); \/* sinh overflow *\/\n+        } else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_sinh.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\n+\/*\n+ * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * wrapper sqrt(x)\n+ *\/\n+\n+#include \"fdlibm.h\"\n+\n+#ifdef __STDC__\n+        double sqrt(double x)           \/* wrapper sqrt *\/\n+#else\n+        double sqrt(x)                  \/* wrapper sqrt *\/\n+        double x;\n+#endif\n+{\n+#ifdef _IEEE_LIBM\n+        return __ieee754_sqrt(x);\n+#else\n+        double z;\n+        z = __ieee754_sqrt(x);\n+        if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;\n+        if(x<0.0) {\n+            return __kernel_standard(x,x,26); \/* sqrt(negative) *\/\n+        } else\n+            return z;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libfdlibm\/w_sqrt.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 1994, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"fdlibm.h\"\n+\n+#include \"java_lang_StrictMath.h\"\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_cos(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jcos((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_sin(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jsin((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_tan(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jtan((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_asin(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jasin((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_acos(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jacos((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_atan(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jatan((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_log(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jlog((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_log10(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jlog10((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_sqrt(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jsqrt((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_atan2(JNIEnv *env, jclass unused, jdouble d1, jdouble d2)\n+{\n+    return (jdouble) jatan2((double)d1, (double)d2);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_IEEEremainder(JNIEnv *env, jclass unused,\n+                                  jdouble dividend,\n+                                  jdouble divisor)\n+{\n+    return (jdouble) jremainder(dividend, divisor);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_cosh(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jcosh((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_sinh(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jsinh((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_tanh(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jtanh((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_log1p(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jlog1p((double)d);\n+}\n+\n+JNIEXPORT jdouble JNICALL\n+Java_java_lang_StrictMath_expm1(JNIEnv *env, jclass unused, jdouble d)\n+{\n+    return (jdouble) jexpm1((double)d);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/StrictMath.c","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"}]}