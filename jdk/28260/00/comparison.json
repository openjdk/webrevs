{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -53,1 +54,1 @@\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -62,0 +63,1 @@\n+    static final byte MAGIC_VALUE = 42;\n@@ -121,1 +123,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -123,1 +124,1 @@\n-        unsafe.setMemory(unsafe_addr, ALLOC_SIZE, (byte)42);\n+        unsafe.setMemory(unsafe_addr, ALLOC_SIZE, MAGIC_VALUE);\n@@ -127,1 +128,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -129,1 +129,1 @@\n-        segment.fill((byte)42);\n+        segment.fill(MAGIC_VALUE);\n@@ -133,1 +133,22 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_fill_int_long_loop() {\n+        for (int i = 0 ; i < segment.byteSize() ; i++) {\n+            segment.set(ValueLayout.JAVA_BYTE, i, MAGIC_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_fill_int_int_loop() {\n+        for (int i = 0 ; i < (int)segment.byteSize() ; i++) {\n+            segment.set(ValueLayout.JAVA_BYTE, i, MAGIC_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_fill_long_long_loop() {\n+        for (long i = 0 ; i < segment.byteSize() ; i++) {\n+            segment.set(ValueLayout.JAVA_BYTE, i, MAGIC_VALUE);\n+        }\n+    }\n+\n+\n+    @Benchmark\n@@ -139,1 +160,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -145,1 +165,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -151,1 +170,24 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_int_long_loop() {\n+        long limit = bytesSegment.byteSize() \/ JAVA_INT_UNALIGNED.byteSize();\n+        for (int i = 0 ; i < limit ; i++) {\n+            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_copy_static_int_int_loop() {\n+        long limit = bytesSegment.byteSize() \/ JAVA_INT_UNALIGNED.byteSize();\n+        for (int i = 0 ; i < (int)limit ; i++) {\n+            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_copy_static_long_long_loop() {\n+        long limit = bytesSegment.byteSize() \/ JAVA_INT_UNALIGNED.byteSize();\n+        for (long i = 0 ; i < limit ; i++) {\n+            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[(int)i]);\n+        }\n+    }\n+\n+    @Benchmark\n@@ -158,1 +200,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -164,1 +205,21 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_small_int_long_loop() {\n+        for (int i = 0 ; i < 10L ; i++) {\n+            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_copy_static_small_int_int_loop() {\n+        for (int i = 0 ; i < 10 ; i++) {\n+            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_copy_static_small_long_long_loop() {\n+        for (long i = 0 ; i < 10 ; i++) {\n+            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[(int)i]);\n+        }\n+    }\n+\n+    @Benchmark\n@@ -170,1 +231,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -176,1 +236,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -183,1 +242,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -189,1 +247,30 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long mismatch_large_segment_int_long_loop() {\n+        for (int i = 0 ; i < mismatchSegmentLarge1.byteSize() ; i++) {\n+            if (mismatchSegmentLarge1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentLarge2.get(ValueLayout.JAVA_BYTE, i)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n+    public long mismatch_large_segment_int_int_loop() {\n+        for (int i = 0 ; i < (int)mismatchSegmentLarge1.byteSize() ; i++) {\n+            if (mismatchSegmentLarge1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentLarge2.get(ValueLayout.JAVA_BYTE, i)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n+    public long mismatch_large_segment_long_long_loop() {\n+        for (long i = 0 ; i < mismatchSegmentLarge1.byteSize() ; i++) {\n+            if (mismatchSegmentLarge1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentLarge2.get(ValueLayout.JAVA_BYTE, i)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n@@ -195,1 +282,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -201,1 +287,30 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long mismatch_small_segment_int_long_loop() {\n+        for (int i = 0 ; i < mismatchSegmentSmall1.byteSize() ; i++) {\n+            if (mismatchSegmentSmall1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentSmall2.get(ValueLayout.JAVA_BYTE, i)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n+    public long mismatch_small_segment_int_int_loop() {\n+        for (int i = 0 ; i < (int)mismatchSegmentSmall1.byteSize() ; i++) {\n+            if (mismatchSegmentSmall1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentSmall2.get(ValueLayout.JAVA_BYTE, i)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n+    public long mismatch_small_segment_long_long_loop() {\n+        for (long i = 0 ; i < mismatchSegmentSmall1.byteSize() ; i++) {\n+            if (mismatchSegmentSmall1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentSmall2.get(ValueLayout.JAVA_BYTE, i)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n@@ -207,1 +322,0 @@\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":132,"deletions":18,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -52,1 +53,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"64\", \"512\",\n@@ -54,1 +55,1 @@\n-    public int ELEM_SIZE;\n+    public int size;\n@@ -58,18 +59,0 @@\n-    MemorySegment heapSrcSegment;\n-    MemorySegment heapDstSegment;\n-    MemorySegment nativeSrcSegment;\n-    MemorySegment nativeDstSegment;\n-    ByteBuffer srcBuffer;\n-    ByteBuffer dstBuffer;\n-\n-    @Setup\n-    public void setup() {\n-        srcArray = new byte[ELEM_SIZE];\n-        dstArray = new byte[ELEM_SIZE];\n-        heapSrcSegment = MemorySegment.ofArray(srcArray);\n-        heapDstSegment = MemorySegment.ofArray(dstArray);\n-        nativeSrcSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        nativeDstSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        srcBuffer = ByteBuffer.wrap(srcArray);\n-        dstBuffer = ByteBuffer.wrap(dstArray);\n-    }\n@@ -77,4 +60,1 @@\n-    @Benchmark\n-    public void arrayCopy() {\n-        System.arraycopy(srcArray, 0, dstArray, 0, ELEM_SIZE);\n-    }\n+    public static class Array extends SegmentBulkCopy {\n@@ -82,4 +62,2 @@\n-    @Benchmark\n-    public void bufferCopy() {\n-        dstBuffer.put(srcBuffer);\n-    }\n+        ByteBuffer srcBuffer;\n+        ByteBuffer dstBuffer;\n@@ -87,5 +65,7 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n-    @Benchmark\n-    public void heapSegmentCopyJava() {\n-        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n-    }\n+        @Setup\n+        public void setup() {\n+            srcArray = new byte[size];\n+            dstArray = new byte[size];\n+            srcBuffer = ByteBuffer.wrap(srcArray);\n+            dstBuffer = ByteBuffer.wrap(dstArray);\n+        }\n@@ -93,5 +73,9 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n-    @Benchmark\n-    public void heapSegmentCopyUnsafe() {\n-        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n-    }\n+        @Benchmark\n+        public void arrayCopy() {\n+            System.arraycopy(srcArray, 0, dstArray, 0, size);\n+        }\n+\n+        @Benchmark\n+        public void bufferCopy() {\n+            dstBuffer.put(srcBuffer);\n+        }\n@@ -99,4 +83,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n-    @Benchmark\n-    public void nativeSegmentCopyJava() {\n-        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n@@ -105,4 +85,77 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n-    @Benchmark\n-    public void nativeSegmentCopyUnsafe() {\n-        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n+    public static class Segment extends SegmentBulkCopy {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n+\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        MemorySegment srcSegment;\n+        MemorySegment dstSegment;\n+\n+        @Setup\n+        public void setup() {\n+            srcArray = new byte[size + 1];\n+            dstArray = new byte[size + 1];\n+\n+            switch (Segment.SegmentType.valueOf(segmentType)) {\n+                case HEAP -> {\n+                    srcSegment = MemorySegment.ofArray(srcArray);\n+                    dstSegment = MemorySegment.ofArray(dstArray);\n+                }\n+                case NATIVE -> {\n+                    srcSegment = Arena.ofAuto().allocate(srcArray.length, Long.BYTES);\n+                    dstSegment = Arena.ofAuto().allocate(dstArray.length, Long.BYTES);\n+                }\n+            }\n+            switch (Segment.Alignment.valueOf(alignment)) {\n+                case ALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(0, size);\n+                    dstSegment = dstSegment.asSlice(0, size);\n+                }\n+                case UNALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(1, size);\n+                    dstSegment = dstSegment.asSlice(1, size);\n+                }\n+            }\n+        }\n+\n+        @Benchmark\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n+        public void copy() {\n+            MemorySegment.copy(srcSegment, 0, dstSegment, 0, size);\n+        }\n+\n+        @Benchmark\n+        public void copyLoopIntInt() {\n+            for (int i = 0; i < (int) srcSegment.byteSize(); i++) {\n+                final byte v = srcSegment.get(ValueLayout.JAVA_BYTE, i);\n+                dstSegment.set(ValueLayout.JAVA_BYTE, i, v);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void copyLoopIntLong() {\n+            for (int i = 0; i < srcSegment.byteSize(); i++) {\n+                final byte v = srcSegment.get(ValueLayout.JAVA_BYTE, i);\n+                dstSegment.set(ValueLayout.JAVA_BYTE, i, v);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void copyLoopLongLong() {\n+            for (long i = 0; i < srcSegment.byteSize(); i++) {\n+                final byte v = srcSegment.get(ValueLayout.JAVA_BYTE, i);\n+                dstSegment.set(ValueLayout.JAVA_BYTE, i, v);\n+            }\n+        }\n+\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n+        @Benchmark\n+        public void copyUnsafe() {\n+            MemorySegment.copy(srcSegment, 0, dstSegment, 0, size);\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkCopy.java","additions":100,"deletions":47,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,3 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+    private static final byte ZERO = 0;\n+\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"64\", \"512\",\n@@ -56,1 +58,1 @@\n-    public int ELEM_SIZE;\n+    public int size;\n@@ -59,13 +61,0 @@\n-    MemorySegment heapSegment;\n-    MemorySegment nativeSegment;\n-    MemorySegment unalignedSegment;\n-    ByteBuffer buffer;\n-\n-    @Setup\n-    public void setup() {\n-        array = new byte[ELEM_SIZE];\n-        heapSegment = MemorySegment.ofArray(array);\n-        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n-        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n-        buffer = ByteBuffer.wrap(array);\n-    }\n@@ -73,4 +62,1 @@\n-    @Benchmark\n-    public void arraysFill() {\n-        Arrays.fill(array, (byte) 0);\n-    }\n+    public static class Array extends SegmentBulkFill {\n@@ -78,6 +64,1 @@\n-    @Benchmark\n-    public void arraysFillLoop() {\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = 0;\n-        }\n-    }\n+        ByteBuffer buffer;\n@@ -85,4 +66,4 @@\n-    @Benchmark\n-    public void bufferFillLoop() {\n-        for (int i = 0; i < array.length; i++) {\n-            buffer.put(i, (byte)0);\n+        @Setup\n+        public void setup() {\n+            array = new byte[size];\n+            buffer = ByteBuffer.wrap(array);\n@@ -90,1 +71,0 @@\n-    }\n@@ -92,5 +72,4 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n-    @Benchmark\n-    public void heapSegmentFillJava() {\n-        heapSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        public void arraysFill() {\n+            Arrays.fill(array, ZERO);\n+        }\n@@ -98,5 +77,6 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n-    @Benchmark\n-    public void heapSegmentFillUnsafe() {\n-        heapSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        public void arraysFillLoop() {\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = ZERO;\n+            }\n+        }\n@@ -104,4 +84,5 @@\n-    @Benchmark\n-    public void heapSegmentFillLoop() {\n-        for (long i = 0; i < heapSegment.byteSize(); i++) {\n-            heapSegment.set(ValueLayout.JAVA_BYTE, i, (byte) 0);\n+        @Benchmark\n+        public void bufferFillLoop() {\n+            for (int i = 0; i < array.length; i++) {\n+                buffer.put(i, ZERO);\n+            }\n@@ -109,1 +90,0 @@\n-    }\n@@ -111,4 +91,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n-    @Benchmark\n-    public void nativeSegmentFillJava() {\n-        nativeSegment.fill((byte) 0);\n@@ -117,5 +93,4 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n-    @Benchmark\n-    public void nativeSegmentFillUnsafe() {\n-        nativeSegment.fill((byte) 0);\n-    }\n+    public static class Segment extends SegmentBulkFill {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n@@ -123,4 +98,19 @@\n-    @Benchmark\n-    public void nativeSegmentFillLoop() {\n-        for (long i = 0; i < nativeSegment.byteSize(); i++) {\n-            nativeSegment.set(ValueLayout.JAVA_BYTE, i, (byte) 0);\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        MemorySegment segment;\n+\n+        @Setup\n+        public void setup() {\n+            array = new byte[size + 1]; \/\/ Allow for adjustment\n+            switch (SegmentType.valueOf(segmentType)) {\n+                case HEAP   -> segment = MemorySegment.ofArray(array);\n+                case NATIVE -> segment = Arena.ofAuto().allocate(array.length, Long.BYTES);\n+            }\n+            switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED   -> segment = segment.asSlice(0, size);\n+                case UNALIGNED -> segment = segment.asSlice(1, size);\n+            }\n@@ -128,1 +118,0 @@\n-    }\n@@ -130,5 +119,5 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n-    @Benchmark\n-    public void unalignedSegmentFillJava() {\n-        unalignedSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+        public void fill() {\n+            segment.fill(ZERO);\n+        }\n@@ -136,5 +125,13 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n-    @Benchmark\n-    public void unalignedSegmentFillUnsafe() {\n-        unalignedSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        public void fillLoopIntInt() {\n+            for (int i = 0; i < (int)segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, ZERO);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void fillLoopIntLong() {\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, ZERO);\n+            }\n+        }\n@@ -142,4 +139,5 @@\n-    @Benchmark\n-    public void unalignedSegmentFillLoop() {\n-        for (long i = 0; i < unalignedSegment.byteSize(); i++) {\n-            unalignedSegment.set(ValueLayout.JAVA_BYTE, i, (byte) 0);\n+        @Benchmark\n+        public void fillLoopLongLong() {\n+            for (long i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, ZERO);\n+            }\n@@ -147,0 +145,7 @@\n+\n+        @Benchmark\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n+        public void fillUnsafe() {\n+            segment.fill(ZERO);\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkFill.java","additions":79,"deletions":74,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,3 @@\n-    @Param({\"8\", \"64\"})\n-    public int ELEM_SIZE;\n+    @Param({\"2\", \/*\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"64\", \"512\",\n+            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"*\/})\n+    public int size;\n@@ -60,3 +61,1 @@\n-    byte[] array;\n-    AbstractMemorySegmentImpl heapSegment;\n-    AbstractMemorySegmentImpl nativeSegment;\n+    byte[] randomArray;\n@@ -64,4 +63,2 @@\n-    @Setup\n-    public void setup() {\n-        \/\/ Always use the same alignment regardless of size\n-        nativeSegment = (AbstractMemorySegmentImpl) Arena.ofAuto().allocate(ELEM_SIZE, 16);\n+    void baseSetup() {\n+        randomArray = new byte[size + 1];\n@@ -69,5 +66,1 @@\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            nativeSegment.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n-        }\n-        array = nativeSegment.toArray(JAVA_BYTE);\n-        heapSegment = (AbstractMemorySegmentImpl) MemorySegment.ofArray(array);\n+        rnd.nextBytes(randomArray);\n@@ -76,4 +69,1 @@\n-    @Benchmark\n-    public int array() {\n-        return Arrays.hashCode(array);\n-    }\n+    public static class Array extends SegmentBulkHash {\n@@ -81,4 +71,12 @@\n-    @Benchmark\n-    public int heapSegment() {\n-        return SegmentBulkOperations.contentHash(heapSegment, 0, ELEM_SIZE);\n-    }\n+        byte[] array;\n+\n+        @Setup\n+        public void setup() {\n+            baseSetup();\n+            array = Arrays.copyOf(randomArray, size);\n+        }\n+\n+        @Benchmark\n+        public int array() {\n+            return Arrays.hashCode(array);\n+        }\n@@ -86,3 +84,0 @@\n-    @Benchmark\n-    public int nativeSegment() {\n-        return SegmentBulkOperations.contentHash(nativeSegment, 0, ELEM_SIZE);\n@@ -91,5 +86,42 @@\n-    @Benchmark\n-    public int nativeSegmentJava() {\n-        int result = 1;\n-        for (long i = 0; i < ELEM_SIZE; i++) {\n-            result = 31 * result + nativeSegment.get(JAVA_BYTE, i);\n+    public static class Segment extends SegmentBulkHash {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n+\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        AbstractMemorySegmentImpl segment;\n+\n+        @Setup\n+        public void setup() {\n+            baseSetup();\n+            MemorySegment s = null;\n+\n+            switch (SegmentBulkFill.Segment.SegmentType.valueOf(segmentType)) {\n+                case HEAP   -> s = MemorySegment.ofArray(randomArray);\n+                case NATIVE -> s = Arena.ofAuto().allocate(randomArray.length, Long.BYTES);\n+            }\n+            switch (SegmentBulkFill.Segment.Alignment.valueOf(alignment)) {\n+                case ALIGNED   -> s = s.asSlice(0, size);\n+                case UNALIGNED -> s = s.asSlice(1, size);\n+            }\n+\n+            \/\/ Always use the same alignment regardless of size\n+            segment = (AbstractMemorySegmentImpl) s;\n+        }\n+\n+        @Benchmark\n+        public int hash() {\n+            return SegmentBulkOperations.contentHash(segment, 0, size);\n+        }\n+\n+        @Benchmark\n+        public void hashLoopIntInt() {\n+            int result = 1;\n+            for (int i = 0; i < (int)segment.byteSize(); i++) {\n+                result = 31 * result + segment.get(JAVA_BYTE, i);\n+            }\n@@ -97,1 +129,17 @@\n-        return result;\n+\n+        @Benchmark\n+        public void hashLoopIntLong() {\n+            int result = 1;\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                result = 31 * result + segment.get(JAVA_BYTE, i);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void hashLoopLongLong() {\n+            int result = 1;\n+            for (long i = 0; i < segment.byteSize(); i++) {\n+                result = 31 * result + segment.get(JAVA_BYTE, i);\n+            }\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkHash.java","additions":80,"deletions":32,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"64\", \"512\",\n@@ -57,14 +57,6 @@\n-    public int ELEM_SIZE;\n-\n-    MemorySegment srcNative;\n-    MemorySegment dstNative;\n-    byte[] srcArray;\n-    byte[] dstArray;\n-    MemorySegment srcHeap;\n-    MemorySegment dstHeap;\n-\n-    @Setup\n-    public void setup() {\n-        \/\/ Always use the same alignment regardless of size\n-        srcNative = Arena.ofAuto().allocate(ELEM_SIZE,16);\n-        dstNative = Arena.ofAuto().allocate(ELEM_SIZE, 16);\n+    public int size;\n+\n+    byte[] baseArray;\n+\n+    void baseSetup() {\n+        baseArray = new byte[size + 1];\n@@ -72,8 +64,1 @@\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            srcNative.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n-        }\n-        dstNative.copyFrom(srcNative);\n-        srcArray = srcNative.toArray(JAVA_BYTE);\n-        dstArray = dstNative.toArray(JAVA_BYTE);\n-        srcHeap = MemorySegment.ofArray(srcArray);\n-        dstHeap = MemorySegment.ofArray(dstArray);\n+        rnd.nextBytes(baseArray);\n@@ -82,5 +67,1 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n-    @Benchmark\n-    public long nativeSegmentJava() {\n-        return srcNative.mismatch(dstNative);\n-    }\n+    public static class Array extends SegmentBulkMismatch {\n@@ -88,5 +69,2 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n-    @Benchmark\n-    public long heapSegmentJava() {\n-        return srcHeap.mismatch(dstHeap);\n-    }\n+        byte[] srcArray;\n+        byte[] dstArray;\n@@ -94,5 +72,11 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n-    @Benchmark\n-    public long nativeSegmentUnsafe() {\n-        return srcNative.mismatch(dstNative);\n-    }\n+        @Setup\n+        public void setup() {\n+            baseSetup();\n+            srcArray = Arrays.copyOf(baseArray, size);\n+            dstArray = Arrays.copyOf(baseArray, size);\n+        }\n+\n+        @Benchmark\n+        public long array() {\n+            return Arrays.mismatch(srcArray, dstArray);\n+        }\n@@ -100,4 +84,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n-    @Benchmark\n-    public long heapSegmentUnsafe() {\n-        return srcHeap.mismatch(dstHeap);\n@@ -106,3 +86,51 @@\n-    @Benchmark\n-    public long array() {\n-        return Arrays.mismatch(srcArray, dstArray);\n+    public static class Segment extends SegmentBulkMismatch {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n+\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        MemorySegment srcSegment;\n+        MemorySegment dstSegment;\n+\n+        @Setup\n+        public void setup() {\n+            baseSetup();\n+\n+            switch (SegmentBulkCopy.Segment.SegmentType.valueOf(segmentType)) {\n+                case HEAP -> {\n+                    srcSegment = MemorySegment.ofArray(baseArray);\n+                    dstSegment = MemorySegment.ofArray(baseArray);\n+                }\n+                case NATIVE -> {\n+                    srcSegment = Arena.ofAuto().allocate(baseArray.length, Long.BYTES);\n+                    dstSegment = Arena.ofAuto().allocate(baseArray.length, Long.BYTES);\n+                }\n+            }\n+            switch (SegmentBulkCopy.Segment.Alignment.valueOf(alignment)) {\n+                case ALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(0, size);\n+                    dstSegment = dstSegment.asSlice(0, size);\n+                }\n+                case UNALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(1, size);\n+                    dstSegment = dstSegment.asSlice(1, size);\n+                }\n+            }\n+        }\n+\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n+        @Benchmark\n+        public long mismatch() {\n+            return srcSegment.mismatch(dstSegment);\n+        }\n+\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n+        @Benchmark\n+        public long mismatchUnsafe() {\n+            return srcSegment.mismatch(dstSegment);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkMismatch.java","additions":74,"deletions":46,"binary":false,"changes":120,"status":"modified"}]}