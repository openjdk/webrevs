{"files":[{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-import jdk.internal.misc.Unsafe;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@Fork(value = 3, jvmArgs = { \"--add-opens=java.base\/jdk.internal.misc=ALL-UNNAMED\" })\n-public class BulkOps {\n-\n-    static final Unsafe unsafe = Utils.unsafe;\n-\n-    static final int ELEM_SIZE = 1_000_000;\n-    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n-    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n-\n-    final Arena arena = Arena.ofShared();\n-\n-    final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n-    final MemorySegment segment = arena.allocate(ALLOC_SIZE, 1);\n-\n-    final IntBuffer buffer = IntBuffer.allocate(ELEM_SIZE);\n-\n-    final int[] ints = new int[ELEM_SIZE];\n-    final MemorySegment bytesSegment = MemorySegment.ofArray(ints);\n-    final long UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n-\n-    \/\/ large(ish) segments\/buffers with same content, 0, for mismatch, non-multiple-of-8 sized\n-    static final int SIZE_WITH_TAIL = (1024 * 1024) + 7;\n-    final MemorySegment mismatchSegmentLarge1;\n-\n-    {\n-        mismatchSegmentLarge1 = arena.allocate(SIZE_WITH_TAIL, 1);\n-    }\n-\n-    final MemorySegment mismatchSegmentLarge2 = arena.allocate(SIZE_WITH_TAIL, 1);\n-    final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-    final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-\n-    \/\/ mismatch at first byte\n-    final MemorySegment mismatchSegmentSmall1 = arena.allocate(7, 1);\n-    final MemorySegment mismatchSegmentSmall2 = arena.allocate(7, 1);\n-    final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n-    final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n-\n-    @Setup\n-    public void setup() {\n-        mismatchSegmentSmall1.fill((byte) 0xFF);\n-        mismatchBufferSmall1.put((byte) 0xFF).clear();\n-        \/\/ verify expected mismatch indices\n-        long si = mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-        if (si != -1)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-        int bi = mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-        if (bi != -1)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-        si = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-        if (si != 0)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-        bi = mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-        if (bi != 0)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-\n-        for (int i = 0; i < ints.length ; i++) {\n-            ints[i] = i;\n-        }\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        arena.close();\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void unsafe_fill() {\n-        unsafe.setMemory(unsafe_addr, ALLOC_SIZE, (byte)42);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_fill() {\n-        segment.fill((byte)42);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void unsafe_copy() {\n-        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, ALLOC_SIZE);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy() {\n-        segment.copyFrom(bytesSegment);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, ints.length);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static_small() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static_small_dontinline() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void unsafe_copy_small() {\n-        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void buffer_copy_small() {\n-        buffer.put(0, ints, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void buffer_copy() {\n-        buffer.put(0, ints, 0, ints.length);\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static_dontinline() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, ints.length);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_large_segment() {\n-        return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_large_bytebuffer() {\n-        return mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_small_segment() {\n-        return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_small_bytebuffer() {\n-        return mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -42,0 +43,1 @@\n+import java.util.Random;\n@@ -44,0 +46,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+\n@@ -52,24 +56,2 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n-    public int ELEM_SIZE;\n-\n-    byte[] srcArray;\n-    byte[] dstArray;\n-    MemorySegment heapSrcSegment;\n-    MemorySegment heapDstSegment;\n-    MemorySegment nativeSrcSegment;\n-    MemorySegment nativeDstSegment;\n-    ByteBuffer srcBuffer;\n-    ByteBuffer dstBuffer;\n-\n-    @Setup\n-    public void setup() {\n-        srcArray = new byte[ELEM_SIZE];\n-        dstArray = new byte[ELEM_SIZE];\n-        heapSrcSegment = MemorySegment.ofArray(srcArray);\n-        heapDstSegment = MemorySegment.ofArray(dstArray);\n-        nativeSrcSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        nativeDstSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        srcBuffer = ByteBuffer.wrap(srcArray);\n-        dstBuffer = ByteBuffer.wrap(dstArray);\n-    }\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int size;\n@@ -77,4 +59,1 @@\n-    @Benchmark\n-    public void arrayCopy() {\n-        System.arraycopy(srcArray, 0, dstArray, 0, ELEM_SIZE);\n-    }\n+    public static class Array extends SegmentBulkCopy {\n@@ -82,4 +61,2 @@\n-    @Benchmark\n-    public void bufferCopy() {\n-        dstBuffer.put(srcBuffer);\n-    }\n+        byte[] srcArray;\n+        byte[] dstArray;\n@@ -87,5 +64,2 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n-    @Benchmark\n-    public void heapSegmentCopyJava() {\n-        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n-    }\n+        ByteBuffer srcBuffer;\n+        ByteBuffer dstBuffer;\n@@ -93,5 +67,19 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n-    @Benchmark\n-    public void heapSegmentCopyUnsafe() {\n-        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n-    }\n+        @Setup\n+        public void setup() {\n+            srcArray = new byte[size];\n+            var rnd = new Random(42);\n+            rnd.nextBytes(srcArray);\n+            dstArray = new byte[size];\n+            srcBuffer = ByteBuffer.wrap(srcArray);\n+            dstBuffer = ByteBuffer.wrap(dstArray);\n+        }\n+\n+        @Benchmark\n+        public void arrayCopy() {\n+            System.arraycopy(srcArray, 0, dstArray, 0, size);\n+        }\n+\n+        @Benchmark\n+        public void bufferCopy() {\n+            dstBuffer.put(srcBuffer);\n+        }\n@@ -99,4 +87,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n-    @Benchmark\n-    public void nativeSegmentCopyJava() {\n-        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n@@ -105,4 +89,84 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n-    @Benchmark\n-    public void nativeSegmentCopyUnsafe() {\n-        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n+    public static class Segment extends SegmentBulkCopy {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n+\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        MemorySegment srcSegment;\n+        MemorySegment dstSegment;\n+\n+        @Setup\n+        public void setup() {\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray;\n+\n+            baseArray = new long[size \/ Long.BYTES + 1];\n+            var rnd = new Random(42);\n+            for (int i = 0; i < baseArray.length; i++) {\n+                baseArray[i] = rnd.nextLong();\n+            }\n+\n+            switch (SegmentType.valueOf(segmentType)) {\n+                case HEAP -> {\n+                    srcSegment = MemorySegment.ofArray(baseArray);\n+                    dstSegment = MemorySegment.ofArray(baseArray.clone());\n+                }\n+                case NATIVE -> {\n+                    var s = MemorySegment.ofArray(baseArray);\n+                    srcSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, s, JAVA_LONG, 0L, baseArray.length);\n+                    dstSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, s, JAVA_LONG, 0L, baseArray.length);\n+                }\n+            }\n+            switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(0, size);\n+                    dstSegment = dstSegment.asSlice(0, size);\n+                }\n+                case UNALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(1, size);\n+                    dstSegment = dstSegment.asSlice(1, size);\n+                }\n+            }\n+        }\n+\n+        @Benchmark\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n+        public void copy() {\n+            MemorySegment.copy(srcSegment, 0, dstSegment, 0, size);\n+        }\n+\n+        @Benchmark\n+        public void copyLoopIntInt() {\n+            for (int i = 0; i < (int) srcSegment.byteSize(); i++) {\n+                final byte v = srcSegment.get(ValueLayout.JAVA_BYTE, i);\n+                dstSegment.set(ValueLayout.JAVA_BYTE, i, v);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void copyLoopIntLong() {\n+            for (int i = 0; i < srcSegment.byteSize(); i++) {\n+                final byte v = srcSegment.get(ValueLayout.JAVA_BYTE, i);\n+                dstSegment.set(ValueLayout.JAVA_BYTE, i, v);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void copyLoopLongLong() {\n+            for (long i = 0; i < srcSegment.byteSize(); i++) {\n+                final byte v = srcSegment.get(ValueLayout.JAVA_BYTE, i);\n+                dstSegment.set(ValueLayout.JAVA_BYTE, i, v);\n+            }\n+        }\n+\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n+        @Benchmark\n+        public void copyUnsafe() {\n+            MemorySegment.copy(srcSegment, 0, dstSegment, 0, size);\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkCopy.java","additions":115,"deletions":51,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+\n@@ -54,18 +56,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n-    public int ELEM_SIZE;\n-\n-    byte[] array;\n-    MemorySegment heapSegment;\n-    MemorySegment nativeSegment;\n-    MemorySegment unalignedSegment;\n-    ByteBuffer buffer;\n-\n-    @Setup\n-    public void setup() {\n-        array = new byte[ELEM_SIZE];\n-        heapSegment = MemorySegment.ofArray(array);\n-        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n-        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n-        buffer = ByteBuffer.wrap(array);\n-    }\n+    private static final byte ZERO = 0;\n@@ -73,4 +58,2 @@\n-    @Benchmark\n-    public void arraysFill() {\n-        Arrays.fill(array, (byte) 0);\n-    }\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int size;\n@@ -78,6 +61,4 @@\n-    @Benchmark\n-    public void arraysFillLoop() {\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = 0;\n-        }\n-    }\n+    public static class Array extends SegmentBulkFill {\n+\n+        byte[] array;\n+        ByteBuffer buffer;\n@@ -85,4 +66,4 @@\n-    @Benchmark\n-    public void bufferFillLoop() {\n-        for (int i = 0; i < array.length; i++) {\n-            buffer.put(i, (byte)0);\n+        @Setup\n+        public void setup() {\n+            array = new byte[size];\n+            buffer = ByteBuffer.wrap(array);\n@@ -90,1 +71,0 @@\n-    }\n@@ -92,5 +72,4 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n-    @Benchmark\n-    public void heapSegmentFillJava() {\n-        heapSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        public void arraysFill() {\n+            Arrays.fill(array, ZERO);\n+        }\n@@ -98,5 +77,6 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n-    @Benchmark\n-    public void heapSegmentFillUnsafe() {\n-        heapSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        public void arraysFillLoop() {\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = ZERO;\n+            }\n+        }\n@@ -104,4 +84,5 @@\n-    @Benchmark\n-    public void heapSegmentFillLoop() {\n-        for (long i = 0; i < heapSegment.byteSize(); i++) {\n-            heapSegment.set(ValueLayout.JAVA_BYTE, i, (byte) 0);\n+        @Benchmark\n+        public void bufferFillLoop() {\n+            for (int i = 0; i < array.length; i++) {\n+                buffer.put(i, ZERO);\n+            }\n@@ -109,1 +90,0 @@\n-    }\n@@ -111,4 +91,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n-    @Benchmark\n-    public void nativeSegmentFillJava() {\n-        nativeSegment.fill((byte) 0);\n@@ -117,5 +93,4 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n-    @Benchmark\n-    public void nativeSegmentFillUnsafe() {\n-        nativeSegment.fill((byte) 0);\n-    }\n+    public static class Segment extends SegmentBulkFill {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n@@ -123,4 +98,22 @@\n-    @Benchmark\n-    public void nativeSegmentFillLoop() {\n-        for (long i = 0; i < nativeSegment.byteSize(); i++) {\n-            nativeSegment.set(ValueLayout.JAVA_BYTE, i, (byte) 0);\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        MemorySegment segment;\n+\n+        @Setup\n+        public void setup() {\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray = new long[size \/ Long.BYTES + 1];\n+            var heapSegment = MemorySegment.ofArray(baseArray);\n+\n+            segment = switch (SegmentType.valueOf(segmentType)) {\n+                case HEAP   -> heapSegment;\n+                case NATIVE -> Arena.ofAuto().allocateFrom(JAVA_LONG, heapSegment, JAVA_LONG, 0L, baseArray.length);\n+            };\n+            segment = switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED   -> segment.asSlice(0, size);\n+                case UNALIGNED -> segment.asSlice(1, size);\n+            };\n@@ -128,1 +121,0 @@\n-    }\n@@ -130,5 +122,5 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n-    @Benchmark\n-    public void unalignedSegmentFillJava() {\n-        unalignedSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+        public void fill() {\n+            segment.fill(ZERO);\n+        }\n@@ -136,5 +128,13 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n-    @Benchmark\n-    public void unalignedSegmentFillUnsafe() {\n-        unalignedSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        public void fillLoopIntInt() {\n+            for (int i = 0; i < (int)segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, ZERO);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void fillLoopIntLong() {\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, ZERO);\n+            }\n+        }\n@@ -142,4 +142,5 @@\n-    @Benchmark\n-    public void unalignedSegmentFillLoop() {\n-        for (long i = 0; i < unalignedSegment.byteSize(); i++) {\n-            unalignedSegment.set(ValueLayout.JAVA_BYTE, i, (byte) 0);\n+        @Benchmark\n+        public void fillLoopLongLong() {\n+            for (long i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, ZERO);\n+            }\n@@ -147,0 +148,7 @@\n+\n+        @Benchmark\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n+        public void fillUnsafe() {\n+            segment.fill(ZERO);\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkFill.java","additions":85,"deletions":77,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -57,2 +58,2 @@\n-    @Param({\"8\", \"64\"})\n-    public int ELEM_SIZE;\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int size;\n@@ -60,3 +61,1 @@\n-    byte[] array;\n-    AbstractMemorySegmentImpl heapSegment;\n-    AbstractMemorySegmentImpl nativeSegment;\n+    public static class Array extends SegmentBulkHash {\n@@ -64,7 +63,9 @@\n-    @Setup\n-    public void setup() {\n-        \/\/ Always use the same alignment regardless of size\n-        nativeSegment = (AbstractMemorySegmentImpl) Arena.ofAuto().allocate(ELEM_SIZE, 16);\n-        var rnd = new Random(42);\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            nativeSegment.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+        byte[] array;\n+\n+        @Setup\n+        public void setup() {\n+            byte[]  randomArray = new byte[size + 1];\n+            var rnd = new Random(42);\n+            rnd.nextBytes(randomArray);\n+\n+            array = Arrays.copyOf(randomArray, size);\n@@ -72,3 +73,0 @@\n-        array = nativeSegment.toArray(JAVA_BYTE);\n-        heapSegment = (AbstractMemorySegmentImpl) MemorySegment.ofArray(array);\n-    }\n@@ -76,4 +74,4 @@\n-    @Benchmark\n-    public int array() {\n-        return Arrays.hashCode(array);\n-    }\n+        @Benchmark\n+        public int array() {\n+            return Arrays.hashCode(array);\n+        }\n@@ -81,3 +79,0 @@\n-    @Benchmark\n-    public int heapSegment() {\n-        return SegmentBulkOperations.contentHash(heapSegment, 0, ELEM_SIZE);\n@@ -86,4 +81,17 @@\n-    @Benchmark\n-    public int nativeSegment() {\n-        return SegmentBulkOperations.contentHash(nativeSegment, 0, ELEM_SIZE);\n-    }\n+    public static class Segment extends SegmentBulkHash {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n+\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        AbstractMemorySegmentImpl segment;\n+\n+        @Setup\n+        public void setup() {\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray;\n@@ -91,5 +99,31 @@\n-    @Benchmark\n-    public int nativeSegmentJava() {\n-        int result = 1;\n-        for (long i = 0; i < ELEM_SIZE; i++) {\n-            result = 31 * result + nativeSegment.get(JAVA_BYTE, i);\n+            baseArray = new long[size \/ Long.BYTES + 1];\n+            var rnd = new Random(42);\n+            for (int i = 0; i < baseArray.length; i++) {\n+                baseArray[i] = rnd.nextLong();\n+            }\n+            var heapSegment = MemorySegment.ofArray(baseArray);\n+\n+            var s = switch (SegmentType.valueOf(segmentType)) {\n+                    case HEAP   -> heapSegment;\n+                    case NATIVE -> Arena.ofAuto().allocateFrom(JAVA_LONG, heapSegment, JAVA_LONG, 0L, baseArray.length);\n+            };\n+            s = switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED   -> s.asSlice(0, size);\n+                case UNALIGNED -> s.asSlice(1, size);\n+            };\n+            \n+            segment = (AbstractMemorySegmentImpl) s;\n+        }\n+\n+        @Benchmark\n+        public int hash() {\n+            return SegmentBulkOperations.contentHash(segment, 0, size);\n+        }\n+\n+        @Benchmark\n+        public int hashLoopIntInt() {\n+            int result = 1;\n+            for (int i = 0; i < (int)segment.byteSize(); i++) {\n+                result = 31 * result + segment.get(JAVA_BYTE, i);\n+            }\n+            return result;\n@@ -97,1 +131,19 @@\n-        return result;\n+\n+        @Benchmark\n+        public int hashLoopIntLong() {\n+            int result = 1;\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                result = 31 * result + segment.get(JAVA_BYTE, i);\n+            }\n+            return result;\n+        }\n+\n+        @Benchmark\n+        public int hashLoopLongLong() {\n+            int result = 1;\n+            for (long i = 0; i < segment.byteSize(); i++) {\n+                result = 31 * result + segment.get(JAVA_BYTE, i);\n+            }\n+            return result;\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkHash.java","additions":85,"deletions":33,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,19 +55,14 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n-    public int ELEM_SIZE;\n-\n-    MemorySegment srcNative;\n-    MemorySegment dstNative;\n-    byte[] srcArray;\n-    byte[] dstArray;\n-    MemorySegment srcHeap;\n-    MemorySegment dstHeap;\n-\n-    @Setup\n-    public void setup() {\n-        \/\/ Always use the same alignment regardless of size\n-        srcNative = Arena.ofAuto().allocate(ELEM_SIZE,16);\n-        dstNative = Arena.ofAuto().allocate(ELEM_SIZE, 16);\n-        var rnd = new Random(42);\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            srcNative.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int size;\n+\n+    public static class Array extends SegmentBulkMismatch {\n+\n+        byte[] srcArray;\n+        byte[] dstArray;\n+\n+        @Setup\n+        public void setup() {\n+            srcArray = new byte[size];\n+            var rnd = new Random(42);\n+            rnd.nextBytes(srcArray);\n+            dstArray = Arrays.copyOf(srcArray, size);\n@@ -75,6 +70,0 @@\n-        dstNative.copyFrom(srcNative);\n-        srcArray = srcNative.toArray(JAVA_BYTE);\n-        dstArray = dstNative.toArray(JAVA_BYTE);\n-        srcHeap = MemorySegment.ofArray(srcArray);\n-        dstHeap = MemorySegment.ofArray(dstArray);\n-    }\n@@ -82,5 +71,4 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n-    @Benchmark\n-    public long nativeSegmentJava() {\n-        return srcNative.mismatch(dstNative);\n-    }\n+        @Benchmark\n+        public long array() {\n+            return Arrays.mismatch(srcArray, dstArray);\n+        }\n@@ -88,4 +76,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n-    @Benchmark\n-    public long heapSegmentJava() {\n-        return srcHeap.mismatch(dstHeap);\n@@ -94,5 +78,1 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n-    @Benchmark\n-    public long nativeSegmentUnsafe() {\n-        return srcNative.mismatch(dstNative);\n-    }\n+    public static class Segment extends SegmentBulkMismatch {\n@@ -100,5 +80,5 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n-    @Benchmark\n-    public long heapSegmentUnsafe() {\n-        return srcHeap.mismatch(dstHeap);\n-    }\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n+\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n@@ -106,3 +86,51 @@\n-    @Benchmark\n-    public long array() {\n-        return Arrays.mismatch(srcArray, dstArray);\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        MemorySegment srcSegment;\n+        MemorySegment dstSegment;\n+\n+        @Setup\n+        public void setup() {\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray;\n+\n+            baseArray = new long[size \/ Long.BYTES + 1];\n+            var rnd = new Random(42);\n+            for (int i = 0; i < baseArray.length; i++) {\n+                baseArray[i] = rnd.nextLong();\n+            }\n+\n+            switch (SegmentType.valueOf(segmentType)) {\n+                case HEAP -> {\n+                    srcSegment = MemorySegment.ofArray(baseArray);\n+                    dstSegment = MemorySegment.ofArray(baseArray.clone());\n+                }\n+                case NATIVE -> {\n+                    var s = MemorySegment.ofArray(baseArray);\n+                    srcSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, s, JAVA_LONG, 0L, baseArray.length);\n+                    dstSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, s, JAVA_LONG, 0L, baseArray.length);\n+                }\n+            }\n+            switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(0, size);\n+                    dstSegment = dstSegment.asSlice(0, size);\n+                }\n+                case UNALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(1, size);\n+                    dstSegment = dstSegment.asSlice(1, size);\n+                }\n+            }\n+        }\n+\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n+        @Benchmark\n+        public long mismatch() {\n+            return srcSegment.mismatch(dstSegment);\n+        }\n+\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n+        @Benchmark\n+        public long mismatchUnsafe() {\n+            return srcSegment.mismatch(dstSegment);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkMismatch.java","additions":76,"deletions":48,"binary":false,"changes":124,"status":"modified"}]}