{"files":[{"patch":"@@ -1,325 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-import jdk.internal.misc.Unsafe;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgs = { \"--add-opens=java.base\/jdk.internal.misc=ALL-UNNAMED\" })\n-public class BulkOps {\n-\n-    static final Unsafe unsafe = Utils.unsafe;\n-\n-    static final int ELEM_SIZE = 1_000_000;\n-    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n-    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n-    static final byte MAGIC_VALUE = 42;\n-\n-    final Arena arena = Arena.ofShared();\n-\n-    final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n-    final MemorySegment segment = arena.allocate(ALLOC_SIZE, 1);\n-\n-    final IntBuffer buffer = IntBuffer.allocate(ELEM_SIZE);\n-\n-    final int[] ints = new int[ELEM_SIZE];\n-    final MemorySegment bytesSegment = MemorySegment.ofArray(ints);\n-    final long UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n-\n-    \/\/ large(ish) segments\/buffers with same content, 0, for mismatch, non-multiple-of-8 sized\n-    static final int SIZE_WITH_TAIL = (1024 * 1024) + 7;\n-    final MemorySegment mismatchSegmentLarge1;\n-\n-    {\n-        mismatchSegmentLarge1 = arena.allocate(SIZE_WITH_TAIL, 1);\n-    }\n-\n-    final MemorySegment mismatchSegmentLarge2 = arena.allocate(SIZE_WITH_TAIL, 1);\n-    final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-    final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-\n-    \/\/ mismatch at first byte\n-    final MemorySegment mismatchSegmentSmall1 = arena.allocate(7, 1);\n-    final MemorySegment mismatchSegmentSmall2 = arena.allocate(7, 1);\n-    final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n-    final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n-\n-    @Setup\n-    public void setup() {\n-        mismatchSegmentSmall1.fill((byte) 0xFF);\n-        mismatchBufferSmall1.put((byte) 0xFF).clear();\n-        \/\/ verify expected mismatch indices\n-        long si = mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-        if (si != -1)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-        int bi = mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-        if (bi != -1)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-        si = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-        if (si != 0)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-        bi = mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-        if (bi != 0)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-\n-        for (int i = 0; i < ints.length ; i++) {\n-            ints[i] = i;\n-        }\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        arena.close();\n-    }\n-\n-    @Benchmark\n-    public void unsafe_fill() {\n-        unsafe.setMemory(unsafe_addr, ALLOC_SIZE, MAGIC_VALUE);\n-    }\n-\n-    @Benchmark\n-    public void segment_fill() {\n-        segment.fill(MAGIC_VALUE);\n-    }\n-\n-    @Benchmark\n-    public void segment_fill_int_long_loop() {\n-        for (int i = 0 ; i < segment.byteSize() ; i++) {\n-            segment.set(ValueLayout.JAVA_BYTE, i, MAGIC_VALUE);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void segment_fill_int_int_loop() {\n-        for (int i = 0 ; i < (int)segment.byteSize() ; i++) {\n-            segment.set(ValueLayout.JAVA_BYTE, i, MAGIC_VALUE);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void segment_fill_long_long_loop() {\n-        for (long i = 0 ; i < segment.byteSize() ; i++) {\n-            segment.set(ValueLayout.JAVA_BYTE, i, MAGIC_VALUE);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void unsafe_copy() {\n-        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, ALLOC_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void segment_copy() {\n-        segment.copyFrom(bytesSegment);\n-    }\n-\n-    @Benchmark\n-    public void segment_copy_static() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, ints.length);\n-    }\n-\n-    @Benchmark\n-    public void segment_copy_static_int_long_loop() {\n-        long limit = bytesSegment.byteSize() \/ JAVA_INT_UNALIGNED.byteSize();\n-        for (int i = 0 ; i < limit ; i++) {\n-            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void segment_copy_static_int_int_loop() {\n-        long limit = bytesSegment.byteSize() \/ JAVA_INT_UNALIGNED.byteSize();\n-        for (int i = 0 ; i < (int)limit ; i++) {\n-            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void segment_copy_static_long_long_loop() {\n-        long limit = bytesSegment.byteSize() \/ JAVA_INT_UNALIGNED.byteSize();\n-        for (long i = 0 ; i < limit ; i++) {\n-            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[(int)i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void segment_copy_static_small() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void segment_copy_static_small_dontinline() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, 10);\n-    }\n-\n-    @Benchmark\n-    public void segment_copy_static_small_int_long_loop() {\n-        for (int i = 0 ; i < 10L ; i++) {\n-            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void segment_copy_static_small_int_int_loop() {\n-        for (int i = 0 ; i < 10 ; i++) {\n-            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void segment_copy_static_small_long_long_loop() {\n-        for (long i = 0 ; i < 10 ; i++) {\n-            segment.setAtIndex(JAVA_INT_UNALIGNED, i, ints[(int)i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void unsafe_copy_small() {\n-        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void buffer_copy_small() {\n-        buffer.put(0, ints, 0, 10);\n-    }\n-\n-    @Benchmark\n-    public void buffer_copy() {\n-        buffer.put(0, ints, 0, ints.length);\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void segment_copy_static_dontinline() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, ints.length);\n-    }\n-\n-    @Benchmark\n-    public long mismatch_large_segment_int_long_loop() {\n-        for (int i = 0 ; i < mismatchSegmentLarge1.byteSize() ; i++) {\n-            if (mismatchSegmentLarge1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentLarge2.get(ValueLayout.JAVA_BYTE, i)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    @Benchmark\n-    public long mismatch_large_segment_int_int_loop() {\n-        for (int i = 0 ; i < (int)mismatchSegmentLarge1.byteSize() ; i++) {\n-            if (mismatchSegmentLarge1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentLarge2.get(ValueLayout.JAVA_BYTE, i)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    @Benchmark\n-    public long mismatch_large_segment_long_long_loop() {\n-        for (long i = 0 ; i < mismatchSegmentLarge1.byteSize() ; i++) {\n-            if (mismatchSegmentLarge1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentLarge2.get(ValueLayout.JAVA_BYTE, i)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    @Benchmark\n-    public long mismatch_large_segment() {\n-        return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-    }\n-\n-    @Benchmark\n-    public int mismatch_large_bytebuffer() {\n-        return mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-    }\n-\n-    @Benchmark\n-    public long mismatch_small_segment_int_long_loop() {\n-        for (int i = 0 ; i < mismatchSegmentSmall1.byteSize() ; i++) {\n-            if (mismatchSegmentSmall1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentSmall2.get(ValueLayout.JAVA_BYTE, i)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    @Benchmark\n-    public long mismatch_small_segment_int_int_loop() {\n-        for (int i = 0 ; i < (int)mismatchSegmentSmall1.byteSize() ; i++) {\n-            if (mismatchSegmentSmall1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentSmall2.get(ValueLayout.JAVA_BYTE, i)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    @Benchmark\n-    public long mismatch_small_segment_long_long_loop() {\n-        for (long i = 0 ; i < mismatchSegmentSmall1.byteSize() ; i++) {\n-            if (mismatchSegmentSmall1.get(ValueLayout.JAVA_BYTE, i) != mismatchSegmentSmall2.get(ValueLayout.JAVA_BYTE, i)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    @Benchmark\n-    public long mismatch_small_segment() {\n-        return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-    }\n-\n-    @Benchmark\n-    public int mismatch_small_bytebuffer() {\n-        return mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":0,"deletions":325,"binary":false,"changes":325,"status":"deleted"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.Random;\n@@ -45,0 +46,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+\n@@ -53,2 +56,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n@@ -57,3 +59,0 @@\n-    byte[] srcArray;\n-    byte[] dstArray;\n-\n@@ -62,0 +61,3 @@\n+        byte[] srcArray;\n+        byte[] dstArray;\n+\n@@ -68,0 +70,2 @@\n+            var rnd = new Random(42);\n+            rnd.nextBytes(srcArray);\n@@ -101,2 +105,8 @@\n-            srcArray = new byte[size + 1];\n-            dstArray = new byte[size + 1];\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray;\n+\n+            baseArray = new long[size \/ Long.BYTES + 1];\n+            var rnd = new Random(42);\n+            for (int i = 0; i < baseArray.length; i++) {\n+                baseArray[i] = rnd.nextLong();\n+            }\n@@ -104,1 +114,1 @@\n-            switch (Segment.SegmentType.valueOf(segmentType)) {\n+            switch (SegmentType.valueOf(segmentType)) {\n@@ -106,2 +116,2 @@\n-                    srcSegment = MemorySegment.ofArray(srcArray);\n-                    dstSegment = MemorySegment.ofArray(dstArray);\n+                    srcSegment = MemorySegment.ofArray(baseArray);\n+                    dstSegment = MemorySegment.ofArray(baseArray.clone());\n@@ -110,2 +120,3 @@\n-                    srcSegment = Arena.ofAuto().allocate(srcArray.length, Long.BYTES);\n-                    dstSegment = Arena.ofAuto().allocate(dstArray.length, Long.BYTES);\n+                    var s = MemorySegment.ofArray(baseArray);\n+                    srcSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, s, JAVA_LONG, 0L, baseArray.length);\n+                    dstSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, s, JAVA_LONG, 0L, baseArray.length);\n@@ -114,1 +125,1 @@\n-            switch (Segment.Alignment.valueOf(alignment)) {\n+            switch (Alignment.valueOf(alignment)) {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkCopy.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+\n@@ -56,2 +58,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n@@ -60,2 +61,0 @@\n-    byte[] array;\n-\n@@ -64,0 +63,1 @@\n+        byte[] array;\n@@ -108,9 +108,12 @@\n-            array = new byte[size + 1]; \/\/ Allow for adjustment\n-            switch (SegmentType.valueOf(segmentType)) {\n-                case HEAP   -> segment = MemorySegment.ofArray(array);\n-                case NATIVE -> segment = Arena.ofAuto().allocate(array.length, Long.BYTES);\n-            }\n-            switch (Alignment.valueOf(alignment)) {\n-                case ALIGNED   -> segment = segment.asSlice(0, size);\n-                case UNALIGNED -> segment = segment.asSlice(1, size);\n-            }\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray = new long[size \/ Long.BYTES + 1];\n+            var heapSegment = MemorySegment.ofArray(baseArray);\n+\n+            segment = switch (SegmentType.valueOf(segmentType)) {\n+                case HEAP   -> heapSegment;\n+                case NATIVE -> Arena.ofAuto().allocateFrom(JAVA_LONG, heapSegment, JAVA_LONG, 0L, baseArray.length);\n+            };\n+            segment = switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED   -> segment.asSlice(0, size);\n+                case UNALIGNED -> segment.asSlice(1, size);\n+            };\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkFill.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -57,2 +58,1 @@\n-    @Param({\"2\", \/*\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"*\/})\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n@@ -61,8 +61,0 @@\n-    byte[] randomArray;\n-\n-    void baseSetup() {\n-        randomArray = new byte[size + 1];\n-        var rnd = new Random(42);\n-        rnd.nextBytes(randomArray);\n-    }\n-\n@@ -75,1 +67,4 @@\n-            baseSetup();\n+            byte[]  randomArray = new byte[size + 1];\n+            var rnd = new Random(42);\n+            rnd.nextBytes(randomArray);\n+\n@@ -101,2 +96,2 @@\n-            baseSetup();\n-            MemorySegment s = null;\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray;\n@@ -104,7 +99,4 @@\n-            switch (SegmentBulkFill.Segment.SegmentType.valueOf(segmentType)) {\n-                case HEAP   -> s = MemorySegment.ofArray(randomArray);\n-                case NATIVE -> s = Arena.ofAuto().allocate(randomArray.length, Long.BYTES);\n-            }\n-            switch (SegmentBulkFill.Segment.Alignment.valueOf(alignment)) {\n-                case ALIGNED   -> s = s.asSlice(0, size);\n-                case UNALIGNED -> s = s.asSlice(1, size);\n+            baseArray = new long[size \/ Long.BYTES + 1];\n+            var rnd = new Random(42);\n+            for (int i = 0; i < baseArray.length; i++) {\n+                baseArray[i] = rnd.nextLong();\n@@ -112,2 +104,11 @@\n-\n-            \/\/ Always use the same alignment regardless of size\n+            var heapSegment = MemorySegment.ofArray(baseArray);\n+\n+            var s = switch (SegmentType.valueOf(segmentType)) {\n+                    case HEAP   -> heapSegment;\n+                    case NATIVE -> Arena.ofAuto().allocateFrom(JAVA_LONG, heapSegment, JAVA_LONG, 0L, baseArray.length);\n+            };\n+            s = switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED   -> s.asSlice(0, size);\n+                case UNALIGNED -> s.asSlice(1, size);\n+            };\n+            \n@@ -123,1 +124,1 @@\n-        public void hashLoopIntInt() {\n+        public int hashLoopIntInt() {\n@@ -128,0 +129,1 @@\n+            return result;\n@@ -131,1 +133,1 @@\n-        public void hashLoopIntLong() {\n+        public int hashLoopIntLong() {\n@@ -136,0 +138,1 @@\n+            return result;\n@@ -139,1 +142,1 @@\n-        public void hashLoopLongLong() {\n+        public int hashLoopLongLong() {\n@@ -144,0 +147,1 @@\n+            return result;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkHash.java","additions":29,"deletions":25,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"16\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n@@ -59,8 +58,0 @@\n-    byte[] baseArray;\n-\n-    void baseSetup() {\n-        baseArray = new byte[size + 1];\n-        var rnd = new Random(42);\n-        rnd.nextBytes(baseArray);\n-    }\n-\n@@ -74,3 +65,4 @@\n-            baseSetup();\n-            srcArray = Arrays.copyOf(baseArray, size);\n-            dstArray = Arrays.copyOf(baseArray, size);\n+            srcArray = new byte[size];\n+            var rnd = new Random(42);\n+            rnd.nextBytes(srcArray);\n+            dstArray = Arrays.copyOf(srcArray, size);\n@@ -102,1 +94,8 @@\n-            baseSetup();\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray;\n+\n+            baseArray = new long[size \/ Long.BYTES + 1];\n+            var rnd = new Random(42);\n+            for (int i = 0; i < baseArray.length; i++) {\n+                baseArray[i] = rnd.nextLong();\n+            }\n@@ -104,1 +103,1 @@\n-            switch (SegmentBulkCopy.Segment.SegmentType.valueOf(segmentType)) {\n+            switch (SegmentType.valueOf(segmentType)) {\n@@ -107,1 +106,1 @@\n-                    dstSegment = MemorySegment.ofArray(baseArray);\n+                    dstSegment = MemorySegment.ofArray(baseArray.clone());\n@@ -110,2 +109,3 @@\n-                    srcSegment = Arena.ofAuto().allocate(baseArray.length, Long.BYTES);\n-                    dstSegment = Arena.ofAuto().allocate(baseArray.length, Long.BYTES);\n+                    var s = MemorySegment.ofArray(baseArray);\n+                    srcSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, s, JAVA_LONG, 0L, baseArray.length);\n+                    dstSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, s, JAVA_LONG, 0L, baseArray.length);\n@@ -114,1 +114,1 @@\n-            switch (SegmentBulkCopy.Segment.Alignment.valueOf(alignment)) {\n+            switch (Alignment.valueOf(alignment)) {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkMismatch.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"}]}