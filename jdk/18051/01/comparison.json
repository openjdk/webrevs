{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.LinkedHashMap;\n@@ -44,0 +45,1 @@\n+import jdk.jfr.Name;\n@@ -57,2 +59,2 @@\n-    private final List<EventType> nativeEventTypes = new ArrayList<>(150);\n-    private final List<EventControl> nativeControls = new ArrayList<EventControl>(nativeEventTypes.size());\n+    private final Map<String, EventType> nativeEventTypes = LinkedHashMap.newHashMap(150);\n+    private final Map<String, EventControl> nativeControls = LinkedHashMap.newHashMap(150);\n@@ -86,2 +88,3 @@\n-                nativeControls.add(new EventControl(pEventType));\n-                nativeEventTypes.add(eventType);\n+                String name = eventType.getName();\n+                nativeControls.put(name, new EventControl(pEventType));\n+                nativeEventTypes.put(name,eventType);\n@@ -104,1 +107,1 @@\n-        for (EventType t : nativeEventTypes) {\n+        for (EventType t : nativeEventTypes.values()) {\n@@ -203,0 +206,26 @@\n+        \/\/ Check for native mirror.\n+        \/\/ Note, defining an event in metadata.xml is not a generic mechanism to emit\n+        \/\/ native data in Java. For example, calling JVM.getStackTraceId(int, long)\n+        \/\/ and assign the result to a long field is not enough to always get a proper\n+        \/\/ stack trace. Purpose of the mechanism is to transfer metadata, such as\n+        \/\/ native type IDs, without specialized Java logic for each type.\n+        if (eventClass.getClassLoader() == null) {\n+            Name name = eventClass.getAnnotation(Name.class);\n+            if (name != null) {\n+                String n = name.value();\n+                EventType nativeType = nativeEventTypes.get(n);\n+                if (nativeType != null) {\n+                    var nativeFields = nativeType.getFields();\n+                    var eventFields = pEventType.getFields();\n+                    var comparator = Comparator.comparing(ValueDescriptor::getName);\n+                    if (!Utils.compareLists(nativeFields, eventFields, comparator)) {\n+                        throw new InternalError(\"Field for native mirror event \" + n + \" doesn't match Java event\");\n+                    }\n+                    nativeEventTypes.remove(n);\n+                    nativeControls.remove(n);\n+                    TypeLibrary.removeType(nativeType.getId());\n+                    pEventType.setAnnotations(nativeType.getAnnotationElements());\n+                    pEventType.setFields(nativeType.getFields());\n+                }\n+            }\n+        }\n@@ -229,1 +258,1 @@\n-        controls.addAll(nativeControls);\n+        controls.addAll(nativeControls.values());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,0 +225,4 @@\n+    public void setFields(List<ValueDescriptor> fields) {\n+        this.fields = List.copyOf(fields);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Type.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -325,1 +325,1 @@\n-                    throw new InternalError(\"Type expected to match for field \" + vd.getName() + \" expected \"  + field.getName() + \" but got \" + vd.getName());\n+                    throw new InternalError(\"Type expected to match for field \" + vd.getName() + \" expected \"  + field.getType().getName() + \" but got \" + vd.getTypeName());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.util.Comparator;\n@@ -179,0 +180,13 @@\n+    public static <T> boolean compareLists(List<T> a, List<T> b, Comparator<T> c) {\n+        int size = a.size();\n+        if (size != b.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < size; i++) {\n+            if (c.compare(a.get(i), b.get(i)) != 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"}]}