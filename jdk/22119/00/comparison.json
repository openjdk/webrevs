{"files":[{"patch":"@@ -530,11 +530,0 @@\n-        @SuppressWarnings(\"removal\")\n-        Field mapField = java.security.AccessController.doPrivileged(\n-            (java.security.PrivilegedAction<Field>) () -> {\n-                try {\n-                    Field f = ConcurrentSkipListSet.class\n-                        .getDeclaredField(\"m\");\n-                    f.setAccessible(true);\n-                    return f;\n-                } catch (ReflectiveOperationException e) {\n-                    throw new Error(e);\n-                }});\n@@ -542,0 +531,2 @@\n+            Field mapField = ConcurrentSkipListSet.class.getDeclaredField(\"m\");\n+            mapField.setAccessible(true);\n@@ -543,1 +534,1 @@\n-        } catch (IllegalAccessException e) {\n+        } catch (IllegalAccessException | NoSuchFieldException e) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentSkipListSet.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2099,11 +2099,0 @@\n-        @SuppressWarnings(\"removal\")\n-        Field lockField = java.security.AccessController.doPrivileged(\n-            (java.security.PrivilegedAction<Field>) () -> {\n-                try {\n-                    Field f = CopyOnWriteArrayList.class\n-                        .getDeclaredField(\"lock\");\n-                    f.setAccessible(true);\n-                    return f;\n-                } catch (ReflectiveOperationException e) {\n-                    throw new Error(e);\n-                }});\n@@ -2111,0 +2100,2 @@\n+            Field lockField = CopyOnWriteArrayList.class.getDeclaredField(\"lock\");\n+            lockField.setAccessible(true);\n@@ -2112,2 +2103,2 @@\n-        } catch (IllegalAccessException e) {\n-            throw new Error(e);\n+        } catch (IllegalAccessException | NoSuchFieldException e) {\n+                throw new RuntimeException(e);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArrayList.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -43,1 +41,0 @@\n-import java.security.PrivilegedActionException;\n@@ -49,1 +46,0 @@\n-import sun.security.util.SecurityConstants;\n@@ -562,2 +558,0 @@\n-        @SuppressWarnings(\"removal\")\n-        final AccessControlContext acc;\n@@ -565,1 +559,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -568,1 +561,0 @@\n-            this.acc = AccessController.getContext();\n@@ -571,1 +563,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -573,10 +564,1 @@\n-            try {\n-                return AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<T>() {\n-                        public T run() throws Exception {\n-                            return task.call();\n-                        }\n-                    }, acc);\n-            } catch (PrivilegedActionException e) {\n-                throw e.getException();\n-            }\n+            return task.call();\n@@ -598,1 +580,0 @@\n-        final AccessControlContext acc;\n@@ -603,11 +584,0 @@\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                \/\/ Calls to getContextClassLoader from this class\n-                \/\/ never trigger a security check, but we check\n-                \/\/ whether our callers have this permission anyways.\n-                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-\n-                \/\/ Whether setContextClassLoader turns out to be necessary\n-                \/\/ or not, we fail fast if permission is not available.\n-                sm.checkPermission(new RuntimePermission(\"setContextClassLoader\"));\n-            }\n@@ -615,1 +585,0 @@\n-            this.acc = AccessController.getContext();\n@@ -619,1 +588,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -621,20 +589,11 @@\n-            try {\n-                return AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<T>() {\n-                        public T run() throws Exception {\n-                            Thread t = Thread.currentThread();\n-                            ClassLoader cl = t.getContextClassLoader();\n-                            if (ccl == cl) {\n-                                return task.call();\n-                            } else {\n-                                t.setContextClassLoader(ccl);\n-                                try {\n-                                    return task.call();\n-                                } finally {\n-                                    t.setContextClassLoader(cl);\n-                                }\n-                            }\n-                        }\n-                    }, acc);\n-            } catch (PrivilegedActionException e) {\n-                throw e.getException();\n+            Thread t = Thread.currentThread();\n+            ClassLoader cl = t.getContextClassLoader();\n+            if (ccl == cl) {\n+                return task.call();\n+            } else {\n+                t.setContextClassLoader(ccl);\n+                try {\n+                    return task.call();\n+                } finally {\n+                    t.setContextClassLoader(cl);\n+                }\n@@ -659,4 +618,1 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager s = System.getSecurityManager();\n-            group = (s != null) ? s.getThreadGroup() :\n-                                  Thread.currentThread().getThreadGroup();\n+            group = Thread.currentThread().getThreadGroup();\n@@ -681,1 +637,1 @@\n-     * Thread factory capturing access control context and class loader.\n+     * Thread factory capturing the current class loader.\n@@ -685,1 +641,0 @@\n-        final AccessControlContext acc;\n@@ -688,1 +643,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -691,11 +645,0 @@\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                \/\/ Calls to getContextClassLoader from this class\n-                \/\/ never trigger a security check, but we check\n-                \/\/ whether our callers have this permission anyways.\n-                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-\n-                \/\/ Fail fast\n-                sm.checkPermission(new RuntimePermission(\"setContextClassLoader\"));\n-            }\n-            this.acc = AccessController.getContext();\n@@ -709,7 +652,2 @@\n-                    AccessController.doPrivileged(new PrivilegedAction<>() {\n-                        public Void run() {\n-                            Thread.currentThread().setContextClassLoader(ccl);\n-                            r.run();\n-                            return null;\n-                        }\n-                    }, acc);\n+                    Thread.currentThread().setContextClassLoader(ccl);\n+                    r.run();\n@@ -814,3 +752,1 @@\n-                    PrivilegedAction<Void> pa = () -> { executor.shutdown(); return null; };\n-                    @SuppressWarnings(\"removal\")\n-                    var ignore = AccessController.doPrivileged(pa);\n+                    executor.shutdown();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Executors.java","additions":17,"deletions":81,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -40,6 +40,0 @@\n-import java.security.AccessController;\n-import java.security.AccessControlContext;\n-import java.security.Permission;\n-import java.security.Permissions;\n-import java.security.PrivilegedAction;\n-import java.security.ProtectionDomain;\n@@ -52,1 +46,0 @@\n-import java.util.concurrent.CountDownLatch;\n@@ -792,3 +785,2 @@\n-     * some System property parsing and security processing that takes\n-     * far longer than the actual construction when SecurityManagers\n-     * are used or properties are set. The common pool is\n+     * some System property parsing that takes\n+     * far longer than the actual construction. The common pool is\n@@ -820,2 +812,1 @@\n-     * InnocuousForkJoinWorkerThread when there is a SecurityManager\n-     * present. These workers have no permissions set, do not belong\n+     * InnocuousForkJoinWorkerThread. These workers do not belong\n@@ -1082,15 +1073,0 @@\n-    \/**\n-     * If there is a security manager, makes sure caller has\n-     * permission to modify threads.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static void checkPermission() {\n-        SecurityManager security; RuntimePermission perm;\n-        if ((security = System.getSecurityManager()) != null) {\n-            if ((perm = modifyThreadPermission) == null)\n-                modifyThreadPermission = perm = \/\/ races OK\n-                    new RuntimePermission(\"modifyThread\");\n-            security.checkPermission(perm);\n-        }\n-    }\n-\n@@ -1132,58 +1108,1 @@\n-            boolean isCommon = (pool.workerNamePrefix == null);\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null && isCommon)\n-                return newCommonWithACC(pool);\n-            else\n-                return newRegularWithACC(pool);\n-        }\n-\n-        \/*\n-         * Create and use static AccessControlContexts only if there\n-         * is a SecurityManager. (These can be removed if\/when\n-         * SecurityManagers are removed from platform.) The ACCs are\n-         * immutable and equivalent even when racily initialized, so\n-         * they don't require locking, although with the chance of\n-         * needlessly duplicate construction.\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        static volatile AccessControlContext regularACC, commonACC;\n-\n-        @SuppressWarnings(\"removal\")\n-        static ForkJoinWorkerThread newRegularWithACC(ForkJoinPool pool) {\n-            AccessControlContext acc = regularACC;\n-            if (acc == null) {\n-                Permissions ps = new Permissions();\n-                ps.add(new RuntimePermission(\"getClassLoader\"));\n-                ps.add(new RuntimePermission(\"setContextClassLoader\"));\n-                regularACC = acc =\n-                    new AccessControlContext(new ProtectionDomain[] {\n-                            new ProtectionDomain(null, ps) });\n-            }\n-            return AccessController.doPrivileged(\n-                new PrivilegedAction<>() {\n-                    public ForkJoinWorkerThread run() {\n-                        return new ForkJoinWorkerThread(null, pool, true, false);\n-                    }}, acc);\n-        }\n-\n-        @SuppressWarnings(\"removal\")\n-        static ForkJoinWorkerThread newCommonWithACC(ForkJoinPool pool) {\n-            AccessControlContext acc = commonACC;\n-            if (acc == null) {\n-                Permissions ps = new Permissions();\n-                ps.add(new RuntimePermission(\"getClassLoader\"));\n-                ps.add(new RuntimePermission(\"setContextClassLoader\"));\n-                ps.add(new RuntimePermission(\"modifyThread\"));\n-                ps.add(new RuntimePermission(\"enableContextClassLoaderOverride\"));\n-                ps.add(new RuntimePermission(\"modifyThreadGroup\"));\n-                commonACC = acc =\n-                    new AccessControlContext(new ProtectionDomain[] {\n-                            new ProtectionDomain(null, ps) });\n-            }\n-            return AccessController.doPrivileged(\n-                new PrivilegedAction<>() {\n-                    public ForkJoinWorkerThread run() {\n-                        return new ForkJoinWorkerThread.\n-                            InnocuousForkJoinWorkerThread(pool);\n-                    }}, acc);\n+            return new ForkJoinWorkerThread(null, pool, true, false);\n@@ -1627,6 +1546,0 @@\n-    \/**\n-     * Permission required for callers of methods that may start or\n-     * kill threads. Lazily constructed.\n-     *\/\n-    static volatile RuntimePermission modifyThreadPermission;\n-\n@@ -2589,1 +2502,0 @@\n-     * @param isSubmit false if this is for a common pool fork\n@@ -2986,1 +2898,0 @@\n-        checkPermission();\n@@ -3274,1 +3185,0 @@\n-        checkPermission();\n@@ -3672,1 +3582,0 @@\n-        checkPermission();\n@@ -3692,1 +3601,0 @@\n-        checkPermission();\n@@ -3799,1 +3707,0 @@\n-            checkPermission();\n@@ -4023,6 +3930,1 @@\n-        @SuppressWarnings(\"removal\")\n-        ForkJoinPool p = common = (System.getSecurityManager() == null) ?\n-            new ForkJoinPool((byte)0) :\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                    public ForkJoinPool run() {\n-                        return new ForkJoinPool((byte)0); }});\n+        ForkJoinPool p = common = new ForkJoinPool((byte)0);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":5,"deletions":103,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -38,4 +38,0 @@\n-import java.security.AccessController;\n-import java.security.AccessControlContext;\n-import java.security.PrivilegedAction;\n-import java.security.ProtectionDomain;\n@@ -231,1 +227,1 @@\n-     * A worker thread that has no permissions, is not a member of any\n+     * A worker thread that is not a member of any\n@@ -248,2 +244,1 @@\n-            if (cl != null && ClassLoader.getSystemClassLoader() != cl)\n-                throw new SecurityException(\"setContextClassLoader\");\n+            \/\/ No-op, do not change the context class loader\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -701,1 +699,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -703,1 +700,0 @@\n-        if (System.getSecurityManager() == null) {\n@@ -705,7 +701,0 @@\n-        } else {\n-            PrivilegedAction<Void> pa = () -> {\n-                implInterruptAll();\n-                return null;\n-            };\n-            AccessController.doPrivileged(pa);\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.security.AccessControlContext;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.Permission;\n@@ -51,1 +50,0 @@\n-    private static final Permission MODIFY_THREAD = new RuntimePermission(\"modifyThread\");\n@@ -83,12 +81,0 @@\n-    \/**\n-     * Throws SecurityException if there is a security manager set and it denies\n-     * RuntimePermission(\"modifyThread\").\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private void checkPermission() {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(MODIFY_THREAD);\n-        }\n-    }\n-\n@@ -146,1 +132,0 @@\n-        checkPermission();\n@@ -153,1 +138,0 @@\n-        checkPermission();\n@@ -205,1 +189,0 @@\n-        checkPermission();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadPerTaskExecutor.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -569,23 +569,0 @@\n-    \/**\n-     * Permission required for callers of shutdown and shutdownNow.\n-     * We additionally require (see checkShutdownAccess) that callers\n-     * have permission to actually interrupt threads in the worker set\n-     * (as governed by Thread.interrupt, which relies on\n-     * ThreadGroup.checkAccess, which in turn relies on\n-     * SecurityManager.checkAccess). Shutdowns are attempted only if\n-     * these checks pass.\n-     *\n-     * All actual invocations of Thread.interrupt (see\n-     * interruptIdleWorkers and interruptWorkers) ignore\n-     * SecurityExceptions, meaning that the attempted interrupts\n-     * silently fail. In the case of shutdown, they should not fail\n-     * unless the SecurityManager has inconsistent policies, sometimes\n-     * allowing access to a thread and sometimes not. In such cases,\n-     * failure to actually interrupt threads may disable or delay full\n-     * termination. Other uses of interruptIdleWorkers are advisory,\n-     * and failure to actually interrupt will merely delay response to\n-     * configuration changes so is not handled exceptionally.\n-     *\/\n-    private static final RuntimePermission shutdownPerm =\n-        new RuntimePermission(\"modifyThread\");\n-\n@@ -676,4 +653,1 @@\n-                try {\n-                    t.interrupt();\n-                } catch (SecurityException ignore) {\n-                }\n+                t.interrupt();\n@@ -752,21 +726,1 @@\n-     * If there is a security manager, makes sure caller has\n-     * permission to shut down threads in general (see shutdownPerm).\n-     * If this passes, additionally makes sure the caller is allowed\n-     * to interrupt each worker thread. This might not be true even if\n-     * first check passed, if the SecurityManager treats some threads\n-     * specially.\n-     *\/\n-    private void checkShutdownAccess() {\n-        \/\/ assert mainLock.isHeldByCurrentThread();\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(shutdownPerm);\n-            for (Worker w : workers)\n-                security.checkAccess(w.thread);\n-        }\n-    }\n-\n-    \/**\n-     * Interrupts all threads, even if active. Ignores SecurityExceptions\n-     * (in which case some threads may remain uninterrupted).\n+     * Interrupts all threads, even if active.\n@@ -783,3 +737,1 @@\n-     * termination or configuration changes. Ignores\n-     * SecurityExceptions (in which case some threads may remain\n-     * uninterrupted).\n+     * termination or configuration changes.\n@@ -808,1 +760,0 @@\n-                    } catch (SecurityException ignore) {\n@@ -1393,1 +1344,0 @@\n-            checkShutdownAccess();\n@@ -1423,1 +1373,0 @@\n-            checkShutdownAccess();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadPoolExecutor.java","additions":3,"deletions":54,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -388,1 +385,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -395,6 +391,1 @@\n-                field = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Field>() {\n-                        public Field run() throws NoSuchFieldException {\n-                            return tclass.getDeclaredField(fieldName);\n-                        }\n-                    });\n+                field = tclass.getDeclaredField(fieldName);\n@@ -410,2 +401,0 @@\n-            } catch (PrivilegedActionException pae) {\n-                throw new RuntimeException(pae.getException());\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -384,1 +381,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -390,6 +386,1 @@\n-                field = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Field>() {\n-                        public Field run() throws NoSuchFieldException {\n-                            return tclass.getDeclaredField(fieldName);\n-                        }\n-                    });\n+                field = tclass.getDeclaredField(fieldName);\n@@ -405,2 +396,0 @@\n-            } catch (PrivilegedActionException pae) {\n-                throw new RuntimeException(pae.getException());\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -332,11 +332,0 @@\n-        @SuppressWarnings(\"removal\")\n-        Field arrayField = java.security.AccessController.doPrivileged(\n-            (java.security.PrivilegedAction<Field>) () -> {\n-                try {\n-                    Field f = AtomicReferenceArray.class\n-                        .getDeclaredField(\"array\");\n-                    f.setAccessible(true);\n-                    return f;\n-                } catch (ReflectiveOperationException e) {\n-                    throw new Error(e);\n-                }});\n@@ -344,0 +333,3 @@\n+\n+            Field arrayField = AtomicReferenceArray.class.getDeclaredField(\"array\");\n+            arrayField.setAccessible(true);\n@@ -345,1 +337,1 @@\n-        } catch (IllegalAccessException e) {\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceArray.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -323,1 +320,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -332,6 +328,1 @@\n-                field = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Field>() {\n-                        public Field run() throws NoSuchFieldException {\n-                            return tclass.getDeclaredField(fieldName);\n-                        }\n-                    });\n+                field = tclass.getDeclaredField(fieldName);\n@@ -348,2 +339,0 @@\n-            } catch (PrivilegedActionException pae) {\n-                throw new RuntimeException(pae.getException());\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -383,11 +383,7 @@\n-            @SuppressWarnings(\"removal\")\n-        MethodHandles.Lookup l2 = java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<>() {\n-                        public MethodHandles.Lookup run() {\n-                            try {\n-                                return MethodHandles.privateLookupIn(Thread.class, MethodHandles.lookup());\n-                            } catch (ReflectiveOperationException e) {\n-                                throw new ExceptionInInitializerError(e);\n-                            }\n-                        }});\n-        THREAD_PROBE = MhUtil.findVarHandle(l2, \"threadLocalRandomProbe\", int.class);\n+        try {\n+            MethodHandles.Lookup l2 =\n+                 MethodHandles.privateLookupIn(Thread.class, MethodHandles.lookup());\n+            THREAD_PROBE = MhUtil.findVarHandle(l2, \"threadLocalRandomProbe\", int.class);\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"}]}