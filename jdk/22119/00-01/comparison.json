{"files":[{"patch":"@@ -2104,1 +2104,1 @@\n-                throw new RuntimeException(e);\n+            throw new Error(e);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArrayList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,6 @@\n+import java.security.AccessController;\n+import java.security.AccessControlContext;\n+import java.security.Permission;\n+import java.security.Permissions;\n+import java.security.PrivilegedAction;\n+import java.security.ProtectionDomain;\n@@ -46,0 +52,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -785,2 +792,3 @@\n-     * some System property parsing that takes\n-     * far longer than the actual construction. The common pool is\n+     * some System property parsing and security processing that takes\n+     * far longer than the actual construction when SecurityManagers\n+     * are used or properties are set. The common pool is\n@@ -812,1 +820,2 @@\n-     * InnocuousForkJoinWorkerThread. These workers do not belong\n+     * InnocuousForkJoinWorkerThread when there is a SecurityManager\n+     * present. These workers have no permissions set, do not belong\n@@ -1073,0 +1082,15 @@\n+    \/**\n+     * If there is a security manager, makes sure caller has\n+     * permission to modify threads.\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    private static void checkPermission() {\n+        SecurityManager security; RuntimePermission perm;\n+        if ((security = System.getSecurityManager()) != null) {\n+            if ((perm = modifyThreadPermission) == null)\n+                modifyThreadPermission = perm = \/\/ races OK\n+                    new RuntimePermission(\"modifyThread\");\n+            security.checkPermission(perm);\n+        }\n+    }\n+\n@@ -1108,1 +1132,58 @@\n-            return new ForkJoinWorkerThread(null, pool, true, false);\n+            boolean isCommon = (pool.workerNamePrefix == null);\n+            @SuppressWarnings(\"removal\")\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm != null && isCommon)\n+                return newCommonWithACC(pool);\n+            else\n+                return newRegularWithACC(pool);\n+        }\n+\n+        \/*\n+         * Create and use static AccessControlContexts only if there\n+         * is a SecurityManager. (These can be removed if\/when\n+         * SecurityManagers are removed from platform.) The ACCs are\n+         * immutable and equivalent even when racily initialized, so\n+         * they don't require locking, although with the chance of\n+         * needlessly duplicate construction.\n+         *\/\n+        @SuppressWarnings(\"removal\")\n+        static volatile AccessControlContext regularACC, commonACC;\n+\n+        @SuppressWarnings(\"removal\")\n+        static ForkJoinWorkerThread newRegularWithACC(ForkJoinPool pool) {\n+            AccessControlContext acc = regularACC;\n+            if (acc == null) {\n+                Permissions ps = new Permissions();\n+                ps.add(new RuntimePermission(\"getClassLoader\"));\n+                ps.add(new RuntimePermission(\"setContextClassLoader\"));\n+                regularACC = acc =\n+                    new AccessControlContext(new ProtectionDomain[] {\n+                            new ProtectionDomain(null, ps) });\n+            }\n+            return AccessController.doPrivileged(\n+                new PrivilegedAction<>() {\n+                    public ForkJoinWorkerThread run() {\n+                        return new ForkJoinWorkerThread(null, pool, true, false);\n+                    }}, acc);\n+        }\n+\n+        @SuppressWarnings(\"removal\")\n+        static ForkJoinWorkerThread newCommonWithACC(ForkJoinPool pool) {\n+            AccessControlContext acc = commonACC;\n+            if (acc == null) {\n+                Permissions ps = new Permissions();\n+                ps.add(new RuntimePermission(\"getClassLoader\"));\n+                ps.add(new RuntimePermission(\"setContextClassLoader\"));\n+                ps.add(new RuntimePermission(\"modifyThread\"));\n+                ps.add(new RuntimePermission(\"enableContextClassLoaderOverride\"));\n+                ps.add(new RuntimePermission(\"modifyThreadGroup\"));\n+                commonACC = acc =\n+                    new AccessControlContext(new ProtectionDomain[] {\n+                            new ProtectionDomain(null, ps) });\n+            }\n+            return AccessController.doPrivileged(\n+                new PrivilegedAction<>() {\n+                    public ForkJoinWorkerThread run() {\n+                        return new ForkJoinWorkerThread.\n+                            InnocuousForkJoinWorkerThread(pool);\n+                    }}, acc);\n@@ -1546,0 +1627,6 @@\n+    \/**\n+     * Permission required for callers of methods that may start or\n+     * kill threads. Lazily constructed.\n+     *\/\n+    static volatile RuntimePermission modifyThreadPermission;\n+\n@@ -2502,0 +2589,1 @@\n+     * @param isSubmit false if this is for a common pool fork\n@@ -2898,0 +2986,1 @@\n+        checkPermission();\n@@ -3185,0 +3274,1 @@\n+        checkPermission();\n@@ -3582,0 +3672,1 @@\n+        checkPermission();\n@@ -3601,0 +3692,1 @@\n+        checkPermission();\n@@ -3707,0 +3799,1 @@\n+            checkPermission();\n@@ -3930,1 +4023,6 @@\n-        ForkJoinPool p = common = new ForkJoinPool((byte)0);\n+        @SuppressWarnings(\"removal\")\n+        ForkJoinPool p = common = (System.getSecurityManager() == null) ?\n+            new ForkJoinPool((byte)0) :\n+            AccessController.doPrivileged(new PrivilegedAction<>() {\n+                    public ForkJoinPool run() {\n+                        return new ForkJoinPool((byte)0); }});\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":103,"deletions":5,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+import java.security.AccessController;\n+import java.security.AccessControlContext;\n+import java.security.PrivilegedAction;\n+import java.security.ProtectionDomain;\n@@ -227,1 +231,1 @@\n-     * A worker thread that is not a member of any\n+     * A worker thread that has no permissions, is not a member of any\n@@ -244,1 +248,2 @@\n-            \/\/ No-op, do not change the context class loader\n+            if (cl != null && ClassLoader.getSystemClassLoader() != cl)\n+                throw new SecurityException(\"setContextClassLoader\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -689,1 +689,1 @@\n-    private void implInterruptAll() {\n+    private void interruptAll() {\n@@ -699,4 +699,0 @@\n-    private void interruptAll() {\n-            implInterruptAll();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -395,6 +395,0 @@\n-                ClassLoader cl = tclass.getClassLoader();\n-                ClassLoader ccl = caller.getClassLoader();\n-                if ((ccl != null) && (ccl != cl) &&\n-                    ((cl == null) || !isAncestor(cl, ccl))) {\n-                    sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);\n-                }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -384,2 +384,1 @@\n-            MethodHandles.Lookup l2 =\n-                 MethodHandles.privateLookupIn(Thread.class, MethodHandles.lookup());\n+            MethodHandles.Lookup l2 = MethodHandles.privateLookupIn(Thread.class, l1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}