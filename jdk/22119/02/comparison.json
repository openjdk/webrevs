{"files":[{"patch":"@@ -530,11 +530,0 @@\n-        @SuppressWarnings(\"removal\")\n-        Field mapField = java.security.AccessController.doPrivileged(\n-            (java.security.PrivilegedAction<Field>) () -> {\n-                try {\n-                    Field f = ConcurrentSkipListSet.class\n-                        .getDeclaredField(\"m\");\n-                    f.setAccessible(true);\n-                    return f;\n-                } catch (ReflectiveOperationException e) {\n-                    throw new Error(e);\n-                }});\n@@ -542,0 +531,2 @@\n+            Field mapField = ConcurrentSkipListSet.class.getDeclaredField(\"m\");\n+            mapField.setAccessible(true);\n@@ -543,1 +534,1 @@\n-        } catch (IllegalAccessException e) {\n+        } catch (IllegalAccessException | NoSuchFieldException e) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentSkipListSet.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2099,11 +2099,0 @@\n-        @SuppressWarnings(\"removal\")\n-        Field lockField = java.security.AccessController.doPrivileged(\n-            (java.security.PrivilegedAction<Field>) () -> {\n-                try {\n-                    Field f = CopyOnWriteArrayList.class\n-                        .getDeclaredField(\"lock\");\n-                    f.setAccessible(true);\n-                    return f;\n-                } catch (ReflectiveOperationException e) {\n-                    throw new Error(e);\n-                }});\n@@ -2111,0 +2100,2 @@\n+            Field lockField = CopyOnWriteArrayList.class.getDeclaredField(\"lock\");\n+            lockField.setAccessible(true);\n@@ -2112,1 +2103,1 @@\n-        } catch (IllegalAccessException e) {\n+        } catch (IllegalAccessException | NoSuchFieldException e) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArrayList.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -43,1 +41,0 @@\n-import java.security.PrivilegedActionException;\n@@ -49,1 +46,0 @@\n-import sun.security.util.SecurityConstants;\n@@ -562,2 +558,0 @@\n-        @SuppressWarnings(\"removal\")\n-        final AccessControlContext acc;\n@@ -565,1 +559,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -568,1 +561,0 @@\n-            this.acc = AccessController.getContext();\n@@ -571,1 +563,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -573,10 +564,1 @@\n-            try {\n-                return AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<T>() {\n-                        public T run() throws Exception {\n-                            return task.call();\n-                        }\n-                    }, acc);\n-            } catch (PrivilegedActionException e) {\n-                throw e.getException();\n-            }\n+            return task.call();\n@@ -598,1 +580,0 @@\n-        final AccessControlContext acc;\n@@ -603,11 +584,0 @@\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                \/\/ Calls to getContextClassLoader from this class\n-                \/\/ never trigger a security check, but we check\n-                \/\/ whether our callers have this permission anyways.\n-                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-\n-                \/\/ Whether setContextClassLoader turns out to be necessary\n-                \/\/ or not, we fail fast if permission is not available.\n-                sm.checkPermission(new RuntimePermission(\"setContextClassLoader\"));\n-            }\n@@ -615,1 +585,0 @@\n-            this.acc = AccessController.getContext();\n@@ -619,1 +588,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -621,20 +589,11 @@\n-            try {\n-                return AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<T>() {\n-                        public T run() throws Exception {\n-                            Thread t = Thread.currentThread();\n-                            ClassLoader cl = t.getContextClassLoader();\n-                            if (ccl == cl) {\n-                                return task.call();\n-                            } else {\n-                                t.setContextClassLoader(ccl);\n-                                try {\n-                                    return task.call();\n-                                } finally {\n-                                    t.setContextClassLoader(cl);\n-                                }\n-                            }\n-                        }\n-                    }, acc);\n-            } catch (PrivilegedActionException e) {\n-                throw e.getException();\n+            Thread t = Thread.currentThread();\n+            ClassLoader cl = t.getContextClassLoader();\n+            if (ccl == cl) {\n+                return task.call();\n+            } else {\n+                t.setContextClassLoader(ccl);\n+                try {\n+                    return task.call();\n+                } finally {\n+                    t.setContextClassLoader(cl);\n+                }\n@@ -659,4 +618,1 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager s = System.getSecurityManager();\n-            group = (s != null) ? s.getThreadGroup() :\n-                                  Thread.currentThread().getThreadGroup();\n+            group = Thread.currentThread().getThreadGroup();\n@@ -681,1 +637,1 @@\n-     * Thread factory capturing access control context and class loader.\n+     * Thread factory capturing the current class loader.\n@@ -685,1 +641,0 @@\n-        final AccessControlContext acc;\n@@ -688,1 +643,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -691,11 +645,0 @@\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                \/\/ Calls to getContextClassLoader from this class\n-                \/\/ never trigger a security check, but we check\n-                \/\/ whether our callers have this permission anyways.\n-                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-\n-                \/\/ Fail fast\n-                sm.checkPermission(new RuntimePermission(\"setContextClassLoader\"));\n-            }\n-            this.acc = AccessController.getContext();\n@@ -709,7 +652,2 @@\n-                    AccessController.doPrivileged(new PrivilegedAction<>() {\n-                        public Void run() {\n-                            Thread.currentThread().setContextClassLoader(ccl);\n-                            r.run();\n-                            return null;\n-                        }\n-                    }, acc);\n+                    Thread.currentThread().setContextClassLoader(ccl);\n+                    r.run();\n@@ -814,3 +752,1 @@\n-                    PrivilegedAction<Void> pa = () -> { executor.shutdown(); return null; };\n-                    @SuppressWarnings(\"removal\")\n-                    var ignore = AccessController.doPrivileged(pa);\n+                    executor.shutdown();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Executors.java","additions":17,"deletions":81,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -691,1 +689,1 @@\n-    private void implInterruptAll() {\n+    private void interruptAll() {\n@@ -701,13 +699,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private void interruptAll() {\n-        if (System.getSecurityManager() == null) {\n-            implInterruptAll();\n-        } else {\n-            PrivilegedAction<Void> pa = () -> {\n-                implInterruptAll();\n-                return null;\n-            };\n-            AccessController.doPrivileged(pa);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.security.AccessControlContext;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.Permission;\n@@ -51,1 +50,0 @@\n-    private static final Permission MODIFY_THREAD = new RuntimePermission(\"modifyThread\");\n@@ -83,12 +81,0 @@\n-    \/**\n-     * Throws SecurityException if there is a security manager set and it denies\n-     * RuntimePermission(\"modifyThread\").\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private void checkPermission() {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(MODIFY_THREAD);\n-        }\n-    }\n-\n@@ -146,1 +132,0 @@\n-        checkPermission();\n@@ -153,1 +138,0 @@\n-        checkPermission();\n@@ -205,1 +189,0 @@\n-        checkPermission();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadPerTaskExecutor.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -569,23 +569,0 @@\n-    \/**\n-     * Permission required for callers of shutdown and shutdownNow.\n-     * We additionally require (see checkShutdownAccess) that callers\n-     * have permission to actually interrupt threads in the worker set\n-     * (as governed by Thread.interrupt, which relies on\n-     * ThreadGroup.checkAccess, which in turn relies on\n-     * SecurityManager.checkAccess). Shutdowns are attempted only if\n-     * these checks pass.\n-     *\n-     * All actual invocations of Thread.interrupt (see\n-     * interruptIdleWorkers and interruptWorkers) ignore\n-     * SecurityExceptions, meaning that the attempted interrupts\n-     * silently fail. In the case of shutdown, they should not fail\n-     * unless the SecurityManager has inconsistent policies, sometimes\n-     * allowing access to a thread and sometimes not. In such cases,\n-     * failure to actually interrupt threads may disable or delay full\n-     * termination. Other uses of interruptIdleWorkers are advisory,\n-     * and failure to actually interrupt will merely delay response to\n-     * configuration changes so is not handled exceptionally.\n-     *\/\n-    private static final RuntimePermission shutdownPerm =\n-        new RuntimePermission(\"modifyThread\");\n-\n@@ -676,4 +653,1 @@\n-                try {\n-                    t.interrupt();\n-                } catch (SecurityException ignore) {\n-                }\n+                t.interrupt();\n@@ -752,21 +726,1 @@\n-     * If there is a security manager, makes sure caller has\n-     * permission to shut down threads in general (see shutdownPerm).\n-     * If this passes, additionally makes sure the caller is allowed\n-     * to interrupt each worker thread. This might not be true even if\n-     * first check passed, if the SecurityManager treats some threads\n-     * specially.\n-     *\/\n-    private void checkShutdownAccess() {\n-        \/\/ assert mainLock.isHeldByCurrentThread();\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(shutdownPerm);\n-            for (Worker w : workers)\n-                security.checkAccess(w.thread);\n-        }\n-    }\n-\n-    \/**\n-     * Interrupts all threads, even if active. Ignores SecurityExceptions\n-     * (in which case some threads may remain uninterrupted).\n+     * Interrupts all threads, even if active.\n@@ -783,3 +737,1 @@\n-     * termination or configuration changes. Ignores\n-     * SecurityExceptions (in which case some threads may remain\n-     * uninterrupted).\n+     * termination or configuration changes.\n@@ -808,1 +760,0 @@\n-                    } catch (SecurityException ignore) {\n@@ -1393,1 +1344,0 @@\n-            checkShutdownAccess();\n@@ -1423,1 +1373,0 @@\n-            checkShutdownAccess();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadPoolExecutor.java","additions":3,"deletions":54,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -388,1 +385,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -395,6 +391,1 @@\n-                field = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Field>() {\n-                        public Field run() throws NoSuchFieldException {\n-                            return tclass.getDeclaredField(fieldName);\n-                        }\n-                    });\n+                field = tclass.getDeclaredField(fieldName);\n@@ -404,8 +395,0 @@\n-                ClassLoader cl = tclass.getClassLoader();\n-                ClassLoader ccl = caller.getClassLoader();\n-                if ((ccl != null) && (ccl != cl) &&\n-                    ((cl == null) || !isAncestor(cl, ccl))) {\n-                    sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);\n-                }\n-            } catch (PrivilegedActionException pae) {\n-                throw new RuntimeException(pae.getException());\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -384,1 +381,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -390,6 +386,1 @@\n-                field = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Field>() {\n-                        public Field run() throws NoSuchFieldException {\n-                            return tclass.getDeclaredField(fieldName);\n-                        }\n-                    });\n+                field = tclass.getDeclaredField(fieldName);\n@@ -399,8 +390,0 @@\n-                ClassLoader cl = tclass.getClassLoader();\n-                ClassLoader ccl = caller.getClassLoader();\n-                if ((ccl != null) && (ccl != cl) &&\n-                    ((cl == null) || !isAncestor(cl, ccl))) {\n-                    sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);\n-                }\n-            } catch (PrivilegedActionException pae) {\n-                throw new RuntimeException(pae.getException());\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -332,11 +332,0 @@\n-        @SuppressWarnings(\"removal\")\n-        Field arrayField = java.security.AccessController.doPrivileged(\n-            (java.security.PrivilegedAction<Field>) () -> {\n-                try {\n-                    Field f = AtomicReferenceArray.class\n-                        .getDeclaredField(\"array\");\n-                    f.setAccessible(true);\n-                    return f;\n-                } catch (ReflectiveOperationException e) {\n-                    throw new Error(e);\n-                }});\n@@ -344,0 +333,3 @@\n+\n+            Field arrayField = AtomicReferenceArray.class.getDeclaredField(\"array\");\n+            arrayField.setAccessible(true);\n@@ -345,1 +337,1 @@\n-        } catch (IllegalAccessException e) {\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceArray.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -323,1 +320,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -332,6 +328,1 @@\n-                field = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Field>() {\n-                        public Field run() throws NoSuchFieldException {\n-                            return tclass.getDeclaredField(fieldName);\n-                        }\n-                    });\n+                field = tclass.getDeclaredField(fieldName);\n@@ -341,6 +332,0 @@\n-                ClassLoader cl = tclass.getClassLoader();\n-                ClassLoader ccl = caller.getClassLoader();\n-                if ((ccl != null) && (ccl != cl) &&\n-                    ((cl == null) || !isAncestor(cl, ccl))) {\n-                    sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);\n-                }\n@@ -348,2 +333,0 @@\n-            } catch (PrivilegedActionException pae) {\n-                throw new RuntimeException(pae.getException());\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -383,11 +383,6 @@\n-            @SuppressWarnings(\"removal\")\n-        MethodHandles.Lookup l2 = java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<>() {\n-                        public MethodHandles.Lookup run() {\n-                            try {\n-                                return MethodHandles.privateLookupIn(Thread.class, MethodHandles.lookup());\n-                            } catch (ReflectiveOperationException e) {\n-                                throw new ExceptionInInitializerError(e);\n-                            }\n-                        }});\n-        THREAD_PROBE = MhUtil.findVarHandle(l2, \"threadLocalRandomProbe\", int.class);\n+        try {\n+            MethodHandles.Lookup l2 = MethodHandles.privateLookupIn(Thread.class, l1);\n+            THREAD_PROBE = MhUtil.findVarHandle(l2, \"threadLocalRandomProbe\", int.class);\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"}]}