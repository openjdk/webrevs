{"files":[{"patch":"@@ -459,0 +459,4 @@\n+        return syntaxError(pos, errs, errorKey, false);\n+    }\n+\n+    private JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey, boolean noEofError) {\n@@ -461,1 +465,1 @@\n-        reportSyntaxError(err, errorKey);\n+        reportSyntaxError(err, errorKey, noEofError);\n@@ -488,0 +492,4 @@\n+        reportSyntaxError(diagPos, errorKey, false);\n+    }\n+\n+    private void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey, boolean noEofError) {\n@@ -490,1 +498,1 @@\n-            if (token.kind == EOF) {\n+            if (token.kind == EOF && !noEofError) {\n@@ -4095,0 +4103,7 @@\n+                } else if (isDefiniteStatementStartToken()) {\n+                    int startPos = token.pos;\n+                    List<JCStatement> statements = blockStatement();\n+                    defs.append(syntaxError(startPos,\n+                                            statements,\n+                                            Errors.StatementNotExpected,\n+                                            true));\n@@ -4327,0 +4342,3 @@\n+            } else if (Feature.IMPLICIT_CLASSES.allowedInSource(source) &&\n+                       (!preview.isPreview(Feature.IMPLICIT_CLASSES) || preview.isEnabled())) {\n+                error = Errors.ClassMethodOrFieldExpected;\n@@ -4909,0 +4927,6 @@\n+        } else if (token.kind == LPAREN && type.hasTag(IDENT)) {\n+            log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    false, true, false, dc));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1622,0 +1622,3 @@\n+compiler.err.class.method.or.field.expected=\\\n+    class, interface, annotation type, enum, record, method or field expected\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8338301\n+ * @summary Verify error recovery and reporting related to implicitly declared classes\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ErrorRecovery\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+import toolbox.ToolBox;\n+\n+public class ErrorRecovery extends TestRunner {\n+\n+    private static final String SOURCE_VERSION = System.getProperty(\"java.specification.version\");\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ErrorRecovery().runTests();\n+    }\n+\n+    ErrorRecovery() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testMethodNoReturnType(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     main() {}\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log = new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(OutputKind.DIRECT);\n+        List<String> expected = List.of(\n+            \"Test.java:1:1: compiler.err.invalid.meth.decl.ret.type.req\",\n+            \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+            \"- compiler.note.preview.recompile\",\n+            \"1 error\"\n+        );\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+    @Test\n+    public void testStatement(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     if (true) {int var = 0;}\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log = new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(OutputKind.DIRECT);\n+        List<String> expected = List.of(\n+            \"Test.java:1:1: compiler.err.statement.not.expected\",\n+            \"1 error\"\n+        );\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+    @Test\n+    public void testExtraSemi(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     class C {};\n+                     void main() {};\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+    }\n+\n+    @Test\n+    public void testVeryBroken(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     \"neither-of-class-method-file-statement\"\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log;\n+        List<String> expected;\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                        \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.class.method.or.field.expected\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.expected4: class, interface, enum, record\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                         \"--release\", \"17\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.expected4: class, interface, enum, record\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ErrorRecovery.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.class.method.or.field.expected\n+\/\/ options: --enable-preview --source ${jdk.version}\n+\n+\"neither-of-class-method-file-statement\"\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ClassMethodOrFieldExpected.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"}]}