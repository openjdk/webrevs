{"files":[{"patch":"@@ -228,0 +228,12 @@\n+MulNode* MulNode::make_and(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new AndINode(in1, in2);\n+    case T_LONG:\n+      return new AndLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n+}\n+\n@@ -950,1 +962,1 @@\n-static int maskShiftAmount(PhaseGVN* phase, Node* shiftNode, int nBits) {\n+static int maskShiftAmount(PhaseGVN* phase, Node* shiftNode, uint nBits) {\n@@ -1322,3 +1334,28 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* RShiftINode::Identity(PhaseGVN* phase) {\n+Node* RShiftNode::IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n+  \/\/ Inputs may be TOP if they are dead.\n+  const TypeInteger* t1 = phase->type(in(1))->isa_integer(bt);\n+  if (t1 == nullptr) {\n+    return NodeSentinel;        \/\/ Left input is an integer\n+  }\n+  int shift = maskShiftAmount(phase, this, bits_per_java_integer(bt));\n+  if (shift == 0) {\n+    return NodeSentinel;\n+  }\n+\n+  \/\/ Check for (x & 0xFF000000) >> 24, whose mask can be made smaller.\n+  \/\/ and convert to (x >> 24) & (0xFF000000 >> 24) = x >> 24\n+  \/\/ Such expressions arise normally from shift chains like (byte)(x >> 24).\n+  const TypeInteger* mask_t;\n+  const Node* and_node = in(1);\n+  if (and_node->Opcode() == Op_And(bt) &&\n+      (mask_t = phase->type(and_node->in(2))->isa_integer(bt)) &&\n+      mask_t->is_con()) {\n+    jlong maskbits = mask_t->get_con_as_long(bt);\n+    \/\/ Convert to \"(x >> shift) & (mask >> shift)\"\n+    Node* shr_nomask = phase->transform(RShiftNode::make(and_node->in(1), in(2), bt));\n+    return MulNode::make_and(shr_nomask, phase->integercon(maskbits >> shift, bt), bt);\n+  }\n+  return nullptr;\n+}\n+\n+Node* RShiftNode::IdentityIL(PhaseGVN* phase, BasicType bt) {\n@@ -1327,2 +1364,2 @@\n-    if ((count & (BitsPerJavaInteger - 1)) == 0) {\n-      \/\/ Shift by a multiple of 32 does nothing\n+    if ((count & (bits_per_java_integer(bt) - 1)) == 0) {\n+      \/\/ Shift by a multiple of 32\/64 does nothing\n@@ -1332,1 +1369,1 @@\n-    if (in(1)->Opcode() == Op_LShiftI &&\n+    if (in(1)->Opcode() == Op_LShift(bt) &&\n@@ -1335,1 +1372,1 @@\n-      count &= BitsPerJavaInteger-1; \/\/ semantics of Java shifts\n+      count &= bits_per_java_integer(bt)-1; \/\/ semantics of Java shifts\n@@ -1337,3 +1374,3 @@\n-      int lo = (-1 << (BitsPerJavaInteger - ((uint)count)-1)); \/\/ FFFF8000\n-      int hi = ~lo;               \/\/ 00007FFF\n-      const TypeInt* t11 = phase->type(in(1)->in(1))->isa_int();\n+      jlong lo = (-1 << (bits_per_java_integer(bt) - ((uint)count)-1)); \/\/ FFFF8000\n+      jlong hi = ~lo;               \/\/ 00007FFF\n+      const TypeInteger* t11 = phase->type(in(1)->in(1))->isa_integer(bt);\n@@ -1344,1 +1381,1 @@\n-      if (lo <= t11->_lo && t11->_hi <= hi) {\n+      if (lo <= t11->lo_as_long() && t11->hi_as_long() <= hi) {\n@@ -1352,70 +1389,3 @@\n-\/\/------------------------------Ideal------------------------------------------\n-Node *RShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Inputs may be TOP if they are dead.\n-  const TypeInt *t1 = phase->type(in(1))->isa_int();\n-  if (!t1) return nullptr;        \/\/ Left input is an integer\n-  const TypeInt *t3;  \/\/ type of in(1).in(2)\n-  int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);\n-  if (shift == 0) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Check for (x & 0xFF000000) >> 24, whose mask can be made smaller.\n-  \/\/ Such expressions arise normally from shift chains like (byte)(x >> 24).\n-  const Node *mask = in(1);\n-  if( mask->Opcode() == Op_AndI &&\n-      (t3 = phase->type(mask->in(2))->isa_int()) &&\n-      t3->is_con() ) {\n-    Node *x = mask->in(1);\n-    jint maskbits = t3->get_con();\n-    \/\/ Convert to \"(x >> shift) & (mask >> shift)\"\n-    Node *shr_nomask = phase->transform( new RShiftINode(mask->in(1), in(2)) );\n-    return new AndINode(shr_nomask, phase->intcon( maskbits >> shift));\n-  }\n-\n-  \/\/ Check for \"(short[i] <<16)>>16\" which simply sign-extends\n-  const Node *shl = in(1);\n-  if( shl->Opcode() != Op_LShiftI ) return nullptr;\n-\n-  if( shift == 16 &&\n-      (t3 = phase->type(shl->in(2))->isa_int()) &&\n-      t3->is_con(16) ) {\n-    Node *ld = shl->in(1);\n-    if( ld->Opcode() == Op_LoadS ) {\n-      \/\/ Sign extension is just useless here.  Return a RShiftI of zero instead\n-      \/\/ returning 'ld' directly.  We cannot return an old Node directly as\n-      \/\/ that is the job of 'Identity' calls and Identity calls only work on\n-      \/\/ direct inputs ('ld' is an extra Node removed from 'this').  The\n-      \/\/ combined optimization requires Identity only return direct inputs.\n-      set_req_X(1, ld, phase);\n-      set_req_X(2, phase->intcon(0), phase);\n-      return this;\n-    }\n-    else if (can_reshape &&\n-             ld->Opcode() == Op_LoadUS &&\n-             ld->outcnt() == 1 && ld->unique_out() == shl)\n-      \/\/ Replace zero-extension-load with sign-extension-load\n-      return ld->as_Load()->convert_to_signed_load(*phase);\n-  }\n-\n-  \/\/ Check for \"(byte[i] <<24)>>24\" which simply sign-extends\n-  if( shift == 24 &&\n-      (t3 = phase->type(shl->in(2))->isa_int()) &&\n-      t3->is_con(24) ) {\n-    Node *ld = shl->in(1);\n-    if (ld->Opcode() == Op_LoadB) {\n-      \/\/ Sign extension is just useless here\n-      set_req_X(1, ld, phase);\n-      set_req_X(2, phase->intcon(0), phase);\n-      return this;\n-    }\n-  }\n-\n-  return nullptr;\n-}\n-\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A RShiftINode shifts its input2 right by input1 amount.\n-const Type* RShiftINode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n+const Type* RShiftNode::ValueIL(PhaseGVN* phase, BasicType bt) const {\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n@@ -1423,2 +1393,2 @@\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  if (t1 == Type::TOP) return Type::TOP;\n+  if (t2 == Type::TOP) return Type::TOP;\n@@ -1427,1 +1397,1 @@\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n+  if (t1 == TypeInteger::zero(bt)) return TypeInteger::zero(bt);\n@@ -1429,1 +1399,1 @@\n-  if( t2 == TypeInt::ZERO ) return t1;\n+  if (t2 == TypeInt::ZERO) return t1;\n@@ -1432,2 +1402,3 @@\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeInt::INT;\n+  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM) {\n+    return TypeInteger::bottom(bt);\n+  }\n@@ -1435,2 +1406,2 @@\n-  const TypeInt *r1 = t1->is_int(); \/\/ Handy access\n-  const TypeInt *r2 = t2->is_int(); \/\/ Handy access\n+  const TypeInteger* r1 = t1->isa_integer(bt);\n+  const TypeInt* r2 = t2->isa_int();\n@@ -1439,1 +1410,1 @@\n-  \/\/ For example, if the shift is 31, we just propagate sign bits.\n+  \/\/ For example, if the shift is 31\/63, we just propagate sign bits.\n@@ -1442,2 +1413,2 @@\n-    shift &= BitsPerJavaInteger-1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 32 does nothing:\n+    shift &= bits_per_java_integer(bt)-1;  \/\/ semantics of Java shifts\n+    \/\/ Shift by a multiple of 32\/64 does nothing:\n@@ -1448,2 +1419,2 @@\n-    jint lo = (jint)r1->_lo >> (jint)shift;\n-    jint hi = (jint)r1->_hi >> (jint)shift;\n+    jlong lo = r1->lo_as_long() >> (jint)shift;\n+    jlong hi = r1->hi_as_long() >> (jint)shift;\n@@ -1451,1 +1422,8 @@\n-    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+#ifdef ASSERT\n+   if (bt == T_INT) {\n+     jint lo_verify = checked_cast<jint>(r1->lo_as_long()) >> (jint)shift;\n+     jint hi_verify = checked_cast<jint>(r1->hi_as_long()) >> (jint)shift;\n+     assert((checked_cast<jint>(lo) == lo_verify) && (checked_cast<jint>(hi) == hi_verify), \"inconsistent\");\n+   }\n+#endif\n+    const TypeInteger* ti = TypeInteger::make(lo, hi, MAX2(r1->_widen,r2->_widen), bt);\n@@ -1454,3 +1432,3 @@\n-    if (shift == BitsPerJavaInteger-1) {\n-      if (r1->_lo >= 0) assert(ti == TypeInt::ZERO,    \">>31 of + is  0\");\n-      if (r1->_hi <  0) assert(ti == TypeInt::MINUS_1, \">>31 of - is -1\");\n+    if (shift == bits_per_java_integer(bt)-1) {\n+      if (r1->lo_as_long() >= 0) assert(ti == TypeInteger::zero(bt),    \">>31\/63 of + is  0\");\n+      if (r1->hi_as_long() <  0) assert(ti == TypeInteger::minus_1(bt), \">>31\/63 of - is -1\");\n@@ -1464,2 +1442,2 @@\n-    if (r1->_lo >= 0) {\n-      return TypeInt::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n+    if (r1->lo_as_long() >= 0) {\n+      return TypeInteger::make(0, r1->hi_as_long(), MAX2(r1->_widen, r2->_widen), bt);\n@@ -1469,2 +1447,2 @@\n-    if (r1->_hi <= -1) {\n-      return TypeInt::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n+    if (r1->hi_as_long() <= -1) {\n+      return TypeInteger::make(r1->lo_as_long(), -1, MAX2(r1->_widen, r2->_widen), bt);\n@@ -1473,1 +1451,1 @@\n-    return TypeInt::INT;\n+    return TypeInteger::bottom(bt);\n@@ -1477,1 +1455,1 @@\n-  return TypeInt::make(r1->get_con() >> (r2->get_con() & 31));\n+  return TypeInteger::make(r1->get_con_as_long(bt) >> (r2->get_con() & (bits_per_java_integer(bt) - 1)), bt);\n@@ -1480,5 +1458,10 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* RShiftLNode::Identity(PhaseGVN* phase) {\n-  const TypeInt *ti = phase->type(in(2))->isa_int(); \/\/ Shift count is an int.\n-  return (ti && ti->is_con() && (ti->get_con() & (BitsPerJavaLong - 1)) == 0) ? in(1) : this;\n+RShiftNode* RShiftNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new RShiftINode(in1, in2);\n+    case T_LONG:\n+      return new RShiftLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n@@ -1487,8 +1470,0 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A RShiftLNode shifts its input2 right by input1 amount.\n-const Type* RShiftLNode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n@@ -1496,4 +1471,5 @@\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n+Node* RShiftINode::Identity(PhaseGVN* phase) {\n+  return IdentityIL(phase, T_INT);\n+}\n@@ -1501,3 +1477,11 @@\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeLong::LONG;\n+\/\/------------------------------Ideal------------------------------------------\n+Node *RShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  Node* progress = IdealIL(phase, can_reshape, T_INT);\n+  if (progress == NodeSentinel) {\n+    return nullptr;\n+  }\n+  if (progress != nullptr) {\n+    return progress;\n+  }\n+  int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);\n+  assert(shift != 0, \"handled by IdealIL\");\n@@ -1505,2 +1489,5 @@\n-  const TypeLong *r1 = t1->is_long(); \/\/ Handy access\n-  const TypeInt  *r2 = t2->is_int (); \/\/ Handy access\n+  \/\/ Check for \"(short[i] <<16)>>16\" which simply sign-extends\n+  const Node *shl = in(1);\n+  if (shl->Opcode() != Op_LShiftI) {\n+    return nullptr;\n+  }\n@@ -1508,19 +1495,14 @@\n-  \/\/ If the shift is a constant, just shift the bounds of the type.\n-  \/\/ For example, if the shift is 63, we just propagate sign bits.\n-  if (!r1->is_con() && r2->is_con()) {\n-    uint shift = r2->get_con();\n-    shift &= (2*BitsPerJavaInteger)-1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 64 does nothing:\n-    if (shift == 0)  return t1;\n-    \/\/ Calculate reasonably aggressive bounds for the result.\n-    \/\/ This is necessary if we are to correctly type things\n-    \/\/ like (x<<24>>24) == ((byte)x).\n-    jlong lo = (jlong)r1->_lo >> (jlong)shift;\n-    jlong hi = (jlong)r1->_hi >> (jlong)shift;\n-    assert(lo <= hi, \"must have valid bounds\");\n-    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n-    #ifdef ASSERT\n-    \/\/ Make sure we get the sign-capture idiom correct.\n-    if (shift == (2*BitsPerJavaInteger)-1) {\n-      if (r1->_lo >= 0) assert(tl == TypeLong::ZERO,    \">>63 of + is 0\");\n-      if (r1->_hi < 0)  assert(tl == TypeLong::MINUS_1, \">>63 of - is -1\");\n+  const TypeInt* left_shift_t;\n+  if (shift == 16 &&\n+      (left_shift_t = phase->type(shl->in(2))->isa_int()) &&\n+      left_shift_t->is_con(16)) {\n+    Node *ld = shl->in(1);\n+    if (ld->Opcode() == Op_LoadS) {\n+      \/\/ Sign extension is just useless here.  Return a RShiftI of zero instead\n+      \/\/ returning 'ld' directly.  We cannot return an old Node directly as\n+      \/\/ that is the job of 'Identity' calls and Identity calls only work on\n+      \/\/ direct inputs ('ld' is an extra Node removed from 'this').  The\n+      \/\/ combined optimization requires Identity only return direct inputs.\n+      set_req_X(1, ld, phase);\n+      set_req_X(2, phase->intcon(0), phase);\n+      return this;\n@@ -1528,2 +1510,5 @@\n-    #endif\n-    return tl;\n+    else if (can_reshape &&\n+             ld->Opcode() == Op_LoadUS &&\n+             ld->outcnt() == 1 && ld->unique_out() == shl)\n+      \/\/ Replace zero-extension-load with sign-extension-load\n+      return ld->as_Load()->convert_to_signed_load(*phase);\n@@ -1532,4 +1517,10 @@\n-  if (!r1->is_con() || !r2->is_con()) {\n-    \/\/ If the left input is non-negative the result must also be non-negative, regardless of what the right input is.\n-    if (r1->_lo >= 0) {\n-      return TypeLong::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n+  \/\/ Check for \"(byte[i] <<24)>>24\" which simply sign-extends\n+  if (shift == 24 &&\n+      (left_shift_t = phase->type(shl->in(2))->isa_int()) &&\n+      left_shift_t->is_con(24)) {\n+    Node *ld = shl->in(1);\n+    if (ld->Opcode() == Op_LoadB) {\n+      \/\/ Sign extension is just useless here\n+      set_req_X(1, ld, phase);\n+      set_req_X(2, phase->intcon(0), phase);\n+      return this;\n@@ -1537,0 +1528,1 @@\n+  }\n@@ -1538,4 +1530,2 @@\n-    \/\/ Conversely, if the left input is negative then the result must be negative.\n-    if (r1->_hi <= -1) {\n-      return TypeLong::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n-    }\n+  return nullptr;\n+}\n@@ -1543,1 +1533,14 @@\n-    return TypeLong::LONG;\n+const Type* RShiftINode::Value(PhaseGVN* phase) const {\n+  return ValueIL(phase, T_INT);\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n+Node* RShiftLNode::Identity(PhaseGVN* phase) {\n+  return IdentityIL(phase, T_LONG);\n+}\n+\n+Node* RShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  Node* progress = IdealIL(phase, can_reshape, T_LONG);\n+  if (progress == NodeSentinel) {\n+    return nullptr;\n@@ -1545,0 +1548,2 @@\n+  return progress;\n+}\n@@ -1546,1 +1551,2 @@\n-  return TypeLong::make(r1->get_con() >> (r2->get_con() & 63));\n+const Type* RShiftLNode::Value(PhaseGVN* phase) const {\n+  return ValueIL(phase, T_LONG);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":164,"deletions":158,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  static MulNode* make_and(Node* in1, Node* in2, BasicType bt);\n@@ -321,0 +322,10 @@\n+\n+class RShiftNode : public Node {\n+public:\n+  RShiftNode(Node* in1, Node* in2) : Node(nullptr,in1,in2) {}\n+  Node* IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt);\n+  Node* IdentityIL(PhaseGVN* phase, BasicType bt);\n+  const Type* ValueIL(PhaseGVN* phase, BasicType bt) const;\n+  static RShiftNode* make(Node* in1, Node* in2, BasicType bt);\n+};\n+\n@@ -323,1 +334,1 @@\n-class RShiftINode : public Node {\n+class RShiftINode : public RShiftNode {\n@@ -325,1 +336,1 @@\n-  RShiftINode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n+  RShiftINode(Node* in1, Node* in2) : RShiftNode(in1,in2) {}\n@@ -328,1 +339,2 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -330,1 +342,2 @@\n-  const Type *bottom_type() const { return TypeInt::INT; }\n+\n+  const Type* bottom_type() const { return TypeInt::INT; }\n@@ -336,1 +349,1 @@\n-class RShiftLNode : public Node {\n+class RShiftLNode : public RShiftNode {\n@@ -338,1 +351,1 @@\n-  RShiftLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n+  RShiftLNode(Node* in1, Node* in2) : RShiftNode(in1,in2) {}\n@@ -341,0 +354,2 @@\n+  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n+\n@@ -342,1 +357,1 @@\n-  const Type *bottom_type() const { return TypeLong::LONG; }\n+  const Type* bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2063,0 +2063,1 @@\n+Op_IL(And)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1702,0 +1702,4 @@\n+const TypeInteger* TypeInteger::make(jlong lo, BasicType bt) {\n+  return make(lo, lo, WidenMin, bt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -610,0 +610,1 @@\n+  static const TypeInteger* make(jlong lo, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -800,0 +800,8 @@\n+inline uint bits_per_java_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return BitsPerJavaInteger;\n+  }\n+  assert(bt == T_LONG, \"int or long only\");\n+  return BitsPerJavaLong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n@@ -59,0 +59,4 @@\n+        assertResult(test7Min, b);\n+        assertResult(test7Max, b);\n+        assertResult(test7Min-1, b);\n+        assertResult(test7Max+1, b);\n@@ -67,0 +71,8 @@\n+        Asserts.assertEQ((x & test5Mask) >> test5Shift, test5(x));\n+        Asserts.assertEQ(x, test6(x));\n+        int x7 = Integer.max(Integer.min(x, test7Max), test7Min);\n+        Asserts.assertEQ(((x7 << test7Shift) >> test7Shift), test7(x));\n+        int x8 = Integer.max(Integer.min(x, test7Max+1), test7Min);\n+        Asserts.assertEQ((x8 << test7Shift) >> test7Shift, test8(x));\n+        int x9 = Integer.max(Integer.min(x, test7Max), test7Min-1);\n+        Asserts.assertEQ((x9 << test7Shift) >> test7Shift, test9(x));\n@@ -92,0 +104,43 @@\n+\n+    final static int test5Shift = RunInfo.getRandom().nextInt(32);\n+    final static int test5Mask = -1 << test5Shift;\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_I, \"1\" })\n+    @IR(failOn = { IRNode.AND_I })\n+    public int test5(int x) {\n+        return (x & test5Mask) >> test5Shift;\n+    }\n+\n+    final static int test6Shift = RunInfo.getRandom().nextInt(Integer.MAX_VALUE \/ 32) * 32 ;\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT_I })\n+    public int test6(int x) {\n+        return (x >> test6Shift);\n+    }\n+\n+    final static int test7Shift = RunInfo.getRandom().nextInt(32);\n+    final static int test7Min = -1 << (32 - test7Shift -1);\n+    final static int test7Max = ~test7Min;\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT_I, IRNode.LSHIFT_I })\n+    public int test7(int x) {\n+        x = Integer.max(Integer.min(x, test7Max), test7Min);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    public int test8(int x) {\n+        x = Integer.max(Integer.min(x, test7Max+1), test7Min);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    public int test9(int x) {\n+        x = Integer.max(Integer.min(x, test7Max), test7Min-1);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftINodeIdealizationTests.java","additions":56,"deletions":1,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @bug 8320330\n+ * @bug 8320330 8349361\n@@ -40,1 +40,1 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n@@ -59,0 +59,4 @@\n+        assertResult(test7Min, b);\n+        assertResult(test7Max, b);\n+        assertResult(test7Min-1, b);\n+        assertResult(test7Max+1, b);\n@@ -67,0 +71,8 @@\n+        Asserts.assertEQ((x & test5Mask) >> test5Shift, test5(x));\n+        Asserts.assertEQ(x, test6(x));\n+        long x7 = Integer.max(Integer.min((int)x, (int)test7Max), (int)test7Min);\n+        Asserts.assertEQ(((x7 << test7Shift) >> test7Shift), test7(x));\n+        long x8 = Integer.max(Integer.min((int)x, (int)(test7Max+1)), (int)test7Min);\n+        Asserts.assertEQ((x8 << test7Shift) >> test7Shift, test8(x));\n+        long x9 = Integer.max(Integer.min((int)x, (int)test7Max), (int)(test7Min-1));\n+        Asserts.assertEQ((x9 << test7Shift) >> test7Shift, test9(x));\n@@ -92,0 +104,43 @@\n+\n+    final static int test5Shift = RunInfo.getRandom().nextInt(64);\n+    final static long test5Mask = -1L << test5Shift;\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_L, \"1\" })\n+    @IR(failOn = { IRNode.AND_L })\n+    public long test5(long x) {\n+        return (x & test5Mask) >> test5Shift;\n+    }\n+\n+    final static int test6Shift = RunInfo.getRandom().nextInt(Integer.MAX_VALUE \/ 64) * 64 ;\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT_L })\n+    public long test6(long x) {\n+        return (x >> test6Shift);\n+    }\n+\n+    final static int test7Shift = RunInfo.getRandom().nextInt(32) + 32;\n+    final static long test7Min = -1L << (64 - test7Shift -1);\n+    final static long test7Max = ~test7Min;\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT_L, IRNode.LSHIFT_L })\n+    public long test7(long x) {\n+        x = Integer.max(Integer.min((int)x, (int)test7Max), (int)test7Min);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_L, \"1\", IRNode.LSHIFT_L, \"1\" })\n+    public long test8(long x) {\n+        x = Integer.max(Integer.min((int)x, (int)(test7Max+1)), (int)test7Min);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_L, \"1\", IRNode.LSHIFT_L, \"1\" })\n+    public long test9(long x) {\n+        x = Integer.max(Integer.min((int)x, (int)test7Max), (int)(test7Min-1));\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftLNodeIdealizationTests.java","additions":57,"deletions":2,"binary":false,"changes":59,"status":"modified"}]}