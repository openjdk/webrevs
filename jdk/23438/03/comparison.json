{"files":[{"patch":"@@ -226,0 +226,12 @@\n+MulNode* MulNode::make_and(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new AndINode(in1, in2);\n+    case T_LONG:\n+      return new AndLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n+}\n+\n@@ -927,1 +939,1 @@\n-static int maskShiftAmount(PhaseGVN* phase, Node* shiftNode, int nBits) {\n+static int maskShiftAmount(PhaseGVN* phase, Node* shiftNode, uint nBits) {\n@@ -1299,3 +1311,27 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* RShiftINode::Identity(PhaseGVN* phase) {\n+Node *RShiftNode::IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n+  \/\/ Inputs may be TOP if they are dead.\n+  const TypeInteger* t1 = phase->type(in(1))->isa_integer(bt);\n+  if (t1 == nullptr) {\n+    return NodeSentinel;        \/\/ Left input is an integer\n+  }\n+  const TypeInteger* t3;  \/\/ type of in(1).in(2)\n+  int shift = maskShiftAmount(phase, this, bits_per_java_integer(bt));\n+  if (shift == 0) {\n+    return NodeSentinel;\n+  }\n+\n+  \/\/ Check for (x & 0xFF000000) >> 24, whose mask can be made smaller.\n+  \/\/ Such expressions arise normally from shift chains like (byte)(x >> 24).\n+  const Node *mask = in(1);\n+  if (mask->Opcode() == Op_And(bt) &&\n+      (t3 = phase->type(mask->in(2))->isa_integer(bt)) &&\n+      t3->is_con()) {\n+    jlong maskbits = t3->get_con_as_long(bt);\n+    \/\/ Convert to \"(x >> shift) & (mask >> shift)\"\n+    Node* shr_nomask = phase->transform(RShiftNode::make(mask->in(1), in(2), bt));\n+    return MulNode::make_and(shr_nomask, phase->integercon(maskbits >> shift, bt), bt);\n+  }\n+  return nullptr;\n+}\n+\n+Node* RShiftNode::IdentityIL(PhaseGVN* phase, BasicType bt) {\n@@ -1304,2 +1340,2 @@\n-    if ((count & (BitsPerJavaInteger - 1)) == 0) {\n-      \/\/ Shift by a multiple of 32 does nothing\n+    if ((count & (bits_per_java_integer(bt) - 1)) == 0) {\n+      \/\/ Shift by a multiple of 32\/64 does nothing\n@@ -1309,1 +1345,1 @@\n-    if (in(1)->Opcode() == Op_LShiftI &&\n+    if (in(1)->Opcode() == Op_LShift(bt) &&\n@@ -1312,1 +1348,1 @@\n-      count &= BitsPerJavaInteger-1; \/\/ semantics of Java shifts\n+      count &= bits_per_java_integer(bt)-1; \/\/ semantics of Java shifts\n@@ -1314,3 +1350,3 @@\n-      int lo = (-1 << (BitsPerJavaInteger - ((uint)count)-1)); \/\/ FFFF8000\n-      int hi = ~lo;               \/\/ 00007FFF\n-      const TypeInt* t11 = phase->type(in(1)->in(1))->isa_int();\n+      jlong lo = (-1 << (bits_per_java_integer(bt) - ((uint)count)-1)); \/\/ FFFF8000\n+      jlong hi = ~lo;               \/\/ 00007FFF\n+      const TypeInteger* t11 = phase->type(in(1)->in(1))->isa_integer(bt);\n@@ -1321,1 +1357,1 @@\n-      if (lo <= t11->_lo && t11->_hi <= hi) {\n+      if (lo <= t11->lo_as_long() && t11->hi_as_long() <= hi) {\n@@ -1329,0 +1365,88 @@\n+const Type* RShiftNode::ValueIL(PhaseGVN* phase, BasicType bt) const {\n+  const Type *t1 = phase->type(in(1));\n+  const Type *t2 = phase->type(in(2));\n+  \/\/ Either input is TOP ==> the result is TOP\n+  if (t1 == Type::TOP) return Type::TOP;\n+  if (t2 == Type::TOP) return Type::TOP;\n+\n+  \/\/ Left input is ZERO ==> the result is ZERO.\n+  if (t1 == TypeInteger::zero(bt)) return TypeInteger::zero(bt);\n+  \/\/ Shift by zero does nothing\n+  if (t2 == TypeInt::ZERO) return t1;\n+\n+  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n+  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM) {\n+    return TypeInteger::bottom(bt);\n+  }\n+\n+  const TypeInteger* r1 = t1->isa_integer(bt); \/\/ Handy access\n+  const TypeInt* r2 = t2->isa_int(); \/\/ Handy access\n+\n+  \/\/ If the shift is a constant, just shift the bounds of the type.\n+  \/\/ For example, if the shift is 31\/63, we just propagate sign bits.\n+  if (!r1->is_con() && r2->is_con()) {\n+    uint shift = r2->get_con();\n+    shift &= bits_per_java_integer(bt)-1;  \/\/ semantics of Java shifts\n+    \/\/ Shift by a multiple of 32\/64 does nothing:\n+    if (shift == 0)  return t1;\n+    \/\/ Calculate reasonably aggressive bounds for the result.\n+    \/\/ This is necessary if we are to correctly type things\n+    \/\/ like (x<<24>>24) == ((byte)x).\n+    jlong lo = r1->lo_as_long() >> (jint)shift;\n+    jlong hi = r1->hi_as_long() >> (jint)shift;\n+    assert(lo <= hi, \"must have valid bounds\");\n+#ifdef ASSERT\n+   if (bt ==T_INT) {\n+     jint lo_verify = checked_cast<jint>(r1->lo_as_long()) >> (jint)shift;\n+     jint hi_verify = checked_cast<jint>(r1->hi_as_long()) >> (jint)shift;\n+     assert((checked_cast<jint>(lo) == lo_verify) && (checked_cast<jint>(hi) == hi_verify), \"inconsistent\");\n+   }\n+#endif\n+    const TypeInteger* ti = TypeInteger::make(lo, hi, MAX2(r1->_widen,r2->_widen), bt);\n+#ifdef ASSERT\n+    \/\/ Make sure we get the sign-capture idiom correct.\n+    if (shift == bits_per_java_integer(bt)-1) {\n+      if (r1->lo_as_long() >= 0) assert(ti == TypeInteger::zero(bt),    \">>31\/63 of + is  0\");\n+      if (r1->hi_as_long() <  0) assert(ti == TypeInteger::minus_1(bt), \">>31\/63 of - is -1\");\n+    }\n+#endif\n+    return ti;\n+  }\n+\n+  if (!r1->is_con() || !r2->is_con()) {\n+    \/\/ If the left input is non-negative the result must also be non-negative, regardless of what the right input is.\n+    if (r1->lo_as_long() >= 0) {\n+      return TypeInteger::make(0, r1->hi_as_long(), MAX2(r1->_widen, r2->_widen), bt);\n+    }\n+\n+    \/\/ Conversely, if the left input is negative then the result must be negative.\n+    if (r1->hi_as_long() <= -1) {\n+      return TypeInteger::make(r1->lo_as_long(), -1, MAX2(r1->_widen, r2->_widen), bt);\n+    }\n+\n+    return TypeInteger::bottom(bt);\n+  }\n+\n+  \/\/ Signed shift right\n+  return TypeInteger::make(r1->get_con_as_long(bt) >> (r2->get_con() & (bits_per_java_integer(bt) - 1)), bt);\n+}\n+\n+RShiftNode* RShiftNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new RShiftINode(in1, in2);\n+    case T_LONG:\n+      return new RShiftLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n+}\n+\n+\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n+Node* RShiftINode::Identity(PhaseGVN* phase) {\n+  return IdentityIL(phase, T_INT);\n+}\n+\n@@ -1331,6 +1455,2 @@\n-  \/\/ Inputs may be TOP if they are dead.\n-  const TypeInt *t1 = phase->type(in(1))->isa_int();\n-  if (!t1) return nullptr;        \/\/ Left input is an integer\n-  const TypeInt *t3;  \/\/ type of in(1).in(2)\n-  int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);\n-  if (shift == 0) {\n+  Node* progress = IdealIL(phase, can_reshape, T_INT);\n+  if (progress == NodeSentinel) {\n@@ -1339,12 +1459,2 @@\n-\n-  \/\/ Check for (x & 0xFF000000) >> 24, whose mask can be made smaller.\n-  \/\/ Such expressions arise normally from shift chains like (byte)(x >> 24).\n-  const Node *mask = in(1);\n-  if( mask->Opcode() == Op_AndI &&\n-      (t3 = phase->type(mask->in(2))->isa_int()) &&\n-      t3->is_con() ) {\n-    Node *x = mask->in(1);\n-    jint maskbits = t3->get_con();\n-    \/\/ Convert to \"(x >> shift) & (mask >> shift)\"\n-    Node *shr_nomask = phase->transform( new RShiftINode(mask->in(1), in(2)) );\n-    return new AndINode(shr_nomask, phase->intcon( maskbits >> shift));\n+  if (progress != nullptr) {\n+    return progress;\n@@ -1352,0 +1462,3 @@\n+  const TypeInt *t3;  \/\/ type of in(1).in(2)\n+  int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);\n+  assert(shift != 0, \"handled by IdealIL\");\n@@ -1394,2 +1507,0 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A RShiftINode shifts its input2 right by input1 amount.\n@@ -1397,58 +1508,1 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n-\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeInt::INT;\n-\n-  const TypeInt *r1 = t1->is_int(); \/\/ Handy access\n-  const TypeInt *r2 = t2->is_int(); \/\/ Handy access\n-\n-  \/\/ If the shift is a constant, just shift the bounds of the type.\n-  \/\/ For example, if the shift is 31, we just propagate sign bits.\n-  if (!r1->is_con() && r2->is_con()) {\n-    uint shift = r2->get_con();\n-    shift &= BitsPerJavaInteger-1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 32 does nothing:\n-    if (shift == 0)  return t1;\n-    \/\/ Calculate reasonably aggressive bounds for the result.\n-    \/\/ This is necessary if we are to correctly type things\n-    \/\/ like (x<<24>>24) == ((byte)x).\n-    jint lo = (jint)r1->_lo >> (jint)shift;\n-    jint hi = (jint)r1->_hi >> (jint)shift;\n-    assert(lo <= hi, \"must have valid bounds\");\n-    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n-#ifdef ASSERT\n-    \/\/ Make sure we get the sign-capture idiom correct.\n-    if (shift == BitsPerJavaInteger-1) {\n-      if (r1->_lo >= 0) assert(ti == TypeInt::ZERO,    \">>31 of + is  0\");\n-      if (r1->_hi <  0) assert(ti == TypeInt::MINUS_1, \">>31 of - is -1\");\n-    }\n-#endif\n-    return ti;\n-  }\n-\n-  if (!r1->is_con() || !r2->is_con()) {\n-    \/\/ If the left input is non-negative the result must also be non-negative, regardless of what the right input is.\n-    if (r1->_lo >= 0) {\n-      return TypeInt::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n-    }\n-\n-    \/\/ Conversely, if the left input is negative then the result must be negative.\n-    if (r1->_hi <= -1) {\n-      return TypeInt::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n-    }\n-\n-    return TypeInt::INT;\n-  }\n-\n-  \/\/ Signed shift right\n-  return TypeInt::make(r1->get_con() >> (r2->get_con() & 31));\n+  return ValueIL(phase, T_INT);\n@@ -1460,2 +1514,1 @@\n-  const TypeInt *ti = phase->type(in(2))->isa_int(); \/\/ Shift count is an int.\n-  return (ti && ti->is_con() && (ti->get_con() & (BitsPerJavaLong - 1)) == 0) ? in(1) : this;\n+  return IdentityIL(phase, T_LONG);\n@@ -1464,57 +1517,4 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A RShiftLNode shifts its input2 right by input1 amount.\n-const Type* RShiftLNode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n-\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeLong::LONG;\n-\n-  const TypeLong *r1 = t1->is_long(); \/\/ Handy access\n-  const TypeInt  *r2 = t2->is_int (); \/\/ Handy access\n-\n-  \/\/ If the shift is a constant, just shift the bounds of the type.\n-  \/\/ For example, if the shift is 63, we just propagate sign bits.\n-  if (!r1->is_con() && r2->is_con()) {\n-    uint shift = r2->get_con();\n-    shift &= (2*BitsPerJavaInteger)-1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 64 does nothing:\n-    if (shift == 0)  return t1;\n-    \/\/ Calculate reasonably aggressive bounds for the result.\n-    \/\/ This is necessary if we are to correctly type things\n-    \/\/ like (x<<24>>24) == ((byte)x).\n-    jlong lo = (jlong)r1->_lo >> (jlong)shift;\n-    jlong hi = (jlong)r1->_hi >> (jlong)shift;\n-    assert(lo <= hi, \"must have valid bounds\");\n-    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n-    #ifdef ASSERT\n-    \/\/ Make sure we get the sign-capture idiom correct.\n-    if (shift == (2*BitsPerJavaInteger)-1) {\n-      if (r1->_lo >= 0) assert(tl == TypeLong::ZERO,    \">>63 of + is 0\");\n-      if (r1->_hi < 0)  assert(tl == TypeLong::MINUS_1, \">>63 of - is -1\");\n-    }\n-    #endif\n-    return tl;\n-  }\n-\n-  if (!r1->is_con() || !r2->is_con()) {\n-    \/\/ If the left input is non-negative the result must also be non-negative, regardless of what the right input is.\n-    if (r1->_lo >= 0) {\n-      return TypeLong::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n-    }\n-\n-    \/\/ Conversely, if the left input is negative then the result must be negative.\n-    if (r1->_hi <= -1) {\n-      return TypeLong::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n-    }\n-\n-    return TypeLong::LONG;\n+Node* RShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  Node* progress = IdealIL(phase, can_reshape, T_LONG);\n+  if (progress == NodeSentinel) {\n+    return nullptr;\n@@ -1522,0 +1522,2 @@\n+  return progress;\n+}\n@@ -1523,1 +1525,2 @@\n-  return TypeLong::make(r1->get_con() >> (r2->get_con() & 63));\n+const Type* RShiftLNode::Value(PhaseGVN* phase) const {\n+  return ValueIL(phase, T_LONG);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":153,"deletions":150,"binary":false,"changes":303,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  static MulNode* make_and(Node* in1, Node* in2, BasicType bt);\n@@ -303,0 +304,10 @@\n+\n+class RShiftNode : public Node {\n+public:\n+  RShiftNode(Node* in1, Node* in2) : Node(nullptr,in1,in2) {}\n+  Node* IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt);\n+  Node* IdentityIL(PhaseGVN* phase, BasicType bt);\n+  const Type* ValueIL(PhaseGVN* phase, BasicType bt) const;\n+  static RShiftNode* make(Node* in1, Node* in2, BasicType bt);\n+};\n+\n@@ -305,1 +316,1 @@\n-class RShiftINode : public Node {\n+class RShiftINode : public RShiftNode {\n@@ -307,1 +318,1 @@\n-  RShiftINode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n+  RShiftINode(Node* in1, Node* in2) : RShiftNode(in1,in2) {}\n@@ -310,1 +321,2 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+\n+  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -312,1 +324,2 @@\n-  const Type *bottom_type() const { return TypeInt::INT; }\n+\n+  const Type* bottom_type() const { return TypeInt::INT; }\n@@ -318,1 +331,1 @@\n-class RShiftLNode : public Node {\n+class RShiftLNode : public RShiftNode {\n@@ -320,1 +333,1 @@\n-  RShiftLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n+  RShiftLNode(Node* in1, Node* in2) : RShiftNode(in1,in2) {}\n@@ -323,0 +336,2 @@\n+  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n+\n@@ -324,1 +339,1 @@\n-  const Type *bottom_type() const { return TypeLong::LONG; }\n+  const Type* bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2059,0 +2059,1 @@\n+Op_IL(And)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1533,0 +1533,4 @@\n+const TypeInteger* TypeInteger::make(jlong lo, BasicType bt) {\n+  return make(lo, lo, WidenMin, bt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -569,0 +569,1 @@\n+  static const TypeInteger* make(jlong lo, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -795,0 +795,7 @@\n+inline uint bits_per_java_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return BitsPerJavaInteger;\n+  }\n+  return BitsPerJavaLong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n@@ -59,0 +59,4 @@\n+        assertResult(test7Min, b);\n+        assertResult(test7Max, b);\n+        assertResult(test7Min-1, b);\n+        assertResult(test7Max+1, b);\n@@ -67,0 +71,8 @@\n+        Asserts.assertEQ((x & 0xFF000000) >> 24, test5(x));\n+        Asserts.assertEQ(x >> 64, test6(x));\n+        int x7 = Integer.max(Integer.min(x, test7Max), test7Min);\n+        Asserts.assertEQ(((x7 << test7Shift) >> test7Shift), test7(x));\n+        int x8 = Integer.max(Integer.min(x, test7Max+1), test7Min);\n+        Asserts.assertEQ((x8 << test7Shift) >> test7Shift, test8(x));\n+        int x9 = Integer.max(Integer.min(x, test7Max), test7Min-1);\n+        Asserts.assertEQ((x9 << test7Shift) >> test7Shift, test9(x));\n@@ -92,0 +104,38 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_I, \"1\" })\n+    @IR(failOn = { IRNode.AND_I })\n+    public int test5(int x) {\n+        return (x & 0xFF000000) >> 24;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT_I })\n+    public int test6(int x) {\n+        return (x >> 64);\n+    }\n+\n+    final int test7Shift = 10;\n+    final int test7Min = -1 << (32 - test7Shift -1);\n+    final int test7Max = ~test7Min;\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT_I, IRNode.LSHIFT_I })\n+    public int test7(int x) {\n+        x = Integer.max(Integer.min(x, test7Max), test7Min);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    public int test8(int x) {\n+        x = Integer.max(Integer.min(x, test7Max+1), test7Min);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    public int test9(int x) {\n+        x = Integer.max(Integer.min(x, test7Max), test7Min-1);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftINodeIdealizationTests.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n@@ -59,0 +59,4 @@\n+        assertResult(test7Min, b);\n+        assertResult(test7Max, b);\n+        assertResult(test7Min-1, b);\n+        assertResult(test7Max+1, b);\n@@ -67,0 +71,7 @@\n+        Asserts.assertEQ((x & 0xFF000000_00000000L) >> 56, test5(x));\n+        long x7 = Integer.max(Integer.min((int)x, (int)test7Max), (int)test7Min);\n+        Asserts.assertEQ(((x7 << test7Shift) >> test7Shift), test7(x));\n+        long x8 = Integer.max(Integer.min((int)x, (int)(test7Max+1)), (int)test7Min);\n+        Asserts.assertEQ((x8 << test7Shift) >> test7Shift, test8(x));\n+        long x9 = Integer.max(Integer.min((int)x, (int)test7Max), (int)(test7Min-1));\n+        Asserts.assertEQ((x9 << test7Shift) >> test7Shift, test9(x));\n@@ -92,0 +103,38 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_L, \"1\" })\n+    @IR(failOn = { IRNode.AND_L })\n+    public long test5(long x) {\n+        return (x & 0xFF000000_00000000L) >> 56;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT_L })\n+    public long test6(long x) {\n+        return (x >> 128);\n+    }\n+\n+    final int test7Shift = 42;\n+    final long test7Min = -1L << (64 - test7Shift -1);\n+    final long test7Max = ~test7Min;\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT_L, IRNode.LSHIFT_L })\n+    public long test7(long x) {\n+        x = Integer.max(Integer.min((int)x, (int)test7Max), (int)test7Min);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_L, \"1\", IRNode.LSHIFT_L, \"1\" })\n+    public long test8(long x) {\n+        x = Integer.max(Integer.min((int)x, (int)(test7Max+1)), (int)test7Min);\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_L, \"1\", IRNode.LSHIFT_L, \"1\" })\n+    public long test9(long x) {\n+        x = Integer.max(Integer.min((int)x, (int)test7Max), (int)(test7Min-1));\n+        return ((x << test7Shift) >> test7Shift);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftLNodeIdealizationTests.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"}]}