{"files":[{"patch":"@@ -1336,23 +1336,8 @@\n-Node* RShiftNode::IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n-  \/\/ Inputs may be TOP if they are dead.\n-  const TypeInteger* t1 = phase->type(in(1))->isa_integer(bt);\n-  if (t1 == nullptr) {\n-    return NodeSentinel;        \/\/ Left input is an integer\n-  }\n-  int shift = maskShiftAmount(phase, this, bits_per_java_integer(bt));\n-  if (shift == 0) {\n-    return NodeSentinel;\n-  }\n-\n-  \/\/ Check for (x & 0xFF000000) >> 24, whose mask can be made smaller.\n-  \/\/ and convert to (x >> 24) & (0xFF000000 >> 24) = x >> 24\n-  \/\/ Such expressions arise normally from shift chains like (byte)(x >> 24).\n-  const TypeInteger* mask_t;\n-  const Node* and_node = in(1);\n-  if (and_node->Opcode() == Op_And(bt) &&\n-      (mask_t = phase->type(and_node->in(2))->isa_integer(bt)) &&\n-      mask_t->is_con()) {\n-    jlong maskbits = mask_t->get_con_as_long(bt);\n-    \/\/ Convert to \"(x >> shift) & (mask >> shift)\"\n-    Node* shr_nomask = phase->transform(RShiftNode::make(and_node->in(1), in(2), bt));\n-    return MulNode::make_and(shr_nomask, phase->integercon(maskbits >> shift, bt), bt);\n+RShiftNode* RShiftNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new RShiftINode(in1, in2);\n+    case T_LONG:\n+      return new RShiftLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n@@ -1363,0 +1348,3 @@\n+\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n@@ -1391,0 +1379,87 @@\n+Node* RShiftINode::Identity(PhaseGVN* phase) {\n+  return IdentityIL(phase, T_INT);\n+}\n+\n+\/\/------------------------------Ideal------------------------------------------\n+Node* RShiftNode::IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n+  \/\/ Inputs may be TOP if they are dead.\n+  const TypeInteger* t1 = phase->type(in(1))->isa_integer(bt);\n+  if (t1 == nullptr) {\n+    return NodeSentinel;        \/\/ Left input is an integer\n+  }\n+  int shift = maskShiftAmount(phase, this, bits_per_java_integer(bt));\n+  if (shift == 0) {\n+    return NodeSentinel;\n+  }\n+\n+  \/\/ Check for (x & 0xFF000000) >> 24, whose mask can be made smaller.\n+  \/\/ and convert to (x >> 24) & (0xFF000000 >> 24) = x >> 24\n+  \/\/ Such expressions arise normally from shift chains like (byte)(x >> 24).\n+  const TypeInteger* mask_t;\n+  const Node* and_node = in(1);\n+  if (and_node->Opcode() == Op_And(bt) &&\n+      (mask_t = phase->type(and_node->in(2))->isa_integer(bt)) &&\n+      mask_t->is_con()) {\n+    jlong maskbits = mask_t->get_con_as_long(bt);\n+    \/\/ Convert to \"(x >> shift) & (mask >> shift)\"\n+    Node* shr_nomask = phase->transform(RShiftNode::make(and_node->in(1), in(2), bt));\n+    return MulNode::make_and(shr_nomask, phase->integercon(maskbits >> shift, bt), bt);\n+  }\n+  return nullptr;\n+}\n+\n+Node *RShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  Node* progress = IdealIL(phase, can_reshape, T_INT);\n+  if (progress == NodeSentinel) {\n+    return nullptr;\n+  }\n+  if (progress != nullptr) {\n+    return progress;\n+  }\n+  int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);\n+  assert(shift != 0, \"handled by IdealIL\");\n+\n+  \/\/ Check for \"(short[i] <<16)>>16\" which simply sign-extends\n+  const Node *shl = in(1);\n+  if (shl->Opcode() != Op_LShiftI) {\n+    return nullptr;\n+  }\n+\n+  const TypeInt* left_shift_t;\n+  if (shift == 16 &&\n+      (left_shift_t = phase->type(shl->in(2))->isa_int()) &&\n+      left_shift_t->is_con(16)) {\n+    Node *ld = shl->in(1);\n+    if (ld->Opcode() == Op_LoadS) {\n+      \/\/ Sign extension is just useless here.  Return a RShiftI of zero instead\n+      \/\/ returning 'ld' directly.  We cannot return an old Node directly as\n+      \/\/ that is the job of 'Identity' calls and Identity calls only work on\n+      \/\/ direct inputs ('ld' is an extra Node removed from 'this').  The\n+      \/\/ combined optimization requires Identity only return direct inputs.\n+      set_req_X(1, ld, phase);\n+      set_req_X(2, phase->intcon(0), phase);\n+      return this;\n+    }\n+    else if (can_reshape &&\n+             ld->Opcode() == Op_LoadUS &&\n+             ld->outcnt() == 1 && ld->unique_out() == shl)\n+      \/\/ Replace zero-extension-load with sign-extension-load\n+      return ld->as_Load()->convert_to_signed_load(*phase);\n+  }\n+\n+  \/\/ Check for \"(byte[i] <<24)>>24\" which simply sign-extends\n+  if (shift == 24 &&\n+      (left_shift_t = phase->type(shl->in(2))->isa_int()) &&\n+      left_shift_t->is_con(24)) {\n+    Node *ld = shl->in(1);\n+    if (ld->Opcode() == Op_LoadB) {\n+      \/\/ Sign extension is just useless here\n+      set_req_X(1, ld, phase);\n+      set_req_X(2, phase->intcon(0), phase);\n+      return this;\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -1460,75 +1535,0 @@\n-RShiftNode* RShiftNode::make(Node* in1, Node* in2, BasicType bt) {\n-  switch (bt) {\n-    case T_INT:\n-      return new RShiftINode(in1, in2);\n-    case T_LONG:\n-      return new RShiftLNode(in1, in2);\n-    default:\n-      fatal(\"Not implemented for %s\", type2name(bt));\n-  }\n-  return nullptr;\n-}\n-\n-\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* RShiftINode::Identity(PhaseGVN* phase) {\n-  return IdentityIL(phase, T_INT);\n-}\n-\n-\/\/------------------------------Ideal------------------------------------------\n-Node *RShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  Node* progress = IdealIL(phase, can_reshape, T_INT);\n-  if (progress == NodeSentinel) {\n-    return nullptr;\n-  }\n-  if (progress != nullptr) {\n-    return progress;\n-  }\n-  int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);\n-  assert(shift != 0, \"handled by IdealIL\");\n-\n-  \/\/ Check for \"(short[i] <<16)>>16\" which simply sign-extends\n-  const Node *shl = in(1);\n-  if (shl->Opcode() != Op_LShiftI) {\n-    return nullptr;\n-  }\n-\n-  const TypeInt* left_shift_t;\n-  if (shift == 16 &&\n-      (left_shift_t = phase->type(shl->in(2))->isa_int()) &&\n-      left_shift_t->is_con(16)) {\n-    Node *ld = shl->in(1);\n-    if (ld->Opcode() == Op_LoadS) {\n-      \/\/ Sign extension is just useless here.  Return a RShiftI of zero instead\n-      \/\/ returning 'ld' directly.  We cannot return an old Node directly as\n-      \/\/ that is the job of 'Identity' calls and Identity calls only work on\n-      \/\/ direct inputs ('ld' is an extra Node removed from 'this').  The\n-      \/\/ combined optimization requires Identity only return direct inputs.\n-      set_req_X(1, ld, phase);\n-      set_req_X(2, phase->intcon(0), phase);\n-      return this;\n-    }\n-    else if (can_reshape &&\n-             ld->Opcode() == Op_LoadUS &&\n-             ld->outcnt() == 1 && ld->unique_out() == shl)\n-      \/\/ Replace zero-extension-load with sign-extension-load\n-      return ld->as_Load()->convert_to_signed_load(*phase);\n-  }\n-\n-  \/\/ Check for \"(byte[i] <<24)>>24\" which simply sign-extends\n-  if (shift == 24 &&\n-      (left_shift_t = phase->type(shl->in(2))->isa_int()) &&\n-      left_shift_t->is_con(24)) {\n-    Node *ld = shl->in(1);\n-    if (ld->Opcode() == Op_LoadB) {\n-      \/\/ Sign extension is just useless here\n-      set_req_X(1, ld, phase);\n-      set_req_X(2, phase->intcon(0), phase);\n-      return this;\n-    }\n-  }\n-\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":98,"deletions":98,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\", \"test10\" })\n@@ -79,0 +79,1 @@\n+        Asserts.assertEQ((x7 << test7Shift) >> test10Shift, test10(x));\n@@ -123,0 +124,12 @@\n+\n+    \/\/ test that (x << shift) >> shift) is a nop if upper bits of x\n+    \/\/ that are shifted left and then right + one bit are all ones or\n+    \/\/ zeroes. For instance:\n+    \/\/ shift = 15, min = 0xffff0000, max=0x0000ffff\n+    \/\/ min << shift = 0x80000000, (min << shift) >> shift = 0xffff0000\n+    \/\/ (min+1) << shift = 0x80008000, ((min+1) << shift) >> shift = 0xffff0001\n+    \/\/ (max-1) << shift = 0x7fff0000, ((max-1) << shift) >> shift = 0x0000fffe\n+    \/\/ max << shift = 0x7fff8000, (min << shift) >> shift = 0x0000ffff\n+    \/\/ But:\n+    \/\/ (min-1) << shift = 7fff8000, ((min-1) << shift) >> shift = 0x0000ffff != 0xfffeffff\n+    \/\/ (max+1) << shift = 0x80000000, ((max+1) << shift) >> shift = 0xffff0000 != 0x00010000\n@@ -147,0 +160,8 @@\n+\n+    final static int test10Shift = RunInfo.getRandom().nextInt(32);\n+\n+    @Test\n+    public int test10(int x) {\n+        x = Integer.max(Integer.min(x, test7Max), test7Min);\n+        return ((x << test7Shift) >> test10Shift);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftINodeIdealizationTests.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\", \"test10\" })\n@@ -79,0 +79,1 @@\n+         Asserts.assertEQ(((x7 << test7Shift) >> test10Shift), test10(x));\n@@ -123,0 +124,1 @@\n+    \/\/ See comment in RShiftINodeIdealizationTests\n@@ -147,0 +149,7 @@\n+\n+    final static int test10Shift = RunInfo.getRandom().nextInt(64);\n+    @Test\n+    public long test10(long x) {\n+        x = Integer.max(Integer.min((int)x, (int)test7Max), (int)test7Min);\n+        return ((x << test7Shift) >> test10Shift);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftLNodeIdealizationTests.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}