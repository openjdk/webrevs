{"files":[{"patch":"@@ -126,1 +126,2 @@\n-     * Returns a {@code List} of {@link Arguments}, with each entry representing a test case scenario.\n+     * Returns a {@code List} of {@link Arguments}, with each entry representing a\n+     * test case scenario.\n@@ -128,5 +129,5 @@\n-     * <li>CharBuffer - the instance to be tested<\/li>\n-     * <li>char[] - the data expected to be backing the current state of the CharBuffer<\/li>\n-     * <li>int start - index (inclusive) into char[] where the CharBuffer should be positioned<\/li>\n-     * <li>int stop - index (exclusive) into char[] where the CharBuffer should be limited<\/li>\n-     * <li>String - description of the test scenario<\/li>\n+     *   <li>CharBuffer - the instance to be tested<\/li>\n+     *   <li>char[] - the data expected to be backing the current state of the CharBuffer<\/li>\n+     *   <li>int start - index (inclusive) into char[] where the CharBuffer should be positioned<\/li>\n+     *   <li>int stop - index (exclusive) into char[] where the CharBuffer should be limited<\/li>\n+     *   <li>String - description of the test scenario<\/li>\n@@ -137,21 +138,18 @@\n-     * <li>Randomly generated content\n-     *   <ul>\n-     *     <li>See {@code populateAndAddCases(String, CharBuffer, List)} for the following types:\n-     *       <ul>\n-     *         <li>HeapCharBuffer<\/i>\n-     *         <li>HeapByteBuffer Big Endian<\/i>\n-     *         <li>HeapByteBuffer Little Endian<\/i>\n-     *         <li>DirectByteBuffer Big Endian<\/i>\n-     *         <li>DirectByteBuffer Little Endian<\/i>\n-     *       <\/ul>\n-     *     <\/li>\n-     *     <li>Randomly generated content into {@link CharBuffer#wrap(CharSequence) StringCharBuffer}\n-     *         - see {@code addCases(String, char[], CharBuffer, List)}.\n-     *       <ul>\n-     *         <li>StringCharBuffer wrapping a {@code CharBuffer}\n-     *             created from {@link CharBuffer#wrap(char[])}<\/li>\n-     *         <li>StringCharBuffer wrapping a {@code String}<\/li>\n-     *       <\/ul>\n-     *     <\/li>\n-     *   <\/ul>\n-     * <\/li>\n+     *   <li>See {@code populateAndAddCases(String, CharBuffer, List)} for the\n+     *       following types:\n+     *     <ul>\n+     *       <li>HeapCharBuffer<\/i>\n+     *       <li>HeapByteBuffer Big Endian<\/i>\n+     *       <li>HeapByteBuffer Little Endian<\/i>\n+     *       <li>DirectByteBuffer Big Endian<\/i>\n+     *       <li>DirectByteBuffer Little Endian<\/i>\n+     *     <\/ul>\n+     *   <\/li>\n+     *   <li>Randomly generated content into {@link CharBuffer#wrap(CharSequence)\n+     *       StringCharBuffer} - see {@code addCases(String, char[], CharBuffer, List)}.\n+     *     <ul>\n+     *       <li>StringCharBuffer wrapping a {@code CharBuffer} created from\n+     *           {@link CharBuffer#wrap(char[])}<\/li>\n+     *       <li>StringCharBuffer wrapping a {@code String}<\/li>\n+     *     <\/ul>\n+     *   <\/li>\n@@ -179,75 +177,0 @@\n-        \/\/ nothing magic about 1273, it is just larger than 1k and an odd number - eliminating any alignment assumptions\n-        char[] buf = new char[1273];\n-        for (int i = 0; i < buf.length; ++i) {\n-            buf[i] = (char) i;\n-        }\n-        String stringBuf = new String(buf);\n-\n-        \/\/ nothing magic about 7, it is simply an odd number to advance - making sure no expectations of alignment\n-        \/\/ comparing to 29 results in 5 loops (0, 7, 14, 21, 28), giving decent coverage of offset and limits\n-        for (int i = 0; i < 29; i += 7) {\n-            CharBuffer buffer = CharBuffer.wrap(buf, i, buf.length - i);\n-            args.add(Arguments.of(buffer, buf, i, buf.length, \"HeapCharBuffer index \" + i + \" to end\"));\n-            args.add(Arguments.of(buffer.slice(), buf, i, buf.length, \"HeapCharBuffer slice \" + i + \" to end\"));\n-\n-            args.add(Arguments.of(CharBuffer.wrap(new String(buf, i, buf.length - i)), buf, i, buf.length,\n-                    \"StringCharBuffer index \" + i + \" to end\"));\n-            buffer = CharBuffer.wrap(stringBuf);\n-            buffer.position(i);\n-            args.add(Arguments.of(buffer.slice(), buf, i, buf.length, \"StringCharBuffer slice \" + i + \" to end\"));\n-\n-            CharBuffer lehbbAsCB = ByteBuffer.allocate(buf.length * 2)\n-                                             .order(ByteOrder.LITTLE_ENDIAN)\n-                                             .asCharBuffer()\n-                                             .put(buf)\n-                                             .position(i);\n-            args.add(Arguments.of(lehbbAsCB, buf, i, buf.length, \"HeapByteBuffer LE as CharBuffer index \" + i + \" to end\"));\n-\n-            CharBuffer behbdAsCB = ByteBuffer.allocateDirect(buf.length * 2)\n-                                             .order(ByteOrder.BIG_ENDIAN)\n-                                             .asCharBuffer()\n-                                             .put(buf)\n-                                             .position(i);\n-            args.add(Arguments.of(behbdAsCB, buf, i, buf.length,\n-                    \"DirectByteBuffer BE as CharBuffer index \" + i + \" to end\"));\n-\n-            if (i > 0) {\n-                buffer = CharBuffer.wrap(buf, 1, buf.length - 1).slice();\n-                buffer.position(i - 1);\n-                args.add(Arguments.of(buffer, buf, i, buf.length,\n-                        \"HeapCharBuffer slice\/offset 1 index \" + (i - 1) + \" to end\"));\n-\n-                int end = buf.length - i;\n-\n-                buffer = CharBuffer.wrap(buf, i, buf.length - (2 * i));\n-                args.add(Arguments.of(buffer, buf, i, end, \"HeapCharBuffer index \" + i + \" to \" + end));\n-                args.add(Arguments.of(buffer.slice(), buf, i, end, \"HeapCharBuffer slice \" + i + \" to \" + end));\n-\n-                args.add(Arguments.of(CharBuffer.wrap(new String(buf, i, buf.length - (2 * i))), buf, i, end,\n-                        \"StringCharBuffer index \" + i + \" to \" + end));\n-                buffer = CharBuffer.wrap(stringBuf);\n-                buffer.position(i);\n-                buffer.limit(end);\n-                args.add(Arguments.of(buffer.slice(), buf, i, end, \"StringCharBuffer slice \" + i + \" to \" + end));\n-\n-                CharBuffer behbbAsCB = ByteBuffer.allocate(buf.length * 2)\n-                                                 .order(ByteOrder.BIG_ENDIAN)\n-                                                 .asCharBuffer()\n-                                                 .put(buf)\n-                                                 .position(1)\n-                                                 .slice()\n-                                                 .position(i - 1)\n-                                                 .limit(end - 1);\n-                args.add(Arguments.of(behbbAsCB, buf, i, buf.length - i, \"HeapByteBuffer BE as CharBuffer index \" + i + \" to \" + end));\n-\n-                CharBuffer ledbbAsCB = ByteBuffer.allocateDirect(buf.length * 2)\n-                                                 .order(ByteOrder.LITTLE_ENDIAN)\n-                                                 .asCharBuffer()\n-                                                 .put(buf)\n-                                                 .position(1)\n-                                                 .slice()\n-                                                 .position(i - 1)\n-                                                 .limit(end - 1);\n-                args.add(Arguments.of(ledbbAsCB, buf, i, buf.length - i, \"DirectByteBuffer LE as CharBuffer index \" + i + \" to \" + end));\n-            }\n-        }\n","filename":"test\/jdk\/java\/nio\/Buffer\/CharBufferAsCharSequenceTest.java","additions":25,"deletions":102,"binary":false,"changes":127,"status":"modified"}]}