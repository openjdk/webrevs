{"files":[{"patch":"@@ -181,1 +181,1 @@\n- * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal\n+ * Class:     sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal\n@@ -186,1 +186,1 @@\n-Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_init0(JNIEnv *env, jclass cls) {\n+Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_init0(JNIEnv *env, jclass cls) {\n@@ -218,1 +218,1 @@\n-JNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getAddressSize\n+JNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_getAddressSize\n@@ -228,1 +228,1 @@\n-\/** called by Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByName0 *\/\n+\/** called by Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_lookupByName0 *\/\n@@ -292,1 +292,1 @@\n- * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal\n+ * Class:     sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal\n@@ -297,1 +297,1 @@\n-Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByName0(\n+Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_lookupByName0(\n@@ -327,1 +327,1 @@\n- * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal\n+ * Class:     sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal\n@@ -331,1 +331,1 @@\n-JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByAddress0\n+JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_lookupByAddress0\n@@ -349,1 +349,1 @@\n-\/** called from Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_readBytesFromProcess0 *\/\n+\/** called from Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_readBytesFromProcess0 *\/\n@@ -369,1 +369,1 @@\n- * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal\n+ * Class:     sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal\n@@ -374,1 +374,1 @@\n-Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_readBytesFromProcess0(\n+Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_readBytesFromProcess0(\n@@ -466,1 +466,1 @@\n-  * are still pthread id. Function BsdDebuggerLocal.getJavaThreadsInfo returns an array of long\n+  * are still pthread id. Function MacosxDebuggerLocal.getJavaThreadsInfo returns an array of long\n@@ -517,1 +517,1 @@\n- * Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0\n+ * Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_getThreadIntegerRegisterSet0\n@@ -680,1 +680,1 @@\n- * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal\n+ * Class:     sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal\n@@ -685,1 +685,1 @@\n-Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0(\n+Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_getThreadIntegerRegisterSet0(\n@@ -812,1 +812,1 @@\n- * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal\n+ * Class:     sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal\n@@ -957,1 +957,1 @@\n- * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal\n+ * Class:     sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal\n@@ -962,1 +962,1 @@\n-Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__I(\n+Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_attach0__I(\n@@ -1092,1 +1092,1 @@\n-    called from Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2 *\/\n+    called from Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2 *\/\n@@ -1123,1 +1123,1 @@\n- * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal\n+ * Class:     sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal\n@@ -1128,1 +1128,1 @@\n-Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2(\n+Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2(\n@@ -1171,1 +1171,1 @@\n- * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal\n+ * Class:     sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal\n@@ -1176,1 +1176,1 @@\n-Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_detach0(\n+Java_sun_jvm_hotspot_debugger_macosx_MacosxDebuggerLocal_detach0(\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/MacosxDebuggerLocal.m","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;\n@@ -43,0 +42,1 @@\n+import sun.jvm.hotspot.debugger.macosx.MacosxDebuggerLocal;\n@@ -375,2 +375,0 @@\n-                } else if (os.equals(\"bsd\")) {\n-                    setupDebuggerBsd();\n@@ -420,4 +418,0 @@\n-            } else if (os.equals(\"bsd\")) {\n-                db = new HotSpotTypeDataBase(machDesc,\n-                new BsdVtblAccess(debugger, jvmLibNames),\n-                debugger, jvmLibNames);\n@@ -426,1 +420,1 @@\n-                new BsdVtblAccess(debugger, jvmLibNames),\n+                new MacosxVtblAccess(debugger, jvmLibNames),\n@@ -508,2 +502,0 @@\n-        } else if (os.equals(\"bsd\")) {\n-            setupJVMLibNamesBsd();\n@@ -583,23 +575,0 @@\n-    \/\/\n-    \/\/ BSD\n-    \/\/\n-\n-    private void setupDebuggerBsd() {\n-        setupJVMLibNamesBsd();\n-\n-        if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n-            machDesc = new MachineDescriptionAMD64();\n-        } else {\n-            throw new DebuggerException(\"BSD only supported on x86_64. Current arch: \" + cpu);\n-        }\n-\n-        BsdDebuggerLocal dbg = new BsdDebuggerLocal(machDesc, !isServer);\n-        debugger = dbg;\n-\n-        attachDebugger();\n-    }\n-\n-    private void setupJVMLibNamesBsd() {\n-        jvmLibNames = new String[] { \"libjvm.so\" };\n-    }\n-\n@@ -621,1 +590,1 @@\n-        BsdDebuggerLocal dbg = new BsdDebuggerLocal(machDesc, !isServer);\n+        MacosxDebuggerLocal dbg = new MacosxDebuggerLocal(machDesc, !isServer);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotAgent.java","additions":3,"deletions":34,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-public class BsdVtblAccess extends BasicVtblAccess {\n+public class MacosxVtblAccess extends BasicVtblAccess {\n@@ -34,1 +34,1 @@\n-  public BsdVtblAccess(SymbolLookup symbolLookup,\n+  public MacosxVtblAccess(SymbolLookup symbolLookup,\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/MacosxVtblAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/BsdVtblAccess.java","status":"renamed"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd;\n-\n-import java.util.List;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.cdbg.*;\n-\n-\/** An extension of the JVMDebugger interface with a few additions to\n-    support 32-bit vs. 64-bit debugging as well as features required\n-    by the architecture-specific subpackages. *\/\n-\n-public interface BsdDebugger extends JVMDebugger {\n-  public String       addressValueToString(long address) throws DebuggerException;\n-  public boolean      readJBoolean(long address) throws DebuggerException;\n-  public byte         readJByte(long address) throws DebuggerException;\n-  public char         readJChar(long address) throws DebuggerException;\n-  public double       readJDouble(long address) throws DebuggerException;\n-  public float        readJFloat(long address) throws DebuggerException;\n-  public int          readJInt(long address) throws DebuggerException;\n-  public long         readJLong(long address) throws DebuggerException;\n-  public short        readJShort(long address) throws DebuggerException;\n-  public long         readCInteger(long address, long numBytes, boolean isUnsigned)\n-    throws DebuggerException;\n-  public BsdAddress readAddress(long address) throws DebuggerException;\n-  public BsdAddress readCompOopAddress(long address) throws DebuggerException;\n-  public BsdAddress readCompKlassAddress(long address) throws DebuggerException;\n-  public BsdOopHandle readOopHandle(long address) throws DebuggerException;\n-  public BsdOopHandle readCompOopHandle(long address) throws DebuggerException;\n-  public long[]       getThreadIntegerRegisterSet(long unique_thread_id) throws DebuggerException;\n-  public long         getAddressValue(Address addr) throws DebuggerException;\n-\n-  \/\/ For BsdCDebugger\n-  public List<ThreadProxy> getThreadList();\n-  public List<LoadObject> getLoadObjectList();\n-  public ClosestSymbol lookup(long address);\n-\n-  \/\/ NOTE: this interface implicitly contains the following methods:\n-  \/\/ From the Debugger interface via JVMDebugger\n-  \/\/   public void attach(int processID) throws DebuggerException;\n-  \/\/   public void attach(String executableName, String coreFileName) throws DebuggerException;\n-  \/\/   public boolean detach();\n-  \/\/   public Address parseAddress(String addressString) throws NumberFormatException;\n-  \/\/   public String getOS();\n-  \/\/   public String getCPU();\n-  \/\/ From the SymbolLookup interface via Debugger and JVMDebugger\n-  \/\/   public Address lookup(String objectName, String symbol);\n-  \/\/   public OopHandle lookupOop(String objectName, String symbol);\n-  \/\/ From the JVMDebugger interface\n-  \/\/   public void configureJavaPrimitiveTypeSizes(long jbooleanSize,\n-  \/\/                                               long jbyteSize,\n-  \/\/                                               long jcharSize,\n-  \/\/                                               long jdoubleSize,\n-  \/\/                                               long jfloatSize,\n-  \/\/                                               long jintSize,\n-  \/\/                                               long jlongSize,\n-  \/\/                                               long jshortSize);\n-  \/\/ From the ThreadAccess interface via Debugger and JVMDebugger\n-  \/\/   public ThreadProxy getThreadForIdentifierAddress(Address addr);\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebugger.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,607 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-\n-import sun.jvm.hotspot.debugger.Address;\n-import sun.jvm.hotspot.debugger.DebuggerBase;\n-import sun.jvm.hotspot.debugger.DebuggerException;\n-import sun.jvm.hotspot.debugger.DebuggerUtilities;\n-import sun.jvm.hotspot.debugger.MachineDescription;\n-import sun.jvm.hotspot.debugger.NotInHeapException;\n-import sun.jvm.hotspot.debugger.OopHandle;\n-import sun.jvm.hotspot.debugger.ProcessInfo;\n-import sun.jvm.hotspot.debugger.ReadResult;\n-import sun.jvm.hotspot.debugger.ThreadProxy;\n-import sun.jvm.hotspot.debugger.UnalignedAddressException;\n-import sun.jvm.hotspot.debugger.UnmappedAddressException;\n-import sun.jvm.hotspot.debugger.cdbg.CDebugger;\n-import sun.jvm.hotspot.debugger.cdbg.ClosestSymbol;\n-import sun.jvm.hotspot.debugger.cdbg.LoadObject;\n-import sun.jvm.hotspot.runtime.JavaThread;\n-import sun.jvm.hotspot.runtime.Threads;\n-import sun.jvm.hotspot.runtime.VM;\n-import sun.jvm.hotspot.utilities.PlatformInfo;\n-\n-\/** <P> An implementation of the JVMDebugger interface. The basic debug\n-    facilities are implemented through ptrace interface in the JNI code\n-    (libsaproc.so). Library maps and symbol table management are done in\n-    JNI. <\/P>\n-\n-    <P> <B>NOTE<\/B> that since we have the notion of fetching \"Java\n-    primitive types\" from the remote process (which might have\n-    different sizes than we expect) we have a bootstrapping\n-    problem. We need to know the sizes of these types before we can\n-    fetch them. The current implementation solves this problem by\n-    requiring that it be configured with these type sizes before they\n-    can be fetched. The readJ(Type) routines here will throw a\n-    RuntimeException if they are called before the debugger is\n-    configured with the Java primitive type sizes. <\/P> *\/\n-\n-@SuppressWarnings(\"restricted\")\n-public class BsdDebuggerLocal extends DebuggerBase implements BsdDebugger {\n-    private boolean useGCC32ABI;\n-    private boolean attached;\n-    private long    p_ps_prochandle;      \/\/ native debugger handle\n-    private long    symbolicator;         \/\/ macosx symbolicator handle\n-    private long    task;                 \/\/ macosx task handle\n-    private boolean isCore;\n-    private boolean isDarwin;             \/\/ variant for bsd\n-\n-    \/\/ CDebugger support\n-    private BsdCDebugger cdbg;\n-\n-    \/\/ loadObjectList is filled by attach0 method\n-    private List<LoadObject> loadObjectList;\n-\n-    private List<JavaThread> javaThreadList;\n-\n-    \/\/ called by native method lookupByAddress0\n-    private ClosestSymbol createClosestSymbol(String name, long offset) {\n-       return new ClosestSymbol(name, offset);\n-    }\n-\n-    \/\/ called by native method attach0\n-    private LoadObject createLoadObject(String fileName, long size,\n-                                        long base) {\n-       Address baseAddr = newAddress(base);\n-       return new SharedObject(this, fileName, size, baseAddr);\n-    }\n-\n-    \/\/ native methods\n-\n-    private static native void init0()\n-                                throws DebuggerException;\n-    private native void attach0(int pid)\n-                                throws DebuggerException;\n-    private native void attach0(String execName, String coreName)\n-                                throws DebuggerException;\n-    private native void detach0()\n-                                throws DebuggerException;\n-    private native long lookupByName0(String objectName, String symbol)\n-                                throws DebuggerException;\n-    private native ClosestSymbol lookupByAddress0(long address)\n-                                throws DebuggerException;\n-    private native long[] getThreadIntegerRegisterSet0(long unique_thread_id)\n-                                throws DebuggerException;\n-    private native byte[] readBytesFromProcess0(long address, long numBytes)\n-                                throws DebuggerException;\n-    public static native int  getAddressSize() ;\n-\n-    \/\/ Note on Bsd threads are really processes. When target process is\n-    \/\/ attached by a serviceability agent thread, only that thread can do\n-    \/\/ ptrace operations on the target. This is because from kernel's point\n-    \/\/ view, other threads are just separate processes and they are not\n-    \/\/ attached to the target. When they attempt to make ptrace calls,\n-    \/\/ an ESRCH error will be returned as kernel believes target is not\n-    \/\/ being traced by the caller.\n-    \/\/ To work around the problem, we use a worker thread here to handle\n-    \/\/ all JNI functions that are making ptrace calls.\n-\n-    interface WorkerThreadTask {\n-       public void doit(BsdDebuggerLocal debugger) throws DebuggerException;\n-    }\n-\n-    class BsdDebuggerLocalWorkerThread extends Thread {\n-       BsdDebuggerLocal debugger;\n-       WorkerThreadTask task;\n-       DebuggerException lastException;\n-\n-       public BsdDebuggerLocalWorkerThread(BsdDebuggerLocal debugger) {\n-         this.debugger = debugger;\n-         setDaemon(true);\n-       }\n-\n-       public void run() {\n-          synchronized (workerThread) {\n-             for (;;) {\n-                if (task != null) {\n-                   lastException = null;\n-                   try {\n-                      task.doit(debugger);\n-                   } catch (DebuggerException exp) {\n-                      lastException = exp;\n-                   }\n-                   task = null;\n-                   workerThread.notifyAll();\n-                }\n-\n-                try {\n-                   workerThread.wait();\n-                } catch (InterruptedException x) {}\n-             }\n-          }\n-       }\n-\n-       public WorkerThreadTask execute(WorkerThreadTask task) throws DebuggerException {\n-          synchronized (workerThread) {\n-             this.task = task;\n-             workerThread.notifyAll();\n-             while (this.task != null) {\n-                try {\n-                   workerThread.wait();\n-                } catch (InterruptedException x) {}\n-             }\n-             if (lastException != null) {\n-                throw new DebuggerException(lastException.getMessage(), lastException);\n-             } else {\n-                return task;\n-             }\n-          }\n-       }\n-    }\n-\n-    private BsdDebuggerLocalWorkerThread workerThread = null;\n-\n-    \/\/----------------------------------------------------------------------\n-    \/\/ Implementation of Debugger interface\n-    \/\/\n-\n-    \/** <P> machDesc may not be null. <\/P>\n-\n-    <P> useCache should be set to true if debugging is being done\n-    locally, and to false if the debugger is being created for the\n-    purpose of supporting remote debugging. <\/P> *\/\n-    public BsdDebuggerLocal(MachineDescription machDesc,\n-                              boolean useCache) throws DebuggerException {\n-        this.machDesc = machDesc;\n-        utils = new DebuggerUtilities(machDesc.getAddressSize(),\n-                                      machDesc.isBigEndian(),\n-                                      machDesc.supports32bitAlignmentOf64bitTypes());\n-\n-        if (useCache) {\n-            \/\/ This is a cache of 64k of 4K pages, or 256 MB.\n-            initCache(4096, parseCacheNumPagesProperty(1024 * 64));\n-        }\n-\n-        isDarwin = getOS().equals(\"darwin\");\n-        workerThread = new BsdDebuggerLocalWorkerThread(this);\n-        workerThread.start();\n-    }\n-\n-    \/** From the Debugger interface via JVMDebugger *\/\n-    public boolean hasProcessList() throws DebuggerException {\n-        return false;\n-    }\n-\n-    \/** From the Debugger interface via JVMDebugger *\/\n-    public List<ProcessInfo> getProcessList() throws DebuggerException {\n-        throw new DebuggerException(\"getProcessList not implemented yet\");\n-    }\n-\n-    private void checkAttached() throws DebuggerException {\n-        if (attached) {\n-            if (isCore) {\n-                throw new DebuggerException(\"attached to a core dump already\");\n-            } else {\n-                throw new DebuggerException(\"attached to a process already\");\n-            }\n-        }\n-    }\n-\n-    private void requireAttach() {\n-        if (! attached) {\n-            throw new RuntimeException(\"not attached to a process or a core!\");\n-        }\n-    }\n-\n-    \/* called from attach methods *\/\n-    private void findABIVersion() throws DebuggerException {\n-        String libjvmName = isDarwin ? \"libjvm.dylib\" : \"libjvm.so\";\n-        String javaThreadVt = isDarwin ? \"_vt_10JavaThread\" : \"__vt_10JavaThread\";\n-        if (lookupByName0(libjvmName, javaThreadVt) != 0) {\n-            \/\/ old C++ ABI\n-            useGCC32ABI = false;\n-        } else {\n-            \/\/ new C++ ABI\n-            useGCC32ABI = true;\n-        }\n-    }\n-\n-    private void fillJavaThreadList() {\n-      \/\/ TODO: thread list on macOS is now supported for corefile only.\n-      if (!isCore && isDarwin) {\n-          javaThreadList = Collections.emptyList();\n-      } else {\n-          Threads threads = VM.getVM().getThreads();\n-          javaThreadList = IntStream.range(0, threads.getNumberOfThreads())\n-                                    .mapToObj(threads::getJavaThreadAt)\n-                                    .toList();\n-      }\n-    }\n-\n-    \/** From the Debugger interface via JVMDebugger *\/\n-    public synchronized void attach(int processID) throws DebuggerException {\n-        checkAttached();\n-        loadObjectList = new ArrayList<>();\n-        class AttachTask implements WorkerThreadTask {\n-           int pid;\n-           public void doit(BsdDebuggerLocal debugger) {\n-              debugger.attach0(pid);\n-              debugger.attached = true;\n-              debugger.isCore = false;\n-              findABIVersion();\n-           }\n-        }\n-\n-        AttachTask task = new AttachTask();\n-        task.pid = processID;\n-        workerThread.execute(task);\n-    }\n-\n-    \/** From the Debugger interface via JVMDebugger *\/\n-    public synchronized void attach(String execName, String coreName) {\n-        checkAttached();\n-        loadObjectList = new ArrayList<>();\n-        attach0(execName, coreName);\n-        attached = true;\n-        isCore = true;\n-        findABIVersion();\n-    }\n-\n-    \/** From the Debugger interface via JVMDebugger *\/\n-    public synchronized boolean detach() {\n-        if (!attached) {\n-            return false;\n-        }\n-\n-        javaThreadList = null;\n-        loadObjectList = null;\n-\n-        if (isCore) {\n-            detach0();\n-            attached = false;\n-            return true;\n-        } else {\n-            class DetachTask implements WorkerThreadTask {\n-                boolean result = false;\n-\n-                public void doit(BsdDebuggerLocal debugger) {\n-                    debugger.detach0();\n-                    debugger.attached = false;\n-                    result = true;\n-                }\n-            }\n-\n-            DetachTask task = new DetachTask();\n-            workerThread.execute(task);\n-            return task.result;\n-        }\n-    }\n-\n-    \/** From the Debugger interface via JVMDebugger *\/\n-    public Address parseAddress(String addressString)\n-            throws NumberFormatException {\n-        long addr = utils.scanAddress(addressString);\n-        if (addr == 0) {\n-            return null;\n-        }\n-        return new BsdAddress(this, addr);\n-    }\n-\n-    \/** From the Debugger interface via JVMDebugger *\/\n-    public String getOS() {\n-        return PlatformInfo.getOS();\n-    }\n-\n-    \/** From the Debugger interface via JVMDebugger *\/\n-    public String getCPU() {\n-        return PlatformInfo.getCPU();\n-    }\n-\n-    public boolean hasConsole() throws DebuggerException {\n-        return false;\n-    }\n-\n-    public String consoleExecuteCommand(String cmd) throws DebuggerException {\n-        throw new DebuggerException(\"No debugger console available on Bsd\");\n-    }\n-\n-    public String getConsolePrompt() throws DebuggerException {\n-        return null;\n-    }\n-\n-    \/* called from lookup *\/\n-    private long handleGCC32ABI(long addr, String symbol) throws DebuggerException {\n-        if (useGCC32ABI && symbol.startsWith(\"_ZTV\")) {\n-            return addr + (2 * machDesc.getAddressSize());\n-        } else {\n-            return addr;\n-        }\n-    }\n-\n-    \/** From the SymbolLookup interface via Debugger and JVMDebugger *\/\n-    public synchronized Address lookup(String objectName, String symbol) {\n-        requireAttach();\n-        if (!attached) {\n-            return null;\n-        }\n-\n-        if (isCore) {\n-            \/\/ MacOSX symbol with \"_\" as leading\n-            long addr = lookupByName0(objectName, isDarwin ? \"_\" + symbol : symbol);\n-            return (addr == 0)? null : new BsdAddress(this, handleGCC32ABI(addr, symbol));\n-        } else {\n-            class LookupByNameTask implements WorkerThreadTask {\n-                String objectName, symbol;\n-                Address result;\n-\n-                public void doit(BsdDebuggerLocal debugger) {\n-                    long addr = debugger.lookupByName0(objectName, symbol);\n-                    result = (addr == 0 ? null : new BsdAddress(debugger, handleGCC32ABI(addr, symbol)));\n-                }\n-            }\n-\n-            LookupByNameTask task = new LookupByNameTask();\n-            task.objectName = objectName;\n-            task.symbol = symbol;\n-            workerThread.execute(task);\n-            return task.result;\n-        }\n-    }\n-\n-    \/** From the SymbolLookup interface via Debugger and JVMDebugger *\/\n-    public synchronized OopHandle lookupOop(String objectName, String symbol) {\n-        Address addr = lookup(objectName, symbol);\n-        if (addr == null) {\n-            return null;\n-        }\n-        return addr.addOffsetToAsOopHandle(0);\n-    }\n-\n-    \/** From the Debugger interface *\/\n-    public MachineDescription getMachineDescription() {\n-        return machDesc;\n-    }\n-\n-    \/\/----------------------------------------------------------------------\n-    \/\/ Implementation of ThreadAccess interface\n-    \/\/\n-\n-    \/** From the ThreadAccess interface via Debugger and JVMDebugger *\/\n-    public ThreadProxy getThreadForIdentifierAddress(Address threadIdAddr, Address uniqueThreadIdAddr) {\n-        return new BsdThread(this, threadIdAddr, uniqueThreadIdAddr);\n-    }\n-\n-    @Override\n-    public ThreadProxy getThreadForIdentifierAddress(Address addr) {\n-        throw new RuntimeException(\"unimplemented\");\n-    }\n-\n-    \/** From the ThreadAccess interface via Debugger and JVMDebugger *\/\n-    public ThreadProxy getThreadForThreadId(long id) {\n-        return new BsdThread(this, id);\n-    }\n-\n-    \/\/----------------------------------------------------------------------\n-    \/\/ Internal routines (for implementation of BsdAddress).\n-    \/\/ These must not be called until the MachineDescription has been set up.\n-    \/\/\n-\n-    \/** From the BsdDebugger interface *\/\n-    public String addressValueToString(long address) {\n-        return utils.addressValueToString(address);\n-    }\n-\n-    \/** From the BsdDebugger interface *\/\n-    public BsdAddress readAddress(long address)\n-            throws UnmappedAddressException, UnalignedAddressException {\n-        long value = readAddressValue(address);\n-        return (value == 0 ? null : new BsdAddress(this, value));\n-    }\n-    public BsdAddress readCompOopAddress(long address)\n-            throws UnmappedAddressException, UnalignedAddressException {\n-        long value = readCompOopAddressValue(address);\n-        return (value == 0 ? null : new BsdAddress(this, value));\n-    }\n-\n-    public BsdAddress readCompKlassAddress(long address)\n-            throws UnmappedAddressException, UnalignedAddressException {\n-        long value = readCompKlassAddressValue(address);\n-        return (value == 0 ? null : new BsdAddress(this, value));\n-    }\n-\n-    \/** From the BsdDebugger interface *\/\n-    public BsdOopHandle readOopHandle(long address)\n-            throws UnmappedAddressException, UnalignedAddressException,\n-                NotInHeapException {\n-        long value = readAddressValue(address);\n-        return (value == 0 ? null : new BsdOopHandle(this, value));\n-    }\n-    public BsdOopHandle readCompOopHandle(long address)\n-            throws UnmappedAddressException, UnalignedAddressException,\n-                NotInHeapException {\n-        long value = readCompOopAddressValue(address);\n-        return (value == 0 ? null : new BsdOopHandle(this, value));\n-    }\n-\n-    \/\/----------------------------------------------------------------------\n-    \/\/ Thread context access\n-    \/\/\n-\n-    public synchronized long[] getThreadIntegerRegisterSet(long unique_thread_id)\n-                                            throws DebuggerException {\n-        requireAttach();\n-        if (isCore) {\n-            return getThreadIntegerRegisterSet0(unique_thread_id);\n-        } else {\n-            class GetThreadIntegerRegisterSetTask implements WorkerThreadTask {\n-                long unique_thread_id;\n-                long[] result;\n-                public void doit(BsdDebuggerLocal debugger) {\n-                    result = debugger.getThreadIntegerRegisterSet0(unique_thread_id);\n-                }\n-            }\n-\n-            GetThreadIntegerRegisterSetTask task = new GetThreadIntegerRegisterSetTask();\n-            task.unique_thread_id = unique_thread_id;\n-            workerThread.execute(task);\n-            return task.result;\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------------\n-    \/\/ Address access. Can not be package private, but should only be\n-    \/\/ accessed by the architecture-specific subpackages.\n-\n-    \/** From the BsdDebugger interface *\/\n-    public long getAddressValue(Address addr) {\n-      if (addr == null) return 0;\n-      return addr.asLongValue();\n-    }\n-\n-    \/** From the BsdDebugger interface *\/\n-    public Address newAddress(long value) {\n-      if (value == 0) return null;\n-      return new BsdAddress(this, value);\n-    }\n-\n-    \/** From the BsdCDebugger interface *\/\n-    public List<ThreadProxy> getThreadList() {\n-      requireAttach();\n-      if (javaThreadList == null) {\n-        fillJavaThreadList();\n-      }\n-      return javaThreadList.stream()\n-                           .map(JavaThread::getThreadProxy)\n-                           .toList();\n-    }\n-\n-    \/** From the BsdCDebugger interface *\/\n-    public List<LoadObject> getLoadObjectList() {\n-      requireAttach();\n-      return loadObjectList;\n-    }\n-\n-    \/** From the BsdCDebugger interface *\/\n-    public synchronized ClosestSymbol lookup(long addr) {\n-       requireAttach();\n-       if (isCore) {\n-          return lookupByAddress0(addr);\n-       } else {\n-          class LookupByAddressTask implements WorkerThreadTask {\n-             long addr;\n-             ClosestSymbol result;\n-\n-             public void doit(BsdDebuggerLocal debugger) {\n-                 result = debugger.lookupByAddress0(addr);\n-             }\n-          }\n-\n-          LookupByAddressTask task = new LookupByAddressTask();\n-          task.addr = addr;\n-          workerThread.execute(task);\n-          return task.result;\n-       }\n-    }\n-\n-    public CDebugger getCDebugger() {\n-      if (cdbg == null) {\n-         cdbg = new BsdCDebugger(this);\n-      }\n-      return cdbg;\n-    }\n-\n-    \/** This reads bytes from the remote process. *\/\n-    public synchronized ReadResult readBytesFromProcess(long address,\n-            long numBytes) throws UnmappedAddressException, DebuggerException {\n-        requireAttach();\n-        if (isCore) {\n-            byte[] res = readBytesFromProcess0(address, numBytes);\n-            return (res != null)? new ReadResult(res) : new ReadResult(address);\n-        } else {\n-            class ReadBytesFromProcessTask implements WorkerThreadTask {\n-                long address, numBytes;\n-                ReadResult result;\n-                public void doit(BsdDebuggerLocal debugger) {\n-                    byte[] res = debugger.readBytesFromProcess0(address, numBytes);\n-                    if (res != null)\n-                        result = new ReadResult(res);\n-                    else\n-                        result = new ReadResult(address);\n-                }\n-            }\n-\n-            ReadBytesFromProcessTask task = new ReadBytesFromProcessTask();\n-            task.address = address;\n-            task.numBytes = numBytes;\n-            workerThread.execute(task);\n-            return task.result;\n-        }\n-    }\n-\n-    \/** this functions used for core file reading and called from native attach0,\n-        it returns an array of long integers as\n-        [thread_id, stack_start, stack_end, thread_id, stack_start, stack_end, ....] for\n-        all java threads recorded in Threads. *\/\n-    public long[] getJavaThreadsInfo() {\n-        requireAttach();\n-        if (javaThreadList == null) {\n-            fillJavaThreadList();\n-        }\n-        long[] result = new long[javaThreadList.size() * 3];    \/\/ triple\n-        long beg, end;\n-        int i = 0;\n-        for (var t : javaThreadList) {\n-            end = t.getStackBaseValue();\n-            beg = end - t.getStackSize();\n-            long uid = ((BsdThread)t.getThreadProxy()).getUniqueThreadId();\n-            result[i] = uid;\n-            result[i + 1] = beg;\n-            result[i + 2] = end;\n-            i += 3;\n-        }\n-        return result;\n-    }\n-\n-    static {\n-        System.loadLibrary(\"saproc\");\n-        init0();\n-    }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebuggerLocal.java","additions":0,"deletions":607,"binary":false,"changes":607,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd;\n-\n-import sun.jvm.hotspot.debugger.*;\n-\n-class BsdOopHandle extends BsdAddress implements OopHandle {\n-  BsdOopHandle(BsdDebugger debugger, long addr) {\n-    super(debugger, addr);\n-  }\n-\n-  public boolean equals(Object arg) {\n-    if (arg == null) {\n-      return false;\n-    }\n-\n-    if (!(arg instanceof BsdOopHandle)) {\n-      return false;\n-    }\n-\n-    return (addr == ((BsdAddress) arg).addr);\n-  }\n-\n-  public Address    addOffsetTo       (long offset) throws UnsupportedOperationException {\n-    throw new UnsupportedOperationException(\"addOffsetTo not applicable to OopHandles (interior object pointers not allowed)\");\n-  }\n-\n-  public Address    andWithMask(long mask) throws UnsupportedOperationException {\n-    throw new UnsupportedOperationException(\"andWithMask not applicable to OopHandles (i.e., anything but C addresses)\");\n-  }\n-\n-  public Address    orWithMask(long mask) throws UnsupportedOperationException {\n-    throw new UnsupportedOperationException(\"orWithMask not applicable to OopHandles (i.e., anything but C addresses)\");\n-  }\n-\n-  public Address    xorWithMask(long mask) throws UnsupportedOperationException {\n-    throw new UnsupportedOperationException(\"xorWithMask not applicable to OopHandles (i.e., anything but C addresses)\");\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdOopHandle.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd;\n-\n-import sun.jvm.hotspot.debugger.*;\n-\n-class BsdThread implements ThreadProxy {\n-    private BsdDebugger debugger;\n-    private int         thread_id;\n-    private long        unique_thread_id;\n-\n-    \/** The address argument must be the address of the _thread_id in the\n-        OSThread. It's value is result ::gettid() call. *\/\n-    BsdThread(BsdDebugger debugger, Address threadIdAddr, Address uniqueThreadIdAddr) {\n-        this.debugger = debugger;\n-        \/\/ FIXME: size of data fetched here should be configurable.\n-        \/\/ However, making it so would produce a dependency on the \"types\"\n-        \/\/ package from the debugger package, which is not desired.\n-        this.thread_id = (int) threadIdAddr.getCIntegerAt(0, 4, true);\n-        this.unique_thread_id = uniqueThreadIdAddr.getCIntegerAt(0, 8, true);\n-    }\n-\n-    BsdThread(BsdDebugger debugger, long id) {\n-        this.debugger = debugger;\n-        \/\/ use unique_thread_id to identify thread\n-        this.unique_thread_id = id;\n-    }\n-\n-    public boolean equals(Object obj) {\n-        if (!(obj instanceof BsdThread other)) {\n-            return false;\n-        }\n-\n-        return (other.unique_thread_id == unique_thread_id);\n-    }\n-\n-    public int hashCode() {\n-        return thread_id;\n-    }\n-\n-    public String toString() {\n-        return Integer.toString(thread_id);\n-    }\n-\n-    public ThreadContext getContext() throws IllegalThreadStateException {\n-        long[] data = debugger.getThreadIntegerRegisterSet(unique_thread_id);\n-        ThreadContext context = BsdThreadContextFactory.createThreadContext(debugger);\n-        \/\/ null means we failed to get the register set for some reason. The caller\n-        \/\/ is responsible for dealing with the set of null registers in that case.\n-        if (data != null) {\n-            for (int i = 0; i < data.length; i++) {\n-                context.setRegister(i, data[i]);\n-            }\n-        }\n-        return context;\n-    }\n-\n-    public boolean canSetContext() throws DebuggerException {\n-        return false;\n-    }\n-\n-    public void setContext(ThreadContext context)\n-      throws IllegalThreadStateException, DebuggerException {\n-        throw new DebuggerException(\"Unimplemented\");\n-    }\n-\n-    \/** this is not interface function, used in core file to get unique thread id on Macosx*\/\n-    public long getUniqueThreadId() {\n-        return unique_thread_id;\n-    }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdThread.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.bsd.aarch64.*;\n-import sun.jvm.hotspot.debugger.bsd.amd64.*;\n-\n-class BsdThreadContextFactory {\n-   static ThreadContext createThreadContext(BsdDebugger dbg) {\n-      String cpu = dbg.getCPU();\n-      if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n-         return new BsdAMD64ThreadContext(dbg);\n-      } else if (cpu.equals(\"aarch64\")) {\n-         return new BsdAARCH64ThreadContext(dbg);\n-      } else {\n-         throw new RuntimeException(\"cpu \" + cpu + \" is not yet supported\");\n-      }\n-   }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdThreadContextFactory.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd.aarch64;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.aarch64.*;\n-import sun.jvm.hotspot.debugger.bsd.*;\n-\n-public class BsdAARCH64ThreadContext extends AARCH64ThreadContext {\n-  private BsdDebugger debugger;\n-\n-  public BsdAARCH64ThreadContext(BsdDebugger debugger) {\n-    super();\n-    this.debugger = debugger;\n-  }\n-\n-  public void setRegisterAsAddress(int index, Address value) {\n-    setRegister(index, debugger.getAddressValue(value));\n-  }\n-\n-  public Address getRegisterAsAddress(int index) {\n-    return debugger.newAddress(getRegister(index));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/aarch64\/BsdAARCH64ThreadContext.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd.amd64;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.amd64.*;\n-import sun.jvm.hotspot.debugger.bsd.*;\n-import sun.jvm.hotspot.debugger.cdbg.*;\n-import sun.jvm.hotspot.debugger.cdbg.basic.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.runtime.amd64.*;\n-\n-public final class BsdAMD64CFrame extends BasicCFrame {\n-   public BsdAMD64CFrame(BsdDebugger dbg, Address rsp, Address rbp, Address rip) {\n-      super(dbg.getCDebugger());\n-      this.rsp = rsp;\n-      this.rbp = rbp;\n-      this.rip = rip;\n-      this.dbg = dbg;\n-   }\n-\n-   \/\/ override base class impl to avoid ELF parsing\n-   public ClosestSymbol closestSymbolToPC() {\n-      \/\/ try native lookup in debugger.\n-      return dbg.lookup(dbg.getAddressValue(pc()));\n-   }\n-\n-   public Address pc() {\n-      return rip;\n-   }\n-\n-   public Address localVariableBase() {\n-      return rbp;\n-   }\n-\n-   @Override\n-   public CFrame sender(ThreadProxy thread) {\n-      return sender(thread, null, null, null);\n-   }\n-\n-   @Override\n-   public CFrame sender(ThreadProxy thread, Address sp, Address fp, Address pc) {\n-      \/\/ Check fp\n-      \/\/ Skip if both fp and pc are given - do not need to load from rbp.\n-      if (fp == null && pc == null) {\n-        if (rbp == null) {\n-          return null;\n-        }\n-\n-        \/\/ Check alignment of rbp\n-        if (dbg.getAddressValue(rbp) % ADDRESS_SIZE != 0) {\n-          return null;\n-        }\n-      }\n-\n-      Address nextRSP = sp != null ? sp : rbp.addOffsetTo(2 * ADDRESS_SIZE);\n-      if (nextRSP == null) {\n-        return null;\n-      }\n-      Address nextRBP = fp != null ? fp : rbp.getAddressAt(0);\n-      if (nextRBP == null) {\n-        return null;\n-      }\n-      Address nextPC  = pc != null ? pc : rbp.getAddressAt(ADDRESS_SIZE);\n-      if (nextPC == null) {\n-        return null;\n-      }\n-      return new BsdAMD64CFrame(dbg, nextRSP, nextRBP, nextPC);\n-   }\n-\n-   @Override\n-   public Frame toFrame() {\n-      return new AMD64Frame(rsp, rbp, rip);\n-   }\n-\n-   \/\/ package\/class internals only\n-   private static final int ADDRESS_SIZE = 8;\n-   private Address rsp;\n-   private Address rip;\n-   private Address rbp;\n-   private BsdDebugger dbg;\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/amd64\/BsdAMD64CFrame.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd.amd64;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.amd64.*;\n-import sun.jvm.hotspot.debugger.bsd.*;\n-\n-public class BsdAMD64ThreadContext extends AMD64ThreadContext {\n-  private BsdDebugger debugger;\n-\n-  public BsdAMD64ThreadContext(BsdDebugger debugger) {\n-    super();\n-    this.debugger = debugger;\n-  }\n-\n-  public void setRegisterAsAddress(int index, Address value) {\n-    setRegister(index, debugger.getAddressValue(value));\n-  }\n-\n-  public Address getRegisterAsAddress(int index) {\n-    return debugger.newAddress(getRegister(index));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/amd64\/BsdAMD64ThreadContext.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -25,1 +25,1 @@\n-package sun.jvm.hotspot.debugger.bsd;\n+package sun.jvm.hotspot.debugger.macosx;\n@@ -29,2 +29,2 @@\n-class BsdAddress implements Address {\n-    protected BsdDebugger debugger;\n+class MacosxAddress implements Address {\n+    protected MacosxDebugger debugger;\n@@ -33,1 +33,1 @@\n-    BsdAddress(BsdDebugger debugger, long addr) {\n+    MacosxAddress(MacosxDebugger debugger, long addr) {\n@@ -47,1 +47,1 @@\n-        if (!(arg instanceof BsdAddress)) {\n+        if (!(arg instanceof MacosxAddress)) {\n@@ -51,1 +51,1 @@\n-        return (addr == ((BsdAddress) arg).addr);\n+        return (addr == ((MacosxAddress) arg).addr);\n@@ -185,1 +185,1 @@\n-    return new BsdAddress(debugger, value);\n+    return new MacosxAddress(debugger, value);\n@@ -193,1 +193,1 @@\n-    return new BsdOopHandle(debugger, value);\n+    return new MacosxOopHandle(debugger, value);\n@@ -202,1 +202,1 @@\n-    return addr - ((BsdAddress) arg).addr;\n+    return addr - ((MacosxAddress) arg).addr;\n@@ -214,1 +214,1 @@\n-    BsdAddress arg = (BsdAddress) a;\n+    MacosxAddress arg = (MacosxAddress) a;\n@@ -228,1 +228,1 @@\n-    BsdAddress arg = (BsdAddress) a;\n+    MacosxAddress arg = (MacosxAddress) a;\n@@ -242,1 +242,1 @@\n-    BsdAddress arg = (BsdAddress) a;\n+    MacosxAddress arg = (MacosxAddress) a;\n@@ -256,1 +256,1 @@\n-    BsdAddress arg = (BsdAddress) a;\n+    MacosxAddress arg = (MacosxAddress) a;\n@@ -271,1 +271,1 @@\n-    return new BsdAddress(debugger, value);\n+    return new MacosxAddress(debugger, value);\n@@ -279,1 +279,1 @@\n-    return new BsdAddress(debugger, value);\n+    return new MacosxAddress(debugger, value);\n@@ -287,1 +287,1 @@\n-    return new BsdAddress(debugger, value);\n+    return new MacosxAddress(debugger, value);\n@@ -307,4 +307,4 @@\n-    BsdAddress p1 = new BsdAddress(null, 0x7FFFFFFFFFFFFFF0L);\n-    BsdAddress p2 = (BsdAddress) p1.addOffsetTo(10);\n-    BsdAddress n1 = (BsdAddress) p2.addOffsetTo(10);\n-    BsdAddress n2 = (BsdAddress) n1.addOffsetTo(10);\n+    MacosxAddress p1 = new MacosxAddress(null, 0x7FFFFFFFFFFFFFF0L);\n+    MacosxAddress p2 = (MacosxAddress) p1.addOffsetTo(10);\n+    MacosxAddress n1 = (MacosxAddress) p2.addOffsetTo(10);\n+    MacosxAddress n2 = (MacosxAddress) n1.addOffsetTo(10);\n@@ -396,1 +396,1 @@\n-    System.err.println(\"BsdAddress: all tests passed successfully.\");\n+    System.err.println(\"MacosxAddress: all tests passed successfully.\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/MacosxAddress.java","additions":21,"deletions":21,"binary":false,"changes":42,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdAddress.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package sun.jvm.hotspot.debugger.bsd;\n+package sun.jvm.hotspot.debugger.macosx;\n@@ -34,2 +34,2 @@\n-import sun.jvm.hotspot.debugger.bsd.amd64.*;\n-import sun.jvm.hotspot.debugger.bsd.aarch64.*;\n+import sun.jvm.hotspot.debugger.macosx.amd64.*;\n+import sun.jvm.hotspot.debugger.macosx.aarch64.*;\n@@ -38,2 +38,2 @@\n-class BsdCDebugger implements CDebugger {\n-  private BsdDebugger dbg;\n+class MacosxCDebugger implements CDebugger {\n+  private MacosxDebugger dbg;\n@@ -41,1 +41,1 @@\n-  BsdCDebugger(BsdDebugger dbg) {\n+  MacosxCDebugger(MacosxDebugger dbg) {\n@@ -95,1 +95,1 @@\n-       return new BsdAMD64CFrame(dbg, rsp, rbp, pc);\n+       return new MacosxAMD64CFrame(dbg, rsp, rbp, pc);\n@@ -104,1 +104,1 @@\n-       return new BsdAARCH64CFrame(dbg, sp, fp, pc);\n+       return new MacosxAARCH64CFrame(dbg, sp, fp, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/MacosxCDebugger.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdCDebugger.java","status":"renamed"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.macosx;\n+\n+import java.util.List;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.cdbg.*;\n+\n+\/** An extension of the JVMDebugger interface with a few additions to\n+    support 32-bit vs. 64-bit debugging as well as features required\n+    by the architecture-specific subpackages. *\/\n+\n+public interface MacosxDebugger extends JVMDebugger {\n+  public String       addressValueToString(long address) throws DebuggerException;\n+  public boolean      readJBoolean(long address) throws DebuggerException;\n+  public byte         readJByte(long address) throws DebuggerException;\n+  public char         readJChar(long address) throws DebuggerException;\n+  public double       readJDouble(long address) throws DebuggerException;\n+  public float        readJFloat(long address) throws DebuggerException;\n+  public int          readJInt(long address) throws DebuggerException;\n+  public long         readJLong(long address) throws DebuggerException;\n+  public short        readJShort(long address) throws DebuggerException;\n+  public long         readCInteger(long address, long numBytes, boolean isUnsigned)\n+    throws DebuggerException;\n+  public MacosxAddress readAddress(long address) throws DebuggerException;\n+  public MacosxAddress readCompOopAddress(long address) throws DebuggerException;\n+  public MacosxAddress readCompKlassAddress(long address) throws DebuggerException;\n+  public MacosxOopHandle readOopHandle(long address) throws DebuggerException;\n+  public MacosxOopHandle readCompOopHandle(long address) throws DebuggerException;\n+  public long[]       getThreadIntegerRegisterSet(long unique_thread_id) throws DebuggerException;\n+  public long         getAddressValue(Address addr) throws DebuggerException;\n+\n+  \/\/ For MacosxCDebugger\n+  public List<ThreadProxy> getThreadList();\n+  public List<LoadObject> getLoadObjectList();\n+  public ClosestSymbol lookup(long address);\n+\n+  \/\/ NOTE: this interface implicitly contains the following methods:\n+  \/\/ From the Debugger interface via JVMDebugger\n+  \/\/   public void attach(int processID) throws DebuggerException;\n+  \/\/   public void attach(String executableName, String coreFileName) throws DebuggerException;\n+  \/\/   public boolean detach();\n+  \/\/   public Address parseAddress(String addressString) throws NumberFormatException;\n+  \/\/   public String getOS();\n+  \/\/   public String getCPU();\n+  \/\/ From the SymbolLookup interface via Debugger and JVMDebugger\n+  \/\/   public Address lookup(String objectName, String symbol);\n+  \/\/   public OopHandle lookupOop(String objectName, String symbol);\n+  \/\/ From the JVMDebugger interface\n+  \/\/   public void configureJavaPrimitiveTypeSizes(long jbooleanSize,\n+  \/\/                                               long jbyteSize,\n+  \/\/                                               long jcharSize,\n+  \/\/                                               long jdoubleSize,\n+  \/\/                                               long jfloatSize,\n+  \/\/                                               long jintSize,\n+  \/\/                                               long jlongSize,\n+  \/\/                                               long jshortSize);\n+  \/\/ From the ThreadAccess interface via Debugger and JVMDebugger\n+  \/\/   public ThreadProxy getThreadForIdentifierAddress(Address addr);\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/MacosxDebugger.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,617 @@\n+\/*\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.macosx;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.debugger.DebuggerBase;\n+import sun.jvm.hotspot.debugger.DebuggerException;\n+import sun.jvm.hotspot.debugger.DebuggerUtilities;\n+import sun.jvm.hotspot.debugger.MachineDescription;\n+import sun.jvm.hotspot.debugger.NotInHeapException;\n+import sun.jvm.hotspot.debugger.OopHandle;\n+import sun.jvm.hotspot.debugger.ProcessInfo;\n+import sun.jvm.hotspot.debugger.ReadResult;\n+import sun.jvm.hotspot.debugger.ThreadProxy;\n+import sun.jvm.hotspot.debugger.UnalignedAddressException;\n+import sun.jvm.hotspot.debugger.UnmappedAddressException;\n+import sun.jvm.hotspot.debugger.cdbg.CDebugger;\n+import sun.jvm.hotspot.debugger.cdbg.ClosestSymbol;\n+import sun.jvm.hotspot.debugger.cdbg.LoadObject;\n+import sun.jvm.hotspot.runtime.JavaThread;\n+import sun.jvm.hotspot.runtime.Threads;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.utilities.PlatformInfo;\n+\n+\/** <P> An implementation of the JVMDebugger interface. The basic debug\n+    facilities are implemented through ptrace interface in the JNI code\n+    (libsaproc.so). Library maps and symbol table management are done in\n+    JNI. <\/P>\n+\n+    <P> <B>NOTE<\/B> that since we have the notion of fetching \"Java\n+    primitive types\" from the remote process (which might have\n+    different sizes than we expect) we have a bootstrapping\n+    problem. We need to know the sizes of these types before we can\n+    fetch them. The current implementation solves this problem by\n+    requiring that it be configured with these type sizes before they\n+    can be fetched. The readJ(Type) routines here will throw a\n+    RuntimeException if they are called before the debugger is\n+    configured with the Java primitive type sizes. <\/P> *\/\n+\n+@SuppressWarnings(\"restricted\")\n+public class MacosxDebuggerLocal extends DebuggerBase implements MacosxDebugger {\n+    private boolean useGCC32ABI;\n+    private boolean attached;\n+    private long    p_ps_prochandle;      \/\/ native debugger handle\n+    private long    symbolicator;         \/\/ macosx symbolicator handle\n+    private long    task;                 \/\/ macosx task handle\n+    private boolean isCore;\n+    private boolean isDarwin;             \/\/ variant for macosx\n+\n+    \/\/ CDebugger support\n+    private MacosxCDebugger cdbg;\n+\n+    \/\/ loadObjectList is filled by attach0 method\n+    private List<LoadObject> loadObjectList;\n+\n+    private List<JavaThread> javaThreadList;\n+\n+    \/\/ called by native method lookupByAddress0\n+    private ClosestSymbol createClosestSymbol(String name, long offset) {\n+       return new ClosestSymbol(name, offset);\n+    }\n+\n+    \/\/ called by native method attach0\n+    private LoadObject createLoadObject(String fileName, long size,\n+                                        long base) {\n+       Address baseAddr = newAddress(base);\n+       return new SharedObject(this, fileName, size, baseAddr);\n+    }\n+\n+    \/\/ native methods\n+\n+    private static native void init0()\n+                                throws DebuggerException;\n+    private native void attach0(int pid)\n+                                throws DebuggerException;\n+    private native void attach0(String execName, String coreName)\n+                                throws DebuggerException;\n+    private native void detach0()\n+                                throws DebuggerException;\n+    private native long lookupByName0(String objectName, String symbol)\n+                                throws DebuggerException;\n+    private native ClosestSymbol lookupByAddress0(long address)\n+                                throws DebuggerException;\n+    private native long[] getThreadIntegerRegisterSet0(long unique_thread_id)\n+                                throws DebuggerException;\n+    private native byte[] readBytesFromProcess0(long address, long numBytes)\n+                                throws DebuggerException;\n+    public static native int  getAddressSize() ;\n+\n+    public native String demangle(String sym);\n+\n+    public native long findLibPtrByAddress0(long pc);\n+\n+    public Address findLibPtrByAddress(Address pc) {\n+      long ptr = findLibPtrByAddress0(pc.asLongValue());\n+      return (ptr == 0L) ? null\n+                         : new MacosxAddress(this, ptr);\n+    }\n+\n+    \/\/ Note on Macosx threads are really processes. When target process is\n+    \/\/ attached by a serviceability agent thread, only that thread can do\n+    \/\/ ptrace operations on the target. This is because from kernel's point\n+    \/\/ view, other threads are just separate processes and they are not\n+    \/\/ attached to the target. When they attempt to make ptrace calls,\n+    \/\/ an ESRCH error will be returned as kernel believes target is not\n+    \/\/ being traced by the caller.\n+    \/\/ To work around the problem, we use a worker thread here to handle\n+    \/\/ all JNI functions that are making ptrace calls.\n+\n+    interface WorkerThreadTask {\n+       public void doit(MacosxDebuggerLocal debugger) throws DebuggerException;\n+    }\n+\n+    class MacosxDebuggerLocalWorkerThread extends Thread {\n+       MacosxDebuggerLocal debugger;\n+       WorkerThreadTask task;\n+       DebuggerException lastException;\n+\n+       public MacosxDebuggerLocalWorkerThread(MacosxDebuggerLocal debugger) {\n+         this.debugger = debugger;\n+         setDaemon(true);\n+       }\n+\n+       public void run() {\n+          synchronized (workerThread) {\n+             for (;;) {\n+                if (task != null) {\n+                   lastException = null;\n+                   try {\n+                      task.doit(debugger);\n+                   } catch (DebuggerException exp) {\n+                      lastException = exp;\n+                   }\n+                   task = null;\n+                   workerThread.notifyAll();\n+                }\n+\n+                try {\n+                   workerThread.wait();\n+                } catch (InterruptedException x) {}\n+             }\n+          }\n+       }\n+\n+       public WorkerThreadTask execute(WorkerThreadTask task) throws DebuggerException {\n+          synchronized (workerThread) {\n+             this.task = task;\n+             workerThread.notifyAll();\n+             while (this.task != null) {\n+                try {\n+                   workerThread.wait();\n+                } catch (InterruptedException x) {}\n+             }\n+             if (lastException != null) {\n+                throw new DebuggerException(lastException.getMessage(), lastException);\n+             } else {\n+                return task;\n+             }\n+          }\n+       }\n+    }\n+\n+    private MacosxDebuggerLocalWorkerThread workerThread = null;\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Implementation of Debugger interface\n+    \/\/\n+\n+    \/** <P> machDesc may not be null. <\/P>\n+\n+    <P> useCache should be set to true if debugging is being done\n+    locally, and to false if the debugger is being created for the\n+    purpose of supporting remote debugging. <\/P> *\/\n+    public MacosxDebuggerLocal(MachineDescription machDesc,\n+                              boolean useCache) throws DebuggerException {\n+        this.machDesc = machDesc;\n+        utils = new DebuggerUtilities(machDesc.getAddressSize(),\n+                                      machDesc.isBigEndian(),\n+                                      machDesc.supports32bitAlignmentOf64bitTypes());\n+\n+        if (useCache) {\n+            \/\/ This is a cache of 64k of 4K pages, or 256 MB.\n+            initCache(4096, parseCacheNumPagesProperty(1024 * 64));\n+        }\n+\n+        isDarwin = getOS().equals(\"darwin\");\n+        workerThread = new MacosxDebuggerLocalWorkerThread(this);\n+        workerThread.start();\n+    }\n+\n+    \/** From the Debugger interface via JVMDebugger *\/\n+    public boolean hasProcessList() throws DebuggerException {\n+        return false;\n+    }\n+\n+    \/** From the Debugger interface via JVMDebugger *\/\n+    public List<ProcessInfo> getProcessList() throws DebuggerException {\n+        throw new DebuggerException(\"getProcessList not implemented yet\");\n+    }\n+\n+    private void checkAttached() throws DebuggerException {\n+        if (attached) {\n+            if (isCore) {\n+                throw new DebuggerException(\"attached to a core dump already\");\n+            } else {\n+                throw new DebuggerException(\"attached to a process already\");\n+            }\n+        }\n+    }\n+\n+    private void requireAttach() {\n+        if (! attached) {\n+            throw new RuntimeException(\"not attached to a process or a core!\");\n+        }\n+    }\n+\n+    \/* called from attach methods *\/\n+    private void findABIVersion() throws DebuggerException {\n+        String libjvmName = isDarwin ? \"libjvm.dylib\" : \"libjvm.so\";\n+        String javaThreadVt = isDarwin ? \"_vt_10JavaThread\" : \"__vt_10JavaThread\";\n+        if (lookupByName0(libjvmName, javaThreadVt) != 0) {\n+            \/\/ old C++ ABI\n+            useGCC32ABI = false;\n+        } else {\n+            \/\/ new C++ ABI\n+            useGCC32ABI = true;\n+        }\n+    }\n+\n+    private void fillJavaThreadList() {\n+      \/\/ TODO: thread list on macOS is now supported for corefile only.\n+      if (!isCore && isDarwin) {\n+          javaThreadList = Collections.emptyList();\n+      } else {\n+          Threads threads = VM.getVM().getThreads();\n+          javaThreadList = IntStream.range(0, threads.getNumberOfThreads())\n+                                    .mapToObj(threads::getJavaThreadAt)\n+                                    .toList();\n+      }\n+    }\n+\n+    \/** From the Debugger interface via JVMDebugger *\/\n+    public synchronized void attach(int processID) throws DebuggerException {\n+        checkAttached();\n+        loadObjectList = new ArrayList<>();\n+        class AttachTask implements WorkerThreadTask {\n+           int pid;\n+           public void doit(MacosxDebuggerLocal debugger) {\n+              debugger.attach0(pid);\n+              debugger.attached = true;\n+              debugger.isCore = false;\n+              findABIVersion();\n+           }\n+        }\n+\n+        AttachTask task = new AttachTask();\n+        task.pid = processID;\n+        workerThread.execute(task);\n+    }\n+\n+    \/** From the Debugger interface via JVMDebugger *\/\n+    public synchronized void attach(String execName, String coreName) {\n+        checkAttached();\n+        loadObjectList = new ArrayList<>();\n+        attach0(execName, coreName);\n+        attached = true;\n+        isCore = true;\n+        findABIVersion();\n+    }\n+\n+    \/** From the Debugger interface via JVMDebugger *\/\n+    public synchronized boolean detach() {\n+        if (!attached) {\n+            return false;\n+        }\n+\n+        javaThreadList = null;\n+        loadObjectList = null;\n+\n+        if (isCore) {\n+            detach0();\n+            attached = false;\n+            return true;\n+        } else {\n+            class DetachTask implements WorkerThreadTask {\n+                boolean result = false;\n+\n+                public void doit(MacosxDebuggerLocal debugger) {\n+                    debugger.detach0();\n+                    debugger.attached = false;\n+                    result = true;\n+                }\n+            }\n+\n+            DetachTask task = new DetachTask();\n+            workerThread.execute(task);\n+            return task.result;\n+        }\n+    }\n+\n+    \/** From the Debugger interface via JVMDebugger *\/\n+    public Address parseAddress(String addressString)\n+            throws NumberFormatException {\n+        long addr = utils.scanAddress(addressString);\n+        if (addr == 0) {\n+            return null;\n+        }\n+        return new MacosxAddress(this, addr);\n+    }\n+\n+    \/** From the Debugger interface via JVMDebugger *\/\n+    public String getOS() {\n+        return PlatformInfo.getOS();\n+    }\n+\n+    \/** From the Debugger interface via JVMDebugger *\/\n+    public String getCPU() {\n+        return PlatformInfo.getCPU();\n+    }\n+\n+    public boolean hasConsole() throws DebuggerException {\n+        return false;\n+    }\n+\n+    public String consoleExecuteCommand(String cmd) throws DebuggerException {\n+        throw new DebuggerException(\"No debugger console available on Macosx\");\n+    }\n+\n+    public String getConsolePrompt() throws DebuggerException {\n+        return null;\n+    }\n+\n+    \/* called from lookup *\/\n+    private long handleGCC32ABI(long addr, String symbol) throws DebuggerException {\n+        if (useGCC32ABI && symbol.startsWith(\"_ZTV\")) {\n+            return addr + (2 * machDesc.getAddressSize());\n+        } else {\n+            return addr;\n+        }\n+    }\n+\n+    \/** From the SymbolLookup interface via Debugger and JVMDebugger *\/\n+    public synchronized Address lookup(String objectName, String symbol) {\n+        requireAttach();\n+        if (!attached) {\n+            return null;\n+        }\n+\n+        if (isCore) {\n+            \/\/ MacOSX symbol with \"_\" as leading\n+            long addr = lookupByName0(objectName, isDarwin ? \"_\" + symbol : symbol);\n+            return (addr == 0)? null : new MacosxAddress(this, handleGCC32ABI(addr, symbol));\n+        } else {\n+            class LookupByNameTask implements WorkerThreadTask {\n+                String objectName, symbol;\n+                Address result;\n+\n+                public void doit(MacosxDebuggerLocal debugger) {\n+                    long addr = debugger.lookupByName0(objectName, symbol);\n+                    result = (addr == 0 ? null : new MacosxAddress(debugger, handleGCC32ABI(addr, symbol)));\n+                }\n+            }\n+\n+            LookupByNameTask task = new LookupByNameTask();\n+            task.objectName = objectName;\n+            task.symbol = symbol;\n+            workerThread.execute(task);\n+            return task.result;\n+        }\n+    }\n+\n+    \/** From the SymbolLookup interface via Debugger and JVMDebugger *\/\n+    public synchronized OopHandle lookupOop(String objectName, String symbol) {\n+        Address addr = lookup(objectName, symbol);\n+        if (addr == null) {\n+            return null;\n+        }\n+        return addr.addOffsetToAsOopHandle(0);\n+    }\n+\n+    \/** From the Debugger interface *\/\n+    public MachineDescription getMachineDescription() {\n+        return machDesc;\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Implementation of ThreadAccess interface\n+    \/\/\n+\n+    \/** From the ThreadAccess interface via Debugger and JVMDebugger *\/\n+    public ThreadProxy getThreadForIdentifierAddress(Address threadIdAddr, Address uniqueThreadIdAddr) {\n+        return new MacosxThread(this, threadIdAddr, uniqueThreadIdAddr);\n+    }\n+\n+    @Override\n+    public ThreadProxy getThreadForIdentifierAddress(Address addr) {\n+        throw new RuntimeException(\"unimplemented\");\n+    }\n+\n+    \/** From the ThreadAccess interface via Debugger and JVMDebugger *\/\n+    public ThreadProxy getThreadForThreadId(long id) {\n+        return new MacosxThread(this, id);\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Internal routines (for implementation of MacosxAddress).\n+    \/\/ These must not be called until the MachineDescription has been set up.\n+    \/\/\n+\n+    \/** From the MacosxDebugger interface *\/\n+    public String addressValueToString(long address) {\n+        return utils.addressValueToString(address);\n+    }\n+\n+    \/** From the MacosxDebugger interface *\/\n+    public MacosxAddress readAddress(long address)\n+            throws UnmappedAddressException, UnalignedAddressException {\n+        long value = readAddressValue(address);\n+        return (value == 0 ? null : new MacosxAddress(this, value));\n+    }\n+    public MacosxAddress readCompOopAddress(long address)\n+            throws UnmappedAddressException, UnalignedAddressException {\n+        long value = readCompOopAddressValue(address);\n+        return (value == 0 ? null : new MacosxAddress(this, value));\n+    }\n+\n+    public MacosxAddress readCompKlassAddress(long address)\n+            throws UnmappedAddressException, UnalignedAddressException {\n+        long value = readCompKlassAddressValue(address);\n+        return (value == 0 ? null : new MacosxAddress(this, value));\n+    }\n+\n+    \/** From the MacosxDebugger interface *\/\n+    public MacosxOopHandle readOopHandle(long address)\n+            throws UnmappedAddressException, UnalignedAddressException,\n+                NotInHeapException {\n+        long value = readAddressValue(address);\n+        return (value == 0 ? null : new MacosxOopHandle(this, value));\n+    }\n+    public MacosxOopHandle readCompOopHandle(long address)\n+            throws UnmappedAddressException, UnalignedAddressException,\n+                NotInHeapException {\n+        long value = readCompOopAddressValue(address);\n+        return (value == 0 ? null : new MacosxOopHandle(this, value));\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Thread context access\n+    \/\/\n+\n+    public synchronized long[] getThreadIntegerRegisterSet(long unique_thread_id)\n+                                            throws DebuggerException {\n+        requireAttach();\n+        if (isCore) {\n+            return getThreadIntegerRegisterSet0(unique_thread_id);\n+        } else {\n+            class GetThreadIntegerRegisterSetTask implements WorkerThreadTask {\n+                long unique_thread_id;\n+                long[] result;\n+                public void doit(MacosxDebuggerLocal debugger) {\n+                    result = debugger.getThreadIntegerRegisterSet0(unique_thread_id);\n+                }\n+            }\n+\n+            GetThreadIntegerRegisterSetTask task = new GetThreadIntegerRegisterSetTask();\n+            task.unique_thread_id = unique_thread_id;\n+            workerThread.execute(task);\n+            return task.result;\n+        }\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Address access. Can not be package private, but should only be\n+    \/\/ accessed by the architecture-specific subpackages.\n+\n+    \/** From the MacosxDebugger interface *\/\n+    public long getAddressValue(Address addr) {\n+      if (addr == null) return 0;\n+      return addr.asLongValue();\n+    }\n+\n+    \/** From the MacosxDebugger interface *\/\n+    public Address newAddress(long value) {\n+      if (value == 0) return null;\n+      return new MacosxAddress(this, value);\n+    }\n+\n+    \/** From the MacosxCDebugger interface *\/\n+    public List<ThreadProxy> getThreadList() {\n+      requireAttach();\n+      if (javaThreadList == null) {\n+        fillJavaThreadList();\n+      }\n+      return javaThreadList.stream()\n+                           .map(JavaThread::getThreadProxy)\n+                           .toList();\n+    }\n+\n+    \/** From the MacosxCDebugger interface *\/\n+    public List<LoadObject> getLoadObjectList() {\n+      requireAttach();\n+      return loadObjectList;\n+    }\n+\n+    \/** From the MacosxCDebugger interface *\/\n+    public synchronized ClosestSymbol lookup(long addr) {\n+       requireAttach();\n+       if (isCore) {\n+          return lookupByAddress0(addr);\n+       } else {\n+          class LookupByAddressTask implements WorkerThreadTask {\n+             long addr;\n+             ClosestSymbol result;\n+\n+             public void doit(MacosxDebuggerLocal debugger) {\n+                 result = debugger.lookupByAddress0(addr);\n+             }\n+          }\n+\n+          LookupByAddressTask task = new LookupByAddressTask();\n+          task.addr = addr;\n+          workerThread.execute(task);\n+          return task.result;\n+       }\n+    }\n+\n+    public CDebugger getCDebugger() {\n+      if (cdbg == null) {\n+         cdbg = new MacosxCDebugger(this);\n+      }\n+      return cdbg;\n+    }\n+\n+    \/** This reads bytes from the remote process. *\/\n+    public synchronized ReadResult readBytesFromProcess(long address,\n+            long numBytes) throws UnmappedAddressException, DebuggerException {\n+        requireAttach();\n+        if (isCore) {\n+            byte[] res = readBytesFromProcess0(address, numBytes);\n+            return (res != null)? new ReadResult(res) : new ReadResult(address);\n+        } else {\n+            class ReadBytesFromProcessTask implements WorkerThreadTask {\n+                long address, numBytes;\n+                ReadResult result;\n+                public void doit(MacosxDebuggerLocal debugger) {\n+                    byte[] res = debugger.readBytesFromProcess0(address, numBytes);\n+                    if (res != null)\n+                        result = new ReadResult(res);\n+                    else\n+                        result = new ReadResult(address);\n+                }\n+            }\n+\n+            ReadBytesFromProcessTask task = new ReadBytesFromProcessTask();\n+            task.address = address;\n+            task.numBytes = numBytes;\n+            workerThread.execute(task);\n+            return task.result;\n+        }\n+    }\n+\n+    \/** this functions used for core file reading and called from native attach0,\n+        it returns an array of long integers as\n+        [thread_id, stack_start, stack_end, thread_id, stack_start, stack_end, ....] for\n+        all java threads recorded in Threads. *\/\n+    public long[] getJavaThreadsInfo() {\n+        requireAttach();\n+        if (javaThreadList == null) {\n+            fillJavaThreadList();\n+        }\n+        long[] result = new long[javaThreadList.size() * 3];    \/\/ triple\n+        long beg, end;\n+        int i = 0;\n+        for (var t : javaThreadList) {\n+            end = t.getStackBaseValue();\n+            beg = end - t.getStackSize();\n+            long uid = ((MacosxThread)t.getThreadProxy()).getUniqueThreadId();\n+            result[i] = uid;\n+            result[i + 1] = beg;\n+            result[i + 2] = end;\n+            i += 3;\n+        }\n+        return result;\n+    }\n+\n+    static {\n+        System.loadLibrary(\"saproc\");\n+        init0();\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/MacosxDebuggerLocal.java","additions":617,"deletions":0,"binary":false,"changes":617,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.macosx;\n+\n+import sun.jvm.hotspot.debugger.*;\n+\n+class MacosxOopHandle extends MacosxAddress implements OopHandle {\n+  MacosxOopHandle(MacosxDebugger debugger, long addr) {\n+    super(debugger, addr);\n+  }\n+\n+  public boolean equals(Object arg) {\n+    if (arg == null) {\n+      return false;\n+    }\n+\n+    if (!(arg instanceof MacosxOopHandle)) {\n+      return false;\n+    }\n+\n+    return (addr == ((MacosxAddress) arg).addr);\n+  }\n+\n+  public Address    addOffsetTo       (long offset) throws UnsupportedOperationException {\n+    throw new UnsupportedOperationException(\"addOffsetTo not applicable to OopHandles (interior object pointers not allowed)\");\n+  }\n+\n+  public Address    andWithMask(long mask) throws UnsupportedOperationException {\n+    throw new UnsupportedOperationException(\"andWithMask not applicable to OopHandles (i.e., anything but C addresses)\");\n+  }\n+\n+  public Address    orWithMask(long mask) throws UnsupportedOperationException {\n+    throw new UnsupportedOperationException(\"orWithMask not applicable to OopHandles (i.e., anything but C addresses)\");\n+  }\n+\n+  public Address    xorWithMask(long mask) throws UnsupportedOperationException {\n+    throw new UnsupportedOperationException(\"xorWithMask not applicable to OopHandles (i.e., anything but C addresses)\");\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/MacosxOopHandle.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.macosx;\n+\n+import sun.jvm.hotspot.debugger.*;\n+\n+class MacosxThread implements ThreadProxy {\n+    private MacosxDebugger debugger;\n+    private int         thread_id;\n+    private long        unique_thread_id;\n+\n+    \/** The address argument must be the address of the _thread_id in the\n+        OSThread. It's value is result ::gettid() call. *\/\n+    MacosxThread(MacosxDebugger debugger, Address threadIdAddr, Address uniqueThreadIdAddr) {\n+        this.debugger = debugger;\n+        \/\/ FIXME: size of data fetched here should be configurable.\n+        \/\/ However, making it so would produce a dependency on the \"types\"\n+        \/\/ package from the debugger package, which is not desired.\n+        this.thread_id = (int) threadIdAddr.getCIntegerAt(0, 4, true);\n+        this.unique_thread_id = uniqueThreadIdAddr.getCIntegerAt(0, 8, true);\n+    }\n+\n+    MacosxThread(MacosxDebugger debugger, long id) {\n+        this.debugger = debugger;\n+        \/\/ use unique_thread_id to identify thread\n+        this.unique_thread_id = id;\n+    }\n+\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof MacosxThread other)) {\n+            return false;\n+        }\n+\n+        return (other.unique_thread_id == unique_thread_id);\n+    }\n+\n+    public int hashCode() {\n+        return thread_id;\n+    }\n+\n+    public String toString() {\n+        return Integer.toString(thread_id);\n+    }\n+\n+    public ThreadContext getContext() throws IllegalThreadStateException {\n+        long[] data = debugger.getThreadIntegerRegisterSet(unique_thread_id);\n+        ThreadContext context = MacosxThreadContextFactory.createThreadContext(debugger);\n+        \/\/ null means we failed to get the register set for some reason. The caller\n+        \/\/ is responsible for dealing with the set of null registers in that case.\n+        if (data != null) {\n+            for (int i = 0; i < data.length; i++) {\n+                context.setRegister(i, data[i]);\n+            }\n+        }\n+        return context;\n+    }\n+\n+    public boolean canSetContext() throws DebuggerException {\n+        return false;\n+    }\n+\n+    public void setContext(ThreadContext context)\n+      throws IllegalThreadStateException, DebuggerException {\n+        throw new DebuggerException(\"Unimplemented\");\n+    }\n+\n+    \/** this is not interface function, used in core file to get unique thread id on Macosx*\/\n+    public long getUniqueThreadId() {\n+        return unique_thread_id;\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/MacosxThread.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.macosx;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.macosx.aarch64.*;\n+import sun.jvm.hotspot.debugger.macosx.amd64.*;\n+\n+class MacosxThreadContextFactory {\n+   static ThreadContext createThreadContext(MacosxDebugger dbg) {\n+      String cpu = dbg.getCPU();\n+      if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n+         return new MacosxAMD64ThreadContext(dbg);\n+      } else if (cpu.equals(\"aarch64\")) {\n+         return new MacosxAARCH64ThreadContext(dbg);\n+      } else {\n+         throw new RuntimeException(\"cpu \" + cpu + \" is not yet supported\");\n+      }\n+   }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/MacosxThreadContextFactory.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package sun.jvm.hotspot.debugger.bsd;\n+package sun.jvm.hotspot.debugger.macosx;\n@@ -34,1 +34,1 @@\n-  SharedObject(BsdDebugger dbg, String filename, long size, Address relocation) {\n+  SharedObject(MacosxDebugger dbg, String filename, long size, Address relocation) {\n@@ -51,1 +51,1 @@\n-  private BsdDebugger   dbg;\n+  private MacosxDebugger   dbg;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/SharedObject.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/SharedObject.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package sun.jvm.hotspot.debugger.bsd.aarch64;\n+package sun.jvm.hotspot.debugger.macosx.aarch64;\n@@ -32,1 +32,1 @@\n-import sun.jvm.hotspot.debugger.bsd.*;\n+import sun.jvm.hotspot.debugger.macosx.*;\n@@ -38,2 +38,2 @@\n-public final class BsdAARCH64CFrame extends BasicCFrame {\n-   public BsdAARCH64CFrame(BsdDebugger dbg, Address sp, Address fp, Address pc) {\n+public final class MacosxAARCH64CFrame extends BasicCFrame {\n+   public MacosxAARCH64CFrame(MacosxDebugger dbg, Address sp, Address fp, Address pc) {\n@@ -114,1 +114,1 @@\n-      return new BsdAARCH64CFrame(dbg, nextSP, nextFP, nextPC);\n+      return new MacosxAARCH64CFrame(dbg, nextSP, nextFP, nextPC);\n@@ -127,1 +127,1 @@\n-   private BsdDebugger dbg;\n+   private MacosxDebugger dbg;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/aarch64\/MacosxAARCH64CFrame.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/aarch64\/BsdAARCH64CFrame.java","status":"renamed"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.macosx.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.macosx.*;\n+\n+public class MacosxAARCH64ThreadContext extends AARCH64ThreadContext {\n+  private MacosxDebugger debugger;\n+\n+  public MacosxAARCH64ThreadContext(MacosxDebugger debugger) {\n+    super();\n+    this.debugger = debugger;\n+  }\n+\n+  public void setRegisterAsAddress(int index, Address value) {\n+    setRegister(index, debugger.getAddressValue(value));\n+  }\n+\n+  public Address getRegisterAsAddress(int index) {\n+    return debugger.newAddress(getRegister(index));\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/aarch64\/MacosxAARCH64ThreadContext.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.macosx.amd64;\n+\n+import java.lang.ref.Cleaner;\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.debugger.DebuggerException;\n+\n+public class DwarfParser {\n+  private static final Cleaner CLEANER = Cleaner.create();\n+  private final long p_dwarf_context; \/\/ native dwarf context handle\n+\n+  private static native void init0();\n+  private static native long createDwarfContext(long lib);\n+  private static native void destroyDwarfContext(long context);\n+  private native boolean isIn0(long pc);\n+\n+  static {\n+    init0();\n+  }\n+\n+  private static Runnable cleanerFor(long context) {\n+    return () -> DwarfParser.destroyDwarfContext(context);\n+  }\n+\n+  public DwarfParser(Address lib) {\n+    p_dwarf_context = createDwarfContext(lib.asLongValue());\n+\n+    if (p_dwarf_context == 0L) {\n+      throw new DebuggerException(\"Could not create DWARF context\");\n+    }\n+\n+    CLEANER.register(this, cleanerFor(p_dwarf_context));\n+  }\n+\n+  public boolean isIn(Address pc) {\n+    return isIn0(pc.asLongValue());\n+  }\n+\n+  private native void processDwarf0(long pc);\n+\n+  public void processDwarf(Address pc) {\n+    processDwarf0(pc.asLongValue());\n+  }\n+\n+  public native int getCFARegister();\n+  public native int getCFAOffset();\n+  public native int getReturnAddressOffsetFromCFA();\n+  public native int getBasePointerOffsetFromCFA();\n+  public native boolean isBPOffsetAvailable();\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/amd64\/DwarfParser.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.macosx.amd64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.amd64.*;\n+import sun.jvm.hotspot.debugger.macosx.*;\n+import sun.jvm.hotspot.debugger.cdbg.*;\n+import sun.jvm.hotspot.debugger.cdbg.basic.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.amd64.*;\n+\n+public final class MacosxAMD64CFrame extends BasicCFrame {\n+   public MacosxAMD64CFrame(MacosxDebugger dbg, Address rsp, Address rbp, Address rip) {\n+      super(dbg.getCDebugger());\n+      this.rsp = rsp;\n+      this.rbp = rbp;\n+      this.rip = rip;\n+      this.dbg = dbg;\n+   }\n+\n+   \/\/ override base class impl to avoid ELF parsing\n+   public ClosestSymbol closestSymbolToPC() {\n+      \/\/ try native lookup in debugger.\n+      return dbg.lookup(dbg.getAddressValue(pc()));\n+   }\n+\n+   public Address pc() {\n+      return rip;\n+   }\n+\n+   public Address localVariableBase() {\n+      return rbp;\n+   }\n+\n+   @Override\n+   public CFrame sender(ThreadProxy thread) {\n+      return sender(thread, null, null, null);\n+   }\n+\n+   @Override\n+   public CFrame sender(ThreadProxy thread, Address sp, Address fp, Address pc) {\n+      \/\/ Check fp\n+      \/\/ Skip if both fp and pc are given - do not need to load from rbp.\n+      if (fp == null && pc == null) {\n+        if (rbp == null) {\n+          return null;\n+        }\n+\n+        \/\/ Check alignment of rbp\n+        if (dbg.getAddressValue(rbp) % ADDRESS_SIZE != 0) {\n+          return null;\n+        }\n+      }\n+\n+      Address nextRSP = sp != null ? sp : rbp.addOffsetTo(2 * ADDRESS_SIZE);\n+      if (nextRSP == null) {\n+        return null;\n+      }\n+      Address nextRBP = fp != null ? fp : rbp.getAddressAt(0);\n+      if (nextRBP == null) {\n+        return null;\n+      }\n+      Address nextPC  = pc != null ? pc : rbp.getAddressAt(ADDRESS_SIZE);\n+      if (nextPC == null) {\n+        return null;\n+      }\n+      return new MacosxAMD64CFrame(dbg, nextRSP, nextRBP, nextPC);\n+   }\n+\n+   @Override\n+   public Frame toFrame() {\n+      return new AMD64Frame(rsp, rbp, rip);\n+   }\n+\n+   \/\/ package\/class internals only\n+   private static final int ADDRESS_SIZE = 8;\n+   private Address rsp;\n+   private Address rip;\n+   private Address rbp;\n+   private MacosxDebugger dbg;\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/amd64\/MacosxAMD64CFrame.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.macosx.amd64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.amd64.*;\n+import sun.jvm.hotspot.debugger.macosx.*;\n+\n+public class MacosxAMD64ThreadContext extends AMD64ThreadContext {\n+  private MacosxDebugger debugger;\n+\n+  public MacosxAMD64ThreadContext(MacosxDebugger debugger) {\n+    super();\n+    this.debugger = debugger;\n+  }\n+\n+  public void setRegisterAsAddress(int index, Address value) {\n+    setRegister(index, debugger.getAddressValue(value));\n+  }\n+\n+  public Address getRegisterAsAddress(int index) {\n+    return debugger.newAddress(getRegister(index));\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/macosx\/amd64\/MacosxAMD64ThreadContext.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -37,2 +37,2 @@\n-import sun.jvm.hotspot.runtime.bsd_amd64.BsdAMD64JavaThreadPDAccess;\n-import sun.jvm.hotspot.runtime.bsd_aarch64.BsdAARCH64JavaThreadPDAccess;\n+import sun.jvm.hotspot.runtime.macosx_amd64.MacosxAMD64JavaThreadPDAccess;\n+import sun.jvm.hotspot.runtime.macosx_aarch64.MacosxAARCH64JavaThreadPDAccess;\n@@ -121,1 +121,1 @@\n-        } else if (os.equals(\"bsd\")) {\n+        } else if (os.equals(\"macosx\")) {\n@@ -123,1 +123,1 @@\n-                access = new BsdAMD64JavaThreadPDAccess();\n+                access = new MacosxAMD64JavaThreadPDAccess();\n@@ -127,1 +127,1 @@\n-                access = new BsdAMD64JavaThreadPDAccess();\n+                access = new MacosxAMD64JavaThreadPDAccess();\n@@ -129,1 +129,1 @@\n-                access = new BsdAARCH64JavaThreadPDAccess();\n+                access = new MacosxAARCH64JavaThreadPDAccess();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package sun.jvm.hotspot.runtime.bsd;\n+package sun.jvm.hotspot.runtime.macosx;\n@@ -27,1 +27,1 @@\n-public class BsdSignals {\n+public class MacosxSignals {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/macosx\/MacosxSignals.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/bsd\/BsdSignals.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package sun.jvm.hotspot.runtime.bsd_aarch64;\n+package sun.jvm.hotspot.runtime.macosx_aarch64;\n@@ -32,2 +32,2 @@\n-import sun.jvm.hotspot.debugger.bsd.BsdDebugger;\n-import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;\n+import sun.jvm.hotspot.debugger.macosx.MacosxDebugger;\n+import sun.jvm.hotspot.debugger.macosx.MacosxDebuggerLocal;\n@@ -41,1 +41,1 @@\n-public class BsdAARCH64JavaThreadPDAccess implements JavaThreadPDAccess {\n+public class MacosxAARCH64JavaThreadPDAccess implements JavaThreadPDAccess {\n@@ -136,1 +136,1 @@\n-    BsdDebuggerLocal debugger = (BsdDebuggerLocal) VM.getVM().getDebugger();\n+    MacosxDebuggerLocal debugger = (MacosxDebuggerLocal) VM.getVM().getDebugger();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/macosx_aarch64\/MacosxAARCH64JavaThreadPDAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/bsd_aarch64\/BsdAARCH64JavaThreadPDAccess.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package sun.jvm.hotspot.runtime.bsd_amd64;\n+package sun.jvm.hotspot.runtime.macosx_amd64;\n@@ -31,2 +31,2 @@\n-import sun.jvm.hotspot.debugger.bsd.BsdDebugger;\n-import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;\n+import sun.jvm.hotspot.debugger.macosx.MacosxDebugger;\n+import sun.jvm.hotspot.debugger.macosx.MacosxDebuggerLocal;\n@@ -40,1 +40,1 @@\n-public class BsdAMD64JavaThreadPDAccess implements JavaThreadPDAccess {\n+public class MacosxAMD64JavaThreadPDAccess implements JavaThreadPDAccess {\n@@ -139,1 +139,1 @@\n-    BsdDebuggerLocal debugger = (BsdDebuggerLocal) VM.getVM().getDebugger();\n+    MacosxDebuggerLocal debugger = (MacosxDebuggerLocal) VM.getVM().getDebugger();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/macosx_amd64\/MacosxAMD64JavaThreadPDAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/bsd_amd64\/BsdAMD64JavaThreadPDAccess.java","status":"renamed"}]}