{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,3 @@\n+static ThreadNode *\n+insertThread(JNIEnv *env, ThreadList *list, jthread thread);\n+\n@@ -280,0 +283,29 @@\n+\/* Creates a new ThreadNode for a vthread if one is needed. *\/\n+static ThreadNode *\n+createVThreadNodeIfNeeded(jthread thread) {\n+    ThreadNode *node = findThread(&otherThreads, thread);\n+    if (node != NULL) {\n+        \/\/tty_message(\"createVThreadNodeIfNeeded: thread is on otherThreads\");\n+        \/\/ Don't create a new node if it is on otherThreads list. Also don't return\n+        \/\/ the existing node because if it is on otherThreads, it is not running.\n+        return NULL;\n+    }\n+\n+    \/\/ See if we have a vthread that is alive. If we do, create a ThreadNode\n+    \/\/ for it. Otherwise just return NULL.\n+    jint vthread_state = 0;\n+    jvmtiError error = threadState(thread, &vthread_state);\n+    if (error != JVMTI_ERROR_NONE) {\n+        EXIT_ERROR(error, \"getting vthread state\");\n+    }\n+    if ((vthread_state & JVMTI_THREAD_STATE_ALIVE) == 0) {\n+        return NULL; \/\/ Don't create a new ThreadNode if thread is not alive\n+    }\n+    node = insertThread(getEnv(), &runningVThreads, thread);\n+    if (node->suspendCount > 0 && !node->suspendOnStart) {\n+        node->toBeResumed = JNI_TRUE;\n+    }\n+\n+    return node;\n+}\n+\n@@ -287,0 +319,10 @@\n+        if (node == NULL && !gdata->includeVThreads) {\n+            \/\/ Unlike platform threads, we don't always have a ThreadNode for all vthreads.\n+            \/\/ They can be freed if not holding on to any relevant state info. It's also\n+            \/\/ possible that the vthread was created before the debugger attached. Also\n+            \/\/ in the future we won't be enabling VIRTUAL_THREAD_START events in some\n+            \/\/ cases, which means we won't be creating a ThreadNode when the vthread is\n+            \/\/ created. If for any of the above reasons the ThreadNode lookup failed,\n+            \/\/ we'll create one for the vthread now, but only if really needed.\n+            node = createVThreadNodeIfNeeded(thread);\n+        }\n@@ -373,0 +415,17 @@\n+\n+#ifdef DEBUG_THREADNAME\n+        {\n+            \/* Set the thread name *\/\n+            jvmtiThreadInfo info;\n+            jvmtiError error;\n+\n+            memset(&info, 0, sizeof(info));\n+            error = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n+                    (gdata->jvmti, node->thread, &info);\n+            if (info.name != NULL) {\n+                strncpy(node->name, info.name, sizeof(node->name) - 1);\n+                jvmtiDeallocate(info.name);\n+            }\n+        }\n+#endif\n+\n@@ -421,16 +480,0 @@\n-#ifdef DEBUG_THREADNAME\n-        {\n-            \/* Set the thread name *\/\n-            jvmtiThreadInfo info;\n-            jvmtiError error;\n-\n-            memset(&info, 0, sizeof(info));\n-            error = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n-                    (gdata->jvmti, node->thread, &info);\n-            if (info.name != NULL) {\n-                strncpy(node->name, info.name, sizeof(node->name) - 1);\n-                jvmtiDeallocate(info.name);\n-            }\n-        }\n-#endif\n-\n@@ -504,0 +547,89 @@\n+\/*\n+ * Free (garbage collect) a vthread node if it is unused. This can only be called when\n+ * locks are held so we don't need to worry about other threads changing the state\n+ * of the ThreadNode while we are looking at it. We also need to make sure the\n+ * ThreadNode is not in use for operations like single stepping or invoking.\n+ *\/\n+static void\n+freeUnusedVThreadNode(JNIEnv *env, ThreadNode* node)\n+{\n+    if (gdata->includeVThreads) {\n+        return;\n+    }\n+\n+    \/*\n+     * node->suspendCount requires special handling to see if it triggers having\n+     * to keep the node around. It's possible for it to be 0 yet we still need to\n+     * keep the node around. Also, it's possbile for it to be non-zero yet we\n+     * don't need to keep the node around. More details in the comments below.\n+     *\/\n+    if (node->suspendCount == 0) {\n+        \/*\n+         * Normally a suspendCount of 0 does not result in having to keep the\n+         * node. However, if the suspendAllCount is not 0, then we do. Otherwise\n+         * when the node is recreated later it will end up assuming suspendAllCount\n+         * as its suspendCount rather than 0, which would be incorrect. This\n+         * mismatch in suspend counts happens when there is a suspendAll in place,\n+         * and ThreadReference.resume() is used to decrement the thread's\n+         * suspendCount to 0.\n+         *\/\n+        if (suspendAllCount > 0) {\n+            return;\n+        }\n+    } else {\n+        \/*\n+         * Although at first it might seem that a non-zero suspendCount would require\n+         * keeping the node, we don't have too if node->suspendCount == suspendAllCount,\n+         * because when the node is recreated it will get suspendAllCount assigned to it.\n+         * So we only worry about keeping the node around if the two counts are not equal.\n+         *\/\n+        if (node->suspendCount != suspendAllCount) {\n+            return;\n+        }\n+\n+    }\n+\n+    \/\/ All of the following conditions must pass if we are to free this node. Note\n+    \/\/ suspendCount checks were already made above, so are not included below. If\n+    \/\/ we got here, then suspendCount checks passed w.r.t. being able to free the node.\n+    \/\/ Also note we don't need to check node->toBeResumed. If it is set, that implies\n+    \/\/ node->suspendCount > 0, and that will trigger toBeResumed getting set when\n+    \/\/ the ThreadNode is recreated. See createVThreadNodeIfNeeded().\n+    if (!node->suspendOnStart &&\n+        node->current_ei == 0 &&\n+        node->cleInfo.ei == 0 &&\n+        !node->currentInvoke.pending &&\n+        !node->currentInvoke.started &&\n+        !node->currentInvoke.available &&\n+        !node->currentStep.pending &&\n+        node->instructionStepMode != JVMTI_ENABLE &&\n+        !node->pendingInterrupt &&\n+        !node->popFrameEvent &&\n+        !node->popFrameProceed &&\n+        !node->popFrameThread &&\n+        node->pendingStop == NULL)\n+    {\n+        removeNode(node);\n+        clearThread(env, node);\n+    }\n+}\n+\n+\/*\n+ * Free (garbage collect) vthread nodes if unused. See freeUnusedVThreadNode() above.\n+ *\/\n+static void\n+freeUnusedVThreadNodes(JNIEnv *env)\n+{\n+    if (gdata->includeVThreads) {\n+        return;\n+    }\n+\n+    ThreadList *list = &runningVThreads;\n+    ThreadNode *node = list->first;\n+    while (node != NULL) {\n+        ThreadNode *temp = node->next;\n+        freeUnusedVThreadNode(env, node);\n+        node = temp;\n+    }\n+}\n+\n@@ -1142,0 +1274,1 @@\n+ * Only called for platform threads.\n@@ -1163,0 +1296,2 @@\n+        jthread thread = initList[i];\n+        JDI_ASSERT(!isVThread(thread));\n@@ -1169,1 +1304,1 @@\n-        node = findThread(&runningThreads, initList[i]);\n+        node = findThread(&runningThreads, thread);\n@@ -1171,1 +1306,1 @@\n-            node = insertThread(env, &otherThreads, initList[i]);\n+            node = insertThread(env, &otherThreads, thread);\n@@ -1190,1 +1325,1 @@\n-            reqList[reqCnt++] = initList[i];\n+            reqList[reqCnt++] = thread;\n@@ -1261,1 +1396,4 @@\n-    node = findThread(NULL, thread);\n+    node = findRunningThread(thread);\n+    if (node == NULL) {\n+        node = findThread(&otherThreads, thread);\n+    }\n@@ -1339,1 +1477,1 @@\n-         * this thread, so the suspend count is 0, unless it is a vthread.\n+         * this thread, so the suspend count is 0.\n@@ -1341,16 +1479,1 @@\n-        if (isVThread(thread)) {\n-            jint vthread_state = 0;\n-            jvmtiError error = threadState(thread, &vthread_state);\n-            if (error != JVMTI_ERROR_NONE) {\n-                EXIT_ERROR(error, \"getting vthread state\");\n-            }\n-            if (vthread_state == 0) {\n-                \/\/ If state == 0, then this is a new vthread that has not been started yet.\n-                *count = 0;\n-            } else {\n-                \/\/ This is a started vthread that we are not tracking. Use suspendAllCount.\n-                *count = suspendAllCount;\n-            }\n-        } else {\n-            *count = 0;\n-        }\n+        *count = 0;\n@@ -1409,3 +1532,0 @@\n-#if 0\n-    tty_message(\"threadControl_suspendAll: suspendAllCount(%d)\", suspendAllCount);\n-#endif\n@@ -1419,0 +1539,2 @@\n+    \/\/tty_message(\"threadControl_suspendAll: suspendAllCount(%d)\", suspendAllCount);\n+\n@@ -1428,0 +1550,5 @@\n+            \/\/ Now is a good time to garbage collect vthread nodes. We want to do it before\n+            \/\/ any suspendAll because it will prevent the suspended nodes from being freed.\n+            if (!gdata->includeVThreads) {\n+                freeUnusedVThreadNodes(env);\n+            }\n@@ -1531,3 +1658,0 @@\n-#if 0\n-    tty_message(\"threadControl_resumeAll: suspendAllCount(%d)\", suspendAllCount);\n-#endif\n@@ -1542,0 +1666,2 @@\n+    \/\/tty_message(\"threadControl_resumeAll: suspendAllCount(%d)\", suspendAllCount);\n+\n@@ -2095,1 +2221,1 @@\n-        \/\/ If the node was previously freed, then it was just recreated and we need\n+        \/\/ If the node was previously freed and was just now recreated, we need\n@@ -2151,1 +2277,1 @@\n-    if (ei == EI_THREAD_END) {\n+    if (ei == EI_THREAD_END || ei == EI_THREAD_START) {\n@@ -2158,4 +2284,17 @@\n-        removeThread(env, node); \/\/ Grabs handlerLock, thus the reason for first grabbing it above.\n-        node = NULL; \/\/ We exiting the threadLock. No longer safe to access.\n-        debugMonitorExit(threadLock);\n-        eventHandler_unlock();\n+        \/\/ Remove nodes for exiting threads, but also remove nodes for vthreads\n+        \/\/ that are just starting to help prevent their accumulation. There can't\n+        \/\/ possibly be any state related information in the node at this point. A new\n+        \/\/ one will be created later if necessary, such as when a new event arrives.\n+        if (ei == EI_THREAD_END || (node->is_vthread && !gdata->includeVThreads)) {\n+            removeThread(env, node); \/\/ Grabs handlerLock, thus the reason for first grabbing it above.\n+            node = NULL; \/\/ Node has been freed. No longer safe to access.\n+       } else {\n+            \/\/ EI_THREAD_START for a platform thread, or we are tracking vthreads.\n+            \/\/ In either case we are not removing the thread node.\n+            \/\/ Just clear these two fields. Others are not set yet. Also no need to\n+            \/\/ worry about pending tasks like we do below for other event types.\n+            node->eventBag = eventBag;\n+            node->current_ei = 0;\n+       }\n+       debugMonitorExit(threadLock);\n+       eventHandler_unlock();\n@@ -2176,1 +2315,1 @@\n-        node = NULL; \/\/ We exiting the threadLock. No longer safe to access.\n+        node = NULL; \/\/ We're exiting the threadLock. No longer safe to access.\n@@ -2192,0 +2331,2 @@\n+        \/\/ Note: Threads that were just created or are about to die don't have pending\n+        \/\/ tasks, which is why this is the only code path where we call doPendingTasks().\n@@ -2210,0 +2351,1 @@\n+    eventHandler_lock(); \/\/ Needed to safely access HANDLING_EVENT(node)\n@@ -2232,0 +2374,1 @@\n+    eventHandler_unlock();\n@@ -2337,0 +2480,1 @@\n+    eventHandler_lock(); \/\/ Needed to safely access HANDLING_EVENT(node)\n@@ -2354,0 +2498,1 @@\n+    eventHandler_unlock();\n@@ -2582,1 +2727,1 @@\n-    tty_message(\"\\nDumping runningVThreads:\");\n+    tty_message(\"\\nDumping runningVThreads(numRunningVThreads=%d):\", numRunningVThreads);\n@@ -2653,0 +2798,3 @@\n+    tty_message(\"\\ttoBeResumed: %d\", node->toBeResumed);\n+    tty_message(\"\\tisStarted: %d\", node->isStarted);\n+    tty_message(\"\\tsuspendOnStart: %d\", node->suspendOnStart);\n@@ -2655,1 +2803,0 @@\n-    tty_message(\"\\ttoBeResumed: %d\", node->toBeResumed);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":200,"deletions":53,"binary":false,"changes":253,"status":"modified"}]}