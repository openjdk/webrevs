{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -465,0 +465,4 @@\n+            if (tc.hasUnknownPosition()) {\n+                \/\/ Handle container annotations\n+                tc.tryFixPosition();\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n@@ -32,1 +31,0 @@\n-import com.sun.tools.classfile.*;\n@@ -34,2 +32,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.lang.classfile.*;\n@@ -206,1 +203,1 @@\n-            ClassFile cf = ClassFile.read(classFile);\n+            ClassModel cf = ClassFile.of().parse(classFile.toPath());\n@@ -208,1 +205,1 @@\n-            println(\"Testing classfile: \" + cf.getName());\n+            println(\"Testing classfile: \" + cf.thisClass().asInternalName());\n@@ -212,3 +209,3 @@\n-            for (Field f : cf.fields) {\n-                test(cf, f);\n-                test(cf, f, true);\n+            for (FieldModel f : cf.fields()) {\n+                test(f);\n+                test(f, true);\n@@ -216,3 +213,3 @@\n-            for (Method m: cf.methods) {\n-                test(cf, m);\n-                test(cf, m, true);\n+            for (MethodModel m: cf.methods()) {\n+                test(m);\n+                test(m, true);\n@@ -542,135 +539,0 @@\n-\n-    \/************ Helper annotations counting methods ******************\/\n-    void test(ClassFile cf) {\n-        test(\"CLASS\",cf, null, null, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(\"CLASS\",cf, null, null, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-        \/\/RuntimeAnnotations since one annotation can result in two attributes.\n-        test(\"CLASS\",cf, null, null, Attribute.RuntimeVisibleAnnotations, true);\n-        test(\"CLASS\",cf, null, null, Attribute.RuntimeInvisibleAnnotations, false);\n-    }\n-\n-    void test(ClassFile cf, Field f, Boolean local) {\n-        if (!local) {\n-            test(\"FIELD\",cf, f, null, Attribute.RuntimeVisibleTypeAnnotations, true);\n-            test(\"FIELD\",cf, f, null, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-            test(\"FIELD\",cf, f, null, Attribute.RuntimeVisibleAnnotations, true);\n-            test(\"FIELD\",cf, f, null, Attribute.RuntimeInvisibleAnnotations, false);\n-        } else {\n-            test(\"CODE\",cf, f, null, Attribute.RuntimeVisibleTypeAnnotations, true);\n-            test(\"CODE\",cf, f, null, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-            test(\"CODE\",cf, f, null, Attribute.RuntimeVisibleAnnotations, true);\n-            test(\"CODE\",cf, f, null, Attribute.RuntimeInvisibleAnnotations, false);\n-        }\n-    }\n-\n-    void test(ClassFile cf, Field f) {\n-        test(cf, f, false);\n-    }\n-\n-    \/\/ 'local' determines whether to look for annotations in code attribute or not.\n-    void test(ClassFile cf, Method m, Boolean local) {\n-        if (!local) {\n-            test(\"METHOD\",cf, null, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-            test(\"METHOD\",cf, null, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-            test(\"METHOD\",cf, null, m, Attribute.RuntimeVisibleAnnotations, true);\n-            test(\"METHOD\",cf, null, m, Attribute.RuntimeInvisibleAnnotations, false);\n-        } else  {\n-            test(\"MCODE\",cf, null, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-            test(\"MCODE\",cf, null, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-            test(\"MCODE\",cf, null, m, Attribute.RuntimeVisibleAnnotations, true);\n-            test(\"MCODE\",cf, null, m, Attribute.RuntimeInvisibleAnnotations, false);\n-        }\n-    }\n-\n-    \/\/ default to not looking in code attribute\n-    void test(ClassFile cf, Method m ) {\n-        test(cf, m, false);\n-    }\n-\n-    \/\/ Test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the class\/field\/method name; increment annotations counts.\n-    void test(String ttype, ClassFile cf, Field f, Method m, String annName, boolean visible) {\n-        String testtype = ttype;\n-        String name = null;\n-        int index = -1;\n-        Attribute attr = null;\n-        Code_attribute cAttr = null;\n-        boolean isTAattr = annName.contains(\"TypeAnnotations\");\n-        try {\n-            switch(testtype) {\n-                case \"FIELD\":\n-                    name = f.getName(cf.constant_pool);\n-                    index = f.attributes.getIndex(cf.constant_pool, annName);\n-                    if(index!= -1)\n-                        attr = f.attributes.get(index);\n-                    break;\n-                case \"CODE\":\n-                    name = f.getName(cf.constant_pool);\n-                    \/\/fetch index of and code attribute and annotations from code attribute.\n-                    index = cf.attributes.getIndex(cf.constant_pool, Attribute.Code);\n-                    if(index!= -1) {\n-                        attr = cf.attributes.get(index);\n-                        assert attr instanceof Code_attribute;\n-                        cAttr = (Code_attribute)attr;\n-                        index = cAttr.attributes.getIndex(cf.constant_pool, annName);\n-                        if(index!= -1)\n-                            attr = cAttr.attributes.get(index);\n-                    }\n-                    break;\n-                case \"METHOD\":\n-                    name = m.getName(cf.constant_pool);\n-                    index = m.attributes.getIndex(cf.constant_pool, annName);\n-                    if(index!= -1)\n-                        attr = m.attributes.get(index);\n-                    break;\n-                case \"MCODE\":\n-                    name = m.getName(cf.constant_pool);\n-                    \/\/fetch index of and code attribute and annotations from code attribute.\n-                    index = m.attributes.getIndex(cf.constant_pool, Attribute.Code);\n-                    if(index!= -1) {\n-                        attr = m.attributes.get(index);\n-                        assert attr instanceof Code_attribute;\n-                        cAttr = (Code_attribute)attr;\n-                        index = cAttr.attributes.getIndex(cf.constant_pool, annName);\n-                        if(index!= -1)\n-                            attr = cAttr.attributes.get(index);\n-                    }\n-                    break;\n-                default:\n-                    name = cf.getName();\n-                    index = cf.attributes.getIndex(cf.constant_pool, annName);\n-                    if(index!= -1) attr = cf.attributes.get(index);\n-            }\n-        } catch(ConstantPoolException cpe) { cpe.printStackTrace(); }\n-\n-        if (index != -1) {\n-            if(isTAattr) { \/\/count RuntimeTypeAnnotations\n-                RuntimeTypeAnnotations_attribute tAttr =\n-                        (RuntimeTypeAnnotations_attribute)attr;\n-                System.out.println(testtype + \": \" + name + \", \" + annName + \": \" +\n-                        tAttr.annotations.length );\n-                if (tAttr.annotations.length > 0) {\n-                    for (int i = 0; i < tAttr.annotations.length; i++) {\n-                        System.out.println(\"  types:\" + tAttr.annotations[i].position.type);\n-                    }\n-                } else {\n-                    System.out.println(\"\");\n-                }\n-                allt += tAttr.annotations.length;\n-                if (visible)\n-                    tvisibles += tAttr.annotations.length;\n-                else\n-                    tinvisibles += tAttr.annotations.length;\n-            } else {\n-                RuntimeAnnotations_attribute tAttr =\n-                        (RuntimeAnnotations_attribute)attr;\n-                System.out.println(testtype + \": \" + name + \", \" + annName + \": \" +\n-                        tAttr.annotations.length );\n-                all += tAttr.annotations.length;\n-                if (visible)\n-                    visibles += tAttr.annotations.length;\n-                else\n-                    invisibles += tAttr.annotations.length;\n-            }\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/CombinationsTargetTest3.java","additions":10,"deletions":148,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315447\n+ * @summary Container annotations for type annotations in lambdas should be\n+ *          placed on the lambda method\n+ * @library \/test\/lib\n+ * @run junit RepeatableInLambdaTest\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.Map;\n+\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class RepeatableInLambdaTest {\n+    static final String src = \"\"\"\n+            import java.lang.annotation.Repeatable;\n+            import java.lang.annotation.Target;\n+            import static java.lang.annotation.ElementType.TYPE_USE;\n+            import java.util.function.Supplier;\n+\n+            @Target(TYPE_USE)\n+            @Repeatable(AC.class)\n+            @interface A {\n+            }\n+\n+            @Target(TYPE_USE)\n+            @interface AC {\n+                A[] value();\n+            }\n+\n+            @Target(TYPE_USE)\n+            @interface B {}\n+\n+            class Test {\n+                void test() {\n+                    Supplier<Integer> s = () -> (@A @A @B Integer) 1;\n+                }\n+            }\n+            \"\"\";\n+\n+    @Test\n+    void test() {\n+        var codes = InMemoryJavaCompiler.compile(Map.of(\"Test\", src));\n+        var bytes = codes.get(\"Test\");\n+        var cf = ClassFile.of().parse(bytes);\n+        var lambdaMethod = cf.methods().stream().filter(mm -> mm.flags().has(AccessFlag.SYNTHETIC))\n+                .findFirst().orElseThrow();\n+        System.err.println(lambdaMethod);\n+        var ritva = lambdaMethod.code().orElseThrow().findAttribute(Attributes.runtimeInvisibleTypeAnnotations()).orElseThrow();\n+        var annoList = ritva.annotations();\n+        assertEquals(2, annoList.size());\n+        assertEquals(ClassDesc.of(\"AC\"), annoList.getFirst().annotation().classSymbol());\n+        assertEquals(ClassDesc.of(\"B\"), annoList.get(1).annotation().classSymbol());\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/RepeatableInLambdaTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}