{"files":[{"patch":"@@ -252,0 +252,1 @@\n+        new EARelockingSimpleWithAccessInOtherThreadTarget()                                .run();\n@@ -373,0 +374,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread()                                .run(this);\n@@ -1753,0 +1755,56 @@\n+\/\/ The debugger reads and publishes an object with eliminated locking to a static variable.\n+\/\/ A 2nd thread in the debuggee finds it there and changes its state using a synchronized method.\n+\/\/ Without eager relocking the accesses are unsynchronized which can be observed.\n+class EARelockingSimpleWithAccessInOtherThread extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        String l1ClassName = EARelockingSimpleWithAccessInOtherThreadTarget.SyncCounter.class.getName();\n+        ObjectReference ctr = getLocalRef(bpe.thread().frame(1), l1ClassName, \"l1\");\n+        setField(testCase, \"sharedCounter\", ctr);\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+class EARelockingSimpleWithAccessInOtherThreadTarget extends EATestCaseBaseTarget {\n+\n+    public static class SyncCounter {\n+        private int val;\n+        public synchronized int inc() { return val++; }\n+    }\n+\n+    public volatile SyncCounter sharedCounter;\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        doLoop = true;\n+        Thread.ofPlatform().daemon().start(() -> {\n+                while (doLoop) {\n+                    SyncCounter ctr = sharedCounter;\n+                    if (ctr != null) {\n+                        ctr.inc();\n+                    }\n+                }\n+            });\n+    }\n+\n+    public void dontinline_testMethod() {\n+        SyncCounter l1 = new SyncCounter();\n+        synchronized (l1) {      \/\/ Eliminated locking\n+            l1.inc();\n+            dontinline_brkpt();  \/\/ Debugger publishes l1 to sharedCounter.\n+            iResult = l1.inc();  \/\/ Changes by the 2nd thread will be observed if l1\n+                                 \/\/ was not relocked before passing it to the debugger.\n+        }\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 1;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"}]}