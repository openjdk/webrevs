{"files":[{"patch":"@@ -86,0 +86,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -1639,3 +1640,13 @@\n-        BasicLock* lock = mon_info->lock();\n-        ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n-        assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+        if (LockingMode == LM_LIGHTWEIGHT && exec_mode == Unpack_none) {\n+          \/\/ We have lost information about the correct state of the lock stack.\n+          \/\/ Inflate the locks instead. Enter then inflate to avoid races with\n+          \/\/ deflation.\n+          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread);\n+          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+          ObjectMonitor* mon = ObjectSynchronizer::inflate(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n+          assert(mon->owner() == deoptee_thread, \"must be\");\n+        } else {\n+          BasicLock* lock = mon_info->lock();\n+          ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n+          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+        }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+ *                 -XX:LockingMode=1\n@@ -53,0 +54,1 @@\n+ *                 -XX:LockingMode=1\n@@ -61,0 +63,1 @@\n+ *                 -XX:LockingMode=1\n@@ -69,0 +72,38 @@\n+ *                 -XX:LockingMode=1\n+ *\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n@@ -216,0 +257,1 @@\n+        new EARelockingArgEscapeLWLockedInCalleeFrameNoRecursiveTarget()                    .run();\n@@ -336,0 +378,1 @@\n+        new EARelockingArgEscapeLWLockedInCalleeFrameNoRecursive()                    .run(this);\n@@ -1908,0 +1951,42 @@\n+\/**\n+ * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame_2Target}. It does\n+ * not use recursive locking and exposed a bug in the lightweight-locking implementation.\n+ *\/\n+class EARelockingArgEscapeLWLockedInCalleeFrameNoRecursive extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingArgEscapeLWLockedInCalleeFrameNoRecursiveTarget extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYVal(1, 1);       \/\/ NoEscape, scalar replaced\n+        XYVal l2 = new XYVal(4, 2);       \/\/ NoEscape, scalar replaced\n+        XYVal l3 = new XYVal(5, 3);       \/\/ ArgEscape\n+        synchronized (l1) {                   \/\/ eliminated\n+            synchronized (l2) {               \/\/ eliminated\n+                l3.dontinline_sync_method(this);  \/\/ l3 escapes\n+            }\n+        }\n+        iResult = l2.x + l2.y;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 6;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"}]}