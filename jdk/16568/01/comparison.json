{"files":[{"patch":"@@ -86,0 +86,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -1639,3 +1640,13 @@\n-        BasicLock* lock = mon_info->lock();\n-        ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n-        assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+        if (LockingMode == LM_LIGHTWEIGHT && exec_mode == Unpack_none) {\n+          \/\/ We have lost information about the correct state of the lock stack.\n+          \/\/ Inflate the locks instead. Enter then inflate to avoid races with\n+          \/\/ deflation.\n+          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread);\n+          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+          ObjectMonitor* mon = ObjectSynchronizer::inflate(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n+          assert(mon->owner() == deoptee_thread, \"must be\");\n+        } else {\n+          BasicLock* lock = mon_info->lock();\n+          ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n+          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+        }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+ *                 -XX:LockingMode=1\n@@ -53,0 +54,1 @@\n+ *                 -XX:LockingMode=1\n@@ -61,0 +63,1 @@\n+ *                 -XX:LockingMode=1\n@@ -69,0 +72,38 @@\n+ *                 -XX:LockingMode=1\n+ *\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n@@ -211,0 +252,1 @@\n+        new EARelockingSimpleWithAccessInOtherThreadTarget()                                .run();\n@@ -216,0 +258,1 @@\n+        new EARelockingArgEscapeLWLockedInCalleeFrameNoRecursiveTarget()                    .run();\n@@ -331,0 +374,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread()                                .run(this);\n@@ -336,0 +380,1 @@\n+        new EARelockingArgEscapeLWLockedInCalleeFrameNoRecursive()                    .run(this);\n@@ -1710,0 +1755,56 @@\n+\/\/ The debugger reads and publishes an object with eliminated locking to a static variable.\n+\/\/ A 2nd thread in the debuggee finds it there and changes its state using a synchronized method.\n+\/\/ Without eager relocking the accesses are unsynchronized which can be observed.\n+class EARelockingSimpleWithAccessInOtherThread extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        String l1ClassName = EARelockingSimpleWithAccessInOtherThreadTarget.SyncCounter.class.getName();\n+        ObjectReference ctr = getLocalRef(bpe.thread().frame(1), l1ClassName, \"l1\");\n+        setField(testCase, \"sharedCounter\", ctr);\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+class EARelockingSimpleWithAccessInOtherThreadTarget extends EATestCaseBaseTarget {\n+\n+    public static class SyncCounter {\n+        private int val;\n+        public synchronized int inc() { return val++; }\n+    }\n+\n+    public volatile SyncCounter sharedCounter;\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        doLoop = true;\n+        Thread.ofPlatform().daemon().start(() -> {\n+                while (doLoop) {\n+                    SyncCounter ctr = sharedCounter;\n+                    if (ctr != null) {\n+                        ctr.inc();\n+                    }\n+                }\n+            });\n+    }\n+\n+    public void dontinline_testMethod() {\n+        SyncCounter l1 = new SyncCounter();\n+        synchronized (l1) {      \/\/ Eliminated locking\n+            l1.inc();\n+            dontinline_brkpt();  \/\/ Debugger publishes l1 to sharedCounter.\n+            iResult = l1.inc();  \/\/ Changes by the 2nd thread will be observed if l1\n+                                 \/\/ was not relocked before passing it to the debugger.\n+        }\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 1;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n@@ -1908,0 +2009,42 @@\n+\/**\n+ * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame_2Target}. It does\n+ * not use recursive locking and exposed a bug in the lightweight-locking implementation.\n+ *\/\n+class EARelockingArgEscapeLWLockedInCalleeFrameNoRecursive extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingArgEscapeLWLockedInCalleeFrameNoRecursiveTarget extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYVal(1, 1);       \/\/ NoEscape, scalar replaced\n+        XYVal l2 = new XYVal(4, 2);       \/\/ NoEscape, scalar replaced\n+        XYVal l3 = new XYVal(5, 3);       \/\/ ArgEscape\n+        synchronized (l1) {                   \/\/ eliminated\n+            synchronized (l2) {               \/\/ eliminated\n+                l3.dontinline_sync_method(this);  \/\/ l3 escapes\n+            }\n+        }\n+        iResult = l2.x + l2.y;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 6;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"modified"}]}