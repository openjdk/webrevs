{"files":[{"patch":"@@ -1144,1 +1144,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -1163,1 +1162,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -890,1 +890,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -914,1 +913,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1216,1 +1216,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -1236,1 +1235,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1015,0 +1015,2 @@\n+  \/\/ Record size of code before we generate stubs in instructions section\n+  _main_code_size = _insts.size();\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -430,0 +430,3 @@\n+  \/\/ Size of code without stubs generated at the end of instructions section\n+  csize_t      _main_code_size;\n+\n@@ -460,0 +463,1 @@\n+    _main_code_size  = 0;\n@@ -633,0 +637,3 @@\n+  \/\/ size of code without stubs in instruction section\n+  csize_t main_code_size() const         { return _main_code_size; }\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1129,1 +1129,2 @@\n-\/\/ heuristic (e.g. post call nop instructions; see InlineSkippedInstructionsCounter)\n+\/\/ heuristic (e.g. post call nop instructions and GC barriers;\n+\/\/ see InlineSkippedInstructionsCounter).\n@@ -1135,1 +1136,1 @@\n-        int isize = code->insts_end() - code->verified_entry_point() - code->skipped_instructions_size();\n+        int isize = code->inline_insts_size();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+  uint inline_insts_size;\n@@ -154,0 +155,1 @@\n+    inline_insts_size   += nm->inline_insts_size();\n@@ -188,0 +190,3 @@\n+    if (inline_insts_size != 0) {\n+      tty->print_cr(\"     inline code = %u (%f%%)\", inline_insts_size, (inline_insts_size * 100.0f)\/total_nm_size);\n+    }\n@@ -1256,1 +1261,9 @@\n-  CHECKED_CAST(_skipped_instructions_size, uint16_t, (code_buffer->total_skipped_instructions_size()));\n+\n+  int size = code_buffer->main_code_size();\n+  assert(size >= 0, \"should be initialized\");\n+  \/\/ Use instructions section size if it is 0 (e.g. native wrapper)\n+  if (size == 0) size = code_size(); \/\/ requires _stub_offset to be set\n+  assert(size <= code_size(), \"incorrect size: %d > %d\", size, code_size());\n+  _inline_insts_size = size - _verified_entry_offset\n+                     - code_buffer->total_skipped_instructions_size();\n+  assert(_inline_insts_size >= 0, \"sanity\");\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -221,0 +221,2 @@\n+  int _inline_insts_size;\n+\n@@ -235,1 +237,0 @@\n-  uint16_t _skipped_instructions_size;\n@@ -592,1 +593,1 @@\n-  int skipped_instructions_size () const { return _skipped_instructions_size; }\n+  int inline_insts_size() const { return _inline_insts_size; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1327,0 +1327,1 @@\n+  \/\/ GC barrier stubs are generated in code section\n@@ -1328,1 +1329,1 @@\n-  stub_req += bs->estimate_stub_size();\n+  code_req += bs->estimate_stub_size();\n@@ -1337,1 +1338,1 @@\n-  if (StressCodeBuffers)\n+  if (StressCodeBuffers) {\n@@ -1339,1 +1340,1 @@\n-\n+  }\n@@ -1348,3 +1349,4 @@\n-  if (C->has_method_handle_invokes())\n-    total_req += deopt_handler_req;  \/\/ deopt MH handler\n-\n+  if (C->has_method_handle_invokes()) {\n+    total_req += deopt_handler_req;        \/\/ deopt MH handler\n+    stub_req  += deopt_handler_req;\n+  }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}