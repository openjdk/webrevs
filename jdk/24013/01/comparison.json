{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"opto\/predicates_enums.hpp\"\n@@ -61,4 +62,1 @@\n-\n-\/\/ The success projection of a Parse Predicate is always an IfTrueNode and the uncommon projection an IfFalseNode\n-typedef IfTrueNode ParsePredicateSuccessProj;\n-typedef IfFalseNode ParsePredicateUncommonProj;\n+enum class PredicateState;\n@@ -489,1 +487,5 @@\n-  bool _useless; \/\/ If the associated loop dies, this parse predicate becomes useless and can be cleaned up by Value().\n+\n+  \/\/ When a Parse Predicate loses its connection to a loop head, it will be marked useless by\n+  \/\/ EliminateUselessPredicates and cleaned up by Value(). It can also become useless when cloning it to both loops\n+  \/\/ during Loop Multiversioning - we no longer use the old version.\n+  PredicateState _predicate_state;\n@@ -500,1 +502,7 @@\n-    return _useless;\n+    return _predicate_state == PredicateState::Useless;\n+  }\n+\n+  void mark_useless(PhaseIterGVN& igvn);\n+\n+  void mark_maybe_useful() {\n+    _predicate_state = PredicateState::MaybeUseful;\n@@ -503,2 +511,2 @@\n-  void mark_useless() {\n-    _useless = true;\n+  bool is_useful() const {\n+    return _predicate_state == PredicateState::Useful;\n@@ -508,1 +516,1 @@\n-    _useless = false;\n+    _predicate_state = PredicateState::Useful;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -397,1 +398,1 @@\n-    remove_template_assertion_predicate_opaq(dead);\n+    remove_template_assertion_predicate_opaque(dead->as_OpaqueTemplateAssertionPredicate());\n@@ -453,1 +454,2 @@\n-  remove_useless_nodes(_template_assertion_predicate_opaqs, useful); \/\/ remove useless Assertion Predicate opaque nodes\n+  \/\/ Remove useless Template Assertion Predicate opaque nodes\n+  remove_useless_nodes(_template_assertion_predicate_opaques, useful);\n@@ -651,1 +653,1 @@\n-      _template_assertion_predicate_opaqs(comp_arena(), 8, 0, nullptr),\n+      _template_assertion_predicate_opaques(comp_arena(), 8, 0, nullptr),\n@@ -1827,2 +1829,1 @@\n-    parse_predicate->mark_useless();\n-    igvn._worklist.push(parse_predicate);\n+    parse_predicate->mark_useless(igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+class OpaqueTemplateAssertionPredicateNode;\n@@ -373,2 +374,3 @@\n-  \/\/ List of OpaqueTemplateAssertionPredicateNode nodes for Template Assertion Predicates.\n-  GrowableArray<Node*>  _template_assertion_predicate_opaqs;\n+  \/\/ List of OpaqueTemplateAssertionPredicateNode nodes for Template Assertion Predicates which can be seen as list\n+  \/\/ of Template Assertion Predicates themselves.\n+  GrowableArray<OpaqueTemplateAssertionPredicateNode*>  _template_assertion_predicate_opaques;\n@@ -684,0 +686,8 @@\n+  const GrowableArray<ParsePredicateNode*>& parse_predicates() const {\n+    return _parse_predicates;\n+  }\n+\n+  const GrowableArray<OpaqueTemplateAssertionPredicateNode*>& template_assertion_predicate_opaques() const {\n+    return _template_assertion_predicate_opaques;\n+  }\n+\n@@ -686,1 +696,1 @@\n-  int           template_assertion_predicate_count() const { return _template_assertion_predicate_opaqs.length(); }\n+  int           template_assertion_predicate_count() const { return _template_assertion_predicate_opaques.length(); }\n@@ -691,5 +701,0 @@\n-  ParsePredicateNode* parse_predicate(int idx) const { return _parse_predicates.at(idx); }\n-\n-  Node* template_assertion_predicate_opaq_node(int idx) const {\n-    return _template_assertion_predicate_opaqs.at(idx);\n-  }\n@@ -731,2 +736,2 @@\n-  void add_template_assertion_predicate_opaq(Node* n) {\n-    assert(!_template_assertion_predicate_opaqs.contains(n),\n+  void add_template_assertion_predicate_opaque(OpaqueTemplateAssertionPredicateNode* n) {\n+    assert(!_template_assertion_predicate_opaques.contains(n),\n@@ -734,1 +739,1 @@\n-    _template_assertion_predicate_opaqs.append(n);\n+    _template_assertion_predicate_opaques.append(n);\n@@ -737,1 +742,1 @@\n-  void remove_template_assertion_predicate_opaq(Node* n) {\n+  void remove_template_assertion_predicate_opaque(OpaqueTemplateAssertionPredicateNode* n) {\n@@ -739,1 +744,1 @@\n-      _template_assertion_predicate_opaqs.remove_if_existing(n);\n+      _template_assertion_predicate_opaques.remove_if_existing(n);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"opto\/predicates.hpp\"\n+#include \"opto\/predicates_enums.hpp\"\n@@ -2172,1 +2172,1 @@\n-      _useless(false) {\n+      _predicate_state(PredicateState::Useful) {\n@@ -2189,0 +2189,5 @@\n+void ParsePredicateNode::mark_useless(PhaseIterGVN& igvn) {\n+  _predicate_state = PredicateState::Useless;\n+  igvn._worklist.push(this);\n+}\n+\n@@ -2198,0 +2203,2 @@\n+  assert(_predicate_state != PredicateState::MaybeUseful, \"should only be MaybeUseful when eliminating useless \"\n+                                                          \"predicates during loop opts\");\n@@ -2201,1 +2208,1 @@\n-  if (_useless || phase->C->post_loop_opts_phase()) {\n+  if (_predicate_state == PredicateState::Useless || phase->C->post_loop_opts_phase()) {\n@@ -2203,2 +2210,0 @@\n-  } else {\n-    return bottom_type();\n@@ -2206,0 +2211,1 @@\n+  return bottom_type();\n@@ -2227,1 +2233,1 @@\n-  if (_useless) {\n+  if (_predicate_state == PredicateState::Useless) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4402,1 +4402,1 @@\n-void PhaseIdealLoop::eliminate_useless_predicates() {\n+void PhaseIdealLoop::eliminate_useless_predicates() const {\n@@ -4407,105 +4407,2 @@\n-  eliminate_useless_parse_predicates();\n-  eliminate_useless_template_assertion_predicates();\n-}\n-\n-\/\/ Eliminate all Parse Predicates that do not belong to a loop anymore by marking them useless. These will be removed\n-\/\/ during the next round of IGVN.\n-void PhaseIdealLoop::eliminate_useless_parse_predicates() {\n-  mark_all_parse_predicates_useless();\n-  if (C->has_loops()) {\n-    mark_loop_associated_parse_predicates_useful();\n-  }\n-  add_useless_parse_predicates_to_igvn_worklist();\n-}\n-\n-void PhaseIdealLoop::mark_all_parse_predicates_useless() const {\n-  for (int i = 0; i < C->parse_predicate_count(); i++) {\n-    C->parse_predicate(i)->mark_useless();\n-  }\n-}\n-\n-void PhaseIdealLoop::mark_loop_associated_parse_predicates_useful() {\n-  for (LoopTreeIterator iterator(_ltree_root); !iterator.done(); iterator.next()) {\n-    IdealLoopTree* loop = iterator.current();\n-    if (loop->can_apply_loop_predication()) {\n-      mark_useful_parse_predicates_for_loop(loop);\n-    }\n-  }\n-}\n-\n-\/\/ This visitor marks all visited Parse Predicates useful.\n-class ParsePredicateUsefulMarker : public PredicateVisitor {\n- public:\n-  using PredicateVisitor::visit;\n-\n-  void visit(const ParsePredicate& parse_predicate) override {\n-    parse_predicate.head()->mark_useful();\n-  }\n-};\n-\n-void PhaseIdealLoop::mark_useful_parse_predicates_for_loop(IdealLoopTree* loop) {\n-  Node* entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n-  const PredicateIterator predicate_iterator(entry);\n-  ParsePredicateUsefulMarker useful_marker;\n-  predicate_iterator.for_each(useful_marker);\n-}\n-\n-void PhaseIdealLoop::add_useless_parse_predicates_to_igvn_worklist() {\n-  for (int i = 0; i < C->parse_predicate_count(); i++) {\n-    ParsePredicateNode* parse_predicate_node = C->parse_predicate(i);\n-    if (parse_predicate_node->is_useless()) {\n-      _igvn._worklist.push(parse_predicate_node);\n-    }\n-  }\n-}\n-\n-\n-\/\/ Eliminate all Template Assertion Predicates that do not belong to their originally associated loop anymore by\n-\/\/ replacing the OpaqueTemplateAssertionPredicate node of the If node with true. These nodes will be removed during the\n-\/\/ next round of IGVN.\n-void PhaseIdealLoop::eliminate_useless_template_assertion_predicates() {\n-  Unique_Node_List useful_predicates;\n-  if (C->has_loops()) {\n-    collect_useful_template_assertion_predicates(useful_predicates);\n-  }\n-  eliminate_useless_template_assertion_predicates(useful_predicates);\n-}\n-\n-void PhaseIdealLoop::collect_useful_template_assertion_predicates(Unique_Node_List& useful_predicates) {\n-  for (LoopTreeIterator iterator(_ltree_root); !iterator.done(); iterator.next()) {\n-    IdealLoopTree* loop = iterator.current();\n-    if (loop->can_apply_loop_predication()) {\n-      collect_useful_template_assertion_predicates_for_loop(loop, useful_predicates);\n-    }\n-  }\n-}\n-\n-void PhaseIdealLoop::collect_useful_template_assertion_predicates_for_loop(IdealLoopTree* loop,\n-                                                                           Unique_Node_List &useful_predicates) {\n-  Node* entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n-  const Predicates predicates(entry);\n-  if (UseProfiledLoopPredicate) {\n-    const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n-    if (profiled_loop_predicate_block->has_parse_predicate()) {\n-      ParsePredicateSuccessProj* parse_predicate_proj = profiled_loop_predicate_block->parse_predicate_success_proj();\n-      get_opaque_template_assertion_predicate_nodes(parse_predicate_proj, useful_predicates);\n-    }\n-  }\n-\n-  if (UseLoopPredicate) {\n-    const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n-    if (loop_predicate_block->has_parse_predicate()) {\n-      ParsePredicateSuccessProj* parse_predicate_proj = loop_predicate_block->parse_predicate_success_proj();\n-      get_opaque_template_assertion_predicate_nodes(parse_predicate_proj, useful_predicates);\n-    }\n-  }\n-}\n-\n-void PhaseIdealLoop::eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates) const {\n-  for (int i = C->template_assertion_predicate_count(); i > 0; i--) {\n-    OpaqueTemplateAssertionPredicateNode* opaque_node =\n-        C->template_assertion_predicate_opaq_node(i - 1)->as_OpaqueTemplateAssertionPredicate();\n-    if (!useful_predicates.member(opaque_node)) { \/\/ not in the useful list\n-      opaque_node->mark_useless(_igvn);\n-    }\n-  }\n+  EliminateUselessPredicates eliminate_useless_predicates(_igvn, _ltree_root);\n+  eliminate_useless_predicates.eliminate();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":106,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -1445,12 +1445,1 @@\n-  void eliminate_useless_predicates();\n-\n-  void eliminate_useless_parse_predicates();\n-  void mark_all_parse_predicates_useless() const;\n-  void mark_loop_associated_parse_predicates_useful();\n-  static void mark_useful_parse_predicates_for_loop(IdealLoopTree* loop);\n-  void add_useless_parse_predicates_to_igvn_worklist();\n-\n-  void eliminate_useless_template_assertion_predicates();\n-  void collect_useful_template_assertion_predicates(Unique_Node_List& useful_predicates);\n-  static void collect_useful_template_assertion_predicates_for_loop(IdealLoopTree* loop, Unique_Node_List& useful_predicates);\n-  void eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates) const;\n+  void eliminate_useless_predicates() const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -514,0 +514,3 @@\n+  if (n->is_OpaqueTemplateAssertionPredicate()) {\n+    C->add_template_assertion_predicate_opaque(n->as_OpaqueTemplateAssertionPredicate());\n+  }\n@@ -610,1 +613,1 @@\n-    compile->remove_template_assertion_predicate_opaq(this);\n+    compile->remove_template_assertion_predicate_opaque(as_OpaqueTemplateAssertionPredicate());\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -115,0 +115,5 @@\n+OpaqueTemplateAssertionPredicateNode::OpaqueTemplateAssertionPredicateNode(BoolNode* bol): Node(nullptr, bol),\n+  _predicate_state(PredicateState::Useful) {\n+  init_class_id(Class_OpaqueTemplateAssertionPredicate);\n+}\n+\n@@ -126,1 +131,3 @@\n-  if (_useless || phase->C->post_loop_opts_phase()) {\n+  assert(_predicate_state != PredicateState::MaybeUseful, \"should only be MaybeUseful when eliminating useless \"\n+                                                          \"predicates during loop opts\");\n+  if (is_useless() || phase->C->post_loop_opts_phase()) {\n@@ -138,1 +145,1 @@\n-  _useless = true;\n+  _predicate_state = PredicateState::Useless;\n@@ -144,1 +151,1 @@\n-  if (_useless) {\n+  if (is_useless()) {\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,2 +29,4 @@\n-#include \"opto\/opcodes.hpp\"\n-#include \"subnode.hpp\"\n+#include \"opto\/predicates_enums.hpp\"\n+#include \"opto\/subnode.hpp\"\n+\n+enum class PredicateState;\n@@ -152,0 +154,1 @@\n+\n@@ -155,1 +158,1 @@\n-  bool _useless;\n+  PredicateState _predicate_state;\n@@ -164,4 +167,1 @@\n-  OpaqueTemplateAssertionPredicateNode(BoolNode* bol) : Node(nullptr, bol),\n-      _useless(false) {\n-    init_class_id(Class_OpaqueTemplateAssertionPredicate);\n-  }\n+  OpaqueTemplateAssertionPredicateNode(BoolNode* bol);\n@@ -175,0 +175,1 @@\n+\n@@ -176,1 +177,1 @@\n-    return _useless;\n+    return _predicate_state == PredicateState::Useless;\n@@ -180,0 +181,13 @@\n+\n+  void mark_maybe_useful() {\n+    _predicate_state = PredicateState::MaybeUseful;\n+  }\n+\n+  bool is_useful() const {\n+    return _predicate_state == PredicateState::Useful;\n+  }\n+\n+  void mark_useful() {\n+    _predicate_state = PredicateState::Useful;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  return has_assertion_predicate_opaque(maybe_success_proj) && has_halt(maybe_success_proj);\n+  return has_assertion_predicate_opaque(maybe_success_proj) && has_halt(maybe_success_proj->as_IfTrue());\n@@ -66,2 +66,2 @@\n-bool AssertionPredicate::has_halt(const Node* success_proj) {\n-  ProjNode* other_proj = success_proj->as_IfProj()->other_if_proj();\n+bool AssertionPredicate::has_halt(const IfTrueNode* success_proj) {\n+  ProjNode* other_proj = success_proj->other_if_proj();\n@@ -93,0 +93,5 @@\n+\/\/ Kills this Parse Predicate by marking it useless. Will be folded away in the next IGVN round.\n+void ParsePredicate::kill(PhaseIterGVN& igvn) const {\n+  _parse_predicate_node->mark_useless(igvn);\n+}\n+\n@@ -164,3 +169,3 @@\n-\/\/ Template Assertion Predicates always have the dedicated OpaqueTemplateAssertionPredicate to identify them.\n-bool TemplateAssertionPredicate::is_predicate(const Node* node) {\n-  if (!may_be_assertion_predicate_if(node)) {\n+\/\/ A Template Assertion Predicate always has a dedicated OpaqueTemplateAssertionPredicate to identify it.\n+bool TemplateAssertionPredicate::is_predicate(const Node* maybe_success_proj) {\n+  if (!may_be_assertion_predicate_if(maybe_success_proj)) {\n@@ -169,2 +174,5 @@\n-  IfNode* if_node = node->in(0)->as_If();\n-  return if_node->in(1)->is_OpaqueTemplateAssertionPredicate();\n+  IfNode* if_node = maybe_success_proj->in(0)->as_If();\n+  bool is_template_assertion_predicate = if_node->in(1)->is_OpaqueTemplateAssertionPredicate();\n+  assert(!is_template_assertion_predicate || AssertionPredicate::has_halt(maybe_success_proj->as_IfTrue()),\n+         \"Template Assertion Predicate must have a Halt Node on the failing path\");\n+  return is_template_assertion_predicate;\n@@ -296,4 +304,3 @@\n-\/\/ Initialized Assertion Predicates always have the dedicated OpaqueInitiailizedAssertionPredicate node to identify\n-\/\/ them.\n-bool InitializedAssertionPredicate::is_predicate(const Node* node) {\n-  if (!may_be_assertion_predicate_if(node)) {\n+\/\/ An Initialized Assertion Predicate always has a dedicated OpaqueInitializedAssertionPredicate node to identify it.\n+bool InitializedAssertionPredicate::is_predicate(const Node* maybe_success_proj) {\n+  if (!may_be_assertion_predicate_if(maybe_success_proj)) {\n@@ -302,2 +309,5 @@\n-  IfNode* if_node = node->in(0)->as_If();\n-  return if_node->in(1)->is_OpaqueInitializedAssertionPredicate();\n+  IfNode* if_node = maybe_success_proj->in(0)->as_If();\n+  bool is_initialized_assertion_predicate = if_node->in(1)->is_OpaqueInitializedAssertionPredicate();\n+  assert(!is_initialized_assertion_predicate || has_halt(maybe_success_proj->as_IfTrue()),\n+         \"Initialized Assertion Predicate must have a Halt Node on the failing path\");\n+  return is_initialized_assertion_predicate;\n@@ -306,0 +316,25 @@\n+#ifdef ASSERT\n+bool InitializedAssertionPredicate::has_halt(const IfTrueNode* success_proj) {\n+  ProjNode* other_proj = success_proj->other_if_proj();\n+  if (other_proj->outcnt() != 1) {\n+    return false;\n+  }\n+\n+  Node* out = other_proj->unique_out();\n+  \/\/ Either the Halt node is directly the unique output.\n+  if (out->is_Halt()) {\n+    return true;\n+  }\n+  \/\/ Or we have a Region that merges serval paths to a single Halt node. Even though OpaqueInitializedAssertionPredicate\n+  \/\/ nodes do not common up (i.e. NO_HASH), we could have Initialized Assertion Predicates from already folded loops\n+  \/\/ being now part of the innermost loop. When then further splitting this loop, we could be cloning the If node\n+  \/\/ of the Initialized Assertion Predicate (part of the loop body) while the OpaqueInitializedAssertionPredicate is not\n+  \/\/ cloned because it's outside the loop body. We end up sharing the OpaqueInitializedAssertionPredicate between the\n+  \/\/ original and the cloned If. This should be fine.\n+  if (out->is_Region() && out->outcnt() == 2) {\n+    return out->find_out_with(Op_Halt);\n+  }\n+  return false;\n+}\n+#endif \/\/ ASSERT\n+\n@@ -622,1 +657,1 @@\n-    _phase->C->add_template_assertion_predicate_opaq(new_expression);\n+    _phase->C->add_template_assertion_predicate_opaque(new_expression);\n@@ -1138,0 +1173,77 @@\n+\n+\/\/ Do the following to find and eliminate useless Parse and Template Assertion Predicates:\n+\/\/ 1. Mark all Parse and Template Assertion Predicates \"maybe useful\".\n+\/\/ 2. Walk through the loop tree and iterate over all Predicates above each loop head. All found Parse and Template\n+\/\/    Assertion Predicates are marked \"useful\".\n+\/\/ 3. Those Parse and Template Assertion Predicates that are still marked \"maybe useful\" are now marked \"useless\" and\n+\/\/    removed in the next round of IGVN.\n+\/\/\n+\/\/ Note that we only mark Predicates useless and not actually replace them now. We leave this work for IGVN which is\n+\/\/ better suited for this kind of graph surgery. We also not want to replace conditions with a constant to avoid\n+\/\/ interference with Predicate matching code when iterating through them.\n+void EliminateUselessPredicates::eliminate() const {\n+  mark_all_predicates_non_useful();\n+  if (C->has_loops()) {\n+    mark_loop_associated_predicates_useful();\n+  }\n+  mark_non_useful_predicates_useless();\n+}\n+\n+void EliminateUselessPredicates::mark_all_predicates_non_useful() const {\n+  mark_predicates_on_list_maybe_useful(_parse_predicates);\n+  mark_predicates_on_list_maybe_useful(_template_assertion_predicate_opaques);\n+}\n+\n+template<class PredicateList>\n+void EliminateUselessPredicates::mark_predicates_on_list_maybe_useful(const PredicateList& predicate_list) {\n+  for (int i = 0; i < predicate_list.length(); i++) {\n+    predicate_list.at(i)->mark_maybe_useful();\n+  }\n+}\n+\n+void EliminateUselessPredicates::mark_loop_associated_predicates_useful() const {\n+  for (LoopTreeIterator iterator(_ltree_root); !iterator.done(); iterator.next()) {\n+    IdealLoopTree* loop = iterator.current();\n+    if (loop->can_apply_loop_predication()) {\n+      mark_useful_predicates_for_loop(loop);\n+    }\n+  }\n+}\n+\n+\/\/ This visitor marks all visited Parse and Template Assertion Predicates useful.\n+class PredicateUsefulMarkerVisitor : public PredicateVisitor {\n+ public:\n+  using PredicateVisitor::visit;\n+\n+  void visit(const ParsePredicate& parse_predicate) override {\n+    parse_predicate.head()->mark_useful();\n+  }\n+\n+  \/\/ We actually mark the associated OpaqueTemplateAssertionPredicate node useful.\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    template_assertion_predicate.opaque_node()->mark_useful();\n+  }\n+};\n+\n+void EliminateUselessPredicates::mark_useful_predicates_for_loop(IdealLoopTree* loop) {\n+  Node* loop_entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n+  const PredicateIterator predicate_iterator(loop_entry);\n+  PredicateUsefulMarkerVisitor predicate_useful_marker_visitor;\n+  predicate_iterator.for_each(predicate_useful_marker_visitor);\n+}\n+\n+void EliminateUselessPredicates::mark_non_useful_predicates_useless() const {\n+  mark_non_useful_predicates_on_list_useless(_parse_predicates);\n+  mark_non_useful_predicates_on_list_useless(_template_assertion_predicate_opaques);\n+}\n+\n+template<class PredicateList>\n+void EliminateUselessPredicates::mark_non_useful_predicates_on_list_useless(\n+    const PredicateList& predicate_list) const {\n+  for (int i = 0; i < predicate_list.length(); i++) {\n+    auto predicate_node = predicate_list.at(i);\n+    if (!predicate_node->is_useful()) {\n+      predicate_node->mark_useless(_igvn);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":127,"deletions":15,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/predicates_enums.hpp\"\n@@ -203,10 +204,0 @@\n-\/\/ Assertion Predicates are either emitted to check the initial value of a range check in the first iteration or the last\n-\/\/ value of a range check in the last iteration of a loop.\n-enum class AssertionPredicateType {\n-  None, \/\/ Not an Assertion Predicate\n-  InitValue,\n-  LastValue,\n-  \/\/ Used for the Initialized Assertion Predicate emitted during Range Check Elimination for the final IV value.\n-  FinalIv\n-};\n-\n@@ -276,1 +267,1 @@\n-  static bool has_halt(const Node* success_proj);\n+\n@@ -279,0 +270,1 @@\n+  static bool has_halt(const IfTrueNode* success_proj);\n@@ -314,2 +306,3 @@\n-  \/\/ This Parse Predicate is valid if the node passed to the constructor is a projection of a ParsePredicateNode and the\n-  \/\/ deopt_reason of the uncommon trap of the ParsePredicateNode matches the passed deopt_reason to the constructor.\n+  \/\/ This Parse Predicate is valid if the node passed to the constructor is a projection of a ParsePredicateNode, the\n+  \/\/ deopt_reason of the uncommon trap of the ParsePredicateNode matches the passed deopt_reason to the constructor and\n+  \/\/ the ParsePredicateNode is not marked useless.\n@@ -317,1 +310,1 @@\n-    return _parse_predicate_node != nullptr;\n+    return _parse_predicate_node != nullptr && !_parse_predicate_node->is_useless();\n@@ -333,5 +326,1 @@\n-  \/\/ Kills this Parse Predicate by marking it useless. Will be folded away in the next IGVN round.\n-  void kill(const PhaseIterGVN& igvn) const {\n-    _parse_predicate_node->mark_useless();\n-    igvn._worklist.push(_parse_predicate_node);\n-  }\n+  void kill(PhaseIterGVN& igvn) const;\n@@ -436,0 +425,2 @@\n+  DEBUG_ONLY(static bool has_halt(const IfTrueNode* success_proj);)\n+\n@@ -1240,0 +1231,32 @@\n+\n+\/\/ Eliminate all useless Parse and Template Assertion Predicates. They become useless when they can no longer be found\n+\/\/ from a loop head. We mark these useless to clean them up later during IGVN. A Predicate that is marked useless will\n+\/\/ no longer be visited by a PredicateVisitor.\n+class EliminateUselessPredicates : public StackObj {\n+  Compile* const C;\n+  const GrowableArray<ParsePredicateNode*>& _parse_predicates;\n+  const GrowableArray<OpaqueTemplateAssertionPredicateNode*>& _template_assertion_predicate_opaques;\n+  PhaseIterGVN& _igvn;\n+  IdealLoopTree* const _ltree_root;\n+\n+  void mark_all_predicates_non_useful() const;\n+  template <class PredicateList>\n+  static void mark_predicates_on_list_maybe_useful(const PredicateList& predicate_list);\n+\n+  void mark_loop_associated_predicates_useful() const;\n+  static void mark_useful_predicates_for_loop(IdealLoopTree* loop);\n+\n+  void mark_non_useful_predicates_useless() const;\n+  template <class PredicateList>\n+  void mark_non_useful_predicates_on_list_useless(const PredicateList& predicate_list) const;\n+\n+ public:\n+  EliminateUselessPredicates(PhaseIterGVN& igvn, IdealLoopTree* ltree_root)\n+      : C(igvn.C), _parse_predicates(igvn.C->parse_predicates()),\n+        _template_assertion_predicate_opaques(igvn.C->template_assertion_predicate_opaques()),\n+        _igvn(igvn),\n+        _ltree_root(ltree_root) {}\n+\n+  void eliminate() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":42,"deletions":19,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_PREDICATES_ENUMS_HPP\n+#define SHARE_OPTO_PREDICATES_ENUMS_HPP\n+\n+\/\/ The success projection of a Parse Predicate is always an IfTrueNode and the uncommon projection an IfFalseNode\n+typedef IfTrueNode ParsePredicateSuccessProj;\n+typedef IfFalseNode ParsePredicateUncommonProj;\n+\n+\/\/ Assertion Predicates are either emitted to check the initial value of a range check in the first iteration or the last\n+\/\/ value of a range check in the last iteration of a loop.\n+enum class AssertionPredicateType {\n+  None, \/\/ Not an Assertion Predicate\n+  InitValue,\n+  LastValue,\n+  \/\/ Used for the Initialized Assertion Predicate emitted during Range Check Elimination for the final IV value.\n+  FinalIv\n+};\n+\n+enum class PredicateState {\n+  \/\/ The Predicate is useless and will be cleaned up in the next round of IGVN. A useless Predicate is not visited\n+  \/\/ anymore by PredicateVisitors. If a Predicate loses its connection to a loop head, it will be marked useless by\n+  \/\/ EliminateUselessPredicates and cleaned up by the Value() methods of the associated Predicate IR nodes.\n+  Useless,\n+  \/\/ This state is used by EliminateUselessPredicates to temporarily mark a Predicate as neither useless nor useful.\n+  \/\/ Outside EliminateUselessPredicates, a Predicate should never be MaybeUseful.\n+  MaybeUseful,\n+  \/\/ Default state: The Predicate is useful and will be visited by PredicateVisitors.\n+  Useful\n+};\n+\n+#endif \/\/ SHARE_OPTO_PREDICATES_ENUMS_HPP\n","filename":"src\/hotspot\/share\/opto\/predicates_enums.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}