{"files":[{"patch":"@@ -833,1 +833,1 @@\n-            StringLatin1.getChars(i, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(i, spaceNeeded, value);\n@@ -835,1 +835,1 @@\n-            StringUTF16.getChars(i, count, spaceNeeded, value);\n+            DecimalDigits.getCharsUTF16(i, spaceNeeded, value);\n@@ -858,1 +858,1 @@\n-            StringLatin1.getChars(l, spaceNeeded, value);\n+            DecimalDigits.getCharsLatin1(l, spaceNeeded, value);\n@@ -860,1 +860,1 @@\n-            StringUTF16.getChars(l, count, spaceNeeded, value);\n+            DecimalDigits.getCharsUTF16(l, spaceNeeded, value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -435,1 +435,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -439,1 +439,1 @@\n-            StringUTF16.getChars(i, size, buf);\n+            DecimalDigits.getCharsUTF16(i, size, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -469,1 +469,1 @@\n-            StringUTF16.getChars(i, size, buf);\n+            DecimalDigits.getCharsUTF16(i, size, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-            index = StringLatin1.getChars(value, index, buf);\n+            index = DecimalDigits.getCharsLatin1(value, index, buf);\n@@ -306,1 +306,1 @@\n-            index = StringUTF16.getChars(value, index, buf);\n+            index = DecimalDigits.getCharsUTF16(value, index, buf);\n@@ -327,1 +327,1 @@\n-            index = StringLatin1.getChars(value, index, buf);\n+            index = DecimalDigits.getCharsLatin1(value, index, buf);\n@@ -332,1 +332,1 @@\n-            index = StringUTF16.getChars(value, index, buf);\n+            index = DecimalDigits.getCharsUTF16(value, index, buf);\n@@ -685,1 +685,1 @@\n-            index = StringLatin1.getChars(value, index, buf);\n+            index = DecimalDigits.getCharsLatin1(value, index, buf);\n@@ -689,1 +689,1 @@\n-            index = StringUTF16.getChars(value, index, buf);\n+            index = DecimalDigits.getCharsUTF16(value, index, buf);\n@@ -709,1 +709,1 @@\n-            index = StringLatin1.getChars(value, index, buf);\n+            index = DecimalDigits.getCharsLatin1(value, index, buf);\n@@ -713,1 +713,1 @@\n-            index = StringUTF16.getChars(value, index, buf);\n+            index = DecimalDigits.getCharsUTF16(value, index, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.util.DecimalDigits;\n@@ -89,114 +88,0 @@\n-    \/**\n-     * Places characters representing the integer i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n-     * integer.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(int i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        int q;\n-        int charPos = index;\n-\n-        boolean negative = i < 0;\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Generate two digits per iteration\n-        while (i <= -100) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (q * 100) - i);\n-            i = q;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i < -9) {\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, -i);\n-        } else {\n-            buf[--charPos] = (byte)('0' - i);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n-    \/**\n-     * Places characters representing the long i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n-     * long.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(long i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        long q;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i <= Integer.MIN_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (int)((q * 100) - i));\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int)i;\n-        while (i2 <= -100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, (q2 * 100) - i2);\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 < -9) {\n-            charPos -= 2;\n-            writeDigitPair(buf, charPos, -i2);\n-        } else {\n-            buf[--charPos] = (byte)('0' - i2);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n-\n-    private static void writeDigitPair(byte[] buf, int charPos, int value) {\n-        short pair = DecimalDigits.digitPair(value);\n-        buf[charPos] = (byte)(pair);\n-        buf[charPos + 1] = (byte)(pair >> 8);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.util.DecimalDigits;\n@@ -1516,14 +1515,0 @@\n-    public static int getChars(int i, int begin, int end, byte[] value) {\n-        checkBoundsBeginEnd(begin, end, value);\n-        int pos = getChars(i, end, value);\n-        assert begin == pos;\n-        return pos;\n-    }\n-\n-    public static int getChars(long l, int begin, int end, byte[] value) {\n-        checkBoundsBeginEnd(begin, end, value);\n-        int pos = getChars(l, end, value);\n-        assert begin == pos;\n-        return pos;\n-    }\n-\n@@ -1665,103 +1650,0 @@\n-    \/\/ Used by trusted callers.  Assumes all necessary bounds checks have\n-    \/\/ been done by the caller.\n-\n-    \/**\n-     * This is a variant of {@link StringLatin1#getChars(int, int, byte[])}, but for\n-     * UTF-16 coder.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, UTF16-coded.\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(int i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        int q, r;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        while (i <= -100) {\n-            q = i \/ 100;\n-            r = (q * 100) - i;\n-            i = q;\n-            charPos -= 2;\n-            putPair(buf, charPos, r);\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i < -9) {\n-            charPos -= 2;\n-            putPair(buf, charPos, -i);\n-        } else {\n-            putChar(buf, --charPos, '0' - i);\n-        }\n-\n-        if (negative) {\n-            putChar(buf, --charPos, '-');\n-        }\n-        return charPos;\n-    }\n-\n-    \/**\n-     * This is a variant of {@link StringLatin1#getChars(long, int, byte[])}, but for\n-     * UTF-16 coder.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, UTF16-coded.\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    static int getChars(long i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        long q;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i <= Integer.MIN_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            putPair(buf, charPos, (int)((q * 100) - i));\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int)i;\n-        while (i2 <= -100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            putPair(buf, charPos, (q2 * 100) - i2);\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 < -9) {\n-            charPos -= 2;\n-            putPair(buf, charPos, -i2);\n-        } else {\n-            putChar(buf, --charPos, '0' - i2);\n-        }\n-\n-        if (negative) {\n-            putChar(buf, --charPos, '-');\n-        }\n-        return charPos;\n-    }\n-\n-    private static void putPair(byte[] buf, int charPos, int v) {\n-        int packed = (int) DecimalDigits.digitPair(v);\n-        putChar(buf, charPos, packed & 0xFF);\n-        putChar(buf, charPos + 1, packed >> 8);\n-    }\n-    \/\/ End of trusted methods.\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2182,8 +2182,0 @@\n-            public int getCharsLatin1(long i, int index, byte[] buf) {\n-                return StringLatin1.getChars(i, index, buf);\n-            }\n-\n-            public int getCharsUTF16(long i, int index, byte[] buf) {\n-                return StringUTF16.getChars(i, index, buf);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -41,0 +43,4 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -331,0 +337,2 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -4167,97 +4175,0 @@\n-    \/\/ Private class to build a string representation for BigDecimal object. The\n-    \/\/ StringBuilder field acts as a buffer to hold the temporary representation\n-    \/\/ of BigDecimal. The cmpCharArray holds all the characters for the compact\n-    \/\/ representation of BigDecimal (except for '-' sign' if it is negative) if\n-    \/\/ its intCompact field is not INFLATED.\n-    static class StringBuilderHelper {\n-        final StringBuilder sb;    \/\/ Placeholder for BigDecimal string\n-        final char[] cmpCharArray; \/\/ character array to place the intCompact\n-\n-        StringBuilderHelper() {\n-            sb = new StringBuilder(32);\n-            \/\/ All non negative longs can be made to fit into 19 character array.\n-            cmpCharArray = new char[19];\n-        }\n-\n-        \/\/ Accessors.\n-        StringBuilder getStringBuilder() {\n-            sb.setLength(0);\n-            return sb;\n-        }\n-\n-        char[] getCompactCharArray() {\n-            return cmpCharArray;\n-        }\n-\n-        \/**\n-         * Places characters representing the intCompact in {@code long} into\n-         * cmpCharArray and returns the offset to the array where the\n-         * representation starts.\n-         *\n-         * @param intCompact the number to put into the cmpCharArray.\n-         * @return offset to the array where the representation starts.\n-         * Note: intCompact must be greater or equal to zero.\n-         *\/\n-        int putIntCompact(long intCompact) {\n-            assert intCompact >= 0;\n-\n-            long q;\n-            int r;\n-            \/\/ since we start from the least significant digit, charPos points to\n-            \/\/ the last character in cmpCharArray.\n-            int charPos = cmpCharArray.length;\n-\n-            \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-            while (intCompact > Integer.MAX_VALUE) {\n-                q = intCompact \/ 100;\n-                r = (int)(intCompact - q * 100);\n-                intCompact = q;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n-            }\n-\n-            \/\/ Get 2 digits\/iteration using ints when i2 >= 100\n-            int q2;\n-            int i2 = (int)intCompact;\n-            while (i2 >= 100) {\n-                q2 = i2 \/ 100;\n-                r  = i2 - q2 * 100;\n-                i2 = q2;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n-            }\n-\n-            cmpCharArray[--charPos] = DIGIT_ONES[i2];\n-            if (i2 >= 10)\n-                cmpCharArray[--charPos] = DIGIT_TENS[i2];\n-\n-            return charPos;\n-        }\n-\n-        static final char[] DIGIT_TENS = {\n-            '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n-            '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n-            '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n-            '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n-            '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n-            '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n-            '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n-            '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n-            '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n-            '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n-        };\n-\n-        static final char[] DIGIT_ONES = {\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-        };\n-    }\n-\n@@ -4274,0 +4185,2 @@\n+        long intCompact = this.intCompact;\n+        int scale = this.scale;\n@@ -4283,3 +4196,10 @@\n-            return (Integer.toString(highInt) + '.' +\n-                    StringBuilderHelper.DIGIT_TENS[lowInt] +\n-                    StringBuilderHelper.DIGIT_ONES[lowInt]) ;\n+            int highIntSize = DecimalDigits.stringSize(highInt);\n+            byte[] buf = new byte[highIntSize + 3];\n+            DecimalDigits.getCharsLatin1(highInt, highIntSize, buf);\n+            buf[highIntSize] = '.';\n+            DecimalDigits.putPairLatin1(buf, highIntSize + 1, lowInt);\n+            try {\n+                return JLA.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+            } catch (CharacterCodingException cce) {\n+                throw new AssertionError(cce);\n+            }\n@@ -4288,1 +4208,0 @@\n-        StringBuilderHelper sbHelper = new StringBuilderHelper();\n@@ -4293,2 +4212,3 @@\n-            offset = sbHelper.putIntCompact(Math.abs(intCompact));\n-            coeff  = sbHelper.getCompactCharArray();\n+            \/\/ All non negative longs can be made to fit into 19 character array.\n+            coeff = new char[19];\n+            offset = DecimalDigits.getChars(Math.abs(intCompact), coeff.length, coeff);\n@@ -4304,1 +4224,1 @@\n-        StringBuilder buf = sbHelper.getStringBuilder();\n+        StringBuilder buf = new StringBuilder(32);;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":24,"deletions":104,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -474,4 +474,0 @@\n-    int getCharsLatin1(long i, int index, byte[] buf);\n-\n-    int getCharsUTF16(long i, int index, byte[] buf);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -30,0 +31,2 @@\n+import static jdk.internal.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+\n@@ -36,0 +39,1 @@\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -41,2 +45,2 @@\n-     *      01 -> '1' | ('0' << 8) -> 0x3130\n-     *      02 -> '2' | ('0' << 8) -> 0x3230\n+     *      01 -> '0' | ('1' << 8) -> 0x3130\n+     *      02 -> '0' | ('2' << 8) -> 0x3230\n@@ -46,1 +50,1 @@\n-     *      10 -> '0' | ('1' << 8) -> 0x3031\n+     *      10 -> '1' | ('0' << 8) -> 0x3031\n@@ -48,1 +52,1 @@\n-     *      12 -> '2' | ('1' << 8) -> 0x3231\n+     *      12 -> '1' | ('2' << 8) -> 0x3231\n@@ -52,2 +56,2 @@\n-     *      97 -> '7' | ('9' << 8) -> 0x3739\n-     *      98 -> '8' | ('9' << 8) -> 0x3839\n+     *      97 -> '9' | ('7' << 8) -> 0x3739\n+     *      98 -> '9' | ('8' << 8) -> 0x3839\n@@ -79,9 +83,0 @@\n-    \/**\n-     * For values from 0 to 99 return a short encoding a pair of ASCII-encoded digit characters in little-endian\n-     * @param i value to convert\n-     * @return a short encoding a pair of ASCII-encoded digit characters\n-     *\/\n-    public static short digitPair(int i) {\n-        return DIGITS[i];\n-    }\n-\n@@ -139,0 +134,301 @@\n+\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n+     * integer.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q;\n+        int charPos = index;\n+\n+        boolean negative = i < 0;\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Generate two digits per iteration\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            putPairLatin1(buf, charPos, (q * 100) - i);\n+            i = q;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i <= -10) {\n+            charPos -= 2;\n+            putPairLatin1(buf, charPos, -i);\n+        } else {\n+            putCharLatin1(buf, --charPos, '0' - i);\n+        }\n+\n+        if (negative) {\n+            putCharLatin1(buf, --charPos, '-');\n+        }\n+        return charPos;\n+    }\n+\n+\n+    \/**\n+     * Places characters representing the long i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Long.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Long.MIN_VALUE that overflows\n+     * long.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(long i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        long q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i < Integer.MIN_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            putPairLatin1(buf, charPos, (int)((q * 100) - i));\n+            i = q;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int)i;\n+        while (i2 <= -100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            putPairLatin1(buf, charPos, (q2 * 100) - i2);\n+            i2 = q2;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 <= -10) {\n+            charPos -= 2;\n+            putPairLatin1(buf, charPos, -i2);\n+        } else {\n+            putCharLatin1(buf, --charPos, '0' - i2);\n+        }\n+\n+        if (negative) {\n+            putCharLatin1(buf, --charPos, '-');\n+        }\n+        return charPos;\n+    }\n+\n+\n+    \/**\n+     * This is a variant of {@link DecimalDigits#getCharsLatin1(int, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, UTF16-coded.\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsUTF16(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            putPairUTF16(buf, charPos, (q * 100) - i);\n+            i = q;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i <= -10) {\n+            charPos -= 2;\n+            putPairUTF16(buf, charPos, -i);\n+        } else {\n+            putCharUTF16(buf, --charPos, '0' - i);\n+        }\n+\n+        if (negative) {\n+            putCharUTF16(buf, --charPos, '-');\n+        }\n+        return charPos;\n+    }\n+\n+\n+    \/**\n+     * This is a variant of {@link DecimalDigits#getCharsLatin1(long, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, UTF16-coded.\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsUTF16(long i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        long q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i < Integer.MIN_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            putPairUTF16(buf, charPos, (int)((q * 100) - i));\n+            i = q;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int)i;\n+        while (i2 <= -100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            putPairUTF16(buf, charPos, (q2 * 100) - i2);\n+            i2 = q2;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 <= -10) {\n+            charPos -= 2;\n+            putPairUTF16(buf, charPos, -i2);\n+        } else {\n+            putCharUTF16(buf, --charPos, '0' - i2);\n+        }\n+\n+        if (negative) {\n+            putCharUTF16(buf, --charPos, '-');\n+        }\n+        return charPos;\n+    }\n+\n+    \/**\n+     * This is a variant of {@link DecimalDigits#getCharsUTF16(long, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, UTF16-coded.\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getChars(long i, int index, char[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        long q;\n+        int charPos = index;\n+\n+        boolean negative = (i < 0);\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i < Integer.MIN_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            putPair(buf, charPos, (int)((q * 100) - i));\n+            i = q;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int)i;\n+        while (i2 <= -100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            putPair(buf, charPos, (q2 * 100) - i2);\n+            i2 = q2;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 <= -10) {\n+            charPos -= 2;\n+            putPair(buf, charPos, -i2);\n+        } else {\n+            buf[--charPos] = (char) ('0' - i2);\n+        }\n+\n+        if (negative) {\n+            buf[--charPos] = '-';\n+        }\n+        return charPos;\n+    }\n+\n+    \/**\n+     * Insert the 2-chars integer into the buf as 2 decimal digit ASCII chars,\n+     * only least significant 16 bits of {@code v} are used.\n+     * @param buf byte buffer to copy into\n+     * @param charPos insert point\n+     * @param v to convert\n+     *\/\n+    public static void putPair(char[] buf, int charPos, int v) {\n+        int packed = DIGITS[v];\n+        buf[charPos    ] = (char) (packed & 0xFF);\n+        buf[charPos + 1] = (char) (packed >> 8);\n+    }\n+\n+    \/**\n+     * Insert the 2-bytes integer into the buf as 2 decimal digit ASCII bytes,\n+     * only least significant 16 bits of {@code v} are used.\n+     * @param buf byte buffer to copy into\n+     * @param charPos insert point\n+     * @param v to convert\n+     *\/\n+    public static void putPairLatin1(byte[] buf, int charPos, int v) {\n+        int packed = DIGITS[v];\n+        putCharLatin1(buf, charPos, packed & 0xFF);\n+        putCharLatin1(buf, charPos + 1, packed >> 8);\n+    }\n+\n+    \/**\n+     * Insert the 2-chars integer into the buf as 2 decimal digit UTF16 bytes,\n+     * only least significant 16 bits of {@code v} are used.\n+     * @param buf byte buffer to copy into\n+     * @param charPos insert point\n+     * @param v to convert\n+     *\/\n+    public static void putPairUTF16(byte[] buf, int charPos, int v) {\n+        int packed = DIGITS[v];\n+        putCharUTF16(buf, charPos, packed & 0xFF);\n+        putCharUTF16(buf, charPos + 1, packed >> 8);\n+    }\n+\n+    private static void putCharLatin1(byte[] buf, int charPos, int c) {\n+        UNSAFE.putByte(buf, ARRAY_BYTE_BASE_OFFSET + (long) charPos, (byte) c);\n+    }\n+\n+    private static void putCharUTF16(byte[] buf, int charPos, int c) {\n+        UNSAFE.putCharUnaligned(buf, ARRAY_BYTE_BASE_OFFSET + ((long) charPos << 1), (char) c);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":311,"deletions":15,"binary":false,"changes":326,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -120,1 +122,4 @@\n-        return StringUTF16.getChars(i, begin, end, value);\n+        StringUTF16.checkBoundsBeginEnd(begin, end, value);\n+        int pos = DecimalDigits.getCharsUTF16(i, end, value);\n+        assert begin == pos;\n+        return pos;\n@@ -124,1 +129,4 @@\n-        return StringUTF16.getChars(l, begin, end, value);\n+        StringUTF16.checkBoundsBeginEnd(begin, end, value);\n+        int pos = DecimalDigits.getCharsUTF16(l, end, value);\n+        assert begin == pos;\n+        return pos;\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    private int[] intArray;\n+    private long[] longArray;\n@@ -72,0 +74,7 @@\n+        int size = 16;\n+        intArray = new int[size];\n+        longArray = new long[size];\n+        for (int i = 0; i < longArray.length; i++) {\n+            intArray[i] = ((100 * i + i) << 24) + 4543 + i * 4;\n+            longArray[i] = ((100L * i + i) << 32) + 4543 + i * 4L;\n+        }\n@@ -227,0 +236,39 @@\n+    @Benchmark\n+    public int appendWithIntLatin1() {\n+        StringBuilder buf = sbLatin1;\n+        buf.setLength(0);\n+        for (int i : intArray) {\n+            buf.append(i);\n+        }\n+        return buf.length();\n+    }\n+\n+    @Benchmark\n+    public int appendWithIntUtf16() {\n+        StringBuilder buf = sbUtf16;\n+        buf.setLength(0);\n+        for (int i : intArray) {\n+            buf.append(i);\n+        }\n+        return buf.length();\n+    }\n+\n+    @Benchmark\n+    public int appendWithLongLatin1() {\n+        StringBuilder buf = sbLatin1;\n+        buf.setLength(0);\n+        for (long l : longArray) {\n+            buf.append(l);\n+        }\n+        return buf.length();\n+    }\n+\n+    @Benchmark\n+    public int appendWithLongUtf16() {\n+        StringBuilder buf = sbUtf16;\n+        buf.setLength(0);\n+        for (long l : longArray) {\n+            buf.append(l);\n+        }\n+        return buf.length();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringBuilders.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"}]}