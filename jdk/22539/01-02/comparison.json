{"files":[{"patch":"@@ -133,4 +133,21 @@\n-        if (length == 0) {\n-            \/\/ The state has to be checked explicitly for zero-length segments\n-            segment.scope.checkValidState();\n-            throw nullNotFound(segment, fromOffset, toOffset);\n+        if (length < 3) {\n+            switch ((int) length) {\n+                case 0:\n+                    \/\/ There can be no null terminator present\n+                    segment.scope.checkValidState();\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 1:\n+                    if (SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset) == 0) {\n+                        return 0;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 2:\n+                    final short val = SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian());\n+                    if ((val & 0x00ff) == 0) {\n+                        return 0;\n+                    }\n+                    if ((val & 0xff00) == 0) {\n+                        return 1;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+            }\n@@ -167,3 +184,21 @@\n-        if (length == 0) {\n-            segment.scope.checkValidState();\n-            throw nullNotFound(segment, fromOffset, toOffset);\n+        if (length < 3 * Short.BYTES) {\n+            switch ((int) length >> 1) {\n+                case 0:\n+                    \/\/ There can be no null terminator present\n+                    segment.scope.checkValidState();\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 1:\n+                    if (SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian()) == 0) {\n+                        return 0;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 2:\n+                    final int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian());\n+                    if ((val & 0x0000_ffff) == 0) {\n+                        return 0;\n+                    }\n+                    if ((val & 0xffff_0000) == 0) {\n+                        return Short.BYTES;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+            }\n@@ -202,3 +237,21 @@\n-        if (length == 0) {\n-            segment.scope.checkValidState();\n-            throw nullNotFound(segment, fromOffset, toOffset);\n+        if (length < 3 * Integer.BYTES) {\n+            switch ((int) length >> 2) {\n+                case 0:\n+                    \/\/ There can be no null terminator present\n+                    segment.scope.checkValidState();\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 1:\n+                    if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian()) == 0) {\n+                        return 0;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 2:\n+                    final long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian());\n+                    if ((val & 0x0000_0000__ffff_ffffL) == 0) {\n+                        return 0;\n+                    }\n+                    if ((val & 0xffff_ffff__0000_0000L) == 0) {\n+                        return Integer.BYTES;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":63,"deletions":10,"binary":false,"changes":73,"status":"modified"}]}