{"files":[{"patch":"@@ -133,4 +133,21 @@\n-        if (length == 0) {\n-            \/\/ The state has to be checked explicitly for zero-length segments\n-            segment.scope.checkValidState();\n-            throw nullNotFound(segment, fromOffset, toOffset);\n+        if (length < 3) {\n+            switch ((int) length) {\n+                case 0:\n+                    \/\/ There can be no null terminator present\n+                    segment.scope.checkValidState();\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 1:\n+                    if (SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset) == 0) {\n+                        return 0;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 2:\n+                    final short val = SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian());\n+                    if ((val & 0x00ff) == 0) {\n+                        return 0;\n+                    }\n+                    if ((val & 0xff00) == 0) {\n+                        return 1;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+            }\n@@ -167,3 +184,21 @@\n-        if (length == 0) {\n-            segment.scope.checkValidState();\n-            throw nullNotFound(segment, fromOffset, toOffset);\n+        if (length < 3 * Short.BYTES) {\n+            switch ((int) length >> 1) {\n+                case 0:\n+                    \/\/ There can be no null terminator present\n+                    segment.scope.checkValidState();\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 1:\n+                    if (SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian()) == 0) {\n+                        return 0;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 2:\n+                    final int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian());\n+                    if ((val & 0x0000_ffff) == 0) {\n+                        return 0;\n+                    }\n+                    if ((val & 0xffff_0000) == 0) {\n+                        return Short.BYTES;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+            }\n@@ -202,3 +237,21 @@\n-        if (length == 0) {\n-            segment.scope.checkValidState();\n-            throw nullNotFound(segment, fromOffset, toOffset);\n+        if (length < 3 * Integer.BYTES) {\n+            switch ((int) length >> 2) {\n+                case 0:\n+                    \/\/ There can be no null terminator present\n+                    segment.scope.checkValidState();\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 1:\n+                    if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian()) == 0) {\n+                        return 0;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+                case 2:\n+                    final long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + fromOffset, !Architecture.isLittleEndian());\n+                    if ((val & 0x0000_0000__ffff_ffffL) == 0) {\n+                        return 0;\n+                    }\n+                    if ((val & 0xffff_ffff__0000_0000L) == 0) {\n+                        return Integer.BYTES;\n+                    }\n+                    throw nullNotFound(segment, fromOffset, toOffset);\n+            }\n@@ -206,2 +259,0 @@\n-        final long longBytes = length & LONG_MASK;\n-        final long longLimit = fromOffset + longBytes;\n@@ -209,6 +260,11 @@\n-        for (; offset < longLimit; offset += Long.BYTES) {\n-            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n-            if (mightContainZeroInt(val)) {\n-                for (int j = 0; j < Long.BYTES; j += Integer.BYTES) {\n-                    if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n-                        return requireWithinStringSize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+        \/\/ For quad byte strings, it does not pay off to use long scanning on x64\n+        if (!Architecture.isX64()) {\n+            final long longBytes = length & LONG_MASK;\n+            final long longLimit = fromOffset + longBytes;\n+            for (; offset < longLimit; offset += Long.BYTES) {\n+                long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+                if (mightContainZeroInt(val)) {\n+                    for (int j = 0; j < Long.BYTES; j += Integer.BYTES) {\n+                        if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                            return requireWithinStringSize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":74,"deletions":18,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -58,4 +58,4 @@\n-    private AbstractMemorySegmentImpl singleByteSegment;\n-    private AbstractMemorySegmentImpl singleByteSegmentMisaligned;\n-    private AbstractMemorySegmentImpl doubleByteSegment;\n-    private AbstractMemorySegmentImpl quadByteSegment;\n+    private MemorySegment singleByteSegment;\n+    private MemorySegment singleByteSegmentMisaligned;\n+    private MemorySegment doubleByteSegment;\n+    private MemorySegment quadByteSegment;\n@@ -69,3 +69,3 @@\n-        singleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Byte.BYTES);\n-        doubleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Short.BYTES);\n-        quadByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Integer.BYTES);\n+        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n@@ -82,1 +82,1 @@\n-        singleByteSegmentMisaligned = (AbstractMemorySegmentImpl) arena.allocate(singleByteSegment.byteSize() + 1).\n+        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n@@ -109,1 +109,1 @@\n-        return StringSupport.strlenByte(singleByteSegment, 0, singleByteSegment.byteSize());\n+        return StringSupport.strlenByte((AbstractMemorySegmentImpl) singleByteSegment, 0, singleByteSegment.byteSize());\n@@ -114,1 +114,1 @@\n-        return StringSupport.strlenByte(singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n+        return StringSupport.strlenByte((AbstractMemorySegmentImpl) singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n@@ -119,1 +119,1 @@\n-        return StringSupport.strlenShort(doubleByteSegment, 0, doubleByteSegment.byteSize());\n+        return StringSupport.strlenShort((AbstractMemorySegmentImpl) doubleByteSegment, 0, doubleByteSegment.byteSize());\n@@ -124,1 +124,1 @@\n-        return StringSupport.strlenInt(quadByteSegment, 0, quadByteSegment.byteSize());\n+        return StringSupport.strlenInt((AbstractMemorySegmentImpl) quadByteSegment, 0, quadByteSegment.byteSize());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}