{"files":[{"patch":"@@ -133,2 +133,2 @@\n-        if (length == 0) {\n-            \/\/ The state has to be checked explicitly for zero-length segments\n+        if (length < Byte.BYTES) {\n+            \/\/ There can be no null terminator present\n@@ -167,1 +167,2 @@\n-        if (length == 0) {\n+        if (length < Short.BYTES) {\n+            \/\/ There can be no null terminator present\n@@ -202,1 +203,2 @@\n-        if (length == 0) {\n+        if (length < Integer.BYTES) {\n+            \/\/ There can be no null terminator present\n@@ -206,2 +208,0 @@\n-        final long longBytes = length & LONG_MASK;\n-        final long longLimit = fromOffset + longBytes;\n@@ -209,6 +209,11 @@\n-        for (; offset < longLimit; offset += Long.BYTES) {\n-            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n-            if (mightContainZeroInt(val)) {\n-                for (int j = 0; j < Long.BYTES; j += Integer.BYTES) {\n-                    if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n-                        return requireWithinStringSize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+        \/\/ For quad byte strings, it does not pay off to use long scanning on x64\n+        if (!Architecture.isX64()) {\n+            final long longBytes = length & LONG_MASK;\n+            final long longLimit = fromOffset + longBytes;\n+            for (; offset < longLimit; offset += Long.BYTES) {\n+                long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+                if (mightContainZeroInt(val)) {\n+                    for (int j = 0; j < Long.BYTES; j += Integer.BYTES) {\n+                        if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                            return requireWithinStringSize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -58,4 +58,4 @@\n-    private AbstractMemorySegmentImpl singleByteSegment;\n-    private AbstractMemorySegmentImpl singleByteSegmentMisaligned;\n-    private AbstractMemorySegmentImpl doubleByteSegment;\n-    private AbstractMemorySegmentImpl quadByteSegment;\n+    private MemorySegment singleByteSegment;\n+    private MemorySegment singleByteSegmentMisaligned;\n+    private MemorySegment doubleByteSegment;\n+    private MemorySegment quadByteSegment;\n@@ -69,3 +69,3 @@\n-        singleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Byte.BYTES);\n-        doubleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Short.BYTES);\n-        quadByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Integer.BYTES);\n+        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n@@ -82,1 +82,1 @@\n-        singleByteSegmentMisaligned = (AbstractMemorySegmentImpl) arena.allocate(singleByteSegment.byteSize() + 1).\n+        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n@@ -109,1 +109,1 @@\n-        return StringSupport.strlenByte(singleByteSegment, 0, singleByteSegment.byteSize());\n+        return StringSupport.strlenByte((AbstractMemorySegmentImpl) singleByteSegment, 0, singleByteSegment.byteSize());\n@@ -114,1 +114,1 @@\n-        return StringSupport.strlenByte(singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n+        return StringSupport.strlenByte((AbstractMemorySegmentImpl) singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n@@ -119,1 +119,1 @@\n-        return StringSupport.strlenShort(doubleByteSegment, 0, doubleByteSegment.byteSize());\n+        return StringSupport.strlenShort((AbstractMemorySegmentImpl) doubleByteSegment, 0, doubleByteSegment.byteSize());\n@@ -124,1 +124,1 @@\n-        return StringSupport.strlenInt(quadByteSegment, 0, quadByteSegment.byteSize());\n+        return StringSupport.strlenInt((AbstractMemorySegmentImpl) quadByteSegment, 0, quadByteSegment.byteSize());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}