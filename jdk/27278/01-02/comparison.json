{"files":[{"patch":"@@ -1441,14 +1441,0 @@\n-\n-  \/\/ Cannot access humongous_obj->size() in case class has been unloaded\n-  size_t required_regions = 1;\n-  size_t region_count = num_regions();\n-  for (size_t index = start->index() + 1; index < region_count; index++) {\n-    ShenandoahHeapRegion* region = get_region(index);\n-    if (region->is_humongous_continuation()) {\n-      required_regions++;\n-    } else {\n-      break;\n-    }\n-  }\n-\n-  size_t index = start->index() + required_regions - 1;\n@@ -1456,5 +1442,7 @@\n-  \/\/ Reclaim from tail. Otherwise, assertion fails when printing region to trace log,\n-  \/\/ as it expects that every region belongs to a humongous region starting with a humongous start region.\n-  for(size_t i = 0; i < required_regions; i++) {\n-    ShenandoahHeapRegion* region = get_region(index --);\n-    assert(region->is_humongous(), \"expect correct humongous start or continuation\");\n+\n+  \/\/ Do not try to get the size of this humongous object. STW collections will\n+  \/\/ have already unloaded classes, so an unmarked object may have a bad klass pointer.\n+  ShenandoahHeapRegion* region = start;\n+  size_t index = region->index();\n+  do {\n+    assert(region->is_humongous(), \"Expect correct humongous start or continuation\");\n@@ -1463,2 +1451,5 @@\n-  }\n-  return required_regions;\n+    region = get_region(++index);\n+  } while (region != nullptr && region->is_humongous_continuation());\n+\n+  \/\/ Return number of regions trashed\n+  return index - start->index();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"}]}