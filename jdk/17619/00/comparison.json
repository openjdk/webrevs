{"files":[{"patch":"@@ -4,0 +4,10 @@\n+Changes in 1.3.1 (22 Jan 2024)\n+- Reject overflows of zip header fields in minizip\n+- Fix bug in inflateSync() for data held in bit buffer\n+- Add LIT_MEM define to use more memory for a small deflate speedup\n+- Fix decision on the emission of Zip64 end records in minizip\n+- Add bounds checking to ERR_MSG() macro, used by zError()\n+- Neutralize zip file traversal attacks in miniunz\n+- Fix a bug in ZLIB_DEBUG compiles in check_match()\n+- Various portability and appearance improvements\n+\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/ChangeLog","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-zlib 1.3 is a general purpose data compression library.  All the code is\n+zlib 1.3.1 is a general purpose data compression library.  All the code is\n@@ -34,1 +34,1 @@\n-The changes made in version 1.3 are documented in the file ChangeLog.\n+The changes made in version 1.3.1 are documented in the file ChangeLog.\n@@ -86,1 +86,1 @@\n- (C) 1995-2023 Jean-loup Gailly and Mark Adler\n+ (C) 1995-2024 Jean-loup Gailly and Mark Adler\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/README","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2023 Jean-loup Gailly and Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n@@ -79,1 +79,1 @@\n-   \" deflate 1.3 Copyright 1995-2023 Jean-loup Gailly and Mark Adler \";\n+   \" deflate 1.3.1 Copyright 1995-2024 Jean-loup Gailly and Mark Adler \";\n@@ -520,1 +520,1 @@\n-    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);\n+    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);\n@@ -530,0 +530,5 @@\n+#ifdef LIT_MEM\n+    s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize << 1));\n+    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);\n+    s->sym_end = s->lit_bufsize - 1;\n+#else\n@@ -532,0 +537,1 @@\n+#endif\n@@ -747,0 +753,5 @@\n+#ifdef LIT_MEM\n+    if (bits < 0 || bits > 16 ||\n+        (uchf *)s->d_buf < s->pending_out + ((Buf_size + 7) >> 3))\n+        return Z_BUF_ERROR;\n+#else\n@@ -750,0 +761,1 @@\n+#endif\n@@ -1321,1 +1333,1 @@\n-    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n+    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);\n@@ -1332,1 +1344,1 @@\n-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n+    zmemcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);\n@@ -1335,0 +1347,4 @@\n+#ifdef LIT_MEM\n+    ds->d_buf = (ushf *)(ds->pending_buf + (ds->lit_bufsize << 1));\n+    ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);\n+#else\n@@ -1336,0 +1352,1 @@\n+#endif\n@@ -1566,4 +1583,12 @@\n-    if (zmemcmp(s->window + match,\n-                s->window + start, length) != EQUAL) {\n-        fprintf(stderr, \" start %u, match %u, length %d\\n\",\n-                start, match, length);\n+    Bytef *back = s->window + (int)match, *here = s->window + start;\n+    IPos len = length;\n+    if (match == (IPos)-1) {\n+        \/* match starts one byte before the current window -- just compare the\n+           subsequent length-1 bytes *\/\n+        back++;\n+        here++;\n+        len--;\n+    }\n+    if (zmemcmp(back, here, len) != EQUAL) {\n+        fprintf(stderr, \" start %u, match %d, length %d\\n\",\n+                start, (int)match, length);\n@@ -1571,2 +1596,2 @@\n-            fprintf(stderr, \"%c%c\", s->window[match++], s->window[start++]);\n-        } while (--length != 0);\n+            fprintf(stderr, \"(%02x %02x)\", *back++, *here++);\n+        } while (--len != 0);\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/deflate.c","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2018 Jean-loup Gailly\n+ * Copyright (C) 1995-2024 Jean-loup Gailly\n@@ -50,0 +50,4 @@\n+\/* define LIT_MEM to slightly increase the speed of deflate (order 1% to 2%) at\n+   the cost of a larger memory footprint *\/\n+\/* #define LIT_MEM *\/\n+\n@@ -244,0 +248,6 @@\n+#ifdef LIT_MEM\n+#   define LIT_BUFS 5\n+    ushf *d_buf;          \/* buffer for distances *\/\n+    uchf *l_buf;          \/* buffer for literals\/lengths *\/\n+#else\n+#   define LIT_BUFS 4\n@@ -245,0 +255,1 @@\n+#endif\n@@ -266,1 +277,1 @@\n-    uInt sym_next;      \/* running index in sym_buf *\/\n+    uInt sym_next;      \/* running index in symbol buffer *\/\n@@ -345,0 +356,19 @@\n+#ifdef LIT_MEM\n+# define _tr_tally_lit(s, c, flush) \\\n+  { uch cc = (c); \\\n+    s->d_buf[s->sym_next] = 0; \\\n+    s->l_buf[s->sym_next++] = cc; \\\n+    s->dyn_ltree[cc].Freq++; \\\n+    flush = (s->sym_next == s->sym_end); \\\n+   }\n+# define _tr_tally_dist(s, distance, length, flush) \\\n+  { uch len = (uch)(length); \\\n+    ush dist = (ush)(distance); \\\n+    s->d_buf[s->sym_next] = dist; \\\n+    s->l_buf[s->sym_next++] = len; \\\n+    dist--; \\\n+    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\\n+    s->dyn_dtree[d_code(dist)].Freq++; \\\n+    flush = (s->sym_next == s->sym_end); \\\n+  }\n+#else\n@@ -364,0 +394,1 @@\n+#endif\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/deflate.h","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 2004-2019 Mark Adler\n+ * Copyright (C) 2004-2024 Mark Adler\n@@ -237,3 +237,0 @@\n-#ifdef INT_MAX\n-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)\n-#else\n@@ -241,2 +238,1 @@\n-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())\n-#endif\n+#define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/gzguts.h","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 2004-2019 Mark Adler\n+ * Copyright (C) 2004-2024 Mark Adler\n@@ -590,1 +590,0 @@\n-#ifndef INT_MAX\n@@ -596,3 +595,4 @@\n-    unsigned p, q;\n-\n-    p = 1;\n+#ifdef INT_MAX\n+    return INT_MAX;\n+#else\n+    unsigned p = 1, q;\n@@ -605,1 +605,0 @@\n-}\n@@ -607,0 +606,1 @@\n+}\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/gzlib.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1414,1 +1414,1 @@\n-        state->hold <<= state->bits & 7;\n+        state->hold >>= state->bits & 7;\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inflate.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2023 Mark Adler\n+ * Copyright (C) 1995-2024 Mark Adler\n@@ -36,1 +36,1 @@\n-   \" inflate 1.3 Copyright 1995-2023 Mark Adler \";\n+   \" inflate 1.3.1 Copyright 1995-2024 Mark Adler \";\n@@ -84,1 +84,1 @@\n-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 198, 203};\n+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 77};\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inftrees.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-   returns returns 852, and \"enough 30 6 15\" for distance codes returns 592.\n-   The initial root table size (9 or 6) is found in the fifth argument of the\n+   returns 852, and \"enough 30 6 15\" for distance codes returns 592. The\n+   initial root table size (9 or 6) is found in the fifth argument of the\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inftrees.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Changes from zlib 1.3\n+Changes from zlib 1.3.1\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/patches\/ChangeLog_java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2021 Jean-loup Gailly\n+ * Copyright (C) 1995-2024 Jean-loup Gailly\n@@ -926,1 +926,1 @@\n-    unsigned sx = 0;    \/* running index in sym_buf *\/\n+    unsigned sx = 0;    \/* running index in symbol buffers *\/\n@@ -931,0 +931,4 @@\n+#ifdef LIT_MEM\n+        dist = s->d_buf[sx];\n+        lc = s->l_buf[sx++];\n+#else\n@@ -934,0 +938,1 @@\n+#endif\n@@ -958,1 +963,4 @@\n-        \/* Check that the overlay between pending_buf and sym_buf is ok: *\/\n+        \/* Check for no overlay of pending_buf on needed symbols *\/\n+#ifdef LIT_MEM\n+        Assert(s->pending < 2 * (s->lit_bufsize + sx), \"pendingBuf overflow\");\n+#else\n@@ -960,0 +968,1 @@\n+#endif\n@@ -1109,0 +1118,4 @@\n+#ifdef LIT_MEM\n+    s->d_buf[s->sym_next] = (ush)dist;\n+    s->l_buf[s->sym_next++] = (uch)lc;\n+#else\n@@ -1112,0 +1125,1 @@\n+#endif\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/trees.c","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n@@ -327,8 +327,0 @@\n-#ifndef Z_ARG \/* function prototypes for stdarg *\/\n-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)\n-#    define Z_ARG(args)  args\n-#  else\n-#    define Z_ARG(args)  ()\n-#  endif\n-#endif\n-\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zconf.h","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-  version 1.3, August 18th, 2023\n+  version 1.3.1, January 22nd, 2024\n@@ -28,1 +28,1 @@\n-  Copyright (C) 1995-2023 Jean-loup Gailly and Mark Adler\n+  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n@@ -64,2 +64,2 @@\n-#define ZLIB_VERSION \"1.3\"\n-#define ZLIB_VERNUM 0x1300\n+#define ZLIB_VERSION \"1.3.1\"\n+#define ZLIB_VERNUM 0x1310\n@@ -68,1 +68,1 @@\n-#define ZLIB_VER_REVISION 0\n+#define ZLIB_VER_REVISION 1\n@@ -963,4 +963,4 @@\n-   In the success case, the application may save the current current value of\n-   total_in which indicates where valid compressed data was found.  In the\n-   error case, the application may repeatedly call inflateSync, providing more\n-   input each time, until success or end of the input data.\n+   In the success case, the application may save the current value of total_in\n+   which indicates where valid compressed data was found.  In the error case,\n+   the application may repeatedly call inflateSync, providing more input each\n+   time, until success or end of the input data.\n@@ -1785,1 +1785,1 @@\n-   len2.\n+   len2. len2 must be non-negative.\n@@ -1792,1 +1792,1 @@\n-   crc32_combine_op().\n+   crc32_combine_op(). len2 must be non-negative.\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zlib.h","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2022 Jean-loup Gailly, Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n@@ -83,1 +83,1 @@\n-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]\n+#define ERR_MSG(err) z_errmsg[(err) < -6 || (err) > 2 ? 9 : 2 - (err)]\n@@ -164,1 +164,1 @@\n-#if defined(MACOS) || defined(TARGET_OS_MAC)\n+#if defined(MACOS)\n@@ -166,9 +166,0 @@\n-#  ifndef Z_SOLO\n-#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os\n-#      include <unix.h> \/* for fdopen *\/\n-#    else\n-#      ifndef fdopen\n-#        define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#      endif\n-#    endif\n-#  endif\n@@ -197,12 +188,0 @@\n-#if defined(_BEOS_) || defined(RISCOS)\n-#  define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#endif\n-\n-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX\n-#  if defined(_WIN32_WCE)\n-#    define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#  else\n-#    define fdopen(fd,type)  _fdopen(fd,type)\n-#  endif\n-#endif\n-\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zutil.h","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"}]}