{"files":[{"patch":"@@ -1338,1 +1338,7 @@\n-        byte[] dst = new byte[sl * 3];\n+        \/\/ UTF-8 encoded can be as much as 3 times the string length\n+        \/\/ For very large estimate, (as in overflow of 32 bit int), precompute the exact size\n+        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val, doReplace) : sl * 3;\n+        if (allocLen > (long)Integer.MAX_VALUE) {\n+            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n+        }\n+        byte[] dst = new byte[(int) allocLen];\n@@ -1388,0 +1394,41 @@\n+    \/**\n+     * {@return the exact size required to UTF_8 encode this UTF16 string}\n+     * @param val UTF16 encoded byte array\n+     * @param doReplace true to replace unmappable characters\n+     *\/\n+    private static long computeSizeUTF8_UTF16(byte[] val, boolean doReplace) {\n+        long dp = 0L;\n+        int sp = 0;\n+        int sl = val.length >> 1;\n+\n+        while (sp < sl) {\n+            char c = StringUTF16.getChar(val, sp++);\n+            if (c < 0x80) {\n+                dp++;\n+            } else if (c < 0x800) {\n+                dp += 2;\n+            } else if (Character.isSurrogate(c)) {\n+                int uc = -1;\n+                char c2;\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n+                    uc = Character.toCodePoint(c, c2);\n+                }\n+                if (uc < 0) {\n+                    if (doReplace) {\n+                        dp++;\n+                    } else {\n+                        throwUnmappable(sp - 1);\n+                    }\n+                } else {\n+                    dp += 4;\n+                    sp++;  \/\/ 2 chars\n+                }\n+            } else {\n+                \/\/ 3 bytes, 16 bits\n+                dp += 3;\n+            }\n+        }\n+        return dp;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,29 @@\n+\n+    \/*\n+     * Test that UTF-8 of too large strings throws OOME, (not NegativeArraySizeException).\n+     *\/\n+    @Test\n+    public void testMaxUTF8_UTF16Encode() {\n+        String s = \"\\uFFFF\";\n+        final byte[] bytes1 = s.getBytes(StandardCharsets.UTF_8);\n+        assertEquals(3, bytes1.length, \"UTF_8 encoded length of 0xffff\");\n+\n+        int min = Integer.MAX_VALUE \/ bytes1.length - 1;\n+        int max = min + 3;\n+\n+        \/\/ String of size min can be UTF_8 encoded.\n+        System.out.println(\"testing size: \" + min);\n+        String s1 = s.repeat(min);\n+        byte[] bytes = s1.getBytes(StandardCharsets.UTF_8);\n+        int remaining = Integer.MAX_VALUE - bytes.length;\n+        assertTrue(remaining >= bytes1.length, \"remainder too large: \" + remaining);\n+\n+        \/\/ Strings of size min+1...min+2, throw OOME\n+        \/\/ The resulting byte array would exceed implementation limits\n+        for (int count = min + 1; count < max; count++) {\n+            System.out.println(\"testing size: \" + count);\n+            final String s2 = s.repeat(count);\n+            OutOfMemoryError ex = assertThrows(OutOfMemoryError.class, () -> s2.getBytes(StandardCharsets.UTF_8));\n+            ex.printStackTrace();\n+        };\n+    }\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/MaxSizeUTF16String.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"}]}