{"files":[{"patch":"@@ -43,1 +43,0 @@\n-import java.util.BitSet;\n@@ -60,2 +59,2 @@\n- * <li>{@linkplain #detectFrameOffsets() Detection} of mandatory stack map frames offsets:<ul>\n- *      <li>Mandatory stack map frame offsets include all jump and switch instructions targets,\n+ * <li>{@linkplain #detectFrames() Detection} of mandatory stack map frames:<ul>\n+ *      <li>Mandatory stack map frame include all jump and switch instructions targets,\n@@ -165,0 +164,1 @@\n+    private static final Frame[] EMPTY_FRAME_ARRAY = new Frame[0];\n@@ -200,1 +200,2 @@\n-    private List<Frame> frames;\n+    private Frame[] frames = EMPTY_FRAME_ARRAY;\n+    private int framesCount = 0;\n@@ -264,1 +265,1 @@\n-        int high = frames.size() - 1;\n+        int high = framesCount - 1;\n@@ -267,1 +268,1 @@\n-            var f = frames.get(mid);\n+            var f = frames[mid];\n@@ -285,2 +286,2 @@\n-        for (var f : frames) {\n-            if (f.dirty) return true;\n+        for (int i = 0; i < framesCount; i++) {\n+            if (frames[i].dirty) return true;\n@@ -294,20 +295,2 @@\n-        for (var exhandler : handlers) {\n-            int start_pc = labelContext.labelToBci(exhandler.tryStart());\n-            int end_pc = labelContext.labelToBci(exhandler.tryEnd());\n-            int handler_pc = labelContext.labelToBci(exhandler.handler());\n-            if (start_pc >= 0 && end_pc >= 0 && end_pc > start_pc && handler_pc >= 0) {\n-                if (start_pc < exMin) exMin = start_pc;\n-                if (end_pc > exMax) exMax = end_pc;\n-                var catchType = exhandler.catchType();\n-                rawHandlers.add(new RawExceptionCatch(start_pc, end_pc, handler_pc,\n-                        catchType.isPresent() ? cpIndexToType(catchType.get().index(), cp)\n-                                              : Type.THROWABLE_TYPE));\n-            }\n-        }\n-        BitSet frameOffsets = detectFrameOffsets();\n-        int framesCount = frameOffsets.cardinality();\n-        frames = new ArrayList<>(framesCount);\n-        int offset = -1;\n-        for (int i = 0; i < framesCount; i++) {\n-            offset = frameOffsets.nextSetBit(offset + 1);\n-            frames.add(new Frame(offset, classHierarchy));\n+        if (!handlers.isEmpty()) {\n+            generateHandlers();\n@@ -315,0 +298,1 @@\n+        detectFrames();\n@@ -323,1 +307,1 @@\n-            var frame = frames.get(i);\n+            var frame = frames[i];\n@@ -325,11 +309,1 @@\n-                if (!patchDeadCode) throw generatorError(\"Unable to generate stack map frame for dead code\", frame.offset);\n-                \/\/patch frame\n-                frame.pushStack(Type.THROWABLE_TYPE);\n-                if (maxStack < 1) maxStack = 1;\n-                int end = (i < framesCount - 1 ? frames.get(i + 1).offset : bytecode.length()) - 1;\n-                \/\/patch bytecode\n-                var arr = bytecode.array();\n-                Arrays.fill(arr, frame.offset, end, (byte) NOP);\n-                arr[end] = (byte) ATHROW;\n-                \/\/patch handlers\n-                removeRangeFromExcTable(frame.offset, end + 1);\n+                deadCodePatching(frame, i);\n@@ -340,0 +314,32 @@\n+    private void generateHandlers() {\n+        var labelContext = this.labelContext;\n+        for (int i = 0; i < handlers.size(); i++) {\n+            var exhandler = handlers.get(i);\n+            int start_pc = labelContext.labelToBci(exhandler.tryStart());\n+            int end_pc = labelContext.labelToBci(exhandler.tryEnd());\n+            int handler_pc = labelContext.labelToBci(exhandler.handler());\n+            if (start_pc >= 0 && end_pc >= 0 && end_pc > start_pc && handler_pc >= 0) {\n+                if (start_pc < exMin) exMin = start_pc;\n+                if (end_pc > exMax) exMax = end_pc;\n+                var catchType = exhandler.catchType();\n+                rawHandlers.add(new RawExceptionCatch(start_pc, end_pc, handler_pc,\n+                        catchType.isPresent() ? cpIndexToType(catchType.get().index(), cp)\n+                                : Type.THROWABLE_TYPE));\n+            }\n+        }\n+    }\n+\n+    private void deadCodePatching(Frame frame, int i) {\n+        if (!patchDeadCode) throw generatorError(\"Unable to generate stack map frame for dead code\", frame.offset);\n+        \/\/patch frame\n+        frame.pushStack(Type.THROWABLE_TYPE);\n+        if (maxStack < 1) maxStack = 1;\n+        int end = (i < framesCount - 1 ? frames[i + 1].offset : bytecode.length()) - 1;\n+        \/\/patch bytecode\n+        var arr = bytecode.array();\n+        Arrays.fill(arr, frame.offset, end, (byte) NOP);\n+        arr[end] = (byte) ATHROW;\n+        \/\/patch handlers\n+        removeRangeFromExcTable(frame.offset, end + 1);\n+    }\n+\n@@ -382,1 +388,1 @@\n-        return frames.isEmpty() ? null : new UnboundAttribute.AdHocAttribute<>(Attributes.stackMapTable()) {\n+        return framesCount == 0 ? null : new UnboundAttribute.AdHocAttribute<>(Attributes.stackMapTable()) {\n@@ -385,1 +391,1 @@\n-                b.writeU2(frames.size());\n+                b.writeU2(framesCount);\n@@ -389,1 +395,2 @@\n-                for (var fr : frames) {\n+                for (int i = 0; i < framesCount; i++) {\n+                    var fr = frames[i];\n@@ -414,2 +421,2 @@\n-            if (stackmapIndex < frames.size()) {\n-                int thisOffset = frames.get(stackmapIndex).offset;\n+            if (stackmapIndex < framesCount) {\n+                int thisOffset = frames[stackmapIndex].offset;\n@@ -420,1 +427,1 @@\n-                    Frame nextFrame = frames.get(stackmapIndex++);\n+                    Frame nextFrame = frames[stackmapIndex++];\n@@ -425,2 +432,2 @@\n-                        if (stackmapIndex == frames.size()) return; \/\/skip the rest of this round\n-                        nextFrame = frames.get(stackmapIndex++);\n+                        if (stackmapIndex == framesCount) return; \/\/skip the rest of this round\n+                        nextFrame = frames[stackmapIndex++];\n@@ -843,3 +850,2 @@\n-     * Performs detection of mandatory stack map frames offsets\n-     * in a single bytecode traversing pass\n-     * @return <code>java.lang.BitSet<\/code> of detected frames offsets\n+     * Performs detection of mandatory stack map frames in a single bytecode traversing pass\n+     * @return detected frames\n@@ -847,8 +853,1 @@\n-    private BitSet detectFrameOffsets() {\n-        var offsets = new BitSet() {\n-            @Override\n-            public void set(int i) {\n-                Preconditions.checkIndex(i, bytecode.length(), RawBytecodeHelper.IAE_FORMATTER);\n-                super.set(i);\n-            }\n-        };\n+    private void detectFrames() {\n@@ -862,1 +861,1 @@\n-                offsets.set(bci);\n+                addFrame(bci);\n@@ -866,1 +865,1 @@\n-                            offsets.set(bcs.dest());\n+                            addFrame(bcs.dest());\n@@ -870,1 +869,1 @@\n-                            offsets.set(bcs.destW());\n+                            addFrame(bcs.destW());\n@@ -877,1 +876,1 @@\n-                            offsets.set(bcs.dest());\n+                            addFrame(bcs.dest());\n@@ -893,1 +892,1 @@\n-                            offsets.set(bci + default_ofset);\n+                            addFrame(bci + default_ofset);\n@@ -895,1 +894,1 @@\n-                                offsets.set(bci + bcs.getIntUnchecked(aligned_bci + (3 + i * delta) * 4));\n+                                addFrame(bci + bcs.getIntUnchecked(aligned_bci + (3 + i * delta) * 4));\n@@ -906,2 +905,2 @@\n-        for (var exhandler : rawHandlers) try {\n-             offsets.set(exhandler.handler());\n+        for (int i = 0; i < rawHandlers.size(); i++) try {\n+            addFrame(rawHandlers.get(i).handler());\n@@ -912,1 +911,24 @@\n-        return offsets;\n+    }\n+\n+    private void addFrame(int offset) {\n+        Preconditions.checkIndex(offset, bytecode.length(), RawBytecodeHelper.IAE_FORMATTER);\n+        var frames = this.frames;\n+        int i = 0, framesCount = this.framesCount;\n+        for (; i < framesCount; i++) {\n+            var frame = frames[i];\n+            if (frame.offset == offset) {\n+                return;\n+            }\n+            if (frame.offset > offset) {\n+                break;\n+            }\n+        }\n+        if (framesCount >= frames.length) {\n+            int newCapacity = framesCount + 8;\n+            this.frames = frames = framesCount == 0 ? new Frame[newCapacity] : Arrays.copyOf(frames, newCapacity);\n+        }\n+        if (i != framesCount) {\n+            System.arraycopy(frames, i, frames, i + 1, framesCount - i);\n+        }\n+        frames[i] = new Frame(offset, classHierarchy);\n+        this.framesCount = framesCount + 1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":90,"deletions":68,"binary":false,"changes":158,"status":"modified"}]}