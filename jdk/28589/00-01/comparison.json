{"files":[{"patch":"@@ -93,0 +93,1 @@\n+  assert(index >= 0, \"out-of-bounds index: %d\", index);\n","filename":"src\/hotspot\/share\/ci\/ciArray.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  assert(offset > 0, \"out-of-bounds offset: %d\", offset);\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+\n@@ -227,1 +228,1 @@\n-\/\/ ciObject::identity_hash_or_zero\n+\/\/ ciObject::identity_hash_or_no_hash\n@@ -230,2 +231,1 @@\n-jint ciObject::identity_hash_or_zero() {\n-  VM_ENTRY_MARK;\n+jint ciObject::identity_hash_or_no_hash() {\n@@ -233,5 +233,4 @@\n-    markWord mark = get_oop()->mark_acquire();\n-    if (UseObjectMonitorTable || !mark.has_monitor()) {\n-      jint hash = mark.hash();\n-      if (hash != 0) {\n-        return hash;\n+    { \/\/ Handle identity hash as if it were a field.\n+      ciConstant value = check_constant_value_cache(IDENTITY_HASH_OFFSET, T_INT);\n+      if (value.is_valid()) {\n+        return value.as_int();\n@@ -240,0 +239,8 @@\n+    VM_ENTRY_MARK;\n+    oop obj = get_oop();\n+    jint identity_hash = checked_cast<jint>(obj->fast_identity_hash_or_no_hash());\n+    add_to_constant_value_cache(IDENTITY_HASH_OFFSET,\n+                                ciConstant(T_INT, identity_hash));\n+    return identity_hash;\n+  } else {\n+    return markWord::no_hash;\n@@ -241,1 +248,0 @@\n-  return 0;\n@@ -244,1 +250,0 @@\n-\n","filename":"src\/hotspot\/share\/ci\/ciObject.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,1 @@\n+  const int IDENTITY_HASH_OFFSET = -1;\n@@ -186,1 +187,1 @@\n-  jint identity_hash_or_zero();\n+  jint identity_hash_or_no_hash();\n","filename":"src\/hotspot\/share\/ci\/ciObject.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -317,0 +317,3 @@\n+  \/\/ identity hash; returns the identity hash key if it is present (doesn't compute it)\n+  inline intptr_t fast_identity_hash_or_no_hash();\n+\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -440,0 +440,15 @@\n+\/\/ Returns the identity hash if it is present (doesn't compute it).\n+intptr_t oopDesc::fast_identity_hash_or_no_hash() {\n+  \/\/ Note: The mark must be read into local variable to avoid concurrent updates.\n+  markWord mrk = mark_acquire();\n+  assert(!mrk.is_marked(), \"should never be marked\");\n+  \/\/ Fast case: if the object is unlocked and the hash value is set, no locking is needed to read it.\n+  \/\/ If UseObjectMonitorTable is set, the hash can simply be installed in the\n+  \/\/ object header, since the monitor isn't in the object header.\n+  if (UseObjectMonitorTable || !mrk.has_monitor()) {\n+    return mrk.hash();\n+  } else {\n+    return markWord::no_hash;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4780,0 +4780,1 @@\n+  \/\/ Fold identity hash after virtual dispatches are excluded.\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    public long testSum() {\n+    public int testSum() {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/constantFold\/IdentityHashCodeFold.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}