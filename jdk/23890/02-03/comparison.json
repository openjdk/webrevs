{"files":[{"patch":"@@ -1636,73 +1636,0 @@\n-  \/\/ Helper for generate_unsafe_setmemory\n-  \/\/ from fill Byte in generate_fill\n-  static void do_setmemory_atomic_loop(Register to, Register count, Register value,\n-                                       MacroAssembler *_masm) {\n-    const Register cnt_words = x29;      \/\/ temp register\n-    const Register tmp_reg   = t1;\n-\n-    Label L_fill_elements, L_exit1;\n-\n-    \/\/ Zero extend value\n-    \/\/ 8 bit -> 32 bit\n-    __ zext(value, value, 8);\n-    __ mv(tmp_reg, value);\n-    __ slli(tmp_reg, tmp_reg, 8);\n-    __ orr(value, value, tmp_reg);\n-    __ mv(tmp_reg, value);\n-    __ slli(tmp_reg, tmp_reg, 16);\n-    __ orr(value, value, tmp_reg);\n-    __ mv(tmp_reg, 8); \/\/ 8 bytes fill by element\n-    __ bltu(count, tmp_reg, L_fill_elements);\n-\n-    \/\/ Align source address at 8 bytes address boundary.\n-    Label L_skip_align1, L_skip_align2, L_skip_align4;\n-\n-    \/\/ One byte misalignment happens only for byte arrays.\n-    __ test_bit(t0, to, 0);\n-    __ beqz(t0, L_skip_align1);\n-    __ sb(value, Address(to, 0));\n-    __ addi(to, to, 1);\n-    __ subiw(count, count, 1);\n-    __ bind(L_skip_align1);\n-    \/\/ Two bytes misalignment happens only for byte and short (char) arrays.\n-    __ test_bit(t0, to, 1);\n-    __ beqz(t0, L_skip_align2);\n-    __ sh(value, Address(to, 0));\n-    __ addi(to, to, 2);\n-    __ subiw(count, count, 2);\n-    __ bind(L_skip_align2);\n-    \/\/ Align to 8 bytes, we know we are 4 byte aligned to start.\n-    __ test_bit(t0, to, 2);\n-    __ beqz(t0, L_skip_align4);\n-    __ sw(value, Address(to, 0));\n-    __ addi(to, to, 4);\n-    __ subiw(count, count, 4);\n-    __ bind(L_skip_align4);\n-\n-    \/\/  Fill large chunks\n-    __ srliw(cnt_words, count, 3); \/\/ number of words\n-\n-    \/\/ 32 bit -> 64 bit\n-    __ zext(value, value, 32);\n-    __ slli(tmp_reg, value, 32);\n-    __ orr(value, value, tmp_reg);\n-\n-    __ slli(tmp_reg, cnt_words, 3);\n-    __ subw(count, count, tmp_reg);\n-    {\n-      __ fill_words(to, cnt_words, value);\n-    }\n-\n-    \/\/ Handle copies less than 8 bytes.\n-    Label L_exit2;\n-\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    __ sb(value, Address(to, 0));\n-    __ addi(to, to, 1);\n-    __ subiw(count, count, 1);\n-    __ j(L_fill_elements);\n-\n-    __ bind(L_exit2);\n-  }\n-\n@@ -1731,3 +1658,3 @@\n-      const Register dest = c_rarg0;\n-      const Register size = c_rarg1;\n-      const Register byteVal = c_rarg2;\n+      const Register to = c_rarg0;\n+      const Register count = c_rarg1;\n+      const Register value = c_rarg2;\n@@ -1735,1 +1662,1 @@\n-      __ beqz(size, L_exit);\n+      __ beqz(count, L_exit);\n@@ -1739,2 +1666,87 @@\n-        UnsafeMemoryAccessMark umam(this, true, false);\n-        do_setmemory_atomic_loop(dest, size, byteVal, _masm);\n+        UnsafeMemoryAccessMark umam(this, true, true);\n+\n+        const Register cnt_words = x29; \/\/ temp register\n+        const Register tmp_reg   = t1; \/\/ temp register\n+\n+        Label L_fill_elements, L_exit_block;\n+\n+        \/\/ if count < 8, jump to L_fill_elements\n+        __ mv(tmp_reg, 8); \/\/ 8 bytes fill by element\n+        __ bltu(count, tmp_reg, L_fill_elements);\n+\n+        \/\/ Zero extend value\n+        \/\/ 8 bit -> 16 bit\n+        __ zext(value, value, 8);\n+        __ slli(tmp_reg, value, 8);\n+        __ orr(value, value, tmp_reg);\n+        \/\/ 16 bit -> 32 bit\n+        __ zext(value, value, 16);\n+        __ slli(tmp_reg, value, 16);\n+        __ orr(value, value, tmp_reg);\n+        \/\/ 32 bit -> 64 bit\n+        __ zext(value, value, 32);\n+        __ slli(tmp_reg, value, 32);\n+        __ orr(value, value, tmp_reg);\n+\n+        \/\/ Align source address at 8 bytes address boundary.\n+        Label L_skip_align1, L_skip_align2, L_skip_align4;\n+        \/\/ One byte misalignment happens.\n+        __ test_bit(t0, to, 0);\n+        __ beqz(t0, L_skip_align1);\n+        __ sb(value, Address(to, 0));\n+        __ addi(to, to, 1);\n+        __ subiw(count, count, 1);\n+        __ bind(L_skip_align1);\n+        \/\/ Two bytes misalignment happens.\n+        __ test_bit(t0, to, 1);\n+        __ beqz(t0, L_skip_align2);\n+        __ sh(value, Address(to, 0));\n+        __ addi(to, to, 2);\n+        __ subiw(count, count, 2);\n+        __ bind(L_skip_align2);\n+        \/\/ Four bytes misalignment happens.\n+        __ test_bit(t0, to, 2);\n+        __ beqz(t0, L_skip_align4);\n+        __ sw(value, Address(to, 0));\n+        __ addi(to, to, 4);\n+        __ subiw(count, count, 4);\n+        __ bind(L_skip_align4);\n+\n+        \/\/  Fill large chunks\n+        __ srliw(cnt_words, count, 3); \/\/ number of words\n+        __ slli(tmp_reg, cnt_words, 3);\n+        __ subw(count, count, tmp_reg);\n+        {\n+          __ fill_words(to, cnt_words, value);\n+        }\n+\n+        \/\/ Remaining count is less than 8 bytes and address is heapword aligned.\n+        Label L_fill_2, L_fill_4;\n+        __ test_bit(t0, count, 0);\n+        __ beqz(t0, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ addi(to, to, 1);\n+        __ bind(L_fill_2);\n+        __ test_bit(t0, count, 1);\n+        __ beqz(t0, L_fill_4);\n+        __ sh(value, Address(to, 0));\n+        __ addi(to, to, 2);\n+        __ bind(L_fill_4);\n+        __ test_bit(t0, count, 2);\n+        __ beqz(t0, L_exit_block);\n+        __ sw(value, Address(to, 0));\n+        __ j(L_exit_block);\n+\n+        \/\/ Handle copies less than 8 bytes\n+        Label L_loop1;\n+\n+        __ bind(L_fill_elements);\n+        __ beqz(count, L_exit_block);\n+ \n+        __ bind(L_loop1);\n+        __ sb(value, Address(to, 0));\n+        __ addi(to, to, 1);\n+        __ subiw(count, count, 1);\n+        __ bnez(count, L_loop1);\n+\n+        __ bind(L_exit_block);        \n@@ -1743,1 +1755,1 @@\n-      __ BIND(L_exit);\n+      __ bind(L_exit);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":92,"deletions":80,"binary":false,"changes":172,"status":"modified"}]}