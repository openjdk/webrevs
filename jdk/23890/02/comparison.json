{"files":[{"patch":"@@ -1636,0 +1636,114 @@\n+  \/\/ Helper for generate_unsafe_setmemory\n+  \/\/ from fill Byte in generate_fill\n+  static void do_setmemory_atomic_loop(Register to, Register count, Register value,\n+                                       MacroAssembler *_masm) {\n+    const Register cnt_words = x29;      \/\/ temp register\n+    const Register tmp_reg   = t1;\n+\n+    Label L_fill_elements, L_exit1;\n+\n+    \/\/ Zero extend value\n+    \/\/ 8 bit -> 32 bit\n+    __ zext(value, value, 8);\n+    __ mv(tmp_reg, value);\n+    __ slli(tmp_reg, tmp_reg, 8);\n+    __ orr(value, value, tmp_reg);\n+    __ mv(tmp_reg, value);\n+    __ slli(tmp_reg, tmp_reg, 16);\n+    __ orr(value, value, tmp_reg);\n+    __ mv(tmp_reg, 8); \/\/ 8 bytes fill by element\n+    __ bltu(count, tmp_reg, L_fill_elements);\n+\n+    \/\/ Align source address at 8 bytes address boundary.\n+    Label L_skip_align1, L_skip_align2, L_skip_align4;\n+\n+    \/\/ One byte misalignment happens only for byte arrays.\n+    __ test_bit(t0, to, 0);\n+    __ beqz(t0, L_skip_align1);\n+    __ sb(value, Address(to, 0));\n+    __ addi(to, to, 1);\n+    __ subiw(count, count, 1);\n+    __ bind(L_skip_align1);\n+    \/\/ Two bytes misalignment happens only for byte and short (char) arrays.\n+    __ test_bit(t0, to, 1);\n+    __ beqz(t0, L_skip_align2);\n+    __ sh(value, Address(to, 0));\n+    __ addi(to, to, 2);\n+    __ subiw(count, count, 2);\n+    __ bind(L_skip_align2);\n+    \/\/ Align to 8 bytes, we know we are 4 byte aligned to start.\n+    __ test_bit(t0, to, 2);\n+    __ beqz(t0, L_skip_align4);\n+    __ sw(value, Address(to, 0));\n+    __ addi(to, to, 4);\n+    __ subiw(count, count, 4);\n+    __ bind(L_skip_align4);\n+\n+    \/\/  Fill large chunks\n+    __ srliw(cnt_words, count, 3); \/\/ number of words\n+\n+    \/\/ 32 bit -> 64 bit\n+    __ zext(value, value, 32);\n+    __ slli(tmp_reg, value, 32);\n+    __ orr(value, value, tmp_reg);\n+\n+    __ slli(tmp_reg, cnt_words, 3);\n+    __ subw(count, count, tmp_reg);\n+    {\n+      __ fill_words(to, cnt_words, value);\n+    }\n+\n+    \/\/ Handle copies less than 8 bytes.\n+    Label L_exit2;\n+\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit2);\n+    __ sb(value, Address(to, 0));\n+    __ addi(to, to, 1);\n+    __ subiw(count, count, 1);\n+    __ j(L_fill_elements);\n+\n+    __ bind(L_exit2);\n+  }\n+\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    c_rarg0   - destination array address\n+  \/\/    c_rarg1   - byte count (size_t)\n+  \/\/    c_rarg2   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory() {\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+\n+    \/\/ bump this on entry, not on exit:\n+    inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    {\n+      Label L_exit;\n+\n+      const Register dest = c_rarg0;\n+      const Register size = c_rarg1;\n+      const Register byteVal = c_rarg2;\n+\n+      __ beqz(size, L_exit);\n+\n+      {\n+        \/\/ Mark remaining code as such which performs Unsafe accesses.\n+        UnsafeMemoryAccessMark umam(this, true, false);\n+        do_setmemory_atomic_loop(dest, size, byteVal, _masm);\n+      }\n+\n+      __ BIND(L_exit);\n+    }\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -2262,0 +2376,2 @@\n+\n+    StubRoutines::_unsafe_setmemory    = generate_unsafe_setmemory();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":116,"deletions":0,"binary":false,"changes":116,"status":"modified"}]}