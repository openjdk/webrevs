{"files":[{"patch":"@@ -1636,0 +1636,144 @@\n+  address generate_unsafecopy_common_error_exit() {\n+    address start = __ pc();\n+    __ mv(x10, 0);\n+    __ leave();\n+    __ ret();\n+    return start;\n+  }\n+\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    c_rarg0   - destination array address\n+  \/\/    c_rarg1   - byte count (size_t)\n+  \/\/    c_rarg2   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory() {\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+\n+    \/\/ bump this on entry, not on exit:\n+    \/\/ inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    Label L_fill_elements;\n+\n+    const Register dest = c_rarg0;\n+    const Register count = c_rarg1;\n+    const Register value = c_rarg2;\n+    const Register cnt_words = x28; \/\/ temp register\n+    const Register tmp_reg   = x29; \/\/ temp register\n+\n+    \/\/ Mark remaining code as such which performs Unsafe accesses.\n+    UnsafeMemoryAccessMark umam(this, true, false);\n+\n+    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    \/\/ if count < 8, jump to L_fill_elements\n+    __ mv(tmp_reg, 8); \/\/ 8 bytes fill by element\n+    __ bltu(count, tmp_reg, L_fill_elements);\n+\n+    \/\/ Propagate byte to 64-bit width\n+    \/\/ 8 bit -> 16 bit\n+    __ zext(value, value, 8);\n+    __ slli(tmp_reg, value, 8);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 16 bit -> 32 bit\n+    __ slli(tmp_reg, value, 16);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 32 bit -> 64 bit\n+    __ slli(tmp_reg, value, 32);\n+    __ orr(value, value, tmp_reg);\n+\n+    \/\/ Align source address at 8 bytes address boundary.\n+    Label L_skip_align1, L_skip_align2, L_skip_align4;\n+    \/\/ One byte misalignment happens.\n+    __ test_bit(t0, dest, 0);\n+    __ beqz(t0, L_skip_align1);\n+    __ sb(value, Address(dest, 0));\n+    __ addi(dest, dest, 1);\n+    __ subi(count, count, 1);\n+    __ bind(L_skip_align1);\n+    \/\/ Two bytes misalignment happens.\n+    __ test_bit(t0, dest, 1);\n+    __ beqz(t0, L_skip_align2);\n+    __ sh(value, Address(dest, 0));\n+    __ addi(dest, dest, 2);\n+    __ subi(count, count, 2);\n+    __ bind(L_skip_align2);\n+    \/\/ Four bytes misalignment happens.\n+    __ test_bit(t0, dest, 2);\n+    __ beqz(t0, L_skip_align4);\n+    __ sw(value, Address(dest, 0));\n+    __ addi(dest, dest, 4);\n+    __ subi(count, count, 4);\n+    __ bind(L_skip_align4);\n+\n+    \/\/  Fill large chunks\n+    __ srli(cnt_words, count, 3); \/\/ number of words\n+    __ slli(tmp_reg, cnt_words, 3);\n+    __ sub(count, count, tmp_reg);\n+    {\n+      __ fill_words(dest, cnt_words, value);\n+    }\n+\n+    \/\/ Remaining count is less than 8 bytes and address is heapword aligned.\n+    {\n+      Label L_fill_2, L_fill_1, L_exit;\n+      __ test_bit(t0, count, 2);\n+      __ beqz(t0, L_fill_2);\n+      __ sw(value, Address(dest, 0));\n+      __ addi(dest, dest, 4);\n+\n+      __ bind(L_fill_2);\n+      __ test_bit(t0, count, 1);\n+      __ beqz(t0, L_fill_1);\n+      __ sh(value, Address(dest, 0));\n+      __ addi(dest, dest, 2);\n+\n+      __ bind(L_fill_1);\n+      __ test_bit(t0, count, 0);\n+      __ beqz(t0, L_exit);\n+      __ sb(value, Address(dest, 0));\n+\n+      __ bind(L_exit);\n+      __ leave();\n+      __ ret();\n+    }\n+\n+    \/\/ Handle copies less than 8 bytes\n+    __ bind(L_fill_elements);\n+    {\n+      Label L_fill_2, L_fill_1, L_exit;\n+      __ test_bit(t0, count, 2);\n+      __ beqz(t0, L_fill_2);\n+      __ sb(value, Address(dest, 0));\n+      __ sb(value, Address(dest, 1));\n+      __ sb(value, Address(dest, 2));\n+      __ sb(value, Address(dest, 3));\n+      __ addi(dest, dest, 4);\n+\n+      __ bind(L_fill_2);\n+      __ test_bit(t0, count, 1);\n+      __ beqz(t0, L_fill_1);\n+      __ sb(value, Address(dest, 0));\n+      __ sb(value, Address(dest, 1));\n+      __ addi(dest, dest, 2);\n+\n+      __ bind(L_fill_1);\n+      __ test_bit(t0, count, 0);\n+      __ beqz(t0, L_exit);\n+      __ sb(value, Address(dest, 0));\n+\n+      __ bind(L_exit);\n+      __ leave();\n+      __ ret();\n+    }\n+\n+    return start;\n+  }\n+\n@@ -2205,0 +2349,3 @@\n+    address ucm_common_error_exit     = generate_unsafecopy_common_error_exit();\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n+\n@@ -2275,0 +2422,2 @@\n+\n+    StubRoutines::_unsafe_setmemory    = generate_unsafe_setmemory();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":149,"deletions":0,"binary":false,"changes":149,"status":"modified"}]}