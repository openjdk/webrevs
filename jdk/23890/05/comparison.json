{"files":[{"patch":"@@ -1636,0 +1636,117 @@\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    c_rarg0   - destination array address\n+  \/\/    c_rarg1   - byte count (size_t)\n+  \/\/    c_rarg2   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory() {\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+\n+    \/\/ bump this on entry, not on exit:\n+    inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    Label L_exit, L_fill_elements;\n+\n+    const Register to = c_rarg0;\n+    const Register count = c_rarg1;\n+    const Register value = c_rarg2;\n+    const Register cnt_words = x29; \/\/ temp register\n+    const Register tmp_reg   = t1; \/\/ temp register\n+\n+    __ beqz(count, L_exit);\n+\n+    \/\/ Mark remaining code as such which performs Unsafe accesses.\n+    UnsafeMemoryAccessMark umam(this, true, true);\n+\n+    \/\/ if count < 8, jump to L_fill_elements\n+    __ mv(tmp_reg, 8); \/\/ 8 bytes fill by element\n+    __ bltu(count, tmp_reg, L_fill_elements);\n+\n+    \/\/ Zero extend value\n+    \/\/ 8 bit -> 16 bit\n+    __ zext(value, value, 8);\n+    __ slli(tmp_reg, value, 8);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 16 bit -> 32 bit\n+    __ zext(value, value, 16);\n+    __ slli(tmp_reg, value, 16);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 32 bit -> 64 bit\n+    __ zext(value, value, 32);\n+    __ slli(tmp_reg, value, 32);\n+    __ orr(value, value, tmp_reg);\n+\n+    \/\/ Align source address at 8 bytes address boundary.\n+    Label L_skip_align1, L_skip_align2, L_skip_align4;\n+    \/\/ One byte misalignment happens.\n+    __ test_bit(t0, to, 0);\n+    __ beqz(t0, L_skip_align1);\n+    __ sb(value, Address(to, 0));\n+    __ addi(to, to, 1);\n+    __ subiw(count, count, 1);\n+    __ bind(L_skip_align1);\n+    \/\/ Two bytes misalignment happens.\n+    __ test_bit(t0, to, 1);\n+    __ beqz(t0, L_skip_align2);\n+    __ sh(value, Address(to, 0));\n+    __ addi(to, to, 2);\n+    __ subiw(count, count, 2);\n+    __ bind(L_skip_align2);\n+    \/\/ Four bytes misalignment happens.\n+    __ test_bit(t0, to, 2);\n+    __ beqz(t0, L_skip_align4);\n+    __ sw(value, Address(to, 0));\n+    __ addi(to, to, 4);\n+    __ subiw(count, count, 4);\n+    __ bind(L_skip_align4);\n+\n+    \/\/  Fill large chunks\n+    __ srliw(cnt_words, count, 3); \/\/ number of words\n+    __ slli(tmp_reg, cnt_words, 3);\n+    __ subw(count, count, tmp_reg);\n+    {\n+      __ fill_words(to, cnt_words, value);\n+    }\n+\n+    \/\/ Remaining count is less than 8 bytes and address is heapword aligned.\n+    Label L_fill_2, L_fill_4;\n+    __ test_bit(t0, count, 0);\n+    __ beqz(t0, L_fill_2);\n+    __ sb(value, Address(to, 0));\n+    __ addi(to, to, 1);\n+    __ bind(L_fill_2);\n+    __ test_bit(t0, count, 1);\n+    __ beqz(t0, L_fill_4);\n+    __ sh(value, Address(to, 0));\n+    __ addi(to, to, 2);\n+    __ bind(L_fill_4);\n+    __ test_bit(t0, count, 2);\n+    __ beqz(t0, L_exit);\n+    __ sw(value, Address(to, 0));\n+    __ j(L_exit);\n+\n+    \/\/ Handle copies less than 8 bytes\n+    Label L_loop1;\n+\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit);\n+\n+    __ bind(L_loop1);\n+    __ sb(value, Address(to, 0));\n+    __ addi(to, to, 1);\n+    __ subiw(count, count, 1);\n+    __ bnez(count, L_loop1);\n+\n+    __ bind(L_exit);\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -2262,0 +2379,2 @@\n+\n+    StubRoutines::_unsafe_setmemory    = generate_unsafe_setmemory();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"modified"}]}