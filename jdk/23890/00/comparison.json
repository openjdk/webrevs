{"files":[{"patch":"@@ -1636,0 +1636,47 @@\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    c_rarg0   - destination array address\n+  \/\/    c_rarg1   - byte count (size_t)\n+  \/\/    c_rarg2   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory(address unsafe_byte_fill) {\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();   \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    assert(unsafe_byte_fill != nullptr, \"Invalid call\");\n+\n+    \/\/ bump this on entry, not on exit:\n+    inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    {\n+      Label L_exit;\n+\n+      const Register dest = c_rarg0;\n+      const Register size = c_rarg1;\n+      const Register byteVal = c_rarg2;\n+\n+      __ beqz(size, L_exit);\n+\n+      \/\/ exchange value of c_rarg1 and c_rarg2 with xorr\n+      __ xorr(c_rarg1, c_rarg1, c_rarg2);\n+      __ xorr(c_rarg2, c_rarg1, c_rarg2);\n+      __ xorr(c_rarg1, c_rarg1, c_rarg2);\n+\n+      __ leave();    \/\/ Clear effect of enter()\n+      __ j(RuntimeAddress(unsafe_byte_fill));\n+\n+      __ BIND(L_exit);\n+      __ leave();\n+      __ ret();\n+    }\n+\n+    return start;\n+  }\n+\n@@ -2262,0 +2309,2 @@\n+\n+    StubRoutines::_unsafe_setmemory    = generate_unsafe_setmemory(StubRoutines::_jbyte_fill);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"}]}