{"files":[{"patch":"@@ -1655,0 +1655,59 @@\n+    Label L_exit, L_fill_elements;\n+\n+    const Register to = c_rarg0;\n+    const Register count = c_rarg1;\n+    const Register value = c_rarg2;\n+    const Register cnt_words = x29; \/\/ temp register\n+    const Register tmp_reg   = t1; \/\/ temp register\n+\n+    __ beqz(count, L_exit);\n+\n+    \/\/ Mark remaining code as such which performs Unsafe accesses.\n+    UnsafeMemoryAccessMark umam(this, true, true);\n+\n+    \/\/ if count < 8, jump to L_fill_elements\n+    __ mv(tmp_reg, 8); \/\/ 8 bytes fill by element\n+    __ bltu(count, tmp_reg, L_fill_elements);\n+\n+    \/\/ Zero extend value\n+    \/\/ 8 bit -> 16 bit\n+    __ zext(value, value, 8);\n+    __ slli(tmp_reg, value, 8);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 16 bit -> 32 bit\n+    __ zext(value, value, 16);\n+    __ slli(tmp_reg, value, 16);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 32 bit -> 64 bit\n+    __ zext(value, value, 32);\n+    __ slli(tmp_reg, value, 32);\n+    __ orr(value, value, tmp_reg);\n+\n+    \/\/ Align source address at 8 bytes address boundary.\n+    Label L_skip_align1, L_skip_align2, L_skip_align4;\n+    \/\/ One byte misalignment happens.\n+    __ test_bit(t0, to, 0);\n+    __ beqz(t0, L_skip_align1);\n+    __ sb(value, Address(to, 0));\n+    __ addi(to, to, 1);\n+    __ subiw(count, count, 1);\n+    __ bind(L_skip_align1);\n+    \/\/ Two bytes misalignment happens.\n+    __ test_bit(t0, to, 1);\n+    __ beqz(t0, L_skip_align2);\n+    __ sh(value, Address(to, 0));\n+    __ addi(to, to, 2);\n+    __ subiw(count, count, 2);\n+    __ bind(L_skip_align2);\n+    \/\/ Four bytes misalignment happens.\n+    __ test_bit(t0, to, 2);\n+    __ beqz(t0, L_skip_align4);\n+    __ sw(value, Address(to, 0));\n+    __ addi(to, to, 4);\n+    __ subiw(count, count, 4);\n+    __ bind(L_skip_align4);\n+\n+    \/\/  Fill large chunks\n+    __ srliw(cnt_words, count, 3); \/\/ number of words\n+    __ slli(tmp_reg, cnt_words, 3);\n+    __ subw(count, count, tmp_reg);\n@@ -1656,100 +1715,1 @@\n-      Label L_exit;\n-\n-      const Register to = c_rarg0;\n-      const Register count = c_rarg1;\n-      const Register value = c_rarg2;\n-\n-      __ beqz(count, L_exit);\n-\n-      {\n-        \/\/ Mark remaining code as such which performs Unsafe accesses.\n-        UnsafeMemoryAccessMark umam(this, true, true);\n-\n-        const Register cnt_words = x29; \/\/ temp register\n-        const Register tmp_reg   = t1; \/\/ temp register\n-\n-        Label L_fill_elements, L_exit_block;\n-\n-        \/\/ if count < 8, jump to L_fill_elements\n-        __ mv(tmp_reg, 8); \/\/ 8 bytes fill by element\n-        __ bltu(count, tmp_reg, L_fill_elements);\n-\n-        \/\/ Zero extend value\n-        \/\/ 8 bit -> 16 bit\n-        __ zext(value, value, 8);\n-        __ slli(tmp_reg, value, 8);\n-        __ orr(value, value, tmp_reg);\n-        \/\/ 16 bit -> 32 bit\n-        __ zext(value, value, 16);\n-        __ slli(tmp_reg, value, 16);\n-        __ orr(value, value, tmp_reg);\n-        \/\/ 32 bit -> 64 bit\n-        __ zext(value, value, 32);\n-        __ slli(tmp_reg, value, 32);\n-        __ orr(value, value, tmp_reg);\n-\n-        \/\/ Align source address at 8 bytes address boundary.\n-        Label L_skip_align1, L_skip_align2, L_skip_align4;\n-        \/\/ One byte misalignment happens.\n-        __ test_bit(t0, to, 0);\n-        __ beqz(t0, L_skip_align1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bind(L_skip_align1);\n-        \/\/ Two bytes misalignment happens.\n-        __ test_bit(t0, to, 1);\n-        __ beqz(t0, L_skip_align2);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2);\n-        __ bind(L_skip_align2);\n-        \/\/ Four bytes misalignment happens.\n-        __ test_bit(t0, to, 2);\n-        __ beqz(t0, L_skip_align4);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ subiw(count, count, 4);\n-        __ bind(L_skip_align4);\n-\n-        \/\/  Fill large chunks\n-        __ srliw(cnt_words, count, 3); \/\/ number of words\n-        __ slli(tmp_reg, cnt_words, 3);\n-        __ subw(count, count, tmp_reg);\n-        {\n-          __ fill_words(to, cnt_words, value);\n-        }\n-\n-        \/\/ Remaining count is less than 8 bytes and address is heapword aligned.\n-        Label L_fill_2, L_fill_4;\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_fill_2);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_4);\n-        __ sh(value, Address(to, 0));\n-        __ addi(to, to, 2);\n-        __ bind(L_fill_4);\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_exit_block);\n-        __ sw(value, Address(to, 0));\n-        __ j(L_exit_block);\n-\n-        \/\/ Handle copies less than 8 bytes\n-        Label L_loop1;\n-\n-        __ bind(L_fill_elements);\n-        __ beqz(count, L_exit_block);\n-\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-\n-        __ bind(L_exit_block);\n-      }\n-\n-      __ bind(L_exit);\n+      __ fill_words(to, cnt_words, value);\n@@ -1757,0 +1717,31 @@\n+\n+    \/\/ Remaining count is less than 8 bytes and address is heapword aligned.\n+    Label L_fill_2, L_fill_4;\n+    __ test_bit(t0, count, 0);\n+    __ beqz(t0, L_fill_2);\n+    __ sb(value, Address(to, 0));\n+    __ addi(to, to, 1);\n+    __ bind(L_fill_2);\n+    __ test_bit(t0, count, 1);\n+    __ beqz(t0, L_fill_4);\n+    __ sh(value, Address(to, 0));\n+    __ addi(to, to, 2);\n+    __ bind(L_fill_4);\n+    __ test_bit(t0, count, 2);\n+    __ beqz(t0, L_exit);\n+    __ sw(value, Address(to, 0));\n+    __ j(L_exit);\n+\n+    \/\/ Handle copies less than 8 bytes\n+    Label L_loop1;\n+\n+    __ bind(L_fill_elements);\n+    __ beqz(count, L_exit);\n+\n+    __ bind(L_loop1);\n+    __ sb(value, Address(to, 0));\n+    __ addi(to, to, 1);\n+    __ subiw(count, count, 1);\n+    __ bnez(count, L_loop1);\n+\n+    __ bind(L_exit);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":91,"deletions":100,"binary":false,"changes":191,"status":"modified"}]}