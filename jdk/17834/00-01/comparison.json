{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n@@ -34,6 +36,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ClassWriterExt;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Handle;\n-\n@@ -68,1 +64,1 @@\n-    protected byte[] generateCPEntryData(byte[] bytes) {\n+    protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n@@ -71,2 +67,2 @@\n-                ClassTransform.endHandler(cb -> cb.withMethod(\"generateCPEntryData\",\n-                        MethodTypeDesc.ofDescriptor(\"()[B\"), ClassFile.ACC_PUBLIC,\n+                ClassTransform.endHandler(cb -> cb.withMethod(methodName,\n+                        MethodTypeDesc.ofDescriptor(methodSignature), accessFlags,\n@@ -76,1 +72,1 @@\n-                                    DirectMethodHandleDesc.Kind kind = kinds[new Random().nextInt(kinds.length)];\n+                                    DirectMethodHandleDesc.Kind kind = kinds[Env.getRNG().nextInt(kinds.length)];\n@@ -98,5 +94,0 @@\n-                                        case GETTER:\n-                                        case SETTER:\n-                                            handle = MethodHandleDesc.ofField(kind, ClassDesc.of(fullClassName),\n-                                                    STATIC_FIELD_NAME, ClassDesc.ofDescriptor(STATIC_FIELD_SIGNATURE));\n-                                            break;\n@@ -105,1 +96,1 @@\n-                                                    MethodTypeDesc.ofDescriptor(INIT_METHOD_SIGNATURE));\n+                                                    ClassDesc.ofDescriptor(INIT_METHOD_SIGNATURE));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenCPFullOfMH.java","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,5 +26,5 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ClassWriterExt;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -41,3 +41,2 @@\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        cw.setCacheMTypes(false);\n-        super.generateCommonData(cw);\n+    protected byte[] generateCommonData(byte[] bytes) {\n+        return super.generateCommonData(bytes);\n@@ -47,3 +46,14 @@\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        mw.visitLdcInsn(Type.getMethodType(\"(FIZ)V\"));\n-        mw.visitInsn(Opcodes.POP);\n+    protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+\n+        bytes = ClassFile.of().transform(cm,\n+                ClassTransform.endHandler(cb -> cb.withMethod(methodName,\n+                        MethodTypeDesc.of(ClassDesc.ofDescriptor(methodSignature)), accessFlags,\n+                        mb -> mb.withCode(\n+                                cob -> {\n+                                    cob.ldc(MethodTypeDesc.ofDescriptor(\"(FIZ)V\"));\n+                                    cob.pop();\n+                                    cob.return_();\n+                                }))));\n+\n+        return bytes;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenCPFullOfMT.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.classfile.ClassBuilder;\n@@ -28,1 +27,2 @@\n-import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n@@ -33,4 +33,1 @@\n-import jdk.internal.classfile.ClassTransform;\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.org.objectweb.asm.ByteVector;\n+\n@@ -41,1 +38,0 @@\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -140,23 +136,17 @@\n-    protected static void createThrowRuntimeExceptionCodeHelper(ClassModel cm, String msg, boolean set_cause) {\n-\n-        ClassFile.of().transform(cm,\n-                ClassTransform.endHandler(cb -> cb.withMethod(\"throwRuntimeException\",\n-                        MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;Z)V\"),\n-                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n-                        mb -> mb.withCode(\n-                                cob -> {\n-                                    cob.new_(ClassDesc.ofInternalName(JL_RUNTIMEEXCEPTION))\n-                                            .dup()\n-                                            .ldc(msg)\n-                                            .invokespecial(ClassDesc.ofInternalName(JL_RUNTIMEEXCEPTION),\n-                                                    INIT_METHOD_NAME,\n-                                                    MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_STRING) + \")V\"));\n-                                    if (set_cause) {\n-                                        cob.dup_x1()\n-                                                .aload(0)\n-                                                .invokevirtual(ClassDesc.ofInternalName(JL_THROWABLE), \"initCause\",\n-                                                        MethodTypeDesc.ofDescriptor(\n-                                                                \"(\" + fd(JL_THROWABLE) + \")\" + fd(JL_THROWABLE)));\n-                                    }\n-                                    cob.athrow();\n-                                }))));\n+    protected static void createThrowRuntimeExceptionCodeHelper(CodeBuilder cob, String msg, boolean set_cause) {\n+\n+        cob.new_(ClassDesc.ofInternalName(JL_RUNTIMEEXCEPTION))\n+                .dup()\n+                .ldc(msg)\n+                .invokespecial(ClassDesc.ofInternalName(JL_RUNTIMEEXCEPTION),\n+                        INIT_METHOD_NAME,\n+                        MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_STRING) + \")V\"));\n+        if (set_cause) {\n+            cob.dup_x1()\n+                    .aload(0)\n+                    .invokevirtual(ClassDesc.ofInternalName(JL_THROWABLE), \"initCause\",\n+                            MethodTypeDesc.ofDescriptor(\n+                                    \"(\" + fd(JL_THROWABLE) + \")\"\n+                                            + fd(JL_THROWABLE)));\n+        }\n+        cob.athrow();\n@@ -165,1 +155,1 @@\n-    protected static void createThrowRuntimeExceptionMethod(ClassModel cm, boolean isStatic, String methodName,\n+    protected static byte[] createThrowRuntimeExceptionMethod(byte[] bytes, boolean isStatic, String methodName,\n@@ -167,1 +157,1 @@\n-        ClassFile.of().transform(cm, ClassTransform.endHandler(clb -> clb.withMethod(methodName,\n+        bytes = ClassFile.of().transform(ClassFile.of().parse(bytes), ClassTransform.endHandler(clb -> clb.withMethod(methodName,\n@@ -170,8 +160,10 @@\n-                mb -> mb.withCode(cb -> cb\n-                        .aload(cob.receiverSlot())\n-                        .ldc(\"Method \" + methodName + methodSignature + \" should not be called!\")\n-                        .invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/GenFullCP\"), \"createThrowRuntimeExceptionCode\",\n-                                MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;)V\"))\n-                        .return_()))));\n-\n-        createThrowRuntimeExceptionCode(cm, \"Method \" + methodName + methodSignature + \" should not be called!\", false);\n+                mb -> mb.withCode(cob -> {\n+                        cob.aload(cob.receiverSlot());\n+                        cob.ldc(\"Method \" + methodName + methodSignature + \" should not be called!\");\n+                        cob.invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/GenFullCP\"), \"createThrowRuntimeExceptionCode\",\n+                                MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;)V\"));\n+                        createThrowRuntimeExceptionCodeHelper(cob, \"Method \" + methodName + methodSignature + \" should not be called!\", false);\n+                        cob.return_();\n+                }))));\n+\n+        return bytes;\n@@ -181,0 +173,1 @@\n+        return bytes;\n@@ -301,1 +294,1 @@\n-                bytes = generateCPEntryData(bytes);\n+                bytes = generateCPEntryData(bytes, methodName, TEST_METHOD_SIGNATURE, ClassFile.ACC_PUBLIC);\n@@ -331,0 +324,1 @@\n+        return bytes;\n@@ -333,1 +327,1 @@\n-    protected abstract byte[] generateCPEntryData(byte[] bytes);\n+    protected abstract byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags);\n@@ -336,2 +330,2 @@\n-        return ClassFile.of().transform(cm, ClassTransform.endHandler(\n-                cb -> cb.withMethod(\"testMethodEpilog\", MethodTypeDesc.ofDescriptor(\"()V\"), ClassFile.ACC_PUBLIC,\n+        return ClassFile.of().transform(ClassFile.of().parse(bytes), ClassTransform.endHandler(\n+                cb -> cb.withMethod(methodName, MethodTypeDesc.ofDescriptor(TEST_METHOD_SIGNATURE), ClassFile.ACC_PUBLIC,\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenFullCP.java","additions":38,"deletions":44,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -26,6 +26,7 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ClassWriterExt;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -38,8 +39,17 @@\n-    \/**\n-     * Generates a class file and writes it to a file\n-     * @see vm.mlvm.share.ClassfileGenerator\n-     * @param args Parameters for ClassfileGenerator.main() method\n-     *\/\n-    public static void main(String[] args) {\n-        ClassfileGenerator.main(args);\n-    }\n+        \/**\n+         * Generates a class file and writes it to a file\n+         * @see vm.mlvm.share.ClassfileGenerator\n+         * @param args Parameters for ClassfileGenerator.main() method\n+         *\/\n+        public static void main(String[] args) {\n+            ClassfileGenerator.main(args);\n+        }\n+\n+        \/**\n+         * Creates static init method, which constructs a call site object, which refers to the target method\n+         * and invokes Dummy.setMH() on this call site\n+         * @param bytes Class file bytes\n+         *\/\n+        @Override\n+        protected byte[] createClassInitMethod(byte[] bytes) {\n+                ClassModel cm = ClassFile.of().parse(bytes);\n@@ -47,12 +57,45 @@\n-    \/**\n-     * Creates static init method, which constructs a call site object, which refers to the target method\n-     * and invokes Dummy.setMH() on this call site\n-     * @param cw Class writer object\n-     *\/\n-    @Override\n-    protected void createClassInitMethod(ClassWriter cw) {\n-        MethodVisitor mw = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC,\n-                STATIC_INIT_METHOD_NAME, INIT_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n+                bytes = ClassFile.of().transform(cm,\n+                                ClassTransform.endHandler(cb -> cb.withMethod(STATIC_INIT_METHOD_NAME,\n+                                                MethodTypeDesc.ofDescriptor(INIT_METHOD_SIGNATURE),\n+                                                ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                                mb -> mb.withCode(\n+                                                                cob -> {\n+                                                                        cob.invokestatic(ClassDesc.ofInternalName(\n+                                                                                        JLI_METHODHANDLES), \"lookup\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"()\"\n+                                                                                                        + fd(JLI_METHODHANDLES_LOOKUP)));\n+                                                                        cob.ldc(ClassDesc.ofDescriptor(fullClassName));\n+                                                                        cob.ldc(TARGET_METHOD_NAME);\n+                                                                        cob.ldc(TARGET_METHOD_SIGNATURE);\n+                                                                        cob.invokevirtual(\n+                                                                                        ClassDesc.ofInternalName(\n+                                                                                                        JL_CLASS),\n+                                                                                        \"getClassLoader\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"()\"\n+                                                                                                        + fd(JL_CLASSLOADER)));\n+                                                                        cob.invokestatic(\n+                                                                                        ClassDesc.ofInternalName(\n+                                                                                                        JLI_METHODTYPE),\n+                                                                                        \"fromMethodDescriptorString\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"(\"\n+                                                                                                        + fd(JL_STRING)\n+                                                                                                        + fd(JL_CLASSLOADER)\n+                                                                                                        + \")\"\n+                                                                                                        + fd(JLI_METHODTYPE)));\n+                                                                        cob.invokevirtual(ClassDesc.ofInternalName(\n+                                                                                        JLI_METHODHANDLES_LOOKUP),\n+                                                                                        \"findStatic\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"(\"\n+                                                                                                        + fd(JL_CLASS)\n+                                                                                                        + fd(JL_STRING)\n+                                                                                                        + fd(JLI_METHODTYPE)\n+                                                                                                        + \")\"\n+                                                                                                        + fd(JLI_METHODHANDLE)));\n+                                                                        cob.invokestatic(ClassDesc.ofInternalName(\n+                                                                                        NEW_INVOKE_SPECIAL_CLASS_NAME),\n+                                                                                        \"setMH\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"(\"\n+                                                                                                        + fd(JLI_METHODHANDLE)\n+                                                                                                        + \")V\"));\n+                                                                        cob.return_();\n+                                                                }))));\n@@ -60,13 +103,11 @@\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODHANDLES, \"lookup\", \"()\" + fd(JLI_METHODHANDLES_LOOKUP));\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitLdcInsn(TARGET_METHOD_NAME);\n-        mw.visitLdcInsn(TARGET_METHOD_SIGNATURE);\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + fd(JL_CLASSLOADER));\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODTYPE,\n-                \"fromMethodDescriptorString\", \"(\" + fd(JL_STRING) + fd(JL_CLASSLOADER) + \")\" + fd(JLI_METHODTYPE));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JLI_METHODHANDLES_LOOKUP,\n-                \"findStatic\", \"(\" + fd(JL_CLASS) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE));\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, NEW_INVOKE_SPECIAL_CLASS_NAME,\n-                \"setMH\", \"(\" + fd(JLI_METHODHANDLE) + \")V\");\n+                return bytes;\n+        }\n+\n+        \/**\n+         * Disables invoke dynamic CP entry caching and generate default common data\n+         * @param bytes Class file bytes\n+         *\/\n+        @Override\n+        protected byte[] generateCommonData(byte[] bytes) {\n+                return super.generateCommonData(bytes);\n+        }\n@@ -74,2 +115,9 @@\n-        finishMethodCode(mw);\n-    }\n+        \/**\n+         * Generates an invokedynamic instruction (plus CP entry)\n+         * which has a valid reference kind in the CP method handle entry for the\n+         * bootstrap method\n+         * @param bytes Class file bytes\n+         *\/\n+        @Override\n+        protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n+                ClassModel cm = ClassFile.of().parse(bytes);\n@@ -77,9 +125,22 @@\n-    \/**\n-     * Disables invoke dynamic CP entry caching and generate default common data\n-     * @param cw Class writer object\n-     *\/\n-    @Override\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        cw.setCacheInvokeDynamic(false);\n-        super.generateCommonData(cw);\n-    }\n+                bytes = ClassFile.of().transform(cm,\n+                                ClassTransform.endHandler(cb -> cb.withMethod(methodName,\n+                                                MethodTypeDesc.ofDescriptor(methodSignature), accessFlags,\n+                                                mb -> mb.withCode(\n+                                                                cob -> {\n+                                                                        MethodHandleDesc bsm;\n+                                                                        if (Env.getRNG().nextBoolean()) {\n+                                                                                 bsm = MethodHandleDesc.ofMethod(\n+                                                                                        DirectMethodHandleDesc.Kind.SPECIAL,\n+                                                                                        ClassDesc.of(this.fullClassName),\n+                                                                                        INIT_METHOD_NAME,\n+                                                                                        MethodTypeDesc.ofDescriptor(NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE)\n+                                                                                );\n+                                                                        } else {\n+                                                                                 bsm = MethodHandleDesc.ofMethod(\n+                                                                                        DirectMethodHandleDesc.Kind.STATIC,\n+                                                                                        ClassDesc.of(this.fullClassName),\n+                                                                                        BOOTSTRAP_METHOD_NAME,\n+                                                                                        MethodTypeDesc.ofDescriptor(BOOTSTRAP_METHOD_SIGNATURE)\n+                                                                                );\n+                                                                        }\n+                                                                        cob.ldc(bsm);\n@@ -87,19 +148,2 @@\n-    \/**\n-     * Generates an invokedynamic instruction (plus CP entry)\n-     * which has a valid reference kind in the CP method handle entry for the bootstrap method\n-     * @param cw Class writer object\n-     * @param mw Method writer object\n-     *\/\n-    @Override\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        Handle bsm;\n-        if (Env.getRNG().nextBoolean()) {\n-            bsm = new Handle(Opcodes.H_NEWINVOKESPECIAL,\n-                    NEW_INVOKE_SPECIAL_CLASS_NAME,\n-                    INIT_METHOD_NAME,\n-                    NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE);\n-        } else {\n-            bsm = new Handle(Opcodes.H_INVOKESTATIC,\n-                    this.fullClassName,\n-                    BOOTSTRAP_METHOD_NAME,\n-                    BOOTSTRAP_METHOD_SIGNATURE);\n+                                                                }))));\n+                return bytes;\n@@ -107,4 +151,0 @@\n-        mw.visitInvokeDynamicInsn(TARGET_METHOD_NAME,\n-                TARGET_METHOD_SIGNATURE,\n-                bsm);\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenManyIndyCorrectBootstrap.java","additions":113,"deletions":73,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -26,7 +26,11 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ClassWriterExt;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.Label;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.Label;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Random;\n+import java.lang.classfile.TypeKind;\n@@ -52,1 +56,1 @@\n-     * @param cw Class writer object\n+     * @param bytes Class file bytes\n@@ -55,34 +59,26 @@\n-    protected void createInitMethod(ClassWriter cw) {\n-        MethodVisitor mw = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC,\n-                INIT_METHOD_NAME, INIT_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n-\n-        mw.visitVarInsn(Opcodes.ALOAD, 0);\n-        mw.visitMethodInsn(Opcodes.INVOKESPECIAL, PARENT_CLASS_NAME,\n-                INIT_METHOD_NAME, INIT_METHOD_SIGNATURE);\n-\n-        \/\/ Create a call site for the target method and store it into bootstrap fields\n-        mw.visitVarInsn(Opcodes.ALOAD, 0);\n-        mw.visitTypeInsn(Opcodes.NEW, JLI_CONSTANTCALLSITE);\n-        mw.visitInsn(Opcodes.DUP);\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODHANDLES,\n-                \"lookup\", \"()\" + fd(JLI_METHODHANDLES_LOOKUP));\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitLdcInsn(TARGET_METHOD_NAME);\n-        mw.visitLdcInsn(TARGET_METHOD_SIGNATURE);\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + fd(JL_CLASSLOADER));\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODTYPE,\n-                \"fromMethodDescriptorString\", \"(\" + fd(JL_STRING) + fd(JL_CLASSLOADER) + \")\" + fd(JLI_METHODTYPE));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JLI_METHODHANDLES_LOOKUP,\n-                \"findStatic\", \"(\" + fd(JL_CLASS) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE));\n-        mw.visitMethodInsn(Opcodes.INVOKESPECIAL, JLI_CONSTANTCALLSITE,\n-                INIT_METHOD_NAME, \"(\" + fd(JLI_METHODHANDLE) + \")V\");\n-        mw.visitInsn(Opcodes.DUP);\n-        mw.visitFieldInsn(Opcodes.PUTSTATIC, fullClassName, STATIC_BOOTSTRAP_FIELD_NAME, STATIC_BOOTSTRAP_FIELD_SIGNATURE);\n-        mw.visitFieldInsn(Opcodes.PUTFIELD, fullClassName, INSTANCE_BOOTSTRAP_FIELD_NAME, INSTANCE_BOOTSTRAP_FIELD_SIGNATURE);\n-\n-        finishMethodCode(mw);\n+    protected byte[] createInitMethod(byte[] bytes) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+\n+        bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withMethod(INIT_METHOD_NAME, MethodTypeDesc.ofDescriptor(INIT_METHOD_SIGNATURE), ClassFile.ACC_PUBLIC,\n+                mb -> mb.withCode(cob -> {\n+                    cob.aload(0)\n+                            .invokespecial(ClassDesc.ofInternalName(PARENT_CLASS_NAME), INIT_METHOD_NAME, MethodTypeDesc.ofDescriptor(INIT_METHOD_SIGNATURE))\n+                            .aload(0)\n+                            .new_(ClassDesc.ofInternalName(JLI_CONSTANTCALLSITE))\n+                            .dup()\n+                            .invokestatic(ClassDesc.ofInternalName(JLI_METHODHANDLES), \"lookup\", MethodTypeDesc.ofDescriptor(\"()\" + fd(JLI_METHODHANDLES_LOOKUP)))\n+                            .ldc(ClassDesc.ofDescriptor(fullClassName))\n+                            .ldc(TARGET_METHOD_NAME)\n+                            .ldc(TARGET_METHOD_SIGNATURE)\n+                            .ldc(ClassDesc.ofDescriptor(fullClassName))\n+                            .invokevirtual(ClassDesc.ofInternalName(JL_CLASS), \"getClassLoader\", MethodTypeDesc.ofDescriptor(\"()\" + fd(JL_CLASSLOADER)))\n+                            .invokestatic(ClassDesc.ofInternalName(JLI_METHODTYPE), \"fromMethodDescriptorString\", MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_STRING) + fd(JL_CLASSLOADER) + \")\" + fd(JLI_METHODTYPE)))\n+                            .invokevirtual(ClassDesc.ofInternalName(JLI_METHODHANDLES_LOOKUP), \"findStatic\", MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_CLASS) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE)))\n+                            .invokespecial(ClassDesc.ofInternalName(JLI_CONSTANTCALLSITE), INIT_METHOD_NAME, MethodTypeDesc.ofDescriptor(\"(\" + fd(JLI_METHODHANDLE) + \")V\"))\n+                            .dup()\n+                            .putstatic(ClassDesc.ofInternalName(fullClassName), STATIC_BOOTSTRAP_FIELD_NAME, ClassDesc.ofDescriptor(STATIC_BOOTSTRAP_FIELD_SIGNATURE))\n+                            .putfield(ClassDesc.ofInternalName(fullClassName), INSTANCE_BOOTSTRAP_FIELD_NAME, ClassDesc.ofDescriptor(INSTANCE_BOOTSTRAP_FIELD_SIGNATURE))\n+                            .return_();\n+                }))));\n+\n+        return bytes;\n@@ -94,1 +90,1 @@\n-     * @param cw Class writer object\n+     * @param bytes Class file bytes\n@@ -97,2 +93,2 @@\n-    protected void createTargetMethod(ClassWriter cw) {\n-        createThrowRuntimeExceptionMethod(cw, true, TARGET_METHOD_NAME, TARGET_METHOD_SIGNATURE);\n+    protected byte[] createTargetMethod(byte[] bytes) {\n+        return createThrowRuntimeExceptionMethod(bytes, true, TARGET_METHOD_NAME, TARGET_METHOD_SIGNATURE);\n@@ -104,1 +100,1 @@\n-     * @param cw Class writer object\n+     * @param bytes Class file bytes\n@@ -107,2 +103,2 @@\n-    protected void createBootstrapMethod(ClassWriter cw) {\n-        createThrowRuntimeExceptionMethod(cw, true, BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_SIGNATURE);\n+    protected byte[] createBootstrapMethod(byte[] bytes) {\n+        return createThrowRuntimeExceptionMethod(bytes, true, BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_SIGNATURE);\n@@ -114,1 +110,1 @@\n-     * @param cw Class writer object\n+     * @param bytes Class file bytes\n@@ -117,2 +113,1 @@\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        cw.setCacheInvokeDynamic(false);\n+    protected byte[] generateCommonData(byte[] bytes) {\n@@ -120,3 +115,1 @@\n-        cw.visitField(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n-                STATIC_BOOTSTRAP_FIELD_NAME,\n-                STATIC_BOOTSTRAP_FIELD_SIGNATURE, null, null);\n+            ClassModel cm = ClassFile.of().parse(bytes);\n@@ -124,3 +117,7 @@\n-        cw.visitField(Opcodes.ACC_PUBLIC,\n-                INSTANCE_BOOTSTRAP_FIELD_NAME,\n-                INSTANCE_BOOTSTRAP_FIELD_SIGNATURE, null, null);\n+            bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb\n+                            .withField(STATIC_BOOTSTRAP_FIELD_NAME,\n+                                            ClassDesc.ofDescriptor(STATIC_BOOTSTRAP_FIELD_SIGNATURE),\n+                                            ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC)\n+                            .withField(INSTANCE_BOOTSTRAP_FIELD_NAME,\n+                                            ClassDesc.ofDescriptor(INSTANCE_BOOTSTRAP_FIELD_SIGNATURE),\n+                                            ClassFile.ACC_PUBLIC)));\n@@ -128,1 +125,1 @@\n-        super.generateCommonData(cw);\n+            bytes = super.generateCommonData(bytes);\n@@ -130,1 +127,1 @@\n-        createThrowRuntimeExceptionMethod(cw, false, INSTANCE_BOOTSTRAP_METHOD_NAME, INSTANCE_BOOTSTRAP_METHOD_SIGNATURE);\n+            return createThrowRuntimeExceptionMethod(bytes, false, INSTANCE_BOOTSTRAP_METHOD_NAME, INSTANCE_BOOTSTRAP_METHOD_SIGNATURE);\n@@ -145,2 +142,1 @@\n-     * @param cw Class writer object\n-     * @param mw Method writer object\n+     * @param bytes Class file bytes\n@@ -149,124 +145,132 @@\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        HandleType[] types = HandleType.values();\n-        HandleType type = types[Env.getRNG().nextInt(types.length)];\n-\n-        switch (type) {\n-            case GETFIELD:\n-            case PUTFIELD:\n-            case GETSTATIC:\n-            case PUTSTATIC:\n-            case INVOKESPECIAL:\n-            case INVOKEVIRTUAL:\n-            case INVOKEINTERFACE:\n-                \/\/ Handle these cases\n-                break;\n-            default:\n-                \/\/ And don't generate code for all other cases\n-                return;\n-        }\n-\n-        Label indyThrowableBegin = new Label();\n-        Label indyThrowableEnd = new Label();\n-        Label catchThrowableLabel = new Label();\n-\n-        Label indyBootstrapBegin = new Label();\n-        Label indyBootstrapEnd = new Label();\n-        Label catchBootstrapLabel = new Label();\n-\n-        mw.visitTryCatchBlock(indyBootstrapBegin, indyBootstrapEnd, catchBootstrapLabel, JL_BOOTSTRAPMETHODERROR);\n-        mw.visitLabel(indyBootstrapBegin);\n-\n-        mw.visitTryCatchBlock(indyThrowableBegin, indyThrowableEnd, catchThrowableLabel, JL_THROWABLE);\n-        mw.visitLabel(indyThrowableBegin);\n-\n-        Handle bsm;\n-        switch (type) {\n-            case GETFIELD:\n-            case PUTFIELD:\n-                bsm = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INSTANCE_BOOTSTRAP_FIELD_NAME,\n-                        INSTANCE_BOOTSTRAP_FIELD_SIGNATURE);\n-                break;\n-            case GETSTATIC:\n-            case PUTSTATIC:\n-                bsm = new Handle(type.asmTag,\n-                        fullClassName,\n-                        STATIC_BOOTSTRAP_FIELD_NAME,\n-                        STATIC_BOOTSTRAP_FIELD_SIGNATURE);\n-                break;\n-            case INVOKESPECIAL:\n-            case INVOKEVIRTUAL:\n-            case INVOKEINTERFACE:\n-                bsm = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INSTANCE_BOOTSTRAP_METHOD_NAME,\n-                        INSTANCE_BOOTSTRAP_METHOD_SIGNATURE);\n-                break;\n-            default:\n-                throw new Error(\"Unexpected handle type \" + type);\n-        }\n-\n-        mw.visitInvokeDynamicInsn(TARGET_METHOD_NAME,\n-                TARGET_METHOD_SIGNATURE,\n-                bsm);\n-\n-        mw.visitLabel(indyBootstrapEnd);\n-        mw.visitLabel(indyThrowableEnd);\n-\n-        \/\/ No exception at all, throw error\n-        Label throwLabel = new Label();\n-        mw.visitJumpInsn(Opcodes.GOTO, throwLabel);\n-\n-        \/\/ JDK-8079697 workaround: we have to generate stackmaps manually\n-        mw.visitFrame(Opcodes.F_SAME1, 0, new Object[0], 1, new Object[] { JL_BOOTSTRAPMETHODERROR });\n-\n-        \/\/ Got a bootstrapmethoderror as expected, check that it is wrapping what we expect\n-        mw.visitLabel(catchBootstrapLabel);\n-\n-        \/\/ Save error in case we need to rethrow it\n-        mw.visitInsn(Opcodes.DUP);\n-        mw.visitVarInsn(Opcodes.ASTORE, 1);\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JL_THROWABLE, \"getCause\", \"()\" + fd(JL_THROWABLE));\n-\n-        \/\/ If it is the expected exception, goto next block\n-        mw.visitTypeInsn(Opcodes.INSTANCEOF, WRAPPED_EXCEPTION);\n-        Label nextBlockLabel = new Label();\n-        mw.visitJumpInsn(Opcodes.IFNE, nextBlockLabel);\n-\n-        \/\/ Not the exception we were expectiong, throw error\n-        mw.visitVarInsn(Opcodes.ALOAD, 1); \/\/ Use full chain as cause\n-        createThrowRuntimeExceptionCodeWithCause(mw,\n-                \"invokedynamic got an unexpected wrapped exception (expected \" + WRAPPED_EXCEPTION\n-                + \", bootstrap type=\" + type\n-                + \", opcode=\" + type.asmTag + \")!\");\n-\n-        \/\/ JDK-8079697 workaround: we have to generate stackmaps manually\n-        mw.visitFrame(Opcodes.F_SAME1, 0, new Object[0], 1, new Object[] { JL_THROWABLE });\n-        mw.visitLabel(catchThrowableLabel);\n-\n-        \/\/ Save error in case we need to rethrow it\n-        mw.visitInsn(Opcodes.DUP);\n-        mw.visitVarInsn(Opcodes.ASTORE, 1);\n-\n-        \/\/ If it is the expected exception, goto next block\n-        mw.visitTypeInsn(Opcodes.INSTANCEOF, DIRECT_ERROR);\n-        mw.visitJumpInsn(Opcodes.IFNE, nextBlockLabel);\n-\n-        \/\/ Not the exception we were expectiong, throw error\n-        mw.visitVarInsn(Opcodes.ALOAD, 1); \/\/ Use full chain as cause\n-        createThrowRuntimeExceptionCodeWithCause(mw,\n-                \"invokedynamic got an unexpected exception (expected \" + DIRECT_ERROR\n-                + \", bootstrap type\" + type\n-                + \", opcode=\" + type.asmTag + \")!\");\n-\n-        \/\/ JDK-8079697 workaround: we have to generate stackmaps manually\n-        mw.visitFrame(Opcodes.F_CHOP, 0, new Object[0], 0, new Object[0]);\n-\n-        \/\/ Unable to place this code once in the method epilog due to bug in ASM\n-        mw.visitLabel(throwLabel);\n-        createThrowRuntimeExceptionCode(mw,\n-                \"invokedynamic should always throw (bootstrap type\" + type +\", opcode=\" + type.asmTag + \")!\");\n-\n-        mw.visitFrame(Opcodes.F_SAME, 0, new Object[0], 0, new Object[0]);\n-        mw.visitLabel(nextBlockLabel);\n+    protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+\n+        bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withMethod(methodName, MethodTypeDesc.ofDescriptor(methodSignature), accessFlags,\n+                mb -> mb.withCode(cob -> {\n+                    DirectMethodHandleDesc.Kind[] kinds = DirectMethodHandleDesc.Kind.values();\n+                    DirectMethodHandleDesc.Kind kind = kinds[Env.getRNG().nextInt(kinds.length)];\n+\n+                    switch (kind) {\n+                        case GETTER:\n+                        case SETTER:\n+                        case STATIC_GETTER:\n+                        case STATIC_SETTER:\n+                        case SPECIAL:\n+                        case VIRTUAL:\n+                        case INTERFACE_VIRTUAL:\n+                            break;\n+                        default:\n+                            return ;\n+                    }\n+                    Label indyThrowableBegin = cob.newLabel();\n+                    Label indyThrowableEnd = cob.newLabel();\n+                    Label catchThrowableLabel = cob.newLabel();\n+\n+                    Label indyBootstrapBegin = cob.newLabel();\n+                    Label indyBootstrapEnd = cob.newLabel();\n+                    Label catchBootstrapLabel = cob.newLabel();\n+\n+                    cob.trying(\n+                            tryBlock -> {\n+                                tryBlock.labelBinding(indyBootstrapBegin);\n+                                tryBlock.labelBinding(indyBootstrapEnd);\n+                            },\n+                            catchBuilder -> {\n+                                catchBuilder.catching(ClassDesc.of(JL_BOOTSTRAPMETHODERROR), catchBlock -> {e:\n+                                    catchBlock.labelBinding(catchBootstrapLabel);\n+                                    catchBlock.returnInstruction(TypeKind.VoidType);\n+                                });\n+                            }\n+                    );\n+                    cob.labelBinding(indyThrowableBegin);\n+\n+                    cob.trying(\n+                            tryBlock -> {\n+                                tryBlock.labelBinding(indyThrowableBegin);\n+                                tryBlock.labelBinding(indyThrowableEnd);\n+                            },\n+                            catchBuilder -> {\n+                                catchBuilder.catching(ClassDesc.of(JL_THROWABLE), catchBlock -> {\n+                                    catchBlock.labelBinding(catchThrowableLabel);\n+                                    catchBlock.returnInstruction(TypeKind.VoidType);\n+                                });\n+                            }\n+                    );\n+                    cob.labelBinding(indyBootstrapBegin);\n+\n+                    DirectMethodHandleDesc bsm;\n+                    switch (kind) {\n+                        case GETTER:\n+                        case SETTER:\n+                            bsm = MethodHandleDesc.ofField(kind, ClassDesc.of(fullClassName), INSTANCE_BOOTSTRAP_FIELD_NAME, ClassDesc.ofDescriptor(INSTANCE_BOOTSTRAP_FIELD_SIGNATURE));\n+                            break;\n+                        case STATIC_GETTER:\n+                        case STATIC_SETTER:\n+                            bsm = MethodHandleDesc.ofField(kind, ClassDesc.of(fullClassName), STATIC_BOOTSTRAP_FIELD_NAME, ClassDesc.ofDescriptor(STATIC_BOOTSTRAP_FIELD_SIGNATURE));\n+                            break;\n+                        case SPECIAL:\n+                        case VIRTUAL:\n+                        case INTERFACE_VIRTUAL:\n+                            bsm = MethodHandleDesc.ofMethod(kind, ClassDesc.of(fullClassName), INSTANCE_BOOTSTRAP_METHOD_NAME, MethodTypeDesc.ofDescriptor(INSTANCE_BOOTSTRAP_METHOD_SIGNATURE));\n+                            break;\n+                        default:\n+                            throw new Error(\"Unexpected handle type \" + kind);\n+                    }\n+\n+                    cob.invokedynamic(DynamicCallSiteDesc.of(bsm, TARGET_METHOD_NAME, MethodTypeDesc.ofDescriptor(TARGET_METHOD_SIGNATURE)));\n+                    cob.labelBinding(indyBootstrapEnd);\n+                    cob.labelBinding(indyThrowableEnd);\n+\n+                    \/\/ No exception at all, throw error\n+                    Label throwLabel = cob.newLabel();\n+                    cob.goto_(throwLabel);\n+\n+                    \/\/ Got a bootstrapmethoderror as expected, check that it is wrapping what we expect\n+                    cob.labelBinding(catchBootstrapLabel);\n+\n+                    \/\/ Save error in case we need to rethrow it\n+                    cob.dup();\n+                    cob.astore(1);\n+                    cob.invokevirtual(ClassDesc.of(JL_THROWABLE), \"getCause\", MethodTypeDesc.ofDescriptor(\"()\" + fd(JL_THROWABLE)));\n+\n+\n+                    \/\/ If it is the expected exception, goto next block\n+                    cob.instanceof_(ClassDesc.of(WRAPPED_EXCEPTION)); \/\/ Check if the object on top of the stack is of the specified type\n+                    Label nextBlockLabel = cob.newLabel();\n+                    cob.ifne(nextBlockLabel);\n+\n+                    \/\/ Not the exception we were expectiong, throw error\n+                    cob.aload(1);\n+                    createThrowRuntimeExceptionCodeHelper(cob, \"invokedynamic got an unexpected wrapped exception (expected \" + WRAPPED_EXCEPTION + \", bootstrap type=\" + kind + \", opcode=\" + kind.refKind + \")!\", true);\n+\n+\n+                    \/\/ JDK-8294976 workaround: we have to generate stackmaps manually and since ClassFile API automatically generates stack map frames, so there is no need to manually generate them.\n+                    cob.labelBinding(catchThrowableLabel);\n+\n+                    \/\/ Save error in case we need to rethrow it\n+                    cob.dup();\n+                    cob.astore(1);\n+\n+                    \/\/ If it is the expected exception, goto next block\n+                    cob.instanceof_(ClassDesc.of(DIRECT_ERROR)); \/\/ Check if the object on top of the stack is of the specified type\n+                    cob.ifne(nextBlockLabel);\n+\n+                    \/\/ Not the exception we were expectiong, throw error\n+                    cob.aload(1);\n+                    createThrowRuntimeExceptionCodeHelper(cob,\n+                            \"invokedynamic got an unexpected exception (expected \" + DIRECT_ERROR\n+                                    + \", bootstrap type\" + kind\n+                                    + \", opcode=\" + kind.refKind + \")!\", true);\n+\n+                    \/\/ Unable to place this code once in the method epilog due to bug in ASM\n+                    cob.labelBinding(throwLabel);\n+                    createThrowRuntimeExceptionCodeHelper(cob,\n+                            \"invokedynamic should always throw (bootstrap type\"\n+                                    + kind +\", \"\n+                                    + \"opcode=\" + kind.refKind + \")!\", false);\n+\n+                    cob.labelBinding(nextBlockLabel);\n+                    cob.return_();\n+                }))));\n+\n+        return bytes;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenManyIndyIncorrectBootstrap.java","additions":189,"deletions":185,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -26,4 +26,8 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Handle;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -40,9 +44,14 @@\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        Handle bsm = new Handle(Opcodes.H_INVOKESTATIC,\n-                fullClassName,\n-                BOOTSTRAP_METHOD_NAME,\n-                BOOTSTRAP_METHOD_SIGNATURE);\n-\n-        mw.visitInvokeDynamicInsn(TARGET_METHOD_NAME,\n-                TARGET_METHOD_SIGNATURE,\n-                bsm);\n+    protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+\n+        bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withMethod(methodName, MethodTypeDesc.ofDescriptor(methodSignature), accessFlags,\n+                mb -> mb.withCode(cob -> {\n+                    \/\/ Create the bootstrap method handle\n+                    DirectMethodHandleDesc bsm = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, ClassDesc.of(fullClassName),\n+                            BOOTSTRAP_METHOD_NAME, MethodTypeDesc.ofDescriptor(BOOTSTRAP_METHOD_SIGNATURE));\n+\n+                    \/\/ Generate the invokedynamic instruction\n+                    cob.invokedynamic(DynamicCallSiteDesc.of(bsm, TARGET_METHOD_NAME, MethodTypeDesc.ofDescriptor(TARGET_METHOD_SIGNATURE)));\n+                }))));\n+\n+        return bytes;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenManyIndyOneCPX.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package vm.mlvm.cp.share;\n-\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-\n-public enum HandleType {\n-    GETFIELD(Opcodes.H_GETFIELD),\n-    PUTFIELD(Opcodes.H_PUTFIELD),\n-    GETSTATIC(Opcodes.H_GETSTATIC),\n-    PUTSTATIC(Opcodes.H_PUTSTATIC),\n-    NEWINVOKESPECIAL(Opcodes.H_NEWINVOKESPECIAL),\n-    INVOKESTATIC(Opcodes.H_INVOKESTATIC),\n-    INVOKEINTERFACE(Opcodes.H_INVOKEINTERFACE),\n-    INVOKESPECIAL(Opcodes.H_INVOKESPECIAL),\n-    INVOKEVIRTUAL(Opcodes.H_INVOKEVIRTUAL);\n-\n-    public final int asmTag;\n-    private HandleType(int asmTag) {\n-        this.asmTag = asmTag;\n-    }\n-}\n-\n-\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/HandleType.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"}]}