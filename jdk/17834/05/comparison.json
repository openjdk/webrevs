{"files":[{"patch":"@@ -26,5 +26,9 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ClassWriterExt;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Handle;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Random;\n@@ -42,2 +46,10 @@\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        cw.setCacheMHandles(false);\n+    protected byte[] generateCommonData(byte[] bytes) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+        bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb\n+                .withField(STATIC_FIELD_NAME, ClassDesc.ofDescriptor(STATIC_FIELD_SIGNATURE),\n+                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC)\n+                .withField(INSTANCE_FIELD_NAME, ClassDesc.ofDescriptor(INSTANCE_FIELD_SIGNATURE), ClassFile.ACC_PUBLIC)\n+                .withMethod(INSTANCE_TARGET_METHOD_NAME, MethodTypeDesc.ofDescriptor(INSTANCE_TARGET_METHOD_SIGNATURE),\n+                        ClassFile.ACC_PUBLIC,\n+                        mb -> mb.withCode(\n+                                CodeBuilder::return_))));\n@@ -45,3 +57,2 @@\n-        cw.visitField(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n-                STATIC_FIELD_NAME,\n-                STATIC_FIELD_SIGNATURE, null, false);\n+        bytes = createInitMethod(bytes);\n+        bytes = createTargetMethod(bytes);\n@@ -49,14 +60,1 @@\n-        cw.visitField(Opcodes.ACC_PUBLIC,\n-                INSTANCE_FIELD_NAME,\n-                INSTANCE_FIELD_SIGNATURE, null, false);\n-\n-        createInitMethod(cw);\n-        createTargetMethod(cw);\n-\n-        MethodVisitor mv = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC,\n-                INSTANCE_TARGET_METHOD_NAME,\n-                INSTANCE_TARGET_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n-        finishMethodCode(mv);\n+        return bytes;\n@@ -66,3 +64,21 @@\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        HandleType[] types = HandleType.values();\n-        HandleType type = types[Env.getRNG().nextInt(types.length)];\n+    protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+        bytes = ClassFile.of().transform(cm,\n+                ClassTransform.endHandler(cb -> cb.withMethod(methodName,\n+                        MethodTypeDesc.ofDescriptor(methodSignature), accessFlags,\n+                        mb -> mb.withCode(\n+                                cob -> {\n+                                    DirectMethodHandleDesc.Kind[] kinds = DirectMethodHandleDesc.Kind.values();\n+                                    DirectMethodHandleDesc.Kind kind = kinds[Env.getRNG().nextInt(kinds.length)];\n+\n+                                    switch (kind) {\n+                                        case SETTER:\n+                                        case STATIC_SETTER:\n+                                            cob.iconst_0();\n+                                            break;\n+                                        case SPECIAL:\n+                                        case VIRTUAL:\n+                                        case INTERFACE_VIRTUAL:\n+                                            cob.aconst_null();\n+                                            break;\n+                                    }\n@@ -70,11 +86,33 @@\n-        switch (type) {\n-            case PUTFIELD:\n-            case PUTSTATIC:\n-                mw.visitInsn(Opcodes.ICONST_0);\n-                break;\n-            case INVOKESPECIAL:\n-            case INVOKEVIRTUAL:\n-            case INVOKEINTERFACE:\n-                mw.visitInsn(Opcodes.ACONST_NULL);\n-                break;\n-        }\n+                                    MethodHandleDesc handle;\n+                                    switch (kind) {\n+                                        case GETTER:\n+                                        case SETTER:\n+                                            handle = MethodHandleDesc.ofField(kind, ClassDesc.of(fullClassName),\n+                                                    INSTANCE_FIELD_NAME,\n+                                                    ClassDesc.ofDescriptor(INSTANCE_FIELD_SIGNATURE));\n+                                            break;\n+                                        case CONSTRUCTOR:\n+                                            handle = MethodHandleDesc.ofConstructor(ClassDesc.of(fullClassName),\n+                                                    ClassDesc.ofDescriptor(INIT_METHOD_SIGNATURE));\n+                                            break;\n+                                        case STATIC:\n+                                            handle = MethodHandleDesc.ofMethod(kind, ClassDesc.of(fullClassName),\n+                                                    TARGET_METHOD_NAME,\n+                                                    MethodTypeDesc.ofDescriptor(TARGET_METHOD_SIGNATURE));\n+                                            break;\n+                                        case INTERFACE_VIRTUAL:\n+                                            handle = MethodHandleDesc.ofMethod(kind,\n+                                                    ClassDesc.of(getDummyInterfaceClassName()),\n+                                                    INSTANCE_TARGET_METHOD_NAME,\n+                                                    MethodTypeDesc.ofDescriptor(INSTANCE_TARGET_METHOD_SIGNATURE));\n+                                            break;\n+                                        case SPECIAL:\n+                                        case VIRTUAL:\n+                                            handle = MethodHandleDesc.ofMethod(kind, ClassDesc.of(fullClassName),\n+                                                    INSTANCE_TARGET_METHOD_NAME,\n+                                                    MethodTypeDesc.ofDescriptor(INSTANCE_TARGET_METHOD_SIGNATURE));\n+                                            break;\n+                                        default:\n+                                            throw new Error(\"Unexpected handle type \" + kind);\n+                                    }\n+                                    cob.ldc(handle);\n@@ -82,45 +120,7 @@\n-        Handle handle;\n-        switch (type) {\n-            case GETFIELD:\n-            case PUTFIELD:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INSTANCE_FIELD_NAME,\n-                        INSTANCE_FIELD_SIGNATURE);\n-                break;\n-            case GETSTATIC:\n-            case PUTSTATIC:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        STATIC_FIELD_NAME,\n-                        STATIC_FIELD_SIGNATURE);\n-                break;\n-            case NEWINVOKESPECIAL:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INIT_METHOD_NAME,\n-                        INIT_METHOD_SIGNATURE);\n-                break;\n-            case INVOKESTATIC:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        TARGET_METHOD_NAME,\n-                        TARGET_METHOD_SIGNATURE);\n-                break;\n-            case INVOKEINTERFACE:\n-                handle = new Handle(type.asmTag,\n-                        getDummyInterfaceClassName(),\n-                        INSTANCE_TARGET_METHOD_NAME,\n-                        INSTANCE_TARGET_METHOD_SIGNATURE);\n-                break;\n-            case INVOKESPECIAL:\n-            case INVOKEVIRTUAL:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INSTANCE_TARGET_METHOD_NAME,\n-                        INSTANCE_TARGET_METHOD_SIGNATURE);\n-                break;\n-            default:\n-                throw new Error(\"Unexpected handle type \" + type);\n-        }\n-        mw.visitLdcInsn(handle);\n+                                    switch (kind) {\n+                                        case GETTER:\n+                                        case STATIC_GETTER:\n+                                            cob.pop();\n+                                            break;\n+                                    }\n+                                }))));\n@@ -128,6 +128,1 @@\n-        switch (type) {\n-            case GETFIELD:\n-            case GETSTATIC:\n-                mw.visitInsn(Opcodes.POP);\n-                break;\n-        }\n+        return bytes;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenCPFullOfMH.java","additions":84,"deletions":89,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -26,5 +26,5 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ClassWriterExt;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -41,3 +41,2 @@\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        cw.setCacheMTypes(false);\n-        super.generateCommonData(cw);\n+    protected byte[] generateCommonData(byte[] bytes) {\n+        return super.generateCommonData(bytes);\n@@ -47,3 +46,14 @@\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        mw.visitLdcInsn(Type.getMethodType(\"(FIZ)V\"));\n-        mw.visitInsn(Opcodes.POP);\n+    protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+\n+        bytes = ClassFile.of().transform(cm,\n+                ClassTransform.endHandler(cb -> cb.withMethod(methodName,\n+                        MethodTypeDesc.of(ClassDesc.ofDescriptor(methodSignature)), accessFlags,\n+                        mb -> mb.withCode(\n+                                cob -> {\n+                                    cob.ldc(MethodTypeDesc.ofDescriptor(\"(FIZ)V\"));\n+                                    cob.pop();\n+                                    cob.return_();\n+                                }))));\n+\n+        return bytes;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenCPFullOfMT.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,8 @@\n-import jdk.internal.org.objectweb.asm.ByteVector;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+\n+\n@@ -31,1 +38,0 @@\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -51,1 +57,1 @@\n-    protected static final String JL_CLASSLOADER  = \"java\/lang\/ClassLoader\";\n+    protected static final String JL_CLASSLOADER = \"java\/lang\/ClassLoader\";\n@@ -66,1 +72,2 @@\n-    protected static final String NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE = \"(\" + fd(JLI_METHODHANDLES_LOOKUP) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")V\";\n+    protected static final String NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE = \"(\" + fd(JLI_METHODHANDLES_LOOKUP)\n+            + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")V\";\n@@ -90,0 +97,2 @@\n+    protected static final MethodTypeDesc TEST_METHOD_TYPE_DESC = MethodTypeDesc.of(ClassDesc.ofDescriptor(\"V\"));\n+\n@@ -103,1 +112,2 @@\n-    protected static final String BOOTSTRAP_METHOD_SIGNATURE = \"(\" +  fd(JLI_METHODHANDLES_LOOKUP) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_CALLSITE);\n+    protected static final String BOOTSTRAP_METHOD_SIGNATURE = \"(\" + fd(JLI_METHODHANDLES_LOOKUP) + fd(JL_STRING)\n+            + fd(JLI_METHODTYPE) + \")\" + fd(JLI_CALLSITE);\n@@ -124,13 +134,0 @@\n-    protected static void createLogMsgCode(MethodVisitor mv, String msg) {\n-        mv.visitLdcInsn(msg);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"vm\/mlvm\/share\/Env\", \"traceVerbose\", \"(Ljava\/lang\/String;)V\");\n-    }\n-\n-    protected static void createThrowRuntimeExceptionCode(MethodVisitor mv, String msg) {\n-        createThrowRuntimeExceptionCodeHelper(mv, msg, false);\n-    }\n-\n-    \/\/ Expects a throwable (the cause) to be on top of the stack when called.\n-    protected static void createThrowRuntimeExceptionCodeWithCause(MethodVisitor mv, String msg) {\n-        createThrowRuntimeExceptionCodeHelper(mv, msg, true);\n-    }\n@@ -139,6 +136,8 @@\n-    protected static void createThrowRuntimeExceptionCodeHelper(MethodVisitor mv, String msg, boolean set_cause) {\n-        mv.visitTypeInsn(Opcodes.NEW, JL_RUNTIMEEXCEPTION);\n-        mv.visitInsn(Opcodes.DUP);\n-        mv.visitLdcInsn(msg);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, JL_RUNTIMEEXCEPTION,\n-                INIT_METHOD_NAME, \"(\" + fd(JL_STRING) + \")V\");\n+    protected static void createThrowRuntimeExceptionCodeHelper(CodeBuilder cob, String msg, boolean set_cause) {\n+\n+        cob.new_(ClassDesc.ofInternalName(JL_RUNTIMEEXCEPTION))\n+                .dup()\n+                .ldc(msg)\n+                .invokespecial(ClassDesc.ofInternalName(JL_RUNTIMEEXCEPTION),\n+                        INIT_METHOD_NAME,\n+                        MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_STRING) + \")V\"));\n@@ -146,3 +145,6 @@\n-          mv.visitInsn(Opcodes.SWAP);\n-          mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JL_RUNTIMEEXCEPTION,\n-                  \"initCause\", \"(\" + fd(JL_THROWABLE) + \")\"+ fd(JL_THROWABLE));\n+            cob.dup_x1()\n+                    .aload(0)\n+                    .invokevirtual(ClassDesc.ofInternalName(JL_THROWABLE), \"initCause\",\n+                            MethodTypeDesc.ofDescriptor(\n+                                    \"(\" + fd(JL_THROWABLE) + \")\"\n+                                            + fd(JL_THROWABLE)));\n@@ -150,1 +152,1 @@\n-        mv.visitInsn(Opcodes.ATHROW);\n+        cob.athrow();\n@@ -153,11 +155,15 @@\n-    protected static void createThrowRuntimeExceptionMethod(ClassWriter cw, boolean isStatic, String methodName, String methodSignature) {\n-        MethodVisitor mv = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC | (isStatic ? Opcodes.ACC_STATIC : 0),\n-                methodName, methodSignature,\n-                null,\n-                new String[0]);\n-\n-        createThrowRuntimeExceptionCode(mv, \"Method \" + methodName + methodSignature + \" should not be called!\");\n-\n-        mv.visitMaxs(-1,  -1);\n-        mv.visitEnd();\n+    protected static byte[] createThrowRuntimeExceptionMethod(byte[] bytes, boolean isStatic, String methodName,\n+            String methodSignature) {\n+        bytes = ClassFile.of().transform(ClassFile.of().parse(bytes), ClassTransform.endHandler(clb -> clb.withMethod(methodName,\n+                MethodTypeDesc.ofDescriptor(methodSignature),\n+                ClassFile.ACC_PUBLIC | (isStatic ? ClassFile.ACC_STATIC : 0),\n+                mb -> mb.withCode(cob -> {\n+                        cob.aload(cob.receiverSlot());\n+                        cob.ldc(\"Method \" + methodName + methodSignature + \" should not be called!\");\n+                        cob.invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/GenFullCP\"), \"createThrowRuntimeExceptionCode\",\n+                                MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;)V\"));\n+                        createThrowRuntimeExceptionCodeHelper(cob, \"Method \" + methodName + methodSignature + \" should not be called!\", false);\n+                        cob.return_();\n+                }))));\n+\n+        return bytes;\n@@ -166,2 +172,2 @@\n-    protected static void finishMethodCode(MethodVisitor mv) {\n-        finishMethodCode(mv, Opcodes.RETURN);\n+    protected byte[] createClassInitMethod(byte[] bytes) {\n+        return bytes;\n@@ -170,4 +176,14 @@\n-    protected static void finishMethodCode(MethodVisitor mv, int returnOpcode) {\n-        mv.visitInsn(returnOpcode);\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    protected byte[] createInitMethod(byte[] bytes) {\n+        return ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                ClassTransform.endHandler(clb -> clb.withMethod(INIT_METHOD_NAME,\n+                        MethodTypeDesc.ofDescriptor(VOID_NO_ARG_METHOD_SIGNATURE),\n+                        ClassFile.ACC_PUBLIC,\n+                        mb -> mb.withCode(cb -> cb\n+                                .aload(cb.receiverSlot())\n+                                .aload(cb.parameterSlot(0))\n+                                .ldc(fullClassName + \" constructor called\")\n+                                .invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/Env\"), \"traceVerbose\",\n+                                        MethodTypeDesc.ofDescriptor(\"Ljava\/lang\/String;)V\"))\n+                                .invokespecial(ClassDesc.ofInternalName(PARENT_CLASS_NAME), INIT_METHOD_NAME,\n+                                        MethodTypeDesc.ofDescriptor(VOID_NO_ARG_METHOD_SIGNATURE))\n+                                .return_()))));\n@@ -176,1 +192,11 @@\n-    protected void createClassInitMethod(ClassWriter cw) {\n+    protected byte[] createTargetMethod(byte[] bytes) {\n+        return ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                ClassTransform.endHandler(\n+                        cb -> cb.withMethod(TARGET_METHOD_NAME, MethodTypeDesc.ofDescriptor(TARGET_METHOD_SIGNATURE),\n+                                ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                mb -> mb.withCode(\n+                                        CodeBuilder -> CodeBuilder\n+                                                .ldc(fullClassName + \" constructor called\")\n+                                                .invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/Env\"), \"traceVerbose\",\n+                                                        MethodTypeDesc.ofDescriptor(\"Ljava\/lang\/String;)V\"))\n+                                                .return_()))));\n@@ -179,15 +205,2 @@\n-    protected void createInitMethod(ClassWriter cw) {\n-        MethodVisitor mv = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC,\n-                INIT_METHOD_NAME, INIT_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n-\n-        mv.visitIntInsn(Opcodes.ALOAD, 0);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL,\n-                PARENT_CLASS_NAME,\n-                INIT_METHOD_NAME, INIT_METHOD_SIGNATURE);\n-\n-        createLogMsgCode(mv, fullClassName + \" constructor called\");\n-\n-        finishMethodCode(mv);\n+    protected byte[] createBootstrapMethod(byte[] bytes) {\n+        return createBootstrapMethod(bytes, true, BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_SIGNATURE);\n@@ -196,8 +209,2 @@\n-    protected void createTargetMethod(ClassWriter cw) {\n-        MethodVisitor mv = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n-                TARGET_METHOD_NAME, TARGET_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n-\n-        createLogMsgCode(mv, fullClassName + \".\" + TARGET_METHOD_NAME + TARGET_METHOD_SIGNATURE + \" called\");\n+    protected byte[] createBootstrapMethod(byte[] bytes, boolean isStatic, String methodName, String methodSignature) {\n+        int argShift = isStatic ? 0 : 1;\n@@ -205,1 +212,22 @@\n-        finishMethodCode(mv);\n+        return ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                ClassTransform.endHandler(cb -> cb.withMethod(methodName, MethodTypeDesc.ofDescriptor(methodSignature),\n+                        ClassFile.ACC_PUBLIC | (isStatic ? ClassFile.ACC_STATIC : 0),\n+                        mb -> mb.withCode(\n+                                CodeBuilder -> CodeBuilder\n+                                        .ldc(fullClassName + \".\" + BOOTSTRAP_METHOD_NAME + BOOTSTRAP_METHOD_SIGNATURE\n+                                                + \" called\")\n+                                        .invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/Env\"), \"traceVerbose\",\n+                                                MethodTypeDesc.ofDescriptor(\"Ljava\/lang\/String;)V\"))\n+                                        .new_(ClassDesc.ofInternalName(JLI_CONSTANTCALLSITE))\n+                                        .dup()\n+                                        .aload(0 + argShift)\n+                                        .ldc(ClassDesc.ofDescriptor(fullClassName))\n+                                        .aload(1 + argShift)\n+                                        .aload(2 + argShift)\n+                                        .invokevirtual(ClassDesc.ofInternalName(JLI_METHODHANDLES_LOOKUP), \"findStatic\",\n+                                                MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_CLASS) + fd(JL_STRING)\n+                                                        + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE)))\n+                                        .invokespecial(ClassDesc.ofInternalName(JLI_CONSTANTCALLSITE),\n+                                                INIT_METHOD_NAME,\n+                                                MethodTypeDesc.ofDescriptor(\"(\" + fd(JLI_METHODHANDLE) + \")V\"))\n+                                        .areturn()))));\n@@ -208,2 +236,2 @@\n-    protected void createBootstrapMethod(ClassWriter cw) {\n-         createBootstrapMethod(cw, true, BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_SIGNATURE);\n+    protected static void finishMethodCode(MethodVisitor mv) {\n+        finishMethodCode(mv, Opcodes.RETURN);\n@@ -212,23 +240,4 @@\n-    protected void createBootstrapMethod(ClassWriter cw, boolean isStatic, String methodName, String methodSignature) {\n-        MethodVisitor mv = cw.visitMethod(\n-                (isStatic ? Opcodes.ACC_STATIC : 0) | Opcodes.ACC_PUBLIC,\n-                methodName, methodSignature,\n-                null, new String[0]);\n-\n-        createLogMsgCode(mv, fullClassName + \".\" + BOOTSTRAP_METHOD_NAME + BOOTSTRAP_METHOD_SIGNATURE + \" called\");\n-\n-        int argShift = isStatic ? 0 : 1;\n-\n-        mv.visitTypeInsn(Opcodes.NEW, JLI_CONSTANTCALLSITE);\n-        mv.visitInsn(Opcodes.DUP);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0 + argShift);\n-        mv.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mv.visitVarInsn(Opcodes.ALOAD, 1 + argShift);\n-        mv.visitVarInsn(Opcodes.ALOAD, 2 + argShift);\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,\n-                JLI_METHODHANDLES_LOOKUP, \"findStatic\",\n-                \"(\" + fd(JL_CLASS) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE));\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, JLI_CONSTANTCALLSITE,\n-                INIT_METHOD_NAME, \"(\" + fd(JLI_METHODHANDLE) + \")V\");\n-\n-        finishMethodCode(mv, Opcodes.ARETURN);\n+    protected static void finishMethodCode(MethodVisitor mv, int returnOpcode) {\n+        mv.visitInsn(returnOpcode);\n+        mv.visitMaxs(-1, -1);\n+        mv.visitEnd();\n@@ -241,1 +250,1 @@\n-        ClassWriterExt cw = new ClassWriterExt(\/*ClassWriter.COMPUTE_FRAMES |*\/ ClassWriter.COMPUTE_MAXS);\n+        ClassWriterExt cw = new ClassWriterExt(\/* ClassWriter.COMPUTE_FRAMES | *\/ ClassWriter.COMPUTE_MAXS);\n@@ -245,1 +254,0 @@\n-        cw.visit(CLASSFILE_VERSION, Opcodes.ACC_PUBLIC, fullClassName, null, PARENT_CLASS_NAME, interfaces);\n@@ -247,10 +255,21 @@\n-        generateCommonData(cw);\n-\n-        MethodVisitor mainMV = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n-                MAIN_METHOD_NAME, MAIN_METHOD_SIGNATURE,\n-                null, new String[0]);\n-\n-        mainMV.visitTypeInsn(Opcodes.NEW, fullClassName);\n-        mainMV.visitInsn(Opcodes.DUP);\n-        mainMV.visitMethodInsn(Opcodes.INVOKESPECIAL, fullClassName, INIT_METHOD_NAME, INIT_METHOD_SIGNATURE);\n+        byte[] bytes = ClassFile.of().build(ClassDesc.ofInternalName(fullClassName), classBuilder -> {\n+            classBuilder.withFlags(ClassFile.ACC_PUBLIC | ClassFile.ACC_SUPER)\n+                    .withInterfaceSymbols(ClassDesc.ofInternalName(interfaces[0]))\n+                    .withSuperclass(ClassDesc.ofInternalName(PARENT_CLASS_NAME))\n+                    .withVersion(CLASSFILE_VERSION, 0);\n+        });\n+\n+        bytes = generateCommonData(bytes);\n+\n+        bytes = ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                ClassTransform.endHandler(cb -> cb.withFlags(ClassFile.ACC_PUBLIC | ClassFile.ACC_SUPER)\n+                        .withMethod(MAIN_METHOD_NAME, MethodTypeDesc.ofDescriptor(MAIN_METHOD_SIGNATURE),\n+                                ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                mb -> mb.withCode(\n+                                        codeBuilder -> codeBuilder\n+                                                .new_(ClassDesc.ofInternalName(fullClassName))\n+                                                .dup()\n+                                                .invokespecial(ClassDesc.ofInternalName(fullClassName),\n+                                                        INIT_METHOD_NAME,\n+                                                        MethodTypeDesc.of(ConstantDescs.CD_void))\n+                                                .return_()))));\n@@ -265,4 +284,5 @@\n-            MethodVisitor mw = cw.visitMethod(\n-                    Opcodes.ACC_PUBLIC,\n-                    methodName, TEST_METHOD_SIGNATURE,\n-                    null, new String[0]);\n+            bytes = ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                    ClassTransform.endHandler(cb -> cb.withMethod(methodName, TEST_METHOD_TYPE_DESC,\n+                            ClassFile.ACC_PUBLIC,\n+                            mb -> mb.withCode(\n+                                    CodeBuilder::return_))));\n@@ -270,1 +290,1 @@\n-            generateTestMethodProlog(mw);\n+            bytes = generateTestMethodProlog(bytes);\n@@ -273,2 +293,2 @@\n-            while (constCount < CP_CONST_COUNT && cw.getBytecodeLength(mw) < MAX_METHOD_SIZE) {\n-                generateCPEntryData(cw, mw);\n+            while (constCount < CP_CONST_COUNT && cw.getByteCodeLength(ClassFile.of().parse(bytes)) < MAX_METHOD_SIZE) {\n+                bytes = generateCPEntryData(bytes, methodName, TEST_METHOD_SIGNATURE, ClassFile.ACC_PUBLIC);\n@@ -278,5 +298,1 @@\n-            generateTestMethodEpilog(mw);\n-\n-            mw.visitMaxs(-1, -1);\n-            mw.visitEnd();\n-\n+            bytes = generateTestMethodEpilog(bytes);\n@@ -284,2 +300,2 @@\n-                          + constCount + \" constants in CP, \"\n-                          + cw.getBytecodeLength(mw) + \" bytes of code\");\n+                    + constCount + \" constants in CP, \"\n+                    + cw.getByteCodeLength(ClassFile.of().parse(bytes)) + \" bytes of code\");\n@@ -287,1 +303,1 @@\n-            mainMV.visitInsn(Opcodes.DUP);\n+            MainMV.visitInsn(Opcodes.DUP);\n@@ -296,2 +312,1 @@\n-        cw.visitEnd();\n-        return new Klass[] { new Klass(this.pkgName, this.shortClassName, MAIN_METHOD_NAME, MAIN_METHOD_SIGNATURE, cw.toByteArray()) };\n+        return new Klass[] { new Klass(this.pkgName, this.shortClassName, MAIN_METHOD_NAME, MAIN_METHOD_SIGNATURE, bytes) };\n@@ -300,5 +315,6 @@\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        createClassInitMethod(cw);\n-        createInitMethod(cw);\n-        createTargetMethod(cw);\n-        createBootstrapMethod(cw);\n+    protected byte[] generateCommonData(byte[] bytes) {\n+        bytes = createClassInitMethod(bytes);\n+        bytes = createInitMethod(bytes);\n+        bytes = createTargetMethod(bytes);\n+        bytes = createBootstrapMethod(bytes);\n+        return bytes;\n@@ -307,1 +323,2 @@\n-    protected void generateTestMethodProlog(MethodVisitor mw) {\n+    protected byte[] generateTestMethodProlog(byte[] bytes) {\n+        return bytes;\n@@ -310,1 +327,1 @@\n-    protected abstract void generateCPEntryData(ClassWriter cw, MethodVisitor mw);\n+    protected abstract byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags);\n@@ -312,2 +329,4 @@\n-    protected void generateTestMethodEpilog(MethodVisitor mw) {\n-        mw.visitInsn(Opcodes.RETURN);\n+    protected byte[] generateTestMethodEpilog(byte[] bytes) {\n+        return ClassFile.of().transform(ClassFile.of().parse(bytes), ClassTransform.endHandler(\n+                cb -> cb.withMethod(methodName, MethodTypeDesc.ofDescriptor(TEST_METHOD_SIGNATURE), ClassFile.ACC_PUBLIC,\n+                        mb -> mb.withCode(CodeBuilder::return_))));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenFullCP.java","additions":152,"deletions":133,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -26,6 +26,4 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ClassWriterExt;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.constant.*;\n@@ -38,8 +36,17 @@\n-    \/**\n-     * Generates a class file and writes it to a file\n-     * @see vm.mlvm.share.ClassfileGenerator\n-     * @param args Parameters for ClassfileGenerator.main() method\n-     *\/\n-    public static void main(String[] args) {\n-        ClassfileGenerator.main(args);\n-    }\n+        \/**\n+         * Generates a class file and writes it to a file\n+         * @see vm.mlvm.share.ClassfileGenerator\n+         * @param args Parameters for ClassfileGenerator.main() method\n+         *\/\n+        public static void main(String[] args) {\n+            ClassfileGenerator.main(args);\n+        }\n+\n+        \/**\n+         * Creates static init method, which constructs a call site object, which refers to the target method\n+         * and invokes Dummy.setMH() on this call site\n+         * @param bytes Class file bytes\n+         *\/\n+        @Override\n+        protected byte[] createClassInitMethod(byte[] bytes) {\n+                ClassModel cm = ClassFile.of().parse(bytes);\n@@ -47,12 +54,45 @@\n-    \/**\n-     * Creates static init method, which constructs a call site object, which refers to the target method\n-     * and invokes Dummy.setMH() on this call site\n-     * @param cw Class writer object\n-     *\/\n-    @Override\n-    protected void createClassInitMethod(ClassWriter cw) {\n-        MethodVisitor mw = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC,\n-                STATIC_INIT_METHOD_NAME, INIT_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n+                bytes = ClassFile.of().transform(cm,\n+                                ClassTransform.endHandler(cb -> cb.withMethod(STATIC_INIT_METHOD_NAME,\n+                                                MethodTypeDesc.ofDescriptor(INIT_METHOD_SIGNATURE),\n+                                                ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                                mb -> mb.withCode(\n+                                                                cob -> {\n+                                                                        cob.invokestatic(ClassDesc.ofInternalName(\n+                                                                                        JLI_METHODHANDLES), \"lookup\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"()\"\n+                                                                                                        + fd(JLI_METHODHANDLES_LOOKUP)));\n+                                                                        cob.ldc(ClassDesc.ofDescriptor(fullClassName));\n+                                                                        cob.ldc(TARGET_METHOD_NAME);\n+                                                                        cob.ldc(TARGET_METHOD_SIGNATURE);\n+                                                                        cob.invokevirtual(\n+                                                                                        ClassDesc.ofInternalName(\n+                                                                                                        JL_CLASS),\n+                                                                                        \"getClassLoader\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"()\"\n+                                                                                                        + fd(JL_CLASSLOADER)));\n+                                                                        cob.invokestatic(\n+                                                                                        ClassDesc.ofInternalName(\n+                                                                                                        JLI_METHODTYPE),\n+                                                                                        \"fromMethodDescriptorString\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"(\"\n+                                                                                                        + fd(JL_STRING)\n+                                                                                                        + fd(JL_CLASSLOADER)\n+                                                                                                        + \")\"\n+                                                                                                        + fd(JLI_METHODTYPE)));\n+                                                                        cob.invokevirtual(ClassDesc.ofInternalName(\n+                                                                                        JLI_METHODHANDLES_LOOKUP),\n+                                                                                        \"findStatic\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"(\"\n+                                                                                                        + fd(JL_CLASS)\n+                                                                                                        + fd(JL_STRING)\n+                                                                                                        + fd(JLI_METHODTYPE)\n+                                                                                                        + \")\"\n+                                                                                                        + fd(JLI_METHODHANDLE)));\n+                                                                        cob.invokestatic(ClassDesc.ofInternalName(\n+                                                                                        NEW_INVOKE_SPECIAL_CLASS_NAME),\n+                                                                                        \"setMH\",\n+                                                                                        MethodTypeDesc.ofDescriptor(\"(\"\n+                                                                                                        + fd(JLI_METHODHANDLE)\n+                                                                                                        + \")V\"));\n+                                                                        cob.return_();\n+                                                                }))));\n@@ -60,13 +100,11 @@\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODHANDLES, \"lookup\", \"()\" + fd(JLI_METHODHANDLES_LOOKUP));\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitLdcInsn(TARGET_METHOD_NAME);\n-        mw.visitLdcInsn(TARGET_METHOD_SIGNATURE);\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + fd(JL_CLASSLOADER));\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODTYPE,\n-                \"fromMethodDescriptorString\", \"(\" + fd(JL_STRING) + fd(JL_CLASSLOADER) + \")\" + fd(JLI_METHODTYPE));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JLI_METHODHANDLES_LOOKUP,\n-                \"findStatic\", \"(\" + fd(JL_CLASS) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE));\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, NEW_INVOKE_SPECIAL_CLASS_NAME,\n-                \"setMH\", \"(\" + fd(JLI_METHODHANDLE) + \")V\");\n+                return bytes;\n+        }\n+\n+        \/**\n+         * Disables invoke dynamic CP entry caching and generate default common data\n+         * @param bytes Class file bytes\n+         *\/\n+        @Override\n+        protected byte[] generateCommonData(byte[] bytes) {\n+                return super.generateCommonData(bytes);\n+        }\n@@ -74,2 +112,9 @@\n-        finishMethodCode(mw);\n-    }\n+        \/**\n+         * Generates an invokedynamic instruction (plus CP entry)\n+         * which has a valid reference kind in the CP method handle entry for the\n+         * bootstrap method\n+         * @param bytes Class file bytes\n+         *\/\n+        @Override\n+        protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n+                ClassModel cm = ClassFile.of().parse(bytes);\n@@ -77,9 +122,22 @@\n-    \/**\n-     * Disables invoke dynamic CP entry caching and generate default common data\n-     * @param cw Class writer object\n-     *\/\n-    @Override\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        cw.setCacheInvokeDynamic(false);\n-        super.generateCommonData(cw);\n-    }\n+                bytes = ClassFile.of().transform(cm,\n+                                ClassTransform.endHandler(cb -> cb.withMethod(methodName,\n+                                                MethodTypeDesc.ofDescriptor(methodSignature), accessFlags,\n+                                                mb -> mb.withCode(\n+                                                                cob -> {\n+                                                                        DirectMethodHandleDesc bsm;\n+                                                                        if (Env.getRNG().nextBoolean()) {\n+                                                                                 bsm = MethodHandleDesc.ofMethod(\n+                                                                                        DirectMethodHandleDesc.Kind.SPECIAL,\n+                                                                                        ClassDesc.of(this.fullClassName),\n+                                                                                        INIT_METHOD_NAME,\n+                                                                                        MethodTypeDesc.ofDescriptor(NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE)\n+                                                                                );\n+                                                                        } else {\n+                                                                                 bsm = MethodHandleDesc.ofMethod(\n+                                                                                        DirectMethodHandleDesc.Kind.STATIC,\n+                                                                                        ClassDesc.of(this.fullClassName),\n+                                                                                        BOOTSTRAP_METHOD_NAME,\n+                                                                                        MethodTypeDesc.ofDescriptor(BOOTSTRAP_METHOD_SIGNATURE)\n+                                                                                );\n+                                                                        }\n+                                                                        cob.invokedynamic(DynamicCallSiteDesc.of(bsm, TARGET_METHOD_NAME, MethodTypeDesc.ofDescriptor(TARGET_METHOD_SIGNATURE)));\n@@ -87,19 +145,2 @@\n-    \/**\n-     * Generates an invokedynamic instruction (plus CP entry)\n-     * which has a valid reference kind in the CP method handle entry for the bootstrap method\n-     * @param cw Class writer object\n-     * @param mw Method writer object\n-     *\/\n-    @Override\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        Handle bsm;\n-        if (Env.getRNG().nextBoolean()) {\n-            bsm = new Handle(Opcodes.H_NEWINVOKESPECIAL,\n-                    NEW_INVOKE_SPECIAL_CLASS_NAME,\n-                    INIT_METHOD_NAME,\n-                    NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE);\n-        } else {\n-            bsm = new Handle(Opcodes.H_INVOKESTATIC,\n-                    this.fullClassName,\n-                    BOOTSTRAP_METHOD_NAME,\n-                    BOOTSTRAP_METHOD_SIGNATURE);\n+                                                                }))));\n+                return bytes;\n@@ -107,4 +148,0 @@\n-        mw.visitInvokeDynamicInsn(TARGET_METHOD_NAME,\n-                TARGET_METHOD_SIGNATURE,\n-                bsm);\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenManyIndyCorrectBootstrap.java","additions":110,"deletions":73,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -26,7 +26,11 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ClassWriterExt;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.Label;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.Label;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Random;\n+import java.lang.classfile.TypeKind;\n@@ -52,1 +56,1 @@\n-     * @param cw Class writer object\n+     * @param bytes Class file bytes\n@@ -55,34 +59,26 @@\n-    protected void createInitMethod(ClassWriter cw) {\n-        MethodVisitor mw = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC,\n-                INIT_METHOD_NAME, INIT_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n-\n-        mw.visitVarInsn(Opcodes.ALOAD, 0);\n-        mw.visitMethodInsn(Opcodes.INVOKESPECIAL, PARENT_CLASS_NAME,\n-                INIT_METHOD_NAME, INIT_METHOD_SIGNATURE);\n-\n-        \/\/ Create a call site for the target method and store it into bootstrap fields\n-        mw.visitVarInsn(Opcodes.ALOAD, 0);\n-        mw.visitTypeInsn(Opcodes.NEW, JLI_CONSTANTCALLSITE);\n-        mw.visitInsn(Opcodes.DUP);\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODHANDLES,\n-                \"lookup\", \"()\" + fd(JLI_METHODHANDLES_LOOKUP));\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitLdcInsn(TARGET_METHOD_NAME);\n-        mw.visitLdcInsn(TARGET_METHOD_SIGNATURE);\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + fd(JL_CLASSLOADER));\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODTYPE,\n-                \"fromMethodDescriptorString\", \"(\" + fd(JL_STRING) + fd(JL_CLASSLOADER) + \")\" + fd(JLI_METHODTYPE));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JLI_METHODHANDLES_LOOKUP,\n-                \"findStatic\", \"(\" + fd(JL_CLASS) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE));\n-        mw.visitMethodInsn(Opcodes.INVOKESPECIAL, JLI_CONSTANTCALLSITE,\n-                INIT_METHOD_NAME, \"(\" + fd(JLI_METHODHANDLE) + \")V\");\n-        mw.visitInsn(Opcodes.DUP);\n-        mw.visitFieldInsn(Opcodes.PUTSTATIC, fullClassName, STATIC_BOOTSTRAP_FIELD_NAME, STATIC_BOOTSTRAP_FIELD_SIGNATURE);\n-        mw.visitFieldInsn(Opcodes.PUTFIELD, fullClassName, INSTANCE_BOOTSTRAP_FIELD_NAME, INSTANCE_BOOTSTRAP_FIELD_SIGNATURE);\n-\n-        finishMethodCode(mw);\n+    protected byte[] createInitMethod(byte[] bytes) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+\n+        bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withMethod(INIT_METHOD_NAME, MethodTypeDesc.ofDescriptor(INIT_METHOD_SIGNATURE), ClassFile.ACC_PUBLIC,\n+                mb -> mb.withCode(cob -> {\n+                    cob.aload(0)\n+                            .invokespecial(ClassDesc.ofInternalName(PARENT_CLASS_NAME), INIT_METHOD_NAME, MethodTypeDesc.ofDescriptor(INIT_METHOD_SIGNATURE))\n+                            .aload(0)\n+                            .new_(ClassDesc.ofInternalName(JLI_CONSTANTCALLSITE))\n+                            .dup()\n+                            .invokestatic(ClassDesc.ofInternalName(JLI_METHODHANDLES), \"lookup\", MethodTypeDesc.ofDescriptor(\"()\" + fd(JLI_METHODHANDLES_LOOKUP)))\n+                            .ldc(ClassDesc.ofDescriptor(fullClassName))\n+                            .ldc(TARGET_METHOD_NAME)\n+                            .ldc(TARGET_METHOD_SIGNATURE)\n+                            .ldc(ClassDesc.ofDescriptor(fullClassName))\n+                            .invokevirtual(ClassDesc.ofInternalName(JL_CLASS), \"getClassLoader\", MethodTypeDesc.ofDescriptor(\"()\" + fd(JL_CLASSLOADER)))\n+                            .invokestatic(ClassDesc.ofInternalName(JLI_METHODTYPE), \"fromMethodDescriptorString\", MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_STRING) + fd(JL_CLASSLOADER) + \")\" + fd(JLI_METHODTYPE)))\n+                            .invokevirtual(ClassDesc.ofInternalName(JLI_METHODHANDLES_LOOKUP), \"findStatic\", MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_CLASS) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE)))\n+                            .invokespecial(ClassDesc.ofInternalName(JLI_CONSTANTCALLSITE), INIT_METHOD_NAME, MethodTypeDesc.ofDescriptor(\"(\" + fd(JLI_METHODHANDLE) + \")V\"))\n+                            .dup()\n+                            .putstatic(ClassDesc.ofInternalName(fullClassName), STATIC_BOOTSTRAP_FIELD_NAME, ClassDesc.ofDescriptor(STATIC_BOOTSTRAP_FIELD_SIGNATURE))\n+                            .putfield(ClassDesc.ofInternalName(fullClassName), INSTANCE_BOOTSTRAP_FIELD_NAME, ClassDesc.ofDescriptor(INSTANCE_BOOTSTRAP_FIELD_SIGNATURE))\n+                            .return_();\n+                }))));\n+\n+        return bytes;\n@@ -94,1 +90,1 @@\n-     * @param cw Class writer object\n+     * @param bytes Class file bytes\n@@ -97,2 +93,2 @@\n-    protected void createTargetMethod(ClassWriter cw) {\n-        createThrowRuntimeExceptionMethod(cw, true, TARGET_METHOD_NAME, TARGET_METHOD_SIGNATURE);\n+    protected byte[] createTargetMethod(byte[] bytes) {\n+        return createThrowRuntimeExceptionMethod(bytes, true, TARGET_METHOD_NAME, TARGET_METHOD_SIGNATURE);\n@@ -104,1 +100,1 @@\n-     * @param cw Class writer object\n+     * @param bytes Class file bytes\n@@ -107,2 +103,2 @@\n-    protected void createBootstrapMethod(ClassWriter cw) {\n-        createThrowRuntimeExceptionMethod(cw, true, BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_SIGNATURE);\n+    protected byte[] createBootstrapMethod(byte[] bytes) {\n+        return createThrowRuntimeExceptionMethod(bytes, true, BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_SIGNATURE);\n@@ -114,1 +110,1 @@\n-     * @param cw Class writer object\n+     * @param bytes Class file bytes\n@@ -117,2 +113,1 @@\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        cw.setCacheInvokeDynamic(false);\n+    protected byte[] generateCommonData(byte[] bytes) {\n@@ -120,3 +115,1 @@\n-        cw.visitField(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n-                STATIC_BOOTSTRAP_FIELD_NAME,\n-                STATIC_BOOTSTRAP_FIELD_SIGNATURE, null, null);\n+            ClassModel cm = ClassFile.of().parse(bytes);\n@@ -124,3 +117,7 @@\n-        cw.visitField(Opcodes.ACC_PUBLIC,\n-                INSTANCE_BOOTSTRAP_FIELD_NAME,\n-                INSTANCE_BOOTSTRAP_FIELD_SIGNATURE, null, null);\n+            bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb\n+                            .withField(STATIC_BOOTSTRAP_FIELD_NAME,\n+                                            ClassDesc.ofDescriptor(STATIC_BOOTSTRAP_FIELD_SIGNATURE),\n+                                            ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC)\n+                            .withField(INSTANCE_BOOTSTRAP_FIELD_NAME,\n+                                            ClassDesc.ofDescriptor(INSTANCE_BOOTSTRAP_FIELD_SIGNATURE),\n+                                            ClassFile.ACC_PUBLIC)));\n@@ -128,1 +125,1 @@\n-        super.generateCommonData(cw);\n+            bytes = super.generateCommonData(bytes);\n@@ -130,1 +127,1 @@\n-        createThrowRuntimeExceptionMethod(cw, false, INSTANCE_BOOTSTRAP_METHOD_NAME, INSTANCE_BOOTSTRAP_METHOD_SIGNATURE);\n+            return createThrowRuntimeExceptionMethod(bytes, false, INSTANCE_BOOTSTRAP_METHOD_NAME, INSTANCE_BOOTSTRAP_METHOD_SIGNATURE);\n@@ -145,2 +142,1 @@\n-     * @param cw Class writer object\n-     * @param mw Method writer object\n+     * @param bytes Class file bytes\n@@ -149,124 +145,131 @@\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        HandleType[] types = HandleType.values();\n-        HandleType type = types[Env.getRNG().nextInt(types.length)];\n-\n-        switch (type) {\n-            case GETFIELD:\n-            case PUTFIELD:\n-            case GETSTATIC:\n-            case PUTSTATIC:\n-            case INVOKESPECIAL:\n-            case INVOKEVIRTUAL:\n-            case INVOKEINTERFACE:\n-                \/\/ Handle these cases\n-                break;\n-            default:\n-                \/\/ And don't generate code for all other cases\n-                return;\n-        }\n-\n-        Label indyThrowableBegin = new Label();\n-        Label indyThrowableEnd = new Label();\n-        Label catchThrowableLabel = new Label();\n-\n-        Label indyBootstrapBegin = new Label();\n-        Label indyBootstrapEnd = new Label();\n-        Label catchBootstrapLabel = new Label();\n-\n-        mw.visitTryCatchBlock(indyBootstrapBegin, indyBootstrapEnd, catchBootstrapLabel, JL_BOOTSTRAPMETHODERROR);\n-        mw.visitLabel(indyBootstrapBegin);\n-\n-        mw.visitTryCatchBlock(indyThrowableBegin, indyThrowableEnd, catchThrowableLabel, JL_THROWABLE);\n-        mw.visitLabel(indyThrowableBegin);\n-\n-        Handle bsm;\n-        switch (type) {\n-            case GETFIELD:\n-            case PUTFIELD:\n-                bsm = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INSTANCE_BOOTSTRAP_FIELD_NAME,\n-                        INSTANCE_BOOTSTRAP_FIELD_SIGNATURE);\n-                break;\n-            case GETSTATIC:\n-            case PUTSTATIC:\n-                bsm = new Handle(type.asmTag,\n-                        fullClassName,\n-                        STATIC_BOOTSTRAP_FIELD_NAME,\n-                        STATIC_BOOTSTRAP_FIELD_SIGNATURE);\n-                break;\n-            case INVOKESPECIAL:\n-            case INVOKEVIRTUAL:\n-            case INVOKEINTERFACE:\n-                bsm = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INSTANCE_BOOTSTRAP_METHOD_NAME,\n-                        INSTANCE_BOOTSTRAP_METHOD_SIGNATURE);\n-                break;\n-            default:\n-                throw new Error(\"Unexpected handle type \" + type);\n-        }\n-\n-        mw.visitInvokeDynamicInsn(TARGET_METHOD_NAME,\n-                TARGET_METHOD_SIGNATURE,\n-                bsm);\n-\n-        mw.visitLabel(indyBootstrapEnd);\n-        mw.visitLabel(indyThrowableEnd);\n-\n-        \/\/ No exception at all, throw error\n-        Label throwLabel = new Label();\n-        mw.visitJumpInsn(Opcodes.GOTO, throwLabel);\n-\n-        \/\/ JDK-8079697 workaround: we have to generate stackmaps manually\n-        mw.visitFrame(Opcodes.F_SAME1, 0, new Object[0], 1, new Object[] { JL_BOOTSTRAPMETHODERROR });\n-\n-        \/\/ Got a bootstrapmethoderror as expected, check that it is wrapping what we expect\n-        mw.visitLabel(catchBootstrapLabel);\n-\n-        \/\/ Save error in case we need to rethrow it\n-        mw.visitInsn(Opcodes.DUP);\n-        mw.visitVarInsn(Opcodes.ASTORE, 1);\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JL_THROWABLE, \"getCause\", \"()\" + fd(JL_THROWABLE));\n-\n-        \/\/ If it is the expected exception, goto next block\n-        mw.visitTypeInsn(Opcodes.INSTANCEOF, WRAPPED_EXCEPTION);\n-        Label nextBlockLabel = new Label();\n-        mw.visitJumpInsn(Opcodes.IFNE, nextBlockLabel);\n-\n-        \/\/ Not the exception we were expectiong, throw error\n-        mw.visitVarInsn(Opcodes.ALOAD, 1); \/\/ Use full chain as cause\n-        createThrowRuntimeExceptionCodeWithCause(mw,\n-                \"invokedynamic got an unexpected wrapped exception (expected \" + WRAPPED_EXCEPTION\n-                + \", bootstrap type=\" + type\n-                + \", opcode=\" + type.asmTag + \")!\");\n-\n-        \/\/ JDK-8079697 workaround: we have to generate stackmaps manually\n-        mw.visitFrame(Opcodes.F_SAME1, 0, new Object[0], 1, new Object[] { JL_THROWABLE });\n-        mw.visitLabel(catchThrowableLabel);\n-\n-        \/\/ Save error in case we need to rethrow it\n-        mw.visitInsn(Opcodes.DUP);\n-        mw.visitVarInsn(Opcodes.ASTORE, 1);\n-\n-        \/\/ If it is the expected exception, goto next block\n-        mw.visitTypeInsn(Opcodes.INSTANCEOF, DIRECT_ERROR);\n-        mw.visitJumpInsn(Opcodes.IFNE, nextBlockLabel);\n-\n-        \/\/ Not the exception we were expectiong, throw error\n-        mw.visitVarInsn(Opcodes.ALOAD, 1); \/\/ Use full chain as cause\n-        createThrowRuntimeExceptionCodeWithCause(mw,\n-                \"invokedynamic got an unexpected exception (expected \" + DIRECT_ERROR\n-                + \", bootstrap type\" + type\n-                + \", opcode=\" + type.asmTag + \")!\");\n-\n-        \/\/ JDK-8079697 workaround: we have to generate stackmaps manually\n-        mw.visitFrame(Opcodes.F_CHOP, 0, new Object[0], 0, new Object[0]);\n-\n-        \/\/ Unable to place this code once in the method epilog due to bug in ASM\n-        mw.visitLabel(throwLabel);\n-        createThrowRuntimeExceptionCode(mw,\n-                \"invokedynamic should always throw (bootstrap type\" + type +\", opcode=\" + type.asmTag + \")!\");\n-\n-        mw.visitFrame(Opcodes.F_SAME, 0, new Object[0], 0, new Object[0]);\n-        mw.visitLabel(nextBlockLabel);\n+    protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+\n+        bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withMethod(methodName, MethodTypeDesc.ofDescriptor(methodSignature), accessFlags,\n+                mb -> mb.withCode(cob -> {\n+                    DirectMethodHandleDesc.Kind[] kinds = DirectMethodHandleDesc.Kind.values();\n+                    DirectMethodHandleDesc.Kind kind = kinds[Env.getRNG().nextInt(kinds.length)];\n+\n+                    switch (kind) {\n+                        case GETTER:\n+                        case SETTER:\n+                        case STATIC_GETTER:\n+                        case STATIC_SETTER:\n+                        case SPECIAL:\n+                        case VIRTUAL:\n+                        case INTERFACE_VIRTUAL:\n+                            break;\n+                        default:\n+                            return ;\n+                    }\n+                    Label indyThrowableBegin = cob.newLabel();\n+                    Label indyThrowableEnd = cob.newLabel();\n+                    Label catchThrowableLabel = cob.newLabel();\n+\n+                    Label indyBootstrapBegin = cob.newLabel();\n+                    Label indyBootstrapEnd = cob.newLabel();\n+                    Label catchBootstrapLabel = cob.newLabel();\n+\n+                    cob.trying(\n+                            tryBlock -> {\n+                                tryBlock.labelBinding(indyBootstrapBegin);\n+                                tryBlock.labelBinding(indyBootstrapEnd);\n+                            },\n+                            catchBuilder -> {\n+                                catchBuilder.catching(ClassDesc.of(JL_BOOTSTRAPMETHODERROR), catchBlock -> {e:\n+                                    catchBlock.labelBinding(catchBootstrapLabel);\n+                                    catchBlock.returnInstruction(TypeKind.VoidType);\n+                                });\n+                            }\n+                    );\n+                    cob.labelBinding(indyThrowableBegin);\n+\n+                    cob.trying(\n+                            tryBlock -> {\n+                                tryBlock.labelBinding(indyThrowableBegin);\n+                                tryBlock.labelBinding(indyThrowableEnd);\n+                            },\n+                            catchBuilder -> {\n+                                catchBuilder.catching(ClassDesc.of(JL_THROWABLE), catchBlock -> {\n+                                    catchBlock.labelBinding(catchThrowableLabel);\n+                                    catchBlock.returnInstruction(TypeKind.VoidType);\n+                                });\n+                            }\n+                    );\n+                    cob.labelBinding(indyBootstrapBegin);\n+\n+                    DirectMethodHandleDesc bsm;\n+                    switch (kind) {\n+                        case GETTER:\n+                        case SETTER:\n+                            bsm = MethodHandleDesc.ofField(kind, ClassDesc.of(fullClassName), INSTANCE_BOOTSTRAP_FIELD_NAME, ClassDesc.ofDescriptor(INSTANCE_BOOTSTRAP_FIELD_SIGNATURE));\n+                            break;\n+                        case STATIC_GETTER:\n+                        case STATIC_SETTER:\n+                            bsm = MethodHandleDesc.ofField(kind, ClassDesc.of(fullClassName), STATIC_BOOTSTRAP_FIELD_NAME, ClassDesc.ofDescriptor(STATIC_BOOTSTRAP_FIELD_SIGNATURE));\n+                            break;\n+                        case SPECIAL:\n+                        case VIRTUAL:\n+                        case INTERFACE_VIRTUAL:\n+                            bsm = MethodHandleDesc.ofMethod(kind, ClassDesc.of(fullClassName), INSTANCE_BOOTSTRAP_METHOD_NAME, MethodTypeDesc.ofDescriptor(INSTANCE_BOOTSTRAP_METHOD_SIGNATURE));\n+                            break;\n+                        default:\n+                            throw new Error(\"Unexpected handle type \" + kind);\n+                    }\n+\n+                    cob.invokedynamic(DynamicCallSiteDesc.of(bsm, TARGET_METHOD_NAME, MethodTypeDesc.ofDescriptor(TARGET_METHOD_SIGNATURE)));\n+                    cob.labelBinding(indyBootstrapEnd);\n+                    cob.labelBinding(indyThrowableEnd);\n+\n+                    \/\/ No exception at all, throw error\n+                    Label throwLabel = cob.newLabel();\n+                    cob.goto_(throwLabel);\n+\n+                    \/\/ Got a bootstrapmethoderror as expected, check that it is wrapping what we expect\n+                    cob.labelBinding(catchBootstrapLabel);\n+\n+                    \/\/ Save error in case we need to rethrow it\n+                    cob.dup();\n+                    cob.astore(1);\n+                    cob.invokevirtual(ClassDesc.of(JL_THROWABLE), \"getCause\", MethodTypeDesc.ofDescriptor(\"()\" + fd(JL_THROWABLE)));\n+\n+\n+                    \/\/ If it is the expected exception, goto next block\n+                    cob.instanceof_(ClassDesc.of(WRAPPED_EXCEPTION)); \/\/ Check if the object on top of the stack is of the specified type\n+                    Label nextBlockLabel = cob.newLabel();\n+                    cob.ifne(nextBlockLabel);\n+\n+                    \/\/ Not the exception we were expectiong, throw error\n+                    cob.aload(1);\n+                    createThrowRuntimeExceptionCodeHelper(cob, \"invokedynamic got an unexpected wrapped exception (expected \" + WRAPPED_EXCEPTION + \", bootstrap type=\" + kind + \", opcode=\" + kind.refKind + \")!\", true);\n+\n+\n+                    \/\/ JDK-8294976 workaround: we have to generate stackmaps manually and since ClassFile API automatically generates stack map frames, so there is no need to manually generate them.\n+                    cob.labelBinding(catchThrowableLabel);\n+\n+                    \/\/ Save error in case we need to rethrow it\n+                    cob.dup();\n+                    cob.astore(1);\n+\n+                    \/\/ If it is the expected exception, goto next block\n+                    cob.instanceof_(ClassDesc.of(DIRECT_ERROR)); \/\/ Check if the object on top of the stack is of the specified type\n+                    cob.ifne(nextBlockLabel);\n+\n+                    \/\/ Not the exception we were expecting, throw error\n+                    cob.aload(1);\n+                    createThrowRuntimeExceptionCodeHelper(cob,\n+                            \"invokedynamic got an unexpected exception (expected \" + DIRECT_ERROR\n+                                    + \", bootstrap type\" + kind\n+                                    + \", opcode=\" + kind.refKind + \")!\", true);\n+\n+                    cob.labelBinding(throwLabel);\n+                    createThrowRuntimeExceptionCodeHelper(cob,\n+                            \"invokedynamic should always throw (bootstrap type\"\n+                                    + kind +\", \"\n+                                    + \"opcode=\" + kind.refKind + \")!\", false);\n+\n+                    cob.labelBinding(nextBlockLabel);\n+                    cob.return_();\n+                }))));\n+\n+        return bytes;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenManyIndyIncorrectBootstrap.java","additions":188,"deletions":185,"binary":false,"changes":373,"status":"modified"},{"patch":"@@ -26,4 +26,8 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Handle;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -40,9 +44,14 @@\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        Handle bsm = new Handle(Opcodes.H_INVOKESTATIC,\n-                fullClassName,\n-                BOOTSTRAP_METHOD_NAME,\n-                BOOTSTRAP_METHOD_SIGNATURE);\n-\n-        mw.visitInvokeDynamicInsn(TARGET_METHOD_NAME,\n-                TARGET_METHOD_SIGNATURE,\n-                bsm);\n+    protected byte[] generateCPEntryData(byte[] bytes, String methodName, String methodSignature, int accessFlags) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+\n+        bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withMethod(methodName, MethodTypeDesc.ofDescriptor(methodSignature), accessFlags,\n+                mb -> mb.withCode(cob -> {\n+                    \/\/ Create the bootstrap method handle\n+                    DirectMethodHandleDesc bsm = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, ClassDesc.of(fullClassName),\n+                            BOOTSTRAP_METHOD_NAME, MethodTypeDesc.ofDescriptor(BOOTSTRAP_METHOD_SIGNATURE));\n+\n+                    \/\/ Generate the invokedynamic instruction\n+                    cob.invokedynamic(DynamicCallSiteDesc.of(bsm, TARGET_METHOD_NAME, MethodTypeDesc.ofDescriptor(TARGET_METHOD_SIGNATURE)));\n+                }))));\n+\n+        return bytes;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenManyIndyOneCPX.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package vm.mlvm.cp.share;\n-\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-\n-public enum HandleType {\n-    GETFIELD(Opcodes.H_GETFIELD),\n-    PUTFIELD(Opcodes.H_PUTFIELD),\n-    GETSTATIC(Opcodes.H_GETSTATIC),\n-    PUTSTATIC(Opcodes.H_PUTSTATIC),\n-    NEWINVOKESPECIAL(Opcodes.H_NEWINVOKESPECIAL),\n-    INVOKESTATIC(Opcodes.H_INVOKESTATIC),\n-    INVOKEINTERFACE(Opcodes.H_INVOKEINTERFACE),\n-    INVOKESPECIAL(Opcodes.H_INVOKESPECIAL),\n-    INVOKEVIRTUAL(Opcodes.H_INVOKEVIRTUAL);\n-\n-    public final int asmTag;\n-    private HandleType(int asmTag) {\n-        this.asmTag = asmTag;\n-    }\n-}\n-\n-\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/HandleType.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -26,0 +26,4 @@\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -123,15 +127,9 @@\n-    public int getBytecodeLength(MethodVisitor mv) {\n-        ByteVector code;\n-        try {\n-            java.lang.reflect.Field field = mv.getClass().getDeclaredField(\"code\");\n-            field.setAccessible(true);\n-            code = (ByteVector) field.get(mv);\n-        } catch (InaccessibleObjectException | SecurityException | ReflectiveOperationException e) {\n-            throw new Error(\"can not read field 'code' from class \" + mv.getClass(), e);\n-        }\n-        try {\n-            java.lang.reflect.Field field = code.getClass().getDeclaredField(\"length\");\n-            field.setAccessible(true);\n-            return field.getInt(code);\n-        } catch (InaccessibleObjectException | SecurityException | ReflectiveOperationException e) {\n-            throw new Error(\"can not read field 'length' from class \" + code.getClass(), e);\n+    public int getByteCodeLength(ClassModel cm) {\n+        int length = 0;\n+        for (MethodModel fm : cm.methods()) {\n+            CodeModel code = fm.code().get();\n+            if (code instanceof CodeAttribute ca) {\n+                length += ca.codeLength();\n+            } else {\n+                throw new InaccessibleObjectException(\"Code attribute is not accessible\");\n+            }\n@@ -139,0 +137,1 @@\n+        return length;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/patches\/java.base\/jdk\/internal\/org\/objectweb\/asm\/ClassWriterExt.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"}]}