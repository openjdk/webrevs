{"files":[{"patch":"@@ -26,0 +26,8 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Random;\n+\n@@ -42,6 +50,10 @@\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        cw.setCacheMHandles(false);\n-\n-        cw.visitField(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n-                STATIC_FIELD_NAME,\n-                STATIC_FIELD_SIGNATURE, null, false);\n+    protected byte[] generateCommonData(byte[] bytes) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+        bytes = ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb\n+                .withField(STATIC_FIELD_NAME, ClassDesc.ofDescriptor(STATIC_FIELD_SIGNATURE),\n+                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC)\n+                .withField(INSTANCE_FIELD_NAME, ClassDesc.ofDescriptor(INSTANCE_FIELD_SIGNATURE), ClassFile.ACC_PUBLIC)\n+                .withMethod(INSTANCE_TARGET_METHOD_NAME, MethodTypeDesc.ofDescriptor(INSTANCE_TARGET_METHOD_SIGNATURE),\n+                        ClassFile.ACC_PUBLIC,\n+                        mb -> mb.withCode(\n+                                CodeBuilder::return_))));\n@@ -49,3 +61,2 @@\n-        cw.visitField(Opcodes.ACC_PUBLIC,\n-                INSTANCE_FIELD_NAME,\n-                INSTANCE_FIELD_SIGNATURE, null, false);\n+        bytes = createInitMethod(bytes);\n+        bytes = createTargetMethod(bytes);\n@@ -53,10 +64,1 @@\n-        createInitMethod(cw);\n-        createTargetMethod(cw);\n-\n-        MethodVisitor mv = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC,\n-                INSTANCE_TARGET_METHOD_NAME,\n-                INSTANCE_TARGET_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n-        finishMethodCode(mv);\n+        return bytes;\n@@ -66,3 +68,21 @@\n-    protected void generateCPEntryData(ClassWriter cw, MethodVisitor mw) {\n-        HandleType[] types = HandleType.values();\n-        HandleType type = types[Env.getRNG().nextInt(types.length)];\n+    protected byte[] generateCPEntryData(byte[] bytes) {\n+        ClassModel cm = ClassFile.of().parse(bytes);\n+        bytes = ClassFile.of().transform(cm,\n+                ClassTransform.endHandler(cb -> cb.withMethod(\"generateCPEntryData\",\n+                        MethodTypeDesc.ofDescriptor(\"()[B\"), ClassFile.ACC_PUBLIC,\n+                        mb -> mb.withCode(\n+                                cob -> {\n+                                    DirectMethodHandleDesc.Kind[] kinds = DirectMethodHandleDesc.Kind.values();\n+                                    DirectMethodHandleDesc.Kind kind = kinds[new Random().nextInt(kinds.length)];\n+\n+                                    switch (kind) {\n+                                        case SETTER:\n+                                        case STATIC_SETTER:\n+                                            cob.iconst_0();\n+                                            break;\n+                                        case SPECIAL:\n+                                        case VIRTUAL:\n+                                        case INTERFACE_VIRTUAL:\n+                                            cob.aconst_null();\n+                                            break;\n+                                    }\n@@ -70,11 +90,38 @@\n-        switch (type) {\n-            case PUTFIELD:\n-            case PUTSTATIC:\n-                mw.visitInsn(Opcodes.ICONST_0);\n-                break;\n-            case INVOKESPECIAL:\n-            case INVOKEVIRTUAL:\n-            case INVOKEINTERFACE:\n-                mw.visitInsn(Opcodes.ACONST_NULL);\n-                break;\n-        }\n+                                    MethodHandleDesc handle;\n+                                    switch (kind) {\n+                                        case GETTER:\n+                                        case SETTER:\n+                                            handle = MethodHandleDesc.ofField(kind, ClassDesc.of(fullClassName),\n+                                                    INSTANCE_FIELD_NAME,\n+                                                    ClassDesc.ofDescriptor(INSTANCE_FIELD_SIGNATURE));\n+                                            break;\n+                                        case GETTER:\n+                                        case SETTER:\n+                                            handle = MethodHandleDesc.ofField(kind, ClassDesc.of(fullClassName),\n+                                                    STATIC_FIELD_NAME, ClassDesc.ofDescriptor(STATIC_FIELD_SIGNATURE));\n+                                            break;\n+                                        case CONSTRUCTOR:\n+                                            handle = MethodHandleDesc.ofConstructor(ClassDesc.of(fullClassName),\n+                                                    MethodTypeDesc.ofDescriptor(INIT_METHOD_SIGNATURE));\n+                                            break;\n+                                        case STATIC:\n+                                            handle = MethodHandleDesc.ofMethod(kind, ClassDesc.of(fullClassName),\n+                                                    TARGET_METHOD_NAME,\n+                                                    MethodTypeDesc.ofDescriptor(TARGET_METHOD_SIGNATURE));\n+                                            break;\n+                                        case INTERFACE_VIRTUAL:\n+                                            handle = MethodHandleDesc.ofMethod(kind,\n+                                                    ClassDesc.of(getDummyInterfaceClassName()),\n+                                                    INSTANCE_TARGET_METHOD_NAME,\n+                                                    MethodTypeDesc.ofDescriptor(INSTANCE_TARGET_METHOD_SIGNATURE));\n+                                            break;\n+                                        case SPECIAL:\n+                                        case VIRTUAL:\n+                                            handle = MethodHandleDesc.ofMethod(kind, ClassDesc.of(fullClassName),\n+                                                    INSTANCE_TARGET_METHOD_NAME,\n+                                                    MethodTypeDesc.ofDescriptor(INSTANCE_TARGET_METHOD_SIGNATURE));\n+                                            break;\n+                                        default:\n+                                            throw new Error(\"Unexpected handle type \" + kind);\n+                                    }\n+                                    cob.ldc(handle);\n@@ -82,45 +129,7 @@\n-        Handle handle;\n-        switch (type) {\n-            case GETFIELD:\n-            case PUTFIELD:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INSTANCE_FIELD_NAME,\n-                        INSTANCE_FIELD_SIGNATURE);\n-                break;\n-            case GETSTATIC:\n-            case PUTSTATIC:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        STATIC_FIELD_NAME,\n-                        STATIC_FIELD_SIGNATURE);\n-                break;\n-            case NEWINVOKESPECIAL:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INIT_METHOD_NAME,\n-                        INIT_METHOD_SIGNATURE);\n-                break;\n-            case INVOKESTATIC:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        TARGET_METHOD_NAME,\n-                        TARGET_METHOD_SIGNATURE);\n-                break;\n-            case INVOKEINTERFACE:\n-                handle = new Handle(type.asmTag,\n-                        getDummyInterfaceClassName(),\n-                        INSTANCE_TARGET_METHOD_NAME,\n-                        INSTANCE_TARGET_METHOD_SIGNATURE);\n-                break;\n-            case INVOKESPECIAL:\n-            case INVOKEVIRTUAL:\n-                handle = new Handle(type.asmTag,\n-                        fullClassName,\n-                        INSTANCE_TARGET_METHOD_NAME,\n-                        INSTANCE_TARGET_METHOD_SIGNATURE);\n-                break;\n-            default:\n-                throw new Error(\"Unexpected handle type \" + type);\n-        }\n-        mw.visitLdcInsn(handle);\n+                                    switch (kind) {\n+                                        case GETTER:\n+                                        case STATIC_GETTER:\n+                                            cob.pop();\n+                                            break;\n+                                    }\n+                                }))));\n@@ -128,6 +137,1 @@\n-        switch (type) {\n-            case GETFIELD:\n-            case GETSTATIC:\n-                mw.visitInsn(Opcodes.POP);\n-                break;\n-        }\n+        return bytes;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenCPFullOfMH.java","additions":88,"deletions":84,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -26,0 +26,10 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n@@ -51,1 +61,1 @@\n-    protected static final String JL_CLASSLOADER  = \"java\/lang\/ClassLoader\";\n+    protected static final String JL_CLASSLOADER = \"java\/lang\/ClassLoader\";\n@@ -66,1 +76,2 @@\n-    protected static final String NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE = \"(\" + fd(JLI_METHODHANDLES_LOOKUP) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")V\";\n+    protected static final String NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE = \"(\" + fd(JLI_METHODHANDLES_LOOKUP)\n+            + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")V\";\n@@ -90,0 +101,2 @@\n+    protected static final MethodTypeDesc TEST_METHOD_TYPE_DESC = MethodTypeDesc.of(ClassDesc.ofDescriptor(\"V\"));\n+\n@@ -103,1 +116,2 @@\n-    protected static final String BOOTSTRAP_METHOD_SIGNATURE = \"(\" +  fd(JLI_METHODHANDLES_LOOKUP) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_CALLSITE);\n+    protected static final String BOOTSTRAP_METHOD_SIGNATURE = \"(\" + fd(JLI_METHODHANDLES_LOOKUP) + fd(JL_STRING)\n+            + fd(JLI_METHODTYPE) + \")\" + fd(JLI_CALLSITE);\n@@ -124,3 +138,25 @@\n-    protected static void createLogMsgCode(MethodVisitor mv, String msg) {\n-        mv.visitLdcInsn(msg);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"vm\/mlvm\/share\/Env\", \"traceVerbose\", \"(Ljava\/lang\/String;)V\");\n+\n+    \/\/ If set_cause is true it expects a Throwable (the cause) to be on top of the stack when called.\n+    protected static void createThrowRuntimeExceptionCodeHelper(ClassModel cm, String msg, boolean set_cause) {\n+\n+        ClassFile.of().transform(cm,\n+                ClassTransform.endHandler(cb -> cb.withMethod(\"throwRuntimeException\",\n+                        MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;Z)V\"),\n+                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                        mb -> mb.withCode(\n+                                cob -> {\n+                                    cob.new_(ClassDesc.ofInternalName(JL_RUNTIMEEXCEPTION))\n+                                            .dup()\n+                                            .ldc(msg)\n+                                            .invokespecial(ClassDesc.ofInternalName(JL_RUNTIMEEXCEPTION),\n+                                                    INIT_METHOD_NAME,\n+                                                    MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_STRING) + \")V\"));\n+                                    if (set_cause) {\n+                                        cob.dup_x1()\n+                                                .aload(0)\n+                                                .invokevirtual(ClassDesc.ofInternalName(JL_THROWABLE), \"initCause\",\n+                                                        MethodTypeDesc.ofDescriptor(\n+                                                                \"(\" + fd(JL_THROWABLE) + \")\" + fd(JL_THROWABLE)));\n+                                    }\n+                                    cob.athrow();\n+                                }))));\n@@ -129,2 +165,13 @@\n-    protected static void createThrowRuntimeExceptionCode(MethodVisitor mv, String msg) {\n-        createThrowRuntimeExceptionCodeHelper(mv, msg, false);\n+    protected static void createThrowRuntimeExceptionMethod(ClassModel cm, boolean isStatic, String methodName,\n+            String methodSignature) {\n+        ClassFile.of().transform(cm, ClassTransform.endHandler(clb -> clb.withMethod(methodName,\n+                MethodTypeDesc.ofDescriptor(methodSignature),\n+                ClassFile.ACC_PUBLIC | (isStatic ? ClassFile.ACC_STATIC : 0),\n+                mb -> mb.withCode(cb -> cb\n+                        .aload(cob.receiverSlot())\n+                        .ldc(\"Method \" + methodName + methodSignature + \" should not be called!\")\n+                        .invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/GenFullCP\"), \"createThrowRuntimeExceptionCode\",\n+                                MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;)V\"))\n+                        .return_()))));\n+\n+        createThrowRuntimeExceptionCode(cm, \"Method \" + methodName + methodSignature + \" should not be called!\", false);\n@@ -133,3 +180,1 @@\n-    \/\/ Expects a throwable (the cause) to be on top of the stack when called.\n-    protected static void createThrowRuntimeExceptionCodeWithCause(MethodVisitor mv, String msg) {\n-        createThrowRuntimeExceptionCodeHelper(mv, msg, true);\n+    protected byte[] createClassInitMethod(byte[] bytes) {\n@@ -138,13 +183,14 @@\n-    \/\/ If set_cause is true it expects a Throwable (the cause) to be on top of the stack when called.\n-    protected static void createThrowRuntimeExceptionCodeHelper(MethodVisitor mv, String msg, boolean set_cause) {\n-        mv.visitTypeInsn(Opcodes.NEW, JL_RUNTIMEEXCEPTION);\n-        mv.visitInsn(Opcodes.DUP);\n-        mv.visitLdcInsn(msg);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, JL_RUNTIMEEXCEPTION,\n-                INIT_METHOD_NAME, \"(\" + fd(JL_STRING) + \")V\");\n-        if (set_cause) {\n-          mv.visitInsn(Opcodes.SWAP);\n-          mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JL_RUNTIMEEXCEPTION,\n-                  \"initCause\", \"(\" + fd(JL_THROWABLE) + \")\"+ fd(JL_THROWABLE));\n-        }\n-        mv.visitInsn(Opcodes.ATHROW);\n+    protected byte[] createInitMethod(byte[] bytes) {\n+        return ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                ClassTransform.endHandler(clb -> clb.withMethod(INIT_METHOD_NAME,\n+                        MethodTypeDesc.ofDescriptor(VOID_NO_ARG_METHOD_SIGNATURE),\n+                        ClassFile.ACC_PUBLIC,\n+                        mb -> mb.withCode(cb -> cb\n+                                .aload(cb.receiverSlot())\n+                                .aload(cb.parameterSlot(0))\n+                                .ldc(fullClassName + \" constructor called\")\n+                                .invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/Env\"), \"traceVerbose\",\n+                                        MethodTypeDesc.ofDescriptor(\"Ljava\/lang\/String;)V\"))\n+                                .invokespecial(ClassDesc.ofInternalName(PARENT_CLASS_NAME), INIT_METHOD_NAME,\n+                                        MethodTypeDesc.ofDescriptor(VOID_NO_ARG_METHOD_SIGNATURE))\n+                                .return_()))));\n@@ -153,6 +199,12 @@\n-    protected static void createThrowRuntimeExceptionMethod(ClassWriter cw, boolean isStatic, String methodName, String methodSignature) {\n-        MethodVisitor mv = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC | (isStatic ? Opcodes.ACC_STATIC : 0),\n-                methodName, methodSignature,\n-                null,\n-                new String[0]);\n+    protected byte[] createTargetMethod(byte[] bytes) {\n+        return ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                ClassTransform.endHandler(\n+                        cb -> cb.withMethod(TARGET_METHOD_NAME, MethodTypeDesc.ofDescriptor(TARGET_METHOD_SIGNATURE),\n+                                ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                mb -> mb.withCode(\n+                                        CodeBuilder -> CodeBuilder\n+                                                .ldc(fullClassName + \" constructor called\")\n+                                                .invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/Env\"), \"traceVerbose\",\n+                                                        MethodTypeDesc.ofDescriptor(\"Ljava\/lang\/String;)V\"))\n+                                                .return_()))));\n+    }\n@@ -160,1 +212,3 @@\n-        createThrowRuntimeExceptionCode(mv, \"Method \" + methodName + methodSignature + \" should not be called!\");\n+    protected byte[] createBootstrapMethod(byte[] bytes) {\n+        return createBootstrapMethod(bytes, true, BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_SIGNATURE);\n+    }\n@@ -162,2 +216,25 @@\n-        mv.visitMaxs(-1,  -1);\n-        mv.visitEnd();\n+    protected byte[] createBootstrapMethod(byte[] bytes, boolean isStatic, String methodName, String methodSignature) {\n+        int argShift = isStatic ? 0 : 1;\n+\n+        return ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                ClassTransform.endHandler(cb -> cb.withMethod(methodName, MethodTypeDesc.ofDescriptor(methodSignature),\n+                        ClassFile.ACC_PUBLIC | (isStatic ? ClassFile.ACC_STATIC : 0),\n+                        mb -> mb.withCode(\n+                                CodeBuilder -> CodeBuilder\n+                                        .ldc(fullClassName + \".\" + BOOTSTRAP_METHOD_NAME + BOOTSTRAP_METHOD_SIGNATURE\n+                                                + \" called\")\n+                                        .invokestatic(ClassDesc.of(\"vm\/mlvm\/share\/Env\"), \"traceVerbose\",\n+                                                MethodTypeDesc.ofDescriptor(\"Ljava\/lang\/String;)V\"))\n+                                        .new_(ClassDesc.ofInternalName(JLI_CONSTANTCALLSITE))\n+                                        .dup()\n+                                        .aload(0 + argShift)\n+                                        .ldc(ClassDesc.ofDescriptor(fullClassName))\n+                                        .aload(1 + argShift)\n+                                        .aload(2 + argShift)\n+                                        .invokevirtual(ClassDesc.ofInternalName(JLI_METHODHANDLES_LOOKUP), \"findStatic\",\n+                                                MethodTypeDesc.ofDescriptor(\"(\" + fd(JL_CLASS) + fd(JL_STRING)\n+                                                        + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE)))\n+                                        .invokespecial(ClassDesc.ofInternalName(JLI_CONSTANTCALLSITE),\n+                                                INIT_METHOD_NAME,\n+                                                MethodTypeDesc.ofDescriptor(\"(\" + fd(JLI_METHODHANDLE) + \")V\"))\n+                                        .areturn()))));\n@@ -176,61 +253,0 @@\n-    protected void createClassInitMethod(ClassWriter cw) {\n-    }\n-\n-    protected void createInitMethod(ClassWriter cw) {\n-        MethodVisitor mv = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC,\n-                INIT_METHOD_NAME, INIT_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n-\n-        mv.visitIntInsn(Opcodes.ALOAD, 0);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL,\n-                PARENT_CLASS_NAME,\n-                INIT_METHOD_NAME, INIT_METHOD_SIGNATURE);\n-\n-        createLogMsgCode(mv, fullClassName + \" constructor called\");\n-\n-        finishMethodCode(mv);\n-    }\n-\n-    protected void createTargetMethod(ClassWriter cw) {\n-        MethodVisitor mv = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n-                TARGET_METHOD_NAME, TARGET_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n-\n-        createLogMsgCode(mv, fullClassName + \".\" + TARGET_METHOD_NAME + TARGET_METHOD_SIGNATURE + \" called\");\n-\n-        finishMethodCode(mv);\n-    }\n-\n-    protected void createBootstrapMethod(ClassWriter cw) {\n-         createBootstrapMethod(cw, true, BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_SIGNATURE);\n-    }\n-\n-    protected void createBootstrapMethod(ClassWriter cw, boolean isStatic, String methodName, String methodSignature) {\n-        MethodVisitor mv = cw.visitMethod(\n-                (isStatic ? Opcodes.ACC_STATIC : 0) | Opcodes.ACC_PUBLIC,\n-                methodName, methodSignature,\n-                null, new String[0]);\n-\n-        createLogMsgCode(mv, fullClassName + \".\" + BOOTSTRAP_METHOD_NAME + BOOTSTRAP_METHOD_SIGNATURE + \" called\");\n-\n-        int argShift = isStatic ? 0 : 1;\n-\n-        mv.visitTypeInsn(Opcodes.NEW, JLI_CONSTANTCALLSITE);\n-        mv.visitInsn(Opcodes.DUP);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0 + argShift);\n-        mv.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mv.visitVarInsn(Opcodes.ALOAD, 1 + argShift);\n-        mv.visitVarInsn(Opcodes.ALOAD, 2 + argShift);\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,\n-                JLI_METHODHANDLES_LOOKUP, \"findStatic\",\n-                \"(\" + fd(JL_CLASS) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE));\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, JLI_CONSTANTCALLSITE,\n-                INIT_METHOD_NAME, \"(\" + fd(JLI_METHODHANDLE) + \")V\");\n-\n-        finishMethodCode(mv, Opcodes.ARETURN);\n-    }\n-\n@@ -241,1 +257,1 @@\n-        ClassWriterExt cw = new ClassWriterExt(\/*ClassWriter.COMPUTE_FRAMES |*\/ ClassWriter.COMPUTE_MAXS);\n+        ClassWriterExt cw = new ClassWriterExt(\/* ClassWriter.COMPUTE_FRAMES | *\/ ClassWriter.COMPUTE_MAXS);\n@@ -245,1 +261,0 @@\n-        cw.visit(CLASSFILE_VERSION, Opcodes.ACC_PUBLIC, fullClassName, null, PARENT_CLASS_NAME, interfaces);\n@@ -247,10 +262,21 @@\n-        generateCommonData(cw);\n-\n-        MethodVisitor mainMV = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n-                MAIN_METHOD_NAME, MAIN_METHOD_SIGNATURE,\n-                null, new String[0]);\n-\n-        mainMV.visitTypeInsn(Opcodes.NEW, fullClassName);\n-        mainMV.visitInsn(Opcodes.DUP);\n-        mainMV.visitMethodInsn(Opcodes.INVOKESPECIAL, fullClassName, INIT_METHOD_NAME, INIT_METHOD_SIGNATURE);\n+        byte[] bytes = ClassFile.of().build(ClassDesc.ofInternalName(fullClassName), classBuilder -> {\n+            classBuilder.withFlags(ClassFile.ACC_PUBLIC | ClassFile.ACC_SUPER)\n+                    .withInterfaceSymbols(ClassDesc.ofInternalName(interfaces[0]))\n+                    .withSuperclass(ClassDesc.ofInternalName(PARENT_CLASS_NAME))\n+                    .withVersion(CLASSFILE_VERSION, 0);\n+        });\n+\n+        bytes = generateCommonData(bytes);\n+\n+        bytes = ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                ClassTransform.endHandler(cb -> cb.withFlags(ClassFile.ACC_PUBLIC | ClassFile.ACC_SUPER)\n+                        .withMethod(MAIN_METHOD_NAME, MethodTypeDesc.ofDescriptor(MAIN_METHOD_SIGNATURE),\n+                                ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                mb -> mb.withCode(\n+                                        codeBuilder -> codeBuilder\n+                                                .new_(ClassDesc.ofInternalName(fullClassName))\n+                                                .dup()\n+                                                .invokespecial(ClassDesc.ofInternalName(fullClassName),\n+                                                        INIT_METHOD_NAME,\n+                                                        MethodTypeDesc.of(ConstantDescs.CD_void))\n+                                                .return_()))));\n@@ -265,4 +291,5 @@\n-            MethodVisitor mw = cw.visitMethod(\n-                    Opcodes.ACC_PUBLIC,\n-                    methodName, TEST_METHOD_SIGNATURE,\n-                    null, new String[0]);\n+            bytes = ClassFile.of().transform(ClassFile.of().parse(bytes),\n+                    ClassTransform.endHandler(cb -> cb.withMethod(methodName, TEST_METHOD_TYPE_DESC,\n+                            ClassFile.ACC_PUBLIC,\n+                            mb -> mb.withCode(\n+                                    CodeBuilder::return_))));\n@@ -270,1 +297,1 @@\n-            generateTestMethodProlog(mw);\n+            bytes = generateTestMethodProlog(bytes);\n@@ -273,2 +300,2 @@\n-            while (constCount < CP_CONST_COUNT && cw.getBytecodeLength(mw) < MAX_METHOD_SIZE) {\n-                generateCPEntryData(cw, mw);\n+            while (constCount < CP_CONST_COUNT && cw.getBytecodeLength(ClassFile.of().parse(bytes)) < MAX_METHOD_SIZE) {\n+                bytes = generateCPEntryData(bytes);\n@@ -278,5 +305,1 @@\n-            generateTestMethodEpilog(mw);\n-\n-            mw.visitMaxs(-1, -1);\n-            mw.visitEnd();\n-\n+            bytes = generateTestMethodEpilog(bytes);\n@@ -284,2 +307,2 @@\n-                          + constCount + \" constants in CP, \"\n-                          + cw.getBytecodeLength(mw) + \" bytes of code\");\n+                    + constCount + \" constants in CP, \"\n+                    + cw.getBytecodeLength(ClassFile.of().parse(bytes)) + \" bytes of code\");\n@@ -296,1 +319,0 @@\n-        cw.visitEnd();\n@@ -300,5 +322,6 @@\n-    protected void generateCommonData(ClassWriterExt cw) {\n-        createClassInitMethod(cw);\n-        createInitMethod(cw);\n-        createTargetMethod(cw);\n-        createBootstrapMethod(cw);\n+    protected byte[] generateCommonData(byte[] bytes) {\n+        bytes = createClassInitMethod(bytes);\n+        bytes = createInitMethod(bytes);\n+        bytes = createTargetMethod(bytes);\n+        bytes = createBootstrapMethod(bytes);\n+        return bytes;\n@@ -307,1 +330,1 @@\n-    protected void generateTestMethodProlog(MethodVisitor mw) {\n+    protected byte[] generateTestMethodProlog(byte[] bytes) {\n@@ -310,1 +333,1 @@\n-    protected abstract void generateCPEntryData(ClassWriter cw, MethodVisitor mw);\n+    protected abstract byte[] generateCPEntryData(byte[] bytes);\n@@ -312,2 +335,4 @@\n-    protected void generateTestMethodEpilog(MethodVisitor mw) {\n-        mw.visitInsn(Opcodes.RETURN);\n+    protected byte[] generateTestMethodEpilog(byte[] bytes) {\n+        return ClassFile.of().transform(cm, ClassTransform.endHandler(\n+                cb -> cb.withMethod(\"testMethodEpilog\", MethodTypeDesc.ofDescriptor(\"()V\"), ClassFile.ACC_PUBLIC,\n+                        mb -> mb.withCode(CodeBuilder::return_))));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenFullCP.java","additions":155,"deletions":130,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -123,15 +124,9 @@\n-    public int getBytecodeLength(MethodVisitor mv) {\n-        ByteVector code;\n-        try {\n-            java.lang.reflect.Field field = mv.getClass().getDeclaredField(\"code\");\n-            field.setAccessible(true);\n-            code = (ByteVector) field.get(mv);\n-        } catch (InaccessibleObjectException | SecurityException | ReflectiveOperationException e) {\n-            throw new Error(\"can not read field 'code' from class \" + mv.getClass(), e);\n-        }\n-        try {\n-            java.lang.reflect.Field field = code.getClass().getDeclaredField(\"length\");\n-            field.setAccessible(true);\n-            return field.getInt(code);\n-        } catch (InaccessibleObjectException | SecurityException | ReflectiveOperationException e) {\n-            throw new Error(\"can not read field 'length' from class \" + code.getClass(), e);\n+    public int getByteCodeLength(ClassModel cm) {\n+        int length = 0;\n+        for (MethodModel fm : cm.methods()) {\n+            CodeModel code = fm.code().get();\n+            if (code instanceof CodeAttribute ca) {\n+                length += ca.codeLength();\n+            } else {\n+                throw new InaccessibleObjectException(\"Code attribute is not accessible\");\n+            }\n@@ -139,0 +134,1 @@\n+        return length;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/patches\/java.base\/jdk\/internal\/org\/objectweb\/asm\/ClassWriterExt.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"}]}