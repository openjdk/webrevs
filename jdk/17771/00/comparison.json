{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"jfr\/recorder\/service\/jfrRecorderService.hpp\"\n@@ -351,1 +352,2 @@\n-  LeakProfiler::emit_events(cutoff_ticks, emit_all == JNI_TRUE, skip_bfs == JNI_TRUE);\n+  JfrRecorderService service;\n+  service.emit_leakprofiler_events(cutoff_ticks, emit_all == JNI_TRUE, skip_bfs == JNI_TRUE);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,0 +208,9 @@\n+static void add_to_leakp_set(const ObjectSample* sample) {\n+  assert(sample != nullptr, \"invariant\");\n+  oop object = sample->object();\n+  if (object == nullptr) {\n+    return;\n+  }\n+  JfrTraceId::load_leakp(object->klass());\n+}\n+\n@@ -222,0 +231,1 @@\n+      add_to_leakp_set(sample);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n@@ -39,1 +40,1 @@\n-  return _object.resolve();\n+  return is_dead() ? nullptr :_object.resolve();\n@@ -51,0 +52,1 @@\n+  assert(object != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,0 @@\n-    return artifact_id(ptr);\n@@ -156,1 +155,1 @@\n-  if (previous_epoch()) {\n+  if (unloading() || previous_epoch()) {\n@@ -256,1 +255,5 @@\n-    return pkg != nullptr ? pkg->module() : nullptr;\n+    if (pkg == nullptr) {\n+      return nullptr;\n+    }\n+    assert(current_epoch() ? IS_SERIALIZED(pkg) : true, \"invariant\");\n+    return pkg->module();\n@@ -275,1 +278,5 @@\n-    return mod != nullptr ? mod->loader_data() : nullptr;\n+    if (mod == nullptr) {\n+      return nullptr;\n+    }\n+    assert(current_epoch() ? IS_SERIALIZED(mod) : true, \"invariant\");\n+    return mod->loader_data();\n@@ -286,12 +293,1 @@\n-    return _class_unload ? _artifacts->should_do_unloading_artifact(value) : IS_NOT_SERIALIZED(value);\n-  }\n-};\n-\n-template <>\n-class SerializePredicate<const Klass*> {\n-  bool _class_unload;\n-public:\n-  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n-  bool operator()(const Klass* klass) {\n-    assert(klass != nullptr, \"invariant\");\n-    return _class_unload ? true : IS_NOT_SERIALIZED(klass);\n+    return _class_unload ? true : IS_NOT_SERIALIZED(value);\n@@ -355,2 +351,5 @@\n-  if (!leakp) {\n-    set_serialized(klass);\n+  if (leakp) {\n+    assert(IS_LEAKP(klass), \"invariant\");\n+    CLEAR_LEAKP(klass);\n+    assert(IS_NOT_LEAKP(klass), \"invariant\");\n+    return;\n@@ -358,0 +357,3 @@\n+  assert(used(klass), \"invariant\");\n+  assert(unloading() ? true : IS_NOT_SERIALIZED(klass), \"invariant\");\n+  set_serialized(klass);\n@@ -361,1 +363,1 @@\n-  return klass != nullptr && (leakp || IS_NOT_SERIALIZED(klass));\n+  return klass != nullptr && (leakp ? IS_LEAKP(klass) : unloading() ? true : IS_NOT_SERIALIZED(klass));\n@@ -376,2 +378,2 @@\n-  KlassPtr mod_klass = get_module_cld_klass(klass, leakp);\n-  if (should_write_cld_klass(mod_klass, leakp)) {\n+  KlassPtr mod_cld_klass = get_module_cld_klass(klass, leakp);\n+  if (should_write_cld_klass(mod_cld_klass, leakp)) {\n@@ -379,1 +381,1 @@\n-    write_klass(writer, mod_klass, leakp, elements);\n+    write_klass(writer, mod_cld_klass, leakp, elements);\n@@ -401,1 +403,0 @@\n-  CLEAR_LEAKP(klass);\n@@ -981,9 +982,6 @@\n-  MethodIteratorHost(JfrCheckpointWriter* writer,\n-                     bool current_epoch = false,\n-                     bool class_unload = false,\n-                     bool skip_header = false) :\n-    _method_cb(writer, class_unload, skip_header),\n-    _klass_cb(writer, class_unload, skip_header),\n-    _klass_used_predicate(current_epoch),\n-    _method_used_predicate(current_epoch),\n-    _method_flag_predicate(current_epoch) {}\n+  MethodIteratorHost(JfrCheckpointWriter* writer) :\n+    _method_cb(writer, unloading(), false),\n+    _klass_cb(writer, unloading(), false),\n+    _klass_used_predicate(current_epoch()),\n+    _method_used_predicate(current_epoch()),\n+    _method_flag_predicate(current_epoch()) {}\n@@ -1040,1 +1038,0 @@\n-typedef MethodIteratorHost<LeakMethodWriterImpl, KlassCallbackStub, true> LeakMethodWriter;\n@@ -1047,1 +1044,1 @@\n-  LeakMethodWriter lpmw(_leakp_writer, current_epoch(), unloading());\n+  LeakMethodWriter lpmw(_leakp_writer);\n@@ -1055,1 +1052,1 @@\n-  MethodWriter mw(_writer, current_epoch(), unloading());\n+  MethodWriter mw(_writer);\n@@ -1068,1 +1065,1 @@\n-  MethodWriter mw(_writer, current_epoch(), unloading());\n+  MethodWriter mw(_writer);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":34,"deletions":37,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,4 +57,0 @@\n-\n-  if (class_unload) {\n-    _unloading_set = new GrowableArray<const Klass*>(initial_klass_list_size);\n-  }\n@@ -120,10 +116,0 @@\n-bool JfrArtifactSet::should_do_unloading_artifact(const void* ptr) {\n-  assert(ptr != nullptr, \"invariant\");\n-  assert(_class_unload, \"invariant\");\n-  assert(_unloading_set != nullptr, \"invariant\");\n-  \/\/ The incoming pointers are of all kinds of different types.\n-  \/\/ However, we are only interested in set membership.\n-  \/\/ Treat them uniformly as const Klass* for simplicity and code reuse.\n-  return not_in_set(_unloading_set, static_cast<const Klass*>(ptr));\n-}\n-\n@@ -132,0 +118,1 @@\n+  assert(IS_SERIALIZED(k), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,1 @@\n+    assert(IS_SERIALIZED(klass), \"invariant\");\n@@ -133,1 +134,1 @@\n-public:\n+ public:\n@@ -204,1 +205,0 @@\n-  GrowableArray<const Klass*>* _unloading_set;\n@@ -232,1 +232,0 @@\n-  bool should_do_unloading_artifact(const void* ptr);\n@@ -235,14 +234,0 @@\n-  template <typename Functor>\n-  void iterate_klasses(Functor& functor) const {\n-    for (int i = 0; i < _klass_list->length(); ++i) {\n-      if (!functor(_klass_list->at(i))) {\n-        return;\n-      }\n-    }\n-    for (int i = 0; i < _klass_loader_set->length(); ++i) {\n-      if (!functor(_klass_loader_set->at(i))) {\n-        return;\n-      }\n-    }\n-  }\n-\n@@ -264,0 +249,18 @@\n+  template <typename Functor>\n+  void iterate_klasses(Functor& functor) const {\n+    if (iterate(functor, _klass_list)) {\n+      iterate(functor, _klass_loader_set);\n+    }\n+  }\n+\n+ private:\n+  template <typename Functor>\n+  bool iterate(Functor& functor, GrowableArray<const Klass*>* list) const {\n+    assert(list != nullptr, \"invariant\");\n+    for (int i = 0; i < list->length(); ++i) {\n+      if (!functor(list->at(i))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,1 @@\n+  static traceid load_leakp(const Klass* klass); \/\/ leak profiler\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,4 @@\n+inline traceid JfrTraceId::load_leakp(const Klass* klass) {\n+  return JfrTraceIdLoadBarrier::load_leakp(klass);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,1 @@\n+  static traceid load_leakp(const Klass* klass); \/\/ leak profiler\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-  assert(USED_THIS_EPOCH(klass), \"invariant\");\n+  assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), \"invariant\");\n@@ -151,0 +151,7 @@\n+inline traceid JfrTraceIdLoadBarrier::load_leakp(const Klass* klass) {\n+  assert(klass != nullptr, \"invariant\");\n+  load(klass); \/\/ Ensure tagged and enqueued.\n+  SET_LEAKP(klass);\n+  return TRACE_ID(klass);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -694,0 +694,12 @@\n+\n+void JfrRecorderService::emit_leakprofiler_events(int64_t cutoff_ticks, bool emit_all, bool skip_bfs) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(JavaThread::current()));\n+  \/\/ Take the rotation lock to exclude flush() during event emits. This is because event emit\n+  \/\/ also creates a number checkpoint events. Those checkpoint events require a future typeset checkpoint\n+  \/\/ event for completeness, i.e. to be generated before being flushed to a segment.\n+  \/\/ The upcoming flush() or rotation() after event emit completes this typeset checkpoint\n+  \/\/ and serializes all event emit checkpoint events to the same segment.\n+  JfrRotationLock lock;\n+  LeakProfiler::emit_events(cutoff_ticks, emit_all, skip_bfs);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+  void emit_leakprofiler_events(int64_t cutoff_ticks, bool emit_all, bool skip_bfs);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,4 @@\n+  }                                                \\\n+  void copy_trace_flags(uint8_t src_flags) const { \\\n+    uint8_t flags = *_trace_flags.flags_addr();    \\\n+    _trace_flags.set_flags(flags | src_flags);     \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTraceIdExtension.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+#include \"oops\/method.hpp\"\n@@ -67,0 +68,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -1174,0 +1176,1 @@\n+      JFR_ONLY(k_new_method->copy_trace_flags(*k_old_method->trace_flags_addr());)\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,2 +80,1 @@\n-                \/\/ Disable assertion until JDK-8323883 is fixed\n-                \/\/ assert false : msg;\n+                assert false : msg;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ConstantMap.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}