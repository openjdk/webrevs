{"files":[{"patch":"@@ -228,0 +228,1 @@\n+        private volatile boolean closed;\n@@ -294,0 +295,9 @@\n+        \/**\n+         * Throws an IOException if the ModuleReader is closed.\n+         *\/\n+        private void ensureOpen() throws IOException {\n+            if (closed) {\n+                throw new IOException(\"ModuleReader is closed\");\n+            }\n+        }\n+\n@@ -313,1 +323,1 @@\n-\n+            assert !closed : \"module reader is closed\";\n@@ -357,0 +367,1 @@\n+            ensureOpen();\n@@ -368,0 +379,1 @@\n+            ensureOpen();\n@@ -378,0 +390,1 @@\n+            ensureOpen();\n@@ -401,0 +414,1 @@\n+            ensureOpen();\n@@ -410,0 +424,1 @@\n+            closed = true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModulePatcher.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8372787\n+ * @summary verify the behaviour of ModuleReader when using --patch-module\n+ * @comment patch the java.base module with a test specific resource\n+ * @compile\/module=java.base java\/lang\/PatchedFoo.java\n+ * @run junit\/othervm ${test.main.class}\n+ *\/\n+class PatchedModuleReaderTest {\n+\n+    private static ModuleReference patchedModuleRef;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        patchedModuleRef = ModuleFinder.ofSystem()\n+                .find(\"java.base\")\n+                .orElseThrow();\n+    }\n+\n+    \/*\n+     * Verifies that the resource that was patched into a module\n+     * is found by the ModuleReader.\n+     *\/\n+    @Test\n+    void testResourceFound() throws Exception {\n+        try (ModuleReader reader = patchedModuleRef.open()) {\n+            String resourceName = \"java\/lang\/PatchedFoo.class\";\n+            Optional<URI> res = reader.find(resourceName);\n+            assertTrue(res.isPresent(), resourceName + \" is missing in \"\n+                    + patchedModuleRef.descriptor().name() + \" module\");\n+            URI uri = res.get();\n+            assertEquals(\"file\", uri.getScheme(),\n+                    \"unexpected scheme in resource URI \" + uri);\n+            assertTrue(uri.getPath().endsWith(resourceName),\n+                    \"unexpected path component \" + uri.getPath()\n+                            + \" in resource URI \" + uri);\n+\n+        }\n+    }\n+\n+    \/*\n+     * Verifies the ModuleReader against a resource which isn't\n+     * expected to be part of the patched module.\n+     *\/\n+    @Test\n+    void testResourceNotFound() throws Exception {\n+        try (ModuleReader reader = patchedModuleRef.open()) {\n+            String nonExistentResource = \"foo\/bar\/NonExistent.class\";\n+            Optional<URI> res = reader.find(nonExistentResource);\n+            assertTrue(res.isEmpty(), \"unexpected resource \" + nonExistentResource\n+                    + \" in \" + patchedModuleRef.descriptor().name() + \" module\");\n+        }\n+    }\n+\n+    \/*\n+     * This test opens a ModuleReader for a patched module, accumulates\n+     * the Stream of resources from that ModuleReader and then closes that\n+     * ModuleReader. It then verifies that the closed ModuleReader\n+     * throws the specified IOException whenever it is used for subsequent\n+     * operations on the Stream of resources.\n+     *\/\n+    @Test\n+    void testIOExceptionAfterClose() throws Exception {\n+        ModuleReader reader;\n+        Stream<String> resources;\n+        try (var _ = reader = patchedModuleRef.open()) {\n+            \/\/ hold on to the available resources, to test them after the\n+            \/\/ ModuleReader is closed\n+            resources = reader.list();\n+        } \/\/ close the ModuleReader\n+\n+        \/\/ verify IOException is thrown by the closed ModuleReader\n+        resources.forEach(rn -> {\n+            assertThrows(IOException.class, () -> reader.read(rn),\n+                    \"ModuleReader.read(String)\");\n+            assertThrows(IOException.class, () -> reader.open(rn),\n+                    \"ModuleReader.open(String)\");\n+            assertThrows(IOException.class, () -> reader.find(rn),\n+                    \"ModuleReader.find(String)\");\n+        });\n+\n+        \/\/ repeat the test for a non-existent resource\n+        String nonExistentResource = \"foo\/bar\/NonExistent.class\";\n+        assertThrows(IOException.class, () -> reader.read(nonExistentResource),\n+                \"ModuleReader.read(String)\");\n+        assertThrows(IOException.class, () -> reader.open(nonExistentResource),\n+                \"ModuleReader.open(String)\");\n+        assertThrows(IOException.class, () -> reader.find(nonExistentResource),\n+                \"ModuleReader.find(String)\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/module\/ModuleReader\/patched\/PatchedModuleReaderTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -22,1 +22,0 @@\n- *\n@@ -24,0 +23,1 @@\n+package java.lang;\n@@ -25,2 +25,1 @@\n-module com.test {\n-  exports com.test;\n+public class PatchedFoo {\n","filename":"test\/jdk\/java\/lang\/module\/ModuleReader\/patched\/java.base\/java\/lang\/PatchedFoo.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/modules\/com.test\/module-info.java","status":"copied"}]}