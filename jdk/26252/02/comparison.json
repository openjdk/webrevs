{"files":[{"patch":"@@ -98,0 +98,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -109,0 +111,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -119,0 +123,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -129,0 +135,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -212,0 +212,2 @@\n+     * @throws IllegalArgumentException if the number of associated values\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -676,0 +676,2 @@\n+     * @throws IllegalArgumentException if the length of array exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -689,0 +691,2 @@\n+     * @throws IllegalArgumentException if the length of array exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -702,1 +706,2 @@\n-     *         an enum constant, or an array of one of these.\n+     *         an enum constant, or an array of one of these; or any array has\n+     *         length over the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -134,0 +134,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -145,0 +147,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -156,1 +160,3 @@\n-     * @throws IllegalArgumentException if any element of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -168,1 +174,3 @@\n-     * @throws IllegalArgumentException if any element of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2405,2 +2405,2 @@\n-     * {@code slot} exceeds {@code 255} or {@code val} exceeds the range of\n-     * {@link TypeKind#BYTE byte}.\n+     * {@code slot} exceeds the limit of {@link java.lang.classfile##u1 u1} or\n+     * {@code val} exceeds the range of {@link TypeKind#BYTE byte}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -65,0 +67,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -73,1 +77,3 @@\n-     * @throws IllegalArgumentException if any of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -82,1 +88,3 @@\n-     * @throws IllegalArgumentException if any of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Interfaces.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -185,0 +185,2 @@\n+     * @throws IllegalArgumentException if the size of {@code targetPath}\n+     *         exceeds the limit of {@link java.lang.classfile##u1 u1}\n@@ -489,0 +491,2 @@\n+         * @throws IllegalArgumentException if the size of the list of targets\n+         *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -497,0 +501,2 @@\n+         * @throws IllegalArgumentException if the size of the list of targets\n+         *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -506,0 +512,2 @@\n+         * @throws IllegalArgumentException if the size of the list of targets\n+         *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -805,1 +813,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+     * @throws IllegalArgumentException if the number of ranges exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CharacterRangeTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -88,0 +90,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -96,0 +100,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -104,0 +110,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ExceptionsAttribute.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -76,0 +78,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassesAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTypeTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}\n@@ -79,0 +81,2 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParametersAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -174,1 +174,2 @@\n-     *         java.lang.classfile##u2 u2}\n+     *         java.lang.classfile##u2 u2} or any of the collections has a size\n+     *         over the limit of {@link java.lang.classfile##u2 u2}\n@@ -191,0 +192,3 @@\n+     * @throws IllegalArgumentException if the information from the handler exceeds\n+     *         the {@code class} file format limit, such as a list with size\n+     *         over the limit of {@link java.lang.classfile##u2 u2}\n@@ -299,0 +303,2 @@\n+         * @throws IllegalArgumentException if the number of modules exceeds\n+         *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -310,1 +316,3 @@\n-         *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+         *         {@link AccessFlag.Location#MODULE_EXPORTS} location or the\n+         *         number of modules exceeds the limit of {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -336,0 +344,2 @@\n+         * @throws IllegalArgumentException if the number of modules exceeds the\n+         *         limit of {@link java.lang.classfile##u2 u2}\n@@ -352,1 +362,3 @@\n-         *         {@link AccessFlag.Location#MODULE_OPENS} location\n+         *         {@link AccessFlag.Location#MODULE_OPENS} location, or if the\n+         *         number of modules exceeds the limit of {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -394,1 +406,4 @@\n-         * @throws IllegalArgumentException if {@code service} or any of the {@code implClasses} represents a primitive type\n+         * @throws IllegalArgumentException if {@code service} or any of the\n+         *         {@code implClasses} represents a primitive type, or the\n+         *         number of implementations exceeds the limit of {@link\n+         *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -107,1 +107,2 @@\n-     *         java.lang.classfile##u2 u2}\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -122,1 +123,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -137,1 +140,2 @@\n-     *         java.lang.classfile##u2 u2}\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -153,1 +157,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -169,1 +175,2 @@\n-     *         java.lang.classfile##u2 u2}\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -186,1 +193,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -201,1 +210,2 @@\n-     *         java.lang.classfile##u2 u2}\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -217,1 +227,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleExportInfo.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -109,0 +111,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -119,0 +123,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -129,0 +135,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleHashesAttribute.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-     *         java.lang.classfile##u2 u2}\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -128,1 +129,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -143,1 +145,2 @@\n-     *         java.lang.classfile##u2 u2}\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -159,1 +162,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -174,1 +178,2 @@\n-     *         java.lang.classfile##u2 u2}\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -190,1 +195,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -204,1 +210,2 @@\n-     *         java.lang.classfile##u2 u2}\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -219,1 +226,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleOpenInfo.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -85,0 +87,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -93,0 +97,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -105,0 +111,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModulePackagesAttribute.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+     * @throws IllegalArgumentException if the number of implementations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -77,0 +79,2 @@\n+     * @throws IllegalArgumentException if the number of implementations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -88,1 +92,2 @@\n-     *         providesWith} represents a primitive type\n+     *         providesWith} represents a primitive type, or the number of\n+     *         implementations exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -100,1 +105,2 @@\n-     *         providesWith} represents a primitive type\n+     *         providesWith} represents a primitive type, or the number of\n+     *         implementations exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleProvideInfo.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+     * @throws IllegalArgumentException if the number of member classes exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -84,0 +86,2 @@\n+     * @throws IllegalArgumentException if the number of member classes exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -93,1 +97,3 @@\n-     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive\n+     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive,\n+     *         or if the number of member classes exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -103,1 +109,3 @@\n-     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive\n+     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive,\n+     *         or if the number of member classes exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestMembersAttribute.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+     * @throws IllegalArgumentException if the number of permitted subclasses\n+     *         or subinterfaces exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -89,0 +91,2 @@\n+     * @throws IllegalArgumentException if the number of permitted subclasses\n+     *         or subinterfaces exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -98,1 +102,3 @@\n-     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive\n+     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive,\n+     *         or if the number of permitted subclasses or subinterfaces exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -108,1 +114,3 @@\n-     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive\n+     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive,\n+     *         or if the number of permitted subclasses or subinterfaces exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/PermittedSubclassesAttribute.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+     * @throws IllegalArgumentException if the number of record components\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -80,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of record components\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,0 +93,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -106,0 +108,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -119,0 +123,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -134,0 +140,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordComponentInfo.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -85,0 +87,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,0 +89,4 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}, or the number of\n+     *         annotations on any parameter exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleParameterAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -91,0 +93,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleTypeAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -83,0 +85,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}, or the number of\n+     *         annotations on any parameter exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleParameterAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -91,0 +93,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleTypeAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+     * @throws IllegalArgumentException if the number of types in {@code locals}\n+     *         or {@code stack} exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+     * @throws IllegalArgumentException if the number of frames exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -574,0 +574,2 @@\n+     * @throws IllegalArgumentException if the number of arguments exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -589,0 +591,2 @@\n+     * @throws IllegalArgumentException if the number of arguments exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n- * represent at most 65535 bytes of data due to the physical restrictions.\n+ * represent at most 65535 bytes of data due to the physical restrictions of\n+ * {@link java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/Utf8Entry.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n- * will cause a {@code NullPointerException}, unless otherwise specified. <\/p>\n+ * will cause a {@code NullPointerException}, unless otherwise specified.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        elements = List.copyOf(elements);\n+        elements = Util.sanitizeU2List(elements);\n@@ -192,1 +192,1 @@\n-            values = List.copyOf(values);\n+            values = Util.sanitizeU2List(values);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+        Util.checkU2(attributesCount, \"attributes count\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-                                 MethodHandleEntryImpl handle,\n-                                 List<LoadableConstantEntry> arguments) {\n+                             MethodHandleEntryImpl handle,\n+                             List<LoadableConstantEntry> arguments) {\n@@ -50,1 +50,1 @@\n-        this.arguments = List.copyOf(arguments);\n+        this.arguments = Util.sanitizeU2List(arguments);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -279,3 +279,1 @@\n-        if (utflen > 65535) {\n-            throw new IllegalArgumentException(\"string too long\");\n-        }\n+        Util.checkU2(utflen, \"utf8 length\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+        Util.checkU2(handlersSize, \"exception handlers\");\n@@ -190,1 +191,1 @@\n-            writeExceptionHandlers(buf, pos);\n+            writeExceptionHandlers(buf, pos, handlersSize);\n@@ -194,2 +195,1 @@\n-    private void writeExceptionHandlers(BufWriterImpl buf, int pos) {\n-        int handlersSize = handlers.size();\n+    private void writeExceptionHandlers(BufWriterImpl buf, int pos, int handlersSize) {\n@@ -230,0 +230,1 @@\n+                        Util.checkU2(crSize, \"character range count\");\n@@ -265,0 +266,1 @@\n+                        Util.checkU2(lvSize, \"local variable count\");\n@@ -294,0 +296,1 @@\n+                        Util.checkU2(lvtSize, \"local variable type count\");\n@@ -444,1 +447,1 @@\n-            b.writeU2(buf.size() \/ 4);\n+            b.writeU2(Util.checkU2(buf.size() \/ 4, \"line number count\"));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        this.interfaces = List.copyOf(interfaces);\n+        this.interfaces = Util.sanitizeU2List(interfaces);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/InterfacesImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+        Util.checkU2(bsmSize, \"num bootstrap methods\");\n@@ -163,4 +164,3 @@\n-        if (size() >= 65536) {\n-            throw new IllegalArgumentException(String.format(\"Constant pool is too large %d\", size()));\n-        }\n-        buf.writeU2(size());\n+        int mySize = size();\n+        Util.checkU2(mySize, \"constant pool count\");\n+        buf.writeU2(mySize);\n@@ -171,1 +171,1 @@\n-        for (int i = writeFrom; i < size(); ) {\n+        for (int i = writeFrom; i < mySize; ) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,2 +306,2 @@\n-            locals = List.copyOf(locals);\n-            stack = List.copyOf(stack);\n+            locals = Util.sanitizeU2List(locals);\n+            stack = Util.sanitizeU2List(stack);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-            this.table = List.copyOf(table);\n+            this.table = Util.sanitizeU2List(table);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TargetInfoImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-            this.exceptions = List.copyOf(exceptions);\n+            this.exceptions = Util.sanitizeU2List(exceptions);\n@@ -247,1 +247,1 @@\n-            this.entries = List.copyOf(entries);\n+            this.entries = Util.sanitizeU2List(entries);\n@@ -271,1 +271,1 @@\n-            this.innerClasses = List.copyOf(innerClasses);\n+            this.innerClasses = Util.sanitizeU2List(innerClasses);\n@@ -295,1 +295,1 @@\n-            this.components = List.copyOf(components);\n+            this.components = Util.sanitizeU2List(components);\n@@ -350,1 +350,1 @@\n-            this.parameters = List.copyOf(parameters);\n+            this.parameters = Util.sanitizeU1List(parameters);\n@@ -424,1 +424,1 @@\n-            this.hashes = List.copyOf(hashes);\n+            this.hashes = Util.sanitizeU2List(hashes);\n@@ -449,1 +449,1 @@\n-        private final Collection<PackageEntry> packages;\n+        private final List<PackageEntry> packages;\n@@ -453,1 +453,1 @@\n-            this.packages = List.copyOf(packages);\n+            this.packages = Util.sanitizeU2List(packages);\n@@ -458,1 +458,1 @@\n-            return List.copyOf(packages);\n+            return packages;\n@@ -501,1 +501,1 @@\n-            this.permittedSubclasses = List.copyOf(permittedSubclasses);\n+            this.permittedSubclasses = Util.sanitizeU2List(permittedSubclasses);\n@@ -525,1 +525,1 @@\n-            this.memberEntries = List.copyOf(memberEntries);\n+            this.memberEntries = Util.sanitizeU2List(memberEntries);\n@@ -645,1 +645,1 @@\n-            this.ranges = List.copyOf(ranges);\n+            this.ranges = Util.sanitizeU2List(ranges);\n@@ -669,1 +669,1 @@\n-            this.lines = List.copyOf(lines);\n+            this.lines = Util.sanitizeU2List(lines);\n@@ -693,1 +693,1 @@\n-            this.locals = List.copyOf(locals);\n+            this.locals = Util.sanitizeU2List(locals);\n@@ -717,1 +717,1 @@\n-            this.locals = List.copyOf(locals);\n+            this.locals = Util.sanitizeU2List(locals);\n@@ -741,1 +741,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -765,1 +765,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -789,7 +789,1 @@\n-            \/\/ deep copy\n-            var array = elements.toArray().clone();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = List.copyOf((List<?>) array[i]);\n-            }\n-\n-            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+            this.elements = Util.sanitizeParameterAnnotations(elements);\n@@ -819,7 +813,1 @@\n-            \/\/ deep copy\n-            var array = elements.toArray().clone();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = List.copyOf((List<?>) array[i]);\n-            }\n-\n-            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+            this.elements = Util.sanitizeParameterAnnotations(elements);\n@@ -849,1 +837,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -873,1 +861,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -958,1 +946,1 @@\n-            exportsTo = List.copyOf(exportsTo);\n+            exportsTo = Util.sanitizeU2List(exportsTo);\n@@ -976,1 +964,1 @@\n-            opensTo = List.copyOf(opensTo);\n+            opensTo = Util.sanitizeU2List(opensTo);\n@@ -985,1 +973,1 @@\n-            providesWith = List.copyOf(providesWith);\n+            providesWith = Util.sanitizeU2List(providesWith);\n@@ -1006,1 +994,1 @@\n-            attributes = List.copyOf(attributes);\n+            attributes = Util.sanitizeU2List(attributes);\n@@ -1016,1 +1004,1 @@\n-            targetPath = List.copyOf(targetPath);\n+            targetPath = Util.sanitizeU1List(targetPath);\n@@ -1050,5 +1038,5 @@\n-            this.requires = List.copyOf(requires);\n-            this.exports = List.copyOf(exports);\n-            this.opens = List.copyOf(opens);\n-            this.uses = List.copyOf(uses);\n-            this.provides = List.copyOf(provides);\n+            this.requires = Util.sanitizeU2List(requires);\n+            this.exports = Util.sanitizeU2List(exports);\n+            this.opens = Util.sanitizeU2List(opens);\n+            this.uses = Util.sanitizeU2List(uses);\n+            this.provides = Util.sanitizeU2List(provides);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":31,"deletions":43,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -149,0 +149,27 @@\n+    \/\/\/ Sanitizes an input list to make it immutable, and verify its size can\n+    \/\/\/ be represented with U1, throwing IAE otherwise.\n+    public static <T> List<T> sanitizeU1List(List<T> input) {\n+        var copy = List.copyOf(input);\n+        checkU1(copy.size(), \"list size\");\n+        return copy;\n+    }\n+\n+    \/\/\/ Sanitizes an input list to make it immutable, and verify its size can\n+    \/\/\/ be represented with U2, throwing IAE otherwise.\n+    public static <T> List<T> sanitizeU2List(Collection<T> input) {\n+        var copy = List.copyOf(input);\n+        checkU2(copy.size(), \"list size\");\n+        return copy;\n+    }\n+\n+    \/\/\/ Sanitizes an input nested list of parameter annotations.\n+    public static List<List<Annotation>> sanitizeParameterAnnotations(List<List<Annotation>> input) {\n+        var array = input.toArray().clone();\n+        checkU1(array.length, \"parameter count\");\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = sanitizeU2List((List<?>) array[i]);\n+        }\n+\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+    }\n+\n@@ -262,0 +289,1 @@\n+        Util.checkU2(size, \"attributes count\");\n@@ -270,0 +298,1 @@\n+        Util.checkU2(size, \"member count\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8320360 8330684 8331320 8331655 8331940 8332486 8335820 8336833\n+ * @bug 8320360 8330684 8331320 8331655 8331940 8332486 8335820 8336833 8361635\n@@ -30,0 +30,3 @@\n+\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.AttributedElement;\n@@ -31,4 +34,1 @@\n-import java.lang.classfile.constantpool.PoolEntry;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.BufWriter;\n@@ -36,0 +36,4 @@\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CustomAttribute;\n+import java.lang.classfile.Label;\n@@ -37,0 +41,1 @@\n+import java.lang.classfile.Signature;\n@@ -44,0 +49,1 @@\n+import java.lang.classfile.constantpool.PoolEntry;\n@@ -45,0 +51,5 @@\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n@@ -46,0 +57,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n@@ -54,0 +67,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -76,0 +91,108 @@\n+    @Test\n+    void testBsmOverLimit() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            var cp = clb.constantPool();\n+            var mhe = cp.methodHandleEntry(BSM_GET_STATIC_FINAL);\n+            var digits = new IntegerEntry[10];\n+            for (int i = 0; i < 10; i++) {\n+                digits[i] = cp.intEntry(i);\n+            }\n+            int lastIndex = -1;\n+            for (int i = 0; i < 66000; i++) {\n+                lastIndex = cp.bsmEntry(mhe, List.of(\n+                        digits[i \/ 10000 % 10],\n+                        digits[i \/ 1000 % 10],\n+                        digits[i \/ 100 % 10],\n+                        digits[i \/ 10 % 10],\n+                        digits[i \/ 1 % 10])).bsmIndex();\n+            }\n+            assertEquals(65999, lastIndex);\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testTooManyFields() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                clb.withField(\"f\", CD_int, 0);\n+            }\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testTooManyMethods() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                clb.withMethodBody(\"m\", MTD_void, 0, CodeBuilder::return_);\n+            }\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    static final class MyAttribute extends CustomAttribute<MyAttribute> {\n+        static final MyAttribute INSTANCE = new MyAttribute();\n+\n+        private enum Mapper implements AttributeMapper<MyAttribute> {\n+            INSTANCE;\n+\n+            @Override\n+            public MyAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void writeAttribute(BufWriter buf, MyAttribute attr) {\n+                buf.writeIndex(buf.constantPool().utf8Entry(\"MyAttribute\"));\n+                buf.writeInt(0);\n+            }\n+\n+            @Override\n+            public boolean allowMultiple() {\n+                return true;\n+            }\n+\n+            @Override\n+            public AttributeStability stability() {\n+                return AttributeStability.STATELESS;\n+            }\n+\n+\n+        }\n+\n+        private MyAttribute() {\n+            super(Mapper.INSTANCE);\n+        }\n+    }\n+\n+    @Test\n+    void testTooManyClassAttributes() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                clb.with(MyAttribute.INSTANCE);\n+            }\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testTooManyFieldAttributes() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> clb.withField(\"f\", CD_int, fb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                fb.with(MyAttribute.INSTANCE);\n+            }\n+            reached.set(true);\n+        })));\n+        assertTrue(reached.get());\n+    }\n+\n@@ -102,0 +225,85 @@\n+    private static void testPseudoOverflow(BiConsumer<CodeBuilder, Label> handler) {\n+        ClassFile cf = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        AtomicBoolean reached = new AtomicBoolean(false);\n+        assertDoesNotThrow(() -> cf.build(CD_Void, cb -> cb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            cob.nop();\n+            var label = cob.newLabel();\n+            for (int i = 0; i < 65535; i++) {\n+                handler.accept(cob, label);\n+            }\n+            cob.labelBinding(label);\n+            cob.return_();\n+            reached.set(true);\n+        })));\n+        assertTrue(reached.get());\n+\n+        reached.set(false);\n+        assertThrows(IllegalArgumentException.class, () -> cf.build(CD_Void, cb -> cb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            cob.nop();\n+            var label = cob.newLabel();\n+            for (int i = 0; i < 65536; i++) {\n+                handler.accept(cob, label);\n+            }\n+            cob.labelBinding(label);\n+            cob.return_();\n+            reached.set(true);\n+        })));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testExceptionCatchOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.exceptionCatch(cob.startLabel(), label, label, CD_Throwable));\n+    }\n+\n+    @Test\n+    void testLocalVariableOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.localVariable(0, \"fake\", CD_int, cob.startLabel(), label));\n+    }\n+\n+    @Test\n+    void testLocalVariableTypeOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.localVariableType(0, \"fake\", Signature.of(CD_int), cob.startLabel(), label));\n+    }\n+\n+    @Test\n+    void testCharacterRangeOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.characterRange(cob.startLabel(), label, 0, 0, 0));\n+    }\n+\n+    \/\/ LineNumber deduplicates so cannot really overflow\n+\n+    @Test\n+    void testHugeLookupswitch() {\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> clb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            var l = cob.newLabel();\n+            \/\/ 10000 * 8 > 65535\n+            var cases = new ArrayList<SwitchCase>(10000);\n+            for (int i = 0; i < 10000; i++) {\n+                cases.add(SwitchCase.of(i, l));\n+            }\n+            cob.lookupswitch(l, cases);\n+            cob.labelBinding(l);\n+            cob.return_();\n+        })));\n+    }\n+\n+    @Test\n+    void testHugeTableswitch() {\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> clb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            var l = cob.newLabel();\n+            \/\/ 20000 * 4 > 65535\n+            cob.tableswitch(-10000, 10000, l, List.of());\n+            cob.labelBinding(l);\n+            cob.return_();\n+        })));\n+    }\n+\n+    @Test\n+    void testHugeUtf8Entry() {\n+        var longString = String.valueOf((char) 0x800).repeat(22000);\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            clb.constantPool().utf8Entry(longString);\n+        }));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":214,"deletions":6,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -0,0 +1,348 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361635\n+ * @summary Testing list size validation in class file format.\n+ * @run junit ListValidationTest\n+ *\/\n+\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Interfaces;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.util.Collections.nCopies;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class ListValidationTest {\n+    @Test\n+    void testAnnotationElements() {\n+        var e = AnnotationElement.ofInt(\"dummy\", 0);\n+        assertDoesNotThrow(() -> Annotation.of(CD_String, nCopies(65535, e)));\n+        assertThrows(IllegalArgumentException.class, () -> Annotation.of(CD_String, nCopies(66000, e)));\n+    }\n+\n+    @Test\n+    void testAnnotationArrayValue() {\n+        var v = AnnotationValue.ofInt(0);\n+        assertDoesNotThrow(() -> AnnotationValue.ofArray(nCopies(65535, v)));\n+        assertThrows(IllegalArgumentException.class, () -> AnnotationValue.ofArray(nCopies(66000, v)));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationPath() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> TypeAnnotation.of(TypeAnnotation.TargetInfo.ofField(), nCopies(255, TypeAnnotation.TypePathComponent.INNER_TYPE), anno));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.of(TypeAnnotation.TargetInfo.ofField(), nCopies(256, TypeAnnotation.TypePathComponent.INNER_TYPE), anno));\n+    }\n+\n+    @Test\n+    void testBsmArgs() {\n+        var cpb = ConstantPoolBuilder.of();\n+        assertDoesNotThrow(() -> cpb.bsmEntry(BSM_INVOKE, nCopies(65535, 0)));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.bsmEntry(BSM_INVOKE, nCopies(66000, 0)));\n+    }\n+\n+    @Test\n+    void testInterfaces() {\n+        var cpb = ConstantPoolBuilder.of();\n+        assertDoesNotThrow(() -> Interfaces.ofSymbols(nCopies(65535, CD_Number)));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.bsmEntry(BSM_INVOKE, nCopies(66000, 0)));\n+    }\n+\n+    @Test\n+    void testStackMapFrame() {\n+        Label label = dummyLabel();\n+        assertDoesNotThrow(() -> StackMapFrameInfo.of(label,\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE)));\n+        assertThrows(IllegalArgumentException.class, () -> StackMapFrameInfo.of(label,\n+                nCopies(66000, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE)));\n+        assertThrows(IllegalArgumentException.class, () -> StackMapFrameInfo.of(label,\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(66000, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE)));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationLocalVarTarget() {\n+        Label label = dummyLabel();\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofLocalVariable(nCopies(65535, TypeAnnotation.LocalVarTargetInfo.of(label, label, 0))));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofLocalVariable(nCopies(66000, TypeAnnotation.LocalVarTargetInfo.of(label, label, 0))));\n+    }\n+\n+    @Test\n+    void testExceptionsAttribute() {\n+        assertDoesNotThrow(() -> ExceptionsAttribute.ofSymbols(nCopies(65535, CD_Throwable)));\n+        assertThrows(IllegalArgumentException.class, () -> ExceptionsAttribute.ofSymbols(nCopies(66000, CD_Throwable)));\n+    }\n+\n+    @Test\n+    void testStackMapTableAttribute() {\n+        var frame = StackMapFrameInfo.of(dummyLabel(),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE));\n+        assertDoesNotThrow(() -> StackMapTableAttribute.of(nCopies(65535, frame)));\n+        assertThrows(IllegalArgumentException.class, () -> StackMapTableAttribute.of(nCopies(66000, frame)));\n+    }\n+\n+    @Test\n+    void testInnerClassesAttribute() {\n+        var entry = InnerClassInfo.of(CD_Void, Optional.empty(), Optional.empty(), 0);\n+        assertDoesNotThrow(() -> InnerClassesAttribute.of(nCopies(65535, entry)));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassesAttribute.of(nCopies(66000, entry)));\n+    }\n+\n+    @Test\n+    void testRecordAttribute() {\n+        var component = RecordComponentInfo.of(\"hello\", CD_int, List.of());\n+        assertDoesNotThrow(() -> RecordAttribute.of(nCopies(65535, component)));\n+        assertThrows(IllegalArgumentException.class, () -> RecordAttribute.of(nCopies(66000, component)));\n+    }\n+\n+    @Test\n+    void testMethodParametersAttribute() {\n+        var component = MethodParameterInfo.of(Optional.empty(), 0);\n+        assertDoesNotThrow(() -> MethodParametersAttribute.of(nCopies(255, component)));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParametersAttribute.of(nCopies(300, component)));\n+    }\n+\n+    @Test\n+    void testModuleHashesAttribute() {\n+        var hash = ModuleHashInfo.of(ModuleDesc.of(\"java.base\"), new byte[0]);\n+        assertDoesNotThrow(() -> ModuleHashesAttribute.of(\"dummy\", nCopies(65535, hash)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleHashesAttribute.of(\"dummy\", nCopies(66000, hash)));\n+    }\n+\n+    @Test\n+    void testModulePackagesAttribute() {\n+        var pkgDesc = PackageDesc.of(\"java.io\");\n+        assertDoesNotThrow(() -> ModulePackagesAttribute.ofNames(nCopies(65535, pkgDesc)));\n+        assertThrows(IllegalArgumentException.class, () -> ModulePackagesAttribute.ofNames(nCopies(66000, pkgDesc)));\n+    }\n+\n+    @Test\n+    void testPermittedSubclassesAttribute() {\n+        assertDoesNotThrow(() -> PermittedSubclassesAttribute.ofSymbols(nCopies(65535, CD_Collection)));\n+        assertThrows(IllegalArgumentException.class, () -> PermittedSubclassesAttribute.ofSymbols(nCopies(66000, CD_Collection)));\n+    }\n+\n+    @Test\n+    void testNestMembersAttribute() {\n+        assertDoesNotThrow(() -> NestMembersAttribute.ofSymbols(nCopies(65535, CD_Collection)));\n+        assertThrows(IllegalArgumentException.class, () -> NestMembersAttribute.ofSymbols(nCopies(66000, CD_Collection)));\n+    }\n+\n+    @Test\n+    void testCharacterRangeTableAttribute() {\n+        var range = CharacterRangeInfo.of(0, 0, 0, 0, 0);\n+        assertDoesNotThrow(() -> CharacterRangeTableAttribute.of(nCopies(65535, range)));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeTableAttribute.of(nCopies(66000, range)));\n+    }\n+\n+    @Test\n+    void testLineNumberTableAttribute() {\n+        var lineNumber = LineNumberInfo.of(0, 0);\n+        assertDoesNotThrow(() -> LineNumberTableAttribute.of(nCopies(65535, lineNumber)));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberTableAttribute.of(nCopies(66000, lineNumber)));\n+    }\n+\n+    @Test\n+    void testLocalVariableTableAttribute() {\n+        var utf8 = TemporaryConstantPool.INSTANCE.utf8Entry(\"dummy\");\n+        var localVariable = new UnboundAttribute.UnboundLocalVariableInfo(0, 0, utf8, utf8, 0);\n+        assertDoesNotThrow(() -> LocalVariableTableAttribute.of(nCopies(65535, localVariable)));\n+        assertThrows(IllegalArgumentException.class, () -> LocalVariableTableAttribute.of(nCopies(66000, localVariable)));\n+    }\n+\n+    @Test\n+    void testLocalVariableTypeTableAttribute() {\n+        var utf8 = TemporaryConstantPool.INSTANCE.utf8Entry(\"dummy\");\n+        var localVariableType = new UnboundAttribute.UnboundLocalVariableTypeInfo(0, 0, utf8, utf8, 0);\n+        assertDoesNotThrow(() -> LocalVariableTypeTableAttribute.of(nCopies(65535, localVariableType)));\n+        assertThrows(IllegalArgumentException.class, () -> LocalVariableTypeTableAttribute.of(nCopies(66000, localVariableType)));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleAnnotationsAttribute() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeVisibleAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleAnnotationsAttribute() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeInvisibleAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleParameterAnnotationsAttributeTopLevel() {\n+        assertDoesNotThrow(() -> RuntimeVisibleParameterAnnotationsAttribute.of(nCopies(255, List.of())));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleParameterAnnotationsAttribute.of(nCopies(256, List.of())));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleParameterAnnotationsAttributeTopLevel() {\n+        assertDoesNotThrow(() -> RuntimeInvisibleParameterAnnotationsAttribute.of(nCopies(255, List.of())));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleParameterAnnotationsAttribute.of(nCopies(256, List.of())));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleParameterAnnotationsAttributeNested() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeVisibleParameterAnnotationsAttribute.of(List.of(nCopies(65535, anno))));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleParameterAnnotationsAttribute.of(List.of(nCopies(65536, anno))));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleParameterAnnotationsAttributeNested() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(nCopies(65535, anno))));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(nCopies(65536, anno))));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleTypeAnnotationsAttribute() {\n+        var anno = TypeAnnotation.of(TypeAnnotation.TargetInfo.ofMethodReturn(), List.of(), Annotation.of(CD_String));\n+        assertDoesNotThrow(() -> RuntimeVisibleTypeAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleTypeAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleTypeAnnotationsAttribute() {\n+        var anno = TypeAnnotation.of(TypeAnnotation.TargetInfo.ofMethodReturn(), List.of(), Annotation.of(CD_String));\n+        assertDoesNotThrow(() -> RuntimeInvisibleTypeAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleTypeAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testModuleExportEntry() {\n+        var pkg = PackageDesc.of(\"dummy.test\");\n+        var mod = ModuleDesc.of(\"the.other\");\n+        assertDoesNotThrow(() -> ModuleExportInfo.of(pkg, 0, nCopies(65535, mod)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(pkg, 0, nCopies(66000, mod)));\n+    }\n+\n+    @Test\n+    void testModuleOpenEntry() {\n+        var pkg = PackageDesc.of(\"dummy.test\");\n+        var mod = ModuleDesc.of(\"the.other\");\n+        assertDoesNotThrow(() -> ModuleOpenInfo.of(pkg, 0, nCopies(65535, mod)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(pkg, 0, nCopies(66000, mod)));\n+    }\n+\n+    @Test\n+    void testModuleProvideEntry() {\n+        assertDoesNotThrow(() -> ModuleProvideInfo.of(CD_Object, nCopies(65535, CD_String)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleProvideInfo.of(CD_Object, nCopies(66000, CD_String)));\n+    }\n+\n+    @Test\n+    void testRecordComponentAttributes() {\n+        var attr = SyntheticAttribute.of();\n+        assertDoesNotThrow(() -> RecordComponentInfo.of(\"dummy\", CD_int, nCopies(65535, attr)));\n+        assertThrows(IllegalArgumentException.class, () -> RecordComponentInfo.of(\"dummy\", CD_int, nCopies(66000, attr)));\n+    }\n+\n+    @Test\n+    void testModuleAttribute() {\n+        var md = ModuleDesc.of(\"java.base\");\n+        var pkg = PackageDesc.of(\"java.lang\");\n+        var require = ModuleRequireInfo.of(md, 0, null);\n+        var export = ModuleExportInfo.of(pkg, 0, List.of());\n+        var provide = ModuleProvideInfo.of(CD_Object, List.of());\n+        var open = ModuleOpenInfo.of(pkg, 0, List.of());\n+        var classEntry = TemporaryConstantPool.INSTANCE.classEntry(CD_String);\n+        var moduleEntry = TemporaryConstantPool.INSTANCE.moduleEntry(md);\n+        assertDoesNotThrow(() -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(66000, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(66000, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(66000, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(66000, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(66000, provide)\n+        ));\n+    }\n+\n+    private static Label dummyLabel() {\n+        Label[] capture = new Label[1];\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            capture[0] = cob.startLabel();\n+            cob.return_();\n+        }));\n+        return capture[0];\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ListValidationTest.java","additions":348,"deletions":0,"binary":false,"changes":348,"status":"added"}]}