{"files":[{"patch":"@@ -747,1 +747,1 @@\n-    lea(rscratch1, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+    lea(rscratch1, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -454,1 +454,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n@@ -2775,0 +2781,190 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n+  enum layout {\n+    rfp_off = 0,\n+    rfp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and LR before call\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ lr and fp are already in place\n+  __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+\n+  __ mov(c_rarg0, rthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ mov(rscratch1, runtime_entry);\n+  __ blr(rscratch1);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+  \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+  __ reinitialize_ptrue();\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n+  __ cbnz(rscratch1, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+  __ mov(c_rarg0, thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(r0, rscratch1, rscratch2);\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":196,"deletions":0,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -7048,1 +7048,1 @@\n-    __ lea(rscratch1, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ lea(rscratch1, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -7308,92 +7308,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-    __ mov(c_rarg0, thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -7415,16 +7323,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n@@ -7434,90 +7326,0 @@\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n-    enum layout {\n-      rfp_off = 0,\n-      rfp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 512;\n-    int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and LR before call\n-\n-    assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-    \/\/ lr and fp are already in place\n-    __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mov(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mov(c_rarg2, arg2);\n-    }\n-    __ mov(c_rarg0, rthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ mov(rscratch1, runtime_entry);\n-    __ blr(rscratch1);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-    __ reinitialize_ptrue();\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n-    __ cbnz(rscratch1, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -8366,10 +8168,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -8411,10 +8203,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -8422,1 +8204,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -8429,17 +8210,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":237,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -755,2 +755,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -143,1 +144,1 @@\n-  __ jump(StubRoutines::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n+  __ jump(SharedRuntime::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n@@ -464,1 +465,1 @@\n-      __ jump(StubRoutines::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n+      __ jump(SharedRuntime::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1731,0 +1731,140 @@\n+\n+\/\/------------------------------------------------------------------------------------------------------------------------\n+\/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+\/\/ the current activation. Fabricates an exception oop and initiates normal\n+\/\/ exception dispatching in this frame.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  int insts_size = 128;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps;\n+  int frame_size;\n+  int frame_complete;\n+\n+  oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  frame_size = 2;\n+  __ mov(Rexception_pc, LR);\n+  __ raw_push(FP, LR);\n+\n+  frame_complete = __ pc() - start;\n+\n+  \/\/ Any extra arguments are already supposed to be R1 and R2\n+  __ mov(R0, Rthread);\n+\n+  int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n+  assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n+  __ call(runtime_entry);\n+  if (pc_offset == -1) {\n+    pc_offset = __ offset();\n+  }\n+\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n+  oop_maps->add_gc_map(pc_offset, map);\n+  __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n+\n+  __ raw_pop(FP, LR);\n+  __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                                    frame_size, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(R0, Rtemp, R1);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2964,46 +2964,0 @@\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  address generate_throw_exception(const char* name, address runtime_entry) {\n-    int insts_size = 128;\n-    int locs_size  = 32;\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps;\n-    int frame_size;\n-    int frame_complete;\n-\n-    oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    frame_size = 2;\n-    __ mov(Rexception_pc, LR);\n-    __ raw_push(FP, LR);\n-\n-    frame_complete = __ pc() - start;\n-\n-    \/\/ Any extra arguments are already supposed to be R1 and R2\n-    __ mov(R0, Rthread);\n-\n-    int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n-    assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n-    __ call(runtime_entry);\n-    if (pc_offset == -1) {\n-      pc_offset = __ offset();\n-    }\n-\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n-    oop_maps->add_gc_map(pc_offset, map);\n-    __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n-\n-    __ raw_pop(FP, LR);\n-    __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n-                                                      frame_size, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -3028,89 +2982,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n-    __ resolve_global_jobject(R0, Rtemp, R1);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3135,2 +3000,0 @@\n-    StubRoutines::_throw_StackOverflowError_entry  = generate_throw_exception(\"StackOverflowError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-\n@@ -3158,2 +3021,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3162,9 +3023,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3174,6 +3026,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":0,"deletions":154,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-  __ b(StubRoutines::throw_StackOverflowError_entry(), ls);\n+  __ b(SharedRuntime::throw_StackOverflowError_entry(), ls);\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1504,1 +1504,1 @@\n-  load_const_optimized(R0, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(R0, SharedRuntime::throw_delayed_StackOverflowError_entry());\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -492,1 +492,1 @@\n-      __ load_const_optimized(temp1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(temp1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -3407,0 +3408,94 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal register window \/ RegisterMap handling).  If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\/\/\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\/\/\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  int frame_size_in_bytes = frame::native_abi_reg_args_size;\n+  OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n+\n+  address start = __ pc();\n+\n+  __ save_LR(R11_scratch1);\n+\n+  \/\/ Push a frame.\n+  __ push_frame_reg_args(0, R11_scratch1);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of\n+  \/\/ stack by this point. Remember the offset of the instruction\n+  \/\/ whose address will be moved to R11_scratch1.\n+  address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n+\n+  __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n+\n+  __ mr(R3_ARG1, R16_thread);\n+#if defined(ABI_ELFv2)\n+  __ call_c(runtime_entry, relocInfo::none);\n+#else\n+  __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, runtime_entry), relocInfo::none);\n+#endif\n+\n+  \/\/ Set an oopmap for the call site.\n+  oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending\n+  \/\/ exception.\n+  {\n+    Label L;\n+    __ ld(R0,\n+          in_bytes(Thread::pending_exception_offset()),\n+          R16_thread);\n+    __ cmpdi(CCR0, R0, 0);\n+    __ bne(CCR0, L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  \/\/ Pop frame.\n+  __ pop_frame();\n+\n+  __ restore_LR(R11_scratch1);\n+\n+  __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n+  __ mtctr(R11_scratch1);\n+  __ bctr();\n+\n+  \/\/ Create runtime stub with OopMap.\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n+                                  frame_size_in_bytes\/wordSize,\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n@@ -3650,0 +3745,78 @@\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  \/\/ The handle is dereferenced through a load barrier.\n+  __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":173,"deletions":0,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -520,103 +520,0 @@\n-#define __ masm->\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal register window \/ RegisterMap handling).  If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-  \/\/\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-  \/\/\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-  address generate_throw_exception(const char* name, address runtime_entry, bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    int frame_size_in_bytes = frame::native_abi_reg_args_size;\n-    OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n-\n-    address start = __ pc();\n-\n-    __ save_LR(R11_scratch1);\n-\n-    \/\/ Push a frame.\n-    __ push_frame_reg_args(0, R11_scratch1);\n-\n-    address frame_complete_pc = __ pc();\n-\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception with restore_saved_exception_pc\");\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of\n-    \/\/ stack by this point. Remember the offset of the instruction\n-    \/\/ whose address will be moved to R11_scratch1.\n-    address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n-\n-    __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n-\n-    __ mr(R3_ARG1, R16_thread);\n-    if (arg1 != noreg) {\n-      __ mr(R4_ARG2, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mr(R5_ARG3, arg2);\n-    }\n-#if defined(ABI_ELFv2)\n-    __ call_c(runtime_entry, relocInfo::none);\n-#else\n-    __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, runtime_entry), relocInfo::none);\n-#endif\n-\n-    \/\/ Set an oopmap for the call site.\n-    oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending\n-    \/\/ exception.\n-    {\n-      Label L;\n-      __ ld(R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                R16_thread);\n-      __ cmpdi(CCR0, R0, 0);\n-      __ bne(CCR0, L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    \/\/ Pop frame.\n-    __ pop_frame();\n-\n-    __ restore_LR(R11_scratch1);\n-\n-    __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n-    __ mtctr(R11_scratch1);\n-    __ bctr();\n-\n-    \/\/ Create runtime stub with OopMap.\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n-                                    frame_size_in_bytes\/wordSize,\n-                                    oop_maps,\n-                                    false);\n-    return stub->entry_point();\n-  }\n-#undef __\n@@ -4619,1 +4516,1 @@\n-    __ load_const_optimized(tmp1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+    __ load_const_optimized(tmp1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n@@ -4678,78 +4575,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    \/\/ The handle is dereferenced through a load barrier.\n-    __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  RuntimeStub* generate_jfr_return_lease() {\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4789,8 +4608,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry   =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -4815,10 +4626,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -4826,1 +4627,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -4831,7 +4631,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    \/\/ Handle IncompatibleClassChangeError in itable stubs.\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":208,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -786,2 +786,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n-  __ load_const_optimized(Rscratch1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n+  __ load_const_optimized(Rscratch1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4147,1 +4147,1 @@\n-  la(t0, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  la(t0, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -444,1 +444,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -2631,0 +2632,188 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n+  assert_cond(runtime_entry != nullptr);\n+  enum layout {\n+    fp_off = 0,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  const int insts_size = 1024;\n+  const int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  assert_cond(oop_maps != nullptr && masm != nullptr);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and RA before call\n+\n+  assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n+\n+  \/\/ ra and fp are already in place\n+  __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+\n+  \/\/ Call runtime\n+  __ mv(c_rarg0, xthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ rt_call(runtime_entry);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+  assert_cond(map != nullptr);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n+  __ bnez(t0, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  assert(stub != nullptr, \"create runtime stub fail!\");\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+  __ mv(c_rarg0, thread);\n+}\n+\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+static RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(x10, t0, t1);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+static RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":189,"deletions":0,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -3777,1 +3777,1 @@\n-    __ la(t0, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ la(t0, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -5618,91 +5618,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-    __ mv(c_rarg0, thread);\n-  }\n-\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(x10, t0, t1);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -5723,108 +5632,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n-    assert_cond(runtime_entry != nullptr);\n-    enum layout {\n-      fp_off = 0,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    const int insts_size = 1024;\n-    const int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    assert_cond(oop_maps != nullptr && masm != nullptr);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and RA before call\n-\n-    assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n-\n-    \/\/ ra and fp are already in place\n-    __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mv(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mv(c_rarg2, arg2);\n-    }\n-    __ mv(c_rarg0, xthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ rt_call(runtime_entry);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-    assert_cond(map != nullptr);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-    __ bnez(t0, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    assert(stub != nullptr, \"create runtime stub fail!\");\n-    return stub->entry_point();\n-  }\n-\n@@ -5855,10 +5656,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -5877,10 +5668,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -5888,1 +5669,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -5896,17 +5676,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":238,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -661,2 +661,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2754,1 +2754,1 @@\n-  load_const_optimized(Z_R1, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(Z_R1, SharedRuntime::throw_delayed_StackOverflowError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,2 +183,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -546,1 +546,1 @@\n-      __ load_const_optimized(Z_R1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(Z_R1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3013,0 +3013,79 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal RegisterMap handling). If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+\n+  int insts_size = 256;\n+  int locs_size  = 0;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer      code(name, insts_size, locs_size);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  int framesize_in_bytes;\n+  address start = __ pc();\n+\n+  __ save_return_pc();\n+  framesize_in_bytes = __ push_frame_abi160(0);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n+  __ get_PC(Z_R1);\n+  __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n+\n+  \/\/ Do the call.\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call_VM_leaf(runtime_entry, Z_thread);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending exception.\n+  { Label L;\n+    __ z_lg(Z_R0,\n+            in_bytes(Thread::pending_exception_offset()),\n+            Z_thread);\n+    __ z_ltgr(Z_R0, Z_R0);\n+    __ z_brne(L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  __ pop_frame();\n+  __ restore_return_pc();\n+\n+  __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n+  __ z_br(Z_R1);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  frame_complete_pc - start,\n+                                  framesize_in_bytes\/wordSize,\n+                                  nullptr \/*oop_maps*\/, false);\n+\n+  return stub;\n+}\n+\n@@ -3266,0 +3345,15 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -575,83 +575,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal RegisterMap handling). If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    assert_different_registers(arg1, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-    assert_different_registers(arg2, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-\n-    int insts_size = 256;\n-    int locs_size  = 0;\n-    CodeBuffer      code(name, insts_size, locs_size);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    int framesize_in_bytes;\n-    address start = __ pc();\n-\n-    __ save_return_pc();\n-    framesize_in_bytes = __ push_frame_abi160(0);\n-\n-    address frame_complete_pc = __ pc();\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception\", 74);\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n-    __ get_PC(Z_R1);\n-    __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n-\n-    \/\/ Do the call.\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call_VM_leaf(runtime_entry, Z_thread, arg1, arg2);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending exception.\n-    { Label L;\n-      __ z_lg(Z_R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                Z_thread);\n-      __ z_ltgr(Z_R0, Z_R0);\n-      __ z_brne(L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    __ pop_frame();\n-    __ restore_return_pc();\n-\n-    __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n-    __ z_br(Z_R1);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    frame_complete_pc - start,\n-                                    framesize_in_bytes\/wordSize,\n-                                    nullptr \/*oop_maps*\/, false);\n-\n-    return stub->entry_point();\n-  }\n-\n@@ -3124,15 +3041,0 @@\n-  #if INCLUDE_JFR\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  RuntimeStub* generate_jfr_return_lease() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  #endif \/\/ INCLUDE_JFR\n-\n@@ -3167,8 +3069,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry          =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -3199,2 +3093,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3203,9 +3095,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3217,5 +3100,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":0,"deletions":122,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -853,3 +853,3 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  AddressLiteral stub(StubRoutines::throw_StackOverflowError_entry());\n-  __ load_absolute_address(tmp1, StubRoutines::throw_StackOverflowError_entry());\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  AddressLiteral stub(SharedRuntime::throw_StackOverflowError_entry());\n+  __ load_absolute_address(tmp1, SharedRuntime::throw_StackOverflowError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1306,1 +1306,1 @@\n-  jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  jump(RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -513,1 +513,1 @@\n-      __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -59,0 +60,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -2633,0 +2640,204 @@\n+\n+  \/\/------------------------------------------------------------------------------------------------------------------------\n+  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+  \/\/ the current activation. Fabricates an exception oop and initiates normal\n+  \/\/ exception dispatching in this frame.\n+  \/\/\n+  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n+  \/\/ This is no longer true after adapter frames were removed but could possibly\n+  \/\/ be brought back in the future if the interpreter code was reworked and it\n+  \/\/ was deemed worthwhile. The comment below was left to describe what must\n+  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n+  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n+  \/\/ Since it doesn't make much difference we've chosen to leave it the\n+  \/\/ way it was in the callee save days and keep the comment.\n+\n+  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n+  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n+  \/\/ If the compiler needs all registers to be preserved between the fault\n+  \/\/ point and the exception handler then it must assume responsibility for that in\n+  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n+  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n+  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n+  \/\/ so caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    thread_off,    \/\/ last_java_sp\n+    arg1_off,\n+    arg2_off,\n+    rbp_off,       \/\/ callee saved register\n+    ret_pc,\n+    framesize\n+  };\n+\n+  int insts_size = 256;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+  Register java_thread = rbx;\n+  __ get_thread(java_thread);\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ pc and rbp, already pushed\n+  __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n+\n+  \/\/ Frame is now completed as far as size and linkage.\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ push java thread (becomes first argument of C function)\n+  __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n+\n+  \/\/ Call runtime\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+\n+  \/\/ restore the thread (cannot use the pushed argument since arguments\n+  \/\/ may be overwritten by C code generated by an optimizing compiler);\n+  \/\/ however can use the register value directly if it is callee saved.\n+  __ get_thread(java_thread);\n+\n+  __ reset_last_Java_frame(java_thread, true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/* ASSERT *\/\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n+  __ movptr(Address(rsp, 0), java_thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ reset_last_Java_frame(java_thread, true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    FPUState_off         = 0,\n+    rbp_off              = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(rax, rdi, rdx);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    FPUState_off = 0,\n+    rbp_off = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":211,"deletions":0,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -73,0 +74,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -3213,0 +3220,95 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n+    rbp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ return address and rbp are already in place\n+  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n+\n+  \/\/ Call runtime\n+  __ movptr(c_rarg0, r15_thread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n@@ -3478,0 +3580,91 @@\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":193,"deletions":0,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -3846,14 +3846,0 @@\n- public:\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    thread_off,    \/\/ last_java_sp\n-    arg1_off,\n-    arg2_off,\n-    rbp_off,       \/\/ callee saved register\n-    ret_pc,\n-    framesize\n-  };\n-\n@@ -3862,99 +3848,0 @@\n-#undef  __\n-#define __ masm->\n-\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  \/\/\n-  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n-  \/\/ This is no longer true after adapter frames were removed but could possibly\n-  \/\/ be brought back in the future if the interpreter code was reworked and it\n-  \/\/ was deemed worthwhile. The comment below was left to describe what must\n-  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n-  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n-  \/\/ Since it doesn't make much difference we've chosen to leave it the\n-  \/\/ way it was in the callee save days and keep the comment.\n-\n-  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n-  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n-  \/\/ If the compiler needs all registers to be preserved between the fault\n-  \/\/ point and the exception handler then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n-  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n-  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n-  \/\/ so caller saved registers were assumed volatile in the compiler.\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-\n-    int insts_size = 256;\n-    int locs_size  = 32;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-    Register java_thread = rbx;\n-    __ get_thread(java_thread);\n-\n-    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ pc and rbp, already pushed\n-    __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n-\n-    \/\/ Frame is now completed as far as size and linkage.\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ push java thread (becomes first argument of C function)\n-    __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n-    if (arg1 != noreg) {\n-      __ movptr(Address(rsp, arg1_off * wordSize), arg1);\n-    }\n-    if (arg2 != noreg) {\n-      assert(arg1 != noreg, \"missing reg arg\");\n-      __ movptr(Address(rsp, arg2_off * wordSize), arg2);\n-    }\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n-\n-    \/\/ Call runtime\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call(RuntimeAddress(runtime_entry));\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(__ pc() - start, map);\n-\n-    \/\/ restore the thread (cannot use the pushed argument since arguments\n-    \/\/ may be overwritten by C code generated by an optimizing compiler);\n-    \/\/ however can use the register value directly if it is callee saved.\n-    __ get_thread(java_thread);\n-\n-    __ reset_last_Java_frame(java_thread, true);\n-\n-    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n-    __ jcc(Assembler::notEqual, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/* ASSERT *\/\n-    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n-\n@@ -4000,103 +3887,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n-    __ movptr(Address(rsp, 0), java_thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ reset_last_Java_frame(java_thread, true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      FPUState_off         = 0,\n-      rbp_off              = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(rax, rdi, rdx);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      FPUState_off = 0,\n-      rbp_off = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4133,6 +3917,0 @@\n-    \/\/ Build this early so it's available for the interpreter\n-    StubRoutines::_throw_StackOverflowError_entry          = generate_throw_exception(\"StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  = generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -4191,2 +3969,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -4195,9 +3971,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4207,6 +3974,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":0,"deletions":239,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-#if INCLUDE_JFR\n-#include \"jfr\/support\/jfrIntrinsics.hpp\"\n-#endif\n@@ -3705,1 +3702,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -3781,192 +3778,0 @@\n-#if INCLUDE_JFR\n-\n-\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-\/\/ It returns a jobject handle to the event writer.\n-\/\/ The handle is dereferenced and the return value is the event writer oop.\n-RuntimeStub* StubGenerator::generate_jfr_write_checkpoint() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n-  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-\/\/ For c2: call to return a leased buffer.\n-RuntimeStub* StubGenerator::generate_jfr_return_lease() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-#endif \/\/ INCLUDE_JFR\n-\n-\/\/ Continuation point for throwing of implicit exceptions that are\n-\/\/ not handled in the current activation. Fabricates an exception\n-\/\/ oop and initiates normal exception dispatching in this\n-\/\/ frame. Since we need to preserve callee-saved values (currently\n-\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-\/\/ map and therefore have to make these stubs into RuntimeStubs\n-\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-\/\/ be preserved between the fault point and the exception handler\n-\/\/ then it must assume responsibility for that in\n-\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-\/\/ continuation_for_implicit_division_by_zero_exception. All other\n-\/\/ implicit exceptions (e.g., NullPointerException or\n-\/\/ AbstractMethodError on entry) are either at call sites or\n-\/\/ otherwise assume that stack unwinding will be initiated, so\n-\/\/ caller saved registers were assumed volatile in the compiler.\n-address StubGenerator::generate_throw_exception(const char* name,\n-                                                address runtime_entry,\n-                                                Register arg1,\n-                                                Register arg2) {\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n-    rbp_off2,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  int insts_size = 512;\n-  int locs_size  = 64;\n-\n-  CodeBuffer code(name, insts_size, locs_size);\n-  OopMapSet* oop_maps  = new OopMapSet();\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-  address start = __ pc();\n-\n-  \/\/ This is an inlined and slightly modified version of call_VM\n-  \/\/ which has the ability to fetch the return PC out of\n-  \/\/ thread-local storage and also sets up last_Java_sp slightly\n-  \/\/ differently than the real call_VM\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-  \/\/ return address and rbp are already in place\n-  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-  int frame_complete = __ pc() - start;\n-\n-  \/\/ Set up last_Java_sp and last_Java_fp\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n-\n-  \/\/ Call runtime\n-  if (arg1 != noreg) {\n-    assert(arg2 != c_rarg1, \"clobbered\");\n-    __ movptr(c_rarg1, arg1);\n-  }\n-  if (arg2 != noreg) {\n-    __ movptr(c_rarg2, arg2);\n-  }\n-  __ movptr(c_rarg0, r15_thread);\n-  BLOCK_COMMENT(\"call runtime_entry\");\n-  __ call(RuntimeAddress(runtime_entry));\n-\n-  \/\/ Generate oop map\n-  OopMap* map = new OopMap(framesize, 0);\n-\n-  oop_maps->add_gc_map(the_pc - start, map);\n-\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  \/\/ check for pending exceptions\n-#ifdef ASSERT\n-  Label L;\n-  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n-  __ jcc(Assembler::notEqual, L);\n-  __ should_not_reach_here();\n-  __ bind(L);\n-#endif \/\/ ASSERT\n-  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(name,\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps, false);\n-  return stub->entry_point();\n-}\n-\n@@ -4090,11 +3895,0 @@\n-  \/\/ Build this early so it's available for the interpreter.\n-  StubRoutines::_throw_StackOverflowError_entry =\n-    generate_throw_exception(\"StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_StackOverflowError));\n-  StubRoutines::_throw_delayed_StackOverflowError_entry =\n-    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_delayed_StackOverflowError));\n@@ -4134,2 +3928,0 @@\n-\n-  JFR_ONLY(generate_jfr_stubs();)\n@@ -4138,9 +3930,0 @@\n-#if INCLUDE_JFR\n-void StubGenerator::generate_jfr_stubs() {\n-  StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-  StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-  StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-  StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-}\n-#endif\n-\n@@ -4150,21 +3933,0 @@\n-  \/\/ These entry points require SharedInfo::stack0 to be set up in\n-  \/\/ non-core builds and need to be relocatable, so they each\n-  \/\/ fabricate a RuntimeStub internally.\n-  StubRoutines::_throw_AbstractMethodError_entry =\n-    generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_AbstractMethodError));\n-\n-  StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_IncompatibleClassChangeError));\n-\n-  StubRoutines::_throw_NullPointerException_at_call_entry =\n-    generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":239,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -589,10 +589,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs();\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint();\n-  \/\/ For c2: call to runtime to return a buffer lease.\n-  RuntimeStub* generate_jfr_return_lease();\n-#endif \/\/ INCLUDE_JFR\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -548,2 +548,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-static RuntimeStub* generate_empty_runtime_stub(const char* name) {\n+static RuntimeStub* generate_empty_runtime_stub() {\n@@ -104,1 +104,0 @@\n-\n@@ -114,1 +113,5 @@\n-  return generate_empty_runtime_stub(\"resolve_blob\");\n+  return generate_empty_runtime_stub();\n+}\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  return generate_empty_runtime_stub();\n@@ -130,0 +133,12 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -206,16 +206,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds and need to be relocatable, so they each\n-    \/\/ fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      ShouldNotCallThisStub();\n-\n-    \/\/ support for verify_oop (must happen after universe_init)\n-    StubRoutines::_verify_oop_subroutine_entry =\n-      ShouldNotCallThisStub();\n-\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -330,2 +330,0 @@\n-  static_field(StubRoutines,                _throw_delayed_StackOverflowError_entry,          address)                               \\\n-                                                                                                                                     \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3170,1 +3170,1 @@\n-                                              StubRoutines::jfr_return_lease(),\n+                                              SharedRuntime::jfr_return_lease(),\n@@ -3369,1 +3369,1 @@\n-                                                  StubRoutines::jfr_write_checkpoint(),\n+                                                  SharedRuntime::jfr_write_checkpoint(),\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  \/\/ stub routines in initial blob are referenced by later generated code\n@@ -130,0 +131,2 @@\n+  \/\/ stack overflow exception blob is referenced by the interpreter\n+  SharedRuntime::generate_initial_stubs();\n@@ -147,0 +150,3 @@\n+#if INCLUDE_JFR\n+  SharedRuntime::generate_jfr_stubs();\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -89,1 +90,3 @@\n-\/\/ Shared stub locations\n+\/\/ Shared runtime stub routines reside in their own unique blob with a\n+\/\/ single entry point\n+\n@@ -96,1 +99,0 @@\n-address             SharedRuntime::_resolve_static_call_entry;\n@@ -103,0 +105,11 @@\n+RuntimeStub*        SharedRuntime::_throw_AbstractMethodError_blob;\n+RuntimeStub*        SharedRuntime::_throw_IncompatibleClassChangeError_blob;\n+RuntimeStub*        SharedRuntime::_throw_NullPointerException_at_call_blob;\n+RuntimeStub*        SharedRuntime::_throw_StackOverflowError_blob;\n+RuntimeStub*        SharedRuntime::_throw_delayed_StackOverflowError_blob;\n+\n+#if INCLUDE_JFR\n+RuntimeStub*        SharedRuntime::_jfr_write_checkpoint_blob = nullptr;\n+RuntimeStub*        SharedRuntime::_jfr_return_lease_blob = nullptr;\n+#endif\n+\n@@ -106,0 +119,7 @@\n+void SharedRuntime::generate_initial_stubs() {\n+  \/\/ Build this early so it's available for the interpreter.\n+  _throw_StackOverflowError_blob =\n+    generate_throw_exception(\"StackOverflowError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n+}\n+\n@@ -113,1 +133,16 @@\n-  _resolve_static_call_entry           = _resolve_static_call_blob->entry_point();\n+\n+  _throw_delayed_StackOverflowError_blob =\n+    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n+\n+  _throw_AbstractMethodError_blob =\n+    generate_throw_exception(\"AbstractMethodError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n+\n+  _throw_IncompatibleClassChangeError_blob =\n+    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n+\n+  _throw_NullPointerException_at_call_blob =\n+    generate_throw_exception(\"NullPointerException at call throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n@@ -130,0 +165,13 @@\n+#if INCLUDE_JFR\n+\/\/------------------------------generate jfr runtime stubs ------\n+void SharedRuntime::generate_jfr_stubs() {\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_jfr_stubs\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  _jfr_write_checkpoint_blob = generate_jfr_write_checkpoint();\n+  _jfr_return_lease_blob = generate_jfr_return_lease();\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -868,1 +916,1 @@\n-        return StubRoutines::throw_StackOverflowError_entry();\n+        return SharedRuntime::throw_StackOverflowError_entry();\n@@ -894,1 +942,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -915,1 +963,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -926,1 +974,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -932,1 +980,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -1468,1 +1516,1 @@\n-  address res = StubRoutines::throw_AbstractMethodError_entry();\n+  address res = SharedRuntime::throw_AbstractMethodError_entry();\n@@ -2388,1 +2436,1 @@\n-                                                                StubRoutines::throw_AbstractMethodError_entry(),\n+                                                                SharedRuntime::throw_AbstractMethodError_entry(),\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":58,"deletions":10,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  static address             _resolve_static_call_entry;\n@@ -67,0 +66,11 @@\n+  static RuntimeStub*        _throw_AbstractMethodError_blob;\n+  static RuntimeStub*        _throw_IncompatibleClassChangeError_blob;\n+  static RuntimeStub*        _throw_NullPointerException_at_call_blob;\n+  static RuntimeStub*        _throw_StackOverflowError_blob;\n+  static RuntimeStub*        _throw_delayed_StackOverflowError_blob;\n+\n+#if INCLUDE_JFR\n+  static RuntimeStub*        _jfr_write_checkpoint_blob;\n+  static RuntimeStub*        _jfr_return_lease_blob;\n+#endif\n+\n@@ -76,1 +86,1 @@\n-\n+  static RuntimeStub*   generate_throw_exception(const char* name, address runtime_entry);\n@@ -78,0 +88,1 @@\n+  static void generate_initial_stubs(void);\n@@ -79,0 +90,9 @@\n+#if INCLUDE_JFR\n+  static void generate_jfr_stubs(void);\n+  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+  \/\/ It returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  static RuntimeStub* generate_jfr_write_checkpoint();\n+  \/\/ For c2: call to runtime to return a buffer lease.\n+  static RuntimeStub* generate_jfr_return_lease();\n+#endif\n@@ -244,0 +264,12 @@\n+  \/\/ Implicit exceptions\n+  static address throw_AbstractMethodError_entry()          { return _throw_AbstractMethodError_blob->entry_point(); }\n+  static address throw_IncompatibleClassChangeError_entry() { return _throw_IncompatibleClassChangeError_blob->entry_point(); }\n+  static address throw_NullPointerException_at_call_entry() { return _throw_NullPointerException_at_call_blob->entry_point(); }\n+  static address throw_StackOverflowError_entry()           { return _throw_StackOverflowError_blob->entry_point(); }\n+  static address throw_delayed_StackOverflowError_entry()   { return _throw_delayed_StackOverflowError_blob->entry_point(); }\n+\n+#if INCLUDE_JFR\n+  static address jfr_write_checkpoint() { return _jfr_write_checkpoint_blob->entry_point(); }\n+  static address jfr_return_lease()     { return _jfr_return_lease_blob->entry_point(); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -64,5 +64,0 @@\n-address StubRoutines::_throw_AbstractMethodError_entry          = nullptr;\n-address StubRoutines::_throw_IncompatibleClassChangeError_entry = nullptr;\n-address StubRoutines::_throw_NullPointerException_at_call_entry = nullptr;\n-address StubRoutines::_throw_StackOverflowError_entry           = nullptr;\n-address StubRoutines::_throw_delayed_StackOverflowError_entry   = nullptr;\n@@ -194,5 +189,0 @@\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_write_checkpoint_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_write_checkpoint = nullptr;)\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_return_lease_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_return_lease = nullptr;)\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,28 @@\n-\/\/ points are defined in the platform-specific inner class.\n+\/\/ points are defined in the platform-specific inner class. Most\n+\/\/ routines have a single (main) entry point. However, a few routines\n+\/\/ do provide alternative entry points.\n+\/\/\n+\/\/ Stub routines whose entries are advertised via class StubRoutines\n+\/\/ are generated in batches at well-defined stages during JVM init:\n+\/\/ initial stubs, continuation stubs, compiler stubs, final stubs.\n+\/\/ Each batch is embedded in a single, associated blob (an instance of\n+\/\/ BufferBlob) i.e. the blob to entry relationship is 1-m.\n+\/\/\n+\/\/ Note that this constrasts with the much smaller number of stub\n+\/\/ routines generated via classes SharedRuntime, c1_Runtime1 and\n+\/\/ OptoRuntime. The latter routines are also generated at well-defined\n+\/\/ points during JVM init. However, each stub routine has its own\n+\/\/ unique blob (various subclasses of RuntimeBlob) i.e. the blob to\n+\/\/ entry relationship is 1-1. The difference arises because\n+\/\/ SharedRuntime routines may need to be relocatable or advertise\n+\/\/ properties such as a frame size via their blob.\n+\/\/\n+\/\/ Staging of stub routine generation is needed in order to manage\n+\/\/ init dependencies between 1) stubs and other stubs or 2) stubs and\n+\/\/ other runtime components. For example, some exception throw stubs\n+\/\/ need to be generated before compiler stubs (such as the\n+\/\/ deoptimization stub) so that the latter can invoke the thrwo rotine\n+\/\/ in bail-out code. Likewise, stubs that access objects (such as the\n+\/\/ object array copy stub) need to be created after initialization of\n+\/\/ some GC constants and generation of the GC barrier stubs they might\n+\/\/ need to invoke.\n@@ -52,2 +79,1 @@\n-\/\/    stubRoutines_<os_family>.cpp       stubGenerator_<arch>.cpp\n-\/\/    stubRoutines_<os_arch>.cpp\n+\/\/                                       stubGenerator_<arch>.cpp\n@@ -78,0 +104,2 @@\n+\/\/ 5. ensure the entry is generated in the right blob to satisfy initialization\n+\/\/    dependencies between it and other stubs or runtime components.\n@@ -140,5 +168,0 @@\n-  static address _throw_AbstractMethodError_entry;\n-  static address _throw_IncompatibleClassChangeError_entry;\n-  static address _throw_NullPointerException_at_call_entry;\n-  static address _throw_StackOverflowError_entry;\n-  static address _throw_delayed_StackOverflowError_entry;\n@@ -272,5 +295,0 @@\n-  JFR_ONLY(static RuntimeStub* _jfr_write_checkpoint_stub;)\n-  JFR_ONLY(static address _jfr_write_checkpoint;)\n-  JFR_ONLY(static RuntimeStub* _jfr_return_lease_stub;)\n-  JFR_ONLY(static address _jfr_return_lease;)\n-\n@@ -332,6 +350,0 @@\n-  \/\/ Implicit exceptions\n-  static address throw_AbstractMethodError_entry()         { return _throw_AbstractMethodError_entry; }\n-  static address throw_IncompatibleClassChangeError_entry(){ return _throw_IncompatibleClassChangeError_entry; }\n-  static address throw_NullPointerException_at_call_entry(){ return _throw_NullPointerException_at_call_entry; }\n-  static address throw_StackOverflowError_entry()          { return _throw_StackOverflowError_entry; }\n-  static address throw_delayed_StackOverflowError_entry()  { return _throw_delayed_StackOverflowError_entry; }\n@@ -490,3 +502,0 @@\n-  JFR_ONLY(static address jfr_write_checkpoint() { return _jfr_write_checkpoint; })\n-  JFR_ONLY(static address jfr_return_lease() { return _jfr_return_lease; })\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"}]}