{"files":[{"patch":"@@ -234,1 +234,1 @@\n-  return prepare_lambda_proxy_class(lambda_ik, caller_ik, THREAD);\n+  return load_and_init_lambda_proxy_class(lambda_ik, caller_ik, THREAD);\n@@ -317,2 +317,2 @@\n-InstanceKlass* LambdaProxyClassDictionary::prepare_lambda_proxy_class(InstanceKlass* lambda_ik,\n-                                                                      InstanceKlass* caller_ik, TRAPS) {\n+InstanceKlass* LambdaProxyClassDictionary::load_and_init_lambda_proxy_class(InstanceKlass* lambda_ik,\n+                                                                            InstanceKlass* caller_ik, TRAPS) {\n@@ -328,0 +328,1 @@\n+  assert(shared_nest_host->is_shared(), \"nest host must be in CDS archive\");\n@@ -329,4 +330,4 @@\n-  InstanceKlass* loaded_lambda =\n-    SystemDictionary::load_shared_lambda_proxy_class(lambda_ik, shared_nest_host, class_loader, protection_domain, pkg_entry, CHECK_NULL);\n-\n-  if (loaded_lambda == nullptr) {\n+  Klass* resolved_nest_host = SystemDictionary::resolve_or_fail(shared_nest_host->name(), class_loader, true, CHECK_NULL);\n+  if (resolved_nest_host != shared_nest_host) {\n+    \/\/ The dynamically resolved nest_host is not the same as the one we used during dump time,\n+    \/\/ so we cannot use lambda_ik.\n@@ -336,0 +337,18 @@\n+  {\n+    InstanceKlass* loaded_lambda =\n+      SystemDictionary::load_shared_class(lambda_ik, class_loader, protection_domain,\n+                                          nullptr, pkg_entry, CHECK_NULL);\n+    if (loaded_lambda != lambda_ik) {\n+      \/\/ changed by JVMTI\n+      return nullptr;\n+    }\n+  }\n+\n+  assert(shared_nest_host->is_same_class_package(lambda_ik),\n+         \"lambda proxy class and its nest host must be in the same package\");\n+  \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n+  \/\/ as verified in add_lambda_proxy_class()\n+  assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n+  assert(shared_nest_host->class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), \"mismatched class loader data\");\n+  lambda_ik->set_nest_host(shared_nest_host);\n+\n@@ -344,1 +363,1 @@\n-  loaded_lambda->add_to_hierarchy(THREAD);\n+  lambda_ik->add_to_hierarchy(THREAD);\n@@ -347,1 +366,1 @@\n-  loaded_lambda->link_class(CHECK_NULL);\n+  lambda_ik->link_class(CHECK_NULL);\n@@ -350,1 +369,1 @@\n-    JvmtiExport::post_class_load(THREAD, loaded_lambda);\n+    JvmtiExport::post_class_load(THREAD, lambda_ik);\n@@ -353,1 +372,1 @@\n-    SystemDictionary::post_class_load_event(&class_load_start_event, loaded_lambda, ClassLoaderData::class_loader_data(class_loader()));\n+    SystemDictionary::post_class_load_event(&class_load_start_event, lambda_ik, ClassLoaderData::class_loader_data(class_loader()));\n@@ -356,1 +375,1 @@\n-  loaded_lambda->initialize(CHECK_NULL);\n+  lambda_ik->initialize(CHECK_NULL);\n@@ -358,1 +377,1 @@\n-  return loaded_lambda;\n+  return lambda_ik;\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -285,2 +285,2 @@\n-  static InstanceKlass* prepare_lambda_proxy_class(InstanceKlass* lambda_ik,\n-                                                   InstanceKlass* caller_ik, TRAPS);\n+  static InstanceKlass* load_and_init_lambda_proxy_class(InstanceKlass* lambda_ik,\n+                                                         InstanceKlass* caller_ik, TRAPS);\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1076,33 +1076,0 @@\n-\/\/ *Legacy* optimization for lambdas before JEP 483. May be removed in the future.\n-InstanceKlass* SystemDictionary::load_shared_lambda_proxy_class(InstanceKlass* ik,\n-                                                                InstanceKlass* shared_nest_host,\n-                                                                Handle class_loader,\n-                                                                Handle protection_domain,\n-                                                                PackageEntry* pkg_entry,\n-                                                                TRAPS) {\n-  assert(shared_nest_host->is_shared(), \"nest host must be in CDS archive\");\n-  Symbol* cn = shared_nest_host->name();\n-  Klass *s = resolve_or_fail(cn, class_loader, true, CHECK_NULL);\n-  if (s != shared_nest_host) {\n-    \/\/ The dynamically resolved nest_host is not the same as the one we used during dump time,\n-    \/\/ so we cannot use ik.\n-    return nullptr;\n-  } else {\n-    assert(s->is_shared(), \"must be\");\n-  }\n-\n-  InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, nullptr, pkg_entry, CHECK_NULL);\n-\n-  if (loaded_ik != nullptr) {\n-    assert(shared_nest_host->is_same_class_package(ik),\n-           \"lambda proxy class and its nest host must be in the same package\");\n-    \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n-    \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n-    assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n-    assert(shared_nest_host->class_loader_data() == class_loader_data(class_loader), \"mismatched class loader data\");\n-    ik->set_nest_host(shared_nest_host);\n-  }\n-\n-  return loaded_ik;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -345,8 +345,0 @@\n-  \/\/ *Legacy* optimization for lambdas before JEP 483. May be removed in the future.\n-  static InstanceKlass* load_shared_lambda_proxy_class(InstanceKlass* ik,\n-                                                       InstanceKlass* shared_nest_host,\n-                                                       Handle class_loader,\n-                                                       Handle protection_domain,\n-                                                       PackageEntry* pkg_entry,\n-                                                       TRAPS);\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-extern Mutex*   CDSLambda_lock;                  \/\/ SystemDictionaryShared::get_shared_lambda_proxy_class\n+extern Mutex*   CDSLambda_lock;                  \/\/ LambdaProxyClassDictionary::find_lambda_proxy_class\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}