{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -117,1 +118,1 @@\n-        if (!CDSConfig::is_dumping_invokedynamic()) {\n+        if (CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n@@ -119,1 +120,1 @@\n-          if (SystemDictionaryShared::is_registered_lambda_proxy_class(ik)) {\n+          if (LambdaProxyClassDictionary::is_registered_lambda_proxy_class(ik)) {\n@@ -123,1 +124,1 @@\n-          assert(!SystemDictionaryShared::is_registered_lambda_proxy_class(ik),\n+          assert(!LambdaProxyClassDictionary::is_registered_lambda_proxy_class(ik),\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -354,1 +355,1 @@\n-    if (SystemDictionaryShared::is_supported_invokedynamic(bootstrap_specifier)) {\n+    if (LambdaProxyClassDictionary::is_supported_invokedynamic(bootstrap_specifier)) {\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -650,0 +650,5 @@\n+\/\/ This is *Legacy* optimization for lambdas before JEP 483. May be removed in the future.\n+bool CDSConfig::is_dumping_lambdas_in_legacy_mode() {\n+  return !is_dumping_method_handles();\n+}\n+\n@@ -655,1 +660,0 @@\n-\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  \/\/ This is *Legacy* optimization for lambdas before JEP 483. May be removed in the future.\n+  static bool is_dumping_lambdas_in_legacy_mode()            NOT_CDS_RETURN_(false);\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -660,1 +661,1 @@\n-      if (!SystemDictionaryShared::is_supported_invokedynamic(&bootstrap_specifier)) {\n+      if (!LambdaProxyClassDictionary::is_supported_invokedynamic(&bootstrap_specifier)) {\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -162,2 +163,4 @@\n-    log_info(cds)(\"Adjust lambda proxy class dictionary\");\n-    SystemDictionaryShared::adjust_lambda_proxy_class_dictionary();\n+    if (CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n+      log_info(cds)(\"Adjust lambda proxy class dictionary\");\n+      LambdaProxyClassDictionary::adjust_dumptime_table();\n+    }\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/cdsProtectionDomain.hpp\"\n@@ -28,0 +30,3 @@\n+#include \"interpreter\/bootstrapInfo.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n@@ -29,0 +34,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -85,0 +91,435 @@\n+\n+DumpTimeLambdaProxyClassDictionary* LambdaProxyClassDictionary::_dumptime_table = nullptr;\n+LambdaProxyClassDictionary LambdaProxyClassDictionary::_runtime_static_table; \/\/ for static CDS archive\n+LambdaProxyClassDictionary LambdaProxyClassDictionary::_runtime_dynamic_table; \/\/ for dynamic CDS archive\n+\n+void LambdaProxyClassDictionary::dumptime_init() {\n+  _dumptime_table = new (mtClass) DumpTimeLambdaProxyClassDictionary;\n+}\n+\n+bool LambdaProxyClassDictionary::is_supported_invokedynamic(BootstrapInfo* bsi) {\n+  LogTarget(Debug, cds, lambda) log;\n+  if (bsi->arg_values() == nullptr || !bsi->arg_values()->is_objArray()) {\n+    if (log.is_enabled()) {\n+      LogStream log_stream(log);\n+      log.print(\"bsi check failed\");\n+      log.print(\"    bsi->arg_values().not_null() %d\", bsi->arg_values().not_null());\n+      if (bsi->arg_values().not_null()) {\n+        log.print(\"    bsi->arg_values()->is_objArray() %d\", bsi->arg_values()->is_objArray());\n+        bsi->print_msg_on(&log_stream);\n+      }\n+    }\n+    return false;\n+  }\n+\n+  Handle bsm = bsi->bsm();\n+  if (bsm.is_null() || !java_lang_invoke_DirectMethodHandle::is_instance(bsm())) {\n+    if (log.is_enabled()) {\n+      log.print(\"bsm check failed\");\n+      log.print(\"    bsm.is_null() %d\", bsm.is_null());\n+      log.print(\"    java_lang_invoke_DirectMethodHandle::is_instance(bsm()) %d\",\n+        java_lang_invoke_DirectMethodHandle::is_instance(bsm()));\n+    }\n+    return false;\n+  }\n+\n+  oop mn = java_lang_invoke_DirectMethodHandle::member(bsm());\n+  Method* method = java_lang_invoke_MemberName::vmtarget(mn);\n+  if (method->klass_name()->equals(\"java\/lang\/invoke\/LambdaMetafactory\") &&\n+      method->name()->equals(\"metafactory\") &&\n+      method->signature()->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;\"\n+            \"Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;\"\n+            \"Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\")) {\n+      return true;\n+  } else {\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      log.print(\"method check failed\");\n+      log.print(\"    klass_name() %s\", method->klass_name()->as_C_string());\n+      log.print(\"    name() %s\", method->name()->as_C_string());\n+      log.print(\"    signature() %s\", method->signature()->as_C_string());\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+void LambdaProxyClassDictionary::add_lambda_proxy_class(InstanceKlass* caller_ik,\n+                                                        InstanceKlass* lambda_ik,\n+                                                        Symbol* invoked_name,\n+                                                        Symbol* invoked_type,\n+                                                        Symbol* method_type,\n+                                                        Method* member_method,\n+                                                        Symbol* instantiated_method_type,\n+                                                        TRAPS) {\n+  if (!CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n+    \/\/ The lambda proxy classes will be stored as part of aot-resolved constant pool entries.\n+    \/\/ There's no need to remember them in a separate table.\n+    return;\n+  }\n+\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    \/\/ Information about lambda proxies are recorded in FinalImageRecipes.\n+    return;\n+  }\n+\n+  assert(caller_ik->class_loader() == lambda_ik->class_loader(), \"mismatched class loader\");\n+  assert(caller_ik->class_loader_data() == lambda_ik->class_loader_data(), \"mismatched class loader data\");\n+  assert(java_lang_Class::class_data(lambda_ik->java_mirror()) == nullptr, \"must not have class data\");\n+\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+\n+  lambda_ik->assign_class_loader_type();\n+  lambda_ik->set_shared_classpath_index(caller_ik->shared_classpath_index());\n+  InstanceKlass* nest_host = caller_ik->nest_host(CHECK);\n+  assert(nest_host != nullptr, \"unexpected nullptr nest_host\");\n+\n+  DumpTimeClassInfo* info = SystemDictionaryShared::get_info_locked(lambda_ik);\n+  if (info != nullptr && !lambda_ik->is_non_strong_hidden() &&\n+      SystemDictionaryShared::is_builtin(lambda_ik) &&\n+      SystemDictionaryShared::is_builtin(caller_ik)\n+      \/\/ Don't include the lambda proxy if its nest host is not in the \"linked\" state.\n+      && nest_host->is_linked()) {\n+    \/\/ Set _is_registered_lambda_proxy in DumpTimeClassInfo so that the lambda_ik\n+    \/\/ won't be excluded during dumping of shared archive.\n+    info->_is_registered_lambda_proxy = true;\n+    info->set_nest_host(nest_host);\n+\n+    LambdaProxyClassKey key(caller_ik,\n+                            invoked_name,\n+                            invoked_type,\n+                            method_type,\n+                            member_method,\n+                            instantiated_method_type);\n+    add_to_dumptime_table(key, lambda_ik);\n+  }\n+}\n+\n+bool LambdaProxyClassDictionary::is_registered_lambda_proxy_class(InstanceKlass* ik) {\n+  DumpTimeClassInfo* info = SystemDictionaryShared::get_info_locked(ik);\n+  bool result = (info != nullptr) ? info->_is_registered_lambda_proxy : false;\n+  if (result) {\n+    assert(CDSConfig::is_dumping_lambdas_in_legacy_mode(), \"only used in legacy lambda proxy support\");\n+  }\n+  return result;\n+}\n+\n+void LambdaProxyClassDictionary::reset_registered_lambda_proxy_class(InstanceKlass* ik) {\n+  DumpTimeClassInfo* info = SystemDictionaryShared::get_info_locked(ik);\n+  if (info != nullptr) {\n+    info->_is_registered_lambda_proxy = false;\n+    info->set_excluded();\n+  }\n+}\n+\n+InstanceKlass* LambdaProxyClassDictionary::get_shared_nest_host(InstanceKlass* lambda_ik) {\n+  assert(!CDSConfig::is_dumping_static_archive() && CDSConfig::is_using_archive(), \"called at run time with CDS enabled only\");\n+  RunTimeClassInfo* record = RunTimeClassInfo::get_for(lambda_ik);\n+  return record->nest_host();\n+}\n+\n+InstanceKlass* LambdaProxyClassDictionary::load_shared_lambda_proxy_class(InstanceKlass* caller_ik,\n+                                                                          Symbol* invoked_name,\n+                                                                          Symbol* invoked_type,\n+                                                                          Symbol* method_type,\n+                                                                          Method* member_method,\n+                                                                          Symbol* instantiated_method_type,\n+                                                                          TRAPS)\n+{\n+  InstanceKlass* lambda_ik = find_lambda_proxy_class(caller_ik, invoked_name, invoked_type,\n+                                                     method_type, member_method, instantiated_method_type);\n+  if (lambda_ik == nullptr) {\n+    return nullptr;\n+  }\n+  return load_and_init_lambda_proxy_class(lambda_ik, caller_ik, THREAD);\n+}\n+\n+InstanceKlass* LambdaProxyClassDictionary::find_lambda_proxy_class(InstanceKlass* caller_ik,\n+                                                                   Symbol* invoked_name,\n+                                                                   Symbol* invoked_type,\n+                                                                   Symbol* method_type,\n+                                                                   Method* member_method,\n+                                                                   Symbol* instantiated_method_type)\n+{\n+  assert(caller_ik != nullptr, \"sanity\");\n+  assert(invoked_name != nullptr, \"sanity\");\n+  assert(invoked_type != nullptr, \"sanity\");\n+  assert(method_type != nullptr, \"sanity\");\n+  assert(instantiated_method_type != nullptr, \"sanity\");\n+\n+  if (!caller_ik->is_shared()     ||\n+      !invoked_name->is_shared()  ||\n+      !invoked_type->is_shared()  ||\n+      !method_type->is_shared()   ||\n+      (member_method != nullptr && !member_method->is_shared()) ||\n+      !instantiated_method_type->is_shared()) {\n+    \/\/ These can't be represented as u4 offset, but we wouldn't have archived a lambda proxy in this case anyway.\n+    return nullptr;\n+  }\n+\n+  MutexLocker ml(CDSLambda_lock, Mutex::_no_safepoint_check_flag);\n+  RunTimeLambdaProxyClassKey key =\n+    RunTimeLambdaProxyClassKey::init_for_runtime(caller_ik, invoked_name, invoked_type,\n+                                                 method_type, member_method, instantiated_method_type);\n+\n+  unsigned hash = key.hash();\n+  \/\/ Try to retrieve the lambda proxy class from static archive.\n+  const RunTimeLambdaProxyClassInfo* info = _runtime_static_table.lookup(&key, hash, 0);\n+  InstanceKlass* proxy_klass = find_lambda_proxy_class(info);\n+  if (proxy_klass == nullptr) {\n+    if (info != nullptr && log_is_enabled(Debug, cds)) {\n+      ResourceMark rm;\n+      log_debug(cds)(\"Used all static archived lambda proxy classes for: %s %s%s\",\n+                     caller_ik->external_name(), invoked_name->as_C_string(), invoked_type->as_C_string());\n+    }\n+  } else {\n+    return proxy_klass;\n+  }\n+\n+  \/\/ Retrieving from static archive is unsuccessful, try dynamic archive.\n+  info = _runtime_dynamic_table.lookup(&key, hash, 0);\n+  proxy_klass = find_lambda_proxy_class(info);\n+  if (proxy_klass == nullptr) {\n+    if (info != nullptr && log_is_enabled(Debug, cds)) {\n+      ResourceMark rm;\n+      log_debug(cds)(\"Used all dynamic archived lambda proxy classes for: %s %s%s\",\n+                     caller_ik->external_name(), invoked_name->as_C_string(), invoked_type->as_C_string());\n+    }\n+  }\n+  return proxy_klass;\n+}\n+\n+InstanceKlass* LambdaProxyClassDictionary::find_lambda_proxy_class(const RunTimeLambdaProxyClassInfo* info) {\n+  InstanceKlass* proxy_klass = nullptr;\n+  if (info != nullptr) {\n+    InstanceKlass* curr_klass = info->proxy_klass_head();\n+    InstanceKlass* prev_klass = curr_klass;\n+    if (curr_klass->lambda_proxy_is_available()) {\n+      while (curr_klass->next_link() != nullptr) {\n+        prev_klass = curr_klass;\n+        curr_klass = InstanceKlass::cast(curr_klass->next_link());\n+      }\n+      assert(curr_klass->is_hidden(), \"must be\");\n+      assert(curr_klass->lambda_proxy_is_available(), \"must be\");\n+\n+      prev_klass->set_next_link(nullptr);\n+      proxy_klass = curr_klass;\n+      proxy_klass->clear_lambda_proxy_is_available();\n+      if (log_is_enabled(Debug, cds)) {\n+        ResourceMark rm;\n+        log_debug(cds)(\"Loaded lambda proxy: %s \", proxy_klass->external_name());\n+      }\n+    }\n+  }\n+  return proxy_klass;\n+}\n+\n+InstanceKlass* LambdaProxyClassDictionary::load_and_init_lambda_proxy_class(InstanceKlass* lambda_ik,\n+                                                                            InstanceKlass* caller_ik, TRAPS) {\n+  Handle class_loader(THREAD, caller_ik->class_loader());\n+  Handle protection_domain;\n+  PackageEntry* pkg_entry = caller_ik->package();\n+  if (caller_ik->class_loader() != nullptr) {\n+    protection_domain = CDSProtectionDomain::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);\n+  }\n+\n+  InstanceKlass* shared_nest_host = get_shared_nest_host(lambda_ik);\n+  assert(shared_nest_host != nullptr, \"unexpected nullptr _nest_host\");\n+  assert(shared_nest_host->is_shared(), \"nest host must be in CDS archive\");\n+\n+  Klass* resolved_nest_host = SystemDictionary::resolve_or_fail(shared_nest_host->name(), class_loader, true, CHECK_NULL);\n+  if (resolved_nest_host != shared_nest_host) {\n+    \/\/ The dynamically resolved nest_host is not the same as the one we used during dump time,\n+    \/\/ so we cannot use lambda_ik.\n+    return nullptr;\n+  }\n+\n+  {\n+    InstanceKlass* loaded_lambda =\n+      SystemDictionary::load_shared_class(lambda_ik, class_loader, protection_domain,\n+                                          nullptr, pkg_entry, CHECK_NULL);\n+    if (loaded_lambda != lambda_ik) {\n+      \/\/ changed by JVMTI\n+      return nullptr;\n+    }\n+  }\n+\n+  assert(shared_nest_host->is_same_class_package(lambda_ik),\n+         \"lambda proxy class and its nest host must be in the same package\");\n+  \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n+  \/\/ as verified in add_lambda_proxy_class()\n+  assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n+  assert(shared_nest_host->class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), \"mismatched class loader data\");\n+  lambda_ik->set_nest_host(shared_nest_host);\n+\n+  \/\/ Ensures the nest host is the same as the lambda proxy's\n+  \/\/ nest host recorded at dump time.\n+  InstanceKlass* nest_host = caller_ik->nest_host(THREAD);\n+  assert(nest_host == shared_nest_host, \"mismatched nest host\");\n+\n+  EventClassLoad class_load_start_event;\n+\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  lambda_ik->add_to_hierarchy(THREAD);\n+  \/\/ But, do not add to dictionary.\n+\n+  lambda_ik->link_class(CHECK_NULL);\n+  \/\/ notify jvmti\n+  if (JvmtiExport::should_post_class_load()) {\n+    JvmtiExport::post_class_load(THREAD, lambda_ik);\n+  }\n+  if (class_load_start_event.should_commit()) {\n+    SystemDictionary::post_class_load_event(&class_load_start_event, lambda_ik, ClassLoaderData::class_loader_data(class_loader()));\n+  }\n+\n+  lambda_ik->initialize(CHECK_NULL);\n+\n+  return lambda_ik;\n+}\n+\n+void LambdaProxyClassDictionary::dumptime_classes_do(MetaspaceClosure* it) {\n+  _dumptime_table->iterate_all([&] (LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    if (key.caller_ik()->is_loader_alive()) {\n+      info.metaspace_pointers_do(it);\n+      key.metaspace_pointers_do(it);\n+    }\n+  });\n+}\n+\n+void LambdaProxyClassDictionary::add_to_dumptime_table(LambdaProxyClassKey& key,\n+                                                       InstanceKlass* proxy_klass) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+\n+  bool created;\n+  DumpTimeLambdaProxyClassInfo* info = _dumptime_table->put_if_absent(key, &created);\n+  info->add_proxy_klass(proxy_klass);\n+  if (created) {\n+    ++_dumptime_table->_count;\n+  }\n+}\n+\n+class CopyLambdaProxyClassInfoToArchive : StackObj {\n+  CompactHashtableWriter* _writer;\n+  ArchiveBuilder* _builder;\n+public:\n+  CopyLambdaProxyClassInfoToArchive(CompactHashtableWriter* writer)\n+  : _writer(writer), _builder(ArchiveBuilder::current()) {}\n+  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    \/\/ In static dump, info._proxy_klasses->at(0) is already relocated to point to the archived class\n+    \/\/ (not the original class).\n+    ResourceMark rm;\n+    log_info(cds,dynamic)(\"Archiving hidden %s\", info._proxy_klasses->at(0)->external_name());\n+    size_t byte_size = sizeof(RunTimeLambdaProxyClassInfo);\n+    RunTimeLambdaProxyClassInfo* runtime_info =\n+        (RunTimeLambdaProxyClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n+    runtime_info->init(key, info);\n+    unsigned int hash = runtime_info->hash();\n+    u4 delta = _builder->any_to_offset_u4((void*)runtime_info);\n+    _writer->add(hash, delta);\n+    return true;\n+  }\n+};\n+\n+void LambdaProxyClassDictionary::write_dictionary(bool is_static_archive) {\n+  LambdaProxyClassDictionary* dictionary = is_static_archive ? &_runtime_static_table : &_runtime_dynamic_table;\n+  CompactHashtableStats stats;\n+  dictionary->reset();\n+  CompactHashtableWriter writer(_dumptime_table->_count, &stats);\n+  CopyLambdaProxyClassInfoToArchive copy(&writer);\n+  _dumptime_table->iterate(&copy);\n+  writer.dump(dictionary, \"lambda proxy class dictionary\");\n+}\n+\n+class AdjustLambdaProxyClassInfo : StackObj {\n+public:\n+  AdjustLambdaProxyClassInfo() {}\n+  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    int len = info._proxy_klasses->length();\n+    InstanceKlass* last_buff_k = nullptr;\n+\n+    for (int i = len - 1; i >= 0; i--) {\n+      InstanceKlass* orig_k = info._proxy_klasses->at(i);\n+      InstanceKlass* buff_k = ArchiveBuilder::current()->get_buffered_addr(orig_k);\n+      assert(ArchiveBuilder::current()->is_in_buffer_space(buff_k), \"must be\");\n+      buff_k->set_lambda_proxy_is_available();\n+      buff_k->set_next_link(last_buff_k);\n+      if (last_buff_k != nullptr) {\n+        ArchivePtrMarker::mark_pointer(buff_k->next_link_addr());\n+      }\n+      last_buff_k = buff_k;\n+    }\n+\n+    return true;\n+  }\n+};\n+\n+void LambdaProxyClassDictionary::adjust_dumptime_table() {\n+  AdjustLambdaProxyClassInfo adjuster;\n+  _dumptime_table->iterate(&adjuster);\n+}\n+\n+class LambdaProxyClassDictionary::CleanupDumpTimeLambdaProxyClassTable: StackObj {\n+ public:\n+  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    assert_lock_strong(DumpTimeTable_lock);\n+    InstanceKlass* caller_ik = key.caller_ik();\n+    InstanceKlass* nest_host = caller_ik->nest_host_not_null();\n+\n+    \/\/ If the caller class and\/or nest_host are excluded, the associated lambda proxy\n+    \/\/ must also be excluded.\n+    bool always_exclude = SystemDictionaryShared::check_for_exclusion(caller_ik, nullptr) ||\n+                          SystemDictionaryShared::check_for_exclusion(nest_host, nullptr);\n+\n+    for (int i = info._proxy_klasses->length() - 1; i >= 0; i--) {\n+      InstanceKlass* ik = info._proxy_klasses->at(i);\n+      if (always_exclude || SystemDictionaryShared::check_for_exclusion(ik, nullptr)) {\n+        LambdaProxyClassDictionary::reset_registered_lambda_proxy_class(ik);\n+        info._proxy_klasses->remove_at(i);\n+      }\n+    }\n+    return info._proxy_klasses->length() == 0 ? true \/* delete the node*\/ : false;\n+  }\n+};\n+\n+void LambdaProxyClassDictionary::cleanup_dumptime_table() {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  CleanupDumpTimeLambdaProxyClassTable cleanup_proxy_classes;\n+  _dumptime_table->unlink(&cleanup_proxy_classes);\n+}\n+\n+class SharedLambdaDictionaryPrinter : StackObj {\n+  outputStream* _st;\n+  int _index;\n+public:\n+  SharedLambdaDictionaryPrinter(outputStream* st, int idx) : _st(st), _index(idx) {}\n+\n+  void do_value(const RunTimeLambdaProxyClassInfo* record) {\n+    if (record->proxy_klass_head()->lambda_proxy_is_available()) {\n+      ResourceMark rm;\n+      Klass* k = record->proxy_klass_head();\n+      while (k != nullptr) {\n+        _st->print_cr(\"%4d: %s %s\", _index++, k->external_name(),\n+                      SystemDictionaryShared::loader_type_for_shared_class(k));\n+        k = k->next_link();\n+      }\n+    }\n+  }\n+};\n+\n+void LambdaProxyClassDictionary::print_on(const char* prefix,\n+                                          outputStream* st,\n+                                          int start_index,\n+                                          bool is_static_archive) {\n+  LambdaProxyClassDictionary* dictionary = is_static_archive ? &_runtime_static_table : &_runtime_dynamic_table;\n+  if (!dictionary->empty()) {\n+    st->print_cr(\"%sShared Lambda Dictionary\", prefix);\n+    SharedLambdaDictionaryPrinter ldp(st, start_index);\n+    dictionary->iterate(&ldp);\n+  }\n+}\n+\n+void LambdaProxyClassDictionary::print_statistics(outputStream* st,\n+                                                        bool is_static_archive) {\n+  LambdaProxyClassDictionary* dictionary = is_static_archive ? &_runtime_static_table : &_runtime_dynamic_table;\n+  dictionary->print_table_statistics(st, \"Lambda Shared Dictionary\");\n+}\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":441,"deletions":0,"binary":false,"changes":441,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -29,0 +31,1 @@\n+#include \"memory\/metaspaceClosure.hpp\"\n@@ -32,0 +35,14 @@\n+\/\/ This file contains *legacy* optimization for lambdas before JEP 483. May be removed in the future.\n+\/\/\n+\/\/ The functionalties in this file are used only when CDSConfig::is_dumping_lambdas_in_legacy_mode()\n+\/\/ returns true during the creation of a CDS archive.\n+\/\/\n+\/\/ With the legacy optimization, generated lambda proxy classes (with names such as\n+\/\/ java.util.ResourceBundle$Control$$Lambda\/0x80000001d) are stored inside the CDS archive, accessible\n+\/\/ by LambdaProxyClassDictionary::find_proxy_class(). This saves part of the time for resolving a\n+\/\/ lambda call site (proxy class generation). However, a significant portion of the cost of\n+\/\/ the lambda call site resolution still remains in the production run.\n+\/\/\n+\/\/ In contrast, with JEP 483, the entire lambda call site (starting from the constant pool entry), is\n+\/\/ resolved in the AOT cache assembly phase. No extra resolution is needed in the production run.\n+\n@@ -34,0 +51,1 @@\n+class MetaspaceClosure;\n@@ -246,0 +264,1 @@\n+\/\/ *Legacy* optimization for lambdas before JEP 483. May be removed in the future.\n@@ -249,1 +268,66 @@\n-  RunTimeLambdaProxyClassInfo::EQUALS> {};\n+  RunTimeLambdaProxyClassInfo::EQUALS>\n+{\n+private:\n+  class CleanupDumpTimeLambdaProxyClassTable;\n+  static DumpTimeLambdaProxyClassDictionary* _dumptime_table;\n+  static LambdaProxyClassDictionary _runtime_static_table; \/\/ for static CDS archive\n+  static LambdaProxyClassDictionary _runtime_dynamic_table; \/\/ for dynamic CDS archive\n+\n+  static void add_to_dumptime_table(LambdaProxyClassKey& key,\n+                                    InstanceKlass* proxy_klass);\n+  static InstanceKlass* find_lambda_proxy_class(const RunTimeLambdaProxyClassInfo* info);\n+  static InstanceKlass* find_lambda_proxy_class(InstanceKlass* caller_ik,\n+                                                Symbol* invoked_name,\n+                                                Symbol* invoked_type,\n+                                                Symbol* method_type,\n+                                                Method* member_method,\n+                                                Symbol* instantiated_method_type);\n+  static InstanceKlass* load_and_init_lambda_proxy_class(InstanceKlass* lambda_ik,\n+                                                         InstanceKlass* caller_ik, TRAPS);\n+  static void reset_registered_lambda_proxy_class(InstanceKlass* ik);\n+  static InstanceKlass* get_shared_nest_host(InstanceKlass* lambda_ik);\n+\n+public:\n+  static void dumptime_init();\n+  static void dumptime_classes_do(MetaspaceClosure* it);\n+  static void add_lambda_proxy_class(InstanceKlass* caller_ik,\n+                                     InstanceKlass* lambda_ik,\n+                                     Symbol* invoked_name,\n+                                     Symbol* invoked_type,\n+                                     Symbol* method_type,\n+                                     Method* member_method,\n+                                     Symbol* instantiated_method_type,\n+                                     TRAPS);\n+  static bool is_supported_invokedynamic(BootstrapInfo* bsi);\n+  static bool is_registered_lambda_proxy_class(InstanceKlass* ik);\n+  static InstanceKlass* load_shared_lambda_proxy_class(InstanceKlass* caller_ik,\n+                                                       Symbol* invoked_name,\n+                                                       Symbol* invoked_type,\n+                                                       Symbol* method_type,\n+                                                       Method* member_method,\n+                                                       Symbol* instantiated_method_type,\n+                                                       TRAPS);\n+  static void write_dictionary(bool is_static_archive);\n+  static void adjust_dumptime_table();\n+  static void cleanup_dumptime_table();\n+\n+  static void reset_dictionary(bool is_static_archive) {\n+    if (is_static_archive) {\n+      _runtime_static_table.reset();\n+    } else {\n+      _runtime_dynamic_table.reset();\n+    }\n+  }\n+\n+  static void serialize(SerializeClosure* soc, bool is_static_archive) {\n+    if (is_static_archive) {\n+      _runtime_static_table.serialize_header(soc);\n+    } else {\n+      _runtime_dynamic_table.serialize_header(soc);\n+    }\n+  }\n+\n+  static void print_on(const char* prefix, outputStream* st,\n+                       int start_index, bool is_static_archive);\n+  static void print_statistics(outputStream* st,  bool is_static_archive);\n+};\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":86,"deletions":2,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -663,1 +664,4 @@\n-  SystemDictionaryShared::adjust_lambda_proxy_class_dictionary();\n+  if (CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n+    log_info(cds)(\"Adjust lambda proxy class dictionary\");\n+    LambdaProxyClassDictionary::adjust_dumptime_table();\n+  }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5456,1 +5456,1 @@\n-    \/\/ These are supported by CDS only when CDSConfig::is_dumping_invokedynamic() is enabled.\n+    \/\/ These are supported by CDS only when CDSConfig::is_dumping_method_handles() is enabled.\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1076,32 +1076,0 @@\n-InstanceKlass* SystemDictionary::load_shared_lambda_proxy_class(InstanceKlass* ik,\n-                                                                Handle class_loader,\n-                                                                Handle protection_domain,\n-                                                                PackageEntry* pkg_entry,\n-                                                                TRAPS) {\n-  InstanceKlass* shared_nest_host = SystemDictionaryShared::get_shared_nest_host(ik);\n-  assert(shared_nest_host->is_shared(), \"nest host must be in CDS archive\");\n-  Symbol* cn = shared_nest_host->name();\n-  Klass *s = resolve_or_fail(cn, class_loader, true, CHECK_NULL);\n-  if (s != shared_nest_host) {\n-    \/\/ The dynamically resolved nest_host is not the same as the one we used during dump time,\n-    \/\/ so we cannot use ik.\n-    return nullptr;\n-  } else {\n-    assert(s->is_shared(), \"must be\");\n-  }\n-\n-  InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, nullptr, pkg_entry, CHECK_NULL);\n-\n-  if (loaded_ik != nullptr) {\n-    assert(shared_nest_host->is_same_class_package(ik),\n-           \"lambda proxy class and its nest host must be in the same package\");\n-    \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n-    \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n-    assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n-    assert(shared_nest_host->class_loader_data() == class_loader_data(class_loader), \"mismatched class loader data\");\n-    ik->set_nest_host(shared_nest_host);\n-  }\n-\n-  return loaded_ik;\n-}\n-\n@@ -1115,0 +1083,1 @@\n+  assert(ik->is_shared(), \"sanity\");\n@@ -1133,1 +1102,1 @@\n-  if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {\n+  if (!ik->is_hidden()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":33,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  friend class LambdaProxyClassDictionary;\n@@ -328,1 +329,1 @@\n-  \/\/ Used by SystemDictionaryShared\n+  \/\/ Used by SystemDictionaryShared and LambdaProxyClassDictionary\n@@ -333,5 +334,0 @@\n-  static InstanceKlass* load_shared_lambda_proxy_class(InstanceKlass* ik,\n-                                                       Handle class_loader,\n-                                                       Handle protection_domain,\n-                                                       PackageEntry* pkg_entry,\n-                                                       TRAPS);\n@@ -348,0 +344,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -54,1 +55,0 @@\n-#include \"interpreter\/bootstrapInfo.hpp\"\n@@ -84,1 +84,0 @@\n-DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_dumptime_lambda_proxy_class_dictionary = nullptr;\n@@ -246,17 +245,0 @@\n-bool SystemDictionaryShared::is_registered_lambda_proxy_class(InstanceKlass* ik) {\n-  DumpTimeClassInfo* info = _dumptime_table->get(ik);\n-  bool result = (info != nullptr) ? info->_is_registered_lambda_proxy : false;\n-  if (result) {\n-    assert(!CDSConfig::is_dumping_invokedynamic(), \"only used in legacy lambda proxy support\");\n-  }\n-  return result;\n-}\n-\n-void SystemDictionaryShared::reset_registered_lambda_proxy_class(InstanceKlass* ik) {\n-  DumpTimeClassInfo* info = _dumptime_table->get(ik);\n-  if (info != nullptr) {\n-    info->_is_registered_lambda_proxy = false;\n-    info->set_excluded();\n-  }\n-}\n-\n@@ -268,9 +250,0 @@\n-bool SystemDictionaryShared::is_hidden_lambda_proxy(InstanceKlass* ik) {\n-  assert(ik->is_shared(), \"applicable to only a shared class\");\n-  if (ik->is_hidden()) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n@@ -505,2 +478,1 @@\n-    _dumptime_lambda_proxy_class_dictionary =\n-                      new (mtClass) DumpTimeLambdaProxyClassDictionary;\n+    LambdaProxyClassDictionary::dumptime_init();\n@@ -590,2 +562,2 @@\n-      if (!CDSConfig::is_dumping_method_handles()) {\n-        assert(is_registered_lambda_proxy_class(k), \"unexpected hidden class %s\", name);\n+      if (CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n+        assert(LambdaProxyClassDictionary::is_registered_lambda_proxy_class(k), \"unexpected hidden class %s\", name);\n@@ -708,1 +680,3 @@\n-  cleanup_lambda_proxy_class_dictionary();\n+  if (CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n+    LambdaProxyClassDictionary::cleanup_dumptime_table();\n+  }\n@@ -744,1 +718,1 @@\n-void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {\n+void SystemDictionaryShared::dumptime_classes_do(MetaspaceClosure* it) {\n@@ -757,7 +731,3 @@\n-  auto do_lambda = [&] (LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    if (key.caller_ik()->is_loader_alive()) {\n-      info.metaspace_pointers_do(it);\n-      key.metaspace_pointers_do(it);\n-    }\n-  };\n-  _dumptime_lambda_proxy_class_dictionary->iterate_all(do_lambda);\n+  if (CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n+    LambdaProxyClassDictionary::dumptime_classes_do(it);\n+  }\n@@ -798,192 +768,0 @@\n-void SystemDictionaryShared::add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey& key,\n-                                                           InstanceKlass* proxy_klass) {\n-  assert_lock_strong(DumpTimeTable_lock);\n-\n-  bool created;\n-  DumpTimeLambdaProxyClassInfo* info = _dumptime_lambda_proxy_class_dictionary->put_if_absent(key, &created);\n-  info->add_proxy_klass(proxy_klass);\n-  if (created) {\n-    ++_dumptime_lambda_proxy_class_dictionary->_count;\n-  }\n-}\n-\n-void SystemDictionaryShared::add_lambda_proxy_class(InstanceKlass* caller_ik,\n-                                                    InstanceKlass* lambda_ik,\n-                                                    Symbol* invoked_name,\n-                                                    Symbol* invoked_type,\n-                                                    Symbol* method_type,\n-                                                    Method* member_method,\n-                                                    Symbol* instantiated_method_type,\n-                                                    TRAPS) {\n-  if (CDSConfig::is_dumping_invokedynamic()) {\n-    \/\/ The lambda proxy classes will be stored as part of aot-resolved constant pool entries.\n-    \/\/ There's no need to remember them in a separate table.\n-    return;\n-  }\n-  if (CDSConfig::is_dumping_preimage_static_archive()) {\n-    \/\/ Information about lambda proxies are recorded in FinalImageRecipes.\n-    return;\n-  }\n-\n-  assert(caller_ik->class_loader() == lambda_ik->class_loader(), \"mismatched class loader\");\n-  assert(caller_ik->class_loader_data() == lambda_ik->class_loader_data(), \"mismatched class loader data\");\n-  assert(java_lang_Class::class_data(lambda_ik->java_mirror()) == nullptr, \"must not have class data\");\n-\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-\n-  lambda_ik->assign_class_loader_type();\n-  lambda_ik->set_shared_classpath_index(caller_ik->shared_classpath_index());\n-  InstanceKlass* nest_host = caller_ik->nest_host(CHECK);\n-  assert(nest_host != nullptr, \"unexpected nullptr nest_host\");\n-\n-  DumpTimeClassInfo* info = _dumptime_table->get(lambda_ik);\n-  if (info != nullptr && !lambda_ik->is_non_strong_hidden() && is_builtin(lambda_ik) && is_builtin(caller_ik)\n-      \/\/ Don't include the lambda proxy if its nest host is not in the \"linked\" state.\n-      && nest_host->is_linked()) {\n-    \/\/ Set _is_registered_lambda_proxy in DumpTimeClassInfo so that the lambda_ik\n-    \/\/ won't be excluded during dumping of shared archive.\n-    info->_is_registered_lambda_proxy = true;\n-    info->set_nest_host(nest_host);\n-\n-    LambdaProxyClassKey key(caller_ik,\n-                            invoked_name,\n-                            invoked_type,\n-                            method_type,\n-                            member_method,\n-                            instantiated_method_type);\n-    add_to_dump_time_lambda_proxy_class_dictionary(key, lambda_ik);\n-  }\n-}\n-\n-InstanceKlass* SystemDictionaryShared::get_shared_lambda_proxy_class(InstanceKlass* caller_ik,\n-                                                                     Symbol* invoked_name,\n-                                                                     Symbol* invoked_type,\n-                                                                     Symbol* method_type,\n-                                                                     Method* member_method,\n-                                                                     Symbol* instantiated_method_type) {\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    return nullptr;\n-  }\n-\n-  assert(caller_ik != nullptr, \"sanity\");\n-  assert(invoked_name != nullptr, \"sanity\");\n-  assert(invoked_type != nullptr, \"sanity\");\n-  assert(method_type != nullptr, \"sanity\");\n-  assert(instantiated_method_type != nullptr, \"sanity\");\n-\n-  if (!caller_ik->is_shared()     ||\n-      !invoked_name->is_shared()  ||\n-      !invoked_type->is_shared()  ||\n-      !method_type->is_shared()   ||\n-      (member_method != nullptr && !member_method->is_shared()) ||\n-      !instantiated_method_type->is_shared()) {\n-    \/\/ These can't be represented as u4 offset, but we wouldn't have archived a lambda proxy in this case anyway.\n-    return nullptr;\n-  }\n-\n-  MutexLocker ml(CDSLambda_lock, Mutex::_no_safepoint_check_flag);\n-  RunTimeLambdaProxyClassKey key =\n-    RunTimeLambdaProxyClassKey::init_for_runtime(caller_ik, invoked_name, invoked_type,\n-                                                 method_type, member_method, instantiated_method_type);\n-\n-  \/\/ Try to retrieve the lambda proxy class from static archive.\n-  const RunTimeLambdaProxyClassInfo* info = _static_archive.lookup_lambda_proxy_class(&key);\n-  InstanceKlass* proxy_klass = retrieve_lambda_proxy_class(info);\n-  if (proxy_klass == nullptr) {\n-    if (info != nullptr && log_is_enabled(Debug, cds)) {\n-      ResourceMark rm;\n-      log_debug(cds)(\"Used all static archived lambda proxy classes for: %s %s%s\",\n-                     caller_ik->external_name(), invoked_name->as_C_string(), invoked_type->as_C_string());\n-    }\n-  } else {\n-    return proxy_klass;\n-  }\n-\n-  \/\/ Retrieving from static archive is unsuccessful, try dynamic archive.\n-  info = _dynamic_archive.lookup_lambda_proxy_class(&key);\n-  proxy_klass = retrieve_lambda_proxy_class(info);\n-  if (proxy_klass == nullptr) {\n-    if (info != nullptr && log_is_enabled(Debug, cds)) {\n-      ResourceMark rm;\n-      log_debug(cds)(\"Used all dynamic archived lambda proxy classes for: %s %s%s\",\n-                     caller_ik->external_name(), invoked_name->as_C_string(), invoked_type->as_C_string());\n-    }\n-  }\n-  return proxy_klass;\n-}\n-\n-InstanceKlass* SystemDictionaryShared::retrieve_lambda_proxy_class(const RunTimeLambdaProxyClassInfo* info) {\n-  InstanceKlass* proxy_klass = nullptr;\n-  if (info != nullptr) {\n-    InstanceKlass* curr_klass = info->proxy_klass_head();\n-    InstanceKlass* prev_klass = curr_klass;\n-    if (curr_klass->lambda_proxy_is_available()) {\n-      while (curr_klass->next_link() != nullptr) {\n-        prev_klass = curr_klass;\n-        curr_klass = InstanceKlass::cast(curr_klass->next_link());\n-      }\n-      assert(curr_klass->is_hidden(), \"must be\");\n-      assert(curr_klass->lambda_proxy_is_available(), \"must be\");\n-\n-      prev_klass->set_next_link(nullptr);\n-      proxy_klass = curr_klass;\n-      proxy_klass->clear_lambda_proxy_is_available();\n-      if (log_is_enabled(Debug, cds)) {\n-        ResourceMark rm;\n-        log_debug(cds)(\"Loaded lambda proxy: %s \", proxy_klass->external_name());\n-      }\n-    }\n-  }\n-  return proxy_klass;\n-}\n-\n-InstanceKlass* SystemDictionaryShared::get_shared_nest_host(InstanceKlass* lambda_ik) {\n-  assert(!CDSConfig::is_dumping_static_archive() && CDSConfig::is_using_archive(), \"called at run time with CDS enabled only\");\n-  RunTimeClassInfo* record = RunTimeClassInfo::get_for(lambda_ik);\n-  return record->nest_host();\n-}\n-\n-InstanceKlass* SystemDictionaryShared::prepare_shared_lambda_proxy_class(InstanceKlass* lambda_ik,\n-                                                                         InstanceKlass* caller_ik, TRAPS) {\n-  Handle class_loader(THREAD, caller_ik->class_loader());\n-  Handle protection_domain;\n-  PackageEntry* pkg_entry = caller_ik->package();\n-  if (caller_ik->class_loader() != nullptr) {\n-    protection_domain = CDSProtectionDomain::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);\n-  }\n-\n-  InstanceKlass* shared_nest_host = get_shared_nest_host(lambda_ik);\n-  assert(shared_nest_host != nullptr, \"unexpected nullptr _nest_host\");\n-\n-  InstanceKlass* loaded_lambda =\n-    SystemDictionary::load_shared_lambda_proxy_class(lambda_ik, class_loader, protection_domain, pkg_entry, CHECK_NULL);\n-\n-  if (loaded_lambda == nullptr) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Ensures the nest host is the same as the lambda proxy's\n-  \/\/ nest host recorded at dump time.\n-  InstanceKlass* nest_host = caller_ik->nest_host(THREAD);\n-  assert(nest_host == shared_nest_host, \"mismatched nest host\");\n-\n-  EventClassLoad class_load_start_event;\n-\n-  \/\/ Add to class hierarchy, and do possible deoptimizations.\n-  loaded_lambda->add_to_hierarchy(THREAD);\n-  \/\/ But, do not add to dictionary.\n-\n-  loaded_lambda->link_class(CHECK_NULL);\n-  \/\/ notify jvmti\n-  if (JvmtiExport::should_post_class_load()) {\n-    JvmtiExport::post_class_load(THREAD, loaded_lambda);\n-  }\n-  if (class_load_start_event.should_commit()) {\n-    SystemDictionary::post_class_load_event(&class_load_start_event, loaded_lambda, ClassLoaderData::class_loader_data(class_loader()));\n-  }\n-\n-  loaded_lambda->initialize(CHECK_NULL);\n-\n-  return loaded_lambda;\n-}\n-\n@@ -1179,47 +957,0 @@\n-bool SystemDictionaryShared::is_supported_invokedynamic(BootstrapInfo* bsi) {\n-  LogTarget(Debug, cds, lambda) log;\n-  if (bsi->arg_values() == nullptr || !bsi->arg_values()->is_objArray()) {\n-    if (log.is_enabled()) {\n-      LogStream log_stream(log);\n-      log.print(\"bsi check failed\");\n-      log.print(\"    bsi->arg_values().not_null() %d\", bsi->arg_values().not_null());\n-      if (bsi->arg_values().not_null()) {\n-        log.print(\"    bsi->arg_values()->is_objArray() %d\", bsi->arg_values()->is_objArray());\n-        bsi->print_msg_on(&log_stream);\n-      }\n-    }\n-    return false;\n-  }\n-\n-  Handle bsm = bsi->bsm();\n-  if (bsm.is_null() || !java_lang_invoke_DirectMethodHandle::is_instance(bsm())) {\n-    if (log.is_enabled()) {\n-      log.print(\"bsm check failed\");\n-      log.print(\"    bsm.is_null() %d\", bsm.is_null());\n-      log.print(\"    java_lang_invoke_DirectMethodHandle::is_instance(bsm()) %d\",\n-        java_lang_invoke_DirectMethodHandle::is_instance(bsm()));\n-    }\n-    return false;\n-  }\n-\n-  oop mn = java_lang_invoke_DirectMethodHandle::member(bsm());\n-  Method* method = java_lang_invoke_MemberName::vmtarget(mn);\n-  if (method->klass_name()->equals(\"java\/lang\/invoke\/LambdaMetafactory\") &&\n-      method->name()->equals(\"metafactory\") &&\n-      method->signature()->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;\"\n-            \"Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;\"\n-            \"Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\")) {\n-      return true;\n-  } else {\n-    if (log.is_enabled()) {\n-      ResourceMark rm;\n-      log.print(\"method check failed\");\n-      log.print(\"    klass_name() %s\", method->klass_name()->as_C_string());\n-      log.print(\"    name() %s\", method->name()->as_C_string());\n-      log.print(\"    signature() %s\", method->signature()->as_C_string());\n-    }\n-  }\n-\n-  return false;\n-}\n-\n@@ -1241,45 +972,0 @@\n-class CopyLambdaProxyClassInfoToArchive : StackObj {\n-  CompactHashtableWriter* _writer;\n-  ArchiveBuilder* _builder;\n-public:\n-  CopyLambdaProxyClassInfoToArchive(CompactHashtableWriter* writer)\n-  : _writer(writer), _builder(ArchiveBuilder::current()) {}\n-  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    \/\/ In static dump, info._proxy_klasses->at(0) is already relocated to point to the archived class\n-    \/\/ (not the original class).\n-    ResourceMark rm;\n-    log_info(cds,dynamic)(\"Archiving hidden %s\", info._proxy_klasses->at(0)->external_name());\n-    size_t byte_size = sizeof(RunTimeLambdaProxyClassInfo);\n-    RunTimeLambdaProxyClassInfo* runtime_info =\n-        (RunTimeLambdaProxyClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n-    runtime_info->init(key, info);\n-    unsigned int hash = runtime_info->hash();\n-    u4 delta = _builder->any_to_offset_u4((void*)runtime_info);\n-    _writer->add(hash, delta);\n-    return true;\n-  }\n-};\n-\n-class AdjustLambdaProxyClassInfo : StackObj {\n-public:\n-  AdjustLambdaProxyClassInfo() {}\n-  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    int len = info._proxy_klasses->length();\n-    InstanceKlass* last_buff_k = nullptr;\n-\n-    for (int i = len - 1; i >= 0; i--) {\n-      InstanceKlass* orig_k = info._proxy_klasses->at(i);\n-      InstanceKlass* buff_k = ArchiveBuilder::current()->get_buffered_addr(orig_k);\n-      assert(ArchiveBuilder::current()->is_in_buffer_space(buff_k), \"must be\");\n-      buff_k->set_lambda_proxy_is_available();\n-      buff_k->set_next_link(last_buff_k);\n-      if (last_buff_k != nullptr) {\n-        ArchivePtrMarker::mark_pointer(buff_k->next_link_addr());\n-      }\n-      last_buff_k = buff_k;\n-    }\n-\n-    return true;\n-  }\n-};\n-\n@@ -1324,9 +1010,0 @@\n-void SystemDictionaryShared::write_lambda_proxy_class_dictionary(LambdaProxyClassDictionary *dictionary) {\n-  CompactHashtableStats stats;\n-  dictionary->reset();\n-  CompactHashtableWriter writer(_dumptime_lambda_proxy_class_dictionary->_count, &stats);\n-  CopyLambdaProxyClassInfoToArchive copy(&writer);\n-  _dumptime_lambda_proxy_class_dictionary->iterate(&copy);\n-  writer.dump(dictionary, \"lambda proxy class dictionary\");\n-}\n-\n@@ -1349,7 +1026,5 @@\n-\n-  write_lambda_proxy_class_dictionary(&archive->_lambda_proxy_class_dictionary);\n-}\n-\n-void SystemDictionaryShared::adjust_lambda_proxy_class_dictionary() {\n-  AdjustLambdaProxyClassInfo adjuster;\n-  _dumptime_lambda_proxy_class_dictionary->iterate(&adjuster);\n+  if (CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n+    LambdaProxyClassDictionary::write_dictionary(is_static_archive);\n+  } else {\n+    LambdaProxyClassDictionary::reset_dictionary(is_static_archive);\n+  }\n@@ -1364,1 +1039,1 @@\n-  archive->_lambda_proxy_class_dictionary.serialize_header(soc);\n+  LambdaProxyClassDictionary::serialize(soc, is_static_archive);\n@@ -1433,1 +1108,1 @@\n-static const char* class_loader_name_for_shared(Klass* k) {\n+const char* SystemDictionaryShared::loader_type_for_shared_class(Klass* k) {\n@@ -1460,1 +1135,1 @@\n-        class_loader_name_for_shared(record->klass()));\n+        SystemDictionaryShared::loader_type_for_shared_class(record->klass()));\n@@ -1469,19 +1144,0 @@\n-class SharedLambdaDictionaryPrinter : StackObj {\n-  outputStream* _st;\n-  int _index;\n-public:\n-  SharedLambdaDictionaryPrinter(outputStream* st, int idx) : _st(st), _index(idx) {}\n-\n-  void do_value(const RunTimeLambdaProxyClassInfo* record) {\n-    if (record->proxy_klass_head()->lambda_proxy_is_available()) {\n-      ResourceMark rm;\n-      Klass* k = record->proxy_klass_head();\n-      while (k != nullptr) {\n-        _st->print_cr(\"%4d: %s %s\", _index++, k->external_name(),\n-                      class_loader_name_for_shared(k));\n-        k = k->next_link();\n-      }\n-    }\n-  }\n-};\n-\n@@ -1489,1 +1145,2 @@\n-                                                   outputStream* st) {\n+                                                   outputStream* st,\n+                                                   bool is_static_archive) {\n@@ -1496,5 +1153,1 @@\n-  if (!_lambda_proxy_class_dictionary.empty()) {\n-    st->print_cr(\"%sShared Lambda Dictionary\", prefix);\n-    SharedLambdaDictionaryPrinter ldp(st, p.index());\n-    _lambda_proxy_class_dictionary.iterate(&ldp);\n-  }\n+  LambdaProxyClassDictionary::print_on(prefix, st, p.index(), is_static_archive);\n@@ -1504,1 +1157,2 @@\n-                                                                 outputStream* st) {\n+                                                                 outputStream* st,\n+                                                                 bool is_static_archive) {\n@@ -1508,1 +1162,1 @@\n-  _lambda_proxy_class_dictionary.print_table_statistics(st, \"Lambda Shared Dictionary\");\n+  LambdaProxyClassDictionary::print_statistics(st, is_static_archive);\n@@ -1514,1 +1168,1 @@\n-      _static_archive.print_on(\"\", st);\n+      _static_archive.print_on(\"\", st, true);\n@@ -1517,1 +1171,1 @@\n-        _dynamic_archive.print_on(\"Dynamic \", st);\n+        _dynamic_archive.print_on(\"Dynamic \", st, false);\n@@ -1530,1 +1184,1 @@\n-    _static_archive.print_table_statistics(\"Static \", st);\n+    _static_archive.print_table_statistics(\"Static \", st, true);\n@@ -1532,1 +1186,1 @@\n-      _dynamic_archive.print_table_statistics(\"Dynamic \", st);\n+      _dynamic_archive.print_table_statistics(\"Dynamic \", st, false);\n@@ -1545,29 +1199,0 @@\n-\n-class CleanupDumpTimeLambdaProxyClassTable: StackObj {\n- public:\n-  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    assert_lock_strong(DumpTimeTable_lock);\n-    InstanceKlass* caller_ik = key.caller_ik();\n-    InstanceKlass* nest_host = caller_ik->nest_host_not_null();\n-\n-    \/\/ If the caller class and\/or nest_host are excluded, the associated lambda proxy\n-    \/\/ must also be excluded.\n-    bool always_exclude = SystemDictionaryShared::check_for_exclusion(caller_ik, nullptr) ||\n-                          SystemDictionaryShared::check_for_exclusion(nest_host, nullptr);\n-\n-    for (int i = info._proxy_klasses->length() - 1; i >= 0; i--) {\n-      InstanceKlass* ik = info._proxy_klasses->at(i);\n-      if (always_exclude || SystemDictionaryShared::check_for_exclusion(ik, nullptr)) {\n-        SystemDictionaryShared::reset_registered_lambda_proxy_class(ik);\n-        info._proxy_klasses->remove_at(i);\n-      }\n-    }\n-    return info._proxy_klasses->length() == 0 ? true \/* delete the node*\/ : false;\n-  }\n-};\n-\n-void SystemDictionaryShared::cleanup_lambda_proxy_class_dictionary() {\n-  assert_lock_strong(DumpTimeTable_lock);\n-  CleanupDumpTimeLambdaProxyClassTable cleanup_proxy_classes;\n-  _dumptime_lambda_proxy_class_dictionary->unlink(&cleanup_proxy_classes);\n-}\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":29,"deletions":404,"binary":false,"changes":433,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -116,1 +115,0 @@\n-class LambdaProxyClassDictionary;\n@@ -119,2 +117,0 @@\n-class DumpTimeLambdaProxyClassDictionary;\n-class LambdaProxyClassKey;\n@@ -140,1 +136,1 @@\n-  friend class CleanupDumpTimeLambdaProxyClassTable;\n+  friend class LambdaProxyClassDictionary;\n@@ -145,1 +141,0 @@\n-    LambdaProxyClassDictionary _lambda_proxy_class_dictionary;\n@@ -147,6 +142,2 @@\n-    const RunTimeLambdaProxyClassInfo* lookup_lambda_proxy_class(RunTimeLambdaProxyClassKey* key) {\n-      return _lambda_proxy_class_dictionary.lookup(key, key->hash(), 0);\n-    }\n-\n-    void print_on(const char* prefix, outputStream* st);\n-    void print_table_statistics(const char* prefix, outputStream* st);\n+    void print_on(const char* prefix, outputStream* st, bool is_static_archive);\n+    void print_table_statistics(const char* prefix, outputStream* st, bool is_static_archive);\n@@ -158,1 +149,0 @@\n-  static DumpTimeLambdaProxyClassDictionary* _dumptime_lambda_proxy_class_dictionary;\n@@ -185,3 +175,0 @@\n-  static void write_lambda_proxy_class_dictionary(LambdaProxyClassDictionary* dictionary);\n-  static void cleanup_lambda_proxy_class_dictionary();\n-  static void reset_registered_lambda_proxy_class(InstanceKlass* ik);\n@@ -192,1 +179,0 @@\n-  static InstanceKlass* retrieve_lambda_proxy_class(const RunTimeLambdaProxyClassInfo* info) NOT_CDS_RETURN_(nullptr);\n@@ -199,2 +185,0 @@\n-  static bool is_registered_lambda_proxy_class(InstanceKlass* ik);\n-  static bool is_hidden_lambda_proxy(InstanceKlass* ik);\n@@ -260,18 +244,0 @@\n-  static void add_lambda_proxy_class(InstanceKlass* caller_ik,\n-                                     InstanceKlass* lambda_ik,\n-                                     Symbol* invoked_name,\n-                                     Symbol* invoked_type,\n-                                     Symbol* method_type,\n-                                     Method* member_method,\n-                                     Symbol* instantiated_method_type, TRAPS) NOT_CDS_RETURN;\n-  static void add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey& key,\n-                                                             InstanceKlass* proxy_klass) NOT_CDS_RETURN;\n-  static InstanceKlass* get_shared_lambda_proxy_class(InstanceKlass* caller_ik,\n-                                                      Symbol* invoked_name,\n-                                                      Symbol* invoked_type,\n-                                                      Symbol* method_type,\n-                                                      Method* member_method,\n-                                                      Symbol* instantiated_method_type) NOT_CDS_RETURN_(nullptr);\n-  static InstanceKlass* get_shared_nest_host(InstanceKlass* lambda_ik) NOT_CDS_RETURN_(nullptr);\n-  static InstanceKlass* prepare_shared_lambda_proxy_class(InstanceKlass* lambda_ik,\n-                                                          InstanceKlass* caller_ik, TRAPS) NOT_CDS_RETURN_(nullptr);\n@@ -298,1 +264,0 @@\n-  static void adjust_lambda_proxy_class_dictionary();\n@@ -302,0 +267,1 @@\n+  static const char* loader_type_for_shared_class(Klass* k);\n@@ -307,1 +273,0 @@\n-  static bool is_supported_invokedynamic(BootstrapInfo* bsi) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":4,"deletions":39,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2702,1 +2702,1 @@\n-  if (CDSConfig::is_dumping_invokedynamic() && HeapShared::is_lambda_proxy_klass(this)) {\n+  if (CDSConfig::is_dumping_method_handles() && HeapShared::is_lambda_proxy_klass(this)) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -3365,1 +3366,1 @@\n-  if (!CDSConfig::is_dumping_archive()) {\n+  if (!CDSConfig::is_dumping_archive() || !CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n@@ -3399,2 +3400,2 @@\n-  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n-                                                 interface_method_type, m, dynamic_method_type, THREAD);\n+  LambdaProxyClassDictionary::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n+                                                     interface_method_type, m, dynamic_method_type, THREAD);\n@@ -3439,8 +3440,5 @@\n-  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, interface_method_name, factory_type,\n-                                                                                   interface_method_type, m, dynamic_method_type);\n-  jclass jcls = nullptr;\n-  if (lambda_ik != nullptr) {\n-    InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, THREAD);\n-    jcls = loaded_lambda == nullptr ? nullptr : (jclass) JNIHandles::make_local(THREAD, loaded_lambda->java_mirror());\n-  }\n-  return jcls;\n+  InstanceKlass* loaded_lambda =\n+    LambdaProxyClassDictionary::load_shared_lambda_proxy_class(caller_ik, interface_method_name, factory_type,\n+                                                               interface_method_type, m, dynamic_method_type,\n+                                                               CHECK_(nullptr));\n+  return loaded_lambda == nullptr ? nullptr : (jclass) JNIHandles::make_local(THREAD, loaded_lambda->java_mirror());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-extern Mutex*   CDSLambda_lock;                  \/\/ SystemDictionaryShared::get_shared_lambda_proxy_class\n+extern Mutex*   CDSLambda_lock;                  \/\/ LambdaProxyClassDictionary::find_lambda_proxy_class\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,4 @@\n+        testCase(\"Use the archive that was created with -XX:-AOTInvokeDynamicLinking.\");\n+        TestCommon.run(\"-cp\", appJar, \"Hello\")\n+            .assertNormalExit(\"Hello\");\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTClassLinkingVMOptions.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}