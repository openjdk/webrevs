{"files":[{"patch":"@@ -623,1 +623,1 @@\n-bool ShenandoahOldHeuristics::resume_old_cycle() {\n+bool ShenandoahOldHeuristics::should_resume_old_cycle() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,1 +188,3 @@\n-  bool resume_old_cycle();\n+\n+  \/\/ Returns true if the old generation needs to prepare for marking, or continue marking.\n+  bool should_resume_old_cycle();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,0 +168,7 @@\n+\n+bool ShenandoahCollectorPolicy::is_allocation_failure(GCCause::Cause cause) {\n+  return cause == GCCause::_allocation_failure\n+      || cause == GCCause::_shenandoah_allocation_failure_evac\n+      || cause == GCCause::_shenandoah_humongous_allocation_failure;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  ShenandoahTracer* tracer() {return _tracer;}\n+  ShenandoahTracer* tracer() const {return _tracer;}\n@@ -93,1 +93,1 @@\n-  inline size_t consecutive_degenerated_gc_count() const {\n+  size_t consecutive_degenerated_gc_count() const {\n@@ -97,6 +97,1 @@\n-  static bool is_allocation_failure(GCCause::Cause cause) {\n-    return cause == GCCause::_allocation_failure\n-        || cause == GCCause::_shenandoah_allocation_failure_evac\n-        || cause == GCCause::_shenandoah_humongous_allocation_failure;\n-  }\n-\n+  static bool is_allocation_failure(GCCause::Cause cause);\n@@ -109,1 +104,1 @@\n-  inline size_t consecutive_young_gc_count() const {\n+  size_t consecutive_young_gc_count() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  \/\/ A monotonically increasing GC count.\n@@ -46,1 +47,0 @@\n-\n@@ -53,0 +53,3 @@\n+  \/\/ Increments the internal GC count.\n+  void update_gc_id();\n+\n@@ -66,1 +69,1 @@\n-  \/\/ until another cycle runs and clears the alloc failure gc flag.\n+  \/\/ until another cycle completes successfully.\n@@ -73,3 +76,0 @@\n-  \/\/ Return true if setting the flag which indicates allocation failure succeeds.\n-  bool try_set_alloc_failure_gc(bool is_humongous);\n-\n@@ -83,0 +83,2 @@\n+\n+  \/\/ Zeros out the number of allocations seen since the last GC cycle.\n@@ -85,2 +87,1 @@\n-  \/\/ Returns the internal gc count used by the control thread. Probably\n-  \/\/ doesn't need to be exposed.\n+  \/\/ Return the value of a monotonic increasing GC count, maintained by the control thread.\n@@ -88,1 +89,0 @@\n-  void update_gc_id();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  _mode(none),\n@@ -55,2 +56,1 @@\n-  _age_period(0),\n-  _mode(none) {\n+  _age_period(0) {\n@@ -98,1 +98,1 @@\n-  \/\/ In case any threads are waiting for a cycle to happen, let them know it isn't.\n+  \/\/ In case any threads are waiting for a cycle to happen, notify them so they observe the shutdown.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,4 +67,0 @@\n-  \/\/ This is true when the old generation cycle is in an interruptible phase (i.e., marking or\n-  \/\/ preparing for mark).\n-  ShenandoahSharedFlag _allow_old_preemption;\n-\n@@ -78,0 +74,3 @@\n+  \/\/ The mode is read frequently by requesting threads and only ever written by the control thread.\n+  volatile GCMode _mode;\n+\n@@ -88,4 +87,3 @@\n-  \/\/ The mode is read frequently by requesting threads and only ever written by the control thread.\n-  shenandoah_padding(0);\n-  volatile GCMode _mode;\n-  shenandoah_padding(1);\n+  \/\/ This is true when the old generation cycle is in an interruptible phase (i.e., marking or\n+  \/\/ preparing for mark).\n+  ShenandoahSharedFlag _allow_old_preemption;\n@@ -105,1 +103,1 @@\n-  GCMode gc_mode() {\n+  GCMode gc_mode() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -443,0 +443,1 @@\n+  \/\/ Returns true if and only if cancellation request was successfully communicated.\n@@ -444,0 +445,2 @@\n+\n+  \/\/ Used by workers in the GC cycle to detect cancellation and honor STS requirements\n@@ -445,0 +448,2 @@\n+\n+  \/\/ This indicates the reason the last GC cycle was cancelled.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        } else if (_old_heuristics->resume_old_cycle() || _old_heuristics->should_start_gc()) {\n+        } else if (_old_heuristics->should_resume_old_cycle() || _old_heuristics->should_start_gc()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}