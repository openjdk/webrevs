{"files":[{"patch":"@@ -53,1 +53,1 @@\n-  _mode(none),\n+  _gc_mode(none),\n@@ -143,1 +143,1 @@\n-    mode = prepare_for_allocation_failure_request(request);\n+    mode = prepare_for_allocation_failure_gc(request);\n@@ -145,1 +145,1 @@\n-    mode = prepare_for_explicit_gc_request(request);\n+    mode = prepare_for_explicit_gc(request);\n@@ -147,1 +147,1 @@\n-    mode = prepare_for_concurrent_gc_request(request);\n+    mode = prepare_for_concurrent_gc(request);\n@@ -152,1 +152,1 @@\n-ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_allocation_failure_request(ShenandoahGCRequest &request) {\n+ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_allocation_failure_gc(ShenandoahGCRequest &request) {\n@@ -182,1 +182,1 @@\n-ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_explicit_gc_request(ShenandoahGCRequest &request) {\n+ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_explicit_gc(ShenandoahGCRequest &request) const {\n@@ -198,1 +198,1 @@\n-ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_concurrent_gc_request(ShenandoahGCRequest &request) {\n+ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_concurrent_gc(const ShenandoahGCRequest &request) const {\n@@ -222,1 +222,1 @@\n-void ShenandoahGenerationalControlThread::run_gc_cycle(ShenandoahGCRequest request) {\n+void ShenandoahGenerationalControlThread::run_gc_cycle(const ShenandoahGCRequest& request) {\n@@ -334,1 +334,1 @@\n-void ShenandoahGenerationalControlThread::process_phase_timings() {\n+void ShenandoahGenerationalControlThread::process_phase_timings() const {\n@@ -388,1 +388,1 @@\n-void ShenandoahGenerationalControlThread::service_concurrent_normal_cycle(ShenandoahGCRequest request) {\n+void ShenandoahGenerationalControlThread::service_concurrent_normal_cycle(const ShenandoahGCRequest& request) {\n@@ -398,1 +398,1 @@\n-void ShenandoahGenerationalControlThread::service_concurrent_old_cycle(ShenandoahGCRequest request) {\n+void ShenandoahGenerationalControlThread::service_concurrent_old_cycle(const ShenandoahGCRequest& request) {\n@@ -632,1 +632,1 @@\n-void ShenandoahGenerationalControlThread::service_stw_degenerated_cycle(ShenandoahGCRequest request) {\n+void ShenandoahGenerationalControlThread::service_stw_degenerated_cycle(const ShenandoahGCRequest& request) {\n@@ -793,4 +793,4 @@\n-  if (_mode != new_mode) {\n-    log_debug(gc, thread)(\"Transition from: %s to: %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n-    EventMark event(\"Control thread transition from: %s, to %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n-    _mode = new_mode;\n+  if (_gc_mode != new_mode) {\n+    log_debug(gc, thread)(\"Transition from: %s to: %s\", gc_mode_name(_gc_mode), gc_mode_name(new_mode));\n+    EventMark event(\"Control thread transition from: %s, to %s\", gc_mode_name(_gc_mode), gc_mode_name(new_mode));\n+    _gc_mode = new_mode;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shenandoah\/shenandoahPadding.hpp\"\n@@ -75,1 +74,3 @@\n-  volatile GCMode _mode;\n+  \/\/ This may be read without taking the _control_lock, but should be read again under the lock\n+  \/\/ before making any state changes (double-checked locking idiom).\n+  volatile GCMode _gc_mode;\n@@ -104,1 +105,1 @@\n-    return _mode;\n+    return _gc_mode;\n@@ -111,1 +112,1 @@\n-  void run_gc_cycle(ShenandoahGCRequest request);\n+  void run_gc_cycle(const ShenandoahGCRequest& request);\n@@ -115,0 +116,2 @@\n+\n+  \/\/ Various service methods handle different gc cycle types\n@@ -117,3 +120,3 @@\n-  void service_stw_degenerated_cycle(ShenandoahGCRequest request);\n-  void service_concurrent_normal_cycle(ShenandoahGCRequest request);\n-  void service_concurrent_old_cycle(ShenandoahGCRequest cause);\n+  void service_stw_degenerated_cycle(const ShenandoahGCRequest& request);\n+  void service_concurrent_normal_cycle(const ShenandoahGCRequest& request);\n+  void service_concurrent_old_cycle(const ShenandoahGCRequest& request);\n@@ -129,1 +132,2 @@\n-  void process_phase_timings();\n+  \/\/ Flushes cycle timings to global timings and prints the phase timings for the last completed cycle.\n+  void process_phase_timings() const;\n@@ -131,0 +135,2 @@\n+  \/\/ Set the gc mode and post a notification if it has changed. The overloaded variant should be used\n+  \/\/ when the _control_lock is already held.\n@@ -133,0 +139,2 @@\n+\n+  \/\/ Return printable name for the given gc mode.\n@@ -136,0 +144,1 @@\n+  \/\/ The overloaded variant should be used when the _control_lock is already held.\n@@ -140,0 +149,1 @@\n+  \/\/ The overloaded variant should be used when the _control_lock is already held.\n@@ -143,0 +153,1 @@\n+  \/\/ Configure the heap to age objects and regions if the aging period has elapsed.\n@@ -144,1 +155,0 @@\n-  void check_for_request(ShenandoahGCRequest& request);\n@@ -146,3 +156,3 @@\n-  GCMode prepare_for_allocation_failure_request(ShenandoahGCRequest &request);\n-\n-  GCMode prepare_for_explicit_gc_request(ShenandoahGCRequest &request);\n+  \/\/ Take the _control_lock and check for a request to run a gc cycle. If a request is found,\n+  \/\/ the `prepare` methods are used to configure the heap and update heuristics accordingly.\n+  void check_for_request(ShenandoahGCRequest& request);\n@@ -150,1 +160,3 @@\n-  GCMode prepare_for_concurrent_gc_request(ShenandoahGCRequest &request);\n+  GCMode prepare_for_allocation_failure_gc(ShenandoahGCRequest &request);\n+  GCMode prepare_for_explicit_gc(ShenandoahGCRequest &request) const;\n+  GCMode prepare_for_concurrent_gc(const ShenandoahGCRequest &request) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -998,1 +998,1 @@\n-      while (result == nullptr && retry_allocation(original_count)) {\n+      while (result == nullptr && should_retry_allocation(original_count)) {\n@@ -1054,1 +1054,1 @@\n-inline bool ShenandoahHeap::retry_allocation(size_t original_full_gc_count) const {\n+inline bool ShenandoahHeap::should_retry_allocation(size_t original_full_gc_count) const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -433,0 +433,2 @@\n+  \/\/ Records the time of the first successful cancellation request. This is used to measure\n+  \/\/ the responsiveness of the heuristic when starting a cycle.\n@@ -434,0 +436,2 @@\n+\n+  \/\/ Indicates the reason the current GC has been cancelled (GCCause::_no_gc means the gc is not cancelled).\n@@ -443,1 +447,1 @@\n-  \/\/ Returns true if and only if cancellation request was successfully communicated.\n+  \/\/ True if gc has been cancelled\n@@ -452,0 +456,2 @@\n+  \/\/ Clears the cancellation cause and optionally resets the oom handler (cancelling an\n+  \/\/ old mark does _not_ touch the oom handler).\n@@ -455,0 +461,2 @@\n+\n+  \/\/ Returns true if and only if this call caused a gc to be cancelled.\n@@ -687,1 +695,3 @@\n-  bool retry_allocation(size_t original_full_gc_count) const;\n+\n+  \/\/ We want to retry an unsuccessful attempt at allocation until at least a full gc.\n+  bool should_retry_allocation(size_t original_full_gc_count) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}