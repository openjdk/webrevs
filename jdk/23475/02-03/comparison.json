{"files":[{"patch":"@@ -126,1 +126,1 @@\n-bool ShenandoahCollectorPolicy::is_at_shutdown() {\n+bool ShenandoahCollectorPolicy::is_at_shutdown() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  bool is_at_shutdown();\n+  bool is_at_shutdown() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-\n@@ -62,1 +61,1 @@\n-  while (!should_terminate()) {\n+  while (!should_terminate() && !policy->is_at_shutdown()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-  _request_lock(Mutex::nosafepoint - 2, \"ShenandoahGCRequest_lock\", true),\n-  _gc_mode_lock(Mutex::nosafepoint - 3, \"ShenandoahGCMode_lock\", true),\n+  _control_lock(Mutex::nosafepoint - 2, \"ShenandoahGCRequest_lock\", true),\n@@ -90,1 +89,1 @@\n-      MonitorLocker lock(&_request_lock, Mutex::_no_safepoint_check_flag);\n+      MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n@@ -92,2 +91,2 @@\n-        set_gc_mode(none);\n-        lock.wait(wait_ms);\n+        set_gc_mode(ml, none);\n+        ml.wait(wait_ms);\n@@ -101,0 +100,10 @@\n+void ShenandoahGenerationalControlThread::stop_service() {\n+  log_debug(gc, thread)(\"Stopping control thread\");\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  _heap->cancel_gc(GCCause::_shenandoah_stop_vm);\n+  _requested_gc_cause = GCCause::_shenandoah_stop_vm;\n+  notify_cancellation(ml, GCCause::_shenandoah_stop_vm);\n+  \/\/ We can't wait here because it may interfere with the active cycle's ability\n+  \/\/ to reach a safepoint (this runs on a java thread).\n+}\n+\n@@ -103,2 +112,1 @@\n-  MonitorLocker lock(&_request_lock, Mutex::_no_safepoint_check_flag);\n-\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n@@ -129,0 +137,1 @@\n+  GCMode mode;\n@@ -130,1 +139,1 @@\n-    prepare_for_allocation_failure_request(request);\n+    mode = prepare_for_allocation_failure_request(request);\n@@ -132,1 +141,1 @@\n-    prepare_for_explicit_gc_request(request);\n+    mode = prepare_for_explicit_gc_request(request);\n@@ -134,1 +143,1 @@\n-    prepare_for_concurrent_gc_request(request);\n+    mode = prepare_for_concurrent_gc_request(request);\n@@ -136,0 +145,1 @@\n+  set_gc_mode(ml, mode);\n@@ -138,1 +148,1 @@\n-void ShenandoahGenerationalControlThread::prepare_for_allocation_failure_request(ShenandoahGCRequest& request) {\n+ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_allocation_failure_request(ShenandoahGCRequest &request) {\n@@ -159,1 +169,1 @@\n-    set_gc_mode(stw_degenerated);\n+    return stw_degenerated;\n@@ -164,1 +174,1 @@\n-    set_gc_mode(stw_full);\n+    return stw_full;\n@@ -168,1 +178,1 @@\n-void ShenandoahGenerationalControlThread::prepare_for_explicit_gc_request(ShenandoahGCRequest& request) {\n+ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_explicit_gc_request(ShenandoahGCRequest &request) {\n@@ -175,1 +185,1 @@\n-    set_gc_mode(stw_full);\n+    return stw_full;;\n@@ -177,2 +187,2 @@\n-    set_gc_mode(concurrent_normal);\n-    \/\/ Unload and clean up everything\n+    \/\/ Unload and clean up everything. Note that this is an _explicit_ request and so does not use\n+    \/\/ the same `should_unload_classes` call as the regulator's concurrent gc request.\n@@ -180,0 +190,1 @@\n+    return concurrent_normal;\n@@ -183,1 +194,1 @@\n-void ShenandoahGenerationalControlThread::prepare_for_concurrent_gc_request(ShenandoahGCRequest& request) {\n+ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_concurrent_gc_request(ShenandoahGCRequest &request) {\n@@ -187,3 +198,0 @@\n-  \/\/ preemption was requested or this is a regular cycle\n-  set_gc_mode(request.generation->is_old() ? servicing_old : concurrent_normal);\n-\n@@ -196,0 +204,3 @@\n+\n+  \/\/ preemption was requested or this is a regular cycle\n+  return request.generation->is_old() ? servicing_old : concurrent_normal;\n@@ -613,7 +624,0 @@\n-void ShenandoahGenerationalControlThread::stop_service() {\n-  log_debug(gc, thread)(\"Stopping control thread\");\n-  MonitorLocker locker(&_request_lock, Mutex::_no_safepoint_check_flag);\n-  _requested_gc_cause = GCCause::_shenandoah_stop_vm;\n-  _request_lock.notify();\n-}\n-\n@@ -656,4 +660,1 @@\n-    assert(_heap->cancelled_gc(), \"GC should already be cancelled\");\n-    log_debug(gc,thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n-    MonitorLocker locker(&_request_lock, Mutex::_no_safepoint_check_flag);\n-    _request_lock.notify();\n+    notify_cancellation(cause);\n@@ -674,7 +675,2 @@\n-  if (gc_mode() == none) {\n-    if (_requested_gc_cause != GCCause::_no_gc) {\n-      log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(_requested_gc_cause));\n-      return false;\n-    }\n-\n-    notify_control_thread(GCCause::_shenandoah_concurrent_gc, generation);\n+  if (preempt_old_marking(generation)) {\n+    log_info(gc)(\"Preempting old generation mark to allow %s GC\", generation->name());\n@@ -682,2 +678,6 @@\n-    MonitorLocker ml(&_gc_mode_lock, Mutex::_no_safepoint_check_flag);\n-    while (gc_mode() == none) {\n+    \/\/ Cancel the old GC and wait for the control thread to start servicing the new request.\n+    \/\/ We are using the fact old is only preemptible when the control thread mode is servicing_old\n+    MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+    while (gc_mode() != concurrent_normal) {\n+      ShenandoahHeap::heap()->cancel_gc(GCCause::_shenandoah_concurrent_gc);\n+      notify_cancellation(ml, GCCause::_shenandoah_concurrent_gc);\n@@ -686,0 +686,1 @@\n+\n@@ -689,10 +690,6 @@\n-  if (preempt_old_marking(generation)) {\n-    assert(gc_mode() == servicing_old, \"Expected to be servicing old, but was: %s.\", gc_mode_name(gc_mode()));\n-    log_info(gc)(\"Preempting old generation mark to allow %s GC\", generation->name());\n-\n-    \/\/ Cancel the old GC and wait for the control thread to stop servicing old\n-    ShenandoahHeap::heap()->cancel_gc(GCCause::_shenandoah_concurrent_gc);\n-    {\n-      MonitorLocker ml(&_gc_mode_lock, Mutex::_no_safepoint_check_flag);\n-      while (gc_mode() == servicing_old) {\n-        ml.wait();\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  if (gc_mode() == none) {\n+    while (gc_mode() == none) {\n+      if (_requested_gc_cause != GCCause::_no_gc) {\n+        log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(_requested_gc_cause));\n+        return false;\n@@ -700,1 +697,0 @@\n-    }\n@@ -702,10 +698,2 @@\n-    \/\/ Setting the request and generation is not necessary here, the control thread knows\n-    \/\/ that when the cancellation cause is for a concurrent gc, then it means a young gc\n-    \/\/ wants to preempt the old gc. The cancellation cause takes precedence.\n-    notify_control_thread(GCCause::_shenandoah_concurrent_gc, generation);\n-\n-    {\n-      MonitorLocker ml(&_gc_mode_lock, Mutex::_no_safepoint_check_flag);\n-      while (gc_mode() == none) {\n-        ml.wait();\n-      }\n+      notify_control_thread(ml, GCCause::_shenandoah_concurrent_gc, generation);\n+      ml.wait();\n@@ -716,0 +704,1 @@\n+\n@@ -723,0 +712,6 @@\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  notify_control_thread(ml, cause, generation);\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_control_thread(MonitorLocker& ml, GCCause::Cause cause, ShenandoahGeneration* generation) {\n+  assert(_control_lock.is_locked(), \"Request lock must be held here\");\n@@ -724,1 +719,0 @@\n-  MonitorLocker locker(&_request_lock, Mutex::_no_safepoint_check_flag);\n@@ -727,1 +721,12 @@\n-  _request_lock.notify();\n+  ml.notify();\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_cancellation(GCCause::Cause cause) {\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  notify_cancellation(ml, cause);\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_cancellation(MonitorLocker& ml, GCCause::Cause cause) {\n+  assert(_heap->cancelled_gc(), \"GC should already be cancelled\");\n+  log_debug(gc,thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n+  ml.notify();\n@@ -785,0 +790,5 @@\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  set_gc_mode(ml, new_mode);\n+}\n+\n+void ShenandoahGenerationalControlThread::set_gc_mode(MonitorLocker& ml, GCMode new_mode) {\n@@ -787,1 +797,0 @@\n-    MonitorLocker ml(&_gc_mode_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":74,"deletions":65,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include <runtime\/mutexLocker.hpp>\n+\n@@ -62,6 +64,3 @@\n-  \/\/ This lock is used to coordinate setting the _requested_gc_cause and _requested generation.\n-  \/\/ It is important that these be changed together and have a consistent view.\n-  Monitor _request_lock;\n-\n-  \/\/ Used to coordinate waiting for the control thread to change state\n-  Monitor _gc_mode_lock;\n+  \/\/ This lock is used to coordinate setting the _requested_gc_cause, _requested generation\n+  \/\/ and _gc_mode. It is important that these be changed together and have a consistent view.\n+  Monitor _control_lock;\n@@ -136,0 +135,1 @@\n+  void set_gc_mode(MonitorLocker& ml, GCMode new_mode);\n@@ -138,1 +138,1 @@\n-  \/\/ Takes the request lock and updates the requested cause and generation, then notifies the lock's waiters.\n+  \/\/ Takes the request lock and updates the requested cause and generation, then notifies the control thread.\n@@ -140,0 +140,5 @@\n+  void notify_control_thread(MonitorLocker& ml, GCCause::Cause cause, ShenandoahGeneration* generation);\n+\n+  \/\/ Notifies the control thread, but does not update the requested cause or generation.\n+  void notify_cancellation(GCCause::Cause cause);\n+  void notify_cancellation(MonitorLocker& ml, GCCause::Cause cause);\n@@ -144,3 +149,5 @@\n-  void prepare_for_allocation_failure_request(ShenandoahGCRequest& request);\n-  void prepare_for_explicit_gc_request(ShenandoahGCRequest& request);\n-  void prepare_for_concurrent_gc_request(ShenandoahGCRequest& request);\n+  GCMode prepare_for_allocation_failure_request(ShenandoahGCRequest &request);\n+\n+  GCMode prepare_for_explicit_gc_request(ShenandoahGCRequest &request);\n+\n+  GCMode prepare_for_concurrent_gc_request(ShenandoahGCRequest &request);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"}]}