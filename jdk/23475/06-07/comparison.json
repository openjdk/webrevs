{"files":[{"patch":"@@ -395,1 +395,1 @@\n-  while (current_gc_id < required_gc_id) {\n+  while (current_gc_id < required_gc_id && !should_terminate()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,5 +53,0 @@\n-  if (should_terminate()) {\n-    log_info(gc)(\"Control thread is terminating, no help for this allocation\");\n-    return;\n-  }\n-\n@@ -69,1 +64,1 @@\n-    while (ShenandoahCollectorPolicy::is_allocation_failure(heap->cancelled_cause())) {\n+    while (!should_terminate() && ShenandoahCollectorPolicy::is_allocation_failure(heap->cancelled_cause())) {\n@@ -76,4 +71,0 @@\n-  if (should_terminate()) {\n-    log_info(gc)(\"Control thread is terminating, no help for this allocation\");\n-    return;\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-      notify_gc_waiters();\n-      notify_alloc_failure_waiters();\n@@ -100,0 +98,3 @@\n+  \/\/ In case any threads are waiting for a cycle to happen, let them know it isn't.\n+  notify_gc_waiters();\n+  notify_alloc_failure_waiters();\n@@ -744,5 +745,0 @@\n-  if (should_terminate()) {\n-    log_info(gc)(\"Control thread is terminating, no more GCs\");\n-    return;\n-  }\n-\n@@ -769,5 +765,3 @@\n-  size_t required_gc_id = current_gc_id + 1;\n-  while (current_gc_id < required_gc_id) {\n-    \/\/ This races with the regulator thread to start a concurrent gc and the\n-    \/\/ control thread to clear it at the start of a cycle. Threads here are\n-    \/\/ allowed to escalate a heuristic's request for concurrent gc.\n+  const size_t required_gc_id = current_gc_id + 1;\n+  while (current_gc_id < required_gc_id && !should_terminate()) {\n+    \/\/ Make requests to run a global cycle until at least one is completed\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -997,2 +997,2 @@\n-      size_t original_count = shenandoah_policy()->full_gc_count();\n-      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+      const size_t original_count = shenandoah_policy()->full_gc_count();\n+      while (result == nullptr && retry_allocation(original_count)) {\n@@ -1003,1 +1003,1 @@\n-        \/\/ If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n+        \/\/ If our allocation request has been satisfied after it initially failed, we count this as good gc progress\n@@ -1054,0 +1054,5 @@\n+inline bool ShenandoahHeap::retry_allocation(size_t original_full_gc_count) const {\n+  return shenandoah_policy()->full_gc_count() == original_full_gc_count\n+      && !shenandoah_policy()->is_at_shutdown();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -682,0 +682,1 @@\n+  bool retry_allocation(size_t original_full_gc_count) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}