{"files":[{"patch":"@@ -41,1 +41,1 @@\n-            return Math.max(paramSlots, attr.codeLength());\n+            return Math.max(paramSlots, attr.maxLocals());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8337225\n@@ -29,0 +30,15 @@\n+import java.io.IOException;\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -30,3 +46,0 @@\n-\n-import static java.lang.constant.ConstantDescs.*;\n-\n@@ -34,0 +47,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -35,0 +49,1 @@\n+import java.net.URI;\n@@ -36,1 +51,0 @@\n-import java.nio.file.Paths;\n@@ -39,6 +53,0 @@\n-import java.lang.classfile.AccessFlags;\n-import java.lang.reflect.AccessFlag;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.Opcode;\n-import java.lang.classfile.TypeKind;\n@@ -46,1 +54,0 @@\n-import static org.junit.jupiter.api.Assertions.*;\n@@ -49,0 +56,5 @@\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -54,2 +66,2 @@\n-    static final String testClassName = \"AdaptCodeTest$TestClass\";\n-    static final Path testClassPath = Paths.get(\"target\/test-classes\/\" + testClassName + \".class\");\n+    static final String testClassName = \"BuilderBlockTest$TestClass\";\n+    static final Path testClassPath = Path.of(URI.create(BuilderBlockTest.class.getResource(testClassName + \".class\").toString()));\n@@ -308,0 +320,77 @@\n+\n+    private static final CodeTransform ALLOCATE_LOCAL_EXAMINER = CodeTransform.ofStateful(() -> new CodeTransform() {\n+        boolean foundItem = false;\n+\n+        @Override\n+        public void atStart(CodeBuilder builder) {\n+            foundItem = false;\n+        }\n+\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            cob.with(coe);\n+            if (coe instanceof ConstantInstruction.LoadConstantInstruction ldc\n+                    && ldc.constantEntry() instanceof StringEntry se\n+                    && se.utf8().equalsString(\"Output\")) {\n+                assertFalse(foundItem);\n+                foundItem = true;\n+                var i = cob.allocateLocal(TypeKind.IntType);\n+                assertEquals(7, i, \"Allocated new int slot\");\n+            }\n+        }\n+\n+        @Override\n+        public void atEnd(CodeBuilder builder) {\n+            assertTrue(foundItem);\n+        }\n+    });\n+\n+    \/\/ Test updating local variable slot management from\n+    \/\/ source code models in transformingCode;\n+    \/\/ CodeBuilder.transform(CodeModel, CodeTransform) is\n+    \/\/ not managed for now\n+    @Test\n+    void testAllocateLocalTransformingCodeAttribute() throws IOException  {\n+        var cf = ClassFile.of();\n+        var code = cf.parse(testClassPath)\n+                .methods()\n+                .stream()\n+                .filter(f -> f.methodName().equalsString(\"work\"))\n+                .findFirst()\n+                .orElseThrow()\n+                .findAttribute(Attributes.code())\n+                .orElseThrow();\n+        ClassFile.of().build(ClassDesc.of(\"Foo\"), cb -> cb\n+                .withMethod(\"foo\", MethodTypeDesc.ofDescriptor(\"(IJI)V\"), 0, mb -> mb\n+                        .transformCode(code, ALLOCATE_LOCAL_EXAMINER)));\n+    }\n+\n+    @Test\n+    void testAllocateLocalTransformingBufferedCode() throws IOException {\n+        var cf = ClassFile.of();\n+        var testClass = cf.parse(testClassPath);\n+        ClassTransform bufferingTransform = (clb, cle) -> {\n+            if (cle instanceof MethodModel mm && mm.methodName().equalsString(\"work\")) {\n+                clb.withMethodBody(mm.methodName(), mm.methodType(), mm.flags().flagsMask(), cob -> {\n+                    int d = cob.allocateLocal(TypeKind.IntType);\n+                    int e = cob.allocateLocal(TypeKind.IntType);\n+\n+                    assertEquals(5, d);\n+                    assertEquals(6, e);\n+\n+                    mm.code().ifPresent(code -> code.forEach(cob));\n+                });\n+            }\n+        };\n+        cf.transformClass(testClass, bufferingTransform.andThen(ClassTransform.transformingMethods(MethodTransform.transformingCode(ALLOCATE_LOCAL_EXAMINER))));\n+    }\n+\n+    public static class TestClass {\n+        public void work(int a, long b, int c) {\n+            int d = Math.addExact(a, 25);\n+            int e = Math.multiplyExact(d, c);\n+            System.out.println(\"Output\");\n+            System.out.println(e + b);\n+            throw new IllegalArgumentException(\"foo\");\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":103,"deletions":14,"binary":false,"changes":117,"status":"modified"}]}