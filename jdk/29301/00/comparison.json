{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -134,2 +134,2 @@\n-  _parsable_bottom = bottom();\n-  _garbage_bytes = 0;\n+  _parsable_bottom.store_relaxed(bottom());\n+  _garbage_bytes.store_relaxed(0);\n@@ -297,1 +297,1 @@\n-  _garbage_bytes = 0;\n+  _garbage_bytes.store_relaxed(0);\n@@ -302,1 +302,1 @@\n-  AtomicAccess::add(&_garbage_bytes, garbage_bytes, memory_order_relaxed);\n+  _garbage_bytes.add_then_fetch(garbage_bytes, memory_order_relaxed);\n@@ -451,1 +451,1 @@\n-  st->print(\"|%3zu\", AtomicAccess::load(&_pinned_object_count));\n+  st->print(\"|%3zu\", _pinned_object_count.load_relaxed());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -76,1 +77,1 @@\n-  HeapWord* volatile _top;\n+  Atomic<HeapWord*> _top;\n@@ -92,2 +93,2 @@\n-  void set_top(HeapWord* value) { _top = value; }\n-  HeapWord* top() const { return _top; }\n+  void set_top(HeapWord* value) { _top.store_relaxed(value); }\n+  HeapWord* top() const { return _top.load_relaxed(); }\n@@ -234,1 +235,1 @@\n-  HeapWord* volatile _parsable_bottom;\n+  Atomic<HeapWord*> _parsable_bottom;\n@@ -237,1 +238,1 @@\n-  size_t _garbage_bytes;\n+  Atomic<size_t> _garbage_bytes;\n@@ -252,1 +253,1 @@\n-  volatile size_t _pinned_object_count;\n+  Atomic<size_t> _pinned_object_count;\n@@ -334,1 +335,1 @@\n-  size_t garbage_bytes() const { return _garbage_bytes; }\n+  size_t garbage_bytes() const { return _garbage_bytes.load_relaxed(); }\n@@ -396,2 +397,2 @@\n-  size_t pinned_count() const { return AtomicAccess::load(&_pinned_object_count); }\n-  bool has_pinned_objects() const { return pinned_count() > 0; }\n+  inline size_t pinned_count() const;\n+  inline bool has_pinned_objects() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-#include \"runtime\/atomicAccess.hpp\"\n@@ -134,1 +133,1 @@\n-  _parsable_bottom = top();\n+  _parsable_bottom.store_relaxed(top());\n@@ -157,1 +156,1 @@\n-  _garbage_bytes = 0;\n+  _garbage_bytes.store_relaxed(0);\n@@ -197,1 +196,1 @@\n-      HeapWord* result = AtomicAccess::cmpxchg(&_top, obj, new_top);\n+      HeapWord* result = _top.compare_exchange(obj, new_top);\n@@ -257,1 +256,1 @@\n-  return _parsable_bottom;\n+  return _parsable_bottom.load_relaxed();\n@@ -261,1 +260,1 @@\n-  return AtomicAccess::load_acquire(&_parsable_bottom);\n+  return _parsable_bottom.load_acquire();\n@@ -265,1 +264,1 @@\n-  AtomicAccess::release_store(&_parsable_bottom, bottom());\n+  _parsable_bottom.release_store(bottom());\n@@ -272,1 +271,1 @@\n-    _garbage_bytes = byte_size(bottom(), top_at_mark_start) - marked_bytes;\n+    _garbage_bytes.store_relaxed(byte_size(bottom(), top_at_mark_start) - marked_bytes);\n@@ -277,1 +276,1 @@\n-    _parsable_bottom = top_at_mark_start;\n+    _parsable_bottom.store_relaxed(top_at_mark_start);\n@@ -289,0 +288,8 @@\n+inline size_t G1HeapRegion::pinned_count() const {\n+  return _pinned_object_count.load_relaxed();\n+}\n+\n+inline bool G1HeapRegion::has_pinned_objects() const {\n+  return pinned_count() > 0;\n+}\n+\n@@ -514,1 +521,1 @@\n-  AtomicAccess::add(&_pinned_object_count, value, memory_order_relaxed);\n+  _pinned_object_count.add_then_fetch(value, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -716,2 +716,4 @@\n-  uint* new_claims = NEW_C_HEAP_ARRAY(uint, _n_regions, mtGC);\n-  memset(new_claims, Unclaimed, sizeof(*_claims) * _n_regions);\n+  Atomic<uint>* new_claims = NEW_C_HEAP_ARRAY(Atomic<uint>, _n_regions, mtGC);\n+  for (uint i = 0; i < _n_regions; i++) {\n+    new_claims[i].store_relaxed(Unclaimed);\n+  }\n@@ -733,1 +735,1 @@\n-  return _claims[region_index] == Claimed;\n+  return _claims[region_index].load_relaxed() == Claimed;\n@@ -738,1 +740,1 @@\n-  uint old_val = AtomicAccess::cmpxchg(&_claims[region_index], Unclaimed, Claimed);\n+  uint old_val = _claims[region_index].compare_exchange(Unclaimed, Claimed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -297,1 +298,1 @@\n-  volatile uint* _claims;\n+  Atomic<uint>*  _claims;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"gc\/g1\/g1HeapRegion.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -42,1 +43,1 @@\n-  nonstatic_field(G1HeapRegion, _top,            HeapWord* volatile)          \\\n+  nonstatic_field(G1HeapRegion, _top,            Atomic<HeapWord*>)           \\\n@@ -44,1 +45,1 @@\n-  volatile_nonstatic_field(G1HeapRegion, _pinned_object_count, size_t)        \\\n+  volatile_nonstatic_field(G1HeapRegion, _pinned_object_count, Atomic<size_t>)\\\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -891,0 +892,1 @@\n+  declare_unsigned_integer_type(Atomic<size_t>)                           \\\n@@ -904,0 +906,1 @@\n+  declare_toplevel_type(Atomic<HeapWord*>)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}