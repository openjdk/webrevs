{"files":[{"patch":"@@ -553,1 +553,0 @@\n-java\/nio\/channels\/FileChannel\/FileExtensionAndMap.java          8297292 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,239 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8168628\n- * @summary Test extending files to very large sizes without hitting a SIGBUS\n- * @requires (os.family == \"linux\")\n- * @requires (sun.arch.data.model == \"64\")\n- * @library \/test\/lib\/\n- * @run main\/othervm\/timeout=600 -Xms4g -Xmx4g FileExtensionAndMap\n- * @run main\/othervm\/timeout=600 -Xms4g -Xmx4g FileExtensionAndMap true\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.MappedByteBuffer;\n-import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.FileChannel;\n-import java.nio.channels.FileChannel.MapMode;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n-import java.util.List;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ForkJoinPool;\n-import java.util.concurrent.Semaphore;\n-import java.util.stream.IntStream;\n-import jtreg.SkippedException;\n-\n-public class FileExtensionAndMap {\n-\n-    private static final ExecutorService CACHED_EXECUTORSERVICE =\n-        Executors.newCachedThreadPool();\n-\n-    private static final String TMPDIR = System.getProperty(\"test.dir\", \".\");\n-\n-    private static boolean useRaf = false;\n-\n-    private static final long FILESIZE = 3L * 1024L * 1024L * 1024L;\n-    private static final int PARALLELISM = 3;\n-\n-    public static void main(String args[]) throws Exception {\n-        if (args.length > 2) {\n-            throw new IllegalArgumentException\n-                (\"Arguments: [true|false [targetFolder]]\");\n-        }\n-\n-        String defaultFolder = TMPDIR + File.separator + \"target\";\n-        if (args.length > 0) {\n-            useRaf = Boolean.valueOf(args[0]);\n-            if (args.length > 1) {\n-                defaultFolder = args[1];\n-            }\n-        }\n-\n-        final String targetFolder = defaultFolder;\n-        Path p = Paths.get(targetFolder);\n-        boolean targetExists = Files.exists(p);\n-        if (!targetExists) {\n-            Files.createDirectory(p);\n-        }\n-\n-        checkRequiredDiskSpace(defaultFolder);\n-\n-        System.out.printf(\"Using RandomAccessFile: %s; target folder: %s%n\",\n-            useRaf, targetFolder);\n-\n-        ForkJoinPool fjPool = new ForkJoinPool(PARALLELISM);\n-        fjPool.submit(() -> {\n-            IntStream.range(0, 20).parallel().forEach((index) -> {\n-                String fileName = \"testBigFile_\" + index + \".dat\";\n-                Path source = null;\n-                Path target = null;\n-                try {\n-                    source = Paths.get(TMPDIR, fileName);\n-                    testCreateBigFile(source);\n-                    target = Paths.get(targetFolder, fileName);\n-                    testFileCopy(source, target);\n-                } catch (Throwable th) {\n-                    System.err.println(\"Error copying file with fileName: \"\n-                        + fileName + \" : \" + th.getMessage());\n-                    th.printStackTrace(System.err);\n-                } finally {\n-                    try {\n-                        if (source != null) {\n-                            Files.deleteIfExists(source);\n-                        }\n-                    } catch (Throwable ignored) {\n-                    }\n-                    try {\n-                        if (target != null) {\n-                            Files.deleteIfExists(target);\n-                        }\n-                    } catch (Throwable ignored) {\n-                    }\n-                }\n-            });\n-        }).join();\n-\n-        if (!targetExists) {\n-            Files.delete(p);\n-        }\n-    }\n-\n-    private static void checkRequiredDiskSpace(String destinationFolder) throws IOException {\n-        Path destinationPath = Path.of(destinationFolder);\n-        Path tmpDir = Path.of(TMPDIR);\n-\n-        long totalDiskSpaceNeeded = FILESIZE * PARALLELISM;\n-\n-        if (Files.getFileStore(tmpDir).equals(Files.getFileStore(destinationPath))) {\n-            totalDiskSpaceNeeded *= 2; \/\/ writing and copying to same FS\n-            long usableDiskSpace = Files.getFileStore(tmpDir).getUsableSpace();\n-            if (usableDiskSpace < totalDiskSpaceNeeded) {\n-                throw new SkippedException(\"Insufficient disk space on \" + TMPDIR\n-                        + \". Test requires: \" + totalDiskSpaceNeeded\n-                        + \". Available on disk: \" + usableDiskSpace);\n-            }\n-\n-        } else {\n-            for (Path p : List.of(destinationPath, tmpDir)) {\n-                long usableDiskSpace = Files.getFileStore(p).getUsableSpace();\n-                if (usableDiskSpace < totalDiskSpaceNeeded) {\n-                    throw new SkippedException(\"Insufficient disk space on \" + p\n-                            + \". Test requires: \" + totalDiskSpaceNeeded\n-                            + \". Available on disk: \" + usableDiskSpace);\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void testFileCopy(Path source, Path target)\n-        throws IOException {\n-        Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n-        System.out.println(\"Finished copying file with fileName: \"\n-                + source.getFileName());\n-    }\n-\n-    private static void testCreateBigFile(Path segmentFile)\n-        throws IOException {\n-        final Semaphore concurrencySemaphore = new Semaphore(5);\n-\n-        int blockSize = 10 * 1024 * 1024;\n-        int loopCount = (int) Math.floorDiv(FILESIZE, blockSize);\n-\n-        String fileName = segmentFile.getFileName().toString();\n-        if (useRaf) {\n-            try (RandomAccessFile raf\n-                = new RandomAccessFile(segmentFile.toFile(), \"rw\")) {\n-                raf.setLength(FILESIZE);\n-                try (FileChannel fc = raf.getChannel()) {\n-                    for (int i = 0; i < loopCount; i++) {\n-                        final long startPosition = 1L * blockSize * i;\n-                        concurrencySemaphore.acquireUninterruptibly();\n-                        CACHED_EXECUTORSERVICE.submit(() -> {\n-                            writeTemplateData(fileName, fc, startPosition,\n-                                    blockSize, concurrencySemaphore);\n-                        });\n-                    }\n-                } finally {\n-                    concurrencySemaphore.acquireUninterruptibly(5);\n-                }\n-            }\n-        } else {\n-            Path file = Files.createFile(segmentFile);\n-            try (FileChannel fc = FileChannel.open(file,\n-                StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n-                for (int i = 0; i < loopCount; i++) {\n-                    final long startPosition = 1L * blockSize * i;\n-                    concurrencySemaphore.acquireUninterruptibly();\n-                    CACHED_EXECUTORSERVICE.submit(() -> {\n-                        writeTemplateData(fileName, fc, startPosition,\n-                                blockSize, concurrencySemaphore);\n-                    });\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void writeTemplateData(String fileName,\n-        FileChannel fc, long startPosition, int blockSize,\n-        Semaphore concurrencySemaphore) {\n-        try {\n-            byte[] EMPTY_RECORD = new byte[blockSize \/ 256];\n-\n-            MappedByteBuffer mappedByteBuffer = fc.map(MapMode.READ_WRITE,\n-                startPosition, blockSize);\n-            IntStream.range(0, 256).forEach((recordIndex) -> {\n-                try {\n-                    mappedByteBuffer.position((int) (recordIndex *\n-                        EMPTY_RECORD.length));\n-                    mappedByteBuffer.put(EMPTY_RECORD, 0, EMPTY_RECORD.length);\n-                } catch (Throwable th) {\n-                    System.err.println\n-                        (\"Error in FileExtensionAndMap.writeTemplateData empty record for fileName: \"\n-                        + fileName + \", startPosition: \" + startPosition + \", recordIndex: \"\n-                        + recordIndex + \" : \" + th.getMessage());\n-                    th.printStackTrace(System.err);\n-                }\n-            });\n-\n-            mappedByteBuffer.force();\n-        } catch (Throwable th) {\n-            if (!(th instanceof ClosedChannelException)) {\n-                System.err.println\n-                    (\"Error in FileExtensionAndMap.writeTemplateData empty record for fileName: \"\n-                    + fileName + \", startPosition: \" + startPosition + \" : \"\n-                    + th.getMessage());\n-                th.printStackTrace(System.err);\n-            }\n-        } finally {\n-            concurrencySemaphore.release();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/FileExtensionAndMap.java","additions":0,"deletions":239,"binary":false,"changes":239,"status":"deleted"}]}