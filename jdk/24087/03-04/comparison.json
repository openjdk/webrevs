{"files":[{"patch":"@@ -25,0 +25,2 @@\n+import static java.util.stream.Collectors.flatMapping;\n+import static java.util.stream.Collectors.groupingBy;\n@@ -26,0 +28,2 @@\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n@@ -36,0 +40,1 @@\n+import java.nio.file.OpenOption;\n@@ -38,0 +43,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -42,0 +48,1 @@\n+import java.util.Base64;\n@@ -43,0 +50,1 @@\n+import java.util.Comparator;\n@@ -49,0 +57,2 @@\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -385,1 +395,1 @@\n-        public List<X509Certificate> findCertificates() {\n+        List<X509Certificate> findCertificates() {\n@@ -402,0 +412,126 @@\n+    record ResolvedCertificateRequest(CertificateRequest request, X509Certificate cert, VerifyStatus verifyStatus) {\n+        ResolvedCertificateRequest {\n+            Objects.requireNonNull(request);\n+            Objects.requireNonNull(cert);\n+            Objects.requireNonNull(verifyStatus);\n+        }\n+\n+        enum VerifyStatus {\n+            VERIFY_OK,\n+            VERIFY_ERROR,\n+            UNVERIFIED\n+        }\n+\n+        ResolvedCertificateRequest(X509Certificate cert) {\n+            this(new CertificateRequest(cert), cert, VerifyStatus.UNVERIFIED);\n+        }\n+\n+        ResolvedCertificateRequest copyVerified(boolean verifySuccess) {\n+            return new ResolvedCertificateRequest(request, cert,\n+                    verifySuccess ? VerifyStatus.VERIFY_OK : VerifyStatus.VERIFY_ERROR);\n+        }\n+    }\n+\n+    record CertificateStats(List<ResolvedCertificateRequest> allResolvedCertificateRequests,\n+            List<X509Certificate> allCertificates, List<CertificateRequest> knownCertificateRequests,\n+            Map<X509Certificate, Throwable> unmappedCertificates) {\n+\n+        private static CertificateStats get(KeychainWithCertsSpec spec) {\n+            return CACHE.computeIfAbsent(spec, CertificateStats::create);\n+        }\n+\n+        Map<CertificateRequest, List<X509Certificate>> mapKnownCertificateRequests() {\n+            return knownCertificateRequests.stream().collect(groupingBy(x -> x, mapping(certificateRequest -> {\n+                return allResolvedCertificateRequests.stream().filter(v -> {\n+                    return v.request().equals(certificateRequest);\n+                }).map(ResolvedCertificateRequest::cert);\n+            }, flatMapping(x -> x, toList()))));\n+        }\n+\n+        Set<CertificateRequest> verifyFailedCertificateRequests() {\n+            return knownCertificateRequests.stream().filter(certificateRequest -> {\n+                return allResolvedCertificateRequests.stream().anyMatch(v -> {\n+                    return v.request().equals(certificateRequest) && v.verifyStatus() == ResolvedCertificateRequest.VerifyStatus.VERIFY_ERROR;\n+                });\n+            }).collect(toSet());\n+        }\n+\n+        Set<CertificateRequest> unmappedCertificateRequests() {\n+            return Comm.compare(Set.copyOf(knownCertificateRequests),\n+                    allResolvedCertificateRequests.stream().map(ResolvedCertificateRequest::request).collect(toSet())).unique1();\n+        }\n+\n+        private static CertificateStats create(KeychainWithCertsSpec spec) {\n+            final var allCertificates = spec.keychain().findCertificates();\n+            final List<ResolvedCertificateRequest> allResolvedCertificateRequests = new ArrayList<>();\n+            final Map<X509Certificate, Throwable> unmappedCertificates = new HashMap<>();\n+\n+            withTempDirectory(workDir -> {\n+                for (final var cert : allCertificates) {\n+                    ResolvedCertificateRequest resolvedCertificateRequest;\n+                    try {\n+                        resolvedCertificateRequest = new ResolvedCertificateRequest(cert);\n+                    } catch (RuntimeException ex) {\n+                        final Throwable t;\n+                        if (ex instanceof ExceptionBox) {\n+                            t = ex.getCause();\n+                        } else {\n+                            t = ex;\n+                        }\n+                        unmappedCertificates.put(cert, t);\n+                        continue;\n+                    }\n+\n+                    if (spec.certificateRequests().contains(resolvedCertificateRequest.request)) {\n+                        final var certFile = workDir.resolve(CertificateHash.of(cert).toString() + \".pem\");\n+                        final var verifySuccess = verifyCertificate(resolvedCertificateRequest, spec.keychain(), certFile);\n+                        resolvedCertificateRequest = resolvedCertificateRequest.copyVerified(verifySuccess);\n+                    }\n+\n+                    allResolvedCertificateRequests.add(resolvedCertificateRequest);\n+                }\n+            });\n+\n+            return new CertificateStats(allResolvedCertificateRequests, List.copyOf(allCertificates),\n+                    List.copyOf(spec.certificateRequests()), unmappedCertificates);\n+        }\n+\n+        private static final Map<KeychainWithCertsSpec, CertificateStats> CACHE = new ConcurrentHashMap<>();\n+    }\n+\n+    record PemData(String label, byte[] data) {\n+        PemData {\n+            Objects.requireNonNull(label);\n+            Objects.requireNonNull(data);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final var sb = new StringBuilder();\n+            sb.append(frame(\"BEGIN \" + label));\n+            sb.append(ENCODER.encodeToString(data));\n+            sb.append(\"\\n\");\n+            sb.append(frame(\"END \" + label));\n+            return sb.toString();\n+        }\n+\n+        static PemData of(X509Certificate cert) {\n+            return new PemData(\"CERTIFICATE\", toSupplier(cert::getEncoded).get());\n+        }\n+\n+        void save(Path path, OpenOption... options) {\n+            try {\n+                Files.createDirectories(path.getParent());\n+                Files.writeString(path, toString(), options);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static String frame(String str) {\n+            return String.format(\"-----%s-----\\n\", Objects.requireNonNull(str));\n+        }\n+\n+        private final static Base64.Encoder ENCODER = Base64.getMimeEncoder(64, \"\\n\".getBytes());\n+    }\n+\n@@ -410,5 +546,1 @@\n-        static CertificateHash fromHexString(String str) {\n-            return new CertificateHash(FORMAT.parseHex(str, 0, str.length()));\n-        }\n-\n-        static CertificateHash of(X509Certificate cert) {\n+        public static CertificateHash of(X509Certificate cert) {\n@@ -434,1 +566,1 @@\n-        ), CODE_SIGN_EXTENDED_KEY_USAGE),\n+        ), CODE_SIGN_EXTENDED_KEY_USAGE, \"codeSign\"),\n@@ -444,1 +576,3 @@\n-        ), INSTALLER_EXTENDED_KEY_USAGE);\n+        ), INSTALLER_EXTENDED_KEY_USAGE,\n+                \/\/ Should be \"pkgSign\", but with this policy `security verify-cert` command fails.\n+                \"basic\");\n@@ -446,1 +580,1 @@\n-        CertificateType(List<String> otherExtensions, List<String> extendedKeyUsage) {\n+        CertificateType(List<String> otherExtensions, List<String> extendedKeyUsage, String verifyPolicy) {\n@@ -449,0 +583,1 @@\n+            this.verifyPolicy = verifyPolicy;\n@@ -460,0 +595,4 @@\n+        String verifyPolicy() {\n+            return verifyPolicy;\n+        }\n+\n@@ -462,0 +601,1 @@\n+        private final String verifyPolicy;\n@@ -464,1 +604,1 @@\n-    public record CertificateRequest(String name, CertificateType type, int days) {\n+    public record CertificateRequest(String name, CertificateType type, int days) implements Comparable<CertificateRequest>{\n@@ -474,0 +614,5 @@\n+        @Override\n+        public int compareTo(CertificateRequest o) {\n+            return COMPARATOR.compare(this, o);\n+        }\n+\n@@ -557,0 +702,5 @@\n+\n+        private static final Comparator<CertificateRequest> COMPARATOR =\n+                Comparator.comparing(CertificateRequest::name)\n+                .thenComparing(Comparator.comparing(CertificateRequest::type))\n+                .thenComparing(Comparator.comparingInt(CertificateRequest::days));\n@@ -662,1 +812,1 @@\n-        final var missingCertificates = specs.stream().filter(spec -> {\n+        final var specsWithExistingKeychains = specs.stream().filter(spec -> {\n@@ -664,29 +814,24 @@\n-        }).map(spec -> {\n-            final var availableCertRequests = spec.keychain().findCertificates().stream().map(cert -> {\n-                try {\n-                    final var certRequest = new CertificateRequest(cert);\n-                    TKit.trace(String.format(\"Certificate with hash=%s: %s\", CertificateHash.of(cert), certRequest));\n-                    return certRequest;\n-                } catch (RuntimeException ex) {\n-                    final Throwable t;\n-                    if (ex instanceof ExceptionBox) {\n-                        t = ex.getCause();\n-                    } else {\n-                        t = ex;\n-                    }\n-                    TKit.trace(String.format(\"Failed to create certificate request from the certificate with hash=%s: %s\",\n-                            CertificateHash.of(cert), t));\n-                    return null;\n-                }\n-            }).filter(Objects::nonNull).collect(toSet());\n-            final var configuredCertRequests = spec.certificateRequests().stream().collect(toSet());\n-            final var comm = Comm.compare(availableCertRequests, configuredCertRequests);\n-            return Map.entry(spec.keychain(), comm.unique2());\n-        }).filter(e -> {\n-            return !e.getValue().isEmpty();\n-        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n-\n-        missingCertificates.entrySet().forEach(e -> {\n-            for (final var certRequest : e.getValue()) {\n-                TKit.trace(String.format(\"Missing certificate for %s certificate request in [%s] keychain\",\n-                        certRequest, e.getKey().name()));\n+        }).toList();\n+\n+        final var certificateStats = specsWithExistingKeychains.stream().collect(\n+                toMap(KeychainWithCertsSpec::keychain, CertificateStats::get));\n+\n+        for (final var keychain : specsWithExistingKeychains.stream().map(KeychainWithCertsSpec::keychain).toList()) {\n+            TKit.trace(String.format(\"In [%s] keychain:\", keychain.name()));\n+            final var certificateStat = certificateStats.get(keychain);\n+            final var resolvedCertificateRequests = certificateStat.allResolvedCertificateRequests().stream()\n+                    .sorted(Comparator.comparing(ResolvedCertificateRequest::request)).toList();\n+            for (final var resolvedCertificateRequest : resolvedCertificateRequests) {\n+                TKit.trace(String.format(\"  Certificate with hash=%s: %s[%s]\",\n+                        CertificateHash.of(resolvedCertificateRequest.cert()),\n+                        resolvedCertificateRequest.request(),\n+                        resolvedCertificateRequest.verifyStatus()));\n+            }\n+\n+            for (final var unmappedCertificate : certificateStat.unmappedCertificates().entrySet()) {\n+                TKit.trace(String.format(\"  Failed to create certificate request from the certificate with hash=%s: %s\",\n+                        CertificateHash.of(unmappedCertificate.getKey()), unmappedCertificate.getValue()));\n+            }\n+\n+            for (final var unmappedCertificateRequest : certificateStat.unmappedCertificateRequests().stream().sorted().toList()) {\n+                TKit.trace(String.format(\"  Missing certificate for %s certificate request\", unmappedCertificateRequest));\n@@ -694,0 +839,8 @@\n+        }\n+\n+        final var missingCertificates = certificateStats.values().stream().anyMatch(stat -> {\n+            return !stat.unmappedCertificateRequests().isEmpty();\n+        });\n+\n+        final var invalidCertificates = certificateStats.values().stream().anyMatch(stat -> {\n+            return !stat.verifyFailedCertificateRequests().isEmpty();\n@@ -696,1 +849,15 @@\n-        return !missingKeychain && missingCertificates.isEmpty();\n+        return !missingKeychain && !missingCertificates && !invalidCertificates;\n+    }\n+\n+    public static Map<CertificateRequest, X509Certificate> mapCertificateRequests(KeychainWithCertsSpec spec) {\n+        return CertificateStats.get(spec).mapKnownCertificateRequests().entrySet().stream().collect(toMap(Map.Entry::getKey, e -> {\n+            return e.getValue().stream().reduce((x, y) -> {\n+                throw new IllegalStateException(String.format(\n+                        \"Certificates with hash=%s and hash=%s map into %s certificate request in [%s] keychain\",\n+                        CertificateHash.of(x), CertificateHash.of(y), e.getKey(), spec.keychain().name()));\n+            }).orElseThrow(() -> {\n+                throw new IllegalStateException(String.format(\n+                        \"A certificate matching %s certificate request not found in [%s] keychain\",\n+                        e.getKey(), spec.keychain().name()));\n+            });\n+        }));\n@@ -712,0 +879,14 @@\n+    private static boolean verifyCertificate(ResolvedCertificateRequest resolvedCertificateRequest, Keychain keychain, Path certFile) {\n+        PemData.of(resolvedCertificateRequest.cert()).save(certFile, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+        for (final var mode : List.of(\"-q\", \"-v\")) {\n+            final var ok = security(\"verify-cert\", \"-L\", \"-n\", mode,\n+                    \"-c\", certFile.normalize().toString(),\n+                    \"-k\", keychain.name(),\n+                    \"-p\", resolvedCertificateRequest.request().type().verifyPolicy()).executeWithoutExitCodeCheck().getExitCode() == 0;\n+            if (ok) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":222,"deletions":41,"binary":false,"changes":263,"status":"modified"}]}