{"files":[{"patch":"@@ -1,3 +1,8 @@\n-keys=jpackagePlatformPackage\n-requires.properties=jpackage.test.SQETest\n-maxOutputSize=2000000\n+keys = \\\n+    jpackagePlatformPackage\n+\n+requires.properties = \\\n+    jpackage.test.SQETest \\\n+    jpackage.test.MacSignTests\n+\n+maxOutputSize = 2000000\n@@ -12,1 +17,3 @@\n-exclusiveAccess.dirs=share windows\n+exclusiveAccess.dirs = \\\n+    share \\\n+    windows\n@@ -14,5 +21,6 @@\n-modules=jdk.jpackage\/jdk.jpackage.internal:+open \\\n-        jdk.jpackage\/jdk.jpackage.internal.util \\\n-        jdk.jpackage\/jdk.jpackage.internal.util.function \\\n-        java.base\/jdk.internal.util \\\n-        jdk.jlink\/jdk.tools.jlink.internal\n+modules = \\\n+    jdk.jpackage\/jdk.jpackage.internal:+open \\\n+    jdk.jpackage\/jdk.jpackage.internal.util \\\n+    jdk.jpackage\/jdk.jpackage.internal.util.function \\\n+    java.base\/jdk.internal.util \\\n+    jdk.jlink\/jdk.tools.jlink.internal\n","filename":"test\/jdk\/tools\/jpackage\/TEST.properties","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,1043 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.flatMapping;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.security.MessageDigest;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import javax.naming.ldap.LdapName;\n+import javax.naming.ldap.Rdn;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+\n+\/**\n+ * Utilities to setup identities and keychains for sign testing.\n+ * <p>\n+ * Identity is a pair of a private key and a certificate created with this\n+ * private key. It is used for signing. Keychain is a storage for identities.\n+ *\n+ * <ul>\n+ * <li>\"\/usr\/bin\/security\" command line tool manages keychains and identities.\n+ * <li>\"\/usr\/bin\/codesign\" command line tool uses identities to sign files and\n+ * folders.\n+ * <li>\"Keychain Access\" is GUI application to manage keychains and identities.\n+ * <\/ul>\n+ *\n+ * <ol>\n+ * <h1>How do you create an identity for testing?<\/h1>\n+ * <li>Create a private RSA key.\n+ * <li>Create a self-signed certificate using the key from step #1.\n+ * <li>Save both the private key and the certificate from steps #1 and #2 in a\n+ * keychain.\n+ * <li>Trust the certificate from step #2.\n+ * <\/ol>\n+ *\n+ * There are few options each above steps can be executed (applies to macOS\n+ * Sequoia).\n+ *\n+ * <h2>1. Create a private RSA key<\/h2>\n+ *\n+ * <h3>1.1. Create a private RSA key with openssl<\/h3>\n+ *\n+ * This is the obvious approach given openssl will be used to create a\n+ * certificate. You can create a key and a certificate with a single openssl\n+ * command. However the catch is importing the private key in a keystore.\n+ * <p>\n+ * All private keys imported in a keychain with {@code \/usr\/bin\/security import}\n+ * command have \"Imported Private Key\" label. There is no other tool to change\n+ * key labels but \"Keychain Access\".\n+ * <p>\n+ * On top of that the internal name of the key can NOT be changed at all. The\n+ * internal name of the key is the name assigned by \/usr\/bin\/security command\n+ * when it imports it. It derives it from the name of a file from which it\n+ * imports the key. E.g. say \"identity.pem\" file stores an identity, then\n+ *\n+ * <pre>\n+ * \/usr\/bin\/security import identity.pem -f pemseq -k foo.keychain\n+ * <\/pre>\n+ *\n+ * command will import a private key with internal name \"identity\" and name\n+ * \"Imported Private Key\" in \"foo.keychain\" keychain. You will see \"Imported\n+ * Private Key\" in the list of keys in \"Keychain Access\" app, but when you will\n+ * use this key with \/usr\/bin\/codesign it will prompt to enter keychain password\n+ * to access \"identity\" key. Even after you give a better name to this key\n+ * instead of \"Imported Private Key\", \/usr\/bin\/codesign will keep referring this\n+ * key as \"identity\".\n+ *\n+ * <h3>1.2. Create a private RSA key with \/usr\/bin\/security<\/h3>\n+ *\n+ * Use\n+ *\n+ * <pre>\n+ * \/usr\/bin\/security create-keypair -a rsa -s 2048 -k foo.keychain -T \/usr\/bin\/security -T \/usr\/bin\/codesign -T \/usr\/bin\/productbuild \"My key\"\n+ * <\/pre>\n+ *\n+ * command to create RSA key pair in \"foo.keychain\" keychain. Both private and\n+ * public keys will be named \"My key\". This way, you can get an adequately\n+ * identified private key in a keychain.\n+ * <p>\n+ * You will need to run an additional command to allow access to the private key\n+ * without being asked for the keychain password:\n+ *\n+ * <pre>\n+ * \/usr\/bin\/security set-key-partition-list -S apple-tool:,apple: -s -k ${KEYCHAIN-PASSWORD} foo.keychain\n+ * <\/pre>\n+ *\n+ * The only combination that suppresses popping up authorization dialog asking\n+ * for keychain password to access a private key when signing files with\n+ * \/usr\/bin\/codesign and \/usr\/bin\/productbuild commands is the above command and\n+ * {@code -T \/usr\/bin\/security -T \/usr\/bin\/codesign -T \/usr\/bin\/productbuild}\n+ * arguments in {@code \/usr\/bin\/security create-keypair} command.\n+ *\n+ * If you use {@code -A} instead of\n+ * {@code -T \/usr\/bin\/security -T \/usr\/bin\/codesign -T \/usr\/bin\/productbuild}\n+ * hoping it will grant blank permission to any app to use the key it will not\n+ * work.\n+ *\n+ * Running the subsequent {@code \/usr\/bin\/security set-key-partition-list...}\n+ * command will not help to suppress popping up the authorization dialog.\n+ *\n+ * <p>\n+ * The correlation between\n+ * {@code -T \/usr\/bin\/security -T \/usr\/bin\/codesign -T \/usr\/bin\/productbuild}\n+ * arguments of {@code \/usr\/bin\/security create-keypair} or\n+ * {@code \/usr\/bin\/security import} command and\n+ * {@code \/usr\/bin\/security set-key-partition-list...} command is not explicitly\n+ * documented and is not mentioned on <a href=\n+ * \"https:\/\/stackoverflow.com\/questions\/20205162\/user-interaction-is-not-allowed-trying-to-sign-an-osx-app-using-codesign\"\n+ * target=\"_blank\">Stack Overflow<\/a> or\n+ * <a href=\"https:\/\/developer.apple.com\/forums\/thread\/666107\" target=\n+ * \"_blank\">Apple Developer Forum<\/a>.\n+ *\n+ * <p>\n+ * Note #1: If user interaction is impossible (ssh session) and\n+ * \/usr\/bin\/codesign is not correctly configured in the access control list of a\n+ * private key it attempts to use it will fail with the following cryptic error:\n+ *\n+ * <pre>\n+ * AppImageMacSignTest.app\/Contents\/runtime\/Contents\/Home\/lib\/libnet.dylib: errSecInternalComponent\n+ * <\/pre>\n+ *\n+ * <p>\n+ * Note #2: For the same cause \/usr\/bin\/product build fails with a better error message:\n+ *\n+ * <pre>\n+ * SignData failed: Error Domain=NSOSStatusErrorDomain Code=-25308 ... (errKCInteractionNotAllowed \/ errSecInteractionNotAllowed: \/ Interaction is not allowed with the Security Server.)\n+ * <\/pre>\n+ *\n+ * <p>\n+ * You can extract the key to use with openssl for certificate creation with\n+ * {@code \/usr\/bin\/security export} command.\n+ *\n+ * <h2>2. Create a self-signed certificate<\/h2>\n+ *\n+ * No brainier, use openssl. If a private key was created with\n+ * {@code \/usr\/bin\/security create-keypair} command it needs to be extracted\n+ * from the keychain in a format suitable for openssl. This can be achieved with\n+ * the following command:\n+ *\n+ * <pre>\n+ * \/usr\/bin\/security export -f pkcs12 -k foo.keychain -t privKeys -P \"\" -o key.p12\n+ * <\/pre>\n+ *\n+ * The above command will save all private keys in a \"foo.keychain\" keychain in\n+ * a PKCS#12-encoded \"key.p12\" file with an empty passphrase.\n+ * <p>\n+ * Note #1: Given there is no way to extract specific private key from a\n+ * keystore make sure it contains a single private key.\n+ * <p>\n+ * Note #2: You can't extract private key in PEM format, i.e.\n+ * {@code \/usr\/bin\/security export -f pemseq -t privKeys} command will fail.\n+ * <p>\n+ * The inferior alternative is to use the GUI \"Certificate Assistant\" from\n+ * \"Keychain Access\".\n+ *\n+ * <h2>3. Save both private key and the certificate from steps #1 and #2 in a\n+ * keychain<\/h2>\n+ *\n+ * Assume private key has been created using\n+ * {@code \/usr\/bin\/security create-keypair} command and is already in a keychain\n+ * you only need to import a certificate created in step #2. If the certificate\n+ * was saved in \"cert.pem\" file in step #2, the following command:\n+ *\n+ * <pre>\n+ * \/usr\/bin\/security import cert.pem -f pemseq -k foo.keychain\n+ * <\/pre>\n+ *\n+ * will import a certificate from \"cert.pem\" file in \"foo.keychain\" keychain.\n+ *\n+ * <h2>4. Trust the certificate from step #2<\/h2>\n+ *\n+ * An untrusted certificate can NOT be used with \/usr\/bin\/codesign. Use\n+ *\n+ * <pre>\n+ * \/usr\/bin\/security security add-trusted-cert -k foo.keychain cert.pem\n+ * <\/pre>\n+ *\n+ * command to add trusted certificate from \"cert.pem\" file to \"foo.keychain\"\n+ * keychain. If the certificate is already in the keychain it will be marked\n+ * trusted.\n+ * <p>\n+ * This step can not be automated as there is no way to avoid entering a user\n+ * password.\n+ * <p>\n+ * Running this command with sudo doesn't help - it will ask for password twice\n+ * (unless you configure sudo not to ask a passowrd, in this case it will ask\n+ * once).\n+ * <p>\n+ * Running this command from ssh session will fail with the following error\n+ * message:\n+ *\n+ * <pre>\n+ * SecTrustSettingsSetTrustSettings: The authorization was denied since no user interaction was possible.\n+ * <\/pre>\n+ *\n+ * User interaction can NOT be avoided for this step. This is a deliberate\n+ * security constrained according to <a href=\n+ * \"https:\/\/developer.apple.com\/documentation\/macos-release-notes\/macos-big-sur-11_0_1-release-notes#Security\"\n+ * target=\"_blank\">Big Sur Release Notes<\/a> and\n+ * <a href=\"https:\/\/developer.apple.com\/forums\/thread\/671582\" target=\n+ * \"_blank\">Apple Developer Forum<\/a>.\n+ *\/\n+\n+public final class MacSign {\n+\n+    public record KeychainWithCertsSpec(Keychain keychain, List<CertificateRequest> certificateRequests) {\n+\n+        public KeychainWithCertsSpec {\n+            Objects.requireNonNull(keychain);\n+            Objects.requireNonNull(certificateRequests);\n+            certificateRequests.forEach(Objects::requireNonNull);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final var sb = new StringBuilder();\n+            sb.append(keychain);\n+            if (!certificateRequests.isEmpty()) {\n+                sb.append(\"; certs=\").append(certificateRequests);\n+            }\n+            return sb.toString();\n+        }\n+\n+        public static final class Builder {\n+\n+            public Builder name(String v) {\n+                keychainBuilder.name(v);\n+                return this;\n+            }\n+\n+            public Builder password(String v) {\n+                keychainBuilder.password(v);\n+                return this;\n+            }\n+\n+            public Builder addCert(CertificateRequest v) {\n+                certs.add(v);\n+                return this;\n+            }\n+\n+            public Builder addCert(CertificateRequest.Builder v) {\n+                return addCert(v.create());\n+            }\n+\n+            public KeychainWithCertsSpec create() {\n+                final var keychain = keychainBuilder.create();\n+                return new KeychainWithCertsSpec(keychain, List.copyOf(certs));\n+            }\n+\n+            private Keychain.Builder keychainBuilder = new Keychain.Builder();\n+            private List<CertificateRequest> certs = new ArrayList<>();\n+        }\n+    }\n+\n+    public record Keychain(String name, String password) {\n+        public Keychain {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(password);\n+        }\n+\n+        public Path path() {\n+            final var path = Path.of(name);\n+            if (path.isAbsolute()) {\n+                return path;\n+            } else {\n+                return Path.of(System.getProperty(\"user.home\")).resolve(\"Library\/Keychains\").resolve(name + \"-db\");\n+            }\n+        }\n+\n+        public static final class Builder {\n+\n+            public Builder name(String v) {\n+                name = v;\n+                return this;\n+            }\n+\n+            public Builder password(String v) {\n+                password = v;\n+                return this;\n+            }\n+\n+            public Keychain create() {\n+                return new Keychain(validatedName(), validatedPassword());\n+            }\n+\n+            private String validatedName() {\n+                return Optional.ofNullable(name).orElse(\"jpackageTest.keychain\");\n+            }\n+\n+            private String validatedPassword() {\n+                return Optional.ofNullable(password).orElse(\"test\");\n+            }\n+\n+            private String name;\n+            private String password;\n+        }\n+\n+        Keychain create() {\n+            final var exec = createExecutor(\"create-keychain\");\n+            final var result = exec.saveOutput().executeWithoutExitCodeCheck();\n+            if (result.getExitCode() == 48 && result.getFirstLineOfOutput().endsWith(\"A keychain with the same name already exists.\")) {\n+                delete();\n+                exec.saveOutput(false).execute();\n+            } else {\n+                result.assertExitCodeIsZero();\n+            }\n+\n+            \/\/ Ensure the keychain is unlocked.\n+            unlock();\n+\n+            \/\/ Set auto-lock timeout to unlimited and remove auto-lock on sleep.\n+            security(\"set-keychain-settings\", name).execute();\n+            return this;\n+        }\n+\n+        Keychain delete() {\n+            security(\"delete-keychain\", name).execute();\n+            return this;\n+        }\n+\n+        Keychain unlock() {\n+            createExecutor(\"unlock-keychain\").execute();\n+            return this;\n+        }\n+\n+        boolean exists() {\n+            return Files.exists(path());\n+        }\n+\n+        Keychain createKeyPair(String name) {\n+            security(\"create-keypair\",\n+                    \"-a\", \"rsa\",\n+                    \"-s\", \"2048\",\n+                    \"-k\", this.name,\n+                    \"-T\", \"\/usr\/bin\/security\",\n+                    \"-T\", \"\/usr\/bin\/codesign\",\n+                    \"-T\", \"\/usr\/bin\/productbuild\").execute();\n+            security(\"set-key-partition-list\", \"-S\", \"apple-tool:,apple:\", \"-s\", \"-k\", password, this.name).execute();\n+            return this;\n+        }\n+\n+        List<X509Certificate> findCertificates() {\n+            final var in = new ByteArrayInputStream(\n+                    security(\"find-certificate\", \"-ap\", name).saveOutput().execute().getOutput().stream().collect(joining(\"\\n\")).getBytes(StandardCharsets.UTF_8));\n+            return toFunction(CERT_FACTORY::generateCertificates).apply(in).stream().map(X509Certificate.class::cast).toList();\n+        }\n+\n+        public static void addToSearchList(Collection<Keychain> keychains) {\n+            security(\"list-keychains\", \"-d\", \"user\", \"-s\", \"login.keychain\")\n+            .addArguments(keychains.stream().map(Keychain::name).toList())\n+            .execute();\n+        }\n+\n+        private Executor createExecutor(String command) {\n+            return security(command, \"-p\", password, name);\n+        }\n+    }\n+\n+    record ResolvedCertificateRequest(CertificateRequest request, X509Certificate cert, VerifyStatus verifyStatus) {\n+        ResolvedCertificateRequest {\n+            Objects.requireNonNull(request);\n+            Objects.requireNonNull(cert);\n+            Objects.requireNonNull(verifyStatus);\n+        }\n+\n+        enum VerifyStatus {\n+            VERIFY_OK,\n+            VERIFY_ERROR,\n+            UNVERIFIED\n+        }\n+\n+        ResolvedCertificateRequest(X509Certificate cert) {\n+            this(new CertificateRequest(cert), cert, VerifyStatus.UNVERIFIED);\n+        }\n+\n+        ResolvedCertificateRequest copyVerified(boolean verifySuccess) {\n+            return new ResolvedCertificateRequest(request, cert,\n+                    verifySuccess ? VerifyStatus.VERIFY_OK : VerifyStatus.VERIFY_ERROR);\n+        }\n+    }\n+\n+    record CertificateStats(List<ResolvedCertificateRequest> allResolvedCertificateRequests,\n+            List<X509Certificate> allCertificates, List<CertificateRequest> knownCertificateRequests,\n+            Map<X509Certificate, Throwable> unmappedCertificates) {\n+\n+        private static CertificateStats get(KeychainWithCertsSpec spec) {\n+            return CACHE.computeIfAbsent(spec, CertificateStats::create);\n+        }\n+\n+        Map<CertificateRequest, List<X509Certificate>> mapKnownCertificateRequests() {\n+            return knownCertificateRequests.stream().collect(groupingBy(x -> x, mapping(certificateRequest -> {\n+                return allResolvedCertificateRequests.stream().filter(v -> {\n+                    return v.request().equals(certificateRequest);\n+                }).map(ResolvedCertificateRequest::cert);\n+            }, flatMapping(x -> x, toList()))));\n+        }\n+\n+        Set<CertificateRequest> verifyFailedCertificateRequests() {\n+            return knownCertificateRequests.stream().filter(certificateRequest -> {\n+                return allResolvedCertificateRequests.stream().anyMatch(v -> {\n+                    return v.request().equals(certificateRequest) && v.verifyStatus() == ResolvedCertificateRequest.VerifyStatus.VERIFY_ERROR;\n+                });\n+            }).collect(toSet());\n+        }\n+\n+        Set<CertificateRequest> unmappedCertificateRequests() {\n+            return Comm.compare(Set.copyOf(knownCertificateRequests),\n+                    allResolvedCertificateRequests.stream().map(ResolvedCertificateRequest::request).collect(toSet())).unique1();\n+        }\n+\n+        private static CertificateStats create(KeychainWithCertsSpec spec) {\n+            final var allCertificates = spec.keychain().findCertificates();\n+            final List<ResolvedCertificateRequest> allResolvedCertificateRequests = new ArrayList<>();\n+            final Map<X509Certificate, Throwable> unmappedCertificates = new HashMap<>();\n+\n+            withTempDirectory(workDir -> {\n+                for (final var cert : allCertificates) {\n+                    ResolvedCertificateRequest resolvedCertificateRequest;\n+                    try {\n+                        resolvedCertificateRequest = new ResolvedCertificateRequest(cert);\n+                    } catch (RuntimeException ex) {\n+                        final Throwable t;\n+                        if (ex instanceof ExceptionBox) {\n+                            t = ex.getCause();\n+                        } else {\n+                            t = ex;\n+                        }\n+                        unmappedCertificates.put(cert, t);\n+                        continue;\n+                    }\n+\n+                    if (spec.certificateRequests().contains(resolvedCertificateRequest.request)) {\n+                        final var certFile = workDir.resolve(CertificateHash.of(cert).toString() + \".pem\");\n+                        final var verifySuccess = verifyCertificate(resolvedCertificateRequest, spec.keychain(), certFile);\n+                        resolvedCertificateRequest = resolvedCertificateRequest.copyVerified(verifySuccess);\n+                    }\n+\n+                    allResolvedCertificateRequests.add(resolvedCertificateRequest);\n+                }\n+            });\n+\n+            return new CertificateStats(allResolvedCertificateRequests, List.copyOf(allCertificates),\n+                    List.copyOf(spec.certificateRequests()), unmappedCertificates);\n+        }\n+\n+        private static final Map<KeychainWithCertsSpec, CertificateStats> CACHE = new ConcurrentHashMap<>();\n+    }\n+\n+    record PemData(String label, byte[] data) {\n+        PemData {\n+            Objects.requireNonNull(label);\n+            Objects.requireNonNull(data);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final var sb = new StringBuilder();\n+            sb.append(frame(\"BEGIN \" + label));\n+            sb.append(ENCODER.encodeToString(data));\n+            sb.append(\"\\n\");\n+            sb.append(frame(\"END \" + label));\n+            return sb.toString();\n+        }\n+\n+        static PemData of(X509Certificate cert) {\n+            return new PemData(\"CERTIFICATE\", toSupplier(cert::getEncoded).get());\n+        }\n+\n+        void save(Path path, OpenOption... options) {\n+            try {\n+                Files.createDirectories(path.getParent());\n+                Files.writeString(path, toString(), options);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static String frame(String str) {\n+            return String.format(\"-----%s-----\\n\", Objects.requireNonNull(str));\n+        }\n+\n+        private final static Base64.Encoder ENCODER = Base64.getMimeEncoder(64, \"\\n\".getBytes());\n+    }\n+\n+    public record CertificateHash(byte[] value) {\n+        public CertificateHash {\n+            Objects.requireNonNull(value);\n+            if (value.length != 20) {\n+                throw new IllegalArgumentException(\"Invalid SHA-1 hash\");\n+            }\n+        }\n+\n+        public static CertificateHash of(X509Certificate cert) {\n+            return new CertificateHash(toSupplier(() -> {\n+                final MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n+                md.update(cert.getEncoded());\n+                return md.digest();\n+            }).get());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return FORMAT.formatHex(value);\n+        }\n+\n+        private static final HexFormat FORMAT = HexFormat.of().withUpperCase();\n+    }\n+\n+    public enum CertificateType {\n+        CODE_SIGN(List.of(\n+                \"basicConstraints=critical,CA:false\",\n+                \"keyUsage=critical,digitalSignature\"\n+        ), CODE_SIGN_EXTENDED_KEY_USAGE, \"codeSign\"),\n+        \/\/ https:\/\/www.apple.com\/certificateauthority\/pdf\/Apple_Developer_ID_CPS_v1.1.pdf\n+        \/\/ https:\/\/security.stackexchange.com\/questions\/17909\/how-to-create-an-apple-installer-package-signing-certificate\n+        \/\/ https:\/\/github.com\/zschuessler\/AXtendedKey\/blob\/32c8ccec3df7e78fe521d09c48bd20558b3a4a24\/src\/axtended_key\/services\/certificate_manager.py#L109C102-L109C115\n+        INSTALLER(List.of(\n+                \"basicConstraints=critical,CA:false\",\n+                \"keyUsage=critical,digitalSignature\",\n+                \/\/ Apple-specific extension for self-distributed apps\n+                \/\/ https:\/\/oid-base.com\/get\/1.2.840.113635.100.6.1.14\n+                \"1.2.840.113635.100.6.1.14=critical,DER:0500\"\n+        ), INSTALLER_EXTENDED_KEY_USAGE,\n+                \/\/ Should be \"pkgSign\", but with this policy `security verify-cert` command fails.\n+                \"basic\");\n+\n+        CertificateType(List<String> otherExtensions, List<String> extendedKeyUsage, String verifyPolicy) {\n+            this.otherExtensions = otherExtensions;\n+            this.extendedKeyUsage = extendedKeyUsage;\n+            this.verifyPolicy = verifyPolicy;\n+        }\n+\n+        boolean isTypeOf(X509Certificate cert) {\n+            return toSupplier(() -> cert.getExtendedKeyUsage().containsAll(extendedKeyUsage)).get();\n+        }\n+\n+        List<String> extensions() {\n+            return Stream.concat(otherExtensions.stream(),\n+                    Stream.of(\"extendedKeyUsage=\" + Stream.concat(Stream.of(\"critical\"), extendedKeyUsage.stream()).collect(joining(\",\")))).toList();\n+        }\n+\n+        String verifyPolicy() {\n+            return verifyPolicy;\n+        }\n+\n+        private final List<String> otherExtensions;\n+        private final List<String> extendedKeyUsage;\n+        private final String verifyPolicy;\n+    }\n+\n+    public record CertificateRequest(String name, CertificateType type, int days) implements Comparable<CertificateRequest>{\n+        public CertificateRequest {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(type);\n+        }\n+\n+        CertificateRequest(X509Certificate cert) {\n+            this(getSubjectCN(cert), getType(cert), getDurationInDays(cert));\n+        }\n+\n+        @Override\n+        public int compareTo(CertificateRequest o) {\n+            return COMPARATOR.compare(this, o);\n+        }\n+\n+        public static final class Builder {\n+\n+            public Builder userName(String v) {\n+                userName = v;\n+                return this;\n+            }\n+\n+            public Builder commonName(String v) {\n+                commonName = v;\n+                return this;\n+            }\n+\n+            public Builder type(CertificateType v) {\n+                type = v;\n+                return this;\n+            }\n+\n+            public Builder days(int v) {\n+                days = v;\n+                return this;\n+            }\n+\n+            public CertificateRequest create() {\n+                return new CertificateRequest(validatedCN(), type, days);\n+            }\n+\n+            private String validatedUserName() {\n+                return Objects.requireNonNull(userName);\n+            }\n+\n+            private String validatedCN() {\n+                return Optional.ofNullable(commonName).orElseGet(() -> {\n+                    switch (type) {\n+                        case CODE_SIGN -> {\n+                            return \"Developer ID Application: \" + validatedUserName();\n+                        }\n+                        case INSTALLER -> {\n+                            return \"Developer ID Installer: \" + validatedUserName();\n+                        }\n+                        default -> {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    }\n+                });\n+            }\n+\n+            private String userName;\n+            private String commonName; \/\/ CN\n+            private CertificateType type = CertificateType.CODE_SIGN;\n+            private int days = 365;\n+        }\n+\n+        private static String getSubjectCN(X509Certificate cert) {\n+            final var principal = cert.getSubjectX500Principal();\n+            final var ldapName = toSupplier(() -> new LdapName(principal.getName())).get();\n+            return ldapName.getRdns().stream().filter(rdn -> {\n+                return rdn.getType().equalsIgnoreCase(\"CN\");\n+            }).map(Rdn::getValue).map(Object::toString).distinct().reduce((x, y) -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Certificate with hash=%s has multiple subject common names: [%s], [%s]\", CertificateHash.of(cert), x, y));\n+            }).orElseThrow(() -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Certificate with hash=%s doesn't have subject common name\", CertificateHash.of(cert)));\n+            });\n+        }\n+\n+        private static CertificateType getType(X509Certificate cert) {\n+            return Stream.of(CertificateType.values()).filter(certType -> {\n+                return certType.isTypeOf(cert);\n+            }).reduce((x, y) -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Ambiguous type of a certificate with hash=%s: [%s], [%s]\", CertificateHash.of(cert), x, y));\n+            }).orElseThrow(() -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Unrecognized type of a certificate with hash=%s\", CertificateHash.of(cert)));\n+            });\n+        }\n+\n+        private static int getDurationInDays(X509Certificate cert) {\n+            final var notBefore = cert.getNotBefore();\n+            final var notAfter = cert.getNotAfter();\n+            return (int)TimeUnit.DAYS.convert(notAfter.getTime() - notBefore.getTime(), TimeUnit.MILLISECONDS);\n+        }\n+\n+        private static final Comparator<CertificateRequest> COMPARATOR =\n+                Comparator.comparing(CertificateRequest::name)\n+                .thenComparing(Comparator.comparing(CertificateRequest::type))\n+                .thenComparing(Comparator.comparingInt(CertificateRequest::days));\n+    }\n+\n+    \/**\n+     * Creates keychains and signing identities from the given configuration.\n+     * <p>\n+     * It will create a single private key and unique certificate using this key for\n+     * every unique {@linkplain CertificateRequest} instance.\n+     * <p>\n+     * Created certificates will be imported into the keychains, and every\n+     * certificate will be marked as trusted.\n+     * <p>\n+     * The user will be prompted to enter the user login password as\n+     * many times as the number of unique certificates this function will create.\n+     *\n+     * @param specs the keychains and signing identities configuration\n+     *\/\n+    public static void setUp(List<KeychainWithCertsSpec> specs) {\n+        validate(specs);\n+\n+        if (!OPENSSL.isAbsolute()) {\n+            final var opensslVer = Executor.of(OPENSSL.toString(), \"version\").saveFirstLineOfOutput().execute().getFirstLineOfOutput();\n+            TKit.trace(String.format(\"openssl version: %s\", opensslVer));\n+        }\n+\n+        traceSigningEnvironment(specs);\n+\n+        \/\/ Reset keychain search list to defaults.\n+        Keychain.addToSearchList(List.of());\n+\n+        final var mainKeychain = specs.getFirst().keychain();\n+\n+        \/\/ Init basic keychain from scratch.\n+        \/\/ This will create the keychain file and the key pair.\n+        mainKeychain.create().createKeyPair(\"jpackage test key\");\n+\n+        \/\/ Use the same private key to create certificates in additional keychains.\n+        for (final var keychainSpec : specs.subList(1, specs.size())) {\n+            final var keychainFile = keychainSpec.keychain().path();\n+            TKit.trace(String.format(\"Create keychain in [%s] file from [%s] keychain\", keychainFile, mainKeychain.name()));\n+            try {\n+                Files.copy(mainKeychain.path(), keychainFile, StandardCopyOption.REPLACE_EXISTING);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        withTempDirectory(dir -> {\n+            \/\/ Create certificates.\n+            final var certPemFiles = createCertificates(mainKeychain, specs, dir);\n+\n+            final Map<Path, Keychain> trustConfig = new HashMap<>();\n+\n+            for (final var certPemFile : certPemFiles.entrySet()) {\n+                \/\/ Import the certificate in all keychains it belongs to.\n+                final var keychains = findKeychains(certPemFile.getKey(), specs).toList();\n+                keychains.forEach(keychain -> {\n+                    MacSign.security(\"import\", certPemFile.getValue().normalize().toString(),\n+                            \"-k\", keychain.name(),\n+                            \"-f\", \"pemseq\",\n+                            \"-t\", \"agg\",\n+                            \"-A\").execute();\n+                });\n+\n+                trustConfig.put(certPemFile.getValue(), keychains.getFirst());\n+            }\n+\n+            \/\/ Trust certificates.\n+            trustCertificates(trustConfig);\n+        });\n+\n+        Keychain.addToSearchList(specs.stream().map(KeychainWithCertsSpec::keychain).toList());\n+    }\n+\n+    \/**\n+     * Destroys the given signing configuration.\n+     * <p>\n+     * It will remove specified keychains from the keychain search list and delete\n+     * the keychain files.\n+     *\n+     * @param specs the keychains and signing identities configuration\n+     *\/\n+    public static void tearDown(List<KeychainWithCertsSpec> specs) {\n+        validate(specs);\n+        Keychain.addToSearchList(List.of());\n+        specs.forEach(spec -> {\n+            spec.keychain().delete();\n+        });\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the given signing configuration is deployed and in\n+     * good standing.\n+     *\n+     * @param specs the keychains and signing identities configuration\n+     * @return {@code true} if the given signing configuration is deployed and in\n+     *         good standing\n+     *\/\n+    public static boolean isDeployed(List<KeychainWithCertsSpec> specs) {\n+        validate(specs);\n+        traceSigningEnvironment(specs);\n+\n+        final var missingKeychain = specs.stream().map(KeychainWithCertsSpec::keychain).filter(Predicate.not(Keychain::exists)).peek(keychain -> {\n+            TKit.trace(String.format(\"Missing [%s] keychain file\", keychain.path()));\n+        }).findAny().isPresent();\n+\n+        final var specsWithExistingKeychains = specs.stream().filter(spec -> {\n+            return spec.keychain().exists();\n+        }).toList();\n+\n+        final var certificateStats = specsWithExistingKeychains.stream().collect(\n+                toMap(KeychainWithCertsSpec::keychain, CertificateStats::get));\n+\n+        for (final var keychain : specsWithExistingKeychains.stream().map(KeychainWithCertsSpec::keychain).toList()) {\n+            TKit.trace(String.format(\"In [%s] keychain:\", keychain.name()));\n+            final var certificateStat = certificateStats.get(keychain);\n+            final var resolvedCertificateRequests = certificateStat.allResolvedCertificateRequests().stream()\n+                    .sorted(Comparator.comparing(ResolvedCertificateRequest::request)).toList();\n+            for (final var resolvedCertificateRequest : resolvedCertificateRequests) {\n+                TKit.trace(String.format(\"  Certificate with hash=%s: %s[%s]\",\n+                        CertificateHash.of(resolvedCertificateRequest.cert()),\n+                        resolvedCertificateRequest.request(),\n+                        resolvedCertificateRequest.verifyStatus()));\n+            }\n+\n+            for (final var unmappedCertificate : certificateStat.unmappedCertificates().entrySet()) {\n+                TKit.trace(String.format(\"  Failed to create certificate request from the certificate with hash=%s: %s\",\n+                        CertificateHash.of(unmappedCertificate.getKey()), unmappedCertificate.getValue()));\n+            }\n+\n+            for (final var unmappedCertificateRequest : certificateStat.unmappedCertificateRequests().stream().sorted().toList()) {\n+                TKit.trace(String.format(\"  Missing certificate for %s certificate request\", unmappedCertificateRequest));\n+            }\n+        }\n+\n+        final var missingCertificates = certificateStats.values().stream().anyMatch(stat -> {\n+            return !stat.unmappedCertificateRequests().isEmpty();\n+        });\n+\n+        final var invalidCertificates = certificateStats.values().stream().anyMatch(stat -> {\n+            return !stat.verifyFailedCertificateRequests().isEmpty();\n+        });\n+\n+        return !missingKeychain && !missingCertificates && !invalidCertificates;\n+    }\n+\n+    public static Map<CertificateRequest, X509Certificate> mapCertificateRequests(KeychainWithCertsSpec spec) {\n+        return CertificateStats.get(spec).mapKnownCertificateRequests().entrySet().stream().collect(toMap(Map.Entry::getKey, e -> {\n+            return e.getValue().stream().reduce((x, y) -> {\n+                throw new IllegalStateException(String.format(\n+                        \"Certificates with hash=%s and hash=%s map into %s certificate request in [%s] keychain\",\n+                        CertificateHash.of(x), CertificateHash.of(y), e.getKey(), spec.keychain().name()));\n+            }).orElseThrow(() -> {\n+                throw new IllegalStateException(String.format(\n+                        \"A certificate matching %s certificate request not found in [%s] keychain\",\n+                        e.getKey(), spec.keychain().name()));\n+            });\n+        }));\n+    }\n+\n+    private static void validate(List<KeychainWithCertsSpec> specs) {\n+        specs.stream().map(KeychainWithCertsSpec::keychain).map(Keychain::name).collect(toMap(x -> x, x -> x, (x, y) -> {\n+            throw new IllegalArgumentException(String.format(\"Multiple keychains with the same name [%s]\", x));\n+        }));\n+\n+        specs.stream().forEach(spec -> {\n+            spec.certificateRequests().stream().collect(toMap(x -> x, x -> x, (x, y) -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Multiple certificate requests with the same specification %s in one keychain [%s]\", x, spec.keychain().name()));\n+            }));\n+        });\n+    }\n+\n+    private static boolean verifyCertificate(ResolvedCertificateRequest resolvedCertificateRequest, Keychain keychain, Path certFile) {\n+        PemData.of(resolvedCertificateRequest.cert()).save(certFile, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+        for (final var mode : List.of(\"-q\", \"-v\")) {\n+            final var ok = security(\"verify-cert\", \"-L\", \"-n\", mode,\n+                    \"-c\", certFile.normalize().toString(),\n+                    \"-k\", keychain.name(),\n+                    \"-p\", resolvedCertificateRequest.request().type().verifyPolicy()).executeWithoutExitCodeCheck().getExitCode() == 0;\n+            if (ok) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void traceSigningEnvironment(Collection<KeychainWithCertsSpec> specs) {\n+        TKit.trace(\"Signing environment:\");\n+        int specIdx = 1;\n+        for (final var spec : specs) {\n+            TKit.trace(String.format(\"[%d\/%d] %s\", specIdx++, specs.size(), spec.keychain()));\n+            int certRequestIdx = 1;\n+            for (final var certRequest : spec.certificateRequests()) {\n+                TKit.trace(String.format(\"  [%d\/%d] %s\", certRequestIdx++, spec.certificateRequests().size(), certRequest));\n+            }\n+        }\n+    }\n+\n+    private static Stream<Keychain> findKeychains(CertificateRequest certificateRequest,\n+            Collection<KeychainWithCertsSpec> specs) {\n+        Objects.requireNonNull(certificateRequest);\n+        return specs.stream().filter(spec -> {\n+            return spec.certificateRequests().contains(certificateRequest);\n+        }).map(KeychainWithCertsSpec::keychain);\n+    }\n+\n+    private static void withTempDirectory(ThrowingConsumer<Path> callback) {\n+        try {\n+            final var dir = Files.createTempDirectory(\"jdk.jpackage.test\");\n+            try {\n+                ThrowingConsumer.toConsumer(callback).accept(dir);\n+            } finally {\n+                TKit.deleteDirectoryRecursive(dir, \"\");\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static Map<CertificateRequest, Path> createCertificates(Keychain privateKeySource,\n+            Collection<KeychainWithCertsSpec> specs, Path outputPemDir) {\n+\n+        Objects.requireNonNull(privateKeySource);\n+        Objects.requireNonNull(specs);\n+        specs.forEach(Objects::requireNonNull);\n+        Objects.requireNonNull(outputPemDir);\n+\n+        final Map<CertificateRequest, X509Certificate> createdCertificates = new HashMap<>();\n+\n+        withTempDirectory(tmpDir -> {\n+            final var cfgFile = tmpDir.resolve(\"cert.cfg\");\n+            final var certFile = tmpDir.resolve(\"cert.pem\");\n+            final var keyFilePKCS12 = tmpDir.resolve(\"key.p12\");\n+            final var keyFilePEM = tmpDir.resolve(\"key.pem\");\n+\n+            security(\"export\",\n+                    \"-f\", \"pkcs12\",\n+                    \"-k\", privateKeySource.name(),\n+                    \"-t\", \"privKeys\",\n+                    \"-P\", \"\",\n+                    \"-o\", keyFilePKCS12.normalize().toString()).execute();\n+\n+            \/\/ This step is needed only for LibreSSL variant of openssl command which can't take\n+            \/\/ private key in PKCS#12 format.\n+            Executor.of(OPENSSL.toString(), \"pkcs12\",\n+                    \"-nodes\",\n+                    \"-in\", keyFilePKCS12.normalize().toString(),\n+                    \"-password\", \"pass:\",\n+                    \"-out\", keyFilePEM.normalize().toString()).dumpOutput().execute();\n+\n+            final var keyFile = keyFilePEM;\n+\n+            for (final var spec : specs) {\n+                for (final var certificateRequest : spec.certificateRequests()) {\n+                    var cert = createdCertificates.get(certificateRequest);\n+                    if (cert == null) {\n+                        TKit.createTextFile(cfgFile, Stream.of(\n+                                \"[ req ]\",\n+                                \"distinguished_name = req_name\",\n+                                \"prompt=no\",\n+                                \"[ req_name ]\",\n+                                \"CN=\" + certificateRequest.name()\n+                        ));\n+\n+                        final var openssl = Executor.of(OPENSSL.toString(), \"req\",\n+                                \"-x509\", \"-utf8\", \"-sha256\", \"-nodes\",\n+                                \"-new\", \/\/ Prevents LibreSSL variant of openssl command from hanging\n+                                \"-days\", Integer.toString(certificateRequest.days()),\n+                                \"-key\", keyFile.normalize().toString(),\n+                                \"-config\", cfgFile.normalize().toString(),\n+                                \"-out\", certFile.normalize().toString());\n+\n+                        certificateRequest.type().extensions().forEach(ext -> {\n+                            openssl.addArgument(\"-addext\");\n+                            openssl.addArgument(ext);\n+                        });\n+\n+                        openssl.dumpOutput().execute();\n+\n+                        try (final var in = Files.newInputStream(certFile)) {\n+                            cert = (X509Certificate)CERT_FACTORY.generateCertificate(in);\n+                            createdCertificates.put(certificateRequest, cert);\n+\n+                            final var certHash = CertificateHash.of(cert);\n+                            final var certPemFile = outputPemDir.resolve(certHash.toString() + \".pem\");\n+                            Files.copy(certFile, certPemFile);\n+                        }\n+                    }\n+                }\n+            }\n+        });\n+\n+        return createdCertificates.entrySet().stream().collect(toMap(Map.Entry::getKey, e -> {\n+            final var certHash = CertificateHash.of(e.getValue());\n+            return outputPemDir.resolve(certHash.toString() + \".pem\");\n+        }));\n+    }\n+\n+    private static void trustCertificates(Map<Path, Keychain> config) {\n+        if (config.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        final var exec = Executor.of(\"osascript\", SIGN_UTILS_SCRIPT.toString(), \"trust-certs\",\n+                config.keySet().iterator().next().getParent().toAbsolutePath().toString());\n+\n+        exec.addArguments(config.entrySet().stream().map(e -> {\n+            return Stream.of(e.getValue().name(), e.getKey().getFileName().toString());\n+        }).flatMap(x -> x).toList());\n+\n+        exec.dumpOutput().execute();\n+    }\n+\n+    static Executor security(String... args) {\n+        return Executor.of(\"security\").dumpOutput().addArguments(args);\n+    }\n+\n+    private static final CertificateFactory CERT_FACTORY = toSupplier(() -> {\n+        return CertificateFactory.getInstance(\"X.509\");\n+    }).get();\n+\n+    \/\/ Code Signing\n+    private static final List<String> CODE_SIGN_EXTENDED_KEY_USAGE = List.of(\"1.3.6.1.5.5.7.3.3\");\n+    \/\/ Apple Custom Extended Key Usage (EKU) packageSign\n+    \/\/ https:\/\/oid-base.com\/get\/1.2.840.113635.100.4.13\n+    private static final List<String> INSTALLER_EXTENDED_KEY_USAGE = List.of(\"1.2.840.113635.100.4.13\");\n+\n+    private static final Path SIGN_UTILS_SCRIPT = TKit.TEST_SRC_ROOT.resolve(\"resources\/sign-utils.applescript\").normalize();\n+\n+    \/\/ macOS comes with \/usr\/bin\/openssl which is LibreSSL\n+    \/\/ If you install openssl with Homebrew, it will be installed in \/usr\/local\/bin\/openssl,\n+    \/\/ and the PATH env variable will be altered to pick up openssl from Homebrew.\n+    \/\/ However, jtreg will alter the value of the PATH env variable and\n+    \/\/ \/usr\/bin\/openssl will preempt \/usr\/local\/bin\/openssl.\n+    \/\/ To workaround this jtreg behavior support specifying path to openssl command.\n+    private static final Path OPENSSL = Path.of(Optional.ofNullable(TKit.getConfigProperty(\"openssl\")).orElse(\"openssl\"));\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":1043,"deletions":0,"binary":false,"changes":1043,"status":"added"},{"patch":"@@ -521,1 +521,0 @@\n-        trace(\"Skip the test: \" + reason);\n@@ -525,0 +524,2 @@\n+        return throwSkippedException(reason);\n+    }\n@@ -526,0 +527,2 @@\n+    public static RuntimeException throwSkippedException(RuntimeException ex) {\n+        trace(\"Skip the test: \" + ex.getMessage());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-            if (!KEEP_WORK_DIR.contains(status)) {\n+            if (!KEEP_WORK_DIR.contains(status) && Files.isDirectory(workDir)) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestInstance.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,3 +27,1 @@\n-\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.TKit;\n+import java.util.stream.Stream;\n@@ -32,0 +30,33 @@\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.MacSign.CertificateType;\n+import jdk.jpackage.test.MacSign.CertificateRequest;\n+import jdk.jpackage.test.MacSign.KeychainWithCertsSpec;\n+import jdk.jpackage.test.TKit;\n+\n+\n+\/*\n+ * @test\n+ * @summary Setup the environment for jpackage macos signing tests.\n+ *          Creates required keychains and signing identities.\n+ *          Does NOT run any jpackag tests.\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @requires (jpackage.test.MacSignTests == \"setup\")\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningBase.setUp\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tear down the environment for jpackage macos signing tests.\n+ *          Deletes required keychains and signing identities.\n+ *          Does NOT run any jpackag tests.\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @requires (jpackage.test.MacSignTests == \"teardown\")\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningBase.tearDown\n+ *\/\n@@ -35,0 +66,50 @@\n+    enum StandardKeychain {\n+        MAIN(DEFAULT_KEYCHAIN,\n+                cert().userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()]).create(),\n+                cert().type(CertificateType.INSTALLER).userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()]).create(),\n+                cert().userName(DEV_NAMES[CertIndex.UNICODE_INDEX.value()]).create(),\n+                cert().type(CertificateType.INSTALLER).userName(DEV_NAMES[CertIndex.UNICODE_INDEX.value()]).create());\n+\n+        StandardKeychain(String keychainName, CertificateRequest cert, CertificateRequest... otherCerts) {\n+            final var builder = keychain(keychainName).addCert(cert);\n+            List.of(otherCerts).forEach(builder::addCert);\n+            this.spec = builder.create();\n+        }\n+\n+        KeychainWithCertsSpec spec() {\n+            return spec;\n+        }\n+\n+        private static KeychainWithCertsSpec.Builder keychain(String name) {\n+            return new KeychainWithCertsSpec.Builder().name(name);\n+        }\n+\n+        private static CertificateRequest.Builder cert() {\n+            return new CertificateRequest.Builder();\n+        }\n+\n+        private static List<KeychainWithCertsSpec> signingEnv() {\n+            return Stream.of(values()).map(StandardKeychain::spec).toList();\n+        }\n+\n+        final KeychainWithCertsSpec spec;\n+    }\n+\n+    public static void setUp() {\n+        MacSign.setUp(StandardKeychain.signingEnv());\n+    }\n+\n+    public static void tearDown() {\n+        MacSign.tearDown(StandardKeychain.signingEnv());\n+    }\n+\n+    public static void verifySignTestEnvReady() {\n+        if (!Inner.SIGN_ENV_READY) {\n+            TKit.throwSkippedException(new IllegalStateException(\"Misconfigured signing test environment\"));\n+        }\n+    }\n+\n+    private final class Inner {\n+        private final static boolean SIGN_ENV_READY = MacSign.isDeployed(StandardKeychain.signingEnv());\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":84,"deletions":3,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+(*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *)\n+\n+on run argv\n+  set action to (item 1 of argv)\n+\n+  if action is \"run-shell-script\" then\n+    runShellCommandInTerminal (item 2 of argv)\n+  else if action is \"trust-certs\" then\n+    set certs to {}\n+    set certFileDir to (item 2 of argv)\n+    repeat with i from 3 to (length of argv) by 2\n+      set end of certs to {keychain: item i of argv, cert: certFileDir & \"\/\" & item (i + 1) of argv}\n+    end repeat\n+    trustCerts(certs)\n+  else\n+    error \"Unrecognized command: [\" & action & \"]\"\n+  end if\n+end run\n+\n+\n+on trustCerts(certs)\n+  set runShellScriptInTerminal to \"osascript \" & quoted form of (POSIX path of (path to me)) & \" run-shell-script \"\n+  repeat with i from 1 to count of certs\n+    set cert to item i of certs\n+    set theLabel to \"certificate [\" & i & \"\/\" & count of certs & \"]\"\n+    repeat\n+      tell application \"Finder\"\n+        activate\n+        display dialog (\"Trust \" & theLabel) giving up after 60\n+      end tell\n+      if button returned of result = \"OK\" then\n+        try\n+          set theScript to \"\/usr\/bin\/security add-trusted-cert -k \" & quoted form of (keychain of cert) & \" \" & quoted form of (cert of cert)\n+          set theCmdline to runShellScriptInTerminal & quoted form of theScript\n+          log \"Execute: \" & theCmdline\n+          do shell script theCmdline\n+          log \"Trusted \" & theLabel\n+          exit repeat\n+        on error errMsg number errNum\n+          log \"Error occurred: \" & errMsg & \" (Error Code: \" & errNum & \")\"\n+        end try\n+      else if gave up of result then\n+        error \"Timeout of a request to trust \" & theLabel\n+      end if\n+    end repeat\n+  end repeat\n+end trustCerts\n+\n+\n+on runShellCommandInTerminal(shellCommand)\n+  waitShellCommandAndCloseTerminalWindow(startShellCommandInTerminal(shellCommand))\n+end runShellCommandInTerminal\n+\n+\n+on startShellCommandInTerminal(shellCommand)\n+  set runningFile to do shell script \"mktemp\"\n+  tell application \"Terminal\"\n+    set theTab to do script shellCommand & \"; rm -f \" & quoted form of runningFile & \"; exit\"\n+    log theTab\n+    return {terminalTab: theTab, file: runningFile}\n+  end tell\n+end startShellCommandInTerminal\n+\n+\n+on waitShellCommandAndCloseTerminalWindow(tabWithRunningFile)\n+  repeat\n+    try\n+      do shell script \"test -f \" & quoted form of file of tabWithRunningFile\n+      -- shell script is still running\n+      delay 2\n+    on error\n+      -- shell script is done, exit\n+      exit repeat\n+    end try\n+  end repeat\n+  closeTerminalTab(terminalTab of tabWithRunningFile)\n+end waitShellCommandAndCloseTerminalWindow\n+\n+\n+on closeTerminalTab(theTab)\n+  -- Find the window owning \"theTab\" tab and close it\n+  tell application \"Terminal\"\n+    repeat with w in windows\n+      repeat with t in tabs of w\n+        if theTab is contents of t then\n+          log \"Closing window \" & (id of w)\n+          close w\n+          return\n+        end if\n+      end repeat\n+    end repeat\n+  end tell\n+end closeTerminalTab\n","filename":"test\/jdk\/tools\/jpackage\/resources\/sign-utils.applescript","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}