{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import static java.util.stream.Collectors.toSet;\n@@ -48,0 +49,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n@@ -49,0 +52,3 @@\n+import javax.naming.ldap.LdapName;\n+import javax.naming.ldap.Rdn;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -243,2 +249,1 @@\n-    public record KeychainWithCertsSpec(Keychain keychain, List<CertificateRequest> certificateRequests,\n-            List<X509Certificate> certificates) {\n+    public record KeychainWithCertsSpec(Keychain keychain, List<CertificateRequest> certificateRequests) {\n@@ -248,1 +253,0 @@\n-            Objects.requireNonNull(certificates);\n@@ -251,7 +255,0 @@\n-            if (!certificates.isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        public KeychainWithCertsSpec(Keychain keychain, List<CertificateRequest> certificateRequests) {\n-            this(keychain, certificateRequests, new ArrayList<>());\n@@ -267,3 +264,0 @@\n-            if (!certificates.isEmpty()) {\n-                sb.append(\"; certs=\").append(certificates.stream().map(CertificateHash::of).toList());\n-            }\n@@ -336,1 +330,1 @@\n-                return Optional.ofNullable(name).orElse(\"jpackagerTest.keychain\");\n+                return Optional.ofNullable(name).orElse(\"jpackageTest.keychain\");\n@@ -375,0 +369,4 @@\n+        boolean exists() {\n+            return Files.exists(path());\n+        }\n+\n@@ -435,4 +433,2 @@\n-                \"keyUsage=critical,digitalSignature\",\n-                \/\/ Code Signing\n-                \"extendedKeyUsage=critical,1.3.6.1.5.5.7.3.3\"\n-        )),\n+                \"keyUsage=critical,digitalSignature\"\n+        ), CODE_SIGN_EXTENDED_KEY_USAGE),\n@@ -445,3 +441,0 @@\n-                \/\/ Apple Custom Extended Key Usage (EKU) packageSign\n-                \/\/ https:\/\/oid-base.com\/get\/1.2.840.113635.100.4.13\n-                \"extendedKeyUsage=critical,1.2.840.113635.100.4.13\",\n@@ -451,1 +444,1 @@\n-        ));\n+        ), INSTALLER_EXTENDED_KEY_USAGE);\n@@ -453,2 +446,3 @@\n-        CertificateType(List<String> extensions) {\n-            this.extensions = extensions;\n+        CertificateType(List<String> otherExtensions, List<String> extendedKeyUsage) {\n+            this.otherExtensions = otherExtensions;\n+            this.extendedKeyUsage = extendedKeyUsage;\n@@ -457,1 +451,11 @@\n-        final List<String> extensions;\n+        boolean isTypeOf(X509Certificate cert) {\n+            return toSupplier(() -> cert.getExtendedKeyUsage().containsAll(extendedKeyUsage)).get();\n+        }\n+\n+        List<String> extensions() {\n+            return Stream.concat(otherExtensions.stream(),\n+                    Stream.of(\"extendedKeyUsage=\" + Stream.concat(Stream.of(\"critical\"), extendedKeyUsage.stream()).collect(joining(\",\")))).toList();\n+        }\n+\n+        private final List<String> otherExtensions;\n+        private final List<String> extendedKeyUsage;\n@@ -466,0 +470,4 @@\n+        CertificateRequest(X509Certificate cert) {\n+            this(getSubjectCN(cert), getType(cert), getDurationInDays(cert));\n+        }\n+\n@@ -503,1 +511,1 @@\n-                            return \"Developer ID Installer: \" + validatedUserName();\n+                            return \"Developer ID Installer2: \" + validatedUserName();\n@@ -517,0 +525,32 @@\n+\n+        private static String getSubjectCN(X509Certificate cert) {\n+            final var principal = cert.getSubjectX500Principal();\n+            final var ldapName = toSupplier(() -> new LdapName(principal.getName())).get();\n+            return ldapName.getRdns().stream().filter(rdn -> {\n+                return rdn.getType().equalsIgnoreCase(\"CN\");\n+            }).map(Rdn::getValue).map(Object::toString).distinct().reduce((x, y) -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Certificate with hash=%s has multiple subject common names: [%s], [%s]\", CertificateHash.of(cert), x, y));\n+            }).orElseThrow(() -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Certificate with hash=%s doesn't have subject common name\", CertificateHash.of(cert)));\n+            });\n+        }\n+\n+        private static CertificateType getType(X509Certificate cert) {\n+            return Stream.of(CertificateType.values()).filter(certType -> {\n+                return certType.isTypeOf(cert);\n+            }).reduce((x, y) -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Ambiguous type of a certificate with hash=%s: [%s], [%s]\", CertificateHash.of(cert), x, y));\n+            }).orElseThrow(() -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Unrecognized type of a certificate with hash=%s\", CertificateHash.of(cert)));\n+            });\n+        }\n+\n+        private static int getDurationInDays(X509Certificate cert) {\n+            final var notBefore = cert.getNotBefore();\n+            final var notAfter = cert.getNotAfter();\n+            return (int)TimeUnit.DAYS.convert(notAfter.getTime() - notBefore.getTime(), TimeUnit.MILLISECONDS);\n+        }\n@@ -534,3 +574,1 @@\n-        specs.stream().map(KeychainWithCertsSpec::keychain).map(Keychain::name).collect(toMap(x -> x, x -> x, (x, y) -> {\n-            throw new IllegalArgumentException(String.format(\"Multiple keychains with the same name [%s]\", x));\n-        }));\n+        validate(specs);\n@@ -538,3 +576,3 @@\n-        TKit.trace(\"Signing environment:\");\n-        for (int i = 0; i != specs.size(); ++i) {\n-            TKit.trace(String.format(\"[%d\/%d] %s\", i + 1, specs.size(), specs.get(i)));\n+        if (!OPENSSL.isAbsolute()) {\n+            final var opensslVer = Executor.of(OPENSSL.toString(), \"version\").saveFirstLineOfOutput().execute().getFirstLineOfOutput();\n+            TKit.trace(String.format(\"openssl version: %s\", opensslVer));\n@@ -543,0 +581,2 @@\n+        traceSigningEnvironment(specs);\n+\n@@ -599,0 +639,1 @@\n+        validate(specs);\n@@ -605,0 +646,78 @@\n+    \/**\n+     * Returns {@code true} if the given signing configuration is deployed and in\n+     * good standing.\n+     *\n+     * @param specs the keychains and signing identities configuration\n+     * @return {@code true} if the given signing configuration is deployed and in\n+     *         good standing\n+     *\/\n+    public static boolean isDeployed(List<KeychainWithCertsSpec> specs) {\n+        validate(specs);\n+        traceSigningEnvironment(specs);\n+\n+        final var missingKeychain = specs.stream().map(KeychainWithCertsSpec::keychain).filter(Predicate.not(Keychain::exists)).peek(keychain -> {\n+            TKit.trace(String.format(\"Missing [%s] keychain file\", keychain.path()));\n+        }).findAny().isPresent();\n+\n+        final var missingCertificates = specs.stream().filter(spec -> {\n+            return spec.keychain().exists();\n+        }).map(spec -> {\n+            final var availableCertRequests = spec.keychain().findCertificates().stream().map(cert -> {\n+                try {\n+                    final var certRequest = new CertificateRequest(cert);\n+                    TKit.trace(String.format(\"Certificate with hash=%s: %s\", CertificateHash.of(cert), certRequest));\n+                    return certRequest;\n+                } catch (RuntimeException ex) {\n+                    final Throwable t;\n+                    if (ex instanceof ExceptionBox) {\n+                        t = ex.getCause();\n+                    } else {\n+                        t = ex;\n+                    }\n+                    TKit.trace(String.format(\"Failed to create certificate request from the certificate with hash=%s: %s\",\n+                            CertificateHash.of(cert), t));\n+                    return null;\n+                }\n+            }).filter(Objects::nonNull).collect(toSet());\n+            final var configuredCertRequests = spec.certificateRequests().stream().collect(toSet());\n+            final var comm = Comm.compare(availableCertRequests, configuredCertRequests);\n+            return Map.entry(spec.keychain(), comm.unique2());\n+        }).filter(e -> {\n+            return !e.getValue().isEmpty();\n+        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        missingCertificates.entrySet().forEach(e -> {\n+            for (final var certRequest : e.getValue()) {\n+                TKit.trace(String.format(\"Missing certificate for %s certificate request in [%s] keychain\",\n+                        certRequest, e.getKey().name()));\n+            }\n+        });\n+\n+        return !missingKeychain && missingCertificates.isEmpty();\n+    }\n+\n+    private static void validate(List<KeychainWithCertsSpec> specs) {\n+        specs.stream().map(KeychainWithCertsSpec::keychain).map(Keychain::name).collect(toMap(x -> x, x -> x, (x, y) -> {\n+            throw new IllegalArgumentException(String.format(\"Multiple keychains with the same name [%s]\", x));\n+        }));\n+\n+        specs.stream().forEach(spec -> {\n+            spec.certificateRequests().stream().collect(toMap(x -> x, x -> x, (x, y) -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Multiple certificate requests with the same specification %s in one keychain [%s]\", x, spec.keychain().name()));\n+            }));\n+        });\n+    }\n+\n+    private static void traceSigningEnvironment(Collection<KeychainWithCertsSpec> specs) {\n+        TKit.trace(\"Signing environment:\");\n+        int specIdx = 1;\n+        for (final var spec : specs) {\n+            TKit.trace(String.format(\"[%d\/%d] %s\", specIdx++, specs.size(), spec.keychain()));\n+            int certRequestIdx = 1;\n+            for (final var certRequest : spec.certificateRequests()) {\n+                TKit.trace(String.format(\"  [%d\/%d] %s\", certRequestIdx++, spec.certificateRequests().size(), certRequest));\n+            }\n+        }\n+    }\n+\n@@ -639,1 +758,2 @@\n-            final var keyFile = tmpDir.resolve(\"key.p12\");\n+            final var keyFilePKCS12 = tmpDir.resolve(\"key.p12\");\n+            final var keyFilePEM = tmpDir.resolve(\"key.pem\");\n@@ -646,1 +766,11 @@\n-                    \"-o\", keyFile.normalize().toString()).execute();\n+                    \"-o\", keyFilePKCS12.normalize().toString()).execute();\n+\n+            \/\/ This step is needed only for LibreSSL variant of openssl command which can't take\n+            \/\/ private key in PKCS#12 format.\n+            Executor.of(OPENSSL.toString(), \"pkcs12\",\n+                    \"-nodes\",\n+                    \"-in\", keyFilePKCS12.normalize().toString(),\n+                    \"-password\", \"pass:\",\n+                    \"-out\", keyFilePEM.normalize().toString()).dumpOutput().execute();\n+\n+            final var keyFile = keyFilePEM;\n@@ -651,4 +781,2 @@\n-                    if (cert != null) {\n-                        spec.certificates().add(cert);\n-                    } else {\n-                        Files.write(cfgFile, List.of(\n+                    if (cert == null) {\n+                        TKit.createTextFile(cfgFile, Stream.of(\n@@ -662,2 +790,4 @@\n-                        final var openssl = Executor.of(\"openssl\", \"req\", \"-x509\", \"-utf8\",\n-                                \"-days\", Integer.toString(certificateRequest.days()), \"-sha256\", \"-nodes\",\n+                        final var openssl = Executor.of(OPENSSL.toString(), \"req\",\n+                                \"-x509\", \"-utf8\", \"-sha256\", \"-nodes\",\n+                                \"-new\", \/\/ Prevents LibreSSL variant of openssl command from hanging\n+                                \"-days\", Integer.toString(certificateRequest.days()),\n@@ -668,1 +798,1 @@\n-                        certificateRequest.type().extensions.forEach(ext -> {\n+                        certificateRequest.type().extensions().forEach(ext -> {\n@@ -679,2 +809,0 @@\n-                            spec.certificates().add(cert);\n-\n@@ -682,1 +810,1 @@\n-                            final var certPemFile = outputPemDir.resolve(CertificateHash.of(cert).toString() + \".pem\");\n+                            final var certPemFile = outputPemDir.resolve(certHash.toString() + \".pem\");\n@@ -719,0 +847,6 @@\n+    \/\/ Code Signing\n+    private static final List<String> CODE_SIGN_EXTENDED_KEY_USAGE = List.of(\"1.3.6.1.5.5.7.3.3\");\n+    \/\/ Apple Custom Extended Key Usage (EKU) packageSign\n+    \/\/ https:\/\/oid-base.com\/get\/1.2.840.113635.100.4.13\n+    private static final List<String> INSTALLER_EXTENDED_KEY_USAGE = List.of(\"1.2.840.113635.100.4.13\");\n+\n@@ -720,0 +854,8 @@\n+\n+    \/\/ macOS comes with \/usr\/bin\/openssl which is LibreSSL\n+    \/\/ If you install openssl with Homebrew, it will be installed in \/usr\/local\/bin\/openssl,\n+    \/\/ and the PATH env variable will be altered to pick up openssl from Homebrew.\n+    \/\/ However, jtreg will alter the value of the PATH env variable and\n+    \/\/ \/usr\/bin\/openssl will preempt \/usr\/local\/bin\/openssl.\n+    \/\/ To workaround this jtreg behavior support specifying path to openssl command.\n+    private static final Path OPENSSL = Path.of(Optional.ofNullable(TKit.getConfigProperty(\"openssl\")).orElse(\"openssl\"));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":186,"deletions":44,"binary":false,"changes":230,"status":"modified"}]}