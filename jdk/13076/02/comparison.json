{"files":[{"patch":"@@ -134,25 +134,15 @@\n-void CardTableRS::clear_into_younger(Generation* old_gen) {\n-  assert(GenCollectedHeap::heap()->is_old_gen(old_gen),\n-         \"Should only be called for the old generation\");\n-  \/\/ The card tables for the youngest gen need never be cleared.\n-  \/\/ There's a bit of subtlety in the clear() and invalidate()\n-  \/\/ methods that we exploit here and in invalidate_or_clear()\n-  \/\/ below to avoid missing cards at the fringes. If clear() or\n-  \/\/ invalidate() are changed in the future, this code should\n-  \/\/ be revisited. 20040107.ysr\n-  clear_MemRegion(old_gen->prev_used_region());\n-}\n-\n-void CardTableRS::invalidate_or_clear(Generation* old_gen) {\n-  assert(GenCollectedHeap::heap()->is_old_gen(old_gen),\n-         \"Should only be called for the old generation\");\n-  \/\/ Invalidate the cards for the currently occupied part of\n-  \/\/ the old generation and clear the cards for the\n-  \/\/ unoccupied part of the generation (if any, making use\n-  \/\/ of that generation's prev_used_region to determine that\n-  \/\/ region). No need to do anything for the youngest\n-  \/\/ generation. Also see note#20040107.ysr above.\n-  MemRegion used_mr = old_gen->used_region();\n-  MemRegion to_be_cleared_mr = old_gen->prev_used_region().minus(used_mr);\n-  if (!to_be_cleared_mr.is_empty()) {\n-    clear_MemRegion(to_be_cleared_mr);\n+void CardTableRS::maintain_old_to_young_invariant(Generation* old_gen, bool is_young_gen_empty) {\n+  assert(GenCollectedHeap::heap()->is_old_gen(old_gen), \"precondition\");\n+\n+  if (is_young_gen_empty) {\n+    clear_MemRegion(old_gen->prev_used_region());\n+  } else {\n+    MemRegion used_mr = old_gen->used_region();\n+    MemRegion prev_used_mr = old_gen->prev_used_region();\n+    if (used_mr.end() < prev_used_mr.end()) {\n+      \/\/ Shrunk; need to clear the previously-used but now-unused parts.\n+      clear_MemRegion(MemRegion(used_mr.end(), prev_used_mr.end()));\n+    }\n+    \/\/ No idea which card contains old-to-young pointer, so dirtying cards for\n+    \/\/ the entire used part of old-gen conservatively.\n+    dirty_MemRegion(used_mr);\n@@ -160,1 +150,0 @@\n-  dirty_MemRegion(used_mr);\n@@ -163,1 +152,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -66,3 +66,5 @@\n-  void clear_into_younger(Generation* old_gen);\n-\n-  void invalidate_or_clear(Generation* old_gen);\n+  \/\/ Update old gen cards to maintain old-to-young-pointer invariant: Clear\n+  \/\/ the old generation card table completely if the young generation had been\n+  \/\/ completely evacuated, otherwise dirties the whole old generation to\n+  \/\/ conservatively not loose any old-to-young pointer.\n+  void maintain_old_to_young_invariant(Generation* old_gen, bool is_young_gen_empty);\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -112,16 +112,2 @@\n-  \/\/ If compaction completely evacuated the young generation then we\n-  \/\/ can clear the card table.  Otherwise, we must invalidate\n-  \/\/ it (consider all cards dirty).  In the future, we might consider doing\n-  \/\/ compaction within generations only, and doing card-table sliding.\n-  CardTableRS* rs = gch->rem_set();\n-  Generation* old_gen = gch->old_gen();\n-\n-  \/\/ Clear\/invalidate below make use of the \"prev_used_regions\" saved earlier.\n-  if (gch->young_gen()->used() == 0) {\n-    \/\/ We've evacuated the young generation.\n-    rs->clear_into_younger(old_gen);\n-  } else {\n-    \/\/ Invalidate the cards corresponding to the currently used\n-    \/\/ region and clear those corresponding to the evacuated region.\n-    rs->invalidate_or_clear(old_gen);\n-  }\n+  bool is_young_gen_empty = (gch->young_gen()->used() == 0);\n+  gch->rem_set()->maintain_old_to_young_invariant(gch->old_gen(), is_young_gen_empty);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"}]}