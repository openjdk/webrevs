{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+\/\/ fp value used for frozen stub\/native frame\n+static intptr_t* const UNUSED_FP = reinterpret_cast<intptr_t*>(UCONST64(0xC0C0C0C0DEADBAAD));\n@@ -104,3 +106,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : UNUSED_FP;\n@@ -195,0 +200,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t** fp_addr = (intptr_t**)(sp - frame::sender_sp_offset);\n+  *fp_addr = UNUSED_FP;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -337,0 +337,3 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,0 +197,3 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+\/\/ fp value used for frozen stub\/native frame\n+static intptr_t* const UNUSED_FP = reinterpret_cast<intptr_t*>(UCONST64(0xC0C0C0C0DEADBAAD));\n+\n@@ -101,3 +104,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : UNUSED_FP;\n@@ -186,0 +192,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t** fp_addr = (intptr_t**)(sp - frame::sender_sp_offset);\n+  *fp_addr = UNUSED_FP;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+  inline void patch_pd_unused(intptr_t* sp);\n@@ -786,3 +787,18 @@\n-  intptr_t* from = _cont_stack_top - frame::metadata_words_at_bottom;\n-  intptr_t* to   = chunk_top - frame::metadata_words_at_bottom;\n-  copy_to_chunk(from, to, cont_size() + frame::metadata_words_at_bottom);\n+\n+  int adjust = frame::metadata_words_at_bottom;\n+#if INCLUDE_ASAN && defined(AARCH64)\n+  \/\/ Reading at offset frame::metadata_words_at_bottom from _cont_stack_top\n+  \/\/ will accesss memory at the callee frame, which on preemption cases will\n+  \/\/ be the VM native method being called. The Arm 64-bit ABI doesn't specify\n+  \/\/ a location where the frame record (returnpc+fp) has to be stored within\n+  \/\/ a stack frame, and GCC currently chooses to save it at the top of the\n+  \/\/ frame (lowest address). ASan treats this memory access in the callee as\n+  \/\/ an overflow access to one of the locals stored in that frame. For these\n+  \/\/ preemption cases we don't need to read these words anyways so we avoid it.\n+  if (_preempt) {\n+    adjust = 0;\n+  }\n+#endif\n+  intptr_t* from = _cont_stack_top - adjust;\n+  intptr_t* to   = chunk_top - adjust;\n+  copy_to_chunk(from, to, cont_size() + adjust);\n@@ -819,0 +835,5 @@\n+    \/\/ For stub\/native frames the fp is not used while frozen, and will be constructed\n+    \/\/ again when thawing the frame (see ThawBase::handle_preempted_continuation). We\n+    \/\/ patch it with a special bad address to help with debugging, particularly when\n+    \/\/ inspecting frames and identifying invalid accesses.\n+    patch_pd_unused(chunk_top);\n@@ -2487,1 +2508,1 @@\n-    \/\/ we copied the original fp at the time of freeze which now will have to be fixed.\n+    \/\/ we copied the fp patched during freeze, which will now have to be fixed.\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+  static const bool compiled = false;\n@@ -130,0 +131,2 @@\n+  static const bool compiled = true;\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}