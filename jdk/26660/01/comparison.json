{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,3 +104,5 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed\n+    \/\/ again when thawing the frame (see ThawBase::new_stack_frame).\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,3 +101,5 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed\n+    \/\/ again when thawing the frame (see ThawBase::new_stack_frame).\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -786,3 +786,18 @@\n-  intptr_t* from = _cont_stack_top - frame::metadata_words_at_bottom;\n-  intptr_t* to   = chunk_top - frame::metadata_words_at_bottom;\n-  copy_to_chunk(from, to, cont_size() + frame::metadata_words_at_bottom);\n+\n+  int adjust = frame::metadata_words_at_bottom;\n+#if INCLUDE_ASAN && defined(AARCH64)\n+  \/\/ Reading at offset frame::metadata_words_at_bottom from _cont_stack_top\n+  \/\/ will accesss memory at the callee frame, which on preemption cases will\n+  \/\/ be the VM native method being called. The Arm 64-bit ABI doesn't specify\n+  \/\/ a location where the frame record (returnpc+fp) has to be stored within\n+  \/\/ a stack frame, and GCC currently chooses to save it at the top of the\n+  \/\/ frame (lowest address). ASan treats this memory access in the callee as\n+  \/\/ an overflow access to one of the locals stored in that frame. For these\n+  \/\/ preemption cases we don't need to read these words anyways so we avoid it.\n+  if (_preempt) {\n+    adjust = 0;\n+  }\n+#endif\n+  intptr_t* from = _cont_stack_top - adjust;\n+  intptr_t* to   = chunk_top - adjust;\n+  copy_to_chunk(from, to, cont_size() + adjust);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+  static const bool compiled = false;\n@@ -130,0 +131,2 @@\n+  static const bool compiled = true;\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}