{"files":[{"patch":"@@ -2224,1 +2224,1 @@\n-  __ ic_check(CodeEntryAlignment);\n+  __ ic_check(InteriorEntryAlignment);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1017,0 +1017,4 @@\n+  \/\/ The UEP of a code blob ensures that the VEP is padded. However, the padding of the UEP is placed\n+  \/\/ before the inline cache check, so we don't have to execute any nop instructions when dispatching\n+  \/\/ through the UEP, yet we can ensure that the VEP is aligned appropriately. That's why we align\n+  \/\/ before the inline cache check here, and not after\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -756,0 +756,3 @@\n+    \/\/ Method might have been compiled since the call site was patched to\n+    \/\/ interpreted; if that is the case treat it as a miss so we can get\n+    \/\/ the call site corrected.\n@@ -1551,0 +1554,2 @@\n+    \/\/ Verified entry point must be aligned\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-  __ ic_check(CodeEntryAlignment);\n+  __ ic_check(InteriorEntryAlignment);\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1876,0 +1876,4 @@\n+  \/\/ The UEP of a code blob ensures that the VEP is padded. However, the padding of the UEP is placed\n+  \/\/ before the inline cache check, so we don't have to execute any nop instructions when dispatching\n+  \/\/ through the UEP, yet we can ensure that the VEP is aligned appropriately. That's why we align\n+  \/\/ before the inline cache check here, and not after\n@@ -1889,1 +1893,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -820,1 +820,2 @@\n-  __ ic_check(1 \/* end_alignment *\/);\n+  \/\/ Inline cache check\n+  __ ic_check(CodeEntryAlignment \/* end_alignment *\/);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1225,0 +1225,4 @@\n+  \/\/ The UEP of a code blob ensures that the VEP is padded. However, the padding of the UEP is placed\n+  \/\/ before the inline cache check, so we don't have to execute any nop instructions when dispatching\n+  \/\/ through the UEP, yet we can ensure that the VEP is aligned appropriately. That's why we align\n+  \/\/ before the inline cache check here, and not after\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3562,0 +3562,4 @@\n+  \/\/ The UEP of a code blob ensures that the VEP is padded. However, the padding of the UEP is placed\n+  \/\/ before the inline cache check, so we don't have to execute any nop instructions when dispatching\n+  \/\/ through the UEP, yet we can ensure that the VEP is aligned appropriately. That's why we align\n+  \/\/ before the inline cache check here, and not after\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2170,0 +2170,5 @@\n+\n+  \/\/ The UEP of a code blob ensures that the VEP is padded. However, the padding of the UEP is placed\n+  \/\/ before the inline cache check, so we don't have to execute any nop instructions when dispatching\n+  \/\/ through the UEP, yet we can ensure that the VEP is aligned appropriately. That's why we align\n+  \/\/ before the inline cache check here, and not after\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1361,0 +1361,4 @@\n+  \/\/ The UEP of a code blob ensures that the VEP is padded. However, the padding of the UEP is placed\n+  \/\/ before the inline cache check, so we don't have to execute any nop instructions when dispatching\n+  \/\/ through the UEP, yet we can ensure that the VEP is aligned appropriately. That's why we align\n+  \/\/ before the inline cache check here, and not after\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1448,0 +1448,1 @@\n+  \/\/ verified entry must be aligned for code patching.\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1487,1 +1487,1 @@\n-  masm.ic_check(CodeEntryAlignment);\n+  masm.ic_check(InteriorEntryAlignment);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -436,1 +436,2 @@\n-static void clean_if_nmethod_is_unloaded(CompiledIC *ic, CompiledMethod* from,\n+template <typename CallsiteT>\n+static void clean_if_nmethod_is_unloaded(CallsiteT* callsite, CompiledMethod* from,\n@@ -438,1 +439,1 @@\n-  CodeBlob* cb = CodeCache::find_blob(ic->destination());\n+  CodeBlob* cb = CodeCache::find_blob(callsite->destination());\n@@ -444,13 +445,1 @@\n-    ic->set_to_clean();\n-  }\n-}\n-\n-static void clean_if_nmethod_is_unloaded(CompiledDirectCall *cdc, CompiledMethod* from,\n-                                         bool clean_all) {\n-  CodeBlob* cb = CodeCache::find_blob(cdc->destination());\n-  if (!cb->is_compiled()) {\n-    return;\n-  }\n-  CompiledMethod* cm = cb->as_compiled_method();\n-  if (clean_all || !cm->is_in_use() || cm->is_unloading() || cm->method()->code() != cm) {\n-    cdc->set_to_clean();\n+    callsite->set_to_clean();\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -182,1 +182,0 @@\n-\/\/      class CHeapObj\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3416,0 +3416,3 @@\n+        \/\/ The UEP of an nmethod ensures that the VEP is padded. However, the padding of the UEP is placed\n+        \/\/ before the inline cache check, so we don't have to execute any nop instructions when dispatching\n+        \/\/ through the UEP, yet we can ensure that the VEP is aligned appropriately.\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1363,0 +1363,1 @@\n+  CompiledICLocker ml(caller_nm);\n@@ -1364,1 +1365,0 @@\n-    CompiledICLocker ml(caller_nm);\n@@ -1369,1 +1369,0 @@\n-    CompiledICLocker ml(caller_nm);\n@@ -1597,3 +1596,0 @@\n-  \/\/ Transitioning IC caches may require transition stubs. If we run out\n-  \/\/ of transition stubs, we have to drop locks and perform a safepoint\n-  \/\/ that refills them.\n@@ -1664,2 +1660,0 @@\n-    \/\/ Check relocations for the matching call to 1) avoid false positives,\n-    \/\/ and 2) determine the type.\n@@ -1807,1 +1801,0 @@\n-  assert(iter.has_current(), \"must have a reloc at java call site\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -214,4 +214,0 @@\n-  volatile_nonstatic_field(CompiledICData,     _speculated_method,                            Method*)                               \\\n-  volatile_nonstatic_field(CompiledICData,     _speculated_klass,                             uintptr_t)                             \\\n-  nonstatic_field(CompiledICData,              _itable_defc_klass,                            Klass*)                                \\\n-  nonstatic_field(CompiledICData,              _itable_refc_klass,                            Klass*)                                \\\n@@ -1167,1 +1163,0 @@\n-  declare_toplevel_type(CompiledICData)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}