{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.ClassBuilder;\n@@ -51,0 +52,3 @@\n+\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -77,4 +81,0 @@\n-    private static final MethodHandle NULL_CHECK;\n-    private static final MethodHandle IS_ZERO;\n-    private static final MethodHandle CHECK_INDEX;\n-    private static final MethodHandle MAPPED_ENUM_LOOKUP;\n@@ -82,2 +82,2 @@\n-    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n+    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final ClassDesc CD_BiPredicate = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n@@ -85,14 +85,18 @@\n-    static {\n-        try {\n-            NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\",\n-                                           MethodType.methodType(boolean.class, Object.class));\n-            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n-                                           MethodType.methodType(boolean.class, int.class));\n-            CHECK_INDEX = LOOKUP.findStatic(Objects.class, \"checkIndex\",\n-                                           MethodType.methodType(int.class, int.class, int.class));\n-            MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumLookup\",\n-                                                   MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,\n-                                                                         Class.class, EnumDesc[].class, EnumMap.class));\n-        }\n-        catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n+    private static class StaticHolders {\n+        private static final MethodHandle NULL_CHECK;\n+        private static final MethodHandle IS_ZERO;\n+        private static final MethodHandle MAPPED_ENUM_LOOKUP;\n+\n+        static {\n+            try {\n+                NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\",\n+                                               MethodType.methodType(boolean.class, Object.class));\n+                IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n+                                               MethodType.methodType(boolean.class, int.class));\n+                MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumLookup\",\n+                                                       MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,\n+                                                                             Class.class, EnumDesc[].class, EnumMap.class));\n+            }\n+            catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n@@ -166,1 +170,0 @@\n-        requireNonNull(labels);\n@@ -168,1 +171,3 @@\n-        Stream.of(labels).forEach(l -> verifyLabel(l, selectorType));\n+        for (Object l : labels) { \/\/ implicit null-check\n+            verifyLabel(l, selectorType);\n+        }\n@@ -172,2 +177,0 @@\n-        target = withIndexCheck(target, labels.length);\n-\n@@ -285,1 +288,1 @@\n-                    MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                    MethodHandles.guardWithTest(MethodHandles.dropArguments(StaticHolders.NULL_CHECK, 0, int.class),\n@@ -287,1 +290,1 @@\n-                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(IS_ZERO, 1, Object.class),\n+                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(StaticHolders.IS_ZERO, 1, Object.class),\n@@ -289,1 +292,1 @@\n-                                                                            MethodHandles.insertArguments(MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));\n+                                                                            MethodHandles.insertArguments(StaticHolders.MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));\n@@ -296,1 +299,0 @@\n-        target = withIndexCheck(target, labels.length);\n@@ -342,6 +344,0 @@\n-    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n-        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n-\n-        return MethodHandles.filterArguments(target, 1, checkIndex);\n-    }\n-\n@@ -410,0 +406,5 @@\n+            \/\/ Objects.checkIndex(RESTART_IDX, labelConstants + 1)\n+            cb.iload(RESTART_IDX);\n+            cb.loadConstant(labelConstants.length + 1);\n+            cb.invokestatic(CD_Objects, \"checkIndex\", MethodTypeDescImpl.ofTrusted(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int));\n+            cb.pop();\n@@ -624,1 +625,1 @@\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())),\n+        byte[] classBytes = ClassFile.of().build(ReferenceClassDescImpl.ofValidatedBinaryName(typeSwitchClassName(caller.lookupClass())),\n@@ -628,1 +629,5 @@\n-                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+                                            ClassDesc.ofDescriptor(selectorType.descriptorString()),\n+                                            ConstantDescs.CD_int,\n+                                            CD_BiPredicate,\n+                                            ConstantDescs.CD_List),\n@@ -640,1 +645,1 @@\n-                                                                              Object.class,\n+                                                                              selectorType,\n@@ -644,1 +649,1 @@\n-            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n@@ -646,4 +651,0 @@\n-            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n-                                                             MethodType.methodType(int.class,\n-                                                                                   selectorType,\n-                                                                                   int.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":43,"deletions":42,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    public static MethodTypeDescImpl ofTrusted(ClassDesc returnType, ClassDesc[] trustedArgTypes) {\n+    public static MethodTypeDescImpl ofTrusted(ClassDesc returnType, ClassDesc... trustedArgTypes) {\n@@ -92,1 +92,1 @@\n-    public static MethodTypeDescImpl ofValidated(ClassDesc returnType, ClassDesc[] trustedArgTypes) {\n+    public static MethodTypeDescImpl ofValidated(ClassDesc returnType, ClassDesc... trustedArgTypes) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,11 @@\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n+     * for a class or interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ClassDesc ofValidatedBinaryName(String typeSwitchClassName) {\n+        return ofValidated(\"L\" + binaryToInternal(typeSwitchClassName) + \";\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.runtime;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class SwitchSanity {\n+\n+    public record A(int a) { }\n+    public record B(int b) { }\n+    public record C(int c) { }\n+\n+    public Object[] inputs = new Object[10];\n+    @Setup\n+    public void setup() {\n+        for (int i = 0; i < 10; i++) {\n+            if (i % 2 == 0) {\n+                inputs[i] = new A(i + 17);\n+            } else if (i % 3 == 0) {\n+                inputs[i] = new B(i + 4711);\n+            } else {\n+                inputs[i] = new C(i + 174711);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public int switchSum() {\n+        int sum = 0;\n+        for (Object o : inputs) {\n+            sum += switch (o) {\n+                case A a -> a.a;\n+                case B b -> b.b;\n+                case C c -> c.c;\n+                default -> 17;\n+            };\n+        }\n+        return sum;\n+    }\n+\n+    public static void main(String[] args) {\n+        SwitchSanity s = new SwitchSanity();\n+        s.setup();\n+        System.out.println(s.switchSum());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/SwitchSanity.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}