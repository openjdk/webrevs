{"files":[{"patch":"@@ -116,2 +116,16 @@\n-                if (sig.charAt(sigp) != ':')\n-                    classBound = referenceTypeSig();\n+                if (sig.charAt(sigp) != ':') {\n+                    int p = nextIdentifierEnd(sig, sigp);\n+                    \/\/ For non-identifier chars:\n+                    \/\/ . \/ < indicates class type (inner, package, type arg)\n+                    \/\/ [ indicates array type\n+                    \/\/ ; indicates class\/type var type\n+                    \/\/ > and : are illegal, such as in <P:R:>\n+                    if (p < sig.length()) {\n+                        char limit = sig.charAt(p);\n+                        if (limit != '>' && limit != ':') {\n+                            classBound = referenceTypeSig();\n+                        }\n+                    }\n+                    \/\/ If classBound is absent here, we start tokenizing\n+                    \/\/ next type parameter, which can trigger failures\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8321540 8319463 8357955\n+ * @bug 8321540 8319463 8357955 8368050 8368331\n@@ -123,0 +123,14 @@\n+\n+        assertEqualsDeep(\n+                MethodSignature.of(\n+                        List.of(TypeParam.of(\"A\", ClassTypeSig.of(\"one\/Two\")), \/\/ \/\n+                                TypeParam.of(\"B\", ClassTypeSig.of(ClassTypeSig.of(\"Outer\"), \"Inner\")), \/\/ .\n+                                TypeParam.of(\"C\", ArrayTypeSig.of(BaseTypeSig.of('I'))), \/\/ [\n+                                TypeParam.of(\"D\", ClassTypeSig.of(\"Generic\", TypeArg.unbounded())), \/\/ <\n+                                TypeParam.of(\"E\", TypeVarSig.of(\"A\")), \/\/ ;\n+                                TypeParam.of(\"F\", (ClassTypeSig) null), \/\/ :\n+                                TypeParam.of(\"G\", (ClassTypeSig) null)), \/\/ >\n+                        List.of(),\n+                        BaseTypeSig.of('V')),\n+                MethodSignature.parseFrom(\"<A:Lone\/Two;B:LOuter.Inner;C:[ID:LGeneric<*>;E:TA;F:G:>()V\")\n+        );\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"}]}