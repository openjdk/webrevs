{"files":[{"patch":"@@ -116,0 +116,1 @@\n+     * @throws IllegalArgumentException if any of {@code arguments} is void\n@@ -122,1 +123,1 @@\n-                                                      List.of(arguments));\n+                                                      SignaturesImpl.validateArgumentList(arguments));\n@@ -134,0 +135,1 @@\n+     * @throws IllegalArgumentException if any of {@code arguments} is void\n@@ -143,1 +145,1 @@\n-                List.of(arguments));\n+                SignaturesImpl.validateArgumentList(arguments));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,5 @@\n+ * <p>\n+ * Names in signatures are <dfn id=\"identifier\">identifiers<\/dfn>, which must\n+ * not be empty and must not contain any of the ASCII characters {@code\n+ * . ; [ \/ < > :}.  Top-level class and interface names are denoted by\n+ * slash-separated identifiers.\n@@ -76,0 +81,2 @@\n+     * @throws IllegalArgumentException if the field descriptor cannot be\n+     *         {@linkplain ##identifier denoted}\n@@ -142,0 +149,25 @@\n+     * <p>\n+     * These are examples of class type signatures:\n+     * <ul>\n+     * <li>{@code Lcom\/example\/Outer;} for {@code Outer}\n+     * <br>Has class name {@code com\/example\/Outer} and no outer type or type\n+     *     argument.\n+     * <li>{@code Lcom\/example\/Outer$Nested<TA;>;} for {@code Outer.Nested<A>}\n+     * <br>Has class name {@code com\/example\/Outer$Nested} representing a nested\n+     *     class, no outer type, and a single type argument of type variable\n+     *     {@code A}.\n+     * <li>{@code Lcom\/example\/GenericOuter<TA;>.Inner;} for {@code\n+     *     GenericOuter<A>.Inner}\n+     * <br>Has class name {@code Inner}, a simple class name, outer type\n+     *     {@code Lcom\/example\/GenericOuter<TA;>;} for {@code GenericOuter<A>},\n+     *     and no type argument.\n+     * <\/ul>\n+     * <p>\n+     * If the {@linkplain #outerType() outer type} exists, the {@linkplain\n+     * #className() class name} is the simple name of the nested type.\n+     * Otherwise, it is a {@linkplain ClassEntry##internalname binary name in\n+     * internal form} (separated by {@code \/}).\n+     * <p>\n+     * If a nested type does not have any enclosing parameterization, it may\n+     * be represented without an outer type and as an internal binary name,\n+     * in which nesting is represented by {@code $} instead of {@code .}.\n@@ -155,1 +187,2 @@\n-         * absent if it is not a parameterized type.\n+         * absent if this is a member class without any parameterized enclosing\n+         * type.\n@@ -164,1 +197,2 @@\n-         * outer type}\n+         * outer type}  Note this may indicate a nested class name with {@code $}\n+         * separators if there is no parameterized enclosing type.\n@@ -191,1 +225,2 @@\n-         *         represent a class or interface\n+         *         represent a class or interface, or if it cannot be\n+         *         {@linkplain Signature##identifier denoted}\n@@ -194,1 +229,1 @@\n-            return of(null, className, typeArgs);\n+            return of(null, Util.toInternalName(className), typeArgs);\n@@ -204,1 +239,7 @@\n-         *         represent a class or interface\n+         *         represent a class or interface, or if it cannot be\n+         *         {@linkplain Signature##identifier denoted}\n+         * @deprecated\n+         * The resulting signature does not denote the class represented by\n+         * {@code className} when {@code outerType} is not null.  Use {@link\n+         * #of(ClassTypeSig, String, TypeArg...) of(ClassTypeSig, String, TypeArg...)}\n+         * instead.\n@@ -206,0 +247,1 @@\n+        @Deprecated(since = \"26\", forRemoval = true)\n@@ -214,1 +256,2 @@\n-         * @param className the name of the class or interface\n+         * @param className the name of the class or interface, may use\n+         *                  {@code \/} to separate\n@@ -216,0 +259,2 @@\n+         * @throws IllegalArgumentException if {@code className} cannot be\n+         *         {@linkplain Signature##identifier denoted}\n@@ -225,1 +270,2 @@\n-         * @param className the name of this class or interface\n+         * @param className the name of this class or interface, may use\n+         *                  {@code \/} to separate if outer type is absent\n@@ -227,0 +273,2 @@\n+         * @throws IllegalArgumentException if {@code className} cannot be\n+         *         {@linkplain Signature##identifier denoted}\n@@ -229,2 +277,6 @@\n-            requireNonNull(className);\n-            return new SignaturesImpl.ClassTypeSigImpl(Optional.ofNullable(outerType), className.replace(\".\", \"\/\"), List.of(typeArgs));\n+            if (outerType != null) {\n+                SignaturesImpl.validateIdentifier(className);\n+            } else {\n+                SignaturesImpl.validatePackageSpecifierPlusIdentifier(className);\n+            }\n+            return new SignaturesImpl.ClassTypeSigImpl(Optional.ofNullable(outerType), className, List.of(typeArgs));\n@@ -386,0 +438,2 @@\n+         * @throws IllegalArgumentException if the name cannot be {@linkplain\n+         *         Signature##identifier denoted}\n@@ -388,1 +442,1 @@\n-            return new SignaturesImpl.TypeVarSigImpl(requireNonNull(identifier));\n+            return new SignaturesImpl.TypeVarSigImpl(SignaturesImpl.validateIdentifier(identifier));\n@@ -411,0 +465,1 @@\n+         * @throws IllegalArgumentException if the component type is void\n@@ -413,1 +468,1 @@\n-            return of(1, requireNonNull(componentSignature));\n+            return of(1, SignaturesImpl.validateNonVoid(componentSignature));\n@@ -421,1 +476,2 @@\n-         *         resulting array type exceeds 255 dimensions\n+         *         resulting array type exceeds 255 dimensions or the component\n+         *         type is void\n@@ -424,1 +480,1 @@\n-            requireNonNull(componentSignature);\n+            SignaturesImpl.validateNonVoid(componentSignature);\n@@ -472,0 +528,2 @@\n+         * @throws IllegalArgumentException if the name cannot be {@linkplain\n+         *         Signature##identifier denoted}\n@@ -475,1 +533,1 @@\n-                    requireNonNull(identifier),\n+                    SignaturesImpl.validateIdentifier(identifier),\n@@ -486,0 +544,2 @@\n+         * @throws IllegalArgumentException if the name cannot be {@linkplain\n+         *         Signature##identifier denoted}\n@@ -489,1 +549,1 @@\n-                    requireNonNull(identifier),\n+                    SignaturesImpl.validateIdentifier(identifier),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":75,"deletions":15,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-                        map(cts.classDesc()),\n+                        Util.toInternalName(map(cts.classDesc())),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-                paramTypes.add(typeSig());\n+                paramTypes.add(validateNonVoid(typeSig()));\n@@ -116,2 +116,16 @@\n-                if (sig.charAt(sigp) != ':')\n-                    classBound = referenceTypeSig();\n+                if (sig.charAt(sigp) != ':') {\n+                    int p = nextIdentifierEnd(sig, sigp);\n+                    \/\/ For non-identifier chars:\n+                    \/\/ . \/ < indicates class type (inner, package, type arg)\n+                    \/\/ [ indicates array type\n+                    \/\/ ; indicates class\/type var type\n+                    \/\/ > and : are illegal, such as in <P:R:>\n+                    if (p < sig.length()) {\n+                        char limit = sig.charAt(p);\n+                        if (limit != '>' && limit != ':') {\n+                            classBound = referenceTypeSig();\n+                        }\n+                    }\n+                    \/\/ If classBound is absent here, we start tokenizing\n+                    \/\/ next type parameter, which can trigger failures\n+                }\n@@ -229,1 +243,0 @@\n-        l:\n@@ -231,5 +244,2 @@\n-            switch (sig.charAt(sigp)) {\n-                case '.', ';', '[', '\/', '<', '>', ':' -> {\n-                    break l;\n-                }\n-            }\n+            if (isNonIdentifierChar(sig.charAt(sigp)))\n+                break;\n@@ -244,0 +254,71 @@\n+    \/\/ Non-identifier chars in ascii 0 to 63, note [ is larger\n+    private static final long SMALL_NON_IDENTIFIER_CHARS_SET = (1L << '.')\n+            | (1L << ';')\n+            | (1L << '\/')\n+            | (1L << '<')\n+            | (1L << '>')\n+            | (1L << ':');\n+\n+    private static boolean isNonIdentifierChar(char c) {\n+        return c < Long.SIZE ? (SMALL_NON_IDENTIFIER_CHARS_SET & (1L << c)) != 0 : c == '[';\n+    }\n+\n+    \/\/\/ {@return exclusive end of the next identifier}\n+    public static int nextIdentifierEnd(String st, int start) {\n+        int end = st.length();\n+        for (int i = start; i < end; i++) {\n+            if (isNonIdentifierChar(st.charAt(i))) {\n+                return i;\n+            }\n+        }\n+        return end;\n+    }\n+\n+    \/\/\/ Validates this string as a simple identifier.\n+    public static String validateIdentifier(String st) {\n+        var len = st.length(); \/\/ implicit null check\n+        if (len == 0 || nextIdentifierEnd(st, 0) != len) {\n+            throw new IllegalArgumentException(\"Not a valid identifier: \" + st);\n+        }\n+        return st;\n+    }\n+\n+    \/\/\/ Validates this string as slash-separated one or more identifiers.\n+    public static String validatePackageSpecifierPlusIdentifier(String st) {\n+        int nextIdentifierStart = 0;\n+        int len = st.length();\n+        while (nextIdentifierStart < len) {\n+            int end = nextIdentifierEnd(st, nextIdentifierStart);\n+            if (end == len)\n+                return st;\n+            if (end == nextIdentifierStart || st.charAt(end) != '\/')\n+                throw new IllegalArgumentException(\"Not a class name: \" + st);\n+            nextIdentifierStart = end + 1;\n+        }\n+        \/\/ Couldn't get an identifier initially or after a separator.\n+        throw new IllegalArgumentException(\"Not a class name: \" + st);\n+    }\n+\n+    \/\/\/ Validates the signature to be non-void (a valid field type).\n+    public static Signature validateNonVoid(Signature incoming) {\n+        Objects.requireNonNull(incoming);\n+        if (incoming instanceof Signature.BaseTypeSig baseType && baseType.baseType() == 'V')\n+            throw new IllegalArgumentException(\"void\");\n+        return incoming;\n+    }\n+\n+    \/\/\/ Returns the validated immutable argument list or fails with IAE.\n+    public static List<Signature> validateArgumentList(Signature[] signatures) {\n+        return validateArgumentList(List.of(signatures));\n+    }\n+\n+    \/\/\/ Returns the validated immutable argument list or fails with IAE.\n+    public static List<Signature> validateArgumentList(List<Signature> signatures) {\n+        var res = List.copyOf(signatures); \/\/ deep null checks\n+        for (var sig : signatures) {\n+            if (sig instanceof Signature.BaseTypeSig baseType && baseType.baseType() == 'V')\n+                throw new IllegalArgumentException(\"void\");\n+        }\n+        return res;\n+    }\n+\n@@ -319,1 +400,1 @@\n-        if (typeParameters != null && !typeParameters.isEmpty()) {\n+        if (!typeParameters.isEmpty()) {\n@@ -325,1 +406,1 @@\n-                if (tp.interfaceBounds() != null) for (var is : tp.interfaceBounds())\n+                for (var is : tp.interfaceBounds())\n@@ -340,1 +421,1 @@\n-            if (superinterfaceSignatures != null) for (var in : superinterfaceSignatures)\n+            for (var in : superinterfaceSignatures)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":94,"deletions":13,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8321540 8319463 8357955\n+ * @bug 8321540 8319463 8357955 8368331\n@@ -51,0 +51,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -66,1 +69,1 @@\n-                                ClassDesc.of(\"LinkedHashIterator\")),\n+                                \"LinkedHashIterator\"),\n@@ -120,0 +123,75 @@\n+\n+        assertEqualsDeep(\n+                MethodSignature.of(\n+                        List.of(TypeParam.of(\"A\", ClassTypeSig.of(\"one\/Two\")), \/\/ \/\n+                                TypeParam.of(\"B\", ClassTypeSig.of(ClassTypeSig.of(\"Outer\"), \"Inner\")), \/\/ .\n+                                TypeParam.of(\"C\", ArrayTypeSig.of(BaseTypeSig.of('I'))), \/\/ [\n+                                TypeParam.of(\"D\", ClassTypeSig.of(\"Generic\", TypeArg.unbounded())), \/\/ <\n+                                TypeParam.of(\"E\", TypeVarSig.of(\"A\")), \/\/ ;\n+                                TypeParam.of(\"F\", (ClassTypeSig) null), \/\/ :\n+                                TypeParam.of(\"G\", (ClassTypeSig) null)), \/\/ >\n+                        List.of(),\n+                        BaseTypeSig.of('V')),\n+                MethodSignature.parseFrom(\"<A:Lone\/Two;B:LOuter.Inner;C:[ID:LGeneric<*>;E:TA;F:G:>()V\")\n+        );\n+    }\n+\n+    @Test\n+    void testGenericCreationChecks() {\n+        var weirdNameClass = ClassDesc.of(\"<Unsupported>\");\n+        var voidSig = BaseTypeSig.of('V');\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> Signature.of(weirdNameClass));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> BaseTypeSig.of(CD_Object));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> BaseTypeSig.of(CD_int.arrayType()));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(CD_int));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(CD_Object.arrayType()));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(weirdNameClass));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(255, voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(voidSig, voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(List.of(), List.of(), voidSig, voidSig));\n+    }\n+\n+    static Stream<String> goodIdentifiers() {\n+        return Stream.of(\"T\", \"Hello\", \"Mock\", \"(Weird)\", \" Huh? \");\n+    }\n+\n+    static Stream<String> badIdentifiers() {\n+        return Stream.of(\"\", \";\", \".\", \"\/\", \"<\", \">\", \"[\", \":\",\n+                \"<Unsupported>\", \"has.chars\", \"\/Outer\", \"test\/\", \"test\/\/Outer\");\n+    }\n+\n+    static Stream<String> slashedIdentifiers() {\n+        return Stream.of(\"test\/Outer\", \"java\/lang\/Integer\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"badIdentifiers\", \"slashedIdentifiers\"})\n+    void testBadSimpleIdentifier(String st) {\n+        ClassTypeSig outer = ClassTypeSig.of(\"test\/Outer\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(outer, st));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeVarSig.of(st));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeParam.of(st, (RefTypeSig) null));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeParam.of(st, Optional.empty()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"goodIdentifiers\")\n+    void testGoodSimpleIdentifier(String st) {\n+        ClassTypeSig outer = ClassTypeSig.of(\"test\/Outer\");\n+        ClassTypeSig.of(outer, st);\n+        TypeVarSig.of(st);\n+        TypeParam.of(st, (RefTypeSig) null);\n+        TypeParam.of(st, Optional.empty());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"badIdentifiers\")\n+    void testBadSlashedIdentifier(String st) {\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(st));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"goodIdentifiers\", \"slashedIdentifiers\"})\n+    void testGoodSlashedIdentifier(String st) {\n+        ClassTypeSig.of(st);\n@@ -234,0 +312,1 @@\n+        [V\n@@ -300,0 +379,1 @@\n+        (V)V\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":83,"deletions":3,"binary":false,"changes":86,"status":"modified"}]}