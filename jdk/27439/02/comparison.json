{"files":[{"patch":"@@ -116,2 +116,16 @@\n-                if (sig.charAt(sigp) != ':')\n-                    classBound = referenceTypeSig();\n+                if (sig.charAt(sigp) != ':') {\n+                    int p = nextIdentifierEnd(sig, sigp);\n+                    \/\/ For non-identifier chars:\n+                    \/\/ . \/ < indicates class type (inner, package, type arg)\n+                    \/\/ [ indicates array type\n+                    \/\/ ; indicates class\/type var type\n+                    \/\/ > and : are illegal, such as in <P:R:>\n+                    if (p < sig.length()) {\n+                        char limit = sig.charAt(p);\n+                        if (limit != '>' && limit != ':') {\n+                            classBound = referenceTypeSig();\n+                        }\n+                    }\n+                    \/\/ If classBound is absent here, we start tokenizing\n+                    \/\/ next type parameter, which can trigger failures\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8321540 8319463 8357955\n+ * @bug 8321540 8319463 8357955 8368331\n@@ -123,0 +123,75 @@\n+\n+        assertEqualsDeep(\n+                MethodSignature.of(\n+                        List.of(TypeParam.of(\"A\", ClassTypeSig.of(\"one\/Two\")), \/\/ \/\n+                                TypeParam.of(\"B\", ClassTypeSig.of(ClassTypeSig.of(\"Outer\"), \"Inner\")), \/\/ .\n+                                TypeParam.of(\"C\", ArrayTypeSig.of(BaseTypeSig.of('I'))), \/\/ [\n+                                TypeParam.of(\"D\", ClassTypeSig.of(\"Generic\", TypeArg.unbounded())), \/\/ <\n+                                TypeParam.of(\"E\", TypeVarSig.of(\"A\")), \/\/ ;\n+                                TypeParam.of(\"F\", (ClassTypeSig) null), \/\/ :\n+                                TypeParam.of(\"G\", (ClassTypeSig) null)), \/\/ >\n+                        List.of(),\n+                        BaseTypeSig.of('V')),\n+                MethodSignature.parseFrom(\"<A:Lone\/Two;B:LOuter.Inner;C:[ID:LGeneric<*>;E:TA;F:G:>()V\")\n+        );\n+    }\n+\n+    @Test\n+    void testGenericCreationChecks() {\n+        var weirdNameClass = ClassDesc.of(\"<Unsupported>\");\n+        var voidSig = BaseTypeSig.of('V');\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> Signature.of(weirdNameClass));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> BaseTypeSig.of(CD_Object));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> BaseTypeSig.of(CD_int.arrayType()));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(CD_int));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(CD_Object.arrayType()));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(weirdNameClass));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(255, voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(voidSig, voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(List.of(), List.of(), voidSig, voidSig));\n+    }\n+\n+    static Stream<String> goodIdentifiers() {\n+        return Stream.of(\"T\", \"Hello\", \"Mock\", \"(Weird)\", \" Huh? \");\n+    }\n+\n+    static Stream<String> badIdentifiers() {\n+        return Stream.of(\"\", \";\", \".\", \"\/\", \"<\", \">\", \"[\", \":\",\n+                \"<Unsupported>\", \"has.chars\", \"\/Outer\", \"test\/\", \"test\/\/Outer\");\n+    }\n+\n+    static Stream<String> slashedIdentifiers() {\n+        return Stream.of(\"test\/Outer\", \"java\/lang\/Integer\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"badIdentifiers\", \"slashedIdentifiers\"})\n+    void testBadSimpleIdentifier(String st) {\n+        ClassTypeSig outer = ClassTypeSig.of(\"test\/Outer\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(outer, st));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeVarSig.of(st));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeParam.of(st, (RefTypeSig) null));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeParam.of(st, Optional.empty()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"goodIdentifiers\")\n+    void testGoodSimpleIdentifier(String st) {\n+        ClassTypeSig outer = ClassTypeSig.of(\"test\/Outer\");\n+        ClassTypeSig.of(outer, st);\n+        TypeVarSig.of(st);\n+        TypeParam.of(st, (RefTypeSig) null);\n+        TypeParam.of(st, Optional.empty());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"badIdentifiers\")\n+    void testBadSlashedIdentifier(String st) {\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(st));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"goodIdentifiers\", \"slashedIdentifiers\"})\n+    void testGoodSlashedIdentifier(String st) {\n+        ClassTypeSig.of(st);\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":76,"deletions":1,"binary":false,"changes":77,"status":"modified"}]}