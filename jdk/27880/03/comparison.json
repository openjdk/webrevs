{"files":[{"patch":"@@ -31,0 +31,2 @@\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -156,0 +158,3 @@\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    add_shared_secret_accessors();\n+  }\n@@ -159,0 +164,91 @@\n+\/\/ We allow only \"stateless\" accessors in the SharedSecrets class to be AOT-initialized, for example,\n+\/\/ in the following pattern:\n+\/\/\n+\/\/ class URL {\n+\/\/     static {\n+\/\/         SharedSecrets.setJavaNetURLAccess(\n+\/\/              new JavaNetURLAccess() { ... });\n+\/\/     }\n+\/\/\n+\/\/ This initializes the field SharedSecrets::javaNetUriAccess, whose type (the inner case in the\n+\/\/ above example) has no fields (static or otherwise) and is not a hidden class, so it cannot possibly\n+\/\/ capture any transient state from the assembly phase that might become invalid in the production run.\n+\/\/\n+class CDSHeapVerifier::SharedSecretsAccessorFinder : public FieldClosure {\n+  CDSHeapVerifier* _verifier;\n+  InstanceKlass* _ik;\n+public:\n+  SharedSecretsAccessorFinder(CDSHeapVerifier* verifier, InstanceKlass* ik)\n+    : _verifier(verifier), _ik(ik) {}\n+\n+  void do_field(fieldDescriptor* fd) {\n+    if (fd->field_type() == T_OBJECT) {\n+      oop static_obj_field = _ik->java_mirror()->obj_field(fd->offset());\n+      if (static_obj_field != nullptr) {\n+        Klass* field_type = static_obj_field->klass();\n+\n+        if (!field_type->is_instance_klass()) {\n+          ResourceMark rm;\n+          log_error(aot, heap)(\"jdk.internal.access.SharedSecrets::%s must not be an array\",\n+                               fd->name()->as_C_string());\n+          AOTMetaspace::unrecoverable_writing_error();\n+        }\n+\n+        InstanceKlass* field_type_ik = InstanceKlass::cast(field_type);\n+        if (has_any_fields(field_type_ik) || field_type_ik->is_hidden()) {\n+          \/\/ If field_type_ik is a hidden class, the accessor is probably initialized using a\n+          \/\/ Lambda, which may contain transient states.\n+          ResourceMark rm;\n+          log_error(aot, heap)(\"jdk.internal.access.SharedSecrets::%s (%s) must be stateless\",\n+                               fd->name()->as_C_string(), field_type_ik->external_name());\n+          AOTMetaspace::unrecoverable_writing_error();\n+        }\n+\n+        _verifier->add_shared_secret_accessor(static_obj_field);\n+      }\n+    }\n+  }\n+\n+  \/\/ Does k (or any of its supertypes) have at least one (static or non-static) field?\n+  static bool has_any_fields(InstanceKlass* k) {\n+    if (k->static_field_size() != 0 || k->nonstatic_field_size() != 0) {\n+      return true;\n+    }\n+\n+    if (k->super() != nullptr && has_any_fields(k->super())) {\n+      return true;\n+    }\n+\n+    Array<InstanceKlass*>* interfaces = k->local_interfaces();\n+    int num_interfaces = interfaces->length();\n+    for (int index = 0; index < num_interfaces; index++) {\n+      if (has_any_fields(interfaces->at(index))) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+};\n+\n+\/\/ This function is for allowing the following pattern in the core libraries:\n+\/\/\n+\/\/     public class URLClassPath {\n+\/\/          private static final JavaNetURLAccess JNUA = SharedSecrets.getJavaNetURLAccess();\n+\/\/\n+\/\/ SharedSecrets::javaNetUriAccess has no states so it can be safely AOT-initialized. During\n+\/\/ the production run, even if URLClassPath.<clinit> is re-executed, it will get back the same\n+\/\/ instance of javaNetUriAccess as it did during the assembly phase.\n+\/\/\n+\/\/ Note: this will forbid complex accessors such as SharedSecrets::javaObjectInputFilterAccess\n+\/\/ to be initialized during the AOT assembly phase.\n+void CDSHeapVerifier::add_shared_secret_accessors() {\n+  TempNewSymbol klass_name = SymbolTable::new_symbol(\"jdk\/internal\/access\/SharedSecrets\");\n+  InstanceKlass* ik = SystemDictionary::find_instance_klass(Thread::current(), klass_name,\n+                                                           Handle());\n+  assert(ik != nullptr, \"must have been loaded\");\n+\n+  SharedSecretsAccessorFinder finder(this, ik);\n+  ik->do_local_static_fields(&finder);\n+}\n+\n@@ -184,5 +280,0 @@\n-    if (fd->signature()->equals(\"Ljdk\/internal\/access\/JavaLangAccess;\")) {\n-      \/\/ A few classes have static fields that point to SharedSecrets.getJavaLangAccess().\n-      \/\/ This object carries no state and we can create a new one in the production run.\n-      return;\n-    }\n@@ -191,0 +282,4 @@\n+      if (_verifier->is_shared_secret_accessor(static_obj_field)) {\n+        return;\n+      }\n+\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":100,"deletions":5,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  class SharedSecretsAccessorFinder;\n@@ -58,0 +59,1 @@\n+  GrowableArray<oop> _shared_secret_accessors;\n@@ -73,0 +75,16 @@\n+\n+  void add_shared_secret_accessors();\n+\n+  void add_shared_secret_accessor(oop obj) {\n+    _shared_secret_accessors.append(obj);\n+  }\n+\n+  bool is_shared_secret_accessor(oop obj) {\n+    for (int i = 0; i < _shared_secret_accessors.length(); i++) {\n+      if (_shared_secret_accessors.at(i) == obj) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -1539,5 +1538,0 @@\n-        runtimeSetup();\n-    }\n-\n-    @AOTRuntimeSetup\n-    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -2671,5 +2670,0 @@\n-        runtimeSetup();\n-    }\n-\n-    @AOTRuntimeSetup\n-    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -294,5 +293,0 @@\n-        runtimeSetup();\n-    }\n-\n-    @AOTRuntimeSetup\n-    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -3734,5 +3733,0 @@\n-        runtimeSetup();\n-    }\n-\n-    @AOTRuntimeSetup\n-    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -1750,5 +1749,0 @@\n-        runtimeSetup();\n-    }\n-\n-    @AOTRuntimeSetup\n-    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/net\/URL.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -61,0 +62,12 @@\n+ *\n+ * <p> Notes on the @AOTSafeClassInitializer annotation:\n+ *\n+ * <p>All static fields in SharedSecrets that are initialized in the AOT\n+ * assembly phase must be stateless (as checked by the HotSpot C++ class\n+ * CDSHeapVerifier::SharedSecretsAccessorFinder) so they can be safely\n+ * stored in the AOT cache.\n+ *\n+ * <p>Static fields such as javaObjectInputFilterAccess point to a Lambda\n+ * which is not stateless. The AOT assembly phase must not execute any Java\n+ * code that would lead to the initialization of such fields, or else the AOT\n+ * cache creation will fail.\n@@ -62,1 +75,1 @@\n-\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+ -runtime\/cds\/appcds\/SignedJar.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Try to AOT-initialize SharedSecrets accessors that are not allowed.\n+ * @bug 8368199\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @build SharedSecretsTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar MyTestApp\n+ * @run driver SharedSecretsTest AOT\n+ *\/\n+\n+import java.io.ObjectInputFilter;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class SharedSecretsTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"MyTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester t = new Tester(mainClass);\n+        t.setCheckExitValue(false);\n+        t.runAOTAssemblyWorkflow();\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester(String name) {\n+            super(name);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] { \"-XX:AOTInitTestClass=\" + mainClass};\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                out.shouldMatch(\"jdk.internal.access.SharedSecrets::javaObjectInputFilterAccess .* must be stateless\");\n+                out.shouldNotHaveExitValue(0);\n+            } else {\n+                out.shouldHaveExitValue(0);\n+            }\n+        }\n+    }\n+}\n+\n+\/\/ We use -XX:AOTInitTestClass to force this class to be AOT-initialized in the assembly phase. It will\n+\/\/ cause the SharedSecrets::javaObjectInputFilterAccess to be initialized, which is not allowed.\n+class MyTestApp {\n+    static Object foo = ObjectInputFilter.Config.createFilter(\"\");\n+    public static void main(String args[]) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/SharedSecretsTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}