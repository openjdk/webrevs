{"files":[{"patch":"@@ -8147,0 +8147,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -8156,0 +8157,13 @@\n+instruct castII_checked(iRegI dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastII dst));\n+  effect(KILL cr);\n+\n+  format %{ \"# castII_checked of $dst\" %}\n+  ins_encode %{\n+    __ verify_int_in_range(_idx, bottom_type()->is_int(), $dst$$Register, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8158,0 +8172,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -8167,0 +8182,13 @@\n+instruct castLL_checked(iRegL dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastLL dst));\n+  effect(KILL cr);\n+\n+  format %{ \"# castLL_checked of $dst\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2746,0 +2746,104 @@\n+\n+static void abort_verify_int_in_range(uint idx, jint val, jint lo, jint hi) {\n+  fatal(\"Invalid CastII, idx: %u, val: %d, lo: %d, hi: %d\", idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_int_in_range(uint idx, const TypeInt* t, Register rval, Register rtmp) {\n+  assert(!t->empty() && !t->singleton(), \"%s\", Type::str(t));\n+  if (t == TypeInt::INT) {\n+    return;\n+  }\n+  BLOCK_COMMENT(\"verify_int_in_range {\");\n+  Label L_success, L_failure;\n+\n+  jint lo = t->_lo;\n+  jint hi = t->_hi;\n+\n+  if (lo != min_jint && hi != max_jint) {\n+    subsw(rtmp, rval, lo);\n+    br(Assembler::LT, L_failure);\n+    subsw(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else if (lo != min_jint) {\n+    subsw(rtmp, rval, lo);\n+    br(Assembler::GE, L_success);\n+  } else if (hi != max_jint) {\n+    subsw(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+\n+  bind(L_failure);\n+  movw(c_rarg0, idx);\n+  mov(c_rarg1, rval);\n+  movw(c_rarg2, lo);\n+  movw(c_rarg3, hi);\n+  reconstruct_frame_pointer(rtmp);\n+  rt_call(CAST_FROM_FN_PTR(address, abort_verify_int_in_range), rtmp);\n+  hlt(0);\n+\n+  bind(L_success);\n+  BLOCK_COMMENT(\"} verify_int_in_range\");\n+}\n+\n+static void abort_verify_long_in_range(uint idx, jlong val, jlong lo, jlong hi) {\n+  fatal(\"Invalid CastLL, idx: %u, val: \" JLONG_FORMAT \", lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_long_in_range(uint idx, const TypeLong* t, Register rval, Register rtmp) {\n+  assert(!t->empty() && !t->singleton(), \"%s\", Type::str(t));\n+  if (t == TypeLong::LONG) {\n+    return;\n+  }\n+  BLOCK_COMMENT(\"verify_long_in_range {\");\n+  Label L_success, L_failure;\n+\n+  jlong lo = t->_lo;\n+  jlong hi = t->_hi;\n+\n+  if (lo != min_jlong && hi != max_jlong) {\n+    subs(rtmp, rval, lo);\n+    br(Assembler::LT, L_failure);\n+    subs(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else if (lo != min_jlong) {\n+    subs(rtmp, rval, lo);\n+    br(Assembler::GE, L_success);\n+  } else if (hi != max_jlong) {\n+    subs(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+\n+  bind(L_failure);\n+  movw(c_rarg0, idx);\n+  mov(c_rarg1, rval);\n+  mov(c_rarg2, lo);\n+  mov(c_rarg3, hi);\n+  reconstruct_frame_pointer(rtmp);\n+  rt_call(CAST_FROM_FN_PTR(address, abort_verify_long_in_range), rtmp);\n+  hlt(0);\n+\n+  bind(L_success);\n+  BLOCK_COMMENT(\"} verify_long_in_range\");\n+}\n+\n+void C2_MacroAssembler::reconstruct_frame_pointer(Register rtmp) {\n+  const int framesize = Compile::current()->output()->frame_size_in_bytes();\n+  if (PreserveFramePointer) {\n+    \/\/ frame pointer is valid\n+#ifdef ASSERT\n+    \/\/ Verify frame pointer value in rfp.\n+    add(rtmp, sp, framesize - 2 * wordSize);\n+    Label L_success;\n+    cmp(rfp, rtmp);\n+    br(Assembler::EQ, L_success);\n+    stop(\"frame pointer mismatch\");\n+    bind(L_success);\n+#endif \/\/ ASSERT\n+  } else {\n+    add(rfp, sp, framesize - 2 * wordSize);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -191,0 +191,5 @@\n+  void verify_int_in_range(uint idx, const TypeInt* t, Register val, Register tmp);\n+  void verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp);\n+\n+  void reconstruct_frame_pointer(Register rtmp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -790,0 +790,113 @@\n+static void abort_verify_int_in_range(uint idx, jint val, jint lo, jint hi) {\n+  fatal(\"Invalid CastII, idx: %u, val: %d, lo: %d, hi: %d\", idx, val, lo, hi);\n+}\n+\n+static void reconstruct_frame_pointer_helper(MacroAssembler* masm, Register dst) {\n+  const int framesize = Compile::current()->output()->frame_size_in_bytes();\n+  masm->movptr(dst, rsp);\n+  if (framesize > 2 * wordSize) {\n+    masm->addptr(dst, framesize - 2 * wordSize);\n+  }\n+}\n+\n+void C2_MacroAssembler::reconstruct_frame_pointer(Register rtmp) {\n+  if (PreserveFramePointer) {\n+    \/\/ frame pointer is valid\n+#ifdef ASSERT\n+    \/\/ Verify frame pointer value in rbp.\n+    reconstruct_frame_pointer_helper(this, rtmp);\n+    Label L_success;\n+    cmpq(rbp, rtmp);\n+    jccb(Assembler::equal, L_success);\n+    STOP(\"frame pointer mismatch\");\n+    bind(L_success);\n+#endif \/\/ ASSERT\n+  } else {\n+    reconstruct_frame_pointer_helper(this, rbp);\n+  }\n+}\n+\n+void C2_MacroAssembler::verify_int_in_range(uint idx, const TypeInt* t, Register val) {\n+  jint lo = t->_lo;\n+  jint hi = t->_hi;\n+  assert(lo < hi, \"type should not be empty or constant, idx: %u, lo: %d, hi: %d\", idx, lo, hi);\n+  if (t == TypeInt::INT) {\n+    return;\n+  }\n+\n+  BLOCK_COMMENT(\"CastII {\");\n+  Label fail;\n+  Label succeed;\n+  if (hi == max_jint) {\n+    cmpl(val, lo);\n+    jccb(Assembler::greaterEqual, succeed);\n+  } else {\n+    if (lo != min_jint) {\n+      cmpl(val, lo);\n+      jccb(Assembler::less, fail);\n+    }\n+    cmpl(val, hi);\n+    jccb(Assembler::lessEqual, succeed);\n+  }\n+\n+  bind(fail);\n+  movl(c_rarg0, idx);\n+  movl(c_rarg1, val);\n+  movl(c_rarg2, lo);\n+  movl(c_rarg3, hi);\n+  reconstruct_frame_pointer(rscratch1);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, abort_verify_int_in_range)));\n+  hlt();\n+  bind(succeed);\n+  BLOCK_COMMENT(\"} \/\/ CastII\");\n+}\n+\n+static void abort_verify_long_in_range(uint idx, jlong val, jlong lo, jlong hi) {\n+  fatal(\"Invalid CastLL, idx: %u, val: \" JLONG_FORMAT \", lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp) {\n+  jlong lo = t->_lo;\n+  jlong hi = t->_hi;\n+  assert(lo < hi, \"type should not be empty or constant, idx: %u, lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, lo, hi);\n+  if (t == TypeLong::LONG) {\n+    return;\n+  }\n+\n+  BLOCK_COMMENT(\"CastLL {\");\n+  Label fail;\n+  Label succeed;\n+\n+  auto cmp_val = [&](jlong bound) {\n+    if (is_simm32(bound)) {\n+      cmpq(val, checked_cast<int>(bound));\n+    } else {\n+      mov64(tmp, bound);\n+      cmpq(val, tmp);\n+    }\n+  };\n+\n+  if (hi == max_jlong) {\n+    cmp_val(lo);\n+    jccb(Assembler::greaterEqual, succeed);\n+  } else {\n+    if (lo != min_jlong) {\n+      cmp_val(lo);\n+      jccb(Assembler::less, fail);\n+    }\n+    cmp_val(hi);\n+    jccb(Assembler::lessEqual, succeed);\n+  }\n+\n+  bind(fail);\n+  movl(c_rarg0, idx);\n+  movq(c_rarg1, val);\n+  mov64(c_rarg2, lo);\n+  mov64(c_rarg3, hi);\n+  reconstruct_frame_pointer(rscratch1);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, abort_verify_long_in_range)));\n+  hlt();\n+  bind(succeed);\n+  BLOCK_COMMENT(\"} \/\/ CastLL\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+  void verify_int_in_range(uint idx, const TypeInt* t, Register val);\n+  void verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp);\n+\n@@ -577,0 +580,3 @@\n+\n+  void reconstruct_frame_pointer(Register rtmp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -425,0 +425,12 @@\n+bool castLL_is_imm32(const Node* n);\n+\n+%}\n+\n+source %{\n+\n+bool castLL_is_imm32(const Node* n) {\n+  assert(n->is_CastLL(), \"must be a CastLL\");\n+  const TypeLong* t = n->bottom_type()->is_long();\n+  return (t->_lo == min_jlong || Assembler::is_simm32(t->_lo)) && (t->_hi == max_jlong || Assembler::is_simm32(t->_hi));\n+}\n+\n@@ -7608,0 +7620,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -7617,0 +7630,13 @@\n+instruct castII_checked(rRegI dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastII dst));\n+\n+  effect(KILL cr);\n+  format %{ \"# cast_checked_II $dst\" %}\n+  ins_encode %{\n+    __ verify_int_in_range(_idx, bottom_type()->is_int(), $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -7619,0 +7645,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -7628,0 +7655,26 @@\n+instruct castLL_checked_L32(rRegL dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0 && castLL_is_imm32(n));\n+  match(Set dst (CastLL dst));\n+\n+  effect(KILL cr);\n+  format %{ \"# cast_checked_LL $dst\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, noreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct castLL_checked(rRegL dst, rRegL tmp, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0 && !castLL_is_imm32(n));\n+  match(Set dst (CastLL dst));\n+\n+  effect(KILL cr, TEMP tmp);\n+  format %{ \"# cast_checked_LL $dst\\tusing $tmp as TEMP\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+class TypeInt;\n+class TypeLong;\n","filename":"src\/hotspot\/share\/opto\/c2_MacroAssembler.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -672,0 +672,10 @@\n+  product(uint, VerifyConstraintCasts, 0, DIAGNOSTIC,                       \\\n+          \"Perform runtime checks to verify the value of a \"                \\\n+          \"ConstraintCast lies inside its type\"                             \\\n+          \"0 = does not perform any verification, \"                         \\\n+          \"1 = perform verification on ConstraintCastNodes that are \"       \\\n+              \"present during code emission, \"                              \\\n+          \"2 = Do not do widening of ConstraintCastNodes so that we can \"   \\\n+              \"have more verification coverage\")                            \\\n+          range(0, 2)                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -534,0 +534,12 @@\n+\n+  \/\/ At VerifyConstraintCasts == 1, we verify the ConstraintCastNodes that are present during code\n+  \/\/ emission. This allows us detecting possible mis-scheduling due to these nodes being pinned at\n+  \/\/ the wrong control nodes.\n+  \/\/ At VerifyConstraintCasts == 2, we do not perform widening so that we can verify the\n+  \/\/ correctness of more ConstraintCastNodes. This further helps us detect possible\n+  \/\/ mis-transformations that may happen due to these nodes being pinned at the wrong control\n+  \/\/ nodes.\n+  if (VerifyConstraintCasts > 1) {\n+    return res;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8346836\n+ * @requires vm.debug == true & vm.flavor == \"server\"\n+ * @summary Run with -Xcomp to test -XX:+StressGCM -XX:VerifyConstraintCasts=1 in debug builds.\n+ *\n+ * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:+StressGCM -XX:VerifyConstraintCasts=1 compiler.c2.TestVerifyConstraintCasts\n+ * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:+StressGCM -XX:VerifyConstraintCasts=2 compiler.c2.TestVerifyConstraintCasts\n+ *\/\n+package compiler.c2;\n+\n+public class TestVerifyConstraintCasts {\n+    public static void main(String[] args) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestVerifyConstraintCasts.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}