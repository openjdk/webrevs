{"files":[{"patch":"@@ -8147,0 +8147,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -8156,0 +8157,13 @@\n+instruct castII_checked(iRegI dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastII dst));\n+  effect(KILL cr);\n+\n+  format %{ \"# castII_checked of $dst\" %}\n+  ins_encode %{\n+    __ verify_int_in_range(_idx, bottom_type()->is_int(), $dst$$Register, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8158,0 +8172,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -8167,0 +8182,13 @@\n+instruct castLL_checked(iRegL dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastLL dst));\n+  effect(KILL cr);\n+\n+  format %{ \"# castLL_checked of $dst\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2746,0 +2746,104 @@\n+\n+static void abort_verify_int_in_range(uint idx, jint val, jint lo, jint hi) {\n+  fatal(\"Invalid CastII, idx: %u, val: %d, lo: %d, hi: %d\", idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_int_in_range(uint idx, const TypeInt* t, Register rval, Register rtmp) {\n+  assert(!t->empty() && !t->singleton(), \"%s\", Type::str(t));\n+  if (t == TypeInt::INT) {\n+    return;\n+  }\n+  BLOCK_COMMENT(\"verify_int_in_range {\");\n+  Label L_success, L_failure;\n+\n+  jint lo = t->_lo;\n+  jint hi = t->_hi;\n+\n+  if (lo != min_jint && hi != max_jint) {\n+    subsw(rtmp, rval, lo);\n+    br(Assembler::LT, L_failure);\n+    subsw(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else if (lo != min_jint) {\n+    subsw(rtmp, rval, lo);\n+    br(Assembler::GE, L_success);\n+  } else if (hi != max_jint) {\n+    subsw(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+\n+  bind(L_failure);\n+  movw(c_rarg0, idx);\n+  mov(c_rarg1, rval);\n+  movw(c_rarg2, lo);\n+  movw(c_rarg3, hi);\n+  reconstruct_frame_pointer(rtmp);\n+  rt_call(CAST_FROM_FN_PTR(address, abort_verify_int_in_range), rtmp);\n+  hlt(0);\n+\n+  bind(L_success);\n+  BLOCK_COMMENT(\"} verify_int_in_range\");\n+}\n+\n+static void abort_verify_long_in_range(uint idx, jlong val, jlong lo, jlong hi) {\n+  fatal(\"Invalid CastLL, idx: %u, val: \" JLONG_FORMAT \", lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_long_in_range(uint idx, const TypeLong* t, Register rval, Register rtmp) {\n+  assert(!t->empty() && !t->singleton(), \"%s\", Type::str(t));\n+  if (t == TypeLong::LONG) {\n+    return;\n+  }\n+  BLOCK_COMMENT(\"verify_long_in_range {\");\n+  Label L_success, L_failure;\n+\n+  jlong lo = t->_lo;\n+  jlong hi = t->_hi;\n+\n+  if (lo != min_jlong && hi != max_jlong) {\n+    subs(rtmp, rval, lo);\n+    br(Assembler::LT, L_failure);\n+    subs(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else if (lo != min_jlong) {\n+    subs(rtmp, rval, lo);\n+    br(Assembler::GE, L_success);\n+  } else if (hi != max_jlong) {\n+    subs(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+\n+  bind(L_failure);\n+  movw(c_rarg0, idx);\n+  mov(c_rarg1, rval);\n+  mov(c_rarg2, lo);\n+  mov(c_rarg3, hi);\n+  reconstruct_frame_pointer(rtmp);\n+  rt_call(CAST_FROM_FN_PTR(address, abort_verify_long_in_range), rtmp);\n+  hlt(0);\n+\n+  bind(L_success);\n+  BLOCK_COMMENT(\"} verify_long_in_range\");\n+}\n+\n+void C2_MacroAssembler::reconstruct_frame_pointer(Register rtmp) {\n+  const int framesize = Compile::current()->output()->frame_size_in_bytes();\n+  if (PreserveFramePointer) {\n+    \/\/ frame pointer is valid\n+#ifdef ASSERT\n+    \/\/ Verify frame pointer value in rfp.\n+    add(rtmp, sp, framesize - 2 * wordSize);\n+    Label L_success;\n+    cmp(rfp, rtmp);\n+    br(Assembler::EQ, L_success);\n+    stop(\"frame pointer mismatch\");\n+    bind(L_success);\n+#endif \/\/ ASSERT\n+  } else {\n+    add(rfp, sp, framesize - 2 * wordSize);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -191,0 +191,5 @@\n+  void verify_int_in_range(uint idx, const TypeInt* t, Register val, Register tmp);\n+  void verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp);\n+\n+  void reconstruct_frame_pointer(Register rtmp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -794,0 +794,25 @@\n+static void reconstruct_frame_pointer_helper(MacroAssembler* masm, Register dst) {\n+  const int framesize = Compile::current()->output()->frame_size_in_bytes();\n+  masm->movptr(dst, rsp);\n+  if (framesize > 2 * wordSize) {\n+    masm->addptr(dst, framesize - 2 * wordSize);\n+  }\n+}\n+\n+void C2_MacroAssembler::reconstruct_frame_pointer(Register rtmp) {\n+  if (PreserveFramePointer) {\n+    \/\/ frame pointer is valid\n+#ifdef ASSERT\n+    \/\/ Verify frame pointer value in rbp.\n+    reconstruct_frame_pointer_helper(this, rtmp);\n+    Label L_success;\n+    cmpq(rbp, rtmp);\n+    jccb(Assembler::equal, L_success);\n+    STOP(\"frame pointer mismatch\");\n+    bind(L_success);\n+#endif \/\/ ASSERT\n+  } else {\n+    reconstruct_frame_pointer_helper(this, rbp);\n+  }\n+}\n+\n@@ -822,0 +847,1 @@\n+  reconstruct_frame_pointer(rscratch1);\n@@ -870,0 +896,1 @@\n+  reconstruct_frame_pointer(rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -580,0 +580,3 @@\n+\n+  void reconstruct_frame_pointer(Register rtmp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}