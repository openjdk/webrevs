{"files":[{"patch":"@@ -146,1 +146,1 @@\n-    Label ext_cpuid8, done, wrapup, vector_save_restore, apx_save_restore_warning;\n+    Label ext_cpuid8, done, wrapup, vector_save_restore, apx_save_restore_warning, apx_xstate;\n@@ -471,0 +471,14 @@\n+    \/\/\n+    \/\/ Query CPUID 0xD.19 for APX XSAVE offset\n+    \/\/ Extended State Enumeration Sub-leaf 19 (APX)\n+    \/\/ EAX = size of APX state (should be 128)\n+    \/\/ EBX = offset in standard XSAVE format\n+    \/\/\n+    __ movl(rax, 0xD);\n+    __ movl(rcx, 19);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::apx_xstate_size_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::apx_xstate_offset_offset())));\n+    __ movl(Address(rsi, 0), rbx);\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -679,0 +679,4 @@\n+    \/\/ cpuid function 0xD, subleaf 19 (APX extended state)\n+    uint32_t          apx_xstate_size;          \/\/ EAX: size of APX state (128)\n+    uint32_t          apx_xstate_offset;        \/\/ EBX: offset in standard XSAVE area\n+\n@@ -742,0 +746,5 @@\n+  static ByteSize apx_xstate_offset_offset() { return byte_offset_of(CpuidInfo, apx_xstate_offset); }\n+  static ByteSize apx_xstate_size_offset() { return byte_offset_of(CpuidInfo, apx_xstate_size); }\n+\n+  static uint32_t apx_xstate_offset() { return _cpuid_info.apx_xstate_offset; }\n+  static uint32_t apx_xstate_size()   { return _cpuid_info.apx_xstate_size; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -383,0 +384,37 @@\n+\/\/ XSAVE constants - from Intel SDM Vol. 1, Chapter 13\n+#define XSAVE_HDR_OFFSET 512\n+#define XFEATURE_APX     (1ULL << 19)\n+\n+\/\/ XSAVE header structure\n+\/\/ See: Intel SDM Vol. 1, Section 13.4.2 \"XSAVE Header\"\n+\/\/ Also: Linux kernel arch\/x86\/include\/asm\/fpu\/types.h\n+struct xstate_header {\n+    uint64_t xfeatures;\n+    uint64_t xcomp_bv;\n+    uint64_t reserved[6];\n+};\n+\n+\/\/ APX extended state - R16-R31 (16 x 64-bit registers)\n+\/\/ See: Intel APX Architecture Specification\n+struct apx_state {\n+    uint64_t regs[16];  \/\/ r16-r31\n+};\n+\n+static apx_state* get_apx_state(const ucontext_t* uc) {\n+    uint32_t offset = VM_Version::apx_xstate_offset();\n+    if (offset == 0 || uc->uc_mcontext.fpregs == nullptr) {\n+        return nullptr;\n+    }\n+\n+    char* xsave = (char*)uc->uc_mcontext.fpregs;\n+    xstate_header* hdr = (xstate_header*)(xsave + XSAVE_HDR_OFFSET);\n+\n+    \/\/ Check if APX state is present in this context\n+    if (!(hdr->xfeatures & XFEATURE_APX)) {\n+        return nullptr;\n+    }\n+\n+    return (apx_state*)(xsave + offset);\n+}\n+\n+\n@@ -409,0 +447,24 @@\n+  \/\/ Dump APX EGPRs (R16-R31)\n+  apx_state* apx = get_apx_state(uc);\n+  if (UseAPX && apx != nullptr) {\n+    st->print(  \"R16=\" INTPTR_FORMAT, (intptr_t)apx->regs[0]);\n+    st->print(\", R17=\" INTPTR_FORMAT, (intptr_t)apx->regs[1]);\n+    st->print(\", R18=\" INTPTR_FORMAT, (intptr_t)apx->regs[2]);\n+    st->print(\", R19=\" INTPTR_FORMAT, (intptr_t)apx->regs[3]);\n+    st->cr();\n+    st->print(  \"R20=\" INTPTR_FORMAT, (intptr_t)apx->regs[4]);\n+    st->print(\", R21=\" INTPTR_FORMAT, (intptr_t)apx->regs[5]);\n+    st->print(\", R22=\" INTPTR_FORMAT, (intptr_t)apx->regs[6]);\n+    st->print(\", R23=\" INTPTR_FORMAT, (intptr_t)apx->regs[7]);\n+    st->cr();\n+    st->print(  \"R24=\" INTPTR_FORMAT, (intptr_t)apx->regs[8]);\n+    st->print(\", R25=\" INTPTR_FORMAT, (intptr_t)apx->regs[9]);\n+    st->print(\", R26=\" INTPTR_FORMAT, (intptr_t)apx->regs[10]);\n+    st->print(\", R27=\" INTPTR_FORMAT, (intptr_t)apx->regs[11]);\n+    st->cr();\n+    st->print(  \"R28=\" INTPTR_FORMAT, (intptr_t)apx->regs[12]);\n+    st->print(\", R29=\" INTPTR_FORMAT, (intptr_t)apx->regs[13]);\n+    st->print(\", R30=\" INTPTR_FORMAT, (intptr_t)apx->regs[14]);\n+    st->print(\", R31=\" INTPTR_FORMAT, (intptr_t)apx->regs[15]);\n+    st->cr();\n+  }\n@@ -435,1 +497,7 @@\n-  const int register_count = 16;\n+  if (context == nullptr) {\n+    return;\n+  }\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  apx_state* apx = UseAPX ? get_apx_state(uc) : nullptr;\n+\n+  const int register_count = 16 + (apx != nullptr ? 16 : 0);\n@@ -438,1 +506,1 @@\n-  if (context == nullptr || n == register_count) {\n+  if (n == register_count) {\n@@ -442,1 +510,0 @@\n-  const ucontext_t *uc = (const ucontext_t*)context;\n@@ -446,0 +513,3 @@\n+\n+    if (n < 16) {\n+      \/\/ Standard registers (RAX-R15)\n@@ -447,18 +517,18 @@\n-    switch (n) {\n-    CASE_PRINT_REG( 0, \"RAX=\", RAX); break;\n-    CASE_PRINT_REG( 1, \"RBX=\", RBX); break;\n-    CASE_PRINT_REG( 2, \"RCX=\", RCX); break;\n-    CASE_PRINT_REG( 3, \"RDX=\", RDX); break;\n-    CASE_PRINT_REG( 4, \"RSP=\", RSP); break;\n-    CASE_PRINT_REG( 5, \"RBP=\", RBP); break;\n-    CASE_PRINT_REG( 6, \"RSI=\", RSI); break;\n-    CASE_PRINT_REG( 7, \"RDI=\", RDI); break;\n-    CASE_PRINT_REG( 8, \"R8 =\", R8); break;\n-    CASE_PRINT_REG( 9, \"R9 =\", R9); break;\n-    CASE_PRINT_REG(10, \"R10=\", R10); break;\n-    CASE_PRINT_REG(11, \"R11=\", R11); break;\n-    CASE_PRINT_REG(12, \"R12=\", R12); break;\n-    CASE_PRINT_REG(13, \"R13=\", R13); break;\n-    CASE_PRINT_REG(14, \"R14=\", R14); break;\n-    CASE_PRINT_REG(15, \"R15=\", R15); break;\n-    }\n+      switch (n) {\n+        CASE_PRINT_REG( 0, \"RAX=\", RAX); break;\n+        CASE_PRINT_REG( 1, \"RBX=\", RBX); break;\n+        CASE_PRINT_REG( 2, \"RCX=\", RCX); break;\n+        CASE_PRINT_REG( 3, \"RDX=\", RDX); break;\n+        CASE_PRINT_REG( 4, \"RSP=\", RSP); break;\n+        CASE_PRINT_REG( 5, \"RBP=\", RBP); break;\n+        CASE_PRINT_REG( 6, \"RSI=\", RSI); break;\n+        CASE_PRINT_REG( 7, \"RDI=\", RDI); break;\n+        CASE_PRINT_REG( 8, \"R8 =\", R8); break;\n+        CASE_PRINT_REG( 9, \"R9 =\", R9); break;\n+        CASE_PRINT_REG(10, \"R10=\", R10); break;\n+        CASE_PRINT_REG(11, \"R11=\", R11); break;\n+        CASE_PRINT_REG(12, \"R12=\", R12); break;\n+        CASE_PRINT_REG(13, \"R13=\", R13); break;\n+        CASE_PRINT_REG(14, \"R14=\", R14); break;\n+        CASE_PRINT_REG(15, \"R15=\", R15); break;\n+      }\n@@ -466,0 +536,23 @@\n+    } else {\n+      \/\/ APX extended general purpose registers (R16-R31)\n+# define CASE_PRINT_REG_APX(n, str, idx) case n: st->print(str); print_location(st, apx->regs[idx]);\n+      switch (n) {\n+        CASE_PRINT_REG_APX(16, \"R16=\", 0); break;\n+        CASE_PRINT_REG_APX(17, \"R17=\", 1); break;\n+        CASE_PRINT_REG_APX(18, \"R18=\", 2); break;\n+        CASE_PRINT_REG_APX(19, \"R19=\", 3); break;\n+        CASE_PRINT_REG_APX(20, \"R20=\", 4); break;\n+        CASE_PRINT_REG_APX(21, \"R21=\", 5); break;\n+        CASE_PRINT_REG_APX(22, \"R22=\", 6); break;\n+        CASE_PRINT_REG_APX(23, \"R23=\", 7); break;\n+        CASE_PRINT_REG_APX(24, \"R24=\", 8); break;\n+        CASE_PRINT_REG_APX(25, \"R25=\", 9); break;\n+        CASE_PRINT_REG_APX(26, \"R26=\", 10); break;\n+        CASE_PRINT_REG_APX(27, \"R27=\", 11); break;\n+        CASE_PRINT_REG_APX(28, \"R28=\", 12); break;\n+        CASE_PRINT_REG_APX(29, \"R29=\", 13); break;\n+        CASE_PRINT_REG_APX(30, \"R30=\", 14); break;\n+        CASE_PRINT_REG_APX(31, \"R31=\", 15); break;\n+      }\n+# undef CASE_PRINT_REG_APX\n+    }\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":114,"deletions":21,"binary":false,"changes":135,"status":"modified"}]}