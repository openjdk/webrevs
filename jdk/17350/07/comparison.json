{"files":[{"patch":"@@ -167,0 +167,1 @@\n+  narrowOop* patching_start = (narrowOop*)region.start() + FileMapInfo::current_info()->heap_oopmap_start_pos();\n@@ -173,1 +174,1 @@\n-      PatchCompressedEmbeddedPointersQuick patcher((narrowOop*)region.start(), quick_delta);\n+      PatchCompressedEmbeddedPointersQuick patcher(patching_start, quick_delta);\n@@ -178,1 +179,1 @@\n-    PatchCompressedEmbeddedPointers patcher((narrowOop*)region.start());\n+    PatchCompressedEmbeddedPointers patcher(patching_start);\n@@ -189,7 +190,0 @@\n-\n-#ifndef PRODUCT\n-  ResourceMark rm;\n-  ResourceBitMap checkBm = HeapShared::calculate_oopmap(region);\n-  assert(bm.is_same(checkBm), \"sanity\");\n-#endif\n-\n@@ -199,1 +193,1 @@\n-    PatchUncompressedEmbeddedPointers patcher((oop*)region.start());\n+    PatchUncompressedEmbeddedPointers patcher((oop*)region.start() + FileMapInfo::current_info()->heap_oopmap_start_pos());\n@@ -319,1 +313,1 @@\n-  PatchLoadedRegionPointers patcher((narrowOop*)load_address, loaded_region);\n+  PatchLoadedRegionPointers patcher((narrowOop*)load_address + FileMapInfo::current_info()->heap_oopmap_start_pos(), loaded_region);\n@@ -452,1 +446,1 @@\n-    PatchNativePointers patcher((Metadata**)r->mapped_base());\n+    PatchNativePointers patcher((Metadata**)r->mapped_base() + FileMapInfo::current_info()->heap_ptrmap_start_pos());\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+GrowableArrayCHeap<int, mtClassShared>* ArchiveHeapWriter::_source_objs_order;\n@@ -75,0 +76,1 @@\n+static int _num_native_ptrs = 0;\n@@ -87,0 +89,1 @@\n+    _source_objs_order = new GrowableArrayCHeap<int, mtClassShared>(10000);\n@@ -94,0 +97,1 @@\n+  _source_objs_order->append(_source_objs->length());\n@@ -229,0 +233,43 @@\n+static int oop_sorting_rank(oop o) {\n+  bool has_o_ptr = HeapShared::has_oop_pointers(o);\n+  bool has_n_ptr = HeapShared::has_native_pointers(o);\n+\n+  if (!has_o_ptr) {\n+    if (!has_n_ptr) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  } else {\n+    if (has_n_ptr) {\n+      return 2;\n+    } else {\n+      return 3;\n+    }\n+  }\n+}\n+\n+\/\/ The goal is to sort the objects in increasing order of:\n+\/\/ - objects that have no pointers\n+\/\/ - objects that have only native pointers\n+\/\/ - objects that have both native and oop pointers\n+\/\/ - objects that have only oop pointers\n+int ArchiveHeapWriter::compare_objs_by_oop_fields(int* a, int* b) {\n+  oop oa = _source_objs->at(*a);\n+  oop ob = _source_objs->at(*b);\n+\n+  int rank_a = oop_sorting_rank(oa);\n+  int rank_b = oop_sorting_rank(ob);\n+\n+  if (rank_a != rank_b) {\n+    return rank_a - rank_b;\n+  } else {\n+    \/\/ If they are the same rank, sort them by their position in the _source_objs array\n+    return *a - *b;\n+  }\n+}\n+\n+void ArchiveHeapWriter::sort_source_objs() {\n+  _source_objs_order->sort(compare_objs_by_oop_fields);\n+}\n+\n@@ -230,2 +277,4 @@\n-  for (int i = 0; i < _source_objs->length(); i++) {\n-    oop src_obj = _source_objs->at(i);\n+  sort_source_objs();\n+  for (int i = 0; i < _source_objs_order->length(); i++) {\n+    int src_obj_index = _source_objs_order->at(i);\n+    oop src_obj = _source_objs->at(src_obj_index);\n@@ -242,2 +291,2 @@\n-  log_info(cds)(\"Size of heap region = \" SIZE_FORMAT \" bytes, %d objects, %d roots\",\n-                _buffer_used, _source_objs->length() + 1, roots->length());\n+  log_info(cds)(\"Size of heap region = \" SIZE_FORMAT \" bytes, %d objects, %d roots, %d native ptrs\",\n+                _buffer_used, _source_objs->length() + 1, roots->length(), _num_native_ptrs);\n@@ -515,0 +564,11 @@\n+static void log_bitmap_usage(const char* which, BitMap* bitmap, size_t total_bits) {\n+  \/\/ The whole heap is covered by total_bits, but there are only non-zero bits within [start ... end).\n+  size_t start = bitmap->find_first_set_bit(0);\n+  size_t end = bitmap->size();\n+  log_info(cds)(\"%s = \" SIZE_FORMAT_W(7) \" ... \" SIZE_FORMAT_W(7) \" (%3zu%% ... %3zu%% = %3zu%%)\", which,\n+                start, end,\n+                start * 100 \/ total_bits,\n+                end * 100 \/ total_bits,\n+                (end - start) * 100 \/ total_bits);\n+}\n+\n@@ -522,2 +582,6 @@\n-  auto iterator = [&] (oop src_obj, HeapShared::CachedOopInfo& info) {\n-    oop requested_obj = requested_obj_from_buffer_offset(info.buffer_offset());\n+  for (int i = 0; i < _source_objs_order->length(); i++) {\n+    int src_obj_index = _source_objs_order->at(i);\n+    oop src_obj = _source_objs->at(src_obj_index);\n+    HeapShared::CachedOopInfo* info = HeapShared::archived_object_cache()->get(src_obj);\n+    assert(info != nullptr, \"must be\");\n+    oop requested_obj = requested_obj_from_buffer_offset(info->buffer_offset());\n@@ -525,1 +589,1 @@\n-    address buffered_obj = offset_to_buffered_address<address>(info.buffer_offset());\n+    address buffered_obj = offset_to_buffered_address<address>(info->buffer_offset());\n@@ -529,1 +593,0 @@\n-  HeapShared::archived_object_cache()->iterate_all(iterator);\n@@ -545,0 +608,4 @@\n+\n+  size_t total_bytes = (size_t)_buffer->length();\n+  log_bitmap_usage(\"oopmap\", heap_info->oopmap(), total_bytes \/ (UseCompressedOops ? sizeof(narrowOop) : sizeof(oop)));\n+  log_bitmap_usage(\"ptrmap\", heap_info->ptrmap(), total_bytes \/ sizeof(address));\n@@ -554,0 +621,2 @@\n+    HeapShared::set_has_native_pointers(src_obj);\n+    _num_native_ptrs ++;\n@@ -568,0 +637,7 @@\n+  \/\/ Leading zeros have been removed so some addresses may not be in the ptrmap\n+  size_t start_pos = FileMapInfo::current_info()->heap_ptrmap_start_pos();\n+  if (idx < start_pos) {\n+    return false;\n+  } else {\n+    idx -= start_pos;\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":85,"deletions":9,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,0 +143,1 @@\n+  static GrowableArrayCHeap<int, mtClassShared>* _source_objs_order;\n@@ -213,0 +214,4 @@\n+\n+  static int compare_objs_by_oop_fields(int* a, int* b);\n+  static void sort_source_objs();\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -292,0 +292,2 @@\n+  st->print_cr(\"- _heap_oopmap_start_pos:         \" SIZE_FORMAT, _heap_oopmap_start_pos);\n+  st->print_cr(\"- _heap_ptrmap_start_pos:         \" SIZE_FORMAT, _heap_ptrmap_start_pos);\n@@ -1568,0 +1570,19 @@\n+\/\/ The start of the archived heap has many primitive arrays (String\n+\/\/ bodies) that are not marked by the oop\/ptr maps. So we must have\n+\/\/ lots of leading zeros.\n+size_t FileMapInfo::remove_bitmap_leading_zeros(CHeapBitMap* map) {\n+  size_t old_zeros = map->find_first_set_bit(0);\n+  size_t old_size = map->size_in_bytes();\n+\n+  \/\/ Slice and resize bitmap\n+  map->truncate(old_zeros, map->size());\n+\n+  DEBUG_ONLY(\n+    size_t new_zeros = map->find_first_set_bit(0);\n+    assert(new_zeros == 0, \"Should have removed leading zeros\");\n+  )\n+\n+  assert(map->size_in_bytes() < old_size, \"Map size should have decreased\");\n+  return old_zeros;\n+}\n+\n@@ -1573,0 +1594,7 @@\n+    \/\/ Remove leading zeros\n+    size_t removed_oop_zeros = remove_bitmap_leading_zeros(heap_info->oopmap());\n+    size_t removed_ptr_zeros = remove_bitmap_leading_zeros(heap_info->ptrmap());\n+\n+    header()->set_heap_oopmap_start_pos(removed_oop_zeros);\n+    header()->set_heap_ptrmap_start_pos(removed_ptr_zeros);\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -231,0 +231,2 @@\n+  size_t _heap_oopmap_start_pos;        \/\/ The first bit in the oopmap corresponds to this position in the heap.\n+  size_t _heap_ptrmap_start_pos;        \/\/ The first bit in the ptrmap corresponds to this position in the heap.\n@@ -272,0 +274,2 @@\n+  size_t heap_oopmap_start_pos()           const { return _heap_oopmap_start_pos;}\n+  size_t heap_ptrmap_start_pos()           const { return _heap_ptrmap_start_pos;}\n@@ -284,0 +288,2 @@\n+  void set_heap_oopmap_start_pos(size_t n)       { _heap_oopmap_start_pos = n; }\n+  void set_heap_ptrmap_start_pos(size_t n)       { _heap_ptrmap_start_pos = n; }\n@@ -381,0 +387,2 @@\n+  size_t  heap_oopmap_start_pos() const { return header()->heap_oopmap_start_pos(); }\n+  size_t  heap_ptrmap_start_pos() const { return header()->heap_ptrmap_start_pos(); }\n@@ -437,0 +445,1 @@\n+  size_t remove_bitmap_leading_zeros(CHeapBitMap* map);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-    CachedOopInfo info = make_cached_oop_info();\n+    CachedOopInfo info = make_cached_oop_info(obj);\n@@ -440,0 +440,18 @@\n+bool HeapShared::has_oop_pointers(oop src_obj) {\n+  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n+  assert(info != nullptr, \"must be\");\n+  return info->has_oop_pointers();\n+}\n+\n+bool HeapShared::has_native_pointers(oop src_obj) {\n+  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n+  assert(info != nullptr, \"must be\");\n+  return info->has_native_pointers();\n+}\n+\n+void HeapShared::set_has_native_pointers(oop src_obj) {\n+  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n+  assert(info != nullptr, \"must be\");\n+  info->set_has_native_pointers();\n+}\n+\n@@ -1141,1 +1159,16 @@\n-HeapShared::CachedOopInfo HeapShared::make_cached_oop_info() {\n+\/\/ Checks if an oop has any non-null oop fields\n+class PointsToOopsChecker : public BasicOopIterateClosure {\n+  bool _result;\n+\n+  template <class T> void check(T *p) {\n+    _result |= (HeapAccess<>::oop_load(p) != nullptr);\n+  }\n+\n+public:\n+  PointsToOopsChecker() : _result(false) {}\n+  void do_oop(narrowOop *p) { check(p); }\n+  void do_oop(      oop *p) { check(p); }\n+  bool result() { return _result; }\n+};\n+\n+HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop obj) {\n@@ -1144,1 +1177,3 @@\n-  return CachedOopInfo(referrer);\n+  PointsToOopsChecker points_to_oops_checker;\n+  obj->oop_iterate(&points_to_oops_checker);\n+  return CachedOopInfo(referrer, points_to_oops_checker.result());\n@@ -1442,0 +1477,1 @@\n+    const char* test_class_name = ArchiveHeapTestClass;\n@@ -1444,0 +1480,1 @@\n+    const char* test_class_name = \"\"; \/\/ avoid C++ printf checks warnings.\n@@ -1447,1 +1484,1 @@\n-      log_warning(cds)(\"Loading ArchiveHeapTestClass %s ...\", ArchiveHeapTestClass);\n+      log_warning(cds)(\"Loading ArchiveHeapTestClass %s ...\", test_class_name);\n@@ -1473,1 +1510,1 @@\n-        st.print(\"ArchiveHeapTestClass %s is not in unnamed module\", ArchiveHeapTestClass);\n+        st.print(\"ArchiveHeapTestClass %s is not in unnamed module\", test_class_name);\n@@ -1480,1 +1517,1 @@\n-        st.print(\"ArchiveHeapTestClass %s is not in unnamed package\", ArchiveHeapTestClass);\n+        st.print(\"ArchiveHeapTestClass %s is not in unnamed package\", test_class_name);\n@@ -1495,1 +1532,1 @@\n-      log_warning(cds)(\"Initializing ArchiveHeapTestClass %s ...\", ArchiveHeapTestClass);\n+      log_warning(cds)(\"Initializing ArchiveHeapTestClass %s ...\", test_class_name);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":44,"deletions":7,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,1 +189,1 @@\n-    \/\/ See \"TEMP notes: What are these?\" in archiveHeapWriter.hpp\n+    \/\/ Used by CDSHeapVerifier.\n@@ -194,0 +194,6 @@\n+\n+    \/\/ One or more fields in this object are pointing to non-null oops.\n+    bool _has_oop_pointers;\n+\n+    \/\/ One or more fields in this object are pointing to MetaspaceObj\n+    bool _has_native_pointers;\n@@ -195,1 +201,1 @@\n-    CachedOopInfo(oop orig_referrer)\n+    CachedOopInfo(oop orig_referrer, bool has_oop_pointers)\n@@ -197,1 +203,3 @@\n-        _buffer_offset(0) {}\n+        _buffer_offset(0),\n+        _has_oop_pointers(has_oop_pointers),\n+        _has_native_pointers(false) {}\n@@ -201,0 +209,3 @@\n+    bool has_oop_pointers()         const { return _has_oop_pointers; }\n+    bool has_native_pointers()      const { return _has_native_pointers; }\n+    void set_has_native_pointers()        { _has_native_pointers = true; }\n@@ -240,1 +251,1 @@\n-  static CachedOopInfo make_cached_oop_info();\n+  static CachedOopInfo make_cached_oop_info(oop obj);\n@@ -371,0 +382,3 @@\n+  static bool has_oop_pointers(oop obj);\n+  static bool has_native_pointers(oop obj);\n+  static void set_has_native_pointers(oop obj);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+bool MetaspaceShared::_use_optimized_module_handling = true;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+  static bool _use_optimized_module_handling;\n+\n@@ -161,0 +163,4 @@\n+  \/\/ Can we skip some expensive operations related to modules?\n+  static bool use_optimized_module_handling() { return NOT_CDS(false) CDS_ONLY(_use_optimized_module_handling); }\n+  static void disable_optimized_module_handling() { _use_optimized_module_handling = false; }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}