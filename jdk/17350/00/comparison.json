{"files":[{"patch":"@@ -109,1 +109,2 @@\n-    narrowOop* p = _start + offset;\n+    size_t shift = MetaspaceShared::oopmap_leading_zeros();\n+    narrowOop* p = _start + offset + shift;\n@@ -126,1 +127,2 @@\n-    narrowOop* p = _start + offset;\n+    size_t shift = MetaspaceShared::oopmap_leading_zeros();\n+    narrowOop* p = _start + offset + shift;\n@@ -148,1 +150,2 @@\n-    oop* p = _start + offset;\n+    size_t shift = MetaspaceShared::oopmap_leading_zeros();\n+    oop* p = _start + offset + shift;\n@@ -189,7 +192,0 @@\n-\n-#ifndef PRODUCT\n-  ResourceMark rm;\n-  ResourceBitMap checkBm = HeapShared::calculate_oopmap(region);\n-  assert(bm.is_same(checkBm), \"sanity\");\n-#endif\n-\n@@ -250,1 +246,2 @@\n-    narrowOop* p = _start + offset;\n+    size_t shift = MetaspaceShared::oopmap_leading_zeros();\n+    narrowOop* p = _start + offset + shift;\n@@ -433,1 +430,2 @@\n-    Metadata** p = _start + offset;\n+    size_t shift = MetaspaceShared::ptrmap_leading_zeros();\n+    Metadata** p = _start + offset + shift;\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+GrowableArrayCHeap<int, mtClassShared>* ArchiveHeapWriter::_source_objs_order;\n@@ -75,0 +76,1 @@\n+static int _num_native_ptrs = 0;\n@@ -87,0 +89,1 @@\n+    _source_objs_order = new GrowableArrayCHeap<int, mtClassShared>(10000);\n@@ -94,0 +97,1 @@\n+  _source_objs_order->append(_source_objs->length());\n@@ -229,0 +233,43 @@\n+static int oop_sorting_rank(oop o) {\n+  bool has_o_ptr = HeapShared::has_oop_pointers(o);\n+  bool has_n_ptr = HeapShared::has_native_pointers(o);\n+\n+  if (!has_o_ptr) {\n+    if (!has_n_ptr) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  } else {\n+    if (has_n_ptr) {\n+      return 2;\n+    } else {\n+      return 3;\n+    }\n+  }\n+}\n+\n+\/\/ The goal is to sort the objects in increasing order of:\n+\/\/ - objects that have no pointers\n+\/\/ - objects that have only native pointers\n+\/\/ - objects that have both native and oop pointers\n+\/\/ - objects that have only oop pointers\n+int ArchiveHeapWriter::compare_objs_by_oop_fields(int* a, int* b) {\n+  oop oa = _source_objs->at(*a);\n+  oop ob = _source_objs->at(*b);\n+\n+  int rank_a = oop_sorting_rank(oa);\n+  int rank_b = oop_sorting_rank(ob);\n+\n+  if (rank_a != rank_b) {\n+    return rank_a - rank_b;\n+  } else {\n+    \/\/ If they are the same rank, sort them by their position in the _source_objs array\n+    return *a - *b;\n+  }\n+}\n+\n+void ArchiveHeapWriter::sort_source_objs() {\n+  _source_objs_order->sort(compare_objs_by_oop_fields);\n+}\n+\n@@ -230,2 +277,4 @@\n-  for (int i = 0; i < _source_objs->length(); i++) {\n-    oop src_obj = _source_objs->at(i);\n+  sort_source_objs();\n+  for (int i = 0; i < _source_objs_order->length(); i++) {\n+    int src_obj_index = _source_objs_order->at(i);\n+    oop src_obj = _source_objs->at(src_obj_index);\n@@ -242,2 +291,2 @@\n-  log_info(cds)(\"Size of heap region = \" SIZE_FORMAT \" bytes, %d objects, %d roots\",\n-                _buffer_used, _source_objs->length() + 1, roots->length());\n+  log_info(cds)(\"Size of heap region = \" SIZE_FORMAT \" bytes, %d objects, %d roots, %d native ptrs\",\n+                _buffer_used, _source_objs->length() + 1, roots->length(), _num_native_ptrs);\n@@ -515,0 +564,11 @@\n+static void log_bitmap_usage(const char* which, BitMap* bitmap, size_t total_bits) {\n+  \/\/ The whole heap is covered by total_bits, but there are only non-zero bits within [start ... end).\n+  size_t start = bitmap->find_first_set_bit(0);\n+  size_t end = bitmap->size();\n+  log_info(cds)(\"%s = \" SIZE_FORMAT_W(7) \" ... \" SIZE_FORMAT_W(7) \" (%3zu%% ... %3zu%% = %3zu%%)\", which,\n+                start, end,\n+                start * 100 \/ total_bits,\n+                end * 100 \/ total_bits,\n+                (end - start) * 100 \/ total_bits);\n+}\n+\n@@ -522,2 +582,6 @@\n-  auto iterator = [&] (oop src_obj, HeapShared::CachedOopInfo& info) {\n-    oop requested_obj = requested_obj_from_buffer_offset(info.buffer_offset());\n+  for (int i = 0; i < _source_objs_order->length(); i++) {\n+    int src_obj_index = _source_objs_order->at(i);\n+    oop src_obj = _source_objs->at(src_obj_index);\n+    HeapShared::CachedOopInfo* info = HeapShared::archived_object_cache()->get(src_obj);\n+    assert(info != nullptr, \"must be\");\n+    oop requested_obj = requested_obj_from_buffer_offset(info->buffer_offset());\n@@ -525,1 +589,1 @@\n-    address buffered_obj = offset_to_buffered_address<address>(info.buffer_offset());\n+    address buffered_obj = offset_to_buffered_address<address>(info->buffer_offset());\n@@ -529,1 +593,0 @@\n-  HeapShared::archived_object_cache()->iterate_all(iterator);\n@@ -545,0 +608,4 @@\n+\n+  size_t total_bytes = (size_t)_buffer->length();\n+  log_bitmap_usage(\"oopmap\", heap_info->oopmap(), total_bytes \/ (UseCompressedOops ? sizeof(narrowOop) : sizeof(oop)));\n+  log_bitmap_usage(\"ptrmap\", heap_info->ptrmap(), total_bytes \/ sizeof(address));\n@@ -554,0 +621,2 @@\n+    HeapShared::set_has_native_pointers(src_obj);\n+    _num_native_ptrs ++;\n@@ -568,0 +637,6 @@\n+  \/\/ Leading zeros have been removed so some addresses may not be in the ptrmap\n+  if (idx < MetaspaceShared::ptrmap_leading_zeros()) {\n+    return false;\n+  } else {\n+    idx -= MetaspaceShared::ptrmap_leading_zeros();\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":83,"deletions":8,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+  static GrowableArrayCHeap<int, mtClassShared>* _source_objs_order;\n@@ -213,0 +214,4 @@\n+\n+  static int compare_objs_by_oop_fields(int* a, int* b);\n+  static void sort_source_objs();\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -292,0 +292,2 @@\n+  st->print_cr(\"- heap_oopmap_leading_zeros:      \" SIZE_FORMAT, _heap_oopmap_leading_zeros);\n+  st->print_cr(\"- heap_ptrmap_leading_zeros:      \" SIZE_FORMAT, _heap_ptrmap_leading_zeros);\n@@ -1573,0 +1575,29 @@\n+    \/\/ Remove leading zeros\n+    size_t old_oop_zeros = heap_info->oopmap()->find_first_set_bit(0);\n+    size_t old_ptr_zeros = heap_info->ptrmap()->find_first_set_bit(0);\n+\n+    size_t old_oop_size = heap_info->oopmap()->size_in_bytes();\n+    size_t old_ptr_size = heap_info->ptrmap()->size_in_bytes();\n+\n+    \/\/ Slice and resize bitmaps\n+    heap_info->oopmap()->slice(old_oop_zeros);\n+    heap_info->ptrmap()->slice(old_ptr_zeros);\n+\n+    \/\/ Bitmap is word aligned so some leading zeros will be left over\n+    \/\/ We want to keep track of how many zeros were removed\n+    size_t new_oop_zeros = heap_info->oopmap()->find_first_set_bit(0);\n+    size_t new_ptr_zeros = heap_info->ptrmap()->find_first_set_bit(0);\n+\n+    size_t removed_oop_zeros = old_oop_zeros - new_oop_zeros;\n+    size_t removed_ptr_zeros = old_ptr_zeros - new_ptr_zeros;\n+\n+    header()->set_heap_oopmap_leading_zeros(removed_oop_zeros);\n+    header()->set_heap_ptrmap_leading_zeros(removed_ptr_zeros);\n+    MetaspaceShared::set_heap_oopmap_leading_zeros(removed_oop_zeros);\n+    MetaspaceShared::set_heap_ptrmap_leading_zeros(removed_ptr_zeros);\n+\n+    assert(new_oop_zeros <= old_oop_zeros, \"Should have removed leading zeros\");\n+    assert(new_ptr_zeros <= old_ptr_zeros, \"Should have removed leading zeros\");\n+    assert(heap_info->oopmap()->size_in_bytes() <= old_oop_size, \"Heap oopmap size should have decreased\");\n+    assert(heap_info->ptrmap()->size_in_bytes() <= old_ptr_size, \"Heap ptrmap size should have decreased\");\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -231,0 +231,2 @@\n+  size_t _heap_oopmap_leading_zeros;    \/\/ The number of leading zero bits in the heap oopmap.\n+  size_t _heap_ptrmap_leading_zeros;    \/\/ The number of leading zero bits in the heap ptrmap.\n@@ -272,0 +274,2 @@\n+  size_t heap_oopmap_leading_zeros()       const { return _heap_oopmap_leading_zeros;}\n+  size_t heap_ptrmap_leading_zeros()       const { return _heap_ptrmap_leading_zeros;}\n@@ -284,0 +288,2 @@\n+  void set_heap_oopmap_leading_zeros(size_t n)   { _heap_oopmap_leading_zeros = n; }\n+  void set_heap_ptrmap_leading_zeros(size_t n)   { _heap_ptrmap_leading_zeros = n; }\n@@ -381,0 +387,2 @@\n+  size_t  heap_oopmap_leading_zeros() const { return header()->heap_oopmap_leading_zeros(); }\n+  size_t  heap_ptrmap_leading_zeros() const { return header()->heap_ptrmap_leading_zeros(); }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-    CachedOopInfo info = make_cached_oop_info();\n+    CachedOopInfo info = make_cached_oop_info(obj);\n@@ -440,0 +440,18 @@\n+bool HeapShared::has_oop_pointers(oop src_obj) {\n+  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n+  assert(info != nullptr, \"must be\");\n+  return info->has_oop_pointers();\n+}\n+\n+bool HeapShared::has_native_pointers(oop src_obj) {\n+  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n+  assert(info != nullptr, \"must be\");\n+  return info->has_native_pointers();\n+}\n+\n+void HeapShared::set_has_native_pointers(oop src_obj) {\n+  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n+  assert(info != nullptr, \"must be\");\n+  info->set_has_native_pointers();\n+}\n+\n@@ -1141,1 +1159,15 @@\n-HeapShared::CachedOopInfo HeapShared::make_cached_oop_info() {\n+class PointsToOopsChecker : public BasicOopIterateClosure {\n+  bool _result;\n+\n+  template <class T> void check(T *p) {\n+    _result |= (HeapAccess<>::oop_load(p) != nullptr);\n+  }\n+\n+public:\n+  PointsToOopsChecker() : _result(false) {}\n+  void do_oop(narrowOop *p) { check(p); }\n+  void do_oop(      oop *p) { check(p); }\n+  bool result() { return _result; }\n+};\n+\n+HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop obj) {\n@@ -1144,1 +1176,3 @@\n-  return CachedOopInfo(referrer);\n+  PointsToOopsChecker points_to_oops_checker;\n+  obj->oop_iterate(&points_to_oops_checker);\n+  return CachedOopInfo(referrer, points_to_oops_checker.result());\n@@ -1442,0 +1476,1 @@\n+    const char* test_class_name = ArchiveHeapTestClass;\n@@ -1444,0 +1479,1 @@\n+    const char* test_class_name = \"\"; \/\/ avoid C++ printf checks warnings.\n@@ -1447,1 +1483,1 @@\n-      log_warning(cds)(\"Loading ArchiveHeapTestClass %s ...\", ArchiveHeapTestClass);\n+      log_warning(cds)(\"Loading ArchiveHeapTestClass %s ...\", test_class_name);\n@@ -1473,1 +1509,1 @@\n-        st.print(\"ArchiveHeapTestClass %s is not in unnamed module\", ArchiveHeapTestClass);\n+        st.print(\"ArchiveHeapTestClass %s is not in unnamed module\", test_class_name);\n@@ -1480,1 +1516,1 @@\n-        st.print(\"ArchiveHeapTestClass %s is not in unnamed package\", ArchiveHeapTestClass);\n+        st.print(\"ArchiveHeapTestClass %s is not in unnamed package\", test_class_name);\n@@ -1495,1 +1531,1 @@\n-      log_warning(cds)(\"Initializing ArchiveHeapTestClass %s ...\", ArchiveHeapTestClass);\n+      log_warning(cds)(\"Initializing ArchiveHeapTestClass %s ...\", test_class_name);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":43,"deletions":7,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-    \/\/ See \"TEMP notes: What are these?\" in archiveHeapWriter.hpp\n+    \/\/ Used by CDSHeapVerifier.\n@@ -194,0 +194,6 @@\n+\n+    \/\/ One or more fields in this object are pointing to non-null oops.\n+    bool _has_oop_pointers;\n+\n+    \/\/ One or more fields in this object are pointing to MetaspaceObj\n+    bool _has_native_pointers;\n@@ -195,1 +201,1 @@\n-    CachedOopInfo(oop orig_referrer)\n+    CachedOopInfo(oop orig_referrer, bool has_oop_pointers)\n@@ -197,1 +203,3 @@\n-        _buffer_offset(0) {}\n+        _buffer_offset(0),\n+        _has_oop_pointers(has_oop_pointers),\n+        _has_native_pointers(false) {}\n@@ -201,0 +209,3 @@\n+    bool has_oop_pointers()         const { return _has_oop_pointers; }\n+    bool has_native_pointers()      const { return _has_native_pointers; }\n+    void set_has_native_pointers()        { _has_native_pointers = true; }\n@@ -240,1 +251,1 @@\n-  static CachedOopInfo make_cached_oop_info();\n+  static CachedOopInfo make_cached_oop_info(oop obj);\n@@ -371,0 +382,3 @@\n+  static bool has_oop_pointers(oop obj);\n+  static bool has_native_pointers(oop obj);\n+  static void set_has_native_pointers(oop obj);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+size_t MetaspaceShared::_ptrmap_leading_zeros = 0;\n+size_t MetaspaceShared::_oopmap_leading_zeros = 0;\n@@ -930,0 +932,4 @@\n+    \/\/ Leading zeros are needed to get correct offsets\n+    _oopmap_leading_zeros = static_mapinfo->header()->heap_oopmap_leading_zeros();\n+    _ptrmap_leading_zeros = static_mapinfo->header()->heap_ptrmap_leading_zeros();\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  static size_t _ptrmap_leading_zeros;\n+  static size_t _oopmap_leading_zeros;\n@@ -166,0 +168,7 @@\n+  \/\/ Leading zeros are removed from heap bitmaps\n+  static size_t oopmap_leading_zeros() { return _oopmap_leading_zeros; }\n+  static size_t ptrmap_leading_zeros() { return _ptrmap_leading_zeros; }\n+\n+  static void set_heap_oopmap_leading_zeros(size_t leading_zeros) { _oopmap_leading_zeros = leading_zeros; }\n+  static void set_heap_ptrmap_leading_zeros(size_t leading_zeros) { _ptrmap_leading_zeros = leading_zeros; }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -102,0 +102,23 @@\n+template <class BitMapWithAllocator>\n+void GrowableBitMap<BitMapWithAllocator>::slice(idx_t start_bit, idx_t end_bit, bool clear) {\n+  assert(start_bit < end_bit, \"End bit must come after start bit\");\n+  assert(end_bit <= size(), \"End bit not in bitmap\");\n+  idx_t start_word = to_words_align_down(start_bit);\n+  idx_t end_word = to_words_align_up(end_bit);\n+  bm_word_t* const old_map = map();\n+  const idx_t new_size_in_bits = (end_word - start_word) * BitsPerWord;\n+\n+  \/\/ Shift over elements to avoid allocating a new array\n+  for (idx_t word = start_word; word < end_word; word++) {\n+    set_word(word - start_word, old_map[word]);\n+    assert(old_map[word-start_word] == old_map[word], \"sanity\");\n+  }\n+\n+  resize(new_size_in_bits, clear);\n+}\n+\n+template <class BitMapWithAllocator>\n+void GrowableBitMap<BitMapWithAllocator>::slice(idx_t start_bit, bool clear) {\n+  slice(start_bit, size(), clear);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -588,0 +588,4 @@\n+  \/\/ Slice bitmap\n+  \/\/ Old bits are shifted to the front and then the map is resized\n+  void slice(idx_t start_bit, idx_t end_bit, bool clear = true);\n+  void slice(idx_t start_bit, bool clear = true);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}