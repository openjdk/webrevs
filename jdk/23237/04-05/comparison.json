{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,1 @@\n-            compiler.keepEndPos = true;\n+            compiler.genEndPos = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.tree.TreeInfo;\n@@ -161,1 +162,1 @@\n-            new LexicalDeferralMapper(tree).mapLexicalDeferrals();\n+            new LexicalDeferralMapper().mapLexicalDeferrals(tree);\n@@ -291,2 +292,0 @@\n-        private final JCCompilationUnit tree;\n-\n@@ -296,5 +295,1 @@\n-        LexicalDeferralMapper(JCCompilationUnit tree) {\n-            this.tree = tree;\n-        }\n-\n-        void mapLexicalDeferrals() {\n+        void mapLexicalDeferrals(JCCompilationUnit tree) {\n@@ -326,2 +321,2 @@\n-        public void visitModuleDef(JCModuleDecl tree) {\n-            scanDecl(tree, super::visitModuleDef);\n+        public void visitModuleDef(JCModuleDecl decl) {\n+            scanDecl(decl, super::visitModuleDef);\n@@ -331,2 +326,2 @@\n-        public void visitPackageDef(JCPackageDecl tree) {\n-            scanDecl(tree, super::visitPackageDef);\n+        public void visitPackageDef(JCPackageDecl decl) {\n+            scanDecl(decl, super::visitPackageDef);\n@@ -336,2 +331,2 @@\n-        public void visitClassDef(JCClassDecl tree) {\n-            scanDecl(tree, super::visitClassDef);\n+        public void visitClassDef(JCClassDecl decl) {\n+            scanDecl(decl, super::visitClassDef);\n@@ -341,2 +336,2 @@\n-        public void visitMethodDef(JCMethodDecl tree) {\n-            scanDecl(tree, super::visitMethodDef);\n+        public void visitMethodDef(JCMethodDecl decl) {\n+            scanDecl(decl, super::visitMethodDef);\n@@ -346,2 +341,2 @@\n-        public void visitVarDef(JCVariableDecl tree) {\n-            scanDecl(tree, super::visitVarDef);\n+        public void visitVarDef(JCVariableDecl decl) {\n+            scanDecl(decl, super::visitVarDef);\n@@ -353,2 +348,2 @@\n-            int minPos = decl.getPreferredPosition();\n-            int maxPos = decl.getEndPosition(tree.endPositions);\n+            int minPos = TreeInfo.getStartPos(decl);\n+            int maxPos = TreeInfo.endPos(decl);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -185,1 +185,0 @@\n-        markUsesPreview(diagPos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-        keepEndPos    = options.isSet(XJCOV) ||\n+        genEndPos     = options.isSet(XJCOV) ||\n@@ -523,1 +523,1 @@\n-    \/** Switch: should we keep the ending positions around after parsing?\n+    \/** Switch: should we store the ending positions?\n@@ -525,1 +525,1 @@\n-    public boolean keepEndPos;\n+    public boolean genEndPos;\n@@ -660,1 +660,1 @@\n-                keepEndPos = true;\n+                genEndPos = true;\n@@ -662,1 +662,1 @@\n-            Parser parser = parserFactory.newParser(content, keepComments(), true,\n+            Parser parser = parserFactory.newParser(content, keepComments(), genEndPos,\n@@ -664,0 +664,1 @@\n+            deferredLintHandler.enterParsingMode();\n@@ -665,1 +666,0 @@\n-                deferredLintHandler.enterParsingMode();\n@@ -667,3 +667,0 @@\n-                deferredLintHandler.exitParsingMode(tree);\n-                if (!keepEndPos)\n-                    tree.endPositions = new JavacParser.EmptyEndPosTable();\n@@ -671,1 +668,1 @@\n-                deferredLintHandler.exitParsingMode(null);\n+                deferredLintHandler.exitParsingMode(tree);\n@@ -1179,1 +1176,1 @@\n-                keepEndPos = true;\n+                genEndPos = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1032,0 +1032,1 @@\n+                var.endPos = S.prevToken().endPos;\n@@ -2764,0 +2765,1 @@\n+            body.endPos = S.prevToken().endPos;\n@@ -3812,0 +3814,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -3837,0 +3840,1 @@\n+        result.endPos = endPos;\n@@ -3925,1 +3929,3 @@\n-                return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n+                JCVariableDecl result = toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n+                result.endPos = S.prevToken().endPos;\n+                return result;\n@@ -3950,1 +3956,1 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null,\n+        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, null,\n@@ -3952,0 +3958,2 @@\n+        result.endPos = S.prevToken().endPos;\n+        return result;\n@@ -4021,0 +4029,1 @@\n+            pd.endPos = S.prevToken().endPos;\n@@ -4130,1 +4139,1 @@\n-        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplicitClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ? constructImplicitClass(defs.toList(), S.prevToken().endPos) : defs.toList();\n@@ -4146,1 +4155,1 @@\n-    private List<JCTree> constructImplicitClass(List<JCTree> origDefs) {\n+    private List<JCTree> constructImplicitClass(List<JCTree> origDefs, int endPos) {\n@@ -4176,0 +4185,1 @@\n+        implicit.endPos = endPos;\n@@ -4191,0 +4201,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4194,0 +4205,1 @@\n+        result.endPos = endPos;\n@@ -4396,0 +4408,1 @@\n+        result.endPos = S.prevToken().endPos;\n@@ -4419,0 +4432,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4444,0 +4458,1 @@\n+        result.endPos = endPos;\n@@ -4484,0 +4499,1 @@\n+        result.endPos = S.prevToken().endPos;\n@@ -4532,0 +4548,1 @@\n+        result.endPos = S.prevToken().endPos;\n@@ -4670,0 +4687,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4671,1 +4689,1 @@\n-            storeEnd(create, S.prevToken().endPos);\n+            storeEnd(create, endPos);\n@@ -4673,1 +4691,2 @@\n-        JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));\n+        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, ident, create));\n+        result.endPos = endPos;\n@@ -5103,0 +5122,1 @@\n+            result.endPos = S.prevToken().endPos;\n@@ -5660,5 +5680,1 @@\n-    public static class EmptyEndPosTable extends AbstractEndPosTable {\n-\n-        public EmptyEndPosTable() {\n-            this(null);\n-        }\n+    protected static class EmptyEndPosTable extends AbstractEndPosTable {\n@@ -5666,1 +5682,1 @@\n-        public EmptyEndPosTable(JavacParser parser) {\n+        EmptyEndPosTable(JavacParser parser) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -644,0 +644,2 @@\n+        \/** Position of closing semicolon, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -840,0 +842,2 @@\n+        \/** position of closing brace, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -934,0 +938,2 @@\n+        \/** position of closing brace or semicolon, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -1019,0 +1025,2 @@\n+        \/** position of closing semicolon, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -3129,0 +3137,2 @@\n+        \/** position of closing brace, optional. *\/\n+        public int endPos = Position.NOPOS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,2 +503,1 @@\n-    \/** The end position of given tree, if it is a block with\n-     *  defined endpos.\n+    \/** The end position of the given tree, if defined.\n@@ -507,3 +506,6 @@\n-        if (tree.hasTag(BLOCK) && ((JCBlock) tree).endpos != Position.NOPOS)\n-            return ((JCBlock) tree).endpos;\n-        else if (tree.hasTag(SYNCHRONIZED))\n+        int endPos;\n+        switch (tree.getTag()) {\n+        case BLOCK:\n+            endPos = ((JCBlock) tree).endpos;\n+            break;\n+        case SYNCHRONIZED:\n@@ -511,1 +513,1 @@\n-        else if (tree.hasTag(TRY)) {\n+        case TRY:\n@@ -515,7 +517,22 @@\n-        } else if (tree.hasTag(SWITCH) &&\n-                   ((JCSwitch) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitch) tree).endpos;\n-        } else if (tree.hasTag(SWITCH_EXPRESSION) &&\n-                   ((JCSwitchExpression) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitchExpression) tree).endpos;\n-        } else\n+        case SWITCH:\n+            endPos = ((JCSwitch) tree).endpos;\n+            break;\n+        case SWITCH_EXPRESSION:\n+            endPos = ((JCSwitchExpression) tree).endpos;\n+            break;\n+        case MODULEDEF:\n+            endPos = ((JCModuleDecl) tree).endPos;\n+            break;\n+        case PACKAGEDEF:\n+            endPos = ((JCPackageDecl) tree).endPos;\n+            break;\n+        case CLASSDEF:\n+            endPos = ((JCClassDecl) tree).endPos;\n+            break;\n+        case METHODDEF:\n+            endPos = ((JCMethodDecl) tree).endPos;\n+            break;\n+        case VARDEF:\n+            endPos = ((JCVariableDecl) tree).endPos;\n+            break;\n+        default:\n@@ -523,0 +540,4 @@\n+        }\n+        if (endPos != Position.NOPOS)\n+            return endPos;\n+        return tree.pos;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n-- compiler.note.preview.filename: ImplicitClassRecovery.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ImplicitClassRecovery.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassBad-Filename.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassHasPackage.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}