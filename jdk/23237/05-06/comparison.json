{"files":[{"patch":"@@ -293,1 +293,1 @@\n-        private int currentDeferral;\n+        private int nextDeferral;\n@@ -303,1 +303,1 @@\n-            currentDeferral = 0;\n+            nextDeferral = 0;\n@@ -351,2 +351,3 @@\n-            \/\/ Skip forward through lexical deferrals until we hit this declaration\n-            while (true) {\n+            \/\/ Find those lexical deferrals that overlap this declaration and map them\n+            int numMatches = 0;\n+            while (nextDeferral + numMatches < parsingDeferrals.size()) {\n@@ -354,4 +355,3 @@\n-                \/\/ We can stop scanning once we pass the last lexical deferral\n-                if (currentDeferral >= parsingDeferrals.size()) {\n-                    throw new ShortCircuitException();\n-                }\n+                \/\/ Where is this declaration relative to the next lexical deferral?\n+                Deferral deferral = parsingDeferrals.get(nextDeferral + numMatches);\n+                int relativePosition = deferral.compareToRange(minPos, maxPos);\n@@ -359,2 +359,6 @@\n-                \/\/ Get the deferral currently under consideration\n-                Deferral deferral = parsingDeferrals.get(currentDeferral);\n+                \/\/ If it's before it, then this declaration overlaps nothing in the list. This only\n+                \/\/ happens with the initial declarations; after that, declarations always stay ahead.\n+                \/\/ Keep recursing forward through the source code.\n+                if (relativePosition > 0) {\n+                    break;\n+                }\n@@ -362,2 +366,1 @@\n-                \/\/ Is its position prior to this declaration?\n-                int relativePosition = deferral.compareToRange(minPos, maxPos);\n+                \/\/ If it's after it, advance through the deferral list until we catch up with it\n@@ -365,1 +368,2 @@\n-                    currentDeferral++;      \/\/ already past it\n+                    Assert.check(numMatches == 0);\n+                    nextDeferral++;\n@@ -369,4 +373,7 @@\n-                \/\/ Is its position after this declaration?\n-                if (relativePosition > 0) {\n-                    break;                  \/\/ stop for now; a subsequent declaration might match\n-                }\n+                \/\/ The deferral is contained within this declaration, so map it to the declaration,\n+                \/\/ and continue doing so for all immediately following deferrals that also match.\n+                \/\/ Note, this declaration may not be the innermost containing declaration; if not,\n+                \/\/ the narrower declaration(s) that follow will overwrite and correct the mapping.\n+                declMap[nextDeferral + numMatches] = decl;\n+                numMatches++;\n+            }\n@@ -374,5 +381,3 @@\n-                \/\/ Deferral's position is within this declaration - we should map it.\n-                \/\/ Note this declaration may not be the innermost containing declaration,\n-                \/\/ but if not, that's OK: the narrower declaration will follow and overwrite.\n-                declMap[currentDeferral] = decl;\n-                break;\n+            \/\/ Have we mapped all of the lexical deferrals? If so don't bother going any further.\n+            if (nextDeferral >= parsingDeferrals.size()) {\n+                throw new ShortCircuitException();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-        previewHandler = new MandatoryWarningHandler(log, source, verbose, true);\n+        previewHandler = new MandatoryWarningHandler(log, source, true);\n@@ -199,4 +199,0 @@\n-\n-        \/\/ For preview warnings, even if a warning is suppressed by of @SuppressWarnings(\"preview\"), we\n-        \/\/ still need the \"recompile\" note at the end of compilation. To ensure that happens, we invoke\n-        \/\/ previewHandler.report() in all cases, but with \"verbose\" set to false if \"preview\" is suppressed.\n@@ -232,1 +228,1 @@\n-        previewHandler.report(pos, warnKey);\n+        previewHandler.report(pos, warnKey, verbose);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -165,3 +165,0 @@\n-        boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);\n-        boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);\n-        boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);\n@@ -170,3 +167,3 @@\n-        deprecationHandler = new MandatoryWarningHandler(log, null, verboseDeprecated, enforceMandatoryWarnings, \"deprecated\");\n-        removalHandler = new MandatoryWarningHandler(log, null, verboseRemoval, enforceMandatoryWarnings);\n-        uncheckedHandler = new MandatoryWarningHandler(log, null, verboseUnchecked, enforceMandatoryWarnings);\n+        deprecationHandler = new MandatoryWarningHandler(log, null, enforceMandatoryWarnings, \"deprecated\");\n+        removalHandler = new MandatoryWarningHandler(log, null, enforceMandatoryWarnings);\n+        uncheckedHandler = new MandatoryWarningHandler(log, null, enforceMandatoryWarnings);\n@@ -241,0 +238,1 @@\n+                boolean verbose = lint.isEnabled(LintCategory.REMOVAL);\n@@ -242,1 +240,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n+                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym), verbose);\n@@ -244,1 +242,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n+                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()), verbose);\n@@ -248,0 +246,1 @@\n+            boolean verbose = lint.isEnabled(LintCategory.DEPRECATION);\n@@ -249,1 +248,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym));\n+                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym), verbose);\n@@ -251,1 +250,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()), verbose);\n@@ -288,1 +287,1 @@\n-            uncheckedHandler.report(pos, warnKey);\n+            uncheckedHandler.report(pos, warnKey, lint.isEnabled(LintCategory.UNCHECKED));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -116,3 +116,0 @@\n-    \/** A map associating \"other nearby documentation comments\"\n-     *  with the preferred documentation comment for a declaration. *\/\n-    protected Map<Comment, List<Comment>> danglingComments = new HashMap<>();\n@@ -585,11 +582,2 @@\n-     *     declaration) any other \"recent\" comments are saved\n-     *     in a map using the primary comment as a key,\n-     *     using this method, {@code saveDanglingComments}.\n-     *  4. When the tree node for the declaration is finally\n-     *     available, and the primary comment, if any,\n-     *     is \"attached\", (in {@link #attach}) any related\n-     *     dangling comments are also attached to the tree node\n-     *     by registering them using the {@link #deferredLintHandler}.\n-     *  5. (Later) Warnings may be generated for the dangling\n-     *     comments, subject to the {@code -Xlint} and\n-     *     {@code @SuppressWarnings}.\n+     *     declaration) any other \"recent\" comments are\n+     *     reported to the {@link #deferredLintHandler}.\n@@ -615,1 +603,0 @@\n-        var lb = new ListBuffer<Comment>();\n@@ -619,1 +606,1 @@\n-                lb.add(c);\n+                reportDanglingDocComment(c);\n@@ -622,1 +609,0 @@\n-        danglingComments.put(dc, lb.toList());\n@@ -627,3 +613,0 @@\n-     *  If there are any related \"dangling comments\", register\n-     *  diagnostics to be handled later, when @SuppressWarnings\n-     *  can be taken into account.\n@@ -638,20 +621,0 @@\n-        reportDanglingComments(tree, dc);\n-    }\n-\n-    \/** Reports all dangling comments associated with the\n-     *  primary comment for a declaration against the position\n-     *  of the tree node for a declaration.\n-     *\n-     * @param tree the tree node for the declaration\n-     * @param dc the primary comment for the declaration\n-     *\/\n-    void reportDanglingComments(JCTree tree, Comment dc) {\n-        var list = danglingComments.remove(dc);\n-        if (list != null) {\n-            deferredLintHandler.push(tree);\n-            try {\n-                list.forEach(this::reportDanglingDocComment);\n-            } finally {\n-                deferredLintHandler.pop();\n-            }\n-        }\n@@ -670,7 +633,10 @@\n-            deferredLintHandler.report(lint -> {\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n-                        !shebang(c, pos)) {\n-                    log.warning(\n-                            pos, LintWarnings.DanglingDocComment);\n-                }\n-            });\n+            deferredLintHandler.push(pos.getPreferredPosition());\n+            try {\n+                deferredLintHandler.report(lint -> {\n+                    if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) && !shebang(c, pos)) {\n+                        log.warning(pos, LintWarnings.DanglingDocComment);\n+                    }\n+                });\n+            } finally {\n+                deferredLintHandler.pop();\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":13,"deletions":47,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -112,4 +112,0 @@\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n@@ -119,2 +115,2 @@\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory) {\n-        this(log, source, verbose, enforceMandatory, null);\n+    public MandatoryWarningHandler(Log log, Source source, boolean enforceMandatory) {\n+        this(log, source, enforceMandatory, null);\n@@ -128,4 +124,0 @@\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n@@ -137,1 +129,1 @@\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, String prefix) {\n+    public MandatoryWarningHandler(Log log, Source source, boolean enforceMandatory, String prefix) {\n@@ -140,1 +132,0 @@\n-        this.verbose = verbose;\n@@ -146,1 +137,1 @@\n-     * Report a mandatory warning using the default \"verbose\" setting.\n+     * Report a mandatory warning.\n@@ -150,12 +141,1 @@\n-     *\/\n-    public void report(DiagnosticPosition pos, LintWarning warnKey) {\n-        report(pos, warnKey, verbose);\n-    }\n-\n-    \/**\n-     * Report a mandatory warning using the provided \"verbose\" setting.\n-     *\n-     * @param pos source code position\n-     * @param warnKey lint warning\n-     * @param verbose true to emit a distinct warning, false to trigger\n-     *                an aggregate message at the end of compilation\n+     * @param verbose true to emit a distinct warning, false just to register a deferred message\n@@ -241,6 +221,0 @@\n-    \/**\n-     * Whether or not to report individual warnings, or simply to report a\n-     * single aggregate warning at the end of the compilation.\n-     *\/\n-    private final boolean verbose;\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"}]}