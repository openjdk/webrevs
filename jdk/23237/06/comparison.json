{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n@@ -29,1 +32,2 @@\n-import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n@@ -31,1 +35,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -33,0 +36,3 @@\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -35,2 +41,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.ListBuffer;\n@@ -39,0 +43,20 @@\n+ * Holds pending {@link Lint} warnings until the {@lint Lint} instance associated with the containing\n+ * module, package, class, method, or variable declaration is known so that {@link @SupressWarnings}\n+ * suppressions may be applied.\n+ *\n+ * <p>\n+ * Warnings are regsistered at any time prior to attribution via {@link #report}. The warning will be\n+ * associated with the file position (if parsing) or declaration (after parsing) placed in context by\n+ * the most recent invocation of {@link #push push()} not yet {@link #pop}'d. Warnings are actually\n+ * emitted later, during attribution, via {@link #flush}.\n+ *\n+ * <p>\n+ * There is also an \"immediate\" mode, where warnings are emitted synchronously; see {@link #pushImmediate}.\n+ *\n+ * <p>\n+ * Deferred warnings are grouped by the innermost containing module, package, class, method, or variable\n+ * declaration (represented by {@link JCTree} nodes), so that the corresponding {@link Lint} configuration\n+ * can be applied when the warning is eventually generated. During parsing, no {@link JCTree} nodes exist\n+ * yet, so warnings are stored by file character offset. Once parsing completes, these offsets are resolved\n+ * to the innermost containing declaration. This class therefore operates in two distinct modes: parsing mode\n+ * and non-parsing mode. Warnings are emitted when the correpsonding declaration is {@link #flush}ed.\n@@ -46,0 +70,1 @@\n+\n@@ -55,3 +80,32 @@\n-    \/** The Lint to use when {@link #immediate(Lint)} is used,\n-     * instead of {@link #setPos(DiagnosticPosition)}. *\/\n-    private Lint immediateLint;\n+    \/**\n+     * The root lint instance.\n+     *\/\n+    private final Lint rootLint;\n+\n+    \/**\n+     * Are we in parsing mode or non-parsing mode?\n+     *\/\n+    private boolean parsingMode;\n+\n+    \/**\n+     * Registered lexical {@link Deferral}s for the source file currently being parsed.\n+     *\n+     * <p>\n+     * This list is only used when parsing a source file. Once parsing ends, these deferrals\n+     * are resolved to their corresponding declarations and moved to {@link #deferralMap}.\n+     *\/\n+    private ArrayList<Deferral> parsingDeferrals = new ArrayList<>();\n+\n+    \/**\n+     * Registered {@link Deferral}s grouped by the innermost containing module, package, class,\n+     * method, or variable declaration.\n+     *\/\n+    private final HashMap<JCTree, ArrayList<Deferral>> deferralMap = new HashMap<>();\n+\n+    \/**\n+     * The current \"reporter\" stack, reflecting calls to {@link #push} and {@link #pop}.\n+     *\n+     * <p>\n+     * The top of the stack determines how calls to {@link #report} are handled.\n+     *\/\n+    private final ArrayDeque<Consumer<LintLogger>> reporterStack = new ArrayDeque<>();\n@@ -62,2 +116,2 @@\n-        this.currentPos = IMMEDIATE_POSITION;\n-        immediateLint = Lint.instance(context);\n+        rootLint = Lint.instance(context);\n+        pushImmediate(rootLint);            \/\/ default to \"immediate\" mode\n@@ -66,3 +120,4 @@\n-    \/**An interface for deferred lint reporting - loggers passed to\n-     * {@link #report(LintLogger) } will be called when\n-     * {@link #flush(DiagnosticPosition) } is invoked.\n+\/\/ LintLogger\n+\n+    \/**\n+     * Callback interface for deferred lint reporting.\n@@ -71,0 +126,6 @@\n+\n+        \/**\n+         * Generate a warning if appropriate.\n+         *\n+         * @param lint the applicable lint configuration\n+         *\/\n@@ -74,2 +135,1 @@\n-    private DiagnosticPosition currentPos;\n-    private Map<DiagnosticPosition, ListBuffer<LintLogger>> loggersQueue = new HashMap<>();\n+\/\/ Mode Switching\n@@ -77,5 +137,2 @@\n-    \/**Associate the given logger with the current position as set by {@link #setPos(DiagnosticPosition) }.\n-     * Will be invoked when {@link #flush(DiagnosticPosition) } will be invoked with the same position.\n-     * <br>\n-     * Will invoke the logger synchronously if {@link #immediate() } was called\n-     * instead of {@link #setPos(DiagnosticPosition) }.\n+    \/**\n+     * Enter parsing mode.\n@@ -83,10 +140,4 @@\n-    public void report(LintLogger logger) {\n-        if (currentPos == IMMEDIATE_POSITION) {\n-            logger.report(immediateLint);\n-        } else {\n-            ListBuffer<LintLogger> loggers = loggersQueue.get(currentPos);\n-            if (loggers == null) {\n-                loggersQueue.put(currentPos, loggers = new ListBuffer<>());\n-            }\n-            loggers.append(logger);\n-        }\n+    public void enterParsingMode() {\n+        Assert.check(!parsingMode);\n+        Assert.check(parsingDeferrals.isEmpty());\n+        parsingMode = true;\n@@ -95,1 +146,9 @@\n-    \/**Invoke all {@link LintLogger}s that were associated with the provided {@code pos}.\n+    \/**\n+     * Exit parsing mode and resolve each of the lexical {@link Deferral}s accumulated during parsing\n+     * to the innermost containing declaration in the given tree.\n+     *\n+     * <p>\n+     * Any lexical {@link Deferral}s that are not encompassed by a declaration are emitted using\n+     * the root {@link Lint} instance.\n+     *\n+     * @param tree top level node, or null to clean up after parsing failed\n@@ -97,7 +156,13 @@\n-    public void flush(DiagnosticPosition pos, Lint lint) {\n-        ListBuffer<LintLogger> loggers = loggersQueue.get(pos);\n-        if (loggers != null) {\n-            for (LintLogger lintLogger : loggers) {\n-                lintLogger.report(lint);\n-            }\n-            loggersQueue.remove(pos);\n+    public void exitParsingMode(JCCompilationUnit tree) {\n+        Assert.check(parsingMode || tree == null);\n+        parsingMode = false;\n+        if (tree != null && !parsingDeferrals.isEmpty()) {\n+\n+            \/\/ Map lexical Deferral's to corresponding declarations\n+            new LexicalDeferralMapper().mapLexicalDeferrals(tree);\n+\n+            \/\/ Report any remainders immediately (must be outside the top level declaration)\n+            Optional.ofNullable(deferralMap.remove(null))\n+              .stream()\n+              .flatMap(ArrayList::stream)\n+              .forEach(deferral -> deferral.logger().report(rootLint));\n@@ -105,0 +170,18 @@\n+        parsingDeferrals.clear();\n+    }\n+\n+\/\/ Reporter Stack\n+\n+    \/**\n+     * Defer {@link #report}ed warnings until the declaration encompassing the given\n+     * source file position is flushed.\n+     *\n+     * <p>\n+     * This should only be invoked when in parsing mode.\n+     *\n+     * @param pos character offset\n+     * @see #pop\n+     *\/\n+    public void push(int pos) {\n+        Assert.check(parsingMode);\n+        reporterStack.push(logger -> parsingDeferrals.add(new Deferral(logger, pos)));\n@@ -107,3 +190,9 @@\n-    \/**Sets the current position to the provided {@code currentPos}. {@link LintLogger}s\n-     * passed to subsequent invocations of {@link #report(LintLogger) } will be associated\n-     * with the given position.\n+    \/**\n+     * Defer {@link #report}ed warnings until the given declaration is flushed.\n+     *\n+     * <p>\n+     * This is normally only invoked when in non-parsing mode, but it can also be invoked in\n+     * parsing mode if the declaration is known (e.g., see \"dangling-doc-comments\" handling).\n+     *\n+     * @param decl module, package, class, method, or variable declaration\n+     * @see #pop\n@@ -111,4 +200,9 @@\n-    public DiagnosticPosition setPos(DiagnosticPosition currentPos) {\n-        DiagnosticPosition prevPosition = this.currentPos;\n-        this.currentPos = currentPos;\n-        return prevPosition;\n+    public void push(JCTree decl) {\n+        Assert.check(decl.getTag() == Tag.MODULEDEF\n+                  || decl.getTag() == Tag.PACKAGEDEF\n+                  || decl.getTag() == Tag.CLASSDEF\n+                  || decl.getTag() == Tag.METHODDEF\n+                  || decl.getTag() == Tag.VARDEF);\n+        reporterStack.push(logger -> deferralMap\n+                                        .computeIfAbsent(decl, s -> new ArrayList<>())\n+                                        .add(new Deferral(logger)));\n@@ -117,2 +211,4 @@\n-    \/**{@link LintLogger}s passed to subsequent invocations of\n-     * {@link #report(LintLogger) } will be invoked immediately.\n+    \/**\n+     * Enter \"immediate\" mode so that {@link #report}ed warnings are emitted synchonously.\n+     *\n+     * @param lint lint configuration to use for reported warnings\n@@ -120,3 +216,2 @@\n-    public DiagnosticPosition immediate(Lint lint) {\n-        immediateLint = lint;\n-        return setPos(IMMEDIATE_POSITION);\n+    public void pushImmediate(Lint lint) {\n+        reporterStack.push(logger -> logger.report(lint));\n@@ -125,1 +220,100 @@\n-    private static final DiagnosticPosition IMMEDIATE_POSITION = new DiagnosticPosition() {\n+    \/**\n+     * Revert to the previous configuration in effect prior to the most recent invocation\n+     * of {@link #push} or {@link #pushImmediate}.\n+     *\n+     * @see #pop\n+     *\/\n+    public void pop() {\n+        Assert.check(reporterStack.size() > 1);     \/\/ the bottom stack entry should never be popped\n+        reporterStack.pop();\n+    }\n+\n+    \/**\n+     * Report a warning.\n+     *\n+     * <p>\n+     * In immediate mode, the warning is emitted synchronously. Otherwise, the warning is emitted later\n+     * when the current declaration is flushed.\n+     *\/\n+    public void report(LintLogger logger) {\n+        Assert.check(!reporterStack.isEmpty());\n+        reporterStack.peek().accept(logger);\n+    }\n+\n+\/\/ Warning Flush\n+\n+    \/**\n+     * Emit deferred warnings encompassed by the given declaration.\n+     *\n+     * @param decl module, package, class, method, or variable declaration\n+     * @param lint lint configuration corresponding to {@code decl}\n+     *\/\n+    public void flush(JCTree decl, Lint lint) {\n+        Assert.check(!parsingMode);\n+        Optional.of(decl)\n+          .map(deferralMap::remove)\n+          .stream()\n+          .flatMap(ArrayList::stream)\n+          .map(Deferral::logger)\n+          .forEach(logger -> logger.report(lint));\n+    }\n+\n+\/\/ Deferral\n+\n+    \/**\n+     * Represents a deferred warning.\n+     *\n+     * @param logger the logger that will report the warning\n+     * @param pos character offset in the source file (parsing mode only)\n+     *\/\n+    private record Deferral(LintLogger logger, int pos) {\n+\n+        \/\/ Create an instance in non-parsing mode\n+        Deferral(LintLogger logger) {\n+            this(logger, -1);\n+        }\n+\n+        \/\/ Compare our position to the given declaration range. Only used for lexical deferrals.\n+        int compareToRange(int minPos, int maxPos) {\n+            if (pos() < minPos)\n+                return -1;\n+            if (pos() == minPos || (pos() > minPos && pos() < maxPos))\n+                return 0;\n+            return 1;\n+        }\n+    }\n+\n+\/\/ LexicalDeferralMapper\n+\n+    \/\/ This scans a source file and identifies, for each lexical Deferral, the innermost\n+    \/\/ declaration that contains it and moves it to the corresponding entry in deferralMap.\n+    private class LexicalDeferralMapper extends TreeScanner {\n+\n+        private JCTree[] declMap;\n+        private int nextDeferral;\n+\n+        void mapLexicalDeferrals(JCCompilationUnit tree) {\n+\n+            \/\/ Sort lexical deferrals by position so our \"online\" algorithm works.\n+            \/\/ We also depend on TreeScanner visiting declarations in lexical order.\n+            parsingDeferrals.sort(Comparator.comparingInt(Deferral::pos));\n+\n+            \/\/ Initialize our mapping table\n+            declMap = new JCTree[parsingDeferrals.size()];\n+            nextDeferral = 0;\n+\n+            \/\/ Scan declarations and map lexical deferrals to them\n+            try {\n+                scan(tree);\n+            } catch (ShortCircuitException e) {\n+                \/\/ got done early\n+            }\n+\n+            \/\/ Move lexical deferrals to their corresponding declarations (or null for remainders)\n+            for (int i = 0; i < declMap.length; i++) {\n+                deferralMap.computeIfAbsent(declMap[i], s -> new ArrayList<>()).add(parsingDeferrals.get(i));\n+            }\n+        }\n+\n+    \/\/ TreeScanner methods\n+\n@@ -127,3 +321,2 @@\n-        public JCTree getTree() {\n-            Assert.error();\n-            return null;\n+        public void visitModuleDef(JCModuleDecl decl) {\n+            scanDecl(decl, super::visitModuleDef);\n@@ -133,3 +326,2 @@\n-        public int getStartPosition() {\n-            Assert.error();\n-            return -1;\n+        public void visitPackageDef(JCPackageDecl decl) {\n+            scanDecl(decl, super::visitPackageDef);\n@@ -139,3 +331,2 @@\n-        public int getPreferredPosition() {\n-            Assert.error();\n-            return -1;\n+        public void visitClassDef(JCClassDecl decl) {\n+            scanDecl(decl, super::visitClassDef);\n@@ -145,3 +336,2 @@\n-        public int getEndPosition(EndPosTable endPosTable) {\n-            Assert.error();\n-            return -1;\n+        public void visitMethodDef(JCMethodDecl decl) {\n+            scanDecl(decl, super::visitMethodDef);\n@@ -149,1 +339,57 @@\n-    };\n+\n+        @Override\n+        public void visitVarDef(JCVariableDecl decl) {\n+            scanDecl(decl, super::visitVarDef);\n+        }\n+\n+        private <T extends JCTree> void scanDecl(T decl, Consumer<? super T> recursion) {\n+\n+            \/\/ Get the lexical extent of this declaration\n+            int minPos = TreeInfo.getStartPos(decl);\n+            int maxPos = TreeInfo.endPos(decl);\n+\n+            \/\/ Find those lexical deferrals that overlap this declaration and map them\n+            int numMatches = 0;\n+            while (nextDeferral + numMatches < parsingDeferrals.size()) {\n+\n+                \/\/ Where is this declaration relative to the next lexical deferral?\n+                Deferral deferral = parsingDeferrals.get(nextDeferral + numMatches);\n+                int relativePosition = deferral.compareToRange(minPos, maxPos);\n+\n+                \/\/ If it's before it, then this declaration overlaps nothing in the list. This only\n+                \/\/ happens with the initial declarations; after that, declarations always stay ahead.\n+                \/\/ Keep recursing forward through the source code.\n+                if (relativePosition > 0) {\n+                    break;\n+                }\n+\n+                \/\/ If it's after it, advance through the deferral list until we catch up with it\n+                if (relativePosition < 0) {\n+                    Assert.check(numMatches == 0);\n+                    nextDeferral++;\n+                    continue;\n+                }\n+\n+                \/\/ The deferral is contained within this declaration, so map it to the declaration,\n+                \/\/ and continue doing so for all immediately following deferrals that also match.\n+                \/\/ Note, this declaration may not be the innermost containing declaration; if not,\n+                \/\/ the narrower declaration(s) that follow will overwrite and correct the mapping.\n+                declMap[nextDeferral + numMatches] = decl;\n+                numMatches++;\n+            }\n+\n+            \/\/ Have we mapped all of the lexical deferrals? If so don't bother going any further.\n+            if (nextDeferral >= parsingDeferrals.size()) {\n+                throw new ShortCircuitException();\n+            }\n+\n+            \/\/ Recurse\n+            recursion.accept(decl);\n+        }\n+    }\n+\n+\/\/ ShortCircuitException\n+\n+    @SuppressWarnings(\"serial\")\n+    private static class ShortCircuitException extends RuntimeException {\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":310,"deletions":64,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -74,0 +75,3 @@\n+    \/** the deferred lint warning handler *\/\n+    private final DeferredLintHandler deferredLintHandler;\n+\n@@ -108,1 +112,2 @@\n-        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, \"preview\", LintCategory.PREVIEW);\n+        deferredLintHandler = DeferredLintHandler.instance(context);\n+        previewHandler = new MandatoryWarningHandler(log, source, true);\n@@ -164,0 +169,5 @@\n+     *\n+     * <p>\n+     * This method is intended to be used during parsing, when declarations do not exist yet.\n+     * The warning is deferred until the applicable {@lint Lint} configuration is known.\n+     *\n@@ -168,1 +178,7 @@\n-        warnPreview(new SimpleDiagnosticPosition(pos), feature);\n+        DiagnosticPosition diagPos = new SimpleDiagnosticPosition(pos);\n+        deferredLintHandler.push(pos);\n+        try {\n+            deferredLintHandler.report(lint -> warnPreview(lint, diagPos, feature));\n+        } finally {\n+            deferredLintHandler.pop();\n+        }\n@@ -174,0 +190,2 @@\n+     *\n+     * @param lint applicable lint configuration\n@@ -177,1 +195,1 @@\n-    public void warnPreview(DiagnosticPosition pos, Feature feature) {\n+    public void warnPreview(Lint lint, DiagnosticPosition pos, Feature feature) {\n@@ -182,2 +200,3 @@\n-                LintWarnings.PreviewFeatureUsePlural(feature.nameFragment()) :\n-                LintWarnings.PreviewFeatureUse(feature.nameFragment()));\n+            LintWarnings.PreviewFeatureUsePlural(feature.nameFragment()) :\n+            LintWarnings.PreviewFeatureUse(feature.nameFragment()),\n+            lint.isEnabled(LintCategory.PREVIEW));\n@@ -209,1 +228,1 @@\n-        previewHandler.report(pos, warnKey);\n+        previewHandler.report(pos, warnKey, verbose);\n@@ -289,1 +308,1 @@\n-    public void checkSourceLevel(DiagnosticPosition pos, Feature feature) {\n+    public void checkSourceLevel(Lint lint, DiagnosticPosition pos, Feature feature) {\n@@ -299,1 +318,1 @@\n-                warnPreview(pos, feature);\n+                warnPreview(lint, pos, feature);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,1 +233,1 @@\n-     * @param deferPos    report errors here\n+     * @param deferDecl   enclosing declaration for DeferredLintHandler, or null for no deferral\n@@ -236,1 +236,1 @@\n-            Symbol s, DiagnosticPosition deferPos)\n+            Symbol s, JCTree deferDecl)\n@@ -254,5 +254,6 @@\n-            DiagnosticPosition prevLintPos =\n-                    deferPos != null\n-                            ? deferredLintHandler.setPos(deferPos)\n-                            : deferredLintHandler.immediate(lint);\n-            Lint prevLint = deferPos != null ? null : chk.setLint(lint);\n+            if (deferDecl != null) {\n+                deferredLintHandler.push(deferDecl);\n+            } else {\n+                deferredLintHandler.pushImmediate(lint);\n+            }\n+            Lint prevLint = deferDecl != null ? null : chk.setLint(lint);\n@@ -271,1 +272,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n@@ -289,1 +290,1 @@\n-            MethodSymbol m, DiagnosticPosition deferPos)\n+            MethodSymbol m, JCTree deferDecl)\n@@ -293,1 +294,1 @@\n-            DiagnosticPosition prevLintPos = deferredLintHandler.setPos(deferPos);\n+            deferredLintHandler.push(deferDecl);\n@@ -297,1 +298,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n@@ -679,1 +680,1 @@\n-            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, tree.pos());\n+            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, null);\n@@ -1032,1 +1033,1 @@\n-            Symbol s, DiagnosticPosition deferPos, boolean isTypeParam)\n+            Symbol s, JCTree deferDecl, boolean isTypeParam)\n@@ -1036,1 +1037,0 @@\n-        DiagnosticPosition prevLintPos = null;\n@@ -1038,2 +1038,2 @@\n-        if (deferPos != null) {\n-            prevLintPos = deferredLintHandler.setPos(deferPos);\n+        if (deferDecl != null) {\n+            deferredLintHandler.push(deferDecl);\n@@ -1044,2 +1044,2 @@\n-            if (prevLintPos != null)\n-                deferredLintHandler.setPos(prevLintPos);\n+            if (deferDecl != null)\n+                deferredLintHandler.pop();\n@@ -1053,2 +1053,1 @@\n-    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym,\n-            DiagnosticPosition deferPos)\n+    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym, JCTree deferDecl)\n@@ -1057,1 +1056,1 @@\n-        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferPos)));\n+        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferDecl)));\n@@ -1092,1 +1091,1 @@\n-        private DiagnosticPosition deferPos;\n+        private JCTree deferDecl;\n@@ -1094,1 +1093,1 @@\n-        public TypeAnnotate(Env<AttrContext> env, Symbol sym, DiagnosticPosition deferPos) {\n+        public TypeAnnotate(Env<AttrContext> env, Symbol sym, JCTree deferDecl) {\n@@ -1098,1 +1097,1 @@\n-            this.deferPos = deferPos;\n+            this.deferDecl = deferDecl;\n@@ -1103,1 +1102,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n@@ -1109,1 +1108,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferPos, true);\n+            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, true);\n@@ -1115,1 +1114,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n@@ -1117,1 +1116,1 @@\n-                enterTypeAnnotations(dimAnnos, env, sym, deferPos, false);\n+                enterTypeAnnotations(dimAnnos, env, sym, deferDecl, false);\n@@ -1136,2 +1135,2 @@\n-            DiagnosticPosition prevPos = deferPos;\n-            deferPos = tree.pos();\n+            JCTree prevDecl = deferDecl;\n+            deferDecl = tree;\n@@ -1147,1 +1146,1 @@\n-                deferPos = prevPos;\n+                deferDecl = prevDecl;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":31,"deletions":32,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -857,4 +857,1 @@\n-\n-        DiagnosticPosition prevLintPos\n-                = deferredLintHandler.setPos(variable.pos());\n-\n+        deferredLintHandler.push(variable);\n@@ -876,1 +873,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -1005,1 +1002,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n@@ -1302,1 +1299,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n@@ -1346,1 +1343,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n@@ -1715,1 +1712,1 @@\n-                preview.checkSourceLevel(selector.pos(), Feature.PRIMITIVE_PATTERNS);\n+                preview.checkSourceLevel(env.info.lint, selector.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -1720,1 +1717,1 @@\n-                preview.checkSourceLevel(selector.pos(), Feature.PATTERN_SWITCH);\n+                preview.checkSourceLevel(env.info.lint, selector.pos(), Feature.PATTERN_SWITCH);\n@@ -1755,1 +1752,1 @@\n-                            preview.checkSourceLevel(expr.pos(), Feature.CASE_NULL);\n+                            preview.checkSourceLevel(env.info.lint, expr.pos(), Feature.CASE_NULL);\n@@ -1835,1 +1832,1 @@\n-                            preview.checkSourceLevel(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                            preview.checkSourceLevel(env.info.lint, pat.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4122,1 +4119,1 @@\n-            preview.checkSourceLevel(tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4148,1 +4145,1 @@\n-            preview.checkSourceLevel(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4185,1 +4182,1 @@\n-            preview.checkSourceLevel(pos, Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, pos, Feature.PRIMITIVE_PATTERNS);\n@@ -4220,1 +4217,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n+        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n@@ -4222,1 +4219,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n@@ -4225,0 +4222,7 @@\n+        Lint lint = env.info.lint.augment(tree.var.sym);\n+        Lint prevLint = chk.setLint(lint);\n+        try {\n+            deferredLintHandler.flush(tree.var, lint);\n+        } finally {\n+            chk.setLint(prevLint);\n+        }\n@@ -5335,1 +5339,1 @@\n-            deferredLintHandler.flush(env.tree.pos(), lint);\n+            deferredLintHandler.flush(env.tree, lint);\n@@ -5564,1 +5568,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -165,3 +165,0 @@\n-        boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);\n-        boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);\n-        boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);\n@@ -170,8 +167,3 @@\n-        deprecationHandler = new MandatoryWarningHandler(log, null, verboseDeprecated,\n-                enforceMandatoryWarnings, \"deprecated\", LintCategory.DEPRECATION);\n-        removalHandler = new MandatoryWarningHandler(log, null, verboseRemoval,\n-                enforceMandatoryWarnings, \"removal\", LintCategory.REMOVAL);\n-        uncheckedHandler = new MandatoryWarningHandler(log, null, verboseUnchecked,\n-                enforceMandatoryWarnings, \"unchecked\", LintCategory.UNCHECKED);\n-        sunApiHandler = new MandatoryWarningHandler(log, null, false,\n-                enforceMandatoryWarnings, \"sunapi\", null);\n+        deprecationHandler = new MandatoryWarningHandler(log, null, enforceMandatoryWarnings, \"deprecated\");\n+        removalHandler = new MandatoryWarningHandler(log, null, enforceMandatoryWarnings);\n+        uncheckedHandler = new MandatoryWarningHandler(log, null, enforceMandatoryWarnings);\n@@ -207,4 +199,0 @@\n-    \/** A handler for messages about using proprietary API.\n-     *\/\n-    private MandatoryWarningHandler sunApiHandler;\n-\n@@ -250,0 +238,1 @@\n+                boolean verbose = lint.isEnabled(LintCategory.REMOVAL);\n@@ -251,1 +240,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n+                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym), verbose);\n@@ -253,1 +242,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n+                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()), verbose);\n@@ -257,0 +246,1 @@\n+            boolean verbose = lint.isEnabled(LintCategory.DEPRECATION);\n@@ -258,1 +248,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym));\n+                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym), verbose);\n@@ -260,1 +250,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()), verbose);\n@@ -269,1 +259,1 @@\n-    public void warnPreviewAPI(DiagnosticPosition pos, LintWarning warnKey) {\n+    public void warnPreviewAPI(Lint lint, DiagnosticPosition pos, LintWarning warnKey) {\n@@ -278,1 +268,1 @@\n-    public void warnDeclaredUsingPreview(DiagnosticPosition pos, Symbol sym) {\n+    public void warnDeclaredUsingPreview(Lint lint, DiagnosticPosition pos, Symbol sym) {\n@@ -297,1 +287,1 @@\n-            uncheckedHandler.report(pos, warnKey);\n+            uncheckedHandler.report(pos, warnKey, lint.isEnabled(LintCategory.UNCHECKED));\n@@ -307,1 +297,0 @@\n-        sunApiHandler.reportDeferredDiagnostic();\n@@ -483,1 +472,0 @@\n-        sunApiHandler.clear();\n@@ -1167,1 +1155,0 @@\n-     *  @param pos           Position to be used for error reporting.\n@@ -1170,0 +1157,1 @@\n+     *  @param tree          The declaration\n@@ -1171,1 +1159,2 @@\n-    long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {\n+    long checkFlags(long flags, Symbol sym, JCTree tree) {\n+        final DiagnosticPosition pos = tree.pos();\n@@ -1215,1 +1204,1 @@\n-                warnOnExplicitStrictfp(pos);\n+                warnOnExplicitStrictfp(tree);\n@@ -1259,1 +1248,1 @@\n-                warnOnExplicitStrictfp(pos);\n+                warnOnExplicitStrictfp(tree);\n@@ -1323,2 +1312,2 @@\n-    private void warnOnExplicitStrictfp(DiagnosticPosition pos) {\n-        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(pos);\n+    private void warnOnExplicitStrictfp(JCTree tree) {\n+        deferredLintHandler.push(tree);\n@@ -1326,1 +1315,1 @@\n-            deferredLintHandler.report(_ -> lint.logIfEnabled(log, pos, LintWarnings.Strictfp));\n+            deferredLintHandler.report(_ -> lint.logIfEnabled(log, tree.pos(), LintWarnings.Strictfp));\n@@ -1328,1 +1317,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -3833,1 +3822,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreview(s)));\n+                    warnPreviewAPI(lint, pos, LintWarnings.IsPreview(s));\n@@ -3836,1 +3825,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreviewReflective(s)));\n+                    warnPreviewAPI(lint, pos, LintWarnings.IsPreviewReflective(s));\n@@ -3845,1 +3834,1 @@\n-                deferredLintHandler.report(_l -> warnDeclaredUsingPreview(pos, s));\n+                warnDeclaredUsingPreview(lint, pos, s);\n@@ -3999,0 +3988,2 @@\n+            Lint prevLint = lint;\n+            lint = lint.augment(tree.sym);\n@@ -4019,0 +4010,1 @@\n+                lint = prevLint;\n@@ -4061,1 +4053,1 @@\n-                    preview.checkSourceLevel(apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n+                    preview.checkSourceLevel(lint, apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n@@ -4736,1 +4728,1 @@\n-                    preview.checkSourceLevel(c.labels.tail.head.pos(), Feature.UNNAMED_VARIABLES);\n+                    preview.checkSourceLevel(lint, c.labels.tail.head.pos(), Feature.UNNAMED_VARIABLES);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":29,"deletions":37,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -506,1 +506,1 @@\n-        c.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, c, tree) | FROM_SOURCE;\n+        c.flags_field = chk.checkFlags(tree.mods.flags, c, tree) | FROM_SOURCE;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-        m.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, m, tree);\n+        m.flags_field = chk.checkFlags(tree.mods.flags, m, tree);\n@@ -197,1 +197,1 @@\n-        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());\n+        deferredLintHandler.push(tree);\n@@ -205,1 +205,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -230,1 +230,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree.pos());\n+        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree);\n@@ -233,1 +233,1 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree.pos());\n+        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree);\n@@ -237,1 +237,1 @@\n-            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree.pos());\n+            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree);\n@@ -266,1 +266,1 @@\n-        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());\n+        deferredLintHandler.push(tree);\n@@ -277,1 +277,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -296,1 +296,1 @@\n-        v.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, v, tree);\n+        v.flags_field = chk.checkFlags(tree.mods.flags, v, tree);\n@@ -318,1 +318,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree.pos());\n+        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree);\n@@ -320,1 +320,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -749,1 +749,1 @@\n-                DiagnosticPosition prevLintPos = deferredLintHandler.setPos(moduleDecl.pos());\n+                deferredLintHandler.push(moduleDecl);\n@@ -757,1 +757,1 @@\n-                    deferredLintHandler.setPos(prevLintPos);\n+                    deferredLintHandler.pop();\n@@ -782,0 +782,1 @@\n+        private Lint lint;\n@@ -789,0 +790,1 @@\n+            lint = Modules.this.lint.augment(sym);\n@@ -820,2 +822,1 @@\n-                            preview.checkSourceLevel(tree.pos(),\n-                                                     Feature.JAVA_BASE_TRANSITIVE);\n+                            preview.checkSourceLevel(lint, tree.pos(), Feature.JAVA_BASE_TRANSITIVE);\n@@ -994,1 +995,1 @@\n-            DiagnosticPosition prevLintPos = deferredLintHandler.setPos(decl.pos());\n+            deferredLintHandler.push(decl);\n@@ -1000,1 +1001,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3980,1 +3980,1 @@\n-        preview.checkSourceLevel(pos, Feature.FLEXIBLE_CONSTRUCTORS);\n+        preview.checkSourceLevel(env.info.lint, pos, Feature.FLEXIBLE_CONSTRUCTORS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,1 +277,1 @@\n-                DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());\n+                deferredLintHandler.push(tree);\n@@ -285,1 +285,1 @@\n-                    deferredLintHandler.setPos(prevLintPos);\n+                    deferredLintHandler.pop();\n@@ -368,1 +368,1 @@\n-            DiagnosticPosition prevLintPos = deferredLintHandler.immediate(lint);\n+            deferredLintHandler.pushImmediate(lint);\n@@ -393,1 +393,1 @@\n-                    DiagnosticPosition prevCheckDeprecatedLintPos = deferredLintHandler.setPos(decl.pos());\n+                    deferredLintHandler.push(decl);\n@@ -398,1 +398,1 @@\n-                        deferredLintHandler.setPos(prevCheckDeprecatedLintPos);\n+                        deferredLintHandler.pop();\n@@ -401,1 +401,1 @@\n-                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl.pos());\n+                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl);\n@@ -406,1 +406,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n@@ -439,1 +439,1 @@\n-            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree.pos());\n+            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree);\n@@ -932,1 +932,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree);\n@@ -934,1 +934,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree);\n@@ -949,2 +949,1 @@\n-            annotate.annotateLater(tree.mods.annotations, baseEnv,\n-                        sym, tree.pos());\n+            annotate.annotateLater(tree.mods.annotations, baseEnv, sym, tree);\n@@ -954,1 +953,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -293,0 +293,4 @@\n+    \/** The deferred lint handler.\n+     *\/\n+    protected DeferredLintHandler deferredLintHandler;\n+\n@@ -400,0 +404,1 @@\n+        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -659,1 +664,6 @@\n-            tree = parser.parseCompilationUnit();\n+            deferredLintHandler.enterParsingMode();\n+            try {\n+                tree = parser.parseCompilationUnit();\n+            } finally {\n+                deferredLintHandler.exitParsingMode(tree);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -88,0 +87,5 @@\n+    \/**\n+     * The deferred lint handler. Required for recognizing @SuppressWarnings.\n+     *\/\n+    private final DeferredLintHandler deferredLintHandler;\n+\n@@ -138,7 +142,0 @@\n-    \/**\n-     * The set of lint options currently in effect. It is initialized\n-     * from the context, and then is set\/reset as needed by Attr as it\n-     * visits all the various parts of the trees during attribution.\n-     *\/\n-    protected final Lint lint;\n-\n@@ -170,0 +167,1 @@\n+        this.deferredLintHandler = fac.deferredLintHandler;\n@@ -171,1 +169,0 @@\n-        this.lint = fac.lint;\n@@ -228,2 +225,6 @@\n-        DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;\n-        log.warning(dp, key);\n+        deferredLintHandler.push(pos);\n+        try {\n+            deferredLintHandler.report(lint -> lint.logIfEnabled(log, new SimpleDiagnosticPosition(pos), key));\n+        } finally {\n+            deferredLintHandler.pop();\n+        }\n@@ -1072,11 +1073,7 @@\n-                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                        Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                TextBlockSupport.checkWhitespace(string);\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.InconsistentWhiteSpaceIndentation);\n-                        }\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n-                        }\n+                    Set<TextBlockSupport.WhitespaceChecks> checks =\n+                            TextBlockSupport.checkWhitespace(string);\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                        lexWarning(pos, LintWarnings.InconsistentWhiteSpaceIndentation);\n+                    }\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                        lexWarning(pos, LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,3 +116,0 @@\n-    \/** A map associating \"other nearby documentation comments\"\n-     *  with the preferred documentation comment for a declaration. *\/\n-    protected Map<Comment, List<Comment>> danglingComments = new HashMap<>();\n@@ -585,11 +582,2 @@\n-     *     declaration) any other \"recent\" comments are saved\n-     *     in a map using the primary comment as a key,\n-     *     using this method, {@code saveDanglingComments}.\n-     *  4. When the tree node for the declaration is finally\n-     *     available, and the primary comment, if any,\n-     *     is \"attached\", (in {@link #attach}) any related\n-     *     dangling comments are also attached to the tree node\n-     *     by registering them using the {@link #deferredLintHandler}.\n-     *  5. (Later) Warnings may be generated for the dangling\n-     *     comments, subject to the {@code -Xlint} and\n-     *     {@code @SuppressWarnings}.\n+     *     declaration) any other \"recent\" comments are\n+     *     reported to the {@link #deferredLintHandler}.\n@@ -615,1 +603,0 @@\n-        var lb = new ListBuffer<Comment>();\n@@ -619,1 +606,1 @@\n-                lb.add(c);\n+                reportDanglingDocComment(c);\n@@ -622,1 +609,0 @@\n-        danglingComments.put(dc, lb.toList());\n@@ -627,3 +613,0 @@\n-     *  If there are any related \"dangling comments\", register\n-     *  diagnostics to be handled later, when @SuppressWarnings\n-     *  can be taken into account.\n@@ -638,20 +621,0 @@\n-        reportDanglingComments(tree, dc);\n-    }\n-\n-    \/** Reports all dangling comments associated with the\n-     *  primary comment for a declaration against the position\n-     *  of the tree node for a declaration.\n-     *\n-     * @param tree the tree node for the declaration\n-     * @param dc the primary comment for the declaration\n-     *\/\n-    void reportDanglingComments(JCTree tree, Comment dc) {\n-        var list = danglingComments.remove(dc);\n-        if (list != null) {\n-            var prevPos = deferredLintHandler.setPos(tree);\n-            try {\n-                list.forEach(this::reportDanglingDocComment);\n-            } finally {\n-                deferredLintHandler.setPos(prevPos);\n-            }\n-        }\n@@ -670,7 +633,10 @@\n-            deferredLintHandler.report(lint -> {\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n-                        !shebang(c, pos)) {\n-                    log.warning(\n-                            pos, LintWarnings.DanglingDocComment);\n-                }\n-            });\n+            deferredLintHandler.push(pos.getPreferredPosition());\n+            try {\n+                deferredLintHandler.report(lint -> {\n+                    if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) && !shebang(c, pos)) {\n+                        log.warning(pos, LintWarnings.DanglingDocComment);\n+                    }\n+                });\n+            } finally {\n+                deferredLintHandler.pop();\n+            }\n@@ -1032,0 +998,1 @@\n+                var.endPos = S.prevToken().endPos;\n@@ -2764,0 +2731,1 @@\n+            body.endPos = S.prevToken().endPos;\n@@ -3812,0 +3780,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -3837,0 +3806,1 @@\n+        result.endPos = endPos;\n@@ -3925,1 +3895,3 @@\n-                return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n+                JCVariableDecl result = toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n+                result.endPos = S.prevToken().endPos;\n+                return result;\n@@ -3950,1 +3922,1 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null,\n+        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, null,\n@@ -3952,0 +3924,2 @@\n+        result.endPos = S.prevToken().endPos;\n+        return result;\n@@ -4021,0 +3995,1 @@\n+            pd.endPos = S.prevToken().endPos;\n@@ -4130,1 +4105,1 @@\n-        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplicitClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ? constructImplicitClass(defs.toList(), S.prevToken().endPos) : defs.toList();\n@@ -4146,1 +4121,1 @@\n-    private List<JCTree> constructImplicitClass(List<JCTree> origDefs) {\n+    private List<JCTree> constructImplicitClass(List<JCTree> origDefs, int endPos) {\n@@ -4176,0 +4151,1 @@\n+        implicit.endPos = endPos;\n@@ -4191,0 +4167,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4194,0 +4171,1 @@\n+        result.endPos = endPos;\n@@ -4396,0 +4374,1 @@\n+        result.endPos = S.prevToken().endPos;\n@@ -4419,0 +4398,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4444,0 +4424,1 @@\n+        result.endPos = endPos;\n@@ -4484,0 +4465,1 @@\n+        result.endPos = S.prevToken().endPos;\n@@ -4532,0 +4514,1 @@\n+        result.endPos = S.prevToken().endPos;\n@@ -4670,0 +4653,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4671,1 +4655,1 @@\n-            storeEnd(create, S.prevToken().endPos);\n+            storeEnd(create, endPos);\n@@ -4673,1 +4657,2 @@\n-        JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));\n+        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, ident, create));\n+        result.endPos = endPos;\n@@ -5103,0 +5088,1 @@\n+            result.endPos = S.prevToken().endPos;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":40,"deletions":54,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -65,1 +65,1 @@\n-    final Lint lint;\n+    final DeferredLintHandler deferredLintHandler;\n@@ -77,1 +77,1 @@\n-        this.lint = Lint.instance(context);\n+        this.deferredLintHandler = DeferredLintHandler.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -644,0 +644,2 @@\n+        \/** Position of closing semicolon, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -840,0 +842,2 @@\n+        \/** position of closing brace, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -934,0 +938,2 @@\n+        \/** position of closing brace or semicolon, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -1019,0 +1025,2 @@\n+        \/** position of closing semicolon, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -3129,0 +3137,2 @@\n+        \/** position of closing brace, optional. *\/\n+        public int endPos = Position.NOPOS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,2 +503,1 @@\n-    \/** The end position of given tree, if it is a block with\n-     *  defined endpos.\n+    \/** The end position of the given tree, if defined.\n@@ -507,3 +506,6 @@\n-        if (tree.hasTag(BLOCK) && ((JCBlock) tree).endpos != Position.NOPOS)\n-            return ((JCBlock) tree).endpos;\n-        else if (tree.hasTag(SYNCHRONIZED))\n+        int endPos;\n+        switch (tree.getTag()) {\n+        case BLOCK:\n+            endPos = ((JCBlock) tree).endpos;\n+            break;\n+        case SYNCHRONIZED:\n@@ -511,1 +513,1 @@\n-        else if (tree.hasTag(TRY)) {\n+        case TRY:\n@@ -515,7 +517,22 @@\n-        } else if (tree.hasTag(SWITCH) &&\n-                   ((JCSwitch) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitch) tree).endpos;\n-        } else if (tree.hasTag(SWITCH_EXPRESSION) &&\n-                   ((JCSwitchExpression) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitchExpression) tree).endpos;\n-        } else\n+        case SWITCH:\n+            endPos = ((JCSwitch) tree).endpos;\n+            break;\n+        case SWITCH_EXPRESSION:\n+            endPos = ((JCSwitchExpression) tree).endpos;\n+            break;\n+        case MODULEDEF:\n+            endPos = ((JCModuleDecl) tree).endPos;\n+            break;\n+        case PACKAGEDEF:\n+            endPos = ((JCPackageDecl) tree).endPos;\n+            break;\n+        case CLASSDEF:\n+            endPos = ((JCClassDecl) tree).endPos;\n+            break;\n+        case METHODDEF:\n+            endPos = ((JCMethodDecl) tree).endPos;\n+            break;\n+        case VARDEF:\n+            endPos = ((JCVariableDecl) tree).endPos;\n+            break;\n+        default:\n@@ -523,0 +540,4 @@\n+        }\n+        if (endPos != Position.NOPOS)\n+            return endPos;\n+        return tree.pos;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+ * <p>\n@@ -52,0 +53,3 @@\n+ * <p>\n+ * Instances assume all warnings will be in the same {@link LintCategory}.\n+ *\n@@ -105,0 +109,13 @@\n+     *\n+     * @param log     The log on which to generate any diagnostics\n+     * @param source  Associated source file, or null for none\n+     * @param enforceMandatory\n+     *                True if mandatory warnings and notes are being enforced.\n+     *\/\n+    public MandatoryWarningHandler(Log log, Source source, boolean enforceMandatory) {\n+        this(log, source, enforceMandatory, null);\n+    }\n+\n+    \/**\n+     * Create a handler for mandatory warnings.\n+     *\n@@ -106,4 +123,1 @@\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n+     * @param source  Associated source file, or null for none\n@@ -112,3 +126,2 @@\n-     * @param prefix  A common prefix for the set of message keys for\n-     *                the messages that may be generated.\n-     * @param lc      An associated lint category for the warnings, or null if none.\n+     * @param prefix  A common prefix for the set of message keys for the messages\n+     *                that may be generated, or null to infer from the lint category.\n@@ -116,3 +129,1 @@\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose,\n-                                   boolean enforceMandatory, String prefix,\n-                                   LintCategory lc) {\n+    public MandatoryWarningHandler(Log log, Source source, boolean enforceMandatory, String prefix) {\n@@ -121,1 +132,0 @@\n-        this.verbose = verbose;\n@@ -124,1 +134,0 @@\n-        this.lintCategory = lc;\n@@ -129,0 +138,4 @@\n+     *\n+     * @param pos source code position\n+     * @param warnKey lint warning\n+     * @param verbose true to emit a distinct warning, false just to register a deferred message\n@@ -130,1 +143,1 @@\n-    public void report(DiagnosticPosition pos, LintWarning warnKey) {\n+    public void report(DiagnosticPosition pos, LintWarning warnKey, boolean verbose) {\n@@ -132,1 +145,4 @@\n-        Assert.check(warnKey.getLintCategory() == lintCategory);\n+\n+        \/\/ Infer the log prefix from the lint category if not given explicitly\n+        if (prefix == null)\n+            prefix = warnKey.getLintCategory().option;\n@@ -194,1 +210,1 @@\n-            if (!verbose)\n+            if (!anyWarningGenerated)\n@@ -205,6 +221,0 @@\n-    \/**\n-     * Whether or not to report individual warnings, or simply to report a\n-     * single aggregate warning at the end of the compilation.\n-     *\/\n-    private final boolean verbose;\n-\n@@ -214,1 +224,1 @@\n-    private final String prefix;\n+    private String prefix;\n@@ -247,1 +257,2 @@\n-     * True if mandatory warnings and notes are being enforced.\n+     * Whether we have actually logged a warning yet or just deferred everything.\n+     * In the latter case, the \"recompile\" notice is included in the summary.\n@@ -249,1 +260,1 @@\n-    private final boolean enforceMandatory;\n+    private boolean anyWarningGenerated;\n@@ -252,2 +263,1 @@\n-     * A LintCategory to be included in point-of-use diagnostics to indicate\n-     * how messages might be suppressed (i.e. with @SuppressWarnings).\n+     * True if mandatory warnings and notes are being enforced.\n@@ -255,1 +265,1 @@\n-    private final LintCategory lintCategory;\n+    private final boolean enforceMandatory;\n@@ -261,2 +271,1 @@\n-    private void logMandatoryWarning(DiagnosticPosition pos, Warning warnKey) {\n-        \/\/ Note: the following log methods are safe if lintCategory is null.\n+    private void logMandatoryWarning(DiagnosticPosition pos, LintWarning warnKey) {\n@@ -267,0 +276,1 @@\n+        anyWarningGenerated = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,0 @@\n-            \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-            \"- compiler.note.preview.recompile\",\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ErrorRecovery.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n-- compiler.note.preview.filename: ImplicitClassRecovery.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ImplicitClassRecovery.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassBad-Filename.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassHasPackage.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify SuppressWarnings works for LintCategore.TEXT_BLOCKS\n+ * @compile\/fail\/ref=TextBlockSuppress.out -XDrawDiagnostics -Xlint:text-blocks -Werror TextBlockSuppress.java\n+ *\/\n+\n+public class TextBlockSuppress {\n+\n+    public static class Example1 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example2 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example3 {\n+        @SuppressWarnings(\"text-blocks\")\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example4 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example5 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example6 {\n+        public void method() {\n+            @SuppressWarnings(\"text-blocks\")\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+TextBlockSuppress.java:12:24: compiler.warn.trailing.white.space.will.be.removed\n+TextBlockSuppress.java:38:24: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,2 +193,2 @@\n-                List.of(\"Use.java:5:13: compiler.warn.is.preview: preview.api.Outer\",\n-                        \"Use.java:7:35: compiler.warn.is.preview: preview.api.Outer\",\n+                List.of(\"Use.java:7:35: compiler.warn.is.preview: preview.api.Outer\",\n+                        \"Use.java:5:13: compiler.warn.is.preview: preview.api.Outer\",\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewAutoSuppress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,1 +327,1 @@\n-                            if (lint == Lint.ENABLE_PREVIEW) {\n+                            if (lint == Lint.ENABLE_PREVIEW && suppress == Suppress.NO) {\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -795,0 +795,93 @@\n+    @Test \/\/JDK-8224228:\n+    public void testSuppressWarnings(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public static int test() {\n+                                return 0;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.Preview;\n+                          public class Test {\n+\n+                            public static class Example1 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example2 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example3 {\n+                                @SuppressWarnings(\"preview\")\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example4 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example5 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example6 {\n+                                @SuppressWarnings(\"preview\")\n+                                int x = Preview.test();     \/\/ SHOULD NOT get a warning here\n+                            }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"--enable-preview\",\n+                         \"-Xlint:preview\",\n+                         \"-source\", String.valueOf(Runtime.version().feature()),\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:7:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"Test.java:27:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"2 warnings\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found: \" + log);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":94,"deletions":1,"binary":false,"changes":95,"status":"modified"}]}