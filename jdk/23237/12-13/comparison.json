{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Comparator;\n@@ -36,3 +35,1 @@\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.tree.TreeInfo;\n-import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n@@ -49,3 +46,2 @@\n- * associated with the file position (if parsing) or declaration (after parsing) placed in context by\n- * the most recent invocation of {@link #push push()} not yet {@link #pop}'d. Warnings are actually\n- * emitted later, during attribution, via {@link #flush}.\n+ * associated with the declaration placed in context by the most recent invocation of {@link #push push()}\n+ * not yet {@link #pop}'d. Warnings are actually emitted later, during attribution, via {@link #flush}.\n@@ -59,4 +55,1 @@\n- * can be applied when the warning is eventually generated. During parsing, no {@link JCTree} nodes exist\n- * yet, so warnings are stored by file character offset. Once parsing completes, these offsets are resolved\n- * to the innermost containing declaration. This class therefore operates in two distinct modes: parsing mode\n- * and non-parsing mode. Warnings are emitted when the correpsonding declaration is {@link #flush}ed.\n+ * can be applied when the warning is eventually generated.\n@@ -81,20 +74,1 @@\n-     * The root lint instance.\n-     *\/\n-    private final Lint rootLint;\n-\n-    \/**\n-     * Are we in parsing mode or non-parsing mode?\n-     *\/\n-    private boolean parsingMode;\n-\n-    \/**\n-     * Registered lexical {@link Deferral}s for the source file currently being parsed.\n-     *\n-     * <p>\n-     * This list is only used when parsing a source file. Once parsing ends, these deferrals\n-     * are resolved to their corresponding declarations and moved to {@link #deferralMap}.\n-     *\/\n-    private ArrayList<Deferral> parsingDeferrals = new ArrayList<>();\n-\n-    \/**\n-     * Registered {@link Deferral}s grouped by the innermost containing module, package, class,\n+     * Registered {@link LintLogger}s grouped by the innermost containing module, package, class,\n@@ -103,1 +77,1 @@\n-    private final HashMap<JCTree, ArrayList<Deferral>> deferralMap = new HashMap<>();\n+    private final HashMap<JCTree, ArrayList<LintLogger>> deferralMap = new HashMap<>();\n@@ -116,1 +90,1 @@\n-        rootLint = Lint.instance(context);\n+        Lint rootLint = Lint.instance(context);\n@@ -122,2 +96,3 @@\n-    \/**\n-     * Callback interface for deferred lint reporting.\n+    \/**An interface for deferred lint reporting - loggers passed to\n+     * {@link #report(LintLogger) } will be called when\n+     * {@link #flush(DiagnosticPosition) } is invoked.\n@@ -135,38 +110,0 @@\n-\/\/ Mode Switching\n-\n-    \/**\n-     * Enter parsing mode.\n-     *\/\n-    public void enterParsingMode() {\n-        Assert.check(!parsingMode);\n-        Assert.check(parsingDeferrals.isEmpty());\n-        parsingMode = true;\n-    }\n-\n-    \/**\n-     * Exit parsing mode and resolve each of the lexical {@link Deferral}s accumulated during parsing\n-     * to the innermost containing declaration in the given tree.\n-     *\n-     * <p>\n-     * Any lexical {@link Deferral}s that are not encompassed by a declaration are emitted using\n-     * the root {@link Lint} instance.\n-     *\n-     * @param tree top level node, or null to clean up after parsing failed\n-     *\/\n-    public void exitParsingMode(JCCompilationUnit tree) {\n-        Assert.check(parsingMode || tree == null);\n-        parsingMode = false;\n-        if (tree != null && !parsingDeferrals.isEmpty()) {\n-\n-            \/\/ Map lexical Deferral's to corresponding declarations\n-            new LexicalDeferralMapper().mapLexicalDeferrals(tree);\n-\n-            \/\/ Report any remainders immediately (must be outside the top level declaration)\n-            Optional.ofNullable(deferralMap.remove(null))\n-              .stream()\n-              .flatMap(ArrayList::stream)\n-              .forEach(deferral -> deferral.logger().report(rootLint));\n-        }\n-        parsingDeferrals.clear();\n-    }\n-\n@@ -175,15 +112,0 @@\n-    \/**\n-     * Defer {@link #report}ed warnings until the declaration encompassing the given\n-     * source file position is flushed.\n-     *\n-     * <p>\n-     * This should only be invoked when in parsing mode.\n-     *\n-     * @param pos character offset\n-     * @see #pop\n-     *\/\n-    public void push(int pos) {\n-        Assert.check(parsingMode);\n-        reporterStack.push(logger -> parsingDeferrals.add(new Deferral(logger, pos)));\n-    }\n-\n@@ -193,4 +115,0 @@\n-     * <p>\n-     * This is normally only invoked when in non-parsing mode, but it can also be invoked in\n-     * parsing mode if the declaration is known (e.g., see \"dangling-doc-comments\" handling).\n-     *\n@@ -208,1 +126,1 @@\n-                                        .add(new Deferral(logger)));\n+                                        .add(logger));\n@@ -252,1 +170,0 @@\n-        Assert.check(!parsingMode);\n@@ -257,1 +174,0 @@\n-          .map(Deferral::logger)\n@@ -260,135 +176,0 @@\n-\n-\/\/ Deferral\n-\n-    \/**\n-     * Represents a deferred warning.\n-     *\n-     * @param logger the logger that will report the warning\n-     * @param pos character offset in the source file (parsing mode only)\n-     *\/\n-    private record Deferral(LintLogger logger, int pos) {\n-\n-        \/\/ Create an instance in non-parsing mode\n-        Deferral(LintLogger logger) {\n-            this(logger, -1);\n-        }\n-\n-        \/\/ Compare our position to the given declaration range. Only used for lexical deferrals.\n-        int compareToRange(int minPos, int maxPos) {\n-            if (pos() < minPos)\n-                return -1;\n-            if (pos() == minPos || (pos() > minPos && pos() < maxPos))\n-                return 0;\n-            return 1;\n-        }\n-    }\n-\n-\/\/ LexicalDeferralMapper\n-\n-    \/\/ This scans a source file and identifies, for each lexical Deferral, the innermost\n-    \/\/ declaration that contains it and moves it to the corresponding entry in deferralMap.\n-    private class LexicalDeferralMapper extends TreeScanner {\n-\n-        private JCTree[] declMap;\n-        private int nextDeferral;\n-\n-        void mapLexicalDeferrals(JCCompilationUnit tree) {\n-\n-            \/\/ Sort lexical deferrals by position so our \"online\" algorithm works.\n-            \/\/ We also depend on TreeScanner visiting declarations in lexical order.\n-            parsingDeferrals.sort(Comparator.comparingInt(Deferral::pos));\n-\n-            \/\/ Initialize our mapping table\n-            declMap = new JCTree[parsingDeferrals.size()];\n-            nextDeferral = 0;\n-\n-            \/\/ Scan declarations and map lexical deferrals to them\n-            try {\n-                scan(tree);\n-            } catch (ShortCircuitException e) {\n-                \/\/ got done early\n-            }\n-\n-            \/\/ Move lexical deferrals to their corresponding declarations (or null for remainders)\n-            for (int i = 0; i < declMap.length; i++) {\n-                deferralMap.computeIfAbsent(declMap[i], s -> new ArrayList<>()).add(parsingDeferrals.get(i));\n-            }\n-        }\n-\n-    \/\/ TreeScanner methods\n-\n-        @Override\n-        public void visitModuleDef(JCModuleDecl decl) {\n-            scanDecl(decl, super::visitModuleDef);\n-        }\n-\n-        @Override\n-        public void visitPackageDef(JCPackageDecl decl) {\n-            scanDecl(decl, super::visitPackageDef);\n-        }\n-\n-        @Override\n-        public void visitClassDef(JCClassDecl decl) {\n-            scanDecl(decl, super::visitClassDef);\n-        }\n-\n-        @Override\n-        public void visitMethodDef(JCMethodDecl decl) {\n-            scanDecl(decl, super::visitMethodDef);\n-        }\n-\n-        @Override\n-        public void visitVarDef(JCVariableDecl decl) {\n-            scanDecl(decl, super::visitVarDef);\n-        }\n-\n-        private <T extends JCTree> void scanDecl(T decl, Consumer<? super T> recursion) {\n-\n-            \/\/ Get the lexical extent of this declaration\n-            int minPos = TreeInfo.getStartPos(decl);\n-            int maxPos = TreeInfo.endPos(decl);\n-\n-            \/\/ Find those lexical deferrals that overlap this declaration and map them\n-            int numMatches = 0;\n-            while (nextDeferral + numMatches < parsingDeferrals.size()) {\n-\n-                \/\/ Where is this declaration relative to the next lexical deferral?\n-                Deferral deferral = parsingDeferrals.get(nextDeferral + numMatches);\n-                int relativePosition = deferral.compareToRange(minPos, maxPos);\n-\n-                \/\/ If it's before it, then this declaration overlaps nothing else in the list.\n-                \/\/ Keep recursing forward through the source code.\n-                if (relativePosition > 0) {\n-                    break;\n-                }\n-\n-                \/\/ If it's after it, advance through the deferral list until we catch up with it\n-                if (relativePosition < 0) {\n-                    Assert.check(numMatches == 0);\n-                    nextDeferral++;\n-                    continue;\n-                }\n-\n-                \/\/ The deferral is contained within this declaration, so map it to the declaration,\n-                \/\/ and continue doing so for all immediately following deferrals that also match.\n-                \/\/ Note, this declaration may not be the innermost containing declaration; if not,\n-                \/\/ the narrower declaration(s) that follow will overwrite and correct the mapping.\n-                declMap[nextDeferral + numMatches] = decl;\n-                numMatches++;\n-            }\n-\n-            \/\/ Have we mapped all of the lexical deferrals? If so don't bother going any further.\n-            if (nextDeferral >= parsingDeferrals.size()) {\n-                throw new ShortCircuitException();\n-            }\n-\n-            \/\/ Recurse\n-            recursion.accept(decl);\n-        }\n-    }\n-\n-\/\/ ShortCircuitException\n-\n-    @SuppressWarnings(\"serial\")\n-    private static class ShortCircuitException extends RuntimeException {\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":11,"deletions":230,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -73,3 +72,0 @@\n-    \/** the deferred lint warning handler *\/\n-    private final DeferredLintHandler deferredLintHandler;\n-\n@@ -109,1 +105,0 @@\n-        rootLint = Lint.instance(context);\n@@ -111,1 +106,1 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n+        rootLint = Lint.instance(context);\n@@ -168,21 +163,0 @@\n-     *\n-     * <p>\n-     * This method is intended to be used during parsing, when declarations do not exist yet.\n-     * The warning is deferred until the applicable {@lint Lint} configuration is known.\n-     *\n-     * @param pos the position at which the preview feature was used.\n-     * @param feature the preview feature used.\n-     *\/\n-    public void warnPreview(int pos, Feature feature) {\n-        DiagnosticPosition diagPos = new SimpleDiagnosticPosition(pos);\n-        deferredLintHandler.push(pos);\n-        try {\n-            deferredLintHandler.report(lint -> warnPreview(lint, diagPos, feature));\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n-    }\n-\n-    \/**\n-     * Report usage of a preview feature. Usages reported through this method will affect the\n-     * set of sourcefiles with dependencies on preview features.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -293,4 +293,0 @@\n-    \/** The deferred lint handler.\n-     *\/\n-    protected DeferredLintHandler deferredLintHandler;\n-\n@@ -404,1 +400,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -664,6 +659,1 @@\n-            deferredLintHandler.enterParsingMode();\n-            try {\n-                tree = parser.parseCompilationUnit();\n-            } finally {\n-                deferredLintHandler.exitParsingMode(tree);\n-            }\n+            tree = parser.parseCompilationUnit();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -87,5 +86,0 @@\n-    \/**\n-     * The deferred lint handler. Required for recognizing @SuppressWarnings.\n-     *\/\n-    private final DeferredLintHandler deferredLintHandler;\n-\n@@ -142,0 +136,5 @@\n+    \/**\n+     * The lexical lint handler facilitates applying {@code @SuppressWarnings} to lexical warnings.\n+     *\/\n+    protected final LexicalLintHandler lexicalLintHandler = new LexicalLintHandler();\n+\n@@ -167,1 +166,0 @@\n-        this.deferredLintHandler = fac.deferredLintHandler;\n@@ -187,1 +185,2 @@\n-            preview.warnPreview(pos, feature);\n+            SimpleDiagnosticPosition diagPos = new SimpleDiagnosticPosition(pos);\n+            lexicalLintHandler.report(diagPos, lint -> preview.warnPreview(lint, diagPos, feature));\n@@ -219,1 +218,2 @@\n-     * Report a warning at the given position using the provided arguments.\n+     * Report a warning at the given position using the provided arguments,\n+     * if the lint category is not disabled by {@code @SuppressWarnings}.\n@@ -225,6 +225,2 @@\n-        deferredLintHandler.push(pos);\n-        try {\n-            deferredLintHandler.report(lint -> lint.logIfEnabled(new SimpleDiagnosticPosition(pos), key));\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n+        DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;\n+        lexicalLintHandler.report(dp, key);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import com.sun.tools.javac.code.DeferredLintHandler.LintLogger;\n@@ -583,1 +584,1 @@\n-     *     reported to the {@link #deferredLintHandler}.\n+     *     reported to the {@link LexicalLintHandler}.\n@@ -624,1 +625,1 @@\n-     * Reports an individual dangling comment using the {@link #deferredLintHandler}.\n+     * Reports an individual dangling comment using the {@link LexicalLintHandler}.\n@@ -632,11 +633,2 @@\n-        if (pos != null) {\n-            deferredLintHandler.push(pos.getPreferredPosition());\n-            try {\n-                deferredLintHandler.report(lint -> {\n-                    if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) && !shebang(c, pos)) {\n-                        log.warning(pos, LintWarnings.DanglingDocComment);\n-                    }\n-                });\n-            } finally {\n-                deferredLintHandler.pop();\n-            }\n+        if (pos != null && !shebang(c, pos)) {\n+            S.lintHandler().report(pos, LintWarnings.DanglingDocComment);\n@@ -670,21 +662,0 @@\n-\n-        \/\/ Module, package, class, method, and variable declarations remember their end positions\n-        switch (tree.getTag()) {\n-        case MODULEDEF:\n-            ((JCModuleDecl)tree).endPos = endpos;\n-            break;\n-        case PACKAGEDEF:\n-            ((JCPackageDecl)tree).endPos = endpos;\n-            break;\n-        case CLASSDEF:\n-            ((JCClassDecl)tree).endPos = endpos;\n-            break;\n-        case METHODDEF:\n-            ((JCMethodDecl)tree).endPos = endpos;\n-            break;\n-        case VARDEF:\n-            ((JCVariableDecl)tree).endPos = endpos;\n-            break;\n-        default:\n-            break;\n-        }\n@@ -1012,1 +983,1 @@\n-                JCVariableDecl var = toP(F.at(varPos).VarDef(mods, name, e, null));\n+                JCVariableDecl var = S.endDecl(toP(F.at(varPos).VarDef(mods, name, e, null)));\n@@ -2751,1 +2722,0 @@\n-            storeEnd(body, S.prevToken().endPos);\n@@ -3822,1 +3792,1 @@\n-        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n+        JCVariableDecl result = S.endDecl(toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar)));\n@@ -3913,3 +3883,1 @@\n-                JCVariableDecl result = toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n-                storeEnd(result, S.prevToken().endPos);\n-                return result;\n+                return S.endDecl(toP(F.at(pos).ReceiverVarDef(mods, pn, type)));\n@@ -3940,4 +3908,2 @@\n-        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, null,\n-                type != null && type.hasTag(IDENT) && ((JCIdent)type).name == names.var));\n-        storeEnd(result, S.prevToken().endPos);\n-        return result;\n+        return S.endDecl(toP(F.at(pos).VarDef(mods, name, type, null,\n+                type != null && type.hasTag(IDENT) && ((JCIdent)type).name == names.var)));\n@@ -4012,2 +3978,1 @@\n-            JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));\n-            storeEnd(pd, S.prevToken().endPos);\n+            JCPackageDecl pd = S.endDecl(toP(F.at(packagePos).PackageDecl(annotations, pid)));\n@@ -4123,1 +4088,1 @@\n-        List<JCTree> topLevelDefs = isImplicitClass ? constructImplicitClass(defs.toList(), S.prevToken().endPos) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplicitClass(defs.toList()) : defs.toList();\n@@ -4135,0 +4100,1 @@\n+        S.lintHandler().flushTo(deferredLintHandler);\n@@ -4139,1 +4105,1 @@\n-    private List<JCTree> constructImplicitClass(List<JCTree> origDefs, int endPos) {\n+    private List<JCTree> constructImplicitClass(List<JCTree> origDefs) {\n@@ -4169,1 +4135,0 @@\n-        storeEnd(implicit, endPos);\n@@ -4188,2 +4153,1 @@\n-        JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));\n-        storeEnd(result, endPos);\n+        JCModuleDecl result = S.lintHandler().endDecl(toP(F.at(pos).ModuleDef(mods, kind, name, directives)), endPos);\n@@ -4390,3 +4354,2 @@\n-        JCClassDecl result = toP(F.at(pos).ClassDef(\n-            mods, name, typarams, extending, implementing, permitting, defs));\n-        storeEnd(result, S.prevToken().endPos);\n+        JCClassDecl result = S.endDecl(toP(F.at(pos).ClassDef(\n+            mods, name, typarams, extending, implementing, permitting, defs)));\n@@ -4441,2 +4404,2 @@\n-        JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));\n-        storeEnd(result, endPos);\n+        JCClassDecl result = S.lintHandler().endDecl(\n+            toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs)), endPos);\n@@ -4481,3 +4444,2 @@\n-        JCClassDecl result = toP(F.at(pos).ClassDef(\n-            mods, name, typarams, null, extending, permitting, defs));\n-        storeEnd(result, S.prevToken().endPos);\n+        JCClassDecl result = S.endDecl(toP(F.at(pos).ClassDef(\n+            mods, name, typarams, null, extending, permitting, defs)));\n@@ -4529,1 +4491,1 @@\n-        JCClassDecl result = toP(F.at(pos).\n+        JCClassDecl result = S.endDecl(toP(F.at(pos).\n@@ -4531,2 +4493,1 @@\n-                     null, implementing, defs));\n-        storeEnd(result, S.prevToken().endPos);\n+                     null, implementing, defs)));\n@@ -4671,1 +4632,0 @@\n-        int endPos = S.prevToken().endPos;\n@@ -4673,1 +4633,1 @@\n-            storeEnd(create, endPos);\n+            storeEnd(create, S.prevToken().endPos);\n@@ -4675,2 +4635,1 @@\n-        JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));\n-        storeEnd(result, endPos);\n+        JCTree result = S.endDecl(toP(F.at(pos).VarDef(mods, name, ident, create)));\n@@ -5103,1 +5062,1 @@\n-                    toP(F.at(pos).MethodDef(mods, name, type, typarams,\n+                    S.endDecl(toP(F.at(pos).MethodDef(mods, name, type, typarams,\n@@ -5105,2 +5064,1 @@\n-                                            body, defaultValue));\n-            storeEnd(result, S.prevToken().endPos);\n+                                            body, defaultValue)));\n@@ -5615,1 +5573,2 @@\n-            preview.warnPreview(pos, feature);\n+            SimpleDiagnosticPosition diagPos = new SimpleDiagnosticPosition(pos);\n+            S.lintHandler().report(diagPos, lint -> preview.warnPreview(lint, diagPos, feature));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":29,"deletions":70,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import com.sun.tools.javac.tree.JCTree;\n@@ -106,0 +107,18 @@\n+\n+    \/**\n+     * Get the {@link LexicalLintHandler} associated with this instance.\n+     *\/\n+    LexicalLintHandler lintHandler();\n+\n+    \/**\n+     * Finish parsing a declaration that supports {@code @SuppressWarnings}.\n+     *\n+     * <p>\n+     * This is a convenience method for when the ending position equals {@code prevToken().endPos}.\n+     *\n+     * @param decl the newly parsed declaration\n+     * @return the given {@code decl} (for fluent chaining)\n+     *\/\n+    default <T extends JCTree> T endDecl(T decl) {\n+        return lintHandler().endDecl(decl, prevToken().endPos);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Lexer.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.parser;\n+\n+import java.util.ArrayDeque;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+\n+import com.sun.tools.javac.code.DeferredLintHandler;\n+import com.sun.tools.javac.code.DeferredLintHandler.LintLogger;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n+import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;\n+\n+\/**\n+ * Stashes lint warnings suppressible via {@code @SuppressWarnings} and their source code\n+ * positions while we await the creation of the innermost containing declaration.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class LexicalLintHandler {\n+\n+    private final LinkedList<Report> reports = new LinkedList<>();\n+    private final ArrayDeque<DeclNode> declNodes = new ArrayDeque<>();\n+\n+    private int lastFlushedStartPos;\n+    private int lastFlushedEndPos;\n+    private boolean flushed;\n+\n+\/\/ Public API\n+\n+    \/**\n+     * Report a lexical warning subject to possible suppression by {@code @SuppressWarnings}.\n+     *\n+     * @param pos the lexical position at which the warning occurs\n+     * @param logger the warning callback\n+     *\/\n+    public void report(DiagnosticPosition pos, LintLogger logger) {\n+        addReport(new Report(pos.getStartPosition(), logger));\n+    }\n+\n+    \/**\n+     * Report a lexical warning subject to possible suppression by {@code @SuppressWarnings}.\n+     *\n+     * @param pos the lexical position at which the warning occurs\n+     * @param key the warning to report\n+     *\/\n+    public void report(DiagnosticPosition pos, LintWarning key) {\n+        report(pos, lint -> lint.logIfEnabled(pos, key));\n+    }\n+\n+    \/**\n+     * Report the creation of a declaration that supports {@code @SuppressWarnings}.\n+     *\n+     * @param decl the newly parsed declaration\n+     * @param endPos the ending position of {@code decl} (exclusive)\n+     * @return the given {@code decl} (for fluent chaining)\n+     *\/\n+    public <T extends JCTree> T endDecl(T decl, int endPos) {\n+        Assert.check(!flushed);\n+        declNodes.addLast(new DeclNode(decl, endPos));\n+        return decl;\n+    }\n+\n+    \/**\n+     * Flush all reported warnings to the given {@link DeferredLintHandler} in association\n+     * their innermost enclosing declaration, if any.\n+     *\n+     * <p>\n+     * This must be invoked at the end, after parsing a file. Once this method is invoked,\n+     * no further invocations of {@link #report} or {@link #endDecl} are allowed.\n+     *\/\n+    public void flushTo(DeferredLintHandler deferredLintHandler) {\n+        Assert.check(!flushed);\n+        flushed = true;\n+\n+        \/\/ Flush reports contained within any of the declaration nodes we have gathered\n+        declNodes.forEach(declNode -> flushDeclReports(deferredLintHandler, declNode));\n+        declNodes.clear();\n+\n+        \/\/ Flush the remaining reports, which must be \"top level\" (i.e., not contained within any declaration)\n+        reports.forEach(report -> flushReport(deferredLintHandler, report));\n+        reports.clear();\n+    }\n+\n+\/\/ Internal Methods\n+\n+    \/\/ Add a new report to our list, which we keep sorted by position, in the appropriate spot.\n+    \/\/ Reports are (usually? always?) generated in source position order, so this should be quick.\n+    private void addReport(Report report) {\n+        Assert.check(!flushed);\n+        ListIterator<Report> i = reports.listIterator(reports.size());\n+        while (i.hasPrevious()) {\n+            if (i.previous().pos() <= report.pos()) {\n+                i.next();\n+                break;\n+            }\n+        }\n+        i.add(report);\n+    }\n+\n+    \/\/ Flush all reports contained within the given declaration\n+    private void flushDeclReports(DeferredLintHandler deferredLintHandler, DeclNode declNode) {\n+\n+        \/\/ Get declaration's starting position so we know its lexical range\n+        int startPos = TreeInfo.getStartPos(declNode.decl());\n+        int endPos = declNode.endPos();\n+\n+        \/\/ Sanity check our assumptions about declarations:\n+        \/\/  1. If two declarations overlap, then one of them must nest within the other\n+        \/\/  2. endDecl() is always invoked in order of increasing declaration ending position\n+        Assert.check(endPos >= lastFlushedEndPos);\n+        Assert.check(startPos >= lastFlushedEndPos || startPos <= lastFlushedStartPos);\n+\n+        \/\/ Find all reports contained by the declaration; they should all be at or near the end of the list\n+        ListIterator<Report> i = reports.listIterator(reports.size());\n+        int count = 0;\n+        while (i.hasPrevious()) {\n+            switch (i.previous().compareToRange(startPos, endPos)) {\n+            case AFTER:     \/\/ unusual; e.g., report is contained in the next token after declaration\n+                continue;\n+            case WITHIN:    \/\/ report is contained in the declaration, so we will flush it\n+                count++;\n+                continue;\n+            case BEFORE:    \/\/ we've gone too far, backup one step and start here\n+                i.next();\n+                break;\n+            }\n+            break;\n+        }\n+\n+        \/\/ Flush the reports contained by the declaration (in order). Note, we know that it is the innermost\n+        \/\/ containing declaration because any more deeply nested declarations must have already been flushed\n+        \/\/ by now; this follows from the above assumptions.\n+        deferredLintHandler.push(declNode.decl());\n+        try {\n+            while (count-- > 0) {\n+                flushReport(deferredLintHandler, i.next());\n+                i.remove();\n+            }\n+        } finally {\n+            deferredLintHandler.pop();\n+        }\n+\n+        \/\/ Update markers\n+        lastFlushedStartPos = startPos;\n+        lastFlushedEndPos = endPos;\n+    }\n+\n+    private void flushReport(DeferredLintHandler deferredLintHandler, Report report) {\n+        deferredLintHandler.report(report.logger());\n+    }\n+\n+\/\/ DeclNode\n+\n+    \/\/ A declaration that has been created and whose starting and ending positions are known\n+    private record DeclNode(JCTree decl, int endPos) { }\n+\n+\/\/ Report\n+\n+    \/\/ A warning report that has not yet been flushed to the DeferredLintHandler\n+    private record Report(int pos, LintLogger logger) {\n+\n+        \/\/ Compare our position to the given range\n+        Direction compareToRange(int minPos, int maxPos) {\n+            if (pos() < minPos)\n+                return Direction.BEFORE;\n+            if (pos() == minPos || (pos() > minPos && pos() < maxPos)) {\n+                return Direction.WITHIN;\n+            }\n+            return Direction.AFTER;\n+        }\n+    }\n+\n+\/\/ Direction\n+\n+    \/\/ Describes where a source code position lies relative to some range of positions\n+    private enum Direction {\n+        BEFORE,\n+        WITHIN,\n+        AFTER;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/LexicalLintHandler.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,0 +153,5 @@\n+    @Override\n+    public LexicalLintHandler lintHandler() {\n+        return tokenizer.lexicalLintHandler;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -65,1 +64,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -77,1 +75,0 @@\n-        this.deferredLintHandler = DeferredLintHandler.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,4 @@\n+        \/** Our {@link LexicalLintHandler}. This is never flushed, so warnings are never realized.\n+         *\/\n+        private final LexicalLintHandler lintHandler = new LexicalLintHandler();\n+\n@@ -170,0 +174,5 @@\n+        @Override\n+        public LexicalLintHandler lintHandler() {\n+            return lintHandler;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -644,2 +644,0 @@\n-        \/** Position of closing semicolon, optional. *\/\n-        public int endPos = Position.NOPOS;\n@@ -842,2 +840,0 @@\n-        \/** position of closing brace, optional. *\/\n-        public int endPos = Position.NOPOS;\n@@ -938,2 +934,0 @@\n-        \/** position of closing brace or semicolon, optional. *\/\n-        public int endPos = Position.NOPOS;\n@@ -1025,2 +1019,0 @@\n-        \/** position of closing semicolon, optional. *\/\n-        public int endPos = Position.NOPOS;\n@@ -3137,2 +3129,0 @@\n-        \/** position of closing brace, optional. *\/\n-        public int endPos = Position.NOPOS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,1 +503,2 @@\n-    \/** The end position of the given tree, if defined.\n+    \/** The end position of given tree, if it is a block with\n+     *  defined endpos.\n@@ -506,6 +507,3 @@\n-        int endPos;\n-        switch (tree.getTag()) {\n-        case BLOCK:\n-            endPos = ((JCBlock) tree).endpos;\n-            break;\n-        case SYNCHRONIZED:\n+        if (tree.hasTag(BLOCK) && ((JCBlock) tree).endpos != Position.NOPOS)\n+            return ((JCBlock) tree).endpos;\n+        else if (tree.hasTag(SYNCHRONIZED))\n@@ -513,1 +511,1 @@\n-        case TRY:\n+        else if (tree.hasTag(TRY)) {\n@@ -517,22 +515,7 @@\n-        case SWITCH:\n-            endPos = ((JCSwitch) tree).endpos;\n-            break;\n-        case SWITCH_EXPRESSION:\n-            endPos = ((JCSwitchExpression) tree).endpos;\n-            break;\n-        case MODULEDEF:\n-            endPos = ((JCModuleDecl) tree).endPos;\n-            break;\n-        case PACKAGEDEF:\n-            endPos = ((JCPackageDecl) tree).endPos;\n-            break;\n-        case CLASSDEF:\n-            endPos = ((JCClassDecl) tree).endPos;\n-            break;\n-        case METHODDEF:\n-            endPos = ((JCMethodDecl) tree).endPos;\n-            break;\n-        case VARDEF:\n-            endPos = ((JCVariableDecl) tree).endPos;\n-            break;\n-        default:\n+        } else if (tree.hasTag(SWITCH) &&\n+                   ((JCSwitch) tree).endpos != Position.NOPOS) {\n+            return ((JCSwitch) tree).endpos;\n+        } else if (tree.hasTag(SWITCH_EXPRESSION) &&\n+                   ((JCSwitchExpression) tree).endpos != Position.NOPOS) {\n+            return ((JCSwitchExpression) tree).endpos;\n+        } else\n@@ -540,4 +523,0 @@\n-        }\n-        if (endPos != Position.NOPOS)\n-            return endPos;\n-        return tree.pos;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":14,"deletions":35,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8350212\n- * @summary Verify ending source positions are calculated for declarations supporting SuppressWarnings\n- * @modules jdk.compiler\/com.sun.tools.javac.tree\n- * @run main DeclarationEndPositions\n- *\/\n-\n-import com.sun.source.tree.CompilationUnitTree;\n-import com.sun.source.tree.Tree;\n-import com.sun.source.tree.Tree;\n-import com.sun.source.util.JavacTask;\n-import com.sun.source.util.TreeScanner;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.tree.TreeInfo;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.util.List;\n-\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.ToolProvider;\n-\n-public class DeclarationEndPositions {\n-\n-    public static void checkEndPosition(Class<? extends JCTree> nodeType, String input, String marker) throws IOException {\n-\n-        \/\/ Create source\n-        var source = new SimpleJavaFileObject(URI.create(\"file:\/\/T.java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return input;\n-            }\n-        };\n-\n-        \/\/ Parse source\n-        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-        JavaCompiler.CompilationTask task = compiler.getTask(null, null, null, List.of(), List.of(), List.of(source));\n-        Iterable<? extends CompilationUnitTree> units = ((JavacTask)task).parse();\n-\n-        \/\/ Find node and check end position\n-        JCTree.JCCompilationUnit unit = (JCTree.JCCompilationUnit)units.iterator().next();\n-        unit.accept(new TreeScanner<Void, Void>() {\n-            @Override\n-            public Void scan(Tree node, Void aVoid) {\n-                if (nodeType.isInstance(node)) {\n-                    JCTree tree = (JCTree)node;\n-                    int actual = TreeInfo.endPos(tree);\n-                    int expected = marker.indexOf('^') + 1;\n-                    if (actual != expected) {\n-                        throw new AssertionError(String.format(\n-                          \"wrong end pos %d != %d for \\\"%s\\\" @ %d\", actual, expected, input, tree.pos));\n-                    }\n-                }\n-                return super.scan(node, aVoid);\n-            }\n-        }, null);\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-\n-        \/\/ JCModuleDecl\n-        checkEndPosition(JCModuleDecl.class,\n-           \"\/* comment *\/ module fred { \/* comment *\/ } \/* comment *\/\",\n-           \"                                          ^              \");\n-\n-        \/\/ JCPackageDecl\n-        checkEndPosition(JCPackageDecl.class,\n-           \"\/* comment *\/ package fred; \/* comment *\/\",\n-           \"                          ^              \");\n-\n-        \/\/ JCClassDecl\n-        checkEndPosition(JCClassDecl.class,\n-           \"\/* comment *\/ class Fred { \/* comment *\/ } \/* comment *\/\",\n-           \"                                         ^              \");\n-\n-        \/\/ JCMethodDecl\n-        checkEndPosition(JCMethodDecl.class,\n-           \"\/* comment *\/ class Fred { void m() { \/* comment *\/ } } \/* comment *\/\",\n-           \"                                                    ^                \");\n-\n-        \/\/ JCVariableDecl\n-        checkEndPosition(JCVariableDecl.class,\n-           \"\/* comment *\/ class Fred { int x; } \/* comment *\/\",\n-           \"                                ^                \");\n-        checkEndPosition(JCVariableDecl.class,\n-           \"\/* comment *\/ class Fred { int x = 123; } \/* comment *\/\",\n-           \"                                      ^                \");\n-        checkEndPosition(JCVariableDecl.class,\n-           \"\/* comment *\/ class A { try {} catch (Error err) {} } \/* comment *\/\",\n-           \"                                              ^                    \");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/parser\/DeclarationEndPositions.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -2301,3 +2301,4 @@\n-        \/\/             0         1         2\n-        \/\/             012345678901234567890\n-        String code = \"void main() { }\";\n+        String code = \"\"\"\n+                      void main() {\n+                      }\n+                      \"\"\";\n@@ -2315,1 +2316,1 @@\n-                assertEquals(\"Wrong end position\", 15, sp.getEndPosition(cut, node));\n+                assertEquals(\"Wrong end position\", -1, sp.getEndPosition(cut, node));\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}