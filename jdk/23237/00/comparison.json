{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,1 @@\n-            compiler.genEndPos = true;\n+            compiler.keepEndPos = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n@@ -29,1 +32,2 @@\n-import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n@@ -31,1 +35,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -33,0 +36,2 @@\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -35,2 +40,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.ListBuffer;\n@@ -39,0 +42,20 @@\n+ * Holds pending {@link Lint} warnings until the {@lint Lint} instance associated with the containing\n+ * module, package, class, method, or variable declaration is known so that {@link @SupressWarnings}\n+ * suppressions may be applied.\n+ *\n+ * <p>\n+ * Warnings are regsistered at any time prior to attribution via {@link #report}. The warning will be\n+ * associated with the file position (if parsing) or declaration (after parsing) placed in context by\n+ * the most recent invocation of {@link #push push()} not yet {@link #pop}'d. Warnings are actually\n+ * emitted later, during attribution, via {@link #flush}.\n+ *\n+ * <p>\n+ * There is also an \"immediate\" mode, where warnings are emitted synchronously; see {@link #pushImmediate}.\n+ *\n+ * <p>\n+ * Deferred warnings are grouped by the innermost containing module, package, class, method, or variable\n+ * declaration (represented by {@link JCTree} nodes), so that the corresponding {@link Lint} configuration\n+ * can be applied when the warning is eventually generated. During parsing, no {@link JCTree} nodes exist\n+ * yet, so warnings are stored by file character offset. Once parsing completes, these offsets are resolved\n+ * to the innermost containing declaration. This class therefore operates in two distinct modes: parsing mode\n+ * and non-parsing mode. Warnings are actually emitted when the correpsonding declaration is {@link #flush}ed.\n@@ -46,0 +69,1 @@\n+\n@@ -55,3 +79,32 @@\n-    \/** The Lint to use when {@link #immediate(Lint)} is used,\n-     * instead of {@link #setPos(DiagnosticPosition)}. *\/\n-    private Lint immediateLint;\n+    \/**\n+     * The root lint instance.\n+     *\/\n+    private final Lint rootLint;\n+\n+    \/**\n+     * Are we in parsing mode or non-parsing mode?\n+     *\/\n+    private boolean parsingMode;\n+\n+    \/**\n+     * Registered lexical {@link Deferral}s for the source file currently being parsed.\n+     *\n+     * <p>\n+     * This list is only used when parsing a source file. Once parsing ends, these deferrals\n+     * are resolved to their corresponding declarations and moved to {@link #deferralMap}.\n+     *\/\n+    private ArrayList<Deferral> parsingDeferrals = new ArrayList<>();\n+\n+    \/**\n+     * Registered {@link Deferral}s grouped by the innermost containing module, package, class,\n+     * method, or variable declaration.\n+     *\/\n+    private final HashMap<JCTree, ArrayList<Deferral>> deferralMap = new HashMap<>();\n+\n+    \/**\n+     * The current \"reporter\" stack, reflecting calls to {@link #push} and {@link #pop}.\n+     *\n+     * <p>\n+     * The top of the stack determines how calls to {@link #report} are handled.\n+     *\/\n+    private final ArrayDeque<Consumer<LintLogger>> reporterStack = new ArrayDeque<>();\n@@ -62,2 +115,2 @@\n-        this.currentPos = IMMEDIATE_POSITION;\n-        immediateLint = Lint.instance(context);\n+        rootLint = Lint.instance(context);\n+        pushImmediate(rootLint);            \/\/ default to \"immediate\" mode\n@@ -66,3 +119,4 @@\n-    \/**An interface for deferred lint reporting - loggers passed to\n-     * {@link #report(LintLogger) } will be called when\n-     * {@link #flush(DiagnosticPosition) } is invoked.\n+\/\/ Mode Switching\n+\n+    \/**\n+     * Enter parsing mode.\n@@ -70,2 +124,4 @@\n-    public interface LintLogger {\n-        void report(Lint lint);\n+    public void enterParsingMode() {\n+        Assert.check(!parsingMode);\n+        Assert.check(parsingDeferrals.isEmpty());\n+        parsingMode = true;\n@@ -74,2 +130,26 @@\n-    private DiagnosticPosition currentPos;\n-    private Map<DiagnosticPosition, ListBuffer<LintLogger>> loggersQueue = new HashMap<>();\n+    \/**\n+     * Exit parsing mode and resolve each of the lexical {@link Deferral}s accumulated during parsing\n+     * to the innermost containing declaration in the given tree.\n+     *\n+     * <p>\n+     * Any lexical {@link Deferral}s that are not encompassed by a declaration are emitted using\n+     * the root {@link Lint} instance.\n+     *\n+     * @param tree top level node, or null to clean up after parsing failed\n+     *\/\n+    public void exitParsingMode(JCCompilationUnit tree) {\n+        Assert.check(parsingMode || tree == null);\n+        parsingMode = false;\n+        if (tree != null && !parsingDeferrals.isEmpty()) {\n+\n+            \/\/ Map lexical Deferral's to corresponding declarations\n+            new LexicalDeferralMapper(tree).mapLexicalDeferrals();\n+\n+            \/\/ Report any remainders immediately (must be outside the top level declaration)\n+            Optional.ofNullable(deferralMap.remove(null))\n+              .stream()\n+              .flatMap(ArrayList::stream)\n+              .forEach(deferral -> deferral.logger().report(rootLint));\n+        }\n+        parsingDeferrals.clear();\n+    }\n@@ -77,5 +157,64 @@\n-    \/**Associate the given logger with the current position as set by {@link #setPos(DiagnosticPosition) }.\n-     * Will be invoked when {@link #flush(DiagnosticPosition) } will be invoked with the same position.\n-     * <br>\n-     * Will invoke the logger synchronously if {@link #immediate() } was called\n-     * instead of {@link #setPos(DiagnosticPosition) }.\n+\/\/ Reporter Stack\n+\n+    \/**\n+     * Defer {@link #report}ed warnings until the declaration encompassing the given\n+     * source file position is flushed.\n+     *\n+     * <p>\n+     * This should only be invoked when in parsing mode.\n+     *\n+     * @param pos character offset\n+     * @see #pop\n+     *\/\n+    public void push(int pos) {\n+        Assert.check(parsingMode);\n+        reporterStack.push(logger -> parsingDeferrals.add(new Deferral(logger, pos)));\n+    }\n+\n+    \/**\n+     * Defer {@link #report}ed warnings until the given declaration is flushed.\n+     *\n+     * <p>\n+     * This is normally only invoked when in non-parsing mode, but it can also be invoked in\n+     * parsing mode if the declaration is known (e.g., see \"dangling-doc-comments\" handling).\n+     *\n+     * @param decl module, package, class, method, or variable declaration\n+     * @see #pop\n+     *\/\n+    public void push(JCTree decl) {\n+        Assert.check(decl.getTag() == Tag.MODULEDEF\n+                  || decl.getTag() == Tag.PACKAGEDEF\n+                  || decl.getTag() == Tag.CLASSDEF\n+                  || decl.getTag() == Tag.METHODDEF\n+                  || decl.getTag() == Tag.VARDEF);\n+        reporterStack.push(logger -> deferralMap\n+                                        .computeIfAbsent(decl, s -> new ArrayList<>())\n+                                        .add(new Deferral(logger)));\n+    }\n+\n+    \/**\n+     * Enter \"immediate\" mode so that {@link #report}ed warnings are emitted synchonously.\n+     *\n+     * @param lint lint configuration to use for reported warnings\n+     *\/\n+    public void pushImmediate(Lint lint) {\n+        reporterStack.push(logger -> logger.report(lint));\n+    }\n+\n+    \/**\n+     * Revert to the previous configuration in effect prior to the most recent invocation\n+     * of {@link #push} or {@link #pushImmediate}.\n+     *\n+     * @see #pop\n+     *\/\n+    public void pop() {\n+        Assert.check(reporterStack.size() > 1);     \/\/ the bottom stack entry should never be popped\n+        reporterStack.pop();\n+    }\n+\n+    \/**\n+     * Report a warning.\n+     *\n+     * <p>\n+     * In immediate mode, the warning is emitted synchronously. Otherwise, the warning is emitted later\n+     * when the current declaration is flushed.\n@@ -84,9 +223,2 @@\n-        if (currentPos == IMMEDIATE_POSITION) {\n-            logger.report(immediateLint);\n-        } else {\n-            ListBuffer<LintLogger> loggers = loggersQueue.get(currentPos);\n-            if (loggers == null) {\n-                loggersQueue.put(currentPos, loggers = new ListBuffer<>());\n-            }\n-            loggers.append(logger);\n-        }\n+        Assert.check(!reporterStack.isEmpty());\n+        reporterStack.peek().accept(logger);\n@@ -95,1 +227,7 @@\n-    \/**Invoke all {@link LintLogger}s that were associated with the provided {@code pos}.\n+\/\/ Warning Flush\n+\n+    \/**\n+     * Emit deferred warnings encompassed by the given declaration.\n+     *\n+     * @param decl module, package, class, method, or variable declaration\n+     * @param lint lint configuration corresponding to {@code decl}\n@@ -97,8 +235,8 @@\n-    public void flush(DiagnosticPosition pos, Lint lint) {\n-        ListBuffer<LintLogger> loggers = loggersQueue.get(pos);\n-        if (loggers != null) {\n-            for (LintLogger lintLogger : loggers) {\n-                lintLogger.report(lint);\n-            }\n-            loggersQueue.remove(pos);\n-        }\n+    public void flush(JCTree decl, Lint lint) {\n+        Assert.check(!parsingMode);\n+        Optional.of(decl)\n+          .map(deferralMap::remove)\n+          .stream()\n+          .flatMap(ArrayList::stream)\n+          .map(Deferral::logger)\n+          .forEach(logger -> logger.report(lint));\n@@ -107,3 +245,4 @@\n-    \/**Sets the current position to the provided {@code currentPos}. {@link LintLogger}s\n-     * passed to subsequent invocations of {@link #report(LintLogger) } will be associated\n-     * with the given position.\n+\/\/ LintLogger\n+\n+    \/**\n+     * Callback interface for deferred lint reporting.\n@@ -111,4 +250,8 @@\n-    public DiagnosticPosition setPos(DiagnosticPosition currentPos) {\n-        DiagnosticPosition prevPosition = this.currentPos;\n-        this.currentPos = currentPos;\n-        return prevPosition;\n+    public interface LintLogger {\n+\n+        \/**\n+         * Generate a warning if appropriate.\n+         *\n+         * @param lint the applicable lint configuration\n+         *\/\n+        void report(Lint lint);\n@@ -117,2 +260,7 @@\n-    \/**{@link LintLogger}s passed to subsequent invocations of\n-     * {@link #report(LintLogger) } will be invoked immediately.\n+\/\/ Deferral\n+\n+    \/**\n+     * Represents a deferred warning.\n+     *\n+     * @param logger the logger that will report the warning\n+     * @param pos character offset in the source file (parsing mode only)\n@@ -120,3 +268,15 @@\n-    public DiagnosticPosition immediate(Lint lint) {\n-        immediateLint = lint;\n-        return setPos(IMMEDIATE_POSITION);\n+    private record Deferral(LintLogger logger, int pos) {\n+\n+        \/\/ Create an instance in non-parsing mode\n+        Deferral(LintLogger logger) {\n+            this(logger, -1);\n+        }\n+\n+        \/\/ Compare our position to the given declaration range. Only used for lexical deferrals.\n+        int compareToRange(int minPos, int maxPos) {\n+            if (pos() < minPos)\n+                return -1;\n+            if (pos() == minPos || (pos() > minPos && pos() < maxPos))\n+                return 0;\n+            return 1;\n+        }\n@@ -125,1 +285,45 @@\n-    private static final DiagnosticPosition IMMEDIATE_POSITION = new DiagnosticPosition() {\n+\/\/ LexicalDeferralMapper\n+\n+    \/\/ This scans a source file and identifies, for each lexical Deferral, the innermost\n+    \/\/ declaration that contains it and moves it to the corresponding entry in deferralMap.\n+    private class LexicalDeferralMapper extends TreeScanner {\n+\n+        private final JCCompilationUnit tree;\n+\n+        private JCTree[] declMap;\n+        private int currentDeferral;\n+\n+        LexicalDeferralMapper(JCCompilationUnit tree) {\n+            this.tree = tree;\n+        }\n+\n+        void mapLexicalDeferrals() {\n+\n+            \/\/ Sort lexical deferrals by position so our \"online\" algorithm works.\n+            \/\/ We also depend on TreeScanner visiting declarations in lexical order.\n+            parsingDeferrals.sort(Comparator.comparingInt(Deferral::pos));\n+\n+            \/\/ Initialize our mapping table\n+            declMap = new JCTree[parsingDeferrals.size()];\n+            currentDeferral = 0;\n+\n+            \/\/ Scan declarations and map lexical deferrals to them\n+            try {\n+                scan(tree);\n+            } catch (ShortCircuitException e) {\n+                \/\/ got done early\n+            }\n+\n+            \/\/ Move lexical deferrals to their corresponding declarations (or null for remainders)\n+            for (int i = 0; i < declMap.length; i++) {\n+                deferralMap.computeIfAbsent(declMap[i], s -> new ArrayList<>()).add(parsingDeferrals.get(i));\n+            }\n+        }\n+\n+    \/\/ TreeScanner methods\n+\n+        @Override\n+        public void visitModuleDef(JCModuleDecl tree) {\n+            scanDecl(tree, super::visitModuleDef);\n+        }\n+\n@@ -127,3 +331,2 @@\n-        public JCTree getTree() {\n-            Assert.error();\n-            return null;\n+        public void visitPackageDef(JCPackageDecl tree) {\n+            scanDecl(tree, super::visitPackageDef);\n@@ -133,3 +336,2 @@\n-        public int getStartPosition() {\n-            Assert.error();\n-            return -1;\n+        public void visitClassDef(JCClassDecl tree) {\n+            scanDecl(tree, super::visitClassDef);\n@@ -139,3 +341,2 @@\n-        public int getPreferredPosition() {\n-            Assert.error();\n-            return -1;\n+        public void visitMethodDef(JCMethodDecl tree) {\n+            scanDecl(tree, super::visitMethodDef);\n@@ -145,3 +346,42 @@\n-        public int getEndPosition(EndPosTable endPosTable) {\n-            Assert.error();\n-            return -1;\n+        public void visitVarDef(JCVariableDecl tree) {\n+            scanDecl(tree, super::visitVarDef);\n+        }\n+\n+        private <T extends JCTree> void scanDecl(T decl, Consumer<? super T> recursion) {\n+\n+            \/\/ Get the lexical extent of this declaration\n+            int minPos = decl.getPreferredPosition();\n+            int maxPos = decl.getEndPosition(tree.endPositions);\n+\n+            \/\/ Skip forward through lexical deferrals until we hit this declaration\n+            while (true) {\n+\n+                \/\/ We can stop scanning once we pass the last lexical deferral\n+                if (currentDeferral >= parsingDeferrals.size()) {\n+                    throw new ShortCircuitException();\n+                }\n+\n+                \/\/ Get the deferral currently under consideration\n+                Deferral deferral = parsingDeferrals.get(currentDeferral);\n+\n+                \/\/ Is its position prior to this declaration?\n+                int relativePosition = deferral.compareToRange(minPos, maxPos);\n+                if (relativePosition < 0) {\n+                    currentDeferral++;      \/\/ already past it\n+                    continue;\n+                }\n+\n+                \/\/ Is its position after this declaration?\n+                if (relativePosition > 0) {\n+                    break;                  \/\/ stop for now; a subsequent declaration might match\n+                }\n+\n+                \/\/ Deferral's position is within this declaration - we should map it.\n+                \/\/ Note this declaration may not be the innermost containing declaration,\n+                \/\/ but if not, that's OK: the narrower declaration will follow and overwrite.\n+                declMap[currentDeferral] = decl;\n+                break;\n+            }\n+\n+            \/\/ Recurse\n+            recursion.accept(decl);\n@@ -149,1 +389,7 @@\n-    };\n+    }\n+\n+\/\/ ShortCircuitException\n+\n+    @SuppressWarnings(\"serial\")\n+    private static class ShortCircuitException extends RuntimeException {\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":312,"deletions":66,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -74,0 +75,3 @@\n+    \/** the deferred lint warning handler *\/\n+    private final DeferredLintHandler deferredLintHandler;\n+\n@@ -108,0 +112,1 @@\n+        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -164,0 +169,5 @@\n+     *\n+     * <p>\n+     * This method is intended to be used during parsing, when declarations do not exist yet.\n+     * The warning is deferred until the applicable {@lint Lint} configuration is known.\n+     *\n@@ -168,1 +178,8 @@\n-        warnPreview(new SimpleDiagnosticPosition(pos), feature);\n+        DiagnosticPosition diagPos = new SimpleDiagnosticPosition(pos);\n+        deferredLintHandler.push(pos);\n+        try {\n+            deferredLintHandler.report(lint -> warnPreview(lint, diagPos, feature));\n+        } finally {\n+            deferredLintHandler.pop();\n+        }\n+        markUsesPreview(diagPos);\n@@ -174,0 +191,2 @@\n+     *\n+     * @param lint applicable lint configuration\n@@ -177,1 +196,1 @@\n-    public void warnPreview(DiagnosticPosition pos, Feature feature) {\n+    public void warnPreview(Lint lint, DiagnosticPosition pos, Feature feature) {\n@@ -181,0 +200,4 @@\n+\n+        \/\/ For preview warnings, even if a warning is suppressed by of @SuppressWarnings(\"preview\"), we\n+        \/\/ still need the \"recompile\" note at the end of compilation. To ensure that happens, we invoke\n+        \/\/ previewHandler.report() in all cases, but with \"verbose\" set to false if \"preview\" is suppressed.\n@@ -182,2 +205,3 @@\n-                LintWarnings.PreviewFeatureUsePlural(feature.nameFragment()) :\n-                LintWarnings.PreviewFeatureUse(feature.nameFragment()));\n+            LintWarnings.PreviewFeatureUsePlural(feature.nameFragment()) :\n+            LintWarnings.PreviewFeatureUse(feature.nameFragment()),\n+            lint.isEnabled(LintCategory.PREVIEW));\n@@ -289,1 +313,1 @@\n-    public void checkSourceLevel(DiagnosticPosition pos, Feature feature) {\n+    public void checkSourceLevel(Lint lint, DiagnosticPosition pos, Feature feature) {\n@@ -299,1 +323,1 @@\n-                warnPreview(pos, feature);\n+                warnPreview(lint, pos, feature);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,1 +233,1 @@\n-     * @param deferPos    report errors here\n+     * @param deferDecl   enclosing declaration for DeferredLintHandler, or null for no deferral\n@@ -236,1 +236,1 @@\n-            Symbol s, DiagnosticPosition deferPos)\n+            Symbol s, JCTree deferDecl)\n@@ -254,5 +254,6 @@\n-            DiagnosticPosition prevLintPos =\n-                    deferPos != null\n-                            ? deferredLintHandler.setPos(deferPos)\n-                            : deferredLintHandler.immediate(lint);\n-            Lint prevLint = deferPos != null ? null : chk.setLint(lint);\n+            if (deferDecl != null) {\n+                deferredLintHandler.push(deferDecl);\n+            } else {\n+                deferredLintHandler.pushImmediate(lint);\n+            }\n+            Lint prevLint = deferDecl != null ? null : chk.setLint(lint);\n@@ -271,1 +272,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n@@ -289,1 +290,1 @@\n-            MethodSymbol m, DiagnosticPosition deferPos)\n+            MethodSymbol m, JCTree deferDecl)\n@@ -293,1 +294,1 @@\n-            DiagnosticPosition prevLintPos = deferredLintHandler.setPos(deferPos);\n+            deferredLintHandler.push(deferDecl);\n@@ -297,1 +298,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n@@ -679,1 +680,1 @@\n-            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, tree.pos());\n+            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, null);\n@@ -1032,1 +1033,1 @@\n-            Symbol s, DiagnosticPosition deferPos, boolean isTypeParam)\n+            Symbol s, JCTree deferDecl, boolean isTypeParam)\n@@ -1036,1 +1037,0 @@\n-        DiagnosticPosition prevLintPos = null;\n@@ -1038,2 +1038,2 @@\n-        if (deferPos != null) {\n-            prevLintPos = deferredLintHandler.setPos(deferPos);\n+        if (deferDecl != null) {\n+            deferredLintHandler.push(deferDecl);\n@@ -1044,2 +1044,3 @@\n-            if (prevLintPos != null)\n-                deferredLintHandler.setPos(prevLintPos);\n+            if (deferDecl != null) {\n+                deferredLintHandler.pop();\n+            }\n@@ -1053,2 +1054,1 @@\n-    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym,\n-            DiagnosticPosition deferPos)\n+    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym, JCTree deferDecl)\n@@ -1057,1 +1057,1 @@\n-        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferPos)));\n+        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferDecl)));\n@@ -1092,1 +1092,1 @@\n-        private DiagnosticPosition deferPos;\n+        private JCTree deferDecl;\n@@ -1094,1 +1094,1 @@\n-        public TypeAnnotate(Env<AttrContext> env, Symbol sym, DiagnosticPosition deferPos) {\n+        public TypeAnnotate(Env<AttrContext> env, Symbol sym, JCTree deferDecl) {\n@@ -1098,1 +1098,1 @@\n-            this.deferPos = deferPos;\n+            this.deferDecl = deferDecl;\n@@ -1103,1 +1103,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n@@ -1109,1 +1109,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferPos, true);\n+            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, true);\n@@ -1115,1 +1115,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n@@ -1117,1 +1117,1 @@\n-                enterTypeAnnotations(dimAnnos, env, sym, deferPos, false);\n+                enterTypeAnnotations(dimAnnos, env, sym, deferDecl, false);\n@@ -1136,2 +1136,2 @@\n-            DiagnosticPosition prevPos = deferPos;\n-            deferPos = tree.pos();\n+            JCTree prevDecl = deferDecl;\n+            deferDecl = tree;\n@@ -1147,1 +1147,1 @@\n-                deferPos = prevPos;\n+                deferDecl = prevDecl;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -857,2 +857,1 @@\n-        DiagnosticPosition prevLintPos\n-                = deferredLintHandler.setPos(variable.pos());\n+        deferredLintHandler.push(variable);\n@@ -874,1 +873,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -1003,1 +1002,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n@@ -1287,1 +1286,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n@@ -1304,1 +1303,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n@@ -1592,0 +1591,1 @@\n+            flushDeferredLintHandler(tree.var);\n@@ -1706,1 +1706,1 @@\n-                preview.checkSourceLevel(selector.pos(), Feature.PRIMITIVE_PATTERNS);\n+                preview.checkSourceLevel(env.info.lint, selector.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -1711,1 +1711,1 @@\n-                preview.checkSourceLevel(selector.pos(), Feature.PATTERN_SWITCH);\n+                preview.checkSourceLevel(env.info.lint, selector.pos(), Feature.PATTERN_SWITCH);\n@@ -1746,1 +1746,1 @@\n-                            preview.checkSourceLevel(expr.pos(), Feature.CASE_NULL);\n+                            preview.checkSourceLevel(env.info.lint, expr.pos(), Feature.CASE_NULL);\n@@ -1826,1 +1826,1 @@\n-                            preview.checkSourceLevel(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                            preview.checkSourceLevel(env.info.lint, pat.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4113,1 +4113,1 @@\n-            preview.checkSourceLevel(tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4139,1 +4139,1 @@\n-            preview.checkSourceLevel(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4176,1 +4176,1 @@\n-            preview.checkSourceLevel(pos, Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, pos, Feature.PRIMITIVE_PATTERNS);\n@@ -4211,1 +4211,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n+        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n@@ -4213,1 +4213,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n@@ -4216,0 +4216,1 @@\n+        flushDeferredLintHandler(tree.var);\n@@ -4224,0 +4225,10 @@\n+    private void flushDeferredLintHandler(JCVariableDecl varDef) {\n+        Lint lint = env.info.lint.augment(varDef.sym);\n+        Lint prevLint = chk.setLint(lint);\n+        try {\n+            deferredLintHandler.flush(varDef, lint);\n+        } finally {\n+            chk.setLint(prevLint);\n+        }\n+    }\n+\n@@ -5326,1 +5337,1 @@\n-            deferredLintHandler.flush(env.tree.pos(), lint);\n+            deferredLintHandler.flush(env.tree, lint);\n@@ -5555,1 +5566,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-    public void warnPreviewAPI(DiagnosticPosition pos, LintWarning warnKey) {\n+    public void warnPreviewAPI(Lint lint, DiagnosticPosition pos, LintWarning warnKey) {\n@@ -278,1 +278,1 @@\n-    public void warnDeclaredUsingPreview(DiagnosticPosition pos, Symbol sym) {\n+    public void warnDeclaredUsingPreview(Lint lint, DiagnosticPosition pos, Symbol sym) {\n@@ -1167,1 +1167,0 @@\n-     *  @param pos           Position to be used for error reporting.\n@@ -1170,0 +1169,1 @@\n+     *  @param tree          The declaration\n@@ -1171,1 +1171,2 @@\n-    long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {\n+    long checkFlags(long flags, Symbol sym, JCTree tree) {\n+        final DiagnosticPosition pos = tree.pos();\n@@ -1215,1 +1216,1 @@\n-                warnOnExplicitStrictfp(pos);\n+                warnOnExplicitStrictfp(tree);\n@@ -1259,1 +1260,1 @@\n-                warnOnExplicitStrictfp(pos);\n+                warnOnExplicitStrictfp(tree);\n@@ -1323,2 +1324,2 @@\n-    private void warnOnExplicitStrictfp(DiagnosticPosition pos) {\n-        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(pos);\n+    private void warnOnExplicitStrictfp(JCTree tree) {\n+        deferredLintHandler.push(tree);\n@@ -1326,1 +1327,1 @@\n-            deferredLintHandler.report(_ -> lint.logIfEnabled(log, pos, LintWarnings.Strictfp));\n+            deferredLintHandler.report(_ -> lint.logIfEnabled(log, tree.pos(), LintWarnings.Strictfp));\n@@ -1328,1 +1329,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -3833,1 +3834,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreview(s)));\n+                    warnPreviewAPI(lint, pos, LintWarnings.IsPreview(s));\n@@ -3836,1 +3837,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreviewReflective(s)));\n+                    warnPreviewAPI(lint, pos, LintWarnings.IsPreviewReflective(s));\n@@ -3845,1 +3846,1 @@\n-                deferredLintHandler.report(_l -> warnDeclaredUsingPreview(pos, s));\n+                warnDeclaredUsingPreview(lint, pos, s);\n@@ -3999,0 +4000,2 @@\n+            Lint prevLint = lint;\n+            lint = lint.augment(tree.sym);\n@@ -4019,0 +4022,1 @@\n+                lint = prevLint;\n@@ -4061,1 +4065,1 @@\n-                    preview.checkSourceLevel(apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n+                    preview.checkSourceLevel(lint, apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n@@ -4736,1 +4740,1 @@\n-                    preview.checkSourceLevel(c.labels.tail.head.pos(), Feature.UNNAMED_VARIABLES);\n+                    preview.checkSourceLevel(lint, c.labels.tail.head.pos(), Feature.UNNAMED_VARIABLES);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -506,1 +506,1 @@\n-        c.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, c, tree) | FROM_SOURCE;\n+        c.flags_field = chk.checkFlags(tree.mods.flags, c, tree) | FROM_SOURCE;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,1 @@\n-        m.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, m, tree);\n+        m.flags_field = chk.checkFlags(tree.mods.flags, m, tree);\n@@ -197,1 +197,1 @@\n-        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());\n+        deferredLintHandler.push(tree);\n@@ -205,1 +205,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -230,1 +230,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree.pos());\n+        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree);\n@@ -233,1 +233,1 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree.pos());\n+        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree);\n@@ -237,1 +237,1 @@\n-            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree.pos());\n+            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree);\n@@ -266,1 +266,1 @@\n-        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());\n+        deferredLintHandler.push(tree);\n@@ -277,1 +277,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -296,1 +296,1 @@\n-        v.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, v, tree);\n+        v.flags_field = chk.checkFlags(tree.mods.flags, v, tree);\n@@ -318,1 +318,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree.pos());\n+        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree);\n@@ -320,1 +320,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -749,1 +749,1 @@\n-                DiagnosticPosition prevLintPos = deferredLintHandler.setPos(moduleDecl.pos());\n+                deferredLintHandler.push(moduleDecl);\n@@ -757,1 +757,1 @@\n-                    deferredLintHandler.setPos(prevLintPos);\n+                    deferredLintHandler.pop();\n@@ -782,0 +782,1 @@\n+        private Lint lint;\n@@ -789,0 +790,1 @@\n+            lint = Modules.this.lint.augment(sym);\n@@ -820,2 +822,1 @@\n-                            preview.checkSourceLevel(tree.pos(),\n-                                                     Feature.JAVA_BASE_TRANSITIVE);\n+                            preview.checkSourceLevel(lint, tree.pos(), Feature.JAVA_BASE_TRANSITIVE);\n@@ -994,1 +995,1 @@\n-            DiagnosticPosition prevLintPos = deferredLintHandler.setPos(decl.pos());\n+            deferredLintHandler.push(decl);\n@@ -1000,1 +1001,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3980,1 +3980,1 @@\n-        preview.checkSourceLevel(pos, Feature.FLEXIBLE_CONSTRUCTORS);\n+        preview.checkSourceLevel(env.info.lint, pos, Feature.FLEXIBLE_CONSTRUCTORS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,1 +277,1 @@\n-                DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());\n+                deferredLintHandler.push(tree);\n@@ -285,1 +285,1 @@\n-                    deferredLintHandler.setPos(prevLintPos);\n+                    deferredLintHandler.pop();\n@@ -368,1 +368,1 @@\n-            DiagnosticPosition prevLintPos = deferredLintHandler.immediate(lint);\n+            deferredLintHandler.pushImmediate(lint);\n@@ -393,1 +393,1 @@\n-                    DiagnosticPosition prevCheckDeprecatedLintPos = deferredLintHandler.setPos(decl.pos());\n+                    deferredLintHandler.push(decl);\n@@ -398,1 +398,1 @@\n-                        deferredLintHandler.setPos(prevCheckDeprecatedLintPos);\n+                        deferredLintHandler.pop();\n@@ -401,1 +401,1 @@\n-                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl.pos());\n+                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl);\n@@ -406,1 +406,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n@@ -439,1 +439,1 @@\n-            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree.pos());\n+            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree);\n@@ -932,1 +932,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree);\n@@ -934,1 +934,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree);\n@@ -949,2 +949,1 @@\n-            annotate.annotateLater(tree.mods.annotations, baseEnv,\n-                        sym, tree.pos());\n+            annotate.annotateLater(tree.mods.annotations, baseEnv, sym, tree);\n@@ -954,1 +953,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -293,0 +293,4 @@\n+    \/** The deferred lint handler.\n+     *\/\n+    protected DeferredLintHandler deferredLintHandler;\n+\n@@ -400,0 +404,1 @@\n+        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -453,1 +458,1 @@\n-        genEndPos     = options.isSet(XJCOV) ||\n+        keepEndPos    = options.isSet(XJCOV) ||\n@@ -518,1 +523,1 @@\n-    \/** Switch: should we store the ending positions?\n+    \/** Switch: should we keep the ending positions around after parsing?\n@@ -520,1 +525,1 @@\n-    public boolean genEndPos;\n+    public boolean keepEndPos;\n@@ -655,1 +660,1 @@\n-                genEndPos = true;\n+                keepEndPos = true;\n@@ -657,1 +662,1 @@\n-            Parser parser = parserFactory.newParser(content, keepComments(), genEndPos,\n+            Parser parser = parserFactory.newParser(content, keepComments(), true,\n@@ -659,1 +664,9 @@\n-            tree = parser.parseCompilationUnit();\n+            try {\n+                deferredLintHandler.enterParsingMode();\n+                tree = parser.parseCompilationUnit();\n+                deferredLintHandler.exitParsingMode(tree);\n+                if (!keepEndPos)\n+                    tree.endPositions = new JavacParser.EmptyEndPosTable();\n+            } finally {\n+                deferredLintHandler.exitParsingMode(null);\n+            }\n@@ -1166,1 +1179,1 @@\n-                genEndPos = true;\n+                keepEndPos = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -88,0 +87,5 @@\n+    \/**\n+     * The deferred lint handler. Required for recognizing @SuppressWarnings.\n+     *\/\n+    private final DeferredLintHandler deferredLintHandler;\n+\n@@ -138,7 +142,0 @@\n-    \/**\n-     * The set of lint options currently in effect. It is initialized\n-     * from the context, and then is set\/reset as needed by Attr as it\n-     * visits all the various parts of the trees during attribution.\n-     *\/\n-    protected final Lint lint;\n-\n@@ -170,0 +167,1 @@\n+        this.deferredLintHandler = fac.deferredLintHandler;\n@@ -171,1 +169,0 @@\n-        this.lint = fac.lint;\n@@ -228,2 +225,6 @@\n-        DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;\n-        log.warning(dp, key);\n+        deferredLintHandler.push(pos);\n+        try {\n+            deferredLintHandler.report(lint -> lint.logIfEnabled(log, new SimpleDiagnosticPosition(pos), key));\n+        } finally {\n+            deferredLintHandler.pop();\n+        }\n@@ -1072,11 +1073,7 @@\n-                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                        Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                TextBlockSupport.checkWhitespace(string);\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.InconsistentWhiteSpaceIndentation);\n-                        }\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n-                        }\n+                    Set<TextBlockSupport.WhitespaceChecks> checks =\n+                            TextBlockSupport.checkWhitespace(string);\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                        lexWarning(pos, LintWarnings.InconsistentWhiteSpaceIndentation);\n+                    }\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                        lexWarning(pos, LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -651,1 +651,1 @@\n-            var prevPos = deferredLintHandler.setPos(tree);\n+            deferredLintHandler.push(tree);\n@@ -655,1 +655,1 @@\n-                deferredLintHandler.setPos(prevPos);\n+                deferredLintHandler.pop();\n@@ -5660,1 +5660,1 @@\n-    protected static class EmptyEndPosTable extends AbstractEndPosTable {\n+    public static class EmptyEndPosTable extends AbstractEndPosTable {\n@@ -5662,1 +5662,5 @@\n-        EmptyEndPosTable(JavacParser parser) {\n+        public EmptyEndPosTable() {\n+            this(null);\n+        }\n+\n+        public EmptyEndPosTable(JavacParser parser) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -65,1 +65,1 @@\n-    final Lint lint;\n+    final DeferredLintHandler deferredLintHandler;\n@@ -77,1 +77,1 @@\n-        this.lint = Lint.instance(context);\n+        this.deferredLintHandler = DeferredLintHandler.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-     * Report a mandatory warning.\n+     * Report a mandatory warning using the default \"verbose\" setting.\n@@ -131,0 +131,7 @@\n+        report(pos, warnKey, verbose);\n+    }\n+\n+    \/**\n+     * Report a mandatory warning using the provided \"verbose\" setting.\n+     *\/\n+    public void report(DiagnosticPosition pos, LintWarning warnKey, boolean verbose) {\n@@ -194,1 +201,1 @@\n-            if (!verbose)\n+            if (!anyWarningGenerated)\n@@ -246,0 +253,6 @@\n+    \/**\n+     * Whether we have actually logged a warning yet or just deferred everything.\n+     * In the latter case, the \"recompile\" notice is included in the summary.\n+     *\/\n+    private boolean anyWarningGenerated;\n+\n@@ -267,0 +280,1 @@\n+        anyWarningGenerated = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,0 @@\n-            \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-            \"- compiler.note.preview.recompile\",\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ErrorRecovery.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify SuppressWarnings works for LintCategore.TEXT_BLOCKS\n+ * @compile\/fail\/ref=TextBlockSuppress.out -XDrawDiagnostics -Xlint:text-blocks -Werror TextBlockSuppress.java\n+ *\/\n+\n+public class TextBlockSuppress {\n+\n+    public static class Example1 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example2 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example3 {\n+        @SuppressWarnings(\"text-blocks\")\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example4 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example5 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example6 {\n+        public void method() {\n+            @SuppressWarnings(\"text-blocks\")\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+TextBlockSuppress.java:12:24: compiler.warn.trailing.white.space.will.be.removed\n+TextBlockSuppress.java:38:24: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,2 +193,2 @@\n-                List.of(\"Use.java:5:13: compiler.warn.is.preview: preview.api.Outer\",\n-                        \"Use.java:7:35: compiler.warn.is.preview: preview.api.Outer\",\n+                List.of(\"Use.java:7:35: compiler.warn.is.preview: preview.api.Outer\",\n+                        \"Use.java:5:13: compiler.warn.is.preview: preview.api.Outer\",\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewAutoSuppress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,1 +327,1 @@\n-                            if (lint == Lint.ENABLE_PREVIEW) {\n+                            if (lint == Lint.ENABLE_PREVIEW && suppress == Suppress.NO) {\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -795,0 +795,93 @@\n+    @Test \/\/JDK-8224228:\n+    public void testSuppressWarnings(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public static int test() {\n+                                return 0;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.Preview;\n+                          public class Test {\n+\n+                            public static class Example1 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example2 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example3 {\n+                                @SuppressWarnings(\"preview\")\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example4 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example5 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example6 {\n+                                @SuppressWarnings(\"preview\")\n+                                int x = Preview.test();     \/\/ SHOULD NOT get a warning here\n+                            }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"--enable-preview\",\n+                         \"-Xlint:preview\",\n+                         \"-source\", String.valueOf(Runtime.version().feature()),\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:7:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"Test.java:27:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"2 warnings\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found: \" + log);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":94,"deletions":1,"binary":false,"changes":95,"status":"modified"}]}