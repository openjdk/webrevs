{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Comparator;\n@@ -35,1 +36,3 @@\n-import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -46,2 +49,3 @@\n- * associated with the declaration placed in context by the most recent invocation of {@link #push push()}\n- * not yet {@link #pop}'d. Warnings are actually emitted later, during attribution, via {@link #flush}.\n+ * associated with the file position (if parsing) or declaration (after parsing) placed in context by\n+ * the most recent invocation of {@link #push push()} not yet {@link #pop}'d. Warnings are actually\n+ * emitted later, during attribution, via {@link #flush}.\n@@ -55,1 +59,4 @@\n- * can be applied when the warning is eventually generated.\n+ * can be applied when the warning is eventually generated. During parsing, no {@link JCTree} nodes exist\n+ * yet, so warnings are stored by file character offset. Once parsing completes, these offsets are resolved\n+ * to the innermost containing declaration. This class therefore operates in two distinct modes: parsing mode\n+ * and non-parsing mode. Warnings are emitted when the correpsonding declaration is {@link #flush}ed.\n@@ -74,1 +81,20 @@\n-     * Registered {@link LintLogger}s grouped by the innermost containing module, package, class,\n+     * The root lint instance.\n+     *\/\n+    private final Lint rootLint;\n+\n+    \/**\n+     * Are we in parsing mode or non-parsing mode?\n+     *\/\n+    private boolean parsingMode;\n+\n+    \/**\n+     * Registered lexical {@link Deferral}s for the source file currently being parsed.\n+     *\n+     * <p>\n+     * This list is only used when parsing a source file. Once parsing ends, these deferrals\n+     * are resolved to their corresponding declarations and moved to {@link #deferralMap}.\n+     *\/\n+    private ArrayList<Deferral> parsingDeferrals = new ArrayList<>();\n+\n+    \/**\n+     * Registered {@link Deferral}s grouped by the innermost containing module, package, class,\n@@ -77,1 +103,1 @@\n-    private final HashMap<JCTree, ArrayList<LintLogger>> deferralMap = new HashMap<>();\n+    private final HashMap<JCTree, ArrayList<Deferral>> deferralMap = new HashMap<>();\n@@ -90,1 +116,1 @@\n-        Lint rootLint = Lint.instance(context);\n+        rootLint = Lint.instance(context);\n@@ -96,3 +122,2 @@\n-    \/**An interface for deferred lint reporting - loggers passed to\n-     * {@link #report(LintLogger) } will be called when\n-     * {@link #flush(DiagnosticPosition) } is invoked.\n+    \/**\n+     * Callback interface for deferred lint reporting.\n@@ -110,0 +135,38 @@\n+\/\/ Mode Switching\n+\n+    \/**\n+     * Enter parsing mode.\n+     *\/\n+    public void enterParsingMode() {\n+        Assert.check(!parsingMode);\n+        Assert.check(parsingDeferrals.isEmpty());\n+        parsingMode = true;\n+    }\n+\n+    \/**\n+     * Exit parsing mode and resolve each of the lexical {@link Deferral}s accumulated during parsing\n+     * to the innermost containing declaration in the given tree.\n+     *\n+     * <p>\n+     * Any lexical {@link Deferral}s that are not encompassed by a declaration are emitted using\n+     * the root {@link Lint} instance.\n+     *\n+     * @param tree top level node, or null to clean up after parsing failed\n+     *\/\n+    public void exitParsingMode(JCCompilationUnit tree) {\n+        Assert.check(parsingMode || tree == null);\n+        parsingMode = false;\n+        if (tree != null && !parsingDeferrals.isEmpty()) {\n+\n+            \/\/ Map lexical Deferral's to corresponding declarations\n+            new LexicalDeferralMapper().mapLexicalDeferrals(tree);\n+\n+            \/\/ Report any remainders immediately (must be outside the top level declaration)\n+            Optional.ofNullable(deferralMap.remove(null))\n+              .stream()\n+              .flatMap(ArrayList::stream)\n+              .forEach(deferral -> deferral.logger().report(rootLint));\n+        }\n+        parsingDeferrals.clear();\n+    }\n+\n@@ -112,0 +175,15 @@\n+    \/**\n+     * Defer {@link #report}ed warnings until the declaration encompassing the given\n+     * source file position is flushed.\n+     *\n+     * <p>\n+     * This should only be invoked when in parsing mode.\n+     *\n+     * @param pos character offset\n+     * @see #pop\n+     *\/\n+    public void push(int pos) {\n+        Assert.check(parsingMode);\n+        reporterStack.push(logger -> parsingDeferrals.add(new Deferral(logger, pos)));\n+    }\n+\n@@ -115,0 +193,4 @@\n+     * <p>\n+     * This is normally only invoked when in non-parsing mode, but it can also be invoked in\n+     * parsing mode if the declaration is known (e.g., see \"dangling-doc-comments\" handling).\n+     *\n@@ -126,1 +208,1 @@\n-                                        .add(logger));\n+                                        .add(new Deferral(logger)));\n@@ -170,0 +252,1 @@\n+        Assert.check(!parsingMode);\n@@ -174,0 +257,1 @@\n+          .map(Deferral::logger)\n@@ -176,0 +260,135 @@\n+\n+\/\/ Deferral\n+\n+    \/**\n+     * Represents a deferred warning.\n+     *\n+     * @param logger the logger that will report the warning\n+     * @param pos character offset in the source file (parsing mode only)\n+     *\/\n+    private record Deferral(LintLogger logger, int pos) {\n+\n+        \/\/ Create an instance in non-parsing mode\n+        Deferral(LintLogger logger) {\n+            this(logger, -1);\n+        }\n+\n+        \/\/ Compare our position to the given declaration range. Only used for lexical deferrals.\n+        int compareToRange(int minPos, int maxPos) {\n+            if (pos() < minPos)\n+                return -1;\n+            if (pos() == minPos || (pos() > minPos && pos() < maxPos))\n+                return 0;\n+            return 1;\n+        }\n+    }\n+\n+\/\/ LexicalDeferralMapper\n+\n+    \/\/ This scans a source file and identifies, for each lexical Deferral, the innermost\n+    \/\/ declaration that contains it and moves it to the corresponding entry in deferralMap.\n+    private class LexicalDeferralMapper extends TreeScanner {\n+\n+        private JCTree[] declMap;\n+        private int nextDeferral;\n+\n+        void mapLexicalDeferrals(JCCompilationUnit tree) {\n+\n+            \/\/ Sort lexical deferrals by position so our \"online\" algorithm works.\n+            \/\/ We also depend on TreeScanner visiting declarations in lexical order.\n+            parsingDeferrals.sort(Comparator.comparingInt(Deferral::pos));\n+\n+            \/\/ Initialize our mapping table\n+            declMap = new JCTree[parsingDeferrals.size()];\n+            nextDeferral = 0;\n+\n+            \/\/ Scan declarations and map lexical deferrals to them\n+            try {\n+                scan(tree);\n+            } catch (ShortCircuitException e) {\n+                \/\/ got done early\n+            }\n+\n+            \/\/ Move lexical deferrals to their corresponding declarations (or null for remainders)\n+            for (int i = 0; i < declMap.length; i++) {\n+                deferralMap.computeIfAbsent(declMap[i], s -> new ArrayList<>()).add(parsingDeferrals.get(i));\n+            }\n+        }\n+\n+    \/\/ TreeScanner methods\n+\n+        @Override\n+        public void visitModuleDef(JCModuleDecl decl) {\n+            scanDecl(decl, super::visitModuleDef);\n+        }\n+\n+        @Override\n+        public void visitPackageDef(JCPackageDecl decl) {\n+            scanDecl(decl, super::visitPackageDef);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl decl) {\n+            scanDecl(decl, super::visitClassDef);\n+        }\n+\n+        @Override\n+        public void visitMethodDef(JCMethodDecl decl) {\n+            scanDecl(decl, super::visitMethodDef);\n+        }\n+\n+        @Override\n+        public void visitVarDef(JCVariableDecl decl) {\n+            scanDecl(decl, super::visitVarDef);\n+        }\n+\n+        private <T extends JCTree> void scanDecl(T decl, Consumer<? super T> recursion) {\n+\n+            \/\/ Get the lexical extent of this declaration\n+            int minPos = TreeInfo.getStartPos(decl);\n+            int maxPos = TreeInfo.endPos(decl);\n+\n+            \/\/ Find those lexical deferrals that overlap this declaration and map them\n+            int numMatches = 0;\n+            while (nextDeferral + numMatches < parsingDeferrals.size()) {\n+\n+                \/\/ Where is this declaration relative to the next lexical deferral?\n+                Deferral deferral = parsingDeferrals.get(nextDeferral + numMatches);\n+                int relativePosition = deferral.compareToRange(minPos, maxPos);\n+\n+                \/\/ If it's before it, then this declaration overlaps nothing else in the list.\n+                \/\/ Keep recursing forward through the source code.\n+                if (relativePosition > 0) {\n+                    break;\n+                }\n+\n+                \/\/ If it's after it, advance through the deferral list until we catch up with it\n+                if (relativePosition < 0) {\n+                    Assert.check(numMatches == 0);\n+                    nextDeferral++;\n+                    continue;\n+                }\n+\n+                \/\/ The deferral is contained within this declaration, so map it to the declaration,\n+                \/\/ and continue doing so for all immediately following deferrals that also match.\n+                \/\/ Note, this declaration may not be the innermost containing declaration; if not,\n+                \/\/ the narrower declaration(s) that follow will overwrite and correct the mapping.\n+                declMap[nextDeferral + numMatches] = decl;\n+                numMatches++;\n+            }\n+\n+            \/\/ Have we mapped all of the lexical deferrals? If so don't bother going any further.\n+            if (nextDeferral >= parsingDeferrals.size()) {\n+                throw new ShortCircuitException();\n+            }\n+\n+            \/\/ Recurse\n+            recursion.accept(decl);\n+        }\n+    }\n+\n+\/\/ ShortCircuitException\n+\n+    @SuppressWarnings(\"serial\")\n+    private static class ShortCircuitException extends RuntimeException {\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":230,"deletions":11,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -74,0 +75,3 @@\n+    \/** the deferred lint warning handler *\/\n+    private final DeferredLintHandler deferredLintHandler;\n+\n@@ -108,1 +112,2 @@\n-        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, LintCategory.PREVIEW);\n+        deferredLintHandler = DeferredLintHandler.instance(context);\n+        previewHandler = new MandatoryWarningHandler(log, source, true, LintCategory.PREVIEW);\n@@ -164,0 +169,5 @@\n+     *\n+     * <p>\n+     * This method is intended to be used during parsing, when declarations do not exist yet.\n+     * The warning is deferred until the applicable {@lint Lint} configuration is known.\n+     *\n@@ -168,1 +178,7 @@\n-        warnPreview(new SimpleDiagnosticPosition(pos), feature);\n+        DiagnosticPosition diagPos = new SimpleDiagnosticPosition(pos);\n+        deferredLintHandler.push(pos);\n+        try {\n+            deferredLintHandler.report(lint -> warnPreview(lint, diagPos, feature));\n+        } finally {\n+            deferredLintHandler.pop();\n+        }\n@@ -174,0 +190,2 @@\n+     *\n+     * @param lint applicable lint configuration\n@@ -177,1 +195,1 @@\n-    public void warnPreview(DiagnosticPosition pos, Feature feature) {\n+    public void warnPreview(Lint lint, DiagnosticPosition pos, Feature feature) {\n@@ -183,1 +201,2 @@\n-                LintWarnings.PreviewFeatureUse(feature.nameFragment()));\n+                LintWarnings.PreviewFeatureUse(feature.nameFragment()),\n+            lint.isEnabled(LintCategory.PREVIEW));\n@@ -209,1 +228,1 @@\n-        previewHandler.report(pos, warnKey);\n+        previewHandler.report(pos, warnKey, verbose);\n@@ -289,1 +308,1 @@\n-    public void checkSourceLevel(DiagnosticPosition pos, Feature feature) {\n+    public void checkSourceLevel(Lint lint, DiagnosticPosition pos, Feature feature) {\n@@ -299,1 +318,1 @@\n-                warnPreview(pos, feature);\n+                warnPreview(lint, pos, feature);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1712,1 +1712,1 @@\n-                preview.checkSourceLevel(selector.pos(), Feature.PRIMITIVE_PATTERNS);\n+                preview.checkSourceLevel(env.info.lint, selector.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -1717,1 +1717,1 @@\n-                preview.checkSourceLevel(selector.pos(), Feature.PATTERN_SWITCH);\n+                preview.checkSourceLevel(env.info.lint, selector.pos(), Feature.PATTERN_SWITCH);\n@@ -1752,1 +1752,1 @@\n-                            preview.checkSourceLevel(expr.pos(), Feature.CASE_NULL);\n+                            preview.checkSourceLevel(env.info.lint, expr.pos(), Feature.CASE_NULL);\n@@ -1832,1 +1832,1 @@\n-                            preview.checkSourceLevel(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                            preview.checkSourceLevel(env.info.lint, pat.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4119,1 +4119,1 @@\n-            preview.checkSourceLevel(tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4145,1 +4145,1 @@\n-            preview.checkSourceLevel(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4182,1 +4182,1 @@\n-            preview.checkSourceLevel(pos, Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, pos, Feature.PRIMITIVE_PATTERNS);\n@@ -4222,0 +4222,7 @@\n+        Lint lint = env.info.lint.augment(tree.var.sym);\n+        Lint prevLint = chk.setLint(lint);\n+        try {\n+            deferredLintHandler.flush(tree.var, lint);\n+        } finally {\n+            chk.setLint(prevLint);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -165,3 +165,0 @@\n-        boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);\n-        boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);\n-        boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);\n@@ -170,1 +167,1 @@\n-        deprecationHandler = new MandatoryWarningHandler(log, null, verboseDeprecated,\n+        deprecationHandler = new MandatoryWarningHandler(log, null,\n@@ -172,1 +169,1 @@\n-        removalHandler = new MandatoryWarningHandler(log, null, verboseRemoval,\n+        removalHandler = new MandatoryWarningHandler(log, null,\n@@ -174,1 +171,1 @@\n-        uncheckedHandler = new MandatoryWarningHandler(log, null, verboseUnchecked,\n+        uncheckedHandler = new MandatoryWarningHandler(log, null,\n@@ -244,0 +241,1 @@\n+                boolean verbose = lint.isEnabled(LintCategory.REMOVAL);\n@@ -245,1 +243,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n+                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym), verbose);\n@@ -247,1 +245,1 @@\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n+                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()), verbose);\n@@ -251,0 +249,1 @@\n+            boolean verbose = lint.isEnabled(LintCategory.DEPRECATION);\n@@ -252,1 +251,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym));\n+                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym), verbose);\n@@ -254,1 +253,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()), verbose);\n@@ -263,1 +262,1 @@\n-    public void warnPreviewAPI(DiagnosticPosition pos, LintWarning warnKey) {\n+    public void warnPreviewAPI(Lint lint, DiagnosticPosition pos, LintWarning warnKey) {\n@@ -272,1 +271,1 @@\n-    public void warnDeclaredUsingPreview(DiagnosticPosition pos, Symbol sym) {\n+    public void warnDeclaredUsingPreview(Lint lint, DiagnosticPosition pos, Symbol sym) {\n@@ -291,1 +290,1 @@\n-            uncheckedHandler.report(pos, warnKey);\n+            uncheckedHandler.report(pos, warnKey, lint.isEnabled(LintCategory.UNCHECKED));\n@@ -3826,1 +3825,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreview(s)));\n+                    warnPreviewAPI(lint, pos, LintWarnings.IsPreview(s));\n@@ -3829,1 +3828,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreviewReflective(s)));\n+                    warnPreviewAPI(lint, pos, LintWarnings.IsPreviewReflective(s));\n@@ -3838,1 +3837,1 @@\n-                deferredLintHandler.report(_l -> warnDeclaredUsingPreview(pos, s));\n+                warnDeclaredUsingPreview(lint, pos, s);\n@@ -3992,0 +3991,2 @@\n+            Lint prevLint = lint;\n+            lint = lint.augment(tree.sym);\n@@ -4012,0 +4013,1 @@\n+                lint = prevLint;\n@@ -4054,1 +4056,1 @@\n-                    preview.checkSourceLevel(apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n+                    preview.checkSourceLevel(lint, apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n@@ -4729,1 +4731,1 @@\n-                    preview.checkSourceLevel(c.labels.tail.head.pos(), Feature.UNNAMED_VARIABLES);\n+                    preview.checkSourceLevel(lint, c.labels.tail.head.pos(), Feature.UNNAMED_VARIABLES);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -782,0 +782,1 @@\n+        private Lint lint;\n@@ -789,0 +790,1 @@\n+            lint = Modules.this.lint.augment(sym);\n@@ -820,2 +822,1 @@\n-                            preview.checkSourceLevel(tree.pos(),\n-                                                     Feature.JAVA_BASE_TRANSITIVE);\n+                            preview.checkSourceLevel(lint, tree.pos(), Feature.JAVA_BASE_TRANSITIVE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3980,1 +3980,1 @@\n-        preview.checkSourceLevel(pos, Feature.FLEXIBLE_CONSTRUCTORS);\n+        preview.checkSourceLevel(env.info.lint, pos, Feature.FLEXIBLE_CONSTRUCTORS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -293,0 +293,4 @@\n+    \/** The deferred lint handler.\n+     *\/\n+    protected DeferredLintHandler deferredLintHandler;\n+\n@@ -400,0 +404,1 @@\n+        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -659,1 +664,6 @@\n-            tree = parser.parseCompilationUnit();\n+            deferredLintHandler.enterParsingMode();\n+            try {\n+                tree = parser.parseCompilationUnit();\n+            } finally {\n+                deferredLintHandler.exitParsingMode(tree);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -88,0 +87,5 @@\n+    \/**\n+     * The deferred lint handler. Required for recognizing @SuppressWarnings.\n+     *\/\n+    private final DeferredLintHandler deferredLintHandler;\n+\n@@ -138,7 +142,0 @@\n-    \/**\n-     * The set of lint options currently in effect. It is initialized\n-     * from the context, and then is set\/reset as needed by Attr as it\n-     * visits all the various parts of the trees during attribution.\n-     *\/\n-    protected final Lint lint;\n-\n@@ -170,0 +167,1 @@\n+        this.deferredLintHandler = fac.deferredLintHandler;\n@@ -171,1 +169,0 @@\n-        this.lint = fac.lint;\n@@ -228,2 +225,6 @@\n-        DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;\n-        log.warning(dp, key);\n+        deferredLintHandler.push(pos);\n+        try {\n+            deferredLintHandler.report(lint -> lint.logIfEnabled(new SimpleDiagnosticPosition(pos), key));\n+        } finally {\n+            deferredLintHandler.pop();\n+        }\n@@ -1072,11 +1073,7 @@\n-                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                        Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                TextBlockSupport.checkWhitespace(string);\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.InconsistentWhiteSpaceIndentation);\n-                        }\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n-                        }\n+                    Set<TextBlockSupport.WhitespaceChecks> checks =\n+                            TextBlockSupport.checkWhitespace(string);\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                        lexWarning(pos, LintWarnings.InconsistentWhiteSpaceIndentation);\n+                    }\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                        lexWarning(pos, LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -116,3 +116,0 @@\n-    \/** A map associating \"other nearby documentation comments\"\n-     *  with the preferred documentation comment for a declaration. *\/\n-    protected Map<Comment, List<Comment>> danglingComments = new HashMap<>();\n@@ -585,11 +582,2 @@\n-     *     declaration) any other \"recent\" comments are saved\n-     *     in a map using the primary comment as a key,\n-     *     using this method, {@code saveDanglingComments}.\n-     *  4. When the tree node for the declaration is finally\n-     *     available, and the primary comment, if any,\n-     *     is \"attached\", (in {@link #attach}) any related\n-     *     dangling comments are also attached to the tree node\n-     *     by registering them using the {@link #deferredLintHandler}.\n-     *  5. (Later) Warnings may be generated for the dangling\n-     *     comments, subject to the {@code -Xlint} and\n-     *     {@code @SuppressWarnings}.\n+     *     declaration) any other \"recent\" comments are\n+     *     reported to the {@link #deferredLintHandler}.\n@@ -615,1 +603,0 @@\n-        var lb = new ListBuffer<Comment>();\n@@ -619,1 +606,1 @@\n-                lb.add(c);\n+                reportDanglingDocComment(c);\n@@ -622,1 +609,0 @@\n-        danglingComments.put(dc, lb.toList());\n@@ -627,3 +613,0 @@\n-     *  If there are any related \"dangling comments\", register\n-     *  diagnostics to be handled later, when @SuppressWarnings\n-     *  can be taken into account.\n@@ -638,20 +621,0 @@\n-        reportDanglingComments(tree, dc);\n-    }\n-\n-    \/** Reports all dangling comments associated with the\n-     *  primary comment for a declaration against the position\n-     *  of the tree node for a declaration.\n-     *\n-     * @param tree the tree node for the declaration\n-     * @param dc the primary comment for the declaration\n-     *\/\n-    void reportDanglingComments(JCTree tree, Comment dc) {\n-        var list = danglingComments.remove(dc);\n-        if (list != null) {\n-            deferredLintHandler.push(tree);\n-            try {\n-                list.forEach(this::reportDanglingDocComment);\n-            } finally {\n-                deferredLintHandler.pop();\n-            }\n-        }\n@@ -670,7 +633,10 @@\n-            deferredLintHandler.report(lint -> {\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n-                        !shebang(c, pos)) {\n-                    log.warning(\n-                            pos, LintWarnings.DanglingDocComment);\n-                }\n-            });\n+            deferredLintHandler.push(pos.getPreferredPosition());\n+            try {\n+                deferredLintHandler.report(lint -> {\n+                    if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) && !shebang(c, pos)) {\n+                        log.warning(pos, LintWarnings.DanglingDocComment);\n+                    }\n+                });\n+            } finally {\n+                deferredLintHandler.pop();\n+            }\n@@ -704,0 +670,21 @@\n+\n+        \/\/ Module, package, class, method, and variable declarations remember their end positions\n+        switch (tree.getTag()) {\n+        case MODULEDEF:\n+            ((JCModuleDecl)tree).endPos = endpos;\n+            break;\n+        case PACKAGEDEF:\n+            ((JCPackageDecl)tree).endPos = endpos;\n+            break;\n+        case CLASSDEF:\n+            ((JCClassDecl)tree).endPos = endpos;\n+            break;\n+        case METHODDEF:\n+            ((JCMethodDecl)tree).endPos = endpos;\n+            break;\n+        case VARDEF:\n+            ((JCVariableDecl)tree).endPos = endpos;\n+            break;\n+        default:\n+            break;\n+        }\n@@ -2764,0 +2751,1 @@\n+            storeEnd(body, S.prevToken().endPos);\n@@ -3925,1 +3913,3 @@\n-                return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n+                JCVariableDecl result = toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n+                storeEnd(result, S.prevToken().endPos);\n+                return result;\n@@ -3950,1 +3940,1 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null,\n+        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, null,\n@@ -3952,0 +3942,2 @@\n+        storeEnd(result, S.prevToken().endPos);\n+        return result;\n@@ -4021,0 +4013,1 @@\n+            storeEnd(pd, S.prevToken().endPos);\n@@ -4130,1 +4123,1 @@\n-        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplicitClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ? constructImplicitClass(defs.toList(), S.prevToken().endPos) : defs.toList();\n@@ -4146,1 +4139,1 @@\n-    private List<JCTree> constructImplicitClass(List<JCTree> origDefs) {\n+    private List<JCTree> constructImplicitClass(List<JCTree> origDefs, int endPos) {\n@@ -4176,0 +4169,1 @@\n+        storeEnd(implicit, endPos);\n@@ -4191,0 +4185,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4194,0 +4189,1 @@\n+        storeEnd(result, endPos);\n@@ -4396,0 +4392,1 @@\n+        storeEnd(result, S.prevToken().endPos);\n@@ -4419,0 +4416,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4444,0 +4442,1 @@\n+        storeEnd(result, endPos);\n@@ -4484,0 +4483,1 @@\n+        storeEnd(result, S.prevToken().endPos);\n@@ -4532,0 +4532,1 @@\n+        storeEnd(result, S.prevToken().endPos);\n@@ -4670,0 +4671,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4671,1 +4673,1 @@\n-            storeEnd(create, S.prevToken().endPos);\n+            storeEnd(create, endPos);\n@@ -4674,0 +4676,1 @@\n+        storeEnd(result, endPos);\n@@ -5103,0 +5106,1 @@\n+            storeEnd(result, S.prevToken().endPos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":56,"deletions":52,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -65,1 +65,1 @@\n-    final Lint lint;\n+    final DeferredLintHandler deferredLintHandler;\n@@ -77,1 +77,1 @@\n-        this.lint = Lint.instance(context);\n+        this.deferredLintHandler = DeferredLintHandler.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -644,0 +644,2 @@\n+        \/** Position of closing semicolon, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -840,0 +842,2 @@\n+        \/** position of closing brace, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -934,0 +938,2 @@\n+        \/** position of closing brace or semicolon, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -1019,0 +1025,2 @@\n+        \/** position of closing semicolon, optional. *\/\n+        public int endPos = Position.NOPOS;\n@@ -3129,0 +3137,2 @@\n+        \/** position of closing brace, optional. *\/\n+        public int endPos = Position.NOPOS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,2 +503,1 @@\n-    \/** The end position of given tree, if it is a block with\n-     *  defined endpos.\n+    \/** The end position of the given tree, if defined.\n@@ -507,3 +506,6 @@\n-        if (tree.hasTag(BLOCK) && ((JCBlock) tree).endpos != Position.NOPOS)\n-            return ((JCBlock) tree).endpos;\n-        else if (tree.hasTag(SYNCHRONIZED))\n+        int endPos;\n+        switch (tree.getTag()) {\n+        case BLOCK:\n+            endPos = ((JCBlock) tree).endpos;\n+            break;\n+        case SYNCHRONIZED:\n@@ -511,1 +513,1 @@\n-        else if (tree.hasTag(TRY)) {\n+        case TRY:\n@@ -515,7 +517,22 @@\n-        } else if (tree.hasTag(SWITCH) &&\n-                   ((JCSwitch) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitch) tree).endpos;\n-        } else if (tree.hasTag(SWITCH_EXPRESSION) &&\n-                   ((JCSwitchExpression) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitchExpression) tree).endpos;\n-        } else\n+        case SWITCH:\n+            endPos = ((JCSwitch) tree).endpos;\n+            break;\n+        case SWITCH_EXPRESSION:\n+            endPos = ((JCSwitchExpression) tree).endpos;\n+            break;\n+        case MODULEDEF:\n+            endPos = ((JCModuleDecl) tree).endPos;\n+            break;\n+        case PACKAGEDEF:\n+            endPos = ((JCPackageDecl) tree).endPos;\n+            break;\n+        case CLASSDEF:\n+            endPos = ((JCClassDecl) tree).endPos;\n+            break;\n+        case METHODDEF:\n+            endPos = ((JCMethodDecl) tree).endPos;\n+            break;\n+        case VARDEF:\n+            endPos = ((JCVariableDecl) tree).endPos;\n+            break;\n+        default:\n@@ -523,0 +540,4 @@\n+        }\n+        if (endPos != Position.NOPOS)\n+            return endPos;\n+        return tree.pos;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -112,4 +112,0 @@\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n@@ -120,2 +116,2 @@\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc) {\n-        this(log, source, verbose, enforceMandatory, lc, null);\n+    public MandatoryWarningHandler(Log log, Source source, boolean enforceMandatory, LintCategory lc) {\n+        this(log, source, enforceMandatory, lc, null);\n@@ -129,4 +125,0 @@\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n@@ -139,1 +131,1 @@\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc, String prefix) {\n+    public MandatoryWarningHandler(Log log, Source source, boolean enforceMandatory, LintCategory lc, String prefix) {\n@@ -142,1 +134,0 @@\n-        this.verbose = verbose;\n@@ -153,0 +144,1 @@\n+     * @param verbose true to emit a distinct warning, false just to register a deferred message\n@@ -154,1 +146,1 @@\n-    public void report(DiagnosticPosition pos, LintWarning warnKey) {\n+    public void report(DiagnosticPosition pos, LintWarning warnKey, boolean verbose) {\n@@ -218,1 +210,1 @@\n-            if (!verbose)\n+            if (!anyWarningGenerated)\n@@ -229,6 +221,0 @@\n-    \/**\n-     * Whether or not to report individual warnings, or simply to report a\n-     * single aggregate warning at the end of the compilation.\n-     *\/\n-    private final boolean verbose;\n-\n@@ -270,0 +256,6 @@\n+    \/**\n+     * Whether we have actually logged a warning yet or just deferred everything.\n+     * In the latter case, the \"recompile\" notice is included in the summary.\n+     *\/\n+    private boolean anyWarningGenerated;\n+\n@@ -290,0 +282,1 @@\n+        anyWarningGenerated = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,0 @@\n-            \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-            \"- compiler.note.preview.recompile\",\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ErrorRecovery.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n-- compiler.note.preview.filename: ImplicitClassRecovery.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ImplicitClassRecovery.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassBad-Filename.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassHasPackage.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify SuppressWarnings works for LintCategore.TEXT_BLOCKS\n+ * @compile\/fail\/ref=TextBlockSuppress.out -XDrawDiagnostics -Xlint:text-blocks -Werror TextBlockSuppress.java\n+ *\/\n+\n+public class TextBlockSuppress {\n+\n+    public static class Example1 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example2 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example3 {\n+        @SuppressWarnings(\"text-blocks\")\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example4 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example5 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example6 {\n+        public void method() {\n+            @SuppressWarnings(\"text-blocks\")\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+TextBlockSuppress.java:12:24: compiler.warn.trailing.white.space.will.be.removed\n+TextBlockSuppress.java:38:24: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350212\n+ * @summary Verify ending source positions are calculated for declarations supporting SuppressWarnings\n+ * @modules jdk.compiler\/com.sun.tools.javac.tree\n+ * @run main DeclarationEndPositions\n+ *\/\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreeScanner;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+public class DeclarationEndPositions {\n+\n+    public static void checkEndPosition(Class<? extends JCTree> nodeType, String input, String marker) throws IOException {\n+\n+        \/\/ Create source\n+        var source = new SimpleJavaFileObject(URI.create(\"file:\/\/T.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return input;\n+            }\n+        };\n+\n+        \/\/ Parse source\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        JavaCompiler.CompilationTask task = compiler.getTask(null, null, null, List.of(), List.of(), List.of(source));\n+        Iterable<? extends CompilationUnitTree> units = ((JavacTask)task).parse();\n+\n+        \/\/ Find node and check end position\n+        JCTree.JCCompilationUnit unit = (JCTree.JCCompilationUnit)units.iterator().next();\n+        unit.accept(new TreeScanner<Void, Void>() {\n+            @Override\n+            public Void scan(Tree node, Void aVoid) {\n+                if (nodeType.isInstance(node)) {\n+                    JCTree tree = (JCTree)node;\n+                    int actual = TreeInfo.endPos(tree);\n+                    int expected = marker.indexOf('^') + 1;\n+                    if (actual != expected) {\n+                        throw new AssertionError(String.format(\n+                          \"wrong end pos %d != %d for \\\"%s\\\" @ %d\", actual, expected, input, tree.pos));\n+                    }\n+                }\n+                return super.scan(node, aVoid);\n+            }\n+        }, null);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+\n+        \/\/ JCModuleDecl\n+        checkEndPosition(JCModuleDecl.class,\n+           \"\/* comment *\/ module fred { \/* comment *\/ } \/* comment *\/\",\n+           \"                                          ^              \");\n+\n+        \/\/ JCPackageDecl\n+        checkEndPosition(JCPackageDecl.class,\n+           \"\/* comment *\/ package fred; \/* comment *\/\",\n+           \"                          ^              \");\n+\n+        \/\/ JCClassDecl\n+        checkEndPosition(JCClassDecl.class,\n+           \"\/* comment *\/ class Fred { \/* comment *\/ } \/* comment *\/\",\n+           \"                                         ^              \");\n+\n+        \/\/ JCMethodDecl\n+        checkEndPosition(JCMethodDecl.class,\n+           \"\/* comment *\/ class Fred { void m() { \/* comment *\/ } } \/* comment *\/\",\n+           \"                                                    ^                \");\n+\n+        \/\/ JCVariableDecl\n+        checkEndPosition(JCVariableDecl.class,\n+           \"\/* comment *\/ class Fred { int x; } \/* comment *\/\",\n+           \"                                ^                \");\n+        checkEndPosition(JCVariableDecl.class,\n+           \"\/* comment *\/ class Fred { int x = 123; } \/* comment *\/\",\n+           \"                                      ^                \");\n+        checkEndPosition(JCVariableDecl.class,\n+           \"\/* comment *\/ class A { try {} catch (Error err) {} } \/* comment *\/\",\n+           \"                                              ^                    \");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/parser\/DeclarationEndPositions.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -2301,4 +2301,3 @@\n-        String code = \"\"\"\n-                      void main() {\n-                      }\n-                      \"\"\";\n+        \/\/             0         1         2\n+        \/\/             012345678901234567890\n+        String code = \"void main() { }\";\n@@ -2316,1 +2315,1 @@\n-                assertEquals(\"Wrong end position\", -1, sp.getEndPosition(cut, node));\n+                assertEquals(\"Wrong end position\", 15, sp.getEndPosition(cut, node));\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,2 +193,2 @@\n-                List.of(\"Use.java:5:13: compiler.warn.is.preview: preview.api.Outer\",\n-                        \"Use.java:7:35: compiler.warn.is.preview: preview.api.Outer\",\n+                List.of(\"Use.java:7:35: compiler.warn.is.preview: preview.api.Outer\",\n+                        \"Use.java:5:13: compiler.warn.is.preview: preview.api.Outer\",\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewAutoSuppress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,1 +327,1 @@\n-                            if (lint == Lint.ENABLE_PREVIEW) {\n+                            if (lint == Lint.ENABLE_PREVIEW && suppress == Suppress.NO) {\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -795,0 +795,93 @@\n+    @Test \/\/JDK-8224228:\n+    public void testSuppressWarnings(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public static int test() {\n+                                return 0;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.Preview;\n+                          public class Test {\n+\n+                            public static class Example1 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example2 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example3 {\n+                                @SuppressWarnings(\"preview\")\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example4 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example5 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example6 {\n+                                @SuppressWarnings(\"preview\")\n+                                int x = Preview.test();     \/\/ SHOULD NOT get a warning here\n+                            }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"--enable-preview\",\n+                         \"-Xlint:preview\",\n+                         \"-source\", String.valueOf(Runtime.version().feature()),\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:7:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"Test.java:27:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"2 warnings\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found: \" + log);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":94,"deletions":1,"binary":false,"changes":95,"status":"modified"}]}