{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Lint;\n@@ -71,3 +72,0 @@\n-    \/** flag: is the \"preview\" lint category enabled? *\/\n-    private final boolean verbose;\n-\n@@ -87,0 +85,1 @@\n+    private final Lint rootLint;\n@@ -107,2 +106,2 @@\n-        verbose = Lint.instance(context).isEnabled(LintCategory.PREVIEW);\n-        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, LintCategory.PREVIEW);\n+        rootLint = Lint.instance(context);\n+        previewHandler = new MandatoryWarningHandler(log, source, true, LintCategory.PREVIEW);\n@@ -164,0 +163,2 @@\n+     *\n+     * @param lint applicable lint configuration\n@@ -167,11 +168,1 @@\n-    public void warnPreview(int pos, Feature feature) {\n-        warnPreview(new SimpleDiagnosticPosition(pos), feature);\n-    }\n-\n-    \/**\n-     * Report usage of a preview feature. Usages reported through this method will affect the\n-     * set of sourcefiles with dependencies on preview features.\n-     * @param pos the position at which the preview feature was used.\n-     * @param feature the preview feature used.\n-     *\/\n-    public void warnPreview(DiagnosticPosition pos, Feature feature) {\n+    public void warnPreview(Lint lint, DiagnosticPosition pos, Feature feature) {\n@@ -181,1 +172,1 @@\n-        previewHandler.report(pos, feature.isPlural() ?\n+        previewHandler.report(lint, pos, feature.isPlural() ?\n@@ -193,1 +184,1 @@\n-        if (verbose) {\n+        if (rootLint.isEnabled(LintCategory.PREVIEW)) {\n@@ -209,1 +200,1 @@\n-        previewHandler.report(pos, warnKey);\n+        previewHandler.report(rootLint, pos, warnKey);\n@@ -289,1 +280,1 @@\n-    public void checkSourceLevel(DiagnosticPosition pos, Feature feature) {\n+    public void checkSourceLevel(Lint lint, DiagnosticPosition pos, Feature feature) {\n@@ -299,1 +290,1 @@\n-                warnPreview(pos, feature);\n+                warnPreview(lint, pos, feature);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1712,1 +1712,1 @@\n-                preview.checkSourceLevel(selector.pos(), Feature.PRIMITIVE_PATTERNS);\n+                preview.checkSourceLevel(env.info.lint, selector.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -1717,1 +1717,1 @@\n-                preview.checkSourceLevel(selector.pos(), Feature.PATTERN_SWITCH);\n+                preview.checkSourceLevel(env.info.lint, selector.pos(), Feature.PATTERN_SWITCH);\n@@ -1752,1 +1752,1 @@\n-                            preview.checkSourceLevel(expr.pos(), Feature.CASE_NULL);\n+                            preview.checkSourceLevel(env.info.lint, expr.pos(), Feature.CASE_NULL);\n@@ -1832,1 +1832,1 @@\n-                            preview.checkSourceLevel(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                            preview.checkSourceLevel(env.info.lint, pat.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4119,1 +4119,1 @@\n-            preview.checkSourceLevel(tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4145,1 +4145,1 @@\n-            preview.checkSourceLevel(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n@@ -4182,1 +4182,1 @@\n-            preview.checkSourceLevel(pos, Feature.PRIMITIVE_PATTERNS);\n+            preview.checkSourceLevel(env.info.lint, pos, Feature.PRIMITIVE_PATTERNS);\n@@ -4222,0 +4222,7 @@\n+        Lint lint = env.info.lint.augment(tree.var.sym);\n+        Lint prevLint = chk.setLint(lint);\n+        try {\n+            deferredLintHandler.flush(tree.var, lint);\n+        } finally {\n+            chk.setLint(prevLint);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -165,3 +165,0 @@\n-        boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);\n-        boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);\n-        boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);\n@@ -170,1 +167,1 @@\n-        deprecationHandler = new MandatoryWarningHandler(log, null, verboseDeprecated,\n+        deprecationHandler = new MandatoryWarningHandler(log, null,\n@@ -172,1 +169,1 @@\n-        removalHandler = new MandatoryWarningHandler(log, null, verboseRemoval,\n+        removalHandler = new MandatoryWarningHandler(log, null,\n@@ -174,1 +171,1 @@\n-        uncheckedHandler = new MandatoryWarningHandler(log, null, verboseUnchecked,\n+        uncheckedHandler = new MandatoryWarningHandler(log, null,\n@@ -243,6 +240,4 @@\n-            if (!lint.isSuppressed(LintCategory.REMOVAL)) {\n-                if (sym.kind == MDL) {\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n-                } else {\n-                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n-                }\n+            if (sym.kind == MDL) {\n+                removalHandler.report(lint, pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n+            } else {\n+                removalHandler.report(lint, pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n@@ -250,1 +245,1 @@\n-        } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {\n+        } else {\n@@ -252,1 +247,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym));\n+                deprecationHandler.report(lint, pos, LintWarnings.HasBeenDeprecatedModule(sym));\n@@ -254,1 +249,1 @@\n-                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+                deprecationHandler.report(lint, pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n@@ -263,1 +258,1 @@\n-    public void warnPreviewAPI(DiagnosticPosition pos, LintWarning warnKey) {\n+    public void warnPreviewAPI(Lint lint, DiagnosticPosition pos, LintWarning warnKey) {\n@@ -272,1 +267,1 @@\n-    public void warnDeclaredUsingPreview(DiagnosticPosition pos, Symbol sym) {\n+    public void warnDeclaredUsingPreview(Lint lint, DiagnosticPosition pos, Symbol sym) {\n@@ -290,2 +285,1 @@\n-        if (!lint.isSuppressed(LintCategory.UNCHECKED))\n-            uncheckedHandler.report(pos, warnKey);\n+        uncheckedHandler.report(lint, pos, warnKey);\n@@ -3826,1 +3820,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreview(s)));\n+                    warnPreviewAPI(lint, pos, LintWarnings.IsPreview(s));\n@@ -3829,1 +3823,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreviewReflective(s)));\n+                    warnPreviewAPI(lint, pos, LintWarnings.IsPreviewReflective(s));\n@@ -3838,1 +3832,1 @@\n-                deferredLintHandler.report(_l -> warnDeclaredUsingPreview(pos, s));\n+                warnDeclaredUsingPreview(lint, pos, s);\n@@ -3992,0 +3986,2 @@\n+            Lint prevLint = lint;\n+            lint = lint.augment(tree.sym);\n@@ -4012,0 +4008,1 @@\n+                lint = prevLint;\n@@ -4054,1 +4051,1 @@\n-                    preview.checkSourceLevel(apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n+                    preview.checkSourceLevel(lint, apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n@@ -4729,1 +4726,1 @@\n-                    preview.checkSourceLevel(c.labels.tail.head.pos(), Feature.UNNAMED_VARIABLES);\n+                    preview.checkSourceLevel(lint, c.labels.tail.head.pos(), Feature.UNNAMED_VARIABLES);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -782,0 +782,1 @@\n+        private Lint lint;\n@@ -789,0 +790,1 @@\n+            lint = Modules.this.lint.augment(sym);\n@@ -820,2 +822,1 @@\n-                            preview.checkSourceLevel(tree.pos(),\n-                                                     Feature.JAVA_BASE_TRANSITIVE);\n+                            preview.checkSourceLevel(lint, tree.pos(), Feature.JAVA_BASE_TRANSITIVE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3980,1 +3980,1 @@\n-        preview.checkSourceLevel(pos, Feature.FLEXIBLE_CONSTRUCTORS);\n+        preview.checkSourceLevel(env.info.lint, pos, Feature.FLEXIBLE_CONSTRUCTORS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -139,3 +137,1 @@\n-     * The set of lint options currently in effect. It is initialized\n-     * from the context, and then is set\/reset as needed by Attr as it\n-     * visits all the various parts of the trees during attribution.\n+     * The lexical lint handler facilitates applying {@code @SuppressWarnings} to lexical warnings.\n@@ -143,1 +139,1 @@\n-    protected final Lint lint;\n+    protected final LexicalLintHandler lexicalLintHandler = new LexicalLintHandler();\n@@ -171,1 +167,0 @@\n-        this.lint = fac.lint;\n@@ -190,1 +185,2 @@\n-            preview.warnPreview(pos, feature);\n+            SimpleDiagnosticPosition diagPos = new SimpleDiagnosticPosition(pos);\n+            lexicalLintHandler.report(diagPos, lint -> preview.warnPreview(lint, diagPos, feature));\n@@ -222,1 +218,2 @@\n-     * Report a warning at the given position using the provided arguments.\n+     * Report a warning at the given position using the provided arguments,\n+     * if the lint category is not disabled by {@code @SuppressWarnings}.\n@@ -229,1 +226,1 @@\n-        log.warning(dp, key);\n+        lexicalLintHandler.report(dp, key);\n@@ -1072,11 +1069,7 @@\n-                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                        Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                TextBlockSupport.checkWhitespace(string);\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.InconsistentWhiteSpaceIndentation);\n-                        }\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n-                        }\n+                    Set<TextBlockSupport.WhitespaceChecks> checks =\n+                            TextBlockSupport.checkWhitespace(string);\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                        lexWarning(pos, LintWarnings.InconsistentWhiteSpaceIndentation);\n+                    }\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                        lexWarning(pos, LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import com.sun.tools.javac.code.DeferredLintHandler.LintLogger;\n@@ -116,3 +117,0 @@\n-    \/** A map associating \"other nearby documentation comments\"\n-     *  with the preferred documentation comment for a declaration. *\/\n-    protected Map<Comment, List<Comment>> danglingComments = new HashMap<>();\n@@ -585,11 +583,2 @@\n-     *     declaration) any other \"recent\" comments are saved\n-     *     in a map using the primary comment as a key,\n-     *     using this method, {@code saveDanglingComments}.\n-     *  4. When the tree node for the declaration is finally\n-     *     available, and the primary comment, if any,\n-     *     is \"attached\", (in {@link #attach}) any related\n-     *     dangling comments are also attached to the tree node\n-     *     by registering them using the {@link #deferredLintHandler}.\n-     *  5. (Later) Warnings may be generated for the dangling\n-     *     comments, subject to the {@code -Xlint} and\n-     *     {@code @SuppressWarnings}.\n+     *     declaration) any other \"recent\" comments are\n+     *     reported to the {@link LexicalLintHandler}.\n@@ -615,1 +604,0 @@\n-        var lb = new ListBuffer<Comment>();\n@@ -619,1 +607,1 @@\n-                lb.add(c);\n+                reportDanglingDocComment(c);\n@@ -622,1 +610,0 @@\n-        danglingComments.put(dc, lb.toList());\n@@ -627,3 +614,0 @@\n-     *  If there are any related \"dangling comments\", register\n-     *  diagnostics to be handled later, when @SuppressWarnings\n-     *  can be taken into account.\n@@ -638,20 +622,0 @@\n-        reportDanglingComments(tree, dc);\n-    }\n-\n-    \/** Reports all dangling comments associated with the\n-     *  primary comment for a declaration against the position\n-     *  of the tree node for a declaration.\n-     *\n-     * @param tree the tree node for the declaration\n-     * @param dc the primary comment for the declaration\n-     *\/\n-    void reportDanglingComments(JCTree tree, Comment dc) {\n-        var list = danglingComments.remove(dc);\n-        if (list != null) {\n-            deferredLintHandler.push(tree);\n-            try {\n-                list.forEach(this::reportDanglingDocComment);\n-            } finally {\n-                deferredLintHandler.pop();\n-            }\n-        }\n@@ -661,1 +625,1 @@\n-     * Reports an individual dangling comment using the {@link #deferredLintHandler}.\n+     * Reports an individual dangling comment using the {@link LexicalLintHandler}.\n@@ -669,8 +633,2 @@\n-        if (pos != null) {\n-            deferredLintHandler.report(lint -> {\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n-                        !shebang(c, pos)) {\n-                    log.warning(\n-                            pos, LintWarnings.DanglingDocComment);\n-                }\n-            });\n+        if (pos != null && !shebang(c, pos)) {\n+            S.lintHandler().report(pos, LintWarnings.DanglingDocComment);\n@@ -1025,1 +983,1 @@\n-                JCVariableDecl var = toP(F.at(varPos).VarDef(mods, name, e, null));\n+                JCVariableDecl var = S.endDecl(toP(F.at(varPos).VarDef(mods, name, e, null)));\n@@ -3834,1 +3792,1 @@\n-        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n+        JCVariableDecl result = S.endDecl(toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar)));\n@@ -3925,1 +3883,1 @@\n-                return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n+                return S.endDecl(toP(F.at(pos).ReceiverVarDef(mods, pn, type)));\n@@ -3950,2 +3908,2 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null,\n-                type != null && type.hasTag(IDENT) && ((JCIdent)type).name == names.var));\n+        return S.endDecl(toP(F.at(pos).VarDef(mods, name, type, null,\n+                type != null && type.hasTag(IDENT) && ((JCIdent)type).name == names.var)));\n@@ -4020,1 +3978,1 @@\n-            JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));\n+            JCPackageDecl pd = S.endDecl(toP(F.at(packagePos).PackageDecl(annotations, pid)));\n@@ -4142,0 +4100,1 @@\n+        S.lintHandler().flushTo(deferredLintHandler);\n@@ -4191,0 +4150,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4193,1 +4153,1 @@\n-        JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));\n+        JCModuleDecl result = S.lintHandler().endDecl(toP(F.at(pos).ModuleDef(mods, kind, name, directives)), endPos);\n@@ -4394,2 +4354,2 @@\n-        JCClassDecl result = toP(F.at(pos).ClassDef(\n-            mods, name, typarams, extending, implementing, permitting, defs));\n+        JCClassDecl result = S.endDecl(toP(F.at(pos).ClassDef(\n+            mods, name, typarams, extending, implementing, permitting, defs)));\n@@ -4419,0 +4379,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4443,1 +4404,2 @@\n-        JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));\n+        JCClassDecl result = S.lintHandler().endDecl(\n+            toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs)), endPos);\n@@ -4482,2 +4444,2 @@\n-        JCClassDecl result = toP(F.at(pos).ClassDef(\n-            mods, name, typarams, null, extending, permitting, defs));\n+        JCClassDecl result = S.endDecl(toP(F.at(pos).ClassDef(\n+            mods, name, typarams, null, extending, permitting, defs)));\n@@ -4529,1 +4491,1 @@\n-        JCClassDecl result = toP(F.at(pos).\n+        JCClassDecl result = S.endDecl(toP(F.at(pos).\n@@ -4531,1 +4493,1 @@\n-                     null, implementing, defs));\n+                     null, implementing, defs)));\n@@ -4673,1 +4635,1 @@\n-        JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));\n+        JCTree result = S.endDecl(toP(F.at(pos).VarDef(mods, name, ident, create)));\n@@ -5100,1 +5062,1 @@\n-                    toP(F.at(pos).MethodDef(mods, name, type, typarams,\n+                    S.endDecl(toP(F.at(pos).MethodDef(mods, name, type, typarams,\n@@ -5102,1 +5064,1 @@\n-                                            body, defaultValue));\n+                                            body, defaultValue)));\n@@ -5611,1 +5573,2 @@\n-            preview.warnPreview(pos, feature);\n+            SimpleDiagnosticPosition diagPos = new SimpleDiagnosticPosition(pos);\n+            S.lintHandler().report(diagPos, lint -> preview.warnPreview(lint, diagPos, feature));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":30,"deletions":67,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import com.sun.tools.javac.tree.JCTree;\n@@ -106,0 +107,18 @@\n+\n+    \/**\n+     * Get the {@link LexicalLintHandler} associated with this instance.\n+     *\/\n+    LexicalLintHandler lintHandler();\n+\n+    \/**\n+     * Finish parsing a declaration that supports {@code @SuppressWarnings}.\n+     *\n+     * <p>\n+     * This is a convenience method for when the ending position equals {@code prevToken().endPos}.\n+     *\n+     * @param decl the newly parsed declaration\n+     * @return the given {@code decl} (for fluent chaining)\n+     *\/\n+    default <T extends JCTree> T endDecl(T decl) {\n+        return lintHandler().endDecl(decl, prevToken().endPos);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Lexer.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.parser;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.sun.tools.javac.code.DeferredLintHandler;\n+import com.sun.tools.javac.code.DeferredLintHandler.LintLogger;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n+\n+\/**\n+ * Stashes lint warnings suppressible via {@code @SuppressWarnings} and their source code\n+ * positions while we await the creation of the innermost containing declaration.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class LexicalLintHandler {\n+\n+    private final LinkedList<Report> reports = new LinkedList<>();\n+    private final ArrayList<DeclNode> declNodes = new ArrayList<>();\n+\n+    private boolean flushed;\n+\n+\/\/ Public API\n+\n+    \/**\n+     * Report a lexical warning subject to possible suppression by {@code @SuppressWarnings}.\n+     *\n+     * @param pos the lexical position at which the warning occurs\n+     * @param logger the warning callback\n+     *\/\n+    public void report(DiagnosticPosition pos, LintLogger logger) {\n+        addReport(new Report(pos.getStartPosition(), logger));\n+    }\n+\n+    \/**\n+     * Report a lexical warning subject to possible suppression by {@code @SuppressWarnings}.\n+     *\n+     * @param pos the lexical position at which the warning occurs\n+     * @param key the warning to report\n+     *\/\n+    public void report(DiagnosticPosition pos, LintWarning key) {\n+        report(pos, lint -> lint.logIfEnabled(pos, key));\n+    }\n+\n+    \/**\n+     * Report the creation of a declaration that supports {@code @SuppressWarnings}.\n+     *\n+     * @param decl the newly parsed declaration\n+     * @param endPos the ending position of {@code decl} (exclusive)\n+     * @return the given {@code decl} (for fluent chaining)\n+     *\/\n+    public <T extends JCTree> T endDecl(T decl, int endPos) {\n+\n+        \/\/ Basic sanity checks\n+        Assert.check(!flushed);\n+        Assert.check(decl.getTag() == Tag.MODULEDEF\n+                  || decl.getTag() == Tag.PACKAGEDEF\n+                  || decl.getTag() == Tag.CLASSDEF\n+                  || decl.getTag() == Tag.METHODDEF\n+                  || decl.getTag() == Tag.VARDEF);\n+\n+        \/\/ Create new declaration node\n+        DeclNode declNode = new DeclNode(decl, endPos);\n+\n+        \/\/ Verify our assumptions about declarations:\n+        \/\/  1. If two declarations overlap, then one of them must nest within the other\n+        \/\/  2. endDecl() is invoked in order of increasing declaration ending position\n+        if (!declNodes.isEmpty()) {\n+            DeclNode prevNode = declNodes.get(declNodes.size() - 1);\n+            Assert.check(declNode.endPos() >= prevNode.endPos());\n+            Assert.check(declNode.startPos() >= prevNode.endPos() || declNode.startPos() <= prevNode.startPos());\n+        }\n+\n+        \/\/ Add node to the list\n+        declNodes.add(declNode);\n+        return decl;\n+    }\n+\n+    \/**\n+     * Flush all reported warnings to the given {@link DeferredLintHandler} in association\n+     * their innermost enclosing declaration, if any.\n+     *\n+     * <p>\n+     * This must be invoked at the end, after parsing a file. Once this method is invoked,\n+     * no further invocations of {@link #report} or {@link #endDecl} are allowed.\n+     *\/\n+    public void flushTo(DeferredLintHandler deferredLintHandler) {\n+        Assert.check(!flushed);\n+        flushed = true;\n+\n+        \/\/ Assign the innermost containing declaration, if any, to each report\n+        ListIterator<Report> reportIterator = reports.listIterator(0);\n+      declLoop:\n+        for (DeclNode declNode : declNodes) {\n+            while (true) {\n+                if (!reportIterator.hasNext())\n+                    break declLoop;\n+                Report report = reportIterator.next();\n+                switch (report.relativeTo(declNode)) {\n+                case BEFORE:        \/\/ report is contained by some outer declaration, or is \"top level\"\n+                    continue;\n+                case WITHIN:        \/\/ assign to this declaration, unless contained by an inner declaration\n+                    report.decl().compareAndSet(null, declNode.decl());\n+                    continue;\n+                case AFTER:         \/\/ we've gone too far, backup one step and go to the next declaration\n+                    reportIterator.previous();\n+                    continue declLoop;\n+                }\n+            }\n+        }\n+\n+        \/\/ Now flush all the reports\n+        reports.forEach(report -> report.flushTo(deferredLintHandler));\n+\n+        \/\/ Clean up\n+        reports.clear();\n+        declNodes.clear();\n+    }\n+\n+\/\/ Internal Methods\n+\n+    \/\/ Add a new report to our list, which we keep sorted by position, in the appropriate spot.\n+    \/\/ Reports are (usually? always?) generated in source position order, so this should be quick.\n+    private void addReport(Report report) {\n+        Assert.check(!flushed);\n+        ListIterator<Report> i = reports.listIterator(reports.size());\n+        while (i.hasPrevious()) {\n+            if (i.previous().pos() <= report.pos()) {\n+                i.next();\n+                break;\n+            }\n+        }\n+        i.add(report);\n+    }\n+\n+\/\/ DeclNode\n+\n+    \/\/ A declaration that has been created and whose starting and ending positions are known\n+    private record DeclNode(JCTree decl, int startPos, int endPos) {\n+\n+        DeclNode(JCTree decl, int endPos) {\n+            this(decl, TreeInfo.getStartPos(decl), endPos);\n+        }\n+    }\n+\n+\/\/ Report\n+\n+    \/\/ A warning report that has not yet been flushed to the DeferredLintHandler\n+    private record Report(int pos, LintLogger logger, AtomicReference<JCTree> decl) {\n+\n+        Report(int pos, LintLogger logger) {\n+            this(pos, logger, new AtomicReference<>());\n+        }\n+\n+        \/\/ Flush this report to the DeferredLintHandler using our assigned declaration (if any)\n+        void flushTo(DeferredLintHandler deferredLintHandler) {\n+            JCTree decl = decl().get();\n+            if (decl != null)\n+                deferredLintHandler.push(decl);\n+            try {\n+                deferredLintHandler.report(logger());\n+            } finally {\n+                if (decl != null)\n+                    deferredLintHandler.pop();\n+            }\n+        }\n+\n+        \/\/ Determine our position relative to the range spanned by the given declaration\n+        Direction relativeTo(DeclNode declNode) {\n+            int startPos = declNode.startPos();\n+            int endPos = declNode.endPos();\n+            if (pos() < startPos)\n+                return Direction.BEFORE;\n+            if (pos() == startPos || (pos() > startPos && pos() < endPos)) {\n+                return Direction.WITHIN;\n+            }\n+            return Direction.AFTER;\n+        }\n+    }\n+\n+\/\/ Direction\n+\n+    \/\/ Describes where a source code position lies relative to some range of positions\n+    private enum Direction {\n+        BEFORE,\n+        WITHIN,\n+        AFTER;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/LexicalLintHandler.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,0 +153,5 @@\n+    @Override\n+    public LexicalLintHandler lintHandler() {\n+        return tokenizer.lexicalLintHandler;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.code.Lint;\n@@ -65,1 +64,0 @@\n-    final Lint lint;\n@@ -77,1 +75,0 @@\n-        this.lint = Lint.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,4 @@\n+        \/** Our {@link LexicalLintHandler}. This is never flushed, so warnings are never realized.\n+         *\/\n+        private final LexicalLintHandler lintHandler = new LexicalLintHandler();\n+\n@@ -170,0 +174,5 @@\n+        @Override\n+        public LexicalLintHandler lintHandler() {\n+            return lintHandler;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.code.Lint;\n@@ -112,4 +113,0 @@\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n@@ -120,2 +117,2 @@\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc) {\n-        this(log, source, verbose, enforceMandatory, lc, null);\n+    public MandatoryWarningHandler(Log log, Source source, boolean enforceMandatory, LintCategory lc) {\n+        this(log, source, enforceMandatory, lc, null);\n@@ -129,4 +126,0 @@\n-     * @param verbose Specify whether or not detailed messages about\n-     *                individual instances should be given, or whether an aggregate\n-     *                message should be generated at the end of the compilation.\n-     *                Typically set via  -Xlint:option.\n@@ -139,1 +132,1 @@\n-    public MandatoryWarningHandler(Log log, Source source, boolean verbose, boolean enforceMandatory, LintCategory lc, String prefix) {\n+    public MandatoryWarningHandler(Log log, Source source, boolean enforceMandatory, LintCategory lc, String prefix) {\n@@ -142,1 +135,0 @@\n-        this.verbose = verbose;\n@@ -151,0 +143,1 @@\n+     * @param lint the applicable Lint configuration\n@@ -154,1 +147,1 @@\n-    public void report(DiagnosticPosition pos, LintWarning warnKey) {\n+    public void report(Lint lint, DiagnosticPosition pos, LintWarning warnKey) {\n@@ -158,1 +151,3 @@\n-        if (verbose) {\n+        if (lint.isSuppressed(lintCategory)) {\n+            return;\n+        } else if (lint.isEnabled(lintCategory)) {\n@@ -218,1 +213,1 @@\n-            if (!verbose)\n+            if (!anyWarningGenerated)\n@@ -229,6 +224,0 @@\n-    \/**\n-     * Whether or not to report individual warnings, or simply to report a\n-     * single aggregate warning at the end of the compilation.\n-     *\/\n-    private final boolean verbose;\n-\n@@ -270,0 +259,6 @@\n+    \/**\n+     * Whether we have actually logged a warning yet or just deferred everything.\n+     * In the latter case, the \"recompile\" notice is included in the summary.\n+     *\/\n+    private boolean anyWarningGenerated;\n+\n@@ -290,0 +285,1 @@\n+        anyWarningGenerated = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,0 @@\n-            \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-            \"- compiler.note.preview.recompile\",\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ErrorRecovery.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n-- compiler.note.preview.filename: ImplicitClassRecovery.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ImplicitClassRecovery.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify lexical lint warnings handle nested declarations with SuppressWarnings correctly\n+ * @compile\/fail\/ref=LexicalLintNesting.out -XDrawDiagnostics -Xlint:text-blocks -Werror LexicalLintNesting.java\n+ *\/\n+\n+\/\/@SuppressWarnings(\"text-blocks\")\n+public class LexicalLintNesting {\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s1 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s2 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    public static class Nested1 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s3 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s4 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested1A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s5 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s6 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s7 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s8 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested1B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s9 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            \/* WARNING HERE *\/ String s10 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s11 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s12 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s13 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s14 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Nested2 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s15 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s16 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested2A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s17 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s18 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s19 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s20 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested2B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s21 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s22 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s23 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s24 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s25 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s26 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+LexicalLintNesting.java:12:36: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:30:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:55:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:68:45: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:80:41: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:92:37: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:162:37: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+7 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.out","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify SuppressWarnings works for LintCategore.TEXT_BLOCKS\n+ * @compile\/fail\/ref=TextBlockSuppress.out -XDrawDiagnostics -Xlint:text-blocks -Werror TextBlockSuppress.java\n+ *\/\n+\n+public class TextBlockSuppress {\n+\n+    public static class Example1 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example2 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example3 {\n+        @SuppressWarnings(\"text-blocks\")\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example4 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example5 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example6 {\n+        public void method() {\n+            @SuppressWarnings(\"text-blocks\")\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+TextBlockSuppress.java:12:24: compiler.warn.trailing.white.space.will.be.removed\n+TextBlockSuppress.java:38:24: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,2 +193,2 @@\n-                List.of(\"Use.java:5:13: compiler.warn.is.preview: preview.api.Outer\",\n-                        \"Use.java:7:35: compiler.warn.is.preview: preview.api.Outer\",\n+                List.of(\"Use.java:7:35: compiler.warn.is.preview: preview.api.Outer\",\n+                        \"Use.java:5:13: compiler.warn.is.preview: preview.api.Outer\",\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewAutoSuppress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,1 +327,3 @@\n-                            if (lint == Lint.ENABLE_PREVIEW) {\n+                            if (suppress == Suppress.YES) {\n+                                expected = Set.of();\n+                            } else if (lint == Lint.ENABLE_PREVIEW) {\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -795,0 +795,93 @@\n+    @Test \/\/JDK-8224228:\n+    public void testSuppressWarnings(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public static int test() {\n+                                return 0;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.Preview;\n+                          public class Test {\n+\n+                            public static class Example1 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example2 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example3 {\n+                                @SuppressWarnings(\"preview\")\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example4 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example5 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example6 {\n+                                @SuppressWarnings(\"preview\")\n+                                int x = Preview.test();     \/\/ SHOULD NOT get a warning here\n+                            }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"--enable-preview\",\n+                         \"-Xlint:preview\",\n+                         \"-source\", String.valueOf(Runtime.version().feature()),\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:7:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"Test.java:27:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"2 warnings\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found: \" + log);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":94,"deletions":1,"binary":false,"changes":95,"status":"modified"}]}