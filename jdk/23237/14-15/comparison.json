{"files":[{"patch":"@@ -28,1 +28,1 @@\n-import java.util.ArrayDeque;\n+import java.util.ArrayList;\n@@ -31,0 +31,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -40,1 +41,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;\n@@ -54,1 +54,1 @@\n-    private final ArrayDeque<DeclNode> declNodes = new ArrayDeque<>();\n+    private final ArrayList<DeclNode> declNodes = new ArrayList<>();\n@@ -56,2 +56,0 @@\n-    private int lastFlushedStartPos;\n-    private int lastFlushedEndPos;\n@@ -90,0 +88,2 @@\n+\n+        \/\/ Basic sanity checks\n@@ -96,1 +96,15 @@\n-        declNodes.addLast(new DeclNode(decl, endPos));\n+\n+        \/\/ Create new declaration node\n+        DeclNode declNode = new DeclNode(decl, endPos);\n+\n+        \/\/ Verify our assumptions about declarations:\n+        \/\/  1. If two declarations overlap, then one of them must nest within the other\n+        \/\/  2. endDecl() is invoked in order of increasing declaration ending position\n+        if (!declNodes.isEmpty()) {\n+            DeclNode prevNode = declNodes.get(declNodes.size() - 1);\n+            Assert.check(declNode.endPos() >= prevNode.endPos());\n+            Assert.check(declNode.startPos() >= prevNode.endPos() || declNode.startPos() <= prevNode.startPos());\n+        }\n+\n+        \/\/ Add node to the list\n+        declNodes.add(declNode);\n@@ -112,3 +126,20 @@\n-        \/\/ Flush reports contained within any of the declaration nodes we have gathered\n-        declNodes.forEach(declNode -> flushDeclReports(deferredLintHandler, declNode));\n-        declNodes.clear();\n+        \/\/ Assign the innermost containing declaration, if any, to each report\n+        ListIterator<Report> reportIterator = reports.listIterator(0);\n+      declLoop:\n+        for (DeclNode declNode : declNodes) {\n+            while (true) {\n+                if (!reportIterator.hasNext())\n+                    break declLoop;\n+                Report report = reportIterator.next();\n+                switch (report.relativeTo(declNode)) {\n+                case BEFORE:        \/\/ report is contained by some outer declaration, or is \"top level\"\n+                    continue;\n+                case WITHIN:        \/\/ assign to this declaration, unless contained by an inner declaration\n+                    report.decl().compareAndSet(null, declNode.decl());\n+                    continue;\n+                case AFTER:         \/\/ we've gone too far, backup one step and go to the next declaration\n+                    reportIterator.previous();\n+                    continue declLoop;\n+                }\n+            }\n+        }\n@@ -116,2 +147,4 @@\n-        \/\/ Flush the remaining reports, which must be \"top level\" (i.e., not contained within any declaration)\n-        reports.forEach(report -> flushReport(deferredLintHandler, report));\n+        \/\/ Now flush all the reports\n+        reports.forEach(report -> report.flushTo(deferredLintHandler));\n+\n+        \/\/ Clean up\n@@ -119,0 +152,1 @@\n+        declNodes.clear();\n@@ -137,12 +171,1 @@\n-    \/\/ Flush all reports contained within the given declaration\n-    private void flushDeclReports(DeferredLintHandler deferredLintHandler, DeclNode declNode) {\n-\n-        \/\/ Get declaration's starting position so we know its lexical range\n-        int startPos = TreeInfo.getStartPos(declNode.decl());\n-        int endPos = declNode.endPos();\n-\n-        \/\/ Sanity check our assumptions about declarations:\n-        \/\/  1. If two declarations overlap, then one of them must nest within the other\n-        \/\/  2. endDecl() is always invoked in order of increasing declaration ending position\n-        Assert.check(endPos >= lastFlushedEndPos);\n-        Assert.check(startPos >= lastFlushedEndPos || startPos <= lastFlushedStartPos);\n+\/\/ DeclNode\n@@ -150,16 +173,2 @@\n-        \/\/ Find all reports contained by the declaration; they should all be at or near the end of the list\n-        ListIterator<Report> i = reports.listIterator(reports.size());\n-        int count = 0;\n-        while (i.hasPrevious()) {\n-            switch (i.previous().compareToRange(startPos, endPos)) {\n-            case AFTER:     \/\/ unusual; e.g., report is contained in the next token after declaration\n-                continue;\n-            case WITHIN:    \/\/ report is contained in the declaration, so we will flush it\n-                count++;\n-                continue;\n-            case BEFORE:    \/\/ we've gone too far, backup one step and start here\n-                i.next();\n-                break;\n-            }\n-            break;\n-        }\n+    \/\/ A declaration that has been created and whose starting and ending positions are known\n+    private record DeclNode(JCTree decl, int startPos, int endPos) {\n@@ -167,11 +176,2 @@\n-        \/\/ Flush the reports contained by the declaration (in order). Note, we know that it is the innermost\n-        \/\/ containing declaration because any more deeply nested declarations must have already been flushed\n-        \/\/ by now; this follows from the above assumptions.\n-        deferredLintHandler.push(declNode.decl());\n-        try {\n-            while (count-- > 0) {\n-                flushReport(deferredLintHandler, i.next());\n-                i.remove();\n-            }\n-        } finally {\n-            deferredLintHandler.pop();\n+        DeclNode(JCTree decl, int endPos) {\n+            this(decl, TreeInfo.getStartPos(decl), endPos);\n@@ -179,8 +179,0 @@\n-\n-        \/\/ Update markers\n-        lastFlushedStartPos = startPos;\n-        lastFlushedEndPos = endPos;\n-    }\n-\n-    private void flushReport(DeferredLintHandler deferredLintHandler, Report report) {\n-        deferredLintHandler.report(report.logger());\n@@ -189,5 +181,0 @@\n-\/\/ DeclNode\n-\n-    \/\/ A declaration that has been created and whose starting and ending positions are known\n-    private record DeclNode(JCTree decl, int endPos) { }\n-\n@@ -197,1 +184,18 @@\n-    private record Report(int pos, LintLogger logger) {\n+    private record Report(int pos, LintLogger logger, AtomicReference<JCTree> decl) {\n+\n+        Report(int pos, LintLogger logger) {\n+            this(pos, logger, new AtomicReference<>());\n+        }\n+\n+        \/\/ Flush this report to the DeferredLintHandler using our assigned declaration (if any)\n+        void flushTo(DeferredLintHandler deferredLintHandler) {\n+            JCTree decl = decl().get();\n+            if (decl != null)\n+                deferredLintHandler.push(decl);\n+            try {\n+                deferredLintHandler.report(logger());\n+            } finally {\n+                if (decl != null)\n+                    deferredLintHandler.pop();\n+            }\n+        }\n@@ -199,3 +203,5 @@\n-        \/\/ Compare our position to the given range\n-        Direction compareToRange(int minPos, int maxPos) {\n-            if (pos() < minPos)\n+        \/\/ Determine our position relative to the range spanned by the given declaration\n+        Direction relativeTo(DeclNode declNode) {\n+            int startPos = declNode.startPos();\n+            int endPos = declNode.endPos();\n+            if (pos() < startPos)\n@@ -203,1 +209,1 @@\n-            if (pos() == minPos || (pos() > minPos && pos() < maxPos)) {\n+            if (pos() == startPos || (pos() > startPos && pos() < endPos)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/LexicalLintHandler.java","additions":74,"deletions":68,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassBad-Filename.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClassHasPackage.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify lexical lint warnings handle nested declarations with SuppressWarnings correctly\n+ * @compile\/fail\/ref=LexicalLintNesting.out -XDrawDiagnostics -Xlint:text-blocks -Werror LexicalLintNesting.java\n+ *\/\n+\n+\/\/@SuppressWarnings(\"text-blocks\")\n+public class LexicalLintNesting {\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s1 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s2 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    public static class Nested1 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s3 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s4 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested1A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s5 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s6 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s7 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s8 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested1B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s9 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            \/* WARNING HERE *\/ String s10 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s11 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s12 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s13 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s14 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Nested2 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s15 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s16 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested2A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s17 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s18 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s19 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s20 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested2B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s21 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s22 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s23 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s24 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s25 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s26 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+LexicalLintNesting.java:12:36: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:30:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:55:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:68:45: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:80:41: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:92:37: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:162:37: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+7 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.out","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"}]}