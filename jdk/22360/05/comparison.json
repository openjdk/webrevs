{"files":[{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RBTREE_HPP\n+#define SHARE_UTILITIES_RBTREE_HPP\n+\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ COMPARATOR must have a static function `cmp(a,b)` which returns:\n+\/\/     - an int < 0 when a < b\n+\/\/     - an int == 0 when a == b\n+\/\/     - an int > 0 when a > b\n+\/\/ ALLOCATOR must check for oom and exit, as RBTree currently does not handle the\n+\/\/ allocation failing.\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+class RBTree {\n+  friend class RBTreeTest;\n+\n+private:\n+  ALLOCATOR _allocator;\n+  size_t _num_nodes;\n+\n+public:\n+  class RBNode {\n+    friend RBTree;\n+\n+  private:\n+    RBNode* _parent;\n+    RBNode* _left;\n+    RBNode* _right;\n+\n+    K _key;\n+    V _value;\n+\n+    enum Color : uint8_t { BLACK, RED };\n+    Color _color;\n+\n+  public:\n+    const K& key() const { return _key; }\n+    V& val() { return _value; }\n+\n+  private:\n+    bool is_black() const { return _color == BLACK; }\n+    bool is_red() const { return _color == RED; }\n+\n+    void color_black() { _color = BLACK; }\n+    void color_red() { _color = RED; }\n+\n+    RBNode(const K& k, const V& v)\n+        : _parent(nullptr), _left(nullptr), _right(nullptr),\n+          _key(k), _value(v), _color(RED) {}\n+\n+    bool is_right_child() const {\n+      return _parent != nullptr && _parent->_right == this;\n+    }\n+\n+    bool is_left_child() const {\n+      return _parent != nullptr && _parent->_left == this;\n+    }\n+\n+    void replace_child(RBNode* old_child, RBNode* new_child);\n+\n+    \/\/ Move node down to the left, and right child up\n+    RBNode* rotate_left();\n+\n+    \/\/ Move node down to the right, and left child up\n+    RBNode* rotate_right();\n+\n+    \/\/ Visit all RBNodes in ascending order.\n+    template <typename F>\n+    void visit_in_order_inner(F f);\n+\n+    \/\/ Visit all RBNodes in ascending order whose keys are in range [from, to).\n+    template <typename F>\n+    void visit_range_in_order_inner(const K& from, const K& to, F f);\n+\n+  #ifdef ASSERT\n+    bool is_correct(unsigned int num_blacks, unsigned int maximum_depth, unsigned int current_depth) const;\n+    size_t count_nodes() const;\n+  #endif \/\/ ASSERT\n+  };\n+\n+private:\n+  RBNode* _root;\n+\n+  RBNode* allocate_node(const K& k, const V& v) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode));\n+    if (node_place == nullptr) {\n+      return nullptr;\n+    }\n+    _num_nodes++;\n+    return new (node_place) RBNode(k, v);\n+  }\n+\n+  void free_node(RBNode* node) {\n+    _allocator.free(node);\n+    _num_nodes--;\n+  }\n+\n+  static inline bool is_black(RBNode* node) {\n+    return node == nullptr || node->is_black();\n+  }\n+\n+  static inline bool is_red(RBNode* node) {\n+    return node != nullptr && node->is_red();\n+  }\n+\n+  RBNode* find_node(RBNode* curr, const K& k);\n+\n+  RBNode* insert_node(const K& k, const V& v);\n+\n+  void fix_insert_violations(RBNode* node);\n+\n+  void remove_black_leaf(RBNode* node);\n+\n+  \/\/ Assumption: node has at most one child. Two children is handled in `remove()`\n+  void remove_from_tree(RBNode* node);\n+\n+  void remove_all_inner(RBNode* node);\n+\n+public:\n+  NONCOPYABLE(RBTree);\n+\n+  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) {}\n+  ~RBTree() { this->remove_all(); }\n+\n+  size_t size() { return _num_nodes; }\n+\n+  \/\/ Inserts a node with the given k\/v into the tree,\n+  \/\/ if the key already exist, the value is updated instead.\n+  void upsert(const K& k, const V& v) {\n+    RBNode* node = insert_node(k, v);\n+    fix_insert_violations(node);\n+  }\n+\n+  \/\/ Removes the node with the given key from the tree if it exists.\n+  \/\/ Returns true if the node was successfully removed, false otherwise.\n+  bool remove(const K& k) {\n+    RBNode* node = find_node(_root, k);\n+    return remove(node);\n+  }\n+\n+  \/\/ Removes the given node from the tree.\n+  \/\/ Returns true if the node was successfully removed, false otherwise.\n+  bool remove(RBNode* node);\n+\n+  \/\/ Removes all existing nodes from the tree.\n+  void remove_all() {\n+    remove_all_inner(_root);\n+    _num_nodes = 0;\n+    _root = nullptr;\n+  }\n+\n+  \/\/ Finds the node with the closest key <= the given key\n+  RBNode* closest_leq(const K& key) {\n+    RBNode* candidate = nullptr;\n+    RBNode* pos = _root;\n+    while (pos != nullptr) {\n+      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r == 0) { \/\/ Exact match\n+        candidate = pos;\n+        break; \/\/ Can't become better than that.\n+      }\n+      if (cmp_r < 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_right;\n+      } else if (cmp_r > 0) {\n+        pos = pos->_left;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  \/\/ Finds the node with the closest key > the given key\n+  RBNode* closest_gt(const K& key) {\n+    RBNode* candidate = nullptr;\n+    RBNode* pos = _root;\n+    while (pos != nullptr) {\n+      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r > 0) { \/\/ node > key\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_left;\n+      } else { \/\/ node <= key\n+        pos = pos->_right;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  struct Range {\n+    RBNode* start;\n+    RBNode* end;\n+    Range(RBNode* start, RBNode* end) : start(start), end(end) {}\n+  };\n+\n+  \/\/ Return the range [start, end)\n+  \/\/ where start->key() <= addr < end->key().\n+  \/\/ Failure to find the range leads to start and\/or end being nullptr.\n+  Range find_enclosing_range(K addr) {\n+    RBNode* start = closest_leq(addr);\n+    RBNode* end = closest_gt(addr);\n+    return Range(start, end);\n+  }\n+\n+  \/\/ Finds the value associated with the key\n+  V* find(K& key) {\n+    RBNode* node = find_node(_root, key);\n+    if (node == nullptr) {\n+      return nullptr;\n+    }\n+    return &node->val();\n+  }\n+\n+  \/\/ Visit all RBNodes in ascending order, calling f on each node.\n+  template <typename F>\n+  void visit_in_order(F f) const {\n+    _root->visit_in_order_inner(f);\n+  }\n+\n+  \/\/ Visit all RBNodes in ascending order whose keys are in range [from, to), calling f on each node.\n+  template <typename F>\n+  void visit_range_in_order(const K& from, const K& to, F f) {\n+    if (_root == nullptr) {\n+      return;\n+    }\n+    _root->visit_range_in_order_inner(from, to, f);\n+  }\n+\n+#ifdef ASSERT\n+  \/\/ Verifies that the tree is correct and holds rb-properties\n+  void verify_self();\n+#endif \/\/ ASSERT\n+\n+private:\n+  template<bool Forward>\n+  class IteratorImpl : public StackObj {\n+  private:\n+    const RBTree* const _tree;\n+    GrowableArrayCHeap<RBNode*, mtInternal> _to_visit;\n+    RBNode* _next;\n+\n+    void push_left(RBNode* node);\n+    void push_right(RBNode* node);\n+\n+  public:\n+    NONCOPYABLE(IteratorImpl);\n+\n+    IteratorImpl(const RBTree* tree) : _tree(tree) {\n+      Forward ? push_left(tree->_root) : push_right(tree->_root);\n+    }\n+\n+    bool has_next() { return !_to_visit.is_empty(); }\n+\n+    RBNode* next() {\n+      RBNode* node = _to_visit.pop();\n+      if (node != nullptr) {\n+        Forward ? push_left(node->_right) : push_right(node->_left);\n+      }\n+      return node;\n+    }\n+  };\n+\n+public:\n+  using Iterator = IteratorImpl<true>; \/\/ Forward iterator\n+  using ReverseIterator = IteratorImpl<false>; \/\/ Backward iterator\n+\n+};\n+\n+template <MemTag mt>\n+class RBTreeCHeapAllocator {\n+public:\n+  void* allocate(size_t sz) {\n+    void* allocation = os::malloc(sz, mt);\n+    if (allocation == nullptr) {\n+      vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR,\n+                            \"red-black tree failed allocation\");\n+    }\n+    return allocation;\n+  }\n+\n+  void free(void* ptr) { os::free(ptr); }\n+};\n+\n+template <typename K, typename V, typename COMPARATOR, MemTag mt>\n+using RBTreeCHeap = RBTree<K, V, COMPARATOR, RBTreeCHeapAllocator<mt>>;\n+\n+#endif \/\/ SHARE_UTILITIES_RBTREE_HPP\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,498 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RBTREE_INLINE_HPP\n+#define SHARE_UTILITIES_RBTREE_INLINE_HPP\n+\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/rbTree.hpp\"\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::replace_child(\n+    RBNode* old_child, RBNode* new_child) {\n+  if (_left == old_child) {\n+    _left = new_child;\n+  } else if (_right == old_child) {\n+    _right = new_child;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_left() {\n+  \/\/ Move node down to the left, and right child up\n+  RBNode* old_right = _right;\n+\n+  _right = old_right->_left;\n+  if (old_right->_left != nullptr) {\n+    old_right->_left->_parent = this;\n+  }\n+\n+  old_right->_parent = _parent;\n+  if (is_left_child()) {\n+    _parent->_left = old_right;\n+  } else if (is_right_child()) {\n+    _parent->_right = old_right;\n+  }\n+\n+  old_right->_left = this;\n+  _parent = old_right;\n+\n+  return old_right;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_right() {\n+  \/\/ Move node down to the right, and left child up\n+  RBNode* old_left = _left;\n+\n+  _left = old_left->_right;\n+  if (old_left->_right != nullptr) {\n+    old_left->_right->_parent = this;\n+  }\n+\n+  old_left->_parent = _parent;\n+  if (is_left_child()) {\n+    _parent->_left = old_left;\n+  } else if (is_right_child()) {\n+    _parent->_right = old_left;\n+  }\n+\n+  old_left->_right = this;\n+  _parent = old_left;\n+\n+  return old_left;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename F>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::visit_in_order_inner(F f) {\n+  if (_left != nullptr) {\n+    _left->visit_in_order_inner(f);\n+  }\n+  f(this);\n+  if (_right != nullptr) {\n+    _right->visit_in_order_inner(f);\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename F>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::visit_range_in_order_inner(\n+    const K& from, const K& to, F f) {\n+  int cmp_from = COMPARATOR::cmp(from, key());\n+  int cmp_to = COMPARATOR::cmp(to, key());\n+  if (_left != nullptr && cmp_from < 0) { \/\/ from < key\n+    _left->visit_range_in_order_inner(from, to, f);\n+  }\n+  if (cmp_from <= 0 && cmp_to > 0) { \/\/ from <= key && to > key\n+    f(this);\n+  }\n+  if (_right != nullptr && cmp_to > 0) { \/\/ to > key\n+    _right->visit_range_in_order_inner(from, to, f);\n+  }\n+}\n+\n+#ifdef ASSERT\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline bool RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::is_correct(\n+  unsigned int num_blacks, unsigned int maximum_depth, unsigned int current_depth) const {\n+  if (current_depth > maximum_depth) {\n+    return false;\n+  }\n+\n+  if (is_black()) {\n+    num_blacks--;\n+  }\n+\n+  bool left_is_correct = num_blacks == 0;\n+  bool right_is_correct = num_blacks == 0;\n+  if (_left != nullptr) {\n+    if (COMPARATOR::cmp(_left->key(), _key) >= 0 || \/\/ left >= root, or\n+        (is_red() && _left->is_red()) ||            \/\/ 2 red nodes, or\n+        (_left->_parent != this)) {                 \/\/ Pointer mismatch,\n+      return false;                                 \/\/ all incorrect.\n+    }\n+    left_is_correct = _left->is_correct(num_blacks, maximum_depth, current_depth++);\n+  }\n+  if (_right != nullptr) {\n+    if (COMPARATOR::cmp(_right->key(), _key) <= 0 || \/\/ right <= root, or\n+        (is_red() && _left->is_red()) ||             \/\/ 2 red nodes, or\n+        (_right->_parent != this)) {                 \/\/ Pointer mismatch,\n+      return false;                                  \/\/ all incorrect.\n+    }\n+    right_is_correct = _right->is_correct(num_blacks, maximum_depth, current_depth++);\n+  }\n+  return left_is_correct && right_is_correct;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline size_t RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::count_nodes() const {\n+  size_t left_nodes = _left == nullptr ? 0 : _left->count_nodes();\n+  size_t right_nodes = _right == nullptr ? 0 : _right->count_nodes();\n+  return 1 + left_nodes + right_nodes;\n+}\n+\n+#endif \/\/ ASSERT\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(RBNode* curr, const K& k) {\n+  while (curr != nullptr) {\n+    int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n+\n+    if (key_cmp_k == 0) {       \/\/ k == key\n+      return curr;\n+    } else if (key_cmp_k < 0) { \/\/ k < key\n+      curr = curr->_left;\n+    } else {                    \/\/ k > key\n+      curr = curr->_right;\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& k, const V& v) {\n+  RBNode* curr = _root;\n+  if (curr == nullptr) { \/\/ Tree is empty\n+    _root = allocate_node(k, v);\n+    return _root;\n+  }\n+\n+  RBNode* parent = nullptr;\n+  while (curr != nullptr) {\n+    int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n+\n+    if (key_cmp_k == 0) { \/\/ k == key\n+      curr->_value = v;\n+      return curr;\n+    }\n+\n+    parent = curr;\n+    if (key_cmp_k < 0) { \/\/ k < key\n+      curr = curr->_left;\n+    } else {             \/\/ k > key\n+      curr = curr->_right;\n+    }\n+  }\n+\n+  \/\/ Create and insert new node\n+  RBNode* node = allocate_node(k, v);\n+  node->_parent = parent;\n+\n+  int key_cmp_k = COMPARATOR::cmp(k, parent->key());\n+  if (key_cmp_k < 0) { \/\/ k < key\n+    parent->_left = node;\n+  } else {             \/\/ k > key\n+    parent->_right = node;\n+  }\n+\n+  return node;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::fix_insert_violations(RBNode* node) {\n+  if (node->is_black()) { \/\/ node's value was updated\n+    return;               \/\/ Tree is already correct\n+  }\n+\n+  RBNode* parent = node->_parent;\n+  while (parent != nullptr && parent->is_red()) {\n+    \/\/ Node and parent are both red, creating a red-violation\n+\n+    RBNode* grandparent = parent->_parent;\n+    if (grandparent == nullptr) { \/\/ Parent is the tree root\n+      assert(parent == _root, \"parent must be root\");\n+      parent->color_black(); \/\/ Color parent black to eliminate the red-violation\n+      return;\n+    }\n+\n+    RBNode* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n+    if (is_black(uncle)) { \/\/ Parent is red, uncle is black\n+      \/\/ Rotate the parent to the position of the grandparent\n+      if (parent->is_left_child()) {\n+        if (node->is_right_child()) { \/\/ Node is an \"inner\" node\n+          \/\/ Rotate and swap node and parent to make it an \"outer\" node\n+          parent->rotate_left();\n+          parent = node;\n+        }\n+        grandparent->rotate_right(); \/\/ Rotate the parent to the position of the grandparent\n+      } else if (parent->is_right_child()) {\n+        if (node->is_left_child()) { \/\/ Node is an \"inner\" node\n+          \/\/ Rotate and swap node and parent to make it an \"outer\" node\n+          parent->rotate_right();\n+          parent = node;\n+        }\n+        grandparent->rotate_left(); \/\/ Rotate the parent to the position of the grandparent\n+      }\n+\n+      \/\/ Swap parent and grandparent colors to eliminate the red-violation\n+      parent->color_black();\n+      grandparent->color_red();\n+\n+      if (_root == grandparent) {\n+        _root = parent;\n+      }\n+\n+      return;\n+    }\n+\n+    \/\/ Parent and uncle are both red\n+    \/\/ Paint both black, paint grandparent red to not create a black-violation\n+    parent->color_black();\n+    uncle->color_black();\n+    grandparent->color_red();\n+\n+    \/\/ Move up two levels to check for new potential red-violation\n+    node = grandparent;\n+    parent = grandparent->_parent;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_black_leaf(RBNode* node) {\n+  \/\/ Black node removed, balancing needed\n+  RBNode* parent = node->_parent;\n+  while (parent != nullptr) {\n+    \/\/ Sibling must exist. If it did not, node would need to be red to not break\n+    \/\/ tree properties, and could be trivially removed before reaching here\n+    RBNode* sibling = node->is_left_child() ? parent->_right : parent->_left;\n+    if (is_red(sibling)) { \/\/ Sibling red, parent and nephews must be black\n+      assert(is_black(parent), \"parent must be black\");\n+      assert(is_black(sibling->_left), \"nephew must be black\");\n+      assert(is_black(sibling->_right), \"nephew must be black\");\n+      \/\/ Swap parent and sibling colors\n+      parent->color_red();\n+      sibling->color_black();\n+\n+      \/\/ Rotate parent down and sibling up\n+      if (node->is_left_child()) {\n+        parent->rotate_left();\n+        sibling = parent->_right;\n+      } else {\n+        parent->rotate_right();\n+        sibling = parent->_left;\n+      }\n+\n+      if (_root == parent) {\n+        _root = parent->_parent;\n+      }\n+      \/\/ Further balancing needed\n+    }\n+\n+    RBNode* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n+    RBNode* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n+    if (is_red(distant_nephew) || is_red(close_nephew)) {\n+      if (is_black(distant_nephew)) { \/\/ close red, distant black\n+        \/\/ Rotate sibling down and inner nephew up\n+        if (node->is_left_child()) {\n+          sibling->rotate_right();\n+        } else {\n+          sibling->rotate_left();\n+        }\n+\n+        distant_nephew = sibling;\n+        sibling = close_nephew;\n+\n+        distant_nephew->color_red();\n+        sibling->color_black();\n+      }\n+\n+      \/\/ Distant nephew red\n+      \/\/ Rotate parent down and sibling up\n+      if (node->is_left_child()) {\n+        parent->rotate_left();\n+      } else {\n+        parent->rotate_right();\n+      }\n+      if (_root == parent) {\n+        _root = sibling;\n+      }\n+\n+      \/\/ Swap parent and sibling colors\n+      if (parent->is_black()) {\n+        sibling->color_black();\n+      } else {\n+        sibling->color_red();\n+      }\n+      parent->color_black();\n+      if (sibling->is_black()) {\n+      }\n+\n+      \/\/ Color distant nephew black to restore black balance\n+      distant_nephew->color_black();\n+      return;\n+    }\n+\n+    if (is_red(parent)) { \/\/ parent red, sibling and nephews black\n+      \/\/ Swap parent and sibling colors to restore black balance\n+      sibling->color_red();\n+      parent->color_black();\n+      return;\n+    }\n+\n+    \/\/ Parent, sibling, and both nephews black\n+    \/\/ Color sibling red and move up one level\n+    sibling->color_red();\n+    node = parent;\n+    parent = node->_parent;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_from_tree(RBNode* node) {\n+  RBNode* parent = node->_parent;\n+  RBNode* left = node->_left;\n+  RBNode* right = node->_right;\n+  if (left != nullptr) { \/\/ node has a left only-child\n+    \/\/ node must be black, and child red, otherwise a black-violation would\n+    \/\/ exist Remove node and color the child black.\n+    assert(right == nullptr, \"right must be nullptr\");\n+    assert(is_black(node), \"node must be black\");\n+    assert(is_red(left), \"child must be red\");\n+    left->color_black();\n+    left->_parent = parent;\n+    if (parent == nullptr) {\n+      assert(node == _root, \"node must be root\");\n+      _root = left;\n+    } else {\n+      parent->replace_child(node, left);\n+    }\n+  } else if (right != nullptr) { \/\/ node has a right only-child\n+    \/\/ node must be black, and child red, otherwise a black-violation would\n+    \/\/ exist Remove node and color the child black.\n+    assert(left == nullptr, \"left must be nullptr\");\n+    assert(is_black(node), \"node must be black\");\n+    assert(is_red(right), \"child must be red\");\n+    right->color_black();\n+    right->_parent = parent;\n+    if (parent == nullptr) {\n+      assert(node == _root, \"node must be root\");\n+      _root = right;\n+    } else {\n+      parent->replace_child(node, right);\n+    }\n+  } else {               \/\/ node has no children\n+    if (node == _root) { \/\/ Tree empty\n+      _root = nullptr;\n+    } else {\n+      if (is_black(node)) {\n+        \/\/ Removed node is black, creating a black imbalance\n+        remove_black_leaf(node);\n+      }\n+      parent->replace_child(node, nullptr);\n+    }\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_all_inner(RBNode* node) {\n+  if (node == nullptr) {\n+    return;\n+  }\n+  remove_all_inner(node->_left);\n+  remove_all_inner(node->_right);\n+  free_node(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline bool RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n+  if (node == nullptr) {\n+    return false;\n+  }\n+\n+  if (node->_left != nullptr && node->_right != nullptr) { \/\/ node has two children\n+    \/\/ Copy the k\/v from the in-order successor and delete that node instead\n+    RBNode* curr = node->_right;\n+    while (curr->_left != nullptr) {\n+      curr = curr->_left;\n+    }\n+    node->_key = curr->key();\n+    node->_value = curr->val();\n+\n+    node = curr;\n+  }\n+\n+  remove_from_tree(node);\n+  free_node(node);\n+  return true;\n+}\n+\n+#ifdef ASSERT\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::verify_self() {\n+  if (_root == nullptr) {\n+    assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n+    return;\n+  }\n+\n+  assert(_root->_parent == nullptr, \"root of rbtree has a parent\");\n+\n+  unsigned int black_nodes = 0;\n+  RBNode* node = _root;\n+  while (node != nullptr) {\n+    if (node->is_black()) {\n+      black_nodes++;\n+    }\n+    node = node->_left;\n+  }\n+\n+  const size_t actual_num_nodes = _root->count_nodes();\n+  const size_t expected_num_nodes = size();\n+  const unsigned int maximum_depth = log2i(size() + 1) * 2;\n+\n+  assert(expected_num_nodes == actual_num_nodes,\n+         \"unexpected number of nodes in rbtree. expected: \" SIZE_FORMAT\n+         \", actual: \" SIZE_FORMAT, expected_num_nodes, actual_num_nodes);\n+  assert(2 * black_nodes <= maximum_depth,\n+         \"rbtree is too deep for its number of nodes. can be at \"\n+         \"most: \" INT32_FORMAT \", but is: \" UINT32_FORMAT, maximum_depth, 2 * black_nodes);\n+  assert(_root->is_correct(black_nodes, maximum_depth, 1), \"rbtree does not hold rb-properties\");\n+}\n+#endif \/\/ ASSERT\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <bool Forward>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::IteratorImpl<Forward>::push_left(RBNode* node) {\n+  while (node != nullptr) {\n+    _to_visit.push(node);\n+    node = node->_left;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <bool Forward>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::IteratorImpl<Forward>::push_right(RBNode* node) {\n+  while (node != nullptr) {\n+    _to_visit.push(node);\n+    node = node->_right;\n+  }\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_RBTREE_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":498,"deletions":0,"binary":false,"changes":498,"status":"added"},{"patch":"@@ -0,0 +1,435 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/rbTree.inline.hpp\"\n+\n+\n+class RBTreeTest : public testing::Test {\n+public:\n+  struct Cmp {\n+    static int cmp(int a, int b) {\n+      return a - b;\n+    }\n+  };\n+\n+  struct CmpInverse {\n+    static int cmp(int a, int b) {\n+      return b - a;\n+    }\n+  };\n+\n+  struct FCmp {\n+    static int cmp(float a, float b) {\n+      if (a < b) return -1;\n+      if (a == b) return 0;\n+      return 1;\n+    }\n+  };\n+\n+#ifdef ASSERT\n+  template<typename K, typename V, typename CMP, typename ALLOC>\n+  void verify_it(RBTree<K, V, CMP, ALLOC>& t) {\n+    t.verify_self();\n+  }\n+#endif \/\/ ASSERT\n+\n+using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtOther>;\n+\n+public:\n+  void inserting_duplicates_results_in_one_value() {\n+    constexpr const int up_to = 10;\n+    GrowableArrayCHeap<int, mtTest> nums_seen(up_to, up_to, 0);\n+    RBTreeInt rbtree;\n+\n+    for (int i = 0; i < up_to; i++) {\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+    }\n+\n+    rbtree.visit_in_order([&](RBTreeInt::RBNode* node) {\n+      nums_seen.at(node->key())++;\n+    });\n+    for (int i = 0; i < up_to; i++) {\n+      EXPECT_EQ(1, nums_seen.at(i));\n+    }\n+  }\n+\n+  void rbtree_ought_not_leak() {\n+    struct LeakCheckedAllocator {\n+      int allocations;\n+\n+      LeakCheckedAllocator()\n+        : allocations(0) {\n+      }\n+\n+      void* allocate(size_t sz) {\n+        void* allocation = os::malloc(sz, mtTest);\n+        if (allocation == nullptr) {\n+          vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, \"rbtree failed allocation\");\n+        }\n+        ++allocations;\n+        return allocation;\n+      }\n+\n+      void free(void* ptr) {\n+        --allocations;\n+        os::free(ptr);\n+      }\n+    };\n+\n+    constexpr const int up_to = 10;\n+    {\n+      RBTree<int, int, Cmp, LeakCheckedAllocator> rbtree;\n+      for (int i = 0; i < up_to; i++) {\n+        rbtree.upsert(i, i);\n+      }\n+      EXPECT_EQ(up_to, rbtree._allocator.allocations);\n+      for (int i = 0; i < up_to; i++) {\n+        rbtree.remove(i);\n+      }\n+      EXPECT_EQ(0, rbtree._allocator.allocations);\n+      EXPECT_EQ(nullptr, rbtree._root);\n+    }\n+\n+    {\n+      RBTree<int, int, Cmp, LeakCheckedAllocator> rbtree;\n+      for (int i = 0; i < up_to; i++) {\n+        rbtree.upsert(i, i);\n+      }\n+      rbtree.remove_all();\n+      EXPECT_EQ(0, rbtree._allocator.allocations);\n+      EXPECT_EQ(nullptr, rbtree._root);\n+    }\n+  }\n+\n+  void test_find() {\n+    struct Empty {};\n+    RBTreeCHeap<float, Empty, FCmp, mtOther> rbtree;\n+    using Node = RBTreeCHeap<float, Empty, FCmp, mtOther>::RBNode;\n+\n+    Node* n = nullptr;\n+    auto test = [&](float f) {\n+      EXPECT_EQ(nullptr, rbtree.find(f));\n+      rbtree.upsert(f, Empty{});\n+      Node* n = rbtree.find_node(rbtree._root, f);\n+      EXPECT_NE(nullptr, n);\n+      EXPECT_EQ(f, n->key());\n+    };\n+\n+    test(1.0f);\n+    test(5.0f);\n+    test(0.0f);\n+  }\n+\n+  void test_visitors() {\n+    { \/\/ Tests with 'default' ordering (ascending)\n+      RBTreeInt rbtree;\n+      using Node = RBTreeInt::RBNode;\n+\n+      rbtree.visit_range_in_order(0, 100, [&](Node* x) {\n+        EXPECT_TRUE(false) << \"Empty rbtree has no nodes to visit\";\n+      });\n+\n+      \/\/ Single-element set\n+      rbtree.upsert(1, 0);\n+      int count = 0;\n+      rbtree.visit_range_in_order(0, 100, [&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(1, count);\n+\n+      count = 0;\n+      rbtree.visit_in_order([&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(1, count);\n+\n+      \/\/ Add an element outside of the range that should not be visited on the right side and\n+      \/\/ one on the left side.\n+      rbtree.upsert(101, 0);\n+      rbtree.upsert(-1, 0);\n+      count = 0;\n+      rbtree.visit_range_in_order(0, 100, [&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(1, count);\n+\n+      count = 0;\n+      rbtree.visit_in_order([&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(3, count);\n+\n+      \/\/ Visiting empty range [0, 0) == {}\n+      rbtree.upsert(0, 0); \/\/ This node should not be visited.\n+      rbtree.visit_range_in_order(0, 0, [&](Node* x) {\n+        EXPECT_TRUE(false) << \"Empty visiting range should not visit any node\";\n+      });\n+\n+      rbtree.remove_all();\n+      for (int i = 0; i < 11; i++) {\n+        rbtree.upsert(i, 0);\n+      }\n+\n+      ResourceMark rm;\n+      GrowableArray<int> seen;\n+      rbtree.visit_range_in_order(0, 10, [&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(10, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(i, seen.at(i));\n+      }\n+\n+      seen.clear();\n+      rbtree.visit_in_order([&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(11, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(i, seen.at(i));\n+      }\n+\n+      seen.clear();\n+      rbtree.visit_range_in_order(10, 12, [&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(1, seen.length());\n+      EXPECT_EQ(10, seen.at(0));\n+    }\n+    { \/\/ Test with descending ordering\n+      RBTreeCHeap<int, int, CmpInverse, mtOther> rbtree;\n+      using Node = RBTreeCHeap<int, int, CmpInverse, mtOther>::RBNode;\n+\n+      for (int i = 0; i < 10; i++) {\n+        rbtree.upsert(i, 0);\n+      }\n+      ResourceMark rm;\n+      GrowableArray<int> seen;\n+      rbtree.visit_range_in_order(9, -1, [&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(10, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(10-i-1, seen.at(i));\n+      }\n+      seen.clear();\n+\n+      rbtree.visit_in_order([&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(10, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(10 - i - 1, seen.at(i));\n+      }\n+    }\n+  }\n+\n+  void test_closest_leq() {\n+    using Node = RBTreeInt::RBNode;\n+    {\n+      RBTreeInt rbtree;\n+      Node* n = rbtree.closest_leq(0);\n+      EXPECT_EQ(nullptr, n);\n+\n+      rbtree.upsert(0, 0);\n+      n = rbtree.closest_leq(0);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(-1, -1);\n+      n = rbtree.closest_leq(0);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(6, 0);\n+      n = rbtree.closest_leq(6);\n+      EXPECT_EQ(6, n->key());\n+\n+      n = rbtree.closest_leq(-2);\n+      EXPECT_EQ(nullptr, n);\n+    }\n+  }\n+\n+  void test_iterator() {\n+    constexpr const int num_nodes = 100;\n+    RBTreeInt tree;\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    RBTreeInt::Iterator iterator(&tree);\n+    for (int n = 0; n <= num_nodes; n++) {\n+      EXPECT_TRUE(iterator.has_next());\n+      EXPECT_EQ(iterator.next()->val(), n);\n+    }\n+\n+    RBTreeInt::ReverseIterator reverse_iterator(&tree);\n+    for (int n = num_nodes; n >= 0; n--) {\n+      EXPECT_TRUE(reverse_iterator.has_next());\n+      EXPECT_EQ(reverse_iterator.next()->val(), n);\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  void test_fill_verify() {\n+    RBTreeInt rbtree;\n+\n+    ResourceMark rm;\n+    GrowableArray<int> allocations;\n+\n+    int size = 10000;\n+    \/\/ Create random values\n+    for (int i = 0; i < size; i++) {\n+      int r = os::random() % size;\n+      allocations.append(r);\n+    }\n+\n+    \/\/ Insert ~half of the values\n+    for (int i = 0; i < size; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(allocations.at(i), allocations.at(i));\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+\n+    \/\/ Insert and remove randomly\n+    for (int i = 0; i < size; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(allocations.at(i), allocations.at(i));\n+      } else {\n+        rbtree.remove(allocations.at(i));\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+\n+    \/\/ Remove all elements\n+    for (int i = 0; i < size; i++) {\n+      rbtree.remove(allocations.at(i));\n+    }\n+\n+    verify_it(rbtree);\n+    EXPECT_EQ(rbtree.size(), 0UL);\n+  }\n+#endif \/\/ ASSERT\n+\n+};\n+\n+TEST_VM_F(RBTreeTest, InsertingDuplicatesResultsInOneValue) {\n+  this->inserting_duplicates_results_in_one_value();\n+}\n+\n+TEST_VM_F(RBTreeTest, RBTreeOughtNotLeak) {\n+  this->rbtree_ought_not_leak();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestFind) {\n+  this->test_find();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestVisitors) {\n+  this->test_visitors();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestClosestLeq) {\n+  this->test_closest_leq();\n+}\n+\n+TEST_VM_F(RBTreeTest, IteratorTest) {\n+  this->test_iterator();\n+}\n+\n+#ifdef ASSERT\n+TEST_VM_F(RBTreeTest, FillAndVerify) {\n+  this->test_fill_verify();\n+}\n+\n+TEST_VM_F(RBTreeTest, InsertRemoveVerify) {\n+  constexpr const int num_nodes = 100;\n+  for (int n_t1 = 0; n_t1 < num_nodes; n_t1++) {\n+    for (int n_t2 = 0; n_t2 < n_t1; n_t2++) {\n+      RBTreeInt tree;\n+      for (int i = 0; i < n_t1; i++) {\n+        tree.upsert(i, i);\n+      }\n+      for (int i = 0; i < n_t2; i++) {\n+        tree.remove(i);\n+      }\n+      verify_it(tree);\n+    }\n+  }\n+}\n+\n+TEST_VM_F(RBTreeTest, VerifyItThroughStressTest) {\n+  { \/\/ Repeatedly verify a tree of moderate size\n+    RBTreeInt rbtree;\n+    constexpr const int ten_thousand = 10000;\n+    for (int i = 0; i < ten_thousand; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(i, i);\n+      } else {\n+        rbtree.remove(i);\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+    for (int i = 0; i < ten_thousand; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(i, i);\n+      } else {\n+        rbtree.remove(i);\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+  }\n+  { \/\/ Make a very large tree and verify at the end\n+  struct Nothing {};\n+    RBTreeCHeap<int, Nothing, Cmp, mtOther> rbtree;\n+    constexpr const int one_hundred_thousand = 100000;\n+    for (int i = 0; i < one_hundred_thousand; i++) {\n+      rbtree.upsert(i, Nothing());\n+    }\n+    verify_it(rbtree);\n+  }\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":435,"deletions":0,"binary":false,"changes":435,"status":"added"}]}