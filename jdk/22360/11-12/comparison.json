{"files":[{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -58,1 +57,1 @@\n-    RBNode* _parent;\n+    uintptr_t _parent; \/\/ LSB encodes color information. 0 = RED, 1 = BLACK\n@@ -65,2 +64,1 @@\n-    enum Color : uint8_t { BLACK, RED };\n-    Color _color;\n+    DEBUG_ONLY(bool _visited);\n@@ -71,0 +69,1 @@\n+    const V& val() const { return _value; }\n@@ -73,2 +72,2 @@\n-    bool is_black() const { return _color == BLACK; }\n-    bool is_red() const { return _color == RED; }\n+    bool is_black() const { return (_parent & 0x1) != 0; }\n+    bool is_red() const { return (_parent & 0x1) == 0; }\n@@ -76,2 +75,2 @@\n-    void set_black() { _color = BLACK; }\n-    void set_red() { _color = RED; }\n+    void set_black() { _parent = _parent | 0x1; }\n+    void set_red() { _parent = _parent & ~0x1; }\n@@ -79,3 +78,6 @@\n-    RBNode(const K& k, const V& v)\n-        : _parent(nullptr), _left(nullptr), _right(nullptr),\n-          _key(k), _value(v), _color(RED) {}\n+    RBNode* parent() const { return (RBNode*)(_parent & ~0x1); }\n+    void set_parent(RBNode* new_parent) {_parent = (_parent & 0x1) | ((uintptr_t)new_parent & ~0x1); }\n+\n+    RBNode(const K& k, const V& v DEBUG_ONLY(COMMA bool visited))\n+        : _parent(0), _left(nullptr), _right(nullptr),\n+          _key(k), _value(v) DEBUG_ONLY(COMMA _visited(visited)) {}\n@@ -84,1 +86,1 @@\n-      return _parent != nullptr && _parent->_right == this;\n+      return parent() != nullptr && parent()->_right == this;\n@@ -88,1 +90,1 @@\n-      return _parent != nullptr && _parent->_left == this;\n+      return parent() != nullptr && parent()->_left == this;\n@@ -93,1 +95,2 @@\n-    \/\/ Move node down to the left, and right child up\n+    \/\/ This node down, right child up\n+    \/\/ Returns right child (now parent)\n@@ -96,1 +99,2 @@\n-    \/\/ Move node down to the right, and left child up\n+    \/\/ This node down, left child up\n+    \/\/ Returns left child (now parent)\n@@ -99,0 +103,4 @@\n+    RBNode* prev();\n+\n+    RBNode* next();\n+\n@@ -100,3 +108,4 @@\n-    bool is_correct(unsigned int num_blacks, unsigned int maximum_depth, unsigned int current_depth) const;\n-    size_t count_nodes() const;\n-  #endif \/\/ ASSERT\n+    void verify(size_t& num_nodes, size_t& black_nodes_until_leaf,\n+                size_t& shortest_leaf_path, size_t& longest_leaf_path,\n+                size_t& tree_depth, bool expect_visited);\n+#endif \/\/ ASSERT\n@@ -107,0 +116,1 @@\n+  DEBUG_ONLY(bool _expected_visited);\n@@ -112,1 +122,1 @@\n-    return new (node_place) RBNode(k, v);\n+    return new (node_place) RBNode(k, v DEBUG_ONLY(COMMA _expected_visited));\n@@ -144,1 +154,1 @@\n-  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) {\n+  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n@@ -162,1 +172,5 @@\n-    return remove(node);\n+    if (node == nullptr){\n+      return false;\n+    }\n+    remove(node);\n+    return true;\n@@ -165,3 +179,2 @@\n-  \/\/ Removes the given node from the tree.\n-  \/\/ Returns true if the node was successfully removed, false otherwise.\n-  bool remove(RBNode* node);\n+  \/\/ Removes the given node from the tree. node must be a valid node\n+  void remove(RBNode* node);\n@@ -171,2 +184,3 @@\n-    GrowableArrayCHeap<RBNode*, mtInternal> to_delete(2 * log2i(_num_nodes + 1));\n-    to_delete.push(_root);\n+    RBNode* to_delete[64];\n+    int stack_idx = 0;\n+    to_delete[stack_idx++] = _root;\n@@ -174,2 +188,2 @@\n-    while (!to_delete.is_empty()) {\n-      RBNode* head = to_delete.pop();\n+    while (stack_idx > 0) {\n+      RBNode* head = to_delete[--stack_idx];\n@@ -177,2 +191,2 @@\n-      to_delete.push(head->_left);\n-      to_delete.push(head->_right);\n+      to_delete[stack_idx++] = head->_left;\n+      to_delete[stack_idx++] = head->_right;\n@@ -185,0 +199,3 @@\n+  \/\/ Alters behaviour of closest_(leq\/gt) functions to include\/exclude the exact value\n+  enum BoundMode : uint8_t { STRICT, INCLUSIVE };\n+\n@@ -186,1 +203,2 @@\n-  RBNode* closest_leq(const K& key) {\n+  \/\/ Change mode to EXCLUSIVE to not include node matching key\n+  RBNode* closest_leq(const K& key, BoundMode mode = INCLUSIVE) {\n@@ -191,1 +209,1 @@\n-      if (cmp_r == 0) { \/\/ Exact match\n+      if (mode == INCLUSIVE && cmp_r == 0) { \/\/ Exact match\n@@ -199,1 +217,1 @@\n-      } else if (cmp_r > 0) {\n+      } else {\n@@ -207,1 +225,2 @@\n-  RBNode* closest_gt(const K& key) {\n+  \/\/ Change mode to STRICT to include node matching key\n+  RBNode* closest_gt(const K& key, BoundMode mode = STRICT) {\n@@ -212,1 +231,5 @@\n-      if (cmp_r > 0) { \/\/ node > key\n+      if (mode == INCLUSIVE && cmp_r == 0) { \/\/ Exact match\n+        candidate = pos;\n+        break; \/\/ Can't become better than that.\n+      }\n+      if (cmp_r > 0) {\n@@ -216,1 +239,1 @@\n-      } else { \/\/ node <= key\n+      } else {\n@@ -223,15 +246,0 @@\n-  struct Range {\n-    RBNode* start;\n-    RBNode* end;\n-    Range(RBNode* start, RBNode* end) : start(start), end(end) {}\n-  };\n-\n-  \/\/ Return the range [start, end)\n-  \/\/ where start->key() <= addr < end->key().\n-  \/\/ Failure to find the range leads to start and\/or end being nullptr.\n-  Range find_enclosing_range(K addr) {\n-    RBNode* start = closest_leq(addr);\n-    RBNode* end = closest_gt(addr);\n-    return Range(start, end);\n-  }\n-\n@@ -247,0 +255,3 @@\n+  \/\/ Finds the value associated with the key\n+  const V* find(const K& key) const { return find(key); }\n+\n@@ -260,33 +271,0 @@\n-private:\n-  template<bool Forward>\n-  class IteratorImpl : public StackObj {\n-  private:\n-    const RBTree* const _tree;\n-    GrowableArrayCHeap<RBNode*, mtInternal> _to_visit;\n-\n-    void push_left(RBNode* node);\n-    void push_right(RBNode* node);\n-\n-  public:\n-    NONCOPYABLE(IteratorImpl);\n-\n-    IteratorImpl(const RBTree* tree) : _tree(tree) {\n-      _to_visit.reserve(2 * log2i(_tree->_num_nodes + 1));\n-      Forward ? push_left(tree->_root) : push_right(tree->_root);\n-    }\n-\n-    bool has_next() { return !_to_visit.is_empty(); }\n-\n-    RBNode* next() {\n-      RBNode* node = _to_visit.pop();\n-      if (node != nullptr) {\n-        Forward ? push_left(node->_right) : push_right(node->_left);\n-      }\n-      return node;\n-    }\n-  };\n-\n-public:\n-  using Iterator = IteratorImpl<true>; \/\/ Forward iterator\n-  using ReverseIterator = IteratorImpl<false>; \/\/ Backward iterator\n-\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":62,"deletions":84,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+  } else {\n+    ShouldNotReachHere();\n@@ -45,1 +47,1 @@\n-  \/\/ Move node down to the left, and right child up\n+  \/\/ This node down, right child up\n@@ -49,2 +51,2 @@\n-  if (old_right->_left != nullptr) {\n-    old_right->_left->_parent = this;\n+  if (_right != nullptr) {\n+    _right->set_parent(this);\n@@ -53,5 +55,3 @@\n-  old_right->_parent = _parent;\n-  if (is_left_child()) {\n-    _parent->_left = old_right;\n-  } else if (is_right_child()) {\n-    _parent->_right = old_right;\n+  old_right->set_parent(parent());\n+  if (parent() != nullptr) {\n+    parent()->replace_child(this, old_right);\n@@ -61,1 +61,1 @@\n-  _parent = old_right;\n+  set_parent(old_right);\n@@ -69,1 +69,1 @@\n-  \/\/ Move node down to the right, and left child up\n+  \/\/ This node down, left child up\n@@ -73,2 +73,2 @@\n-  if (old_left->_right != nullptr) {\n-    old_left->_right->_parent = this;\n+  if (_left != nullptr) {\n+    _left->set_parent(this);\n@@ -77,5 +77,3 @@\n-  old_left->_parent = _parent;\n-  if (is_left_child()) {\n-    _parent->_left = old_left;\n-  } else if (is_right_child()) {\n-    _parent->_right = old_left;\n+  old_left->set_parent(parent());\n+  if (parent() != nullptr) {\n+    parent()->replace_child(this, old_left);\n@@ -85,1 +83,1 @@\n-  _parent = old_left;\n+  set_parent(old_left);\n@@ -90,1 +88,0 @@\n-#ifdef ASSERT\n@@ -92,4 +89,9 @@\n-inline bool RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::is_correct(\n-  unsigned int num_blacks, unsigned int maximum_depth, unsigned int current_depth) const {\n-  if (current_depth > maximum_depth) {\n-    return false;\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::prev() {\n+  RBNode* node = this;\n+  if (_left != nullptr) { \/\/ right subtree exists\n+    node = _left;\n+    while (node->_right != nullptr) {\n+      node = node->_right;\n+    }\n+    return node;\n@@ -98,2 +100,2 @@\n-  if (is_black()) {\n-    num_blacks--;\n+  while (node != nullptr && node->is_left_child()) {\n+    node = node->parent();\n@@ -101,0 +103,33 @@\n+  return node->parent();\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::next() {\n+  RBNode* node = this;\n+  if (_right != nullptr) { \/\/ right subtree exists\n+    node = _right;\n+    while (node->_left != nullptr) {\n+      node = node->_left;\n+    }\n+    return node;\n+  }\n+\n+  while (node != nullptr && node->is_right_child()) {\n+    node = node->parent();\n+  }\n+  return node->parent();\n+}\n+\n+#ifdef ASSERT\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::verify(\n+    size_t& num_nodes, size_t& black_nodes_until_leaf, size_t& shortest_leaf_path, size_t& longest_leaf_path,\n+    size_t& tree_depth, bool expect_visited) {\n+  assert(expect_visited != _visited, \"node already visited\");\n+  _visited = !_visited;\n+\n+  size_t num_black_nodes_left = 0;\n+  size_t shortest_leaf_path_left = 0;\n+  size_t longest_leaf_path_left = 0;\n+  size_t tree_depth_left = 0;\n@@ -102,2 +137,0 @@\n-  bool left_is_correct = num_blacks == 0;\n-  bool right_is_correct = num_blacks == 0;\n@@ -105,4 +138,2 @@\n-    if (COMPARATOR::cmp(_left->key(), _key) >= 0 || \/\/ left >= root, or\n-        (is_red() && _left->is_red()) ||            \/\/ 2 red nodes, or\n-        (_left->_parent != this)) {                 \/\/ Pointer mismatch,\n-      return false;                                 \/\/ all incorrect.\n+    if (_right == nullptr) {\n+      assert(is_black() && _left->is_red(), \"if one child it must be red and node black\");\n@@ -110,1 +141,5 @@\n-    left_is_correct = _left->is_correct(num_blacks, maximum_depth, current_depth++);\n+    assert(COMPARATOR::cmp(_left->key(), _key) < 0, \"left node must be less than parent\");\n+    assert(is_black() || _left->is_black(), \"2 red nodes in a row\");\n+    assert(_left->parent() == this, \"pointer mismatch\");\n+    _left->verify(num_nodes, num_black_nodes_left, shortest_leaf_path_left,\n+                  longest_leaf_path_left, tree_depth_left, expect_visited);\n@@ -112,0 +147,6 @@\n+\n+  size_t num_black_nodes_right = 0;\n+  size_t shortest_leaf_path_right = 0;\n+  size_t longest_leaf_path_right = 0;\n+  size_t tree_depth_right = 0;\n+\n@@ -113,4 +154,2 @@\n-    if (COMPARATOR::cmp(_right->key(), _key) <= 0 || \/\/ right <= root, or\n-        (is_red() && _left->is_red()) ||             \/\/ 2 red nodes, or\n-        (_right->_parent != this)) {                 \/\/ Pointer mismatch,\n-      return false;                                  \/\/ all incorrect.\n+    if (_left == nullptr) {\n+      assert(is_black() && _right->is_red(), \"if one child it must be red and node black\");\n@@ -118,1 +157,24 @@\n-    right_is_correct = _right->is_correct(num_blacks, maximum_depth, current_depth++);\n+    assert(COMPARATOR::cmp(_right->key(), _key) > 0, \"right node must be greater than parent\");\n+    assert(is_black() || _left->is_black(), \"2 red nodes in a row\");\n+    assert(_right->parent() == this, \"pointer mismatch\");\n+    _right->verify(num_nodes, num_black_nodes_right, shortest_leaf_path_right,\n+                   longest_leaf_path_right, tree_depth_right, expect_visited);\n+  }\n+\n+  shortest_leaf_path = MAX2(longest_leaf_path_left, longest_leaf_path_right);\n+  longest_leaf_path = MAX2(longest_leaf_path_left, longest_leaf_path_right);\n+\n+  assert(shortest_leaf_path <= longest_leaf_path && longest_leaf_path <= shortest_leaf_path * 2,\n+         \"tree imbalanced, shortest path: \" SIZE_FORMAT \" longest: \" SIZE_FORMAT, shortest_leaf_path, longest_leaf_path);\n+  assert(num_black_nodes_left == num_black_nodes_right,\n+         \"number of black nodes in left\/right subtree should match\");\n+\n+  num_nodes++;\n+  tree_depth = 1 + MAX2(tree_depth_left, tree_depth_right);\n+\n+  shortest_leaf_path++;\n+  longest_leaf_path++;\n+\n+  black_nodes_until_leaf = num_black_nodes_left;\n+  if (is_black()) {\n+    black_nodes_until_leaf++;\n@@ -120,2 +182,0 @@\n-  return left_is_correct && right_is_correct;\n-}\n@@ -123,5 +183,0 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline size_t RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::count_nodes() const {\n-  size_t left_nodes = _left == nullptr ? 0 : _left->count_nodes();\n-  size_t right_nodes = _right == nullptr ? 0 : _right->count_nodes();\n-  return 1 + left_nodes + right_nodes;\n@@ -178,1 +233,1 @@\n-  node->_parent = parent;\n+  node->set_parent(parent);\n@@ -196,1 +251,1 @@\n-  RBNode* parent = node->_parent;\n+  RBNode* parent = node->parent();\n@@ -200,1 +255,1 @@\n-    RBNode* grandparent = parent->_parent;\n+    RBNode* grandparent = parent->parent();\n@@ -245,1 +300,1 @@\n-    parent = grandparent->_parent;\n+    parent = grandparent->parent();\n@@ -252,1 +307,1 @@\n-  RBNode* parent = node->_parent;\n+  RBNode* parent = node->parent();\n@@ -275,1 +330,1 @@\n-        _root = parent->_parent;\n+        _root = parent->parent();\n@@ -333,1 +388,1 @@\n-    parent = node->_parent;\n+    parent = node->parent();\n@@ -339,1 +394,1 @@\n-  RBNode* parent = node->_parent;\n+  RBNode* parent = node->parent();\n@@ -349,1 +404,1 @@\n-    left->_parent = parent;\n+    left->set_parent(parent);\n@@ -363,1 +418,1 @@\n-    right->_parent = parent;\n+    right->set_parent(parent);\n@@ -384,4 +439,2 @@\n-inline bool RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n-  if (node == nullptr) {\n-    return false;\n-  }\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n+  assert(node != nullptr, \"must be\");\n@@ -399,1 +452,1 @@\n-    std::swap(curr->_color, node->_color);\n+    std::swap(curr->_parent, node->_parent); \/\/ Swaps parent and color\n@@ -401,1 +454,1 @@\n-    \/\/ If node is curr's parent, swapping right\/parent severs the node connection\n+    \/\/ If node is curr's parent, parent and right pointers become invalid\n@@ -404,2 +457,1 @@\n-      curr->_parent = node->_parent;\n-      node->_parent = curr;\n+      node->set_parent(curr);\n@@ -409,3 +461,2 @@\n-      std::swap(curr->_parent, node->_parent);\n-      node->_parent->replace_child(curr, node);\n-      curr->_right->_parent = curr;\n+      node->parent()->replace_child(curr, node);\n+      curr->_right->set_parent(curr);\n@@ -414,2 +465,3 @@\n-    if (curr->_parent != nullptr) curr->_parent->replace_child(node, curr);\n-    curr->_left->_parent = curr;\n+    if (curr->parent() != nullptr) curr->parent()->replace_child(node, curr);\n+    curr->_left->set_parent(curr);\n+\n@@ -417,2 +469,2 @@\n-    if (node->_left != nullptr) node->_left->_parent = node;\n-    if (node->_right != nullptr) node->_right->_parent = node;\n+    if (node->_left != nullptr) node->_left->set_parent(node);\n+    if (node->_right != nullptr) node->_right->set_parent(node);\n@@ -423,1 +475,0 @@\n-  return true;\n@@ -429,1 +480,2 @@\n-  GrowableArrayCHeap<RBNode*, mtInternal> to_visit(2 * log2i(_num_nodes + 1));\n+  RBNode* to_visit[64];\n+  int stack_idx = 0;\n@@ -431,1 +483,1 @@\n-  while (!to_visit.is_empty() || head != nullptr) {\n+  while (stack_idx > 0 || head != nullptr) {\n@@ -433,1 +485,1 @@\n-      to_visit.push(head);\n+      to_visit[stack_idx++] = head;\n@@ -436,1 +488,1 @@\n-    head = to_visit.pop();\n+    head = to_visit[--stack_idx];\n@@ -446,25 +498,7 @@\n-  GrowableArrayCHeap<RBNode*, mtInternal> to_visit;\n-  RBNode* head = _root;\n-  while (!to_visit.is_empty() || head != nullptr) {\n-    while (head != nullptr) {\n-      int cmp_from = COMPARATOR::cmp(head->_key, from);\n-      to_visit.push(head);\n-      if (cmp_from >= 0) {\n-        head = head->_left;\n-      } else {\n-        \/\/ We've reached a node which is strictly less than from\n-        \/\/ We don't need to visit any further to the left.\n-        break;\n-      }\n-    }\n-    head = to_visit.pop();\n-    const int cmp_from = COMPARATOR::cmp(head->_key, from);\n-    const int cmp_to = COMPARATOR::cmp(head->_key, to);\n-    if (cmp_from >= 0 && cmp_to < 0) {\n-      f(head);\n-    }\n-    if (cmp_to < 0) {\n-      head = head->_right;\n-    } else {\n-      head = nullptr;\n-    }\n+  RBNode* curr = closest_gt(from, BoundMode::INCLUSIVE);\n+  if (curr == nullptr) return;\n+  RBNode* end = closest_gt(to, BoundMode::INCLUSIVE);\n+\n+  while (curr != nullptr && curr != end) {\n+    f(curr);\n+    curr = curr->next();\n@@ -482,1 +516,1 @@\n-  assert(_root->_parent == nullptr, \"root of rbtree has a parent\");\n+  assert(_root->parent() == nullptr, \"root of rbtree has a parent\");\n@@ -484,8 +518,6 @@\n-  unsigned int black_nodes = 0;\n-  RBNode* node = _root;\n-  while (node != nullptr) {\n-    if (node->is_black()) {\n-      black_nodes++;\n-    }\n-    node = node->_left;\n-  }\n+  size_t num_nodes = 0;\n+  size_t black_depth = 0;\n+  size_t tree_depth = 0;\n+  size_t shortest_leaf_path = 0;\n+  size_t longest_leaf_path = 0;\n+  _expected_visited = !_expected_visited;\n@@ -493,3 +525,1 @@\n-  const size_t actual_num_nodes = _root->count_nodes();\n-  const size_t expected_num_nodes = size();\n-  const unsigned int maximum_depth = log2i(size() + 1) * 2;\n+  _root->verify(num_nodes, black_depth, shortest_leaf_path, longest_leaf_path, tree_depth, _expected_visited);\n@@ -497,1 +527,7 @@\n-  assert(expected_num_nodes == actual_num_nodes,\n+  const unsigned int maximum_depth = log2i(size() + 1) * 2;\n+  \n+  assert(shortest_leaf_path <= longest_leaf_path && longest_leaf_path <= shortest_leaf_path * 2,\n+         \"tree imbalanced, shortest path: \" SIZE_FORMAT \" longest: \" SIZE_FORMAT,\n+         shortest_leaf_path, longest_leaf_path);\n+  assert(tree_depth <= maximum_depth, \"rbtree is too deep\");\n+  assert(size() == num_nodes,\n@@ -499,5 +535,1 @@\n-         \", actual: \" SIZE_FORMAT, expected_num_nodes, actual_num_nodes);\n-  assert(2 * black_nodes <= maximum_depth,\n-         \"rbtree is too deep for its number of nodes. can be at \"\n-         \"most: \" INT32_FORMAT \", but is: \" UINT32_FORMAT, maximum_depth, 2 * black_nodes);\n-  assert(_root->is_correct(black_nodes, maximum_depth, 1), \"rbtree does not hold rb-properties\");\n+         \", actual: \" SIZE_FORMAT, size(), num_nodes);\n@@ -507,19 +539,1 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-template <bool Forward>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::IteratorImpl<Forward>::push_left(RBNode* node) {\n-  while (node != nullptr) {\n-    _to_visit.push(node);\n-    node = node->_left;\n-  }\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-template <bool Forward>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::IteratorImpl<Forward>::push_right(RBNode* node) {\n-  while (node != nullptr) {\n-    _to_visit.push(node);\n-    node = node->_right;\n-  }\n-}\n-\n-#endif \/\/ SHARE_UTILITIES_RBTREE_INLINE_HPP\n\\ No newline at end of file\n+#endif \/\/ SHARE_UTILITIES_RBTREE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":150,"deletions":136,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include <cstddef>\n@@ -57,0 +58,19 @@\n+\/\/ Bump-pointer style allocator that can't free\n+template <size_t AreaSize>\n+struct ArrayAllocator {\n+  uint8_t area[AreaSize];\n+  size_t offset = 0;\n+\n+  void* allocate(size_t sz) {\n+    if (offset + sz > AreaSize) {\n+      vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR,\n+                            \"red-black tree failed allocation\");\n+    }\n+    void* place = &area[offset];\n+    offset += sz;\n+    return place;\n+  }\n+\n+  void free(void* ptr) { }\n+};\n+\n@@ -68,1 +88,1 @@\n-    constexpr const int up_to = 10;\n+    constexpr int up_to = 10;\n@@ -111,1 +131,1 @@\n-    constexpr const int up_to = 10;\n+    constexpr int up_to = 10;\n@@ -283,0 +303,40 @@\n+  void test_node_prev() {\n+    RBTreeInt _tree;\n+    using Node = RBTreeInt::RBNode;\n+    constexpr int num_nodes = 100;\n+\n+    for (int i = num_nodes; i > 0; i--) {\n+      _tree.upsert(i, i);\n+    }\n+\n+    Node* node = _tree.find_node(_tree._root, num_nodes);\n+    int count = num_nodes;\n+    while (node != nullptr) {\n+      EXPECT_EQ(count, node->val());\n+      node = node->prev();\n+      count--;\n+    }\n+\n+    EXPECT_EQ(count, 0);\n+  }\n+\n+    void test_node_next() {\n+    RBTreeInt _tree;\n+    using Node = RBTreeInt::RBNode;\n+    constexpr int num_nodes = 100;\n+\n+    for (int i = 0; i < num_nodes; i++) {\n+      _tree.upsert(i, i);\n+    }\n+\n+    Node* node = _tree.find_node(_tree._root, 0);\n+    int count = 0;\n+    while (node != nullptr) {\n+      EXPECT_EQ(count, node->val());\n+      node = node->next();\n+      count++;\n+    }\n+\n+    EXPECT_EQ(count, num_nodes);\n+  }\n+\n@@ -336,30 +396,0 @@\n-  void test_empty_iterator() {\n-    RBTreeInt tree;\n-    RBTreeInt::Iterator iterator(&tree);\n-    RBTreeInt::ReverseIterator reverse_iterator(&tree);\n-    EXPECT_FALSE(iterator.has_next());\n-    EXPECT_FALSE(reverse_iterator.has_next());\n-  }\n-\n-    void test_iterator() {\n-    constexpr const int num_nodes = 100;\n-    RBTreeInt tree;\n-    for (int n = 0; n <= num_nodes; n++) {\n-      tree.upsert(n, n);\n-    }\n-\n-    RBTreeInt::Iterator iterator(&tree);\n-    for (int n = 0; n <= num_nodes; n++) {\n-      EXPECT_TRUE(iterator.has_next());\n-      EXPECT_EQ(iterator.next()->val(), n);\n-    }\n-    EXPECT_FALSE(iterator.has_next());\n-\n-    RBTreeInt::ReverseIterator reverse_iterator(&tree);\n-    for (int n = num_nodes; n >= 0; n--) {\n-      EXPECT_TRUE(reverse_iterator.has_next());\n-      EXPECT_EQ(reverse_iterator.next()->val(), n);\n-    }\n-    EXPECT_FALSE(reverse_iterator.has_next());\n-  }\n-\n@@ -412,0 +442,31 @@\n+\n+  void test_nodes_visited_once() {\n+    constexpr size_t memory_size = 65536;\n+    using Tree = RBTree<int, int, Cmp, ArrayAllocator<memory_size>>;\n+    using Node = Tree::RBNode;\n+\n+    Tree tree;\n+\n+    int num_nodes = memory_size \/ sizeof(Node);\n+    for (int i = 0; i < num_nodes; i++) {\n+      tree.upsert(i, i);\n+      Node* node = tree.find_node(tree._root, i);\n+    }\n+\n+    Node* start = tree.find_node(tree._root, 0);\n+\n+    Node* node = start;\n+    for (int i = 0; i < num_nodes; i++) {\n+      EXPECT_EQ(tree._expected_visited, node->_visited);\n+      node += 1;\n+    }\n+\n+    tree.verify_self();\n+\n+    node = start;\n+    for (int i = 0; i < num_nodes; i++) {\n+      EXPECT_EQ(tree._expected_visited, node->_visited);\n+      node += 1;\n+    }\n+\n+  }\n@@ -436,2 +497,2 @@\n-TEST_VM_F(RBTreeTest, NodeStableTest) {\n-  this->test_stable_nodes();\n+TEST_VM_F(RBTreeTest, NodePrev) {\n+  this->test_node_prev();\n@@ -440,2 +501,2 @@\n-TEST_VM_F(RBTreeTest, NodeStableAddressTest) {\n-  this->test_stable_nodes_addresses();\n+TEST_VM_F(RBTreeTest, NodeNext) {\n+  this->test_node_next();\n@@ -444,2 +505,2 @@\n-TEST_VM_F(RBTreeTest, EmptyIteratorTest) {\n-  this->test_empty_iterator();\n+TEST_VM_F(RBTreeTest, NodeStableTest) {\n+  this->test_stable_nodes();\n@@ -448,2 +509,2 @@\n-TEST_VM_F(RBTreeTest, IteratorTest) {\n-  this->test_iterator();\n+TEST_VM_F(RBTreeTest, NodeStableAddressTest) {\n+  this->test_stable_nodes_addresses();\n@@ -457,0 +518,4 @@\n+TEST_VM_F(RBTreeTest, NodesVisitedOnce) {\n+  this->test_nodes_visited_once();\n+}\n+\n@@ -458,1 +523,1 @@\n-  constexpr const int num_nodes = 100;\n+  constexpr int num_nodes = 100;\n@@ -476,1 +541,1 @@\n-    constexpr const int ten_thousand = 10000;\n+    constexpr int ten_thousand = 10000;\n@@ -503,1 +568,1 @@\n-    constexpr const int one_hundred_thousand = 100000;\n+    constexpr int one_hundred_thousand = 100000;\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":108,"deletions":43,"binary":false,"changes":151,"status":"modified"}]}