{"files":[{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/debug.hpp\"\n@@ -32,1 +31,0 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n@@ -75,1 +73,1 @@\n-    RBNode(const K &k, const V &v)\n+    RBNode(const K& k, const V& v)\n@@ -79,1 +77,1 @@\n-    bool is_right_child() {\n+    bool is_right_child() const {\n@@ -83,1 +81,1 @@\n-    bool is_left_child() {\n+    bool is_left_child() const {\n@@ -87,38 +85,1 @@\n-    void replace_child(RBNode* old_child, RBNode* new_child) {\n-      if (_left == old_child) {\n-        _left = new_child;\n-      } else if (_right == old_child) {\n-        _right = new_child;\n-      }\n-    }\n-\n-    RBNode* rotate_left() {\n-      \/\/ Move node down to the left, and right child up\n-      RBNode* old_right = _right;\n-\n-      _right = old_right->_left;\n-      if (old_right->_left != nullptr) {\n-        old_right->_left->_parent = this;\n-      }\n-\n-      old_right->_parent = _parent;\n-      if (is_left_child()) {\n-        _parent->_left = old_right;\n-      } else if (is_right_child()) {\n-        _parent->_right = old_right;\n-      }\n-\n-      old_right->_left = this;\n-      _parent = old_right;\n-\n-      return old_right;\n-    }\n-\n-    RBNode* rotate_right() {\n-      \/\/ Move node down to the right, and left child up\n-      RBNode* old_left = _left;\n-\n-      _left = old_left->_right;\n-      if (old_left->_right != nullptr) {\n-        old_left->_right->_parent = this;\n-      }\n+    void replace_child(RBNode* old_child, RBNode* new_child);\n@@ -126,9 +87,2 @@\n-      old_left->_parent = _parent;\n-      if (is_left_child()) {\n-        _parent->_left = old_left;\n-      } else if (is_right_child()) {\n-        _parent->_right = old_left;\n-      }\n-\n-      old_left->_right = this;\n-      _parent = old_left;\n+    \/\/ Move node down to the left, and right child up\n+    RBNode* rotate_left();\n@@ -136,2 +90,2 @@\n-      return old_left;\n-    }\n+    \/\/ Move node down to the right, and left child up\n+    RBNode* rotate_right();\n@@ -139,0 +93,1 @@\n+    \/\/ Visit all RBNodes in ascending order.\n@@ -140,9 +95,1 @@\n-    void visit_in_order_inner(F f) {\n-      if (_left != nullptr) {\n-        _left->visit_in_order_inner(f);\n-      }\n-      f(this);\n-      if (_right != nullptr) {\n-        _right->visit_in_order_inner(f);\n-      }\n-    }\n+    void visit_in_order_inner(F f);\n@@ -152,19 +99,1 @@\n-    void visit_range_in_order_inner(const K& from, const K& to, F f) {\n-      int cmp_from = COMPARATOR::cmp(from, key());\n-      int cmp_to = COMPARATOR::cmp(to, key());\n-      if (_left != nullptr && cmp_from < 0) { \/\/ from < key\n-        _left->visit_range_in_order_inner(from, to, f);\n-      }\n-      if (cmp_from <= 0 && cmp_to > 0) { \/\/ from <= key && to > key\n-        f(this);\n-      }\n-      if (_right != nullptr && cmp_to > 0) { \/\/ to > key\n-        _right->visit_range_in_order_inner(from, to, f);\n-      }\n-    }\n-\n-#ifdef ASSERT\n-    bool is_correct(unsigned int num_blacks) const {\n-      if (is_black()) {\n-        num_blacks--;\n-      }\n+    void visit_range_in_order_inner(const K& from, const K& to, F f);\n@@ -172,27 +101,4 @@\n-      bool left_is_correct = num_blacks == 0;\n-      bool right_is_correct = num_blacks == 0;\n-      if (_left != nullptr) {\n-        if (COMPARATOR::cmp(_left->key(), _key) >= 0 || \/\/ left >= root, or\n-            (is_red() && _left->is_red())            || \/\/ 2 red nodes, or\n-            (_left->_parent != this)) {                 \/\/ Pointer mismatch,\n-          return false;                                 \/\/ all incorrect.\n-        }\n-        left_is_correct = _left->is_correct(num_blacks);\n-      }\n-      if (_right != nullptr) {\n-        if (COMPARATOR::cmp(_right->key(), _key) <= 0 || \/\/ right <= root, or\n-            (is_red() && _left->is_red())             || \/\/ 2 red nodes, or\n-            (_right->_parent != this)) {                 \/\/ Pointer mismatch,\n-          return false;                                  \/\/ all incorrect.\n-        }\n-        right_is_correct = _right->is_correct(num_blacks);\n-      }\n-      return left_is_correct && right_is_correct;\n-    }\n-\n-    size_t count_nodes() const {\n-      size_t left_nodes = _left == nullptr ? 0 : _left->count_nodes();\n-      size_t right_nodes = _right == nullptr ? 0 : _right->count_nodes();\n-      return 1 + left_nodes + right_nodes;\n-    }\n-#endif \/\/ ASSERT\n+  #ifdef ASSERT\n+    bool is_correct(unsigned int num_blacks, unsigned int maximum_depth, unsigned int current_depth) const;\n+    size_t count_nodes() const;\n+  #endif \/\/ ASSERT\n@@ -226,141 +132,1 @@\n-  RBNode* find(RBNode* curr, const K& k) {\n-    while (curr != nullptr) {\n-      int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n-\n-      if (key_cmp_k == 0) {       \/\/ k == key\n-        return curr;\n-      } else if (key_cmp_k < 0) { \/\/ k < key\n-        curr = curr->_left;\n-      } else {                    \/\/ k > key\n-        curr = curr->_right;\n-      }\n-    }\n-\n-    return nullptr;\n-  }\n-\n-  RBNode* insert_node(const K& k, const V& v) {\n-    RBNode* curr = _root;\n-    if (curr == nullptr) { \/\/ Tree is empty\n-      _root = allocate_node(k, v);\n-      return _root;\n-    }\n-\n-    RBNode* parent = nullptr;\n-    while (curr != nullptr) {\n-      int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n-\n-      if (key_cmp_k == 0) { \/\/ k == key\n-        curr->_value = v;\n-        return curr;\n-      }\n-\n-      parent = curr;\n-      if (key_cmp_k < 0) { \/\/ k < key\n-        curr = curr->_left;\n-      } else {             \/\/ k > key\n-        curr = curr->_right;\n-      }\n-    }\n-\n-    \/\/ Create and insert new node\n-    RBNode* node = allocate_node(k, v);\n-    node->_parent = parent;\n-\n-    int key_cmp_k = COMPARATOR::cmp(k, parent->key());\n-    if (key_cmp_k < 0) { \/\/ k < key\n-      parent->_left = node;\n-    } else {             \/\/ k > key\n-      parent->_right = node;\n-    }\n-\n-    return node;\n-  }\n-\n-  void fix_insert_violations(RBNode* node) {\n-    if(node->is_black()) { \/\/ node's value was updated\n-      return;              \/\/ Tree is already correct\n-    }\n-\n-    RBNode* parent = node->_parent;\n-    while (parent != nullptr && parent->is_red()) {\n-      \/\/ Node and parent are both red, creating a red-violation\n-\n-      RBNode* grandparent = parent->_parent;\n-      if (grandparent == nullptr) { \/\/ Parent is the tree root\n-        assert(parent == _root, \"parent must be root\");\n-        parent->color_black();      \/\/ Color parent black to eliminate the red-violation\n-        return;\n-      }\n-\n-      RBNode* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n-      if (is_black(uncle)) { \/\/ Parent is red, uncle is black\n-        \/\/ Rotate the parent to the position of the grandparent\n-        if (parent->is_left_child()) {\n-          if (node->is_right_child()) { \/\/ Node is an \"inner\" node\n-            \/\/ Rotate and swap node and parent to make it an \"outer\" node\n-            parent->rotate_left();\n-            parent = node;\n-          }\n-          grandparent->rotate_right();  \/\/ Rotate the parent to the position of the grandparent\n-        } else if (parent->is_right_child()) {\n-          if (node->is_left_child()) {  \/\/ Node is an \"inner\" node\n-            \/\/ Rotate and swap node and parent to make it an \"outer\" node\n-            parent->rotate_right();\n-            parent = node;\n-          }\n-          grandparent->rotate_left();   \/\/ Rotate the parent to the position of the grandparent\n-        }\n-\n-        \/\/ Swap parent and grandparent colors to eliminate the red-violation\n-        parent->color_black();\n-        grandparent->color_red();\n-\n-        if (_root == grandparent) {\n-          _root = parent;\n-        }\n-\n-        return;\n-      }\n-\n-      \/\/ Parent and uncle are both red\n-      \/\/ Paint both black, paint grandparent red to not create a black-violation\n-      parent->color_black();\n-      uncle->color_black();\n-      grandparent->color_red();\n-\n-      \/\/ Move up two levels to check for new potential red-violation\n-      node = grandparent;\n-      parent = grandparent->_parent;\n-    }\n-  }\n-\n-  void remove_black_leaf(RBNode* node) {\n-    \/\/ Black node removed, balancing needed\n-    RBNode* parent = node->_parent;\n-    while (parent != nullptr) {\n-      \/\/ Sibling must exist. If it did not, node would need to be red to not break tree properties,\n-      \/\/ and could be trivially removed before reaching here\n-      RBNode* sibling = node->is_left_child() ? parent->_right : parent->_left;\n-      if (is_red(sibling)) { \/\/ Sibling red, parent and nephews must be black\n-        assert(is_black(parent), \"parent must be black\");\n-        assert(is_black(sibling->_left), \"nephew must be black\");\n-        assert(is_black(sibling->_right), \"nephew must be black\");\n-        \/\/ Swap parent and sibling colors\n-        parent->color_red();\n-        sibling->color_black();\n-\n-        \/\/ Rotate parent down and sibling up\n-        if (node->is_left_child()) {\n-          parent->rotate_left();\n-          sibling = parent->_right;\n-        } else {\n-          parent->rotate_right();\n-          sibling = parent->_left;\n-        }\n-\n-        if (_root == parent) {\n-          _root = parent->_parent;\n-        }\n-        \/\/ Further balancing needed\n-      }\n+  RBNode* find_node(RBNode* curr, const K& k);\n@@ -368,43 +134,1 @@\n-      RBNode* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n-      RBNode* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n-      if (is_red(distant_nephew) || is_red(close_nephew)) {\n-        if (is_black(distant_nephew)) { \/\/ close red, distant black\n-          \/\/ Rotate sibling down and inner nephew up\n-          if (node->is_left_child()) {\n-            sibling->rotate_right();\n-          } else {\n-            sibling->rotate_left();\n-          }\n-\n-          distant_nephew = sibling;\n-          sibling = close_nephew;\n-\n-          distant_nephew->color_red();\n-          sibling->color_black();\n-        }\n-\n-        \/\/ Distant nephew red\n-        \/\/ Rotate parent down and sibling up\n-        if (node->is_left_child()) {\n-          parent->rotate_left();\n-        } else {\n-          parent->rotate_right();\n-        }\n-        if (_root == parent) {\n-          _root = sibling;\n-        }\n-\n-        \/\/ Swap parent and sibling colors\n-        if (parent->is_black()) {\n-          sibling->color_black();\n-        } else {\n-          sibling->color_red();\n-        }\n-        parent->color_black();\n-        if (sibling->is_black()) {\n-        }\n-\n-        \/\/ Color distant nephew black to restore black balance\n-        distant_nephew->color_black();\n-        return;\n-      }\n+  RBNode* insert_node(const K& k, const V& v);\n@@ -412,6 +136,1 @@\n-      if (is_red(parent)) { \/\/ parent red, sibling and nephews black\n-        \/\/ Swap parent and sibling colors to restore black balance\n-        sibling->color_red();\n-        parent->color_black();\n-        return;\n-      }\n+  void fix_insert_violations(RBNode* node);\n@@ -419,7 +138,1 @@\n-      \/\/ Parent, sibling, and both nephews black\n-      \/\/ Color sibling red and move up one level\n-      sibling->color_red();\n-      node = parent;\n-      parent = node->_parent;\n-    }\n-  }\n+  void remove_black_leaf(RBNode* node);\n@@ -428,44 +141,1 @@\n-  void remove_from_tree(RBNode* node) {\n-    RBNode* parent = node->_parent;\n-    RBNode* left = node->_left;\n-    RBNode* right = node->_right;\n-    if (left != nullptr) { \/\/ node has a left only-child\n-      \/\/ node must be black, and child red, otherwise a black-violation would exist\n-      \/\/ Remove node and color the child black.\n-      assert(right == nullptr, \"right must be nullptr\");\n-      assert(is_black(node), \"node must be black\");\n-      assert(is_red(left), \"child must be red\");\n-      left->color_black();\n-      left->_parent = parent;\n-      if (parent == nullptr) {\n-        assert(node == _root, \"node must be root\");\n-        _root = left;\n-      } else {\n-        parent->replace_child(node, left);\n-      }\n-    } else if (right != nullptr) { \/\/ node has a right only-child\n-      \/\/ node must be black, and child red, otherwise a black-violation would exist\n-      \/\/ Remove node and color the child black.\n-      assert(left == nullptr, \"left must be nullptr\");\n-      assert(is_black(node), \"node must be black\");\n-      assert(is_red(right), \"child must be red\");\n-      right->color_black();\n-      right->_parent = parent;\n-      if (parent == nullptr) {\n-        assert(node == _root, \"node must be root\");\n-        _root = right;\n-      } else {\n-        parent->replace_child(node, right);\n-      }\n-    } else { \/\/ node has no children\n-      if (node == _root) { \/\/ Tree empty\n-        _root = nullptr;\n-      } else {\n-        if (is_black(node)) {\n-          \/\/ Removed node is black, creating a black imbalance\n-          remove_black_leaf(node);\n-        }\n-        parent->replace_child(node, nullptr);\n-      }\n-    }\n-  }\n+  void remove_from_tree(RBNode* node);\n@@ -473,8 +143,1 @@\n-  void remove_all_inner(RBNode* node) {\n-    if (node == nullptr) {\n-      return;\n-    }\n-    remove_all_inner(node->_left);\n-    remove_all_inner(node->_right);\n-    free_node(node);\n-  }\n+  void remove_all_inner(RBNode* node);\n@@ -490,0 +153,2 @@\n+  \/\/ Inserts a node with the given k\/v into the tree,\n+  \/\/ if the key already exist, the value is updated instead.\n@@ -495,0 +160,2 @@\n+  \/\/ Removes the node with the given key from the tree if it exists.\n+  \/\/ Returns true if the node was successfully removed, false otherwise.\n@@ -496,1 +163,1 @@\n-    RBNode* node = find(_root, k);\n+    RBNode* node = find_node(_root, k);\n@@ -500,21 +167,3 @@\n-  bool remove(RBNode* node) {\n-    if (node == nullptr) {\n-      return false;\n-    }\n-\n-    if (node->_left != nullptr && node->_right != nullptr) { \/\/ node has two children\n-      \/\/ Copy the k\/v from the in-order successor and delete that node instead\n-      RBNode* curr = node->_right;\n-      while (curr->_left != nullptr) {\n-        curr = curr->_left;\n-      }\n-      node->_key = curr->key();\n-      node->_value = curr->val();\n-\n-      node = curr;\n-    }\n-\n-    remove_from_tree(node);\n-    free_node(node);\n-    return true;\n-  }\n+  \/\/ Removes the given node from the tree.\n+  \/\/ Returns true if the node was successfully removed, false otherwise.\n+  bool remove(RBNode* node);\n@@ -522,0 +171,1 @@\n+  \/\/ Removes all existing nodes from the tree.\n@@ -528,0 +178,1 @@\n+  \/\/ Finds the node with the closest key <= the given key\n@@ -548,0 +199,1 @@\n+  \/\/ Finds the node with the closest key > the given key\n@@ -567,2 +219,1 @@\n-    Range(RBNode* start, RBNode* end)\n-    : start(start), end(end) {}\n+    Range(RBNode* start, RBNode* end) : start(start), end(end) {}\n@@ -573,1 +224,1 @@\n-  \/\/ Failure to find the range leads to start and\/or end being null.\n+  \/\/ Failure to find the range leads to start and\/or end being nullptr.\n@@ -580,0 +231,1 @@\n+  \/\/ Finds the value associated with the key\n@@ -581,1 +233,1 @@\n-    RBNode* node = find(_root, key);\n+    RBNode* node = find_node(_root, key);\n@@ -588,1 +240,1 @@\n-  \/\/ Visit all RBNodes in ascending order.\n+  \/\/ Visit all RBNodes in ascending order, calling f on each node.\n@@ -594,1 +246,1 @@\n-  \/\/ Visit all RBNodes in ascending order whose keys are in range [from, to).\n+  \/\/ Visit all RBNodes in ascending order whose keys are in range [from, to), calling f on each node.\n@@ -597,1 +249,1 @@\n-    if (_root == nullptr)\n+    if (_root == nullptr) {\n@@ -599,0 +251,1 @@\n+    }\n@@ -603,25 +256,2 @@\n-  void verify_self() {\n-    if (_root == nullptr) {\n-      assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n-      return;\n-    }\n-\n-    assert(_root->_parent == nullptr, \"root of rbtree has a parent\");\n-\n-    unsigned int black_nodes = 0;\n-    RBNode* node = _root;\n-    while (node != nullptr) {\n-      if (node->is_black()) {\n-        black_nodes++;\n-      }\n-      node = node->_left;\n-    }\n-\n-    const size_t actual_num_nodes = _root->count_nodes();\n-    const size_t expected_num_nodes = size();\n-    const unsigned int maximum_depth = log2i(size() + 1) * 2;\n-\n-    assert(expected_num_nodes == actual_num_nodes, \"unexpected number of nodes in rbtree. expected: \" SIZE_FORMAT \", actual: \" SIZE_FORMAT, expected_num_nodes, actual_num_nodes);\n-    assert(2 * black_nodes <= maximum_depth, \"rbtree is too deep for its number of nodes. can be at most: \" INT32_FORMAT \", but is: \" UINT32_FORMAT, maximum_depth, 2 * black_nodes);\n-    assert(_root->is_correct(black_nodes), \"rbtree does not hold rb-properties\");\n-  }\n+  \/\/ Verifies that the tree is correct and holds rb-properties\n+  void verify_self();\n@@ -638,13 +268,2 @@\n-    void push_left(RBNode* node) {\n-      while (node != nullptr) {\n-        _to_visit.push(node);\n-        node = node->_left;\n-      }\n-    }\n-\n-    void push_right(RBNode* node) {\n-      while (node != nullptr) {\n-        _to_visit.push(node);\n-        node = node->_right;\n-      }\n-    }\n+    void push_left(RBNode* node);\n+    void push_right(RBNode* node);\n@@ -657,4 +276,1 @@\n-    bool has_next() {\n-      return !_to_visit.is_empty();\n-    }\n-\n+    bool has_next() { return !_to_visit.is_empty(); }\n@@ -694,1 +310,0 @@\n-\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":45,"deletions":430,"binary":false,"changes":475,"status":"modified"},{"patch":"@@ -0,0 +1,510 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RBTREE_INLINE_HPP\n+#define SHARE_UTILITIES_RBTREE_INLINE_HPP\n+\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/rbTree.hpp\"\n+\n+\/\/ ----------------\n+\/\/ RBNode functions\n+\/\/ ----------------\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::replace_child(\n+    RBNode* old_child, RBNode* new_child) {\n+  if (_left == old_child) {\n+    _left = new_child;\n+  } else if (_right == old_child) {\n+    _right = new_child;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_left() {\n+  \/\/ Move node down to the left, and right child up\n+  RBNode* old_right = _right;\n+\n+  _right = old_right->_left;\n+  if (old_right->_left != nullptr) {\n+    old_right->_left->_parent = this;\n+  }\n+\n+  old_right->_parent = _parent;\n+  if (is_left_child()) {\n+    _parent->_left = old_right;\n+  } else if (is_right_child()) {\n+    _parent->_right = old_right;\n+  }\n+\n+  old_right->_left = this;\n+  _parent = old_right;\n+\n+  return old_right;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_right() {\n+  \/\/ Move node down to the right, and left child up\n+  RBNode* old_left = _left;\n+\n+  _left = old_left->_right;\n+  if (old_left->_right != nullptr) {\n+    old_left->_right->_parent = this;\n+  }\n+\n+  old_left->_parent = _parent;\n+  if (is_left_child()) {\n+    _parent->_left = old_left;\n+  } else if (is_right_child()) {\n+    _parent->_right = old_left;\n+  }\n+\n+  old_left->_right = this;\n+  _parent = old_left;\n+\n+  return old_left;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename F>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::visit_in_order_inner(F f) {\n+  if (_left != nullptr) {\n+    _left->visit_in_order_inner(f);\n+  }\n+  f(this);\n+  if (_right != nullptr) {\n+    _right->visit_in_order_inner(f);\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename F>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::visit_range_in_order_inner(\n+    const K& from, const K& to, F f) {\n+  int cmp_from = COMPARATOR::cmp(from, key());\n+  int cmp_to = COMPARATOR::cmp(to, key());\n+  if (_left != nullptr && cmp_from < 0) { \/\/ from < key\n+    _left->visit_range_in_order_inner(from, to, f);\n+  }\n+  if (cmp_from <= 0 && cmp_to > 0) { \/\/ from <= key && to > key\n+    f(this);\n+  }\n+  if (_right != nullptr && cmp_to > 0) { \/\/ to > key\n+    _right->visit_range_in_order_inner(from, to, f);\n+  }\n+}\n+\n+#ifdef ASSERT\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline bool RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::is_correct(\n+  unsigned int num_blacks, unsigned int maximum_depth, unsigned int current_depth) const {\n+  if (current_depth > maximum_depth) {\n+    return false;\n+  }\n+\n+  if (is_black()) {\n+    num_blacks--;\n+  }\n+\n+  bool left_is_correct = num_blacks == 0;\n+  bool right_is_correct = num_blacks == 0;\n+  if (_left != nullptr) {\n+    if (COMPARATOR::cmp(_left->key(), _key) >= 0 || \/\/ left >= root, or\n+        (is_red() && _left->is_red()) ||            \/\/ 2 red nodes, or\n+        (_left->_parent != this)) {                 \/\/ Pointer mismatch,\n+      return false;                                 \/\/ all incorrect.\n+    }\n+    left_is_correct = _left->is_correct(num_blacks, maximum_depth, current_depth++);\n+  }\n+  if (_right != nullptr) {\n+    if (COMPARATOR::cmp(_right->key(), _key) <= 0 || \/\/ right <= root, or\n+        (is_red() && _left->is_red()) ||             \/\/ 2 red nodes, or\n+        (_right->_parent != this)) {                 \/\/ Pointer mismatch,\n+      return false;                                  \/\/ all incorrect.\n+    }\n+    right_is_correct = _right->is_correct(num_blacks, maximum_depth, current_depth++);\n+  }\n+  return left_is_correct && right_is_correct;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline size_t RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::count_nodes() const {\n+  size_t left_nodes = _left == nullptr ? 0 : _left->count_nodes();\n+  size_t right_nodes = _right == nullptr ? 0 : _right->count_nodes();\n+  return 1 + left_nodes + right_nodes;\n+}\n+\n+#endif \/\/ ASSERT\n+\n+\/\/ ----------------\n+\/\/ RBTree functions\n+\/\/ ----------------\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(RBNode* curr, const K& k) {\n+  while (curr != nullptr) {\n+    int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n+\n+    if (key_cmp_k == 0) {       \/\/ k == key\n+      return curr;\n+    } else if (key_cmp_k < 0) { \/\/ k < key\n+      curr = curr->_left;\n+    } else {                    \/\/ k > key\n+      curr = curr->_right;\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& k, const V& v) {\n+  RBNode* curr = _root;\n+  if (curr == nullptr) { \/\/ Tree is empty\n+    _root = allocate_node(k, v);\n+    return _root;\n+  }\n+\n+  RBNode* parent = nullptr;\n+  while (curr != nullptr) {\n+    int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n+\n+    if (key_cmp_k == 0) { \/\/ k == key\n+      curr->_value = v;\n+      return curr;\n+    }\n+\n+    parent = curr;\n+    if (key_cmp_k < 0) { \/\/ k < key\n+      curr = curr->_left;\n+    } else {             \/\/ k > key\n+      curr = curr->_right;\n+    }\n+  }\n+\n+  \/\/ Create and insert new node\n+  RBNode* node = allocate_node(k, v);\n+  node->_parent = parent;\n+\n+  int key_cmp_k = COMPARATOR::cmp(k, parent->key());\n+  if (key_cmp_k < 0) { \/\/ k < key\n+    parent->_left = node;\n+  } else {             \/\/ k > key\n+    parent->_right = node;\n+  }\n+\n+  return node;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::fix_insert_violations(RBNode* node) {\n+  if (node->is_black()) { \/\/ node's value was updated\n+    return;               \/\/ Tree is already correct\n+  }\n+\n+  RBNode* parent = node->_parent;\n+  while (parent != nullptr && parent->is_red()) {\n+    \/\/ Node and parent are both red, creating a red-violation\n+\n+    RBNode* grandparent = parent->_parent;\n+    if (grandparent == nullptr) { \/\/ Parent is the tree root\n+      assert(parent == _root, \"parent must be root\");\n+      parent->color_black(); \/\/ Color parent black to eliminate the red-violation\n+      return;\n+    }\n+\n+    RBNode* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n+    if (is_black(uncle)) { \/\/ Parent is red, uncle is black\n+      \/\/ Rotate the parent to the position of the grandparent\n+      if (parent->is_left_child()) {\n+        if (node->is_right_child()) { \/\/ Node is an \"inner\" node\n+          \/\/ Rotate and swap node and parent to make it an \"outer\" node\n+          parent->rotate_left();\n+          parent = node;\n+        }\n+        grandparent->rotate_right(); \/\/ Rotate the parent to the position of the grandparent\n+      } else if (parent->is_right_child()) {\n+        if (node->is_left_child()) { \/\/ Node is an \"inner\" node\n+          \/\/ Rotate and swap node and parent to make it an \"outer\" node\n+          parent->rotate_right();\n+          parent = node;\n+        }\n+        grandparent->rotate_left(); \/\/ Rotate the parent to the position of the grandparent\n+      }\n+\n+      \/\/ Swap parent and grandparent colors to eliminate the red-violation\n+      parent->color_black();\n+      grandparent->color_red();\n+\n+      if (_root == grandparent) {\n+        _root = parent;\n+      }\n+\n+      return;\n+    }\n+\n+    \/\/ Parent and uncle are both red\n+    \/\/ Paint both black, paint grandparent red to not create a black-violation\n+    parent->color_black();\n+    uncle->color_black();\n+    grandparent->color_red();\n+\n+    \/\/ Move up two levels to check for new potential red-violation\n+    node = grandparent;\n+    parent = grandparent->_parent;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_black_leaf(RBNode* node) {\n+  \/\/ Black node removed, balancing needed\n+  RBNode* parent = node->_parent;\n+  while (parent != nullptr) {\n+    \/\/ Sibling must exist. If it did not, node would need to be red to not break\n+    \/\/ tree properties, and could be trivially removed before reaching here\n+    RBNode* sibling = node->is_left_child() ? parent->_right : parent->_left;\n+    if (is_red(sibling)) { \/\/ Sibling red, parent and nephews must be black\n+      assert(is_black(parent), \"parent must be black\");\n+      assert(is_black(sibling->_left), \"nephew must be black\");\n+      assert(is_black(sibling->_right), \"nephew must be black\");\n+      \/\/ Swap parent and sibling colors\n+      parent->color_red();\n+      sibling->color_black();\n+\n+      \/\/ Rotate parent down and sibling up\n+      if (node->is_left_child()) {\n+        parent->rotate_left();\n+        sibling = parent->_right;\n+      } else {\n+        parent->rotate_right();\n+        sibling = parent->_left;\n+      }\n+\n+      if (_root == parent) {\n+        _root = parent->_parent;\n+      }\n+      \/\/ Further balancing needed\n+    }\n+\n+    RBNode* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n+    RBNode* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n+    if (is_red(distant_nephew) || is_red(close_nephew)) {\n+      if (is_black(distant_nephew)) { \/\/ close red, distant black\n+        \/\/ Rotate sibling down and inner nephew up\n+        if (node->is_left_child()) {\n+          sibling->rotate_right();\n+        } else {\n+          sibling->rotate_left();\n+        }\n+\n+        distant_nephew = sibling;\n+        sibling = close_nephew;\n+\n+        distant_nephew->color_red();\n+        sibling->color_black();\n+      }\n+\n+      \/\/ Distant nephew red\n+      \/\/ Rotate parent down and sibling up\n+      if (node->is_left_child()) {\n+        parent->rotate_left();\n+      } else {\n+        parent->rotate_right();\n+      }\n+      if (_root == parent) {\n+        _root = sibling;\n+      }\n+\n+      \/\/ Swap parent and sibling colors\n+      if (parent->is_black()) {\n+        sibling->color_black();\n+      } else {\n+        sibling->color_red();\n+      }\n+      parent->color_black();\n+      if (sibling->is_black()) {\n+      }\n+\n+      \/\/ Color distant nephew black to restore black balance\n+      distant_nephew->color_black();\n+      return;\n+    }\n+\n+    if (is_red(parent)) { \/\/ parent red, sibling and nephews black\n+      \/\/ Swap parent and sibling colors to restore black balance\n+      sibling->color_red();\n+      parent->color_black();\n+      return;\n+    }\n+\n+    \/\/ Parent, sibling, and both nephews black\n+    \/\/ Color sibling red and move up one level\n+    sibling->color_red();\n+    node = parent;\n+    parent = node->_parent;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_from_tree(RBNode* node) {\n+  RBNode* parent = node->_parent;\n+  RBNode* left = node->_left;\n+  RBNode* right = node->_right;\n+  if (left != nullptr) { \/\/ node has a left only-child\n+    \/\/ node must be black, and child red, otherwise a black-violation would\n+    \/\/ exist Remove node and color the child black.\n+    assert(right == nullptr, \"right must be nullptr\");\n+    assert(is_black(node), \"node must be black\");\n+    assert(is_red(left), \"child must be red\");\n+    left->color_black();\n+    left->_parent = parent;\n+    if (parent == nullptr) {\n+      assert(node == _root, \"node must be root\");\n+      _root = left;\n+    } else {\n+      parent->replace_child(node, left);\n+    }\n+  } else if (right != nullptr) { \/\/ node has a right only-child\n+    \/\/ node must be black, and child red, otherwise a black-violation would\n+    \/\/ exist Remove node and color the child black.\n+    assert(left == nullptr, \"left must be nullptr\");\n+    assert(is_black(node), \"node must be black\");\n+    assert(is_red(right), \"child must be red\");\n+    right->color_black();\n+    right->_parent = parent;\n+    if (parent == nullptr) {\n+      assert(node == _root, \"node must be root\");\n+      _root = right;\n+    } else {\n+      parent->replace_child(node, right);\n+    }\n+  } else {               \/\/ node has no children\n+    if (node == _root) { \/\/ Tree empty\n+      _root = nullptr;\n+    } else {\n+      if (is_black(node)) {\n+        \/\/ Removed node is black, creating a black imbalance\n+        remove_black_leaf(node);\n+      }\n+      parent->replace_child(node, nullptr);\n+    }\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_all_inner(RBNode* node) {\n+  if (node == nullptr) {\n+    return;\n+  }\n+  remove_all_inner(node->_left);\n+  remove_all_inner(node->_right);\n+  free_node(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline bool RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n+  if (node == nullptr) {\n+    return false;\n+  }\n+\n+  if (node->_left != nullptr && node->_right != nullptr) { \/\/ node has two children\n+    \/\/ Copy the k\/v from the in-order successor and delete that node instead\n+    RBNode* curr = node->_right;\n+    while (curr->_left != nullptr) {\n+      curr = curr->_left;\n+    }\n+    node->_key = curr->key();\n+    node->_value = curr->val();\n+\n+    node = curr;\n+  }\n+\n+  remove_from_tree(node);\n+  free_node(node);\n+  return true;\n+}\n+\n+#ifdef ASSERT\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::verify_self() {\n+  if (_root == nullptr) {\n+    assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n+    return;\n+  }\n+\n+  assert(_root->_parent == nullptr, \"root of rbtree has a parent\");\n+\n+  unsigned int black_nodes = 0;\n+  RBNode* node = _root;\n+  while (node != nullptr) {\n+    if (node->is_black()) {\n+      black_nodes++;\n+    }\n+    node = node->_left;\n+  }\n+\n+  const size_t actual_num_nodes = _root->count_nodes();\n+  const size_t expected_num_nodes = size();\n+  const unsigned int maximum_depth = log2i(size() + 1) * 2;\n+\n+  assert(expected_num_nodes == actual_num_nodes,\n+         \"unexpected number of nodes in rbtree. expected: \" SIZE_FORMAT\n+         \", actual: \" SIZE_FORMAT, expected_num_nodes, actual_num_nodes);\n+  assert(2 * black_nodes <= maximum_depth,\n+         \"rbtree is too deep for its number of nodes. can be at \"\n+         \"most: \" INT32_FORMAT \", but is: \" UINT32_FORMAT, maximum_depth, 2 * black_nodes);\n+  assert(_root->is_correct(black_nodes, maximum_depth, 1), \"rbtree does not hold rb-properties\");\n+}\n+#endif \/\/ ASSERT\n+\n+\/\/ ------------------\n+\/\/ Iterator functions\n+\/\/ ------------------\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <bool Forward>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::IteratorImpl<Forward>::push_left(RBNode* node) {\n+  while (node != nullptr) {\n+    _to_visit.push(node);\n+    node = node->_left;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <bool Forward>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::IteratorImpl<Forward>::push_right(RBNode* node) {\n+  while (node != nullptr) {\n+    _to_visit.push(node);\n+    node = node->_right;\n+  }\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_RBTREE_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":510,"deletions":0,"binary":false,"changes":510,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/rbTree.hpp\"\n+#include \"utilities\/rbTree.inline.hpp\"\n@@ -142,1 +142,1 @@\n-      EXPECT_EQ(nullptr, rbtree.find(rbtree._root, f));\n+      EXPECT_EQ(nullptr, rbtree.find(f));\n@@ -144,1 +144,1 @@\n-      Node* n = rbtree.find(rbtree._root, f);\n+      Node* n = rbtree.find_node(rbtree._root, f);\n@@ -313,1 +313,1 @@\n-      allocations.append(r % size);\n+      allocations.append(r);\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}