{"files":[{"patch":"@@ -79,1 +79,1 @@\n-    void set_parent(RBNode* new_parent) {_parent = (_parent & 0x1) | ((uintptr_t)new_parent & ~0x1); }\n+    void set_parent(RBNode* new_parent) { _parent = (_parent & 0x1) | (uintptr_t)new_parent; }\n@@ -81,1 +81,1 @@\n-    RBNode(const K& k, const V& v DEBUG_ONLY(COMMA bool visited))\n+    RBNode(const K& key, const V& val DEBUG_ONLY(COMMA bool visited))\n@@ -83,1 +83,1 @@\n-          _key(k), _value(v) DEBUG_ONLY(COMMA _visited(visited)) {}\n+          _key(key), _value(val) DEBUG_ONLY(COMMA _visited(visited)) {}\n@@ -118,1 +118,1 @@\n-  RBNode* allocate_node(const K& k, const V& v) {\n+  RBNode* allocate_node(const K& key, const V& val) {\n@@ -122,1 +122,1 @@\n-    return new (node_place) RBNode(k, v DEBUG_ONLY(COMMA _expected_visited));\n+    return new (node_place) RBNode(key, val DEBUG_ONLY(COMMA _expected_visited));\n@@ -142,1 +142,1 @@\n-  RBNode* insert_node(const K& k, const V& v);\n+  RBNode* insert_node(const K& key, const V& val);\n@@ -163,2 +163,2 @@\n-  void upsert(const K& k, const V& v) {\n-    RBNode* node = insert_node(k, v);\n+  void upsert(const K& key, const V& val) {\n+    RBNode* node = insert_node(key, val);\n@@ -170,2 +170,2 @@\n-  bool remove(const K& k) {\n-    RBNode* node = find_node(k);\n+  bool remove(const K& key) {\n+    RBNode* node = find_node(key);\n@@ -199,3 +199,0 @@\n-  \/\/ Alters behaviour of closest_(leq\/gt) functions to include\/exclude the exact value\n-  enum BoundMode : uint8_t { EXCLUSIVE, INCLUSIVE };\n-\n@@ -203,2 +200,1 @@\n-  \/\/ Change mode to EXCLUSIVE to not include node matching key\n-  RBNode* closest_leq(const K& key, BoundMode mode = INCLUSIVE) {\n+  const RBNode* closest_leq(const K& key) const {\n@@ -209,1 +205,1 @@\n-      if (mode == INCLUSIVE && cmp_r == 0) { \/\/ Exact match\n+      if (cmp_r == 0) { \/\/ Exact match\n@@ -225,2 +221,1 @@\n-  \/\/ Change mode to INCLUSIVE to include node matching key\n-  RBNode* closest_gt(const K& key, BoundMode mode = EXCLUSIVE) {\n+  const RBNode* closest_gt(const K& key) const {\n@@ -231,1 +226,18 @@\n-      if (mode == INCLUSIVE && cmp_r == 0) { \/\/ Exact match\n+      if (cmp_r > 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_left;\n+      } else {\n+        pos = pos->_right;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  \/\/ Finds the node with the closest key >= the given key\n+  const RBNode* closest_geq(const K& key) const {\n+    RBNode* candidate = nullptr;\n+    RBNode* pos = _root;\n+    while (pos != nullptr) {\n+      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r == 0) { \/\/ Exact match\n@@ -246,2 +258,8 @@\n-  const RBNode* closest_leq(const K& k, BoundMode mode = INCLUSIVE) const {\n-    return const_cast<RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_leq(k, mode);\n+  RBNode* closest_leq(const K& key) {\n+    return const_cast<RBNode*>(\n+        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_leq(key));\n+  }\n+\n+  RBNode* closest_gt(const K& key) {\n+    return const_cast<RBNode*>(\n+        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_gt(key));\n@@ -250,2 +268,3 @@\n-  const RBNode* closest_gt(const K& k, BoundMode mode = EXCLUSIVE) const {\n-    return const_cast<RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_gt(k, mode);\n+  RBNode* closest_geq(const K& key) {\n+    return const_cast<RBNode*>(\n+        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_geq(key));\n@@ -264,3 +283,3 @@\n-  Range find_enclosing_range(K addr) {\n-    RBNode* start = closest_leq(addr);\n-    RBNode* end = closest_gt(addr);\n+  Range find_enclosing_range(K key) {\n+    RBNode* start = closest_leq(key);\n+    RBNode* end = closest_gt(key);\n@@ -271,1 +290,1 @@\n-  RBNode* find_node(const K& k);\n+  const RBNode* find_node(const K& key) const;\n@@ -273,2 +292,3 @@\n-  const RBNode* find_node(const K& k) const {\n-    return const_cast<RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->find_node(k);\n+  RBNode* find_node(const K& key) {\n+    return const_cast<RBNode*>(\n+        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->find_node(key));\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":49,"deletions":29,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -31,1 +32,0 @@\n-#include <utility> \/\/ for std::swap\n@@ -189,2 +189,2 @@\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(const K& k) {\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(const K& key) const {\n@@ -193,1 +193,1 @@\n-    const int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n+    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n@@ -209,1 +209,1 @@\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& k, const V& v) {\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& key, const V& val) {\n@@ -212,1 +212,1 @@\n-    _root = allocate_node(k, v);\n+    _root = allocate_node(key, val);\n@@ -218,1 +218,1 @@\n-    const int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n+    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n@@ -221,1 +221,1 @@\n-      curr->_value = v;\n+      curr->_value = val;\n@@ -234,1 +234,1 @@\n-  RBNode* node = allocate_node(k, v);\n+  RBNode* node = allocate_node(key, val);\n@@ -237,1 +237,1 @@\n-  const int key_cmp_k = COMPARATOR::cmp(k, parent->key());\n+  const int key_cmp_k = COMPARATOR::cmp(key, parent->key());\n@@ -453,2 +453,2 @@\n-    std::swap(curr->_left, node->_left);\n-    std::swap(curr->_parent, node->_parent); \/\/ Swaps parent and color\n+    swap(curr->_left, node->_left);\n+    swap(curr->_parent, node->_parent); \/\/ Swaps parent and color\n@@ -462,1 +462,1 @@\n-      std::swap(curr->_right, node->_right);\n+      swap(curr->_right, node->_right);\n@@ -500,1 +500,1 @@\n-  RBNode* curr = closest_gt(from, BoundMode::INCLUSIVE);\n+  RBNode* curr = closest_geq(from);\n@@ -502,1 +502,1 @@\n-  RBNode* end = closest_gt(to, BoundMode::INCLUSIVE);\n+  RBNode* end = closest_geq(to);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"}]}