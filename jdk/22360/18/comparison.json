{"files":[{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RBTREE_HPP\n+#define SHARE_UTILITIES_RBTREE_HPP\n+\n+#include \"nmt\/memTag.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include <type_traits>\n+\n+\/\/ COMPARATOR must have a static function `cmp(a,b)` which returns:\n+\/\/     - an int < 0 when a < b\n+\/\/     - an int == 0 when a == b\n+\/\/     - an int > 0 when a > b\n+\/\/ ALLOCATOR must check for oom and exit, as RBTree currently does not handle the\n+\/\/ allocation failing.\n+\/\/ Key needs to be of a type that is trivially destructible.\n+\/\/ The tree will call a value's destructor when its node is removed.\n+\/\/ Nodes are address stable and will not change during its lifetime.\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+class RBTree {\n+  friend class RBTreeTest;\n+\n+private:\n+  ALLOCATOR _allocator;\n+  size_t _num_nodes;\n+\n+public:\n+  class RBNode {\n+    friend RBTree;\n+    friend class RBTreeTest;\n+\n+  private:\n+    uintptr_t _parent; \/\/ LSB encodes color information. 0 = RED, 1 = BLACK\n+    RBNode* _left;\n+    RBNode* _right;\n+\n+    const K _key;\n+    V _value;\n+\n+    DEBUG_ONLY(bool _visited);\n+\n+  public:\n+    const K& key() const { return _key; }\n+    V& val() { return _value; }\n+    const V& val() const { return _value; }\n+\n+  private:\n+    bool is_black() const { return (_parent & 0x1) != 0; }\n+    bool is_red() const { return (_parent & 0x1) == 0; }\n+\n+    void set_black() { _parent |= 0x1; }\n+    void set_red() { _parent &= ~0x1; }\n+\n+    RBNode* parent() const { return (RBNode*)(_parent & ~0x1); }\n+    void set_parent(RBNode* new_parent) { _parent = (_parent & 0x1) | (uintptr_t)new_parent; }\n+\n+    RBNode(const K& key, const V& val DEBUG_ONLY(COMMA bool visited))\n+        : _parent(0), _left(nullptr), _right(nullptr),\n+          _key(key), _value(val) DEBUG_ONLY(COMMA _visited(visited)) {}\n+\n+    bool is_right_child() const {\n+      return parent() != nullptr && parent()->_right == this;\n+    }\n+\n+    bool is_left_child() const {\n+      return parent() != nullptr && parent()->_left == this;\n+    }\n+\n+    void replace_child(RBNode* old_child, RBNode* new_child);\n+\n+    \/\/ This node down, right child up\n+    \/\/ Returns right child (now parent)\n+    RBNode* rotate_left();\n+\n+    \/\/ This node down, left child up\n+    \/\/ Returns left child (now parent)\n+    RBNode* rotate_right();\n+\n+    RBNode* prev();\n+\n+    RBNode* next();\n+\n+  #ifdef ASSERT\n+    void verify(size_t& num_nodes, size_t& black_nodes_until_leaf,\n+                size_t& shortest_leaf_path, size_t& longest_leaf_path,\n+                size_t& tree_depth, bool expect_visited);\n+#endif \/\/ ASSERT\n+  };\n+\n+private:\n+  RBNode* _root;\n+  DEBUG_ONLY(bool _expected_visited);\n+\n+  RBNode* allocate_node(const K& key, const V& val) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode));\n+    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    _num_nodes++;\n+    return new (node_place) RBNode(key, val DEBUG_ONLY(COMMA _expected_visited));\n+  }\n+\n+  void free_node(RBNode* node) {\n+    node->_value.~V();\n+    _allocator.free(node);\n+    _num_nodes--;\n+  }\n+\n+  \/\/ True if node is black (nil nodes count as black)\n+  static inline bool is_black(const RBNode* node) {\n+    return node == nullptr || node->is_black();\n+  }\n+\n+  static inline bool is_red(const RBNode* node) {\n+    return node != nullptr && node->is_red();\n+  }\n+\n+\n+  \/\/ If the node with key k already exist, the value is updated instead.\n+  RBNode* insert_node(const K& key, const V& val);\n+\n+  void fix_insert_violations(RBNode* node);\n+\n+  void remove_black_leaf(RBNode* node);\n+\n+  \/\/ Assumption: node has at most one child. Two children is handled in `remove()`\n+  void remove_from_tree(RBNode* node);\n+\n+public:\n+  NONCOPYABLE(RBTree);\n+\n+  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n+    static_assert(std::is_trivially_destructible<K>::value, \"key type must be trivially destructable\");\n+  }\n+  ~RBTree() { this->remove_all(); }\n+\n+  size_t size() { return _num_nodes; }\n+\n+  \/\/ Inserts a node with the given k\/v into the tree,\n+  \/\/ if the key already exist, the value is updated instead.\n+  void upsert(const K& key, const V& val) {\n+    RBNode* node = insert_node(key, val);\n+    fix_insert_violations(node);\n+  }\n+\n+  \/\/ Removes the node with the given key from the tree if it exists.\n+  \/\/ Returns true if the node was successfully removed, false otherwise.\n+  bool remove(const K& key) {\n+    RBNode* node = find_node(key);\n+    if (node == nullptr){\n+      return false;\n+    }\n+    remove(node);\n+    return true;\n+  }\n+\n+  \/\/ Removes the given node from the tree. node must be a valid node\n+  void remove(RBNode* node);\n+\n+  \/\/ Removes all existing nodes from the tree.\n+  void remove_all() {\n+    RBNode* to_delete[64];\n+    int stack_idx = 0;\n+    to_delete[stack_idx++] = _root;\n+\n+    while (stack_idx > 0) {\n+      RBNode* head = to_delete[--stack_idx];\n+      if (head == nullptr) continue;\n+      to_delete[stack_idx++] = head->_left;\n+      to_delete[stack_idx++] = head->_right;\n+      free_node(head);\n+    }\n+    _num_nodes = 0;\n+    _root = nullptr;\n+  }\n+\n+  \/\/ Finds the node with the closest key <= the given key\n+  const RBNode* closest_leq(const K& key) const {\n+    RBNode* candidate = nullptr;\n+    RBNode* pos = _root;\n+    while (pos != nullptr) {\n+      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r == 0) { \/\/ Exact match\n+        candidate = pos;\n+        break; \/\/ Can't become better than that.\n+      }\n+      if (cmp_r < 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_right;\n+      } else {\n+        pos = pos->_left;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  \/\/ Finds the node with the closest key > the given key\n+  const RBNode* closest_gt(const K& key) const {\n+    RBNode* candidate = nullptr;\n+    RBNode* pos = _root;\n+    while (pos != nullptr) {\n+      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r > 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_left;\n+      } else {\n+        pos = pos->_right;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  \/\/ Finds the node with the closest key >= the given key\n+  const RBNode* closest_geq(const K& key) const {\n+    RBNode* candidate = nullptr;\n+    RBNode* pos = _root;\n+    while (pos != nullptr) {\n+      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r == 0) { \/\/ Exact match\n+        candidate = pos;\n+        break; \/\/ Can't become better than that.\n+      }\n+      if (cmp_r > 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_left;\n+      } else {\n+        pos = pos->_right;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  RBNode* closest_leq(const K& key) {\n+    return const_cast<RBNode*>(\n+        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_leq(key));\n+  }\n+\n+  RBNode* closest_gt(const K& key) {\n+    return const_cast<RBNode*>(\n+        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_gt(key));\n+  }\n+\n+  RBNode* closest_geq(const K& key) {\n+    return const_cast<RBNode*>(\n+        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_geq(key));\n+  }\n+\n+  struct Range {\n+    RBNode* start;\n+    RBNode* end;\n+    Range(RBNode* start, RBNode* end)\n+    : start(start), end(end) {}\n+  };\n+\n+  \/\/ Return the range [start, end)\n+  \/\/ where start->key() <= addr < end->key().\n+  \/\/ Failure to find the range leads to start and\/or end being null.\n+  Range find_enclosing_range(K key) {\n+    RBNode* start = closest_leq(key);\n+    RBNode* end = closest_gt(key);\n+    return Range(start, end);\n+  }\n+\n+  \/\/ Finds the node associated with the key\n+  const RBNode* find_node(const K& key) const;\n+\n+  RBNode* find_node(const K& key) {\n+    return const_cast<RBNode*>(\n+        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->find_node(key));\n+  }\n+\n+  \/\/ Finds the value associated with the key\n+  V* find(const K& key) {\n+    RBNode* node = find_node(key);\n+    return node == nullptr ? nullptr : &node->val();\n+  }\n+\n+  const V* find(const K& key) const {\n+    const RBNode* node = find_node(key);\n+    return node == nullptr ? nullptr : &node->val();\n+  }\n+\n+  \/\/ Visit all RBNodes in ascending order, calling f on each node.\n+  template <typename F>\n+  void visit_in_order(F f) const;\n+\n+  \/\/ Visit all RBNodes in ascending order whose keys are in range [from, to), calling f on each node.\n+  template <typename F>\n+  void visit_range_in_order(const K& from, const K& to, F f);\n+\n+#ifdef ASSERT\n+  \/\/ Verifies that the tree is correct and holds rb-properties\n+  void verify_self();\n+#endif \/\/ ASSERT\n+\n+};\n+\n+template <MemTag mem_tag>\n+class RBTreeCHeapAllocator {\n+public:\n+  void* allocate(size_t sz) {\n+    void* allocation = os::malloc(sz, mem_tag);\n+    if (allocation == nullptr) {\n+      vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR,\n+                            \"red-black tree failed allocation\");\n+    }\n+    return allocation;\n+  }\n+\n+  void free(void* ptr) { os::free(ptr); }\n+};\n+\n+template <typename K, typename V, typename COMPARATOR, MemTag mem_tag>\n+using RBTreeCHeap = RBTree<K, V, COMPARATOR, RBTreeCHeapAllocator<mem_tag>>;\n+\n+#endif \/\/ SHARE_UTILITIES_RBTREE_HPP\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,541 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RBTREE_INLINE_HPP\n+#define SHARE_UTILITIES_RBTREE_INLINE_HPP\n+\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/rbTree.hpp\"\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::replace_child(\n+    RBNode* old_child, RBNode* new_child) {\n+  if (_left == old_child) {\n+    _left = new_child;\n+  } else if (_right == old_child) {\n+    _right = new_child;\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_left() {\n+  \/\/ This node down, right child up\n+  RBNode* old_right = _right;\n+\n+  _right = old_right->_left;\n+  if (_right != nullptr) {\n+    _right->set_parent(this);\n+  }\n+\n+  old_right->set_parent(parent());\n+  if (parent() != nullptr) {\n+    parent()->replace_child(this, old_right);\n+  }\n+\n+  old_right->_left = this;\n+  set_parent(old_right);\n+\n+  return old_right;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_right() {\n+  \/\/ This node down, left child up\n+  RBNode* old_left = _left;\n+\n+  _left = old_left->_right;\n+  if (_left != nullptr) {\n+    _left->set_parent(this);\n+  }\n+\n+  old_left->set_parent(parent());\n+  if (parent() != nullptr) {\n+    parent()->replace_child(this, old_left);\n+  }\n+\n+  old_left->_right = this;\n+  set_parent(old_left);\n+\n+  return old_left;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::prev() {\n+  RBNode* node = this;\n+  if (_left != nullptr) { \/\/ right subtree exists\n+    node = _left;\n+    while (node->_right != nullptr) {\n+      node = node->_right;\n+    }\n+    return node;\n+  }\n+\n+  while (node != nullptr && node->is_left_child()) {\n+    node = node->parent();\n+  }\n+  return node->parent();\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::next() {\n+  RBNode* node = this;\n+  if (_right != nullptr) { \/\/ right subtree exists\n+    node = _right;\n+    while (node->_left != nullptr) {\n+      node = node->_left;\n+    }\n+    return node;\n+  }\n+\n+  while (node != nullptr && node->is_right_child()) {\n+    node = node->parent();\n+  }\n+  return node->parent();\n+}\n+\n+#ifdef ASSERT\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::verify(\n+    size_t& num_nodes, size_t& black_nodes_until_leaf, size_t& shortest_leaf_path, size_t& longest_leaf_path,\n+    size_t& tree_depth, bool expect_visited) {\n+  assert(expect_visited != _visited, \"node already visited\");\n+  _visited = !_visited;\n+\n+  size_t num_black_nodes_left = 0;\n+  size_t shortest_leaf_path_left = 0;\n+  size_t longest_leaf_path_left = 0;\n+  size_t tree_depth_left = 0;\n+\n+  if (_left != nullptr) {\n+    if (_right == nullptr) {\n+      assert(is_black() && _left->is_red(), \"if one child it must be red and node black\");\n+    }\n+    assert(COMPARATOR::cmp(_left->key(), _key) < 0, \"left node must be less than parent\");\n+    assert(is_black() || _left->is_black(), \"2 red nodes in a row\");\n+    assert(_left->parent() == this, \"pointer mismatch\");\n+    _left->verify(num_nodes, num_black_nodes_left, shortest_leaf_path_left,\n+                  longest_leaf_path_left, tree_depth_left, expect_visited);\n+  }\n+\n+  size_t num_black_nodes_right = 0;\n+  size_t shortest_leaf_path_right = 0;\n+  size_t longest_leaf_path_right = 0;\n+  size_t tree_depth_right = 0;\n+\n+  if (_right != nullptr) {\n+    if (_left == nullptr) {\n+      assert(is_black() && _right->is_red(), \"if one child it must be red and node black\");\n+    }\n+    assert(COMPARATOR::cmp(_right->key(), _key) > 0, \"right node must be greater than parent\");\n+    assert(is_black() || _left->is_black(), \"2 red nodes in a row\");\n+    assert(_right->parent() == this, \"pointer mismatch\");\n+    _right->verify(num_nodes, num_black_nodes_right, shortest_leaf_path_right,\n+                   longest_leaf_path_right, tree_depth_right, expect_visited);\n+  }\n+\n+  shortest_leaf_path = MAX2(longest_leaf_path_left, longest_leaf_path_right);\n+  longest_leaf_path = MAX2(longest_leaf_path_left, longest_leaf_path_right);\n+\n+  assert(shortest_leaf_path <= longest_leaf_path && longest_leaf_path <= shortest_leaf_path * 2,\n+         \"tree imbalanced, shortest path: %zu longest: %zu\", shortest_leaf_path, longest_leaf_path);\n+  assert(num_black_nodes_left == num_black_nodes_right,\n+         \"number of black nodes in left\/right subtree should match\");\n+\n+  num_nodes++;\n+  tree_depth = 1 + MAX2(tree_depth_left, tree_depth_right);\n+\n+  shortest_leaf_path++;\n+  longest_leaf_path++;\n+\n+  black_nodes_until_leaf = num_black_nodes_left;\n+  if (is_black()) {\n+    black_nodes_until_leaf++;\n+  }\n+\n+}\n+\n+#endif \/\/ ASSERT\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(const K& key) const {\n+  RBNode* curr = _root;\n+  while (curr != nullptr) {\n+    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n+\n+    if (key_cmp_k == 0) {\n+      return curr;\n+    } else if (key_cmp_k < 0) {\n+      curr = curr->_left;\n+    } else {\n+      curr = curr->_right;\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& key, const V& val) {\n+  RBNode* curr = _root;\n+  if (curr == nullptr) { \/\/ Tree is empty\n+    _root = allocate_node(key, val);\n+    return _root;\n+  }\n+\n+  RBNode* parent = nullptr;\n+  while (curr != nullptr) {\n+    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n+\n+    if (key_cmp_k == 0) {\n+      curr->_value = val;\n+      return curr;\n+    }\n+\n+    parent = curr;\n+    if (key_cmp_k < 0) {\n+      curr = curr->_left;\n+    } else {\n+      curr = curr->_right;\n+    }\n+  }\n+\n+  \/\/ Create and insert new node\n+  RBNode* node = allocate_node(key, val);\n+  node->set_parent(parent);\n+\n+  const int key_cmp_k = COMPARATOR::cmp(key, parent->key());\n+  if (key_cmp_k < 0) {\n+    parent->_left = node;\n+  } else {\n+    parent->_right = node;\n+  }\n+\n+  return node;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::fix_insert_violations(RBNode* node) {\n+  if (node->is_black()) { \/\/ node's value was updated\n+    return;               \/\/ Tree is already correct\n+  }\n+\n+  RBNode* parent = node->parent();\n+  while (parent != nullptr && parent->is_red()) {\n+    \/\/ Node and parent are both red, creating a red-violation\n+\n+    RBNode* grandparent = parent->parent();\n+    if (grandparent == nullptr) { \/\/ Parent is the tree root\n+      assert(parent == _root, \"parent must be root\");\n+      parent->set_black(); \/\/ Color parent black to eliminate the red-violation\n+      return;\n+    }\n+\n+    RBNode* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n+    if (is_black(uncle)) { \/\/ Parent is red, uncle is black\n+      \/\/ Rotate the parent to the position of the grandparent\n+      if (parent->is_left_child()) {\n+        if (node->is_right_child()) { \/\/ Node is an \"inner\" node\n+          \/\/ Rotate and swap node and parent to make it an \"outer\" node\n+          parent->rotate_left();\n+          parent = node;\n+        }\n+        grandparent->rotate_right(); \/\/ Rotate the parent to the position of the grandparent\n+      } else if (parent->is_right_child()) {\n+        if (node->is_left_child()) { \/\/ Node is an \"inner\" node\n+          \/\/ Rotate and swap node and parent to make it an \"outer\" node\n+          parent->rotate_right();\n+          parent = node;\n+        }\n+        grandparent->rotate_left(); \/\/ Rotate the parent to the position of the grandparent\n+      }\n+\n+      \/\/ Swap parent and grandparent colors to eliminate the red-violation\n+      parent->set_black();\n+      grandparent->set_red();\n+\n+      if (_root == grandparent) {\n+        _root = parent;\n+      }\n+\n+      return;\n+    }\n+\n+    \/\/ Parent and uncle are both red\n+    \/\/ Paint both black, paint grandparent red to not create a black-violation\n+    parent->set_black();\n+    uncle->set_black();\n+    grandparent->set_red();\n+\n+    \/\/ Move up two levels to check for new potential red-violation\n+    node = grandparent;\n+    parent = grandparent->parent();\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_black_leaf(RBNode* node) {\n+  \/\/ Black node removed, balancing needed\n+  RBNode* parent = node->parent();\n+  while (parent != nullptr) {\n+    \/\/ Sibling must exist. If it did not, node would need to be red to not break\n+    \/\/ tree properties, and could be trivially removed before reaching here\n+    RBNode* sibling = node->is_left_child() ? parent->_right : parent->_left;\n+    if (is_red(sibling)) { \/\/ Sibling red, parent and nephews must be black\n+      assert(is_black(parent), \"parent must be black\");\n+      assert(is_black(sibling->_left), \"nephew must be black\");\n+      assert(is_black(sibling->_right), \"nephew must be black\");\n+      \/\/ Swap parent and sibling colors\n+      parent->set_red();\n+      sibling->set_black();\n+\n+      \/\/ Rotate parent down and sibling up\n+      if (node->is_left_child()) {\n+        parent->rotate_left();\n+        sibling = parent->_right;\n+      } else {\n+        parent->rotate_right();\n+        sibling = parent->_left;\n+      }\n+\n+      if (_root == parent) {\n+        _root = parent->parent();\n+      }\n+      \/\/ Further balancing needed\n+    }\n+\n+    RBNode* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n+    RBNode* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n+    if (is_red(distant_nephew) || is_red(close_nephew)) {\n+      if (is_black(distant_nephew)) { \/\/ close red, distant black\n+        \/\/ Rotate sibling down and inner nephew up\n+        if (node->is_left_child()) {\n+          sibling->rotate_right();\n+        } else {\n+          sibling->rotate_left();\n+        }\n+\n+        distant_nephew = sibling;\n+        sibling = close_nephew;\n+\n+        distant_nephew->set_red();\n+        sibling->set_black();\n+      }\n+\n+      \/\/ Distant nephew red\n+      \/\/ Rotate parent down and sibling up\n+      if (node->is_left_child()) {\n+        parent->rotate_left();\n+      } else {\n+        parent->rotate_right();\n+      }\n+      if (_root == parent) {\n+        _root = sibling;\n+      }\n+\n+      \/\/ Swap parent and sibling colors\n+      if (parent->is_black()) {\n+        sibling->set_black();\n+      } else {\n+        sibling->set_red();\n+      }\n+      parent->set_black();\n+\n+      \/\/ Color distant nephew black to restore black balance\n+      distant_nephew->set_black();\n+      return;\n+    }\n+\n+    if (is_red(parent)) { \/\/ parent red, sibling and nephews black\n+      \/\/ Swap parent and sibling colors to restore black balance\n+      sibling->set_red();\n+      parent->set_black();\n+      return;\n+    }\n+\n+    \/\/ Parent, sibling, and both nephews black\n+    \/\/ Color sibling red and move up one level\n+    sibling->set_red();\n+    node = parent;\n+    parent = node->parent();\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_from_tree(RBNode* node) {\n+  RBNode* parent = node->parent();\n+  RBNode* left = node->_left;\n+  RBNode* right = node->_right;\n+  if (left != nullptr) { \/\/ node has a left only-child\n+    \/\/ node must be black, and child red, otherwise a black-violation would\n+    \/\/ exist Remove node and color the child black.\n+    assert(right == nullptr, \"right must be nullptr\");\n+    assert(is_black(node), \"node must be black\");\n+    assert(is_red(left), \"child must be red\");\n+    left->set_black();\n+    left->set_parent(parent);\n+    if (parent == nullptr) {\n+      assert(node == _root, \"node must be root\");\n+      _root = left;\n+    } else {\n+      parent->replace_child(node, left);\n+    }\n+  } else if (right != nullptr) { \/\/ node has a right only-child\n+    \/\/ node must be black, and child red, otherwise a black-violation would\n+    \/\/ exist Remove node and color the child black.\n+    assert(left == nullptr, \"left must be nullptr\");\n+    assert(is_black(node), \"node must be black\");\n+    assert(is_red(right), \"child must be red\");\n+    right->set_black();\n+    right->set_parent(parent);\n+    if (parent == nullptr) {\n+      assert(node == _root, \"node must be root\");\n+      _root = right;\n+    } else {\n+      parent->replace_child(node, right);\n+    }\n+  } else {               \/\/ node has no children\n+    if (node == _root) { \/\/ Tree empty\n+      _root = nullptr;\n+    } else {\n+      if (is_black(node)) {\n+        \/\/ Removed node is black, creating a black imbalance\n+        remove_black_leaf(node);\n+      }\n+      parent->replace_child(node, nullptr);\n+    }\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n+  assert(node != nullptr, \"must be\");\n+\n+  if (node->_left != nullptr && node->_right != nullptr) { \/\/ node has two children\n+    \/\/ Swap place with the in-order successor and delete there instead\n+    RBNode* curr = node->_right;\n+    while (curr->_left != nullptr) {\n+      curr = curr->_left;\n+    }\n+\n+    if (_root == node) _root = curr;\n+\n+    swap(curr->_left, node->_left);\n+    swap(curr->_parent, node->_parent); \/\/ Swaps parent and color\n+\n+    \/\/ If node is curr's parent, parent and right pointers become invalid\n+    if (node->_right == curr) {\n+      node->_right = curr->_right;\n+      node->set_parent(curr);\n+      curr->_right = node;\n+    } else {\n+      swap(curr->_right, node->_right);\n+      node->parent()->replace_child(curr, node);\n+      curr->_right->set_parent(curr);\n+    }\n+\n+    if (curr->parent() != nullptr) curr->parent()->replace_child(node, curr);\n+    curr->_left->set_parent(curr);\n+\n+\n+    if (node->_left != nullptr) node->_left->set_parent(node);\n+    if (node->_right != nullptr) node->_right->set_parent(node);\n+  }\n+\n+  remove_from_tree(node);\n+  free_node(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename F>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_in_order(F f) const {\n+  RBNode* to_visit[64];\n+  int stack_idx = 0;\n+  RBNode* head = _root;\n+  while (stack_idx > 0 || head != nullptr) {\n+    while (head != nullptr) {\n+      to_visit[stack_idx++] = head;\n+      head = head->_left;\n+    }\n+    head = to_visit[--stack_idx];\n+    f(head);\n+    head = head->_right;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename F>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_range_in_order(const K& from, const K& to, F f) {\n+  assert(COMPARATOR::cmp(from, to) <= 0, \"from must be less or equal to to\");\n+  RBNode* curr = closest_geq(from);\n+  if (curr == nullptr) return;\n+  RBNode* end = closest_geq(to);\n+\n+  while (curr != nullptr && curr != end) {\n+    f(curr);\n+    curr = curr->next();\n+  }\n+}\n+\n+#ifdef ASSERT\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::verify_self() {\n+  if (_root == nullptr) {\n+    assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n+    return;\n+  }\n+\n+  assert(_root->parent() == nullptr, \"root of rbtree has a parent\");\n+\n+  size_t num_nodes = 0;\n+  size_t black_depth = 0;\n+  size_t tree_depth = 0;\n+  size_t shortest_leaf_path = 0;\n+  size_t longest_leaf_path = 0;\n+  _expected_visited = !_expected_visited;\n+\n+  _root->verify(num_nodes, black_depth, shortest_leaf_path, longest_leaf_path, tree_depth, _expected_visited);\n+\n+  const unsigned int maximum_depth = log2i(size() + 1) * 2;\n+\n+  assert(shortest_leaf_path <= longest_leaf_path && longest_leaf_path <= shortest_leaf_path * 2,\n+         \"tree imbalanced, shortest path: %zu longest: %zu\",\n+         shortest_leaf_path, longest_leaf_path);\n+  assert(tree_depth <= maximum_depth, \"rbtree is too deep\");\n+  assert(size() == num_nodes,\n+         \"unexpected number of nodes in rbtree. expected: %zu\"\n+         \", actual: %zu\", size(), num_nodes);\n+}\n+#endif \/\/ ASSERT\n+\n+#endif \/\/ SHARE_UTILITIES_RBTREE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":541,"deletions":0,"binary":false,"changes":541,"status":"added"},{"patch":"@@ -0,0 +1,573 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/rbTree.hpp\"\n+#include \"utilities\/rbTree.inline.hpp\"\n+\n+\n+class RBTreeTest : public testing::Test {\n+public:\n+  struct Cmp {\n+    static int cmp(int a, int b) {\n+      return a - b;\n+    }\n+  };\n+\n+  struct CmpInverse {\n+    static int cmp(int a, int b) {\n+      return b - a;\n+    }\n+  };\n+\n+  struct FCmp {\n+    static int cmp(float a, float b) {\n+      if (a < b) return -1;\n+      if (a == b) return 0;\n+      return 1;\n+    }\n+  };\n+\n+\/\/ Bump-pointer style allocator that can't free\n+template <size_t AreaSize>\n+struct ArrayAllocator {\n+  uint8_t area[AreaSize];\n+  size_t offset = 0;\n+\n+  void* allocate(size_t sz) {\n+    if (offset + sz > AreaSize) {\n+      vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR,\n+                            \"red-black tree failed allocation\");\n+    }\n+    void* place = &area[offset];\n+    offset += sz;\n+    return place;\n+  }\n+\n+  void free(void* ptr) { }\n+};\n+\n+#ifdef ASSERT\n+  template<typename K, typename V, typename CMP, typename ALLOC>\n+  void verify_it(RBTree<K, V, CMP, ALLOC>& t) {\n+    t.verify_self();\n+  }\n+#endif \/\/ ASSERT\n+\n+using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtOther>;\n+\n+public:\n+  void inserting_duplicates_results_in_one_value() {\n+    constexpr int up_to = 10;\n+    GrowableArrayCHeap<int, mtTest> nums_seen(up_to, up_to, 0);\n+    RBTreeInt rbtree;\n+\n+    for (int i = 0; i < up_to; i++) {\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+    }\n+\n+    rbtree.visit_in_order([&](RBTreeInt::RBNode* node) {\n+      nums_seen.at(node->key())++;\n+    });\n+    for (int i = 0; i < up_to; i++) {\n+      EXPECT_EQ(1, nums_seen.at(i));\n+    }\n+  }\n+\n+  void rbtree_ought_not_leak() {\n+    struct LeakCheckedAllocator {\n+      int allocations;\n+\n+      LeakCheckedAllocator()\n+        : allocations(0) {\n+      }\n+\n+      void* allocate(size_t sz) {\n+        void* allocation = os::malloc(sz, mtTest);\n+        if (allocation == nullptr) {\n+          vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, \"rbtree failed allocation\");\n+        }\n+        ++allocations;\n+        return allocation;\n+      }\n+\n+      void free(void* ptr) {\n+        --allocations;\n+        os::free(ptr);\n+      }\n+    };\n+\n+    constexpr int up_to = 10;\n+    {\n+      RBTree<int, int, Cmp, LeakCheckedAllocator> rbtree;\n+      for (int i = 0; i < up_to; i++) {\n+        rbtree.upsert(i, i);\n+      }\n+      EXPECT_EQ(up_to, rbtree._allocator.allocations);\n+      for (int i = 0; i < up_to; i++) {\n+        rbtree.remove(i);\n+      }\n+      EXPECT_EQ(0, rbtree._allocator.allocations);\n+      EXPECT_EQ(nullptr, rbtree._root);\n+    }\n+\n+    {\n+      RBTree<int, int, Cmp, LeakCheckedAllocator> rbtree;\n+      for (int i = 0; i < up_to; i++) {\n+        rbtree.upsert(i, i);\n+      }\n+      rbtree.remove_all();\n+      EXPECT_EQ(0, rbtree._allocator.allocations);\n+      EXPECT_EQ(nullptr, rbtree._root);\n+    }\n+  }\n+\n+  void test_find() {\n+    struct Empty {};\n+    RBTreeCHeap<float, Empty, FCmp, mtOther> rbtree;\n+    using Node = RBTreeCHeap<float, Empty, FCmp, mtOther>::RBNode;\n+\n+    Node* n = nullptr;\n+    auto test = [&](float f) {\n+      EXPECT_EQ(nullptr, rbtree.find(f));\n+      rbtree.upsert(f, Empty{});\n+      const Node* n = rbtree.find_node(f);\n+      EXPECT_NE(nullptr, n);\n+      EXPECT_EQ(f, n->key());\n+    };\n+\n+    test(1.0f);\n+    test(5.0f);\n+    test(0.0f);\n+  }\n+\n+  void test_visitors() {\n+    { \/\/ Tests with 'default' ordering (ascending)\n+      RBTreeInt rbtree;\n+      using Node = RBTreeInt::RBNode;\n+\n+      rbtree.visit_range_in_order(0, 100, [&](Node* x) {\n+        EXPECT_TRUE(false) << \"Empty rbtree has no nodes to visit\";\n+      });\n+\n+      \/\/ Single-element set\n+      rbtree.upsert(1, 0);\n+      int count = 0;\n+      rbtree.visit_range_in_order(0, 100, [&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(1, count);\n+\n+      count = 0;\n+      rbtree.visit_in_order([&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(1, count);\n+\n+      \/\/ Add an element outside of the range that should not be visited on the right side and\n+      \/\/ one on the left side.\n+      rbtree.upsert(101, 0);\n+      rbtree.upsert(-1, 0);\n+      count = 0;\n+      rbtree.visit_range_in_order(0, 100, [&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(1, count);\n+\n+      count = 0;\n+      rbtree.visit_in_order([&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(3, count);\n+\n+      \/\/ Visiting empty range [0, 0) == {}\n+      rbtree.upsert(0, 0); \/\/ This node should not be visited.\n+      rbtree.visit_range_in_order(0, 0, [&](Node* x) {\n+        EXPECT_TRUE(false) << \"Empty visiting range should not visit any node\";\n+      });\n+\n+      rbtree.remove_all();\n+      for (int i = 0; i < 11; i++) {\n+        rbtree.upsert(i, 0);\n+      }\n+\n+      ResourceMark rm;\n+      GrowableArray<int> seen;\n+      rbtree.visit_range_in_order(0, 10, [&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(10, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(i, seen.at(i));\n+      }\n+\n+      seen.clear();\n+      rbtree.visit_in_order([&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(11, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(i, seen.at(i));\n+      }\n+\n+      seen.clear();\n+      rbtree.visit_range_in_order(10, 12, [&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(1, seen.length());\n+      EXPECT_EQ(10, seen.at(0));\n+    }\n+    { \/\/ Test with descending ordering\n+      RBTreeCHeap<int, int, CmpInverse, mtOther> rbtree;\n+      using Node = RBTreeCHeap<int, int, CmpInverse, mtOther>::RBNode;\n+\n+      for (int i = 0; i < 10; i++) {\n+        rbtree.upsert(i, 0);\n+      }\n+      ResourceMark rm;\n+      GrowableArray<int> seen;\n+      rbtree.visit_range_in_order(9, -1, [&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(10, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(10-i-1, seen.at(i));\n+      }\n+      seen.clear();\n+\n+      rbtree.visit_in_order([&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(10, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(10 - i - 1, seen.at(i));\n+      }\n+    }\n+  }\n+\n+  void test_closest_leq() {\n+    using Node = RBTreeInt::RBNode;\n+    {\n+      RBTreeInt rbtree;\n+      Node* n = rbtree.closest_leq(0);\n+      EXPECT_EQ(nullptr, n);\n+\n+      rbtree.upsert(0, 0);\n+      n = rbtree.closest_leq(0);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(-1, -1);\n+      n = rbtree.closest_leq(0);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(6, 0);\n+      n = rbtree.closest_leq(6);\n+      EXPECT_EQ(6, n->key());\n+\n+      n = rbtree.closest_leq(-2);\n+      EXPECT_EQ(nullptr, n);\n+    }\n+  }\n+\n+  void test_node_prev() {\n+    RBTreeInt _tree;\n+    using Node = RBTreeInt::RBNode;\n+    constexpr int num_nodes = 100;\n+\n+    for (int i = num_nodes; i > 0; i--) {\n+      _tree.upsert(i, i);\n+    }\n+\n+    Node* node = _tree.find_node(num_nodes);\n+    int count = num_nodes;\n+    while (node != nullptr) {\n+      EXPECT_EQ(count, node->val());\n+      node = node->prev();\n+      count--;\n+    }\n+\n+    EXPECT_EQ(count, 0);\n+  }\n+\n+    void test_node_next() {\n+    RBTreeInt _tree;\n+    using Node = RBTreeInt::RBNode;\n+    constexpr int num_nodes = 100;\n+\n+    for (int i = 0; i < num_nodes; i++) {\n+      _tree.upsert(i, i);\n+    }\n+\n+    Node* node = _tree.find_node(0);\n+    int count = 0;\n+    while (node != nullptr) {\n+      EXPECT_EQ(count, node->val());\n+      node = node->next();\n+      count++;\n+    }\n+\n+    EXPECT_EQ(count, num_nodes);\n+  }\n+\n+  void test_stable_nodes() {\n+    using Node = RBTreeInt::RBNode;\n+    RBTreeInt rbtree;\n+    ResourceMark rm;\n+    GrowableArray<Node*> a(10000);\n+    for (int i = 0; i < 10000; i++) {\n+      rbtree.upsert(i, i);\n+      a.push(rbtree.find_node(i));\n+    }\n+\n+    for (int i = 0; i < 2000; i++) {\n+      int r = os::random() % 10000;\n+      Node* to_delete = rbtree.find_node(r);\n+      if (to_delete != nullptr && to_delete->_left != nullptr &&\n+          to_delete->_right != nullptr) {\n+        rbtree.remove(to_delete);\n+      }\n+    }\n+\n+    \/\/ After deleting, nodes should have been moved around but kept their values\n+    for (int i = 0; i < 10000; i++) {\n+      const Node* n = rbtree.find_node(i);\n+      if (n != nullptr) {\n+        EXPECT_EQ(a.at(i), n);\n+      }\n+    }\n+  }\n+\n+  void test_stable_nodes_addresses() {\n+    using Tree = RBTreeCHeap<int, void*, Cmp, mtOther>;\n+    using Node = Tree::RBNode;\n+    Tree rbtree;\n+    for (int i = 0; i < 10000; i++) {\n+      rbtree.upsert(i, nullptr);\n+      Node* inserted_node = rbtree.find_node(i);\n+      inserted_node->val() = inserted_node;\n+    }\n+\n+    for (int i = 0; i < 2000; i++) {\n+      int r = os::random() % 10000;\n+      Node* to_delete = rbtree.find_node(r);\n+      if (to_delete != nullptr && to_delete->_left != nullptr &&\n+          to_delete->_right != nullptr) {\n+        rbtree.remove(to_delete);\n+      }\n+    }\n+\n+    \/\/ After deleting, values should have remained consistant\n+    rbtree.visit_in_order([&](Node* node) {\n+      EXPECT_EQ(node, node->val());\n+    });\n+  }\n+\n+#ifdef ASSERT\n+  void test_fill_verify() {\n+    RBTreeInt rbtree;\n+\n+    ResourceMark rm;\n+    GrowableArray<int> allocations;\n+\n+    int size = 10000;\n+    \/\/ Create random values\n+    for (int i = 0; i < size; i++) {\n+      int r = os::random() % size;\n+      allocations.append(r);\n+    }\n+\n+    \/\/ Insert ~half of the values\n+    for (int i = 0; i < size; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(allocations.at(i), allocations.at(i));\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+\n+    \/\/ Insert and remove randomly\n+    for (int i = 0; i < size; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(allocations.at(i), allocations.at(i));\n+      } else {\n+        rbtree.remove(allocations.at(i));\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+\n+    \/\/ Remove all elements\n+    for (int i = 0; i < size; i++) {\n+      rbtree.remove(allocations.at(i));\n+    }\n+\n+    verify_it(rbtree);\n+    EXPECT_EQ(rbtree.size(), 0UL);\n+  }\n+\n+  void test_nodes_visited_once() {\n+    constexpr size_t memory_size = 65536;\n+    using Tree = RBTree<int, int, Cmp, ArrayAllocator<memory_size>>;\n+    using Node = Tree::RBNode;\n+\n+    Tree tree;\n+\n+    int num_nodes = memory_size \/ sizeof(Node);\n+    for (int i = 0; i < num_nodes; i++) {\n+      tree.upsert(i, i);\n+    }\n+\n+    Node* start = tree.find_node(0);\n+\n+    Node* node = start;\n+    for (int i = 0; i < num_nodes; i++) {\n+      EXPECT_EQ(tree._expected_visited, node->_visited);\n+      node += 1;\n+    }\n+\n+    verify_it(tree);\n+\n+    node = start;\n+    for (int i = 0; i < num_nodes; i++) {\n+      EXPECT_EQ(tree._expected_visited, node->_visited);\n+      node += 1;\n+    }\n+\n+  }\n+#endif \/\/ ASSERT\n+\n+};\n+\n+TEST_VM_F(RBTreeTest, InsertingDuplicatesResultsInOneValue) {\n+  this->inserting_duplicates_results_in_one_value();\n+}\n+\n+TEST_VM_F(RBTreeTest, RBTreeOughtNotLeak) {\n+  this->rbtree_ought_not_leak();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestFind) {\n+  this->test_find();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestVisitors) {\n+  this->test_visitors();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestClosestLeq) {\n+  this->test_closest_leq();\n+}\n+\n+TEST_VM_F(RBTreeTest, NodePrev) {\n+  this->test_node_prev();\n+}\n+\n+TEST_VM_F(RBTreeTest, NodeNext) {\n+  this->test_node_next();\n+}\n+\n+TEST_VM_F(RBTreeTest, NodeStableTest) {\n+  this->test_stable_nodes();\n+}\n+\n+TEST_VM_F(RBTreeTest, NodeStableAddressTest) {\n+  this->test_stable_nodes_addresses();\n+}\n+\n+#ifdef ASSERT\n+TEST_VM_F(RBTreeTest, FillAndVerify) {\n+  this->test_fill_verify();\n+}\n+\n+TEST_VM_F(RBTreeTest, NodesVisitedOnce) {\n+  this->test_nodes_visited_once();\n+}\n+\n+TEST_VM_F(RBTreeTest, InsertRemoveVerify) {\n+  constexpr int num_nodes = 100;\n+  for (int n_t1 = 0; n_t1 < num_nodes; n_t1++) {\n+    for (int n_t2 = 0; n_t2 < n_t1; n_t2++) {\n+      RBTreeInt tree;\n+      for (int i = 0; i < n_t1; i++) {\n+        tree.upsert(i, i);\n+      }\n+      for (int i = 0; i < n_t2; i++) {\n+        tree.remove(i);\n+      }\n+      verify_it(tree);\n+    }\n+  }\n+}\n+\n+TEST_VM_F(RBTreeTest, VerifyItThroughStressTest) {\n+  { \/\/ Repeatedly verify a tree of moderate size\n+    RBTreeInt rbtree;\n+    constexpr int ten_thousand = 10000;\n+    for (int i = 0; i < ten_thousand; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(i, i);\n+      } else {\n+        rbtree.remove(i);\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+    for (int i = 0; i < ten_thousand; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(i, i);\n+      } else {\n+        rbtree.remove(i);\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+  }\n+  { \/\/ Make a very large tree and verify at the end\n+    struct Nothing {};\n+    RBTreeCHeap<int, Nothing, Cmp, mtOther> rbtree;\n+    constexpr int one_hundred_thousand = 100000;\n+    for (int i = 0; i < one_hundred_thousand; i++) {\n+      rbtree.upsert(i, Nothing());\n+    }\n+    verify_it(rbtree);\n+  }\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":573,"deletions":0,"binary":false,"changes":573,"status":"added"}]}