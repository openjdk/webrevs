{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -31,0 +32,1 @@\n+#include <type_traits>\n@@ -38,0 +40,2 @@\n+\/\/ Key needs to be of a type that is trivially destructable\n+\/\/ The tree will call a value's destructor when its node is removed\n@@ -50,0 +54,1 @@\n+    friend class RBTreeTest;\n@@ -56,1 +61,1 @@\n-    K _key;\n+    const K _key;\n@@ -93,8 +98,0 @@\n-    \/\/ Visit all RBNodes in ascending order.\n-    template <typename F>\n-    void visit_in_order_inner(F f);\n-\n-    \/\/ Visit all RBNodes in ascending order whose keys are in range [from, to).\n-    template <typename F>\n-    void visit_range_in_order_inner(const K& from, const K& to, F f);\n-\n@@ -112,3 +109,1 @@\n-    if (node_place == nullptr) {\n-      return nullptr;\n-    }\n+    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n@@ -120,0 +115,1 @@\n+    node->_value.~V();\n@@ -134,0 +130,1 @@\n+   \/\/ If the node with key k already exist, the value is updated instead.\n@@ -143,2 +140,0 @@\n-  void remove_all_inner(RBNode* node);\n-\n@@ -148,1 +143,3 @@\n-  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) {}\n+  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) {\n+    static_assert(std::is_trivially_destructible<K>::value, \"key type must be trivially destructable\");\n+  }\n@@ -173,1 +170,10 @@\n-    remove_all_inner(_root);\n+    GrowableArrayCHeap<RBNode*, mtInternal> to_delete(2 * log2i(_num_nodes + 1));\n+    to_delete.push(_root);\n+\n+    while (!to_delete.is_empty()) {\n+      RBNode* head = to_delete.pop();\n+      if (head == nullptr) continue;\n+      to_delete.push(head->_left);\n+      to_delete.push(head->_right);\n+      free_node(head);\n+    }\n@@ -242,3 +248,1 @@\n-  void visit_in_order(F f) const {\n-    _root->visit_in_order_inner(f);\n-  }\n+  void visit_in_order(F f);\n@@ -248,6 +252,1 @@\n-  void visit_range_in_order(const K& from, const K& to, F f) {\n-    if (_root == nullptr) {\n-      return;\n-    }\n-    _root->visit_range_in_order_inner(from, to, f);\n-  }\n+  void visit_range_in_order(const K& from, const K& to, F f);\n@@ -266,1 +265,0 @@\n-    RBNode* _next;\n@@ -275,0 +273,1 @@\n+      _to_visit.reserve(2 * log2i(_tree->_num_nodes + 1));\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,29 +90,0 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-template <typename F>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::visit_in_order_inner(F f) {\n-  if (_left != nullptr) {\n-    _left->visit_in_order_inner(f);\n-  }\n-  f(this);\n-  if (_right != nullptr) {\n-    _right->visit_in_order_inner(f);\n-  }\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-template <typename F>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::visit_range_in_order_inner(\n-    const K& from, const K& to, F f) {\n-  int cmp_from = COMPARATOR::cmp(from, key());\n-  int cmp_to = COMPARATOR::cmp(to, key());\n-  if (_left != nullptr && cmp_from < 0) { \/\/ from < key\n-    _left->visit_range_in_order_inner(from, to, f);\n-  }\n-  if (cmp_from <= 0 && cmp_to > 0) { \/\/ from <= key && to > key\n-    f(this);\n-  }\n-  if (_right != nullptr && cmp_to > 0) { \/\/ to > key\n-    _right->visit_range_in_order_inner(from, to, f);\n-  }\n-}\n-\n@@ -167,1 +138,1 @@\n-    if (key_cmp_k == 0) {       \/\/ k == key\n+    if (key_cmp_k == 0) {\n@@ -169,1 +140,1 @@\n-    } else if (key_cmp_k < 0) { \/\/ k < key\n+    } else if (key_cmp_k < 0) {\n@@ -171,1 +142,1 @@\n-    } else {                    \/\/ k > key\n+    } else {\n@@ -192,1 +163,1 @@\n-    if (key_cmp_k == 0) { \/\/ k == key\n+    if (key_cmp_k == 0) {\n@@ -198,1 +169,1 @@\n-    if (key_cmp_k < 0) { \/\/ k < key\n+    if (key_cmp_k < 0) {\n@@ -200,1 +171,1 @@\n-    } else {             \/\/ k > key\n+    } else {\n@@ -210,1 +181,1 @@\n-  if (key_cmp_k < 0) { \/\/ k < key\n+  if (key_cmp_k < 0) {\n@@ -212,1 +183,1 @@\n-  } else {             \/\/ k > key\n+  } else {\n@@ -412,10 +383,0 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_all_inner(RBNode* node) {\n-  if (node == nullptr) {\n-    return;\n-  }\n-  remove_all_inner(node->_left);\n-  remove_all_inner(node->_right);\n-  free_node(node);\n-}\n-\n@@ -429,1 +390,1 @@\n-    \/\/ Copy the k\/v from the in-order successor and delete that node instead\n+    \/\/ Swap place with the in-order successor and delete there instead\n@@ -434,2 +395,0 @@\n-    node->_key = curr->key();\n-    node->_value = curr->val();\n@@ -437,1 +396,23 @@\n-    node = curr;\n+    if (_root == node) _root = curr;\n+\n+    std::swap(curr->_left, node->_left);\n+    std::swap(curr->_color, node->_color);\n+\n+    \/\/ If node is curr's parent, swapping right\/parent severs the node connection\n+    if (node->_right == curr) {\n+      node->_right = curr->_right;\n+      curr->_parent = node->_parent;\n+      node->_parent = curr;\n+      curr->_right = node;\n+    } else {\n+      std::swap(curr->_right, node->_right);\n+      std::swap(curr->_parent, node->_parent);\n+      node->_parent->replace_child(curr, node);\n+      curr->_right->_parent = curr;\n+    }\n+\n+    if (curr->_parent != nullptr) curr->_parent->replace_child(node, curr);\n+    curr->_left->_parent = curr;\n+\n+    if (node->_left != nullptr) node->_left->_parent = node;\n+    if (node->_right != nullptr) node->_right->_parent = node;\n@@ -445,0 +426,48 @@\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename F>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_in_order(F f) {\n+  GrowableArrayCHeap<RBNode*, mtInternal> to_visit(2 * log2i(_num_nodes + 1));\n+  RBNode* head = _root;\n+  while (!to_visit.is_empty() || head != nullptr) {\n+    while (head != nullptr) {\n+      to_visit.push(head);\n+      head = head->_left;\n+    }\n+    head = to_visit.pop();\n+    f(head);\n+    head = head->_right;\n+  }\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename F>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_range_in_order(const K& from, const K& to, F f) {\n+  assert(COMPARATOR::cmp(from, to) <= 0, \"from must be less or equal to to\");\n+  GrowableArrayCHeap<RBNode*, mtInternal> to_visit;\n+  RBNode* head = _root;\n+  while (!to_visit.is_empty() || head != nullptr) {\n+    while (head != nullptr) {\n+      int cmp_from = COMPARATOR::cmp(head->_key, from);\n+      to_visit.push(head);\n+      if (cmp_from >= 0) {\n+        head = head->_left;\n+      } else {\n+        \/\/ We've reached a node which is strictly less than from\n+        \/\/ We don't need to visit any further to the left.\n+        break;\n+      }\n+    }\n+    head = to_visit.pop();\n+    const int cmp_from = COMPARATOR::cmp(head->_key, from);\n+    const int cmp_to = COMPARATOR::cmp(head->_key, to);\n+    if (cmp_from >= 0 && cmp_to < 0) {\n+      f(head);\n+    }\n+    if (cmp_to < 0) {\n+      head = head->_right;\n+    } else {\n+      head = nullptr;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":81,"deletions":52,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,1 +282,37 @@\n-  void test_iterator() {\n+  void test_stable_nodes() {\n+    using Node = RBTreeInt::RBNode;\n+    RBTreeInt rbtree;\n+    ResourceMark rm;\n+    GrowableArray<Node*> a(10000);\n+    for (int i = 0; i < 10000; i++) {\n+      rbtree.upsert(i, i);\n+      a.push(rbtree.find_node(rbtree._root, i));\n+    }\n+\n+    for (int i = 0; i < 2000; i++) {\n+      int r = os::random() % 10000;\n+      Node* to_delete = rbtree.find_node(rbtree._root, r);\n+      if (to_delete != nullptr && to_delete->_left != nullptr &&\n+          to_delete->_right != nullptr) {\n+        rbtree.remove(to_delete);\n+      }\n+    }\n+\n+    \/\/ After deleting, nodes should have been moved around but kept their values\n+    for (int i = 0; i < 10000; i++) {\n+      Node* n = rbtree.find_node(rbtree._root, i);\n+      if (n != nullptr) {\n+        assert(a.at(i) == n, \"must be same\");\n+      }\n+    }\n+  }\n+\n+  void test_empty_iterator() {\n+    RBTreeInt tree;\n+    RBTreeInt::Iterator iterator(&tree);\n+    RBTreeInt::ReverseIterator reverse_iterator(&tree);\n+    EXPECT_FALSE(iterator.has_next());\n+    EXPECT_FALSE(reverse_iterator.has_next());\n+  }\n+\n+    void test_iterator() {\n@@ -294,0 +330,1 @@\n+    EXPECT_FALSE(iterator.has_next());\n@@ -300,0 +337,1 @@\n+    EXPECT_FALSE(reverse_iterator.has_next());\n@@ -372,0 +410,8 @@\n+TEST_VM_F(RBTreeTest, NodeStableTest) {\n+  this->test_stable_nodes();\n+}\n+\n+TEST_VM_F(RBTreeTest, EmptyIteratorTest) {\n+  this->test_empty_iterator();\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"}]}