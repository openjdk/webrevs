{"files":[{"patch":"@@ -0,0 +1,694 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RBTREE_HPP\n+#define SHARE_UTILITIES_RBTREE_HPP\n+\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+\/\/ COMPARATOR must have a static function `cmp(a,b)` which returns:\n+\/\/     - an int < 0 when a < b\n+\/\/     - an int == 0 when a == b\n+\/\/     - an int > 0 when a > b\n+\/\/ ALLOCATOR must check for oom and exit, as RBTree currently does not handle the\n+\/\/ allocation failing.\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+class RBTree {\n+  friend class RBTreeTest;\n+\n+private:\n+  ALLOCATOR _allocator;\n+  size_t _num_nodes;\n+\n+public:\n+  class RBNode {\n+    friend RBTree;\n+\n+  private:\n+    RBNode* _parent;\n+    RBNode* _left;\n+    RBNode* _right;\n+\n+    K _key;\n+    V _value;\n+\n+    enum Color : uint8_t { BLACK, RED };\n+    Color _color;\n+\n+  public:\n+    const K& key() const { return _key; }\n+    V& val() { return _value; }\n+\n+  private:\n+    bool is_black() const { return _color == BLACK; }\n+    bool is_red() const { return _color == RED; }\n+\n+    void color_black() { _color = BLACK; }\n+    void color_red() { _color = RED; }\n+\n+    RBNode(const K &k, const V &v)\n+        : _parent(nullptr), _left(nullptr), _right(nullptr),\n+          _key(k), _value(v), _color(RED) {}\n+\n+    bool is_right_child() {\n+      return _parent != nullptr && _parent->_right == this;\n+    }\n+\n+    bool is_left_child() {\n+      return _parent != nullptr && _parent->_left == this;\n+    }\n+\n+    void replace_child(RBNode* old_child, RBNode* new_child) {\n+      if (_left == old_child) {\n+        _left = new_child;\n+      } else if (_right == old_child) {\n+        _right = new_child;\n+      }\n+    }\n+\n+    RBNode* rotate_left() {\n+      \/\/ Move node down to the left, and right child up\n+      RBNode* old_right = _right;\n+\n+      _right = old_right->_left;\n+      if (old_right->_left != nullptr) {\n+        old_right->_left->_parent = this;\n+      }\n+\n+      old_right->_parent = _parent;\n+      if (is_left_child()) {\n+        _parent->_left = old_right;\n+      } else if (is_right_child()) {\n+        _parent->_right = old_right;\n+      }\n+\n+      old_right->_left = this;\n+      _parent = old_right;\n+\n+      return old_right;\n+    }\n+\n+    RBNode* rotate_right() {\n+      \/\/ Move node down to the right, and left child up\n+      RBNode* old_left = _left;\n+\n+      _left = old_left->_right;\n+      if (old_left->_right != nullptr) {\n+        old_left->_right->_parent = this;\n+      }\n+\n+      old_left->_parent = _parent;\n+      if (is_left_child()) {\n+        _parent->_left = old_left;\n+      } else if (is_right_child()) {\n+        _parent->_right = old_left;\n+      }\n+\n+      old_left->_right = this;\n+      _parent = old_left;\n+\n+      return old_left;\n+    }\n+\n+    template <typename F>\n+    void visit_in_order_inner(F f) {\n+      if (_left != nullptr) {\n+        _left->visit_in_order_inner(f);\n+      }\n+      f(this);\n+      if (_right != nullptr) {\n+        _right->visit_in_order_inner(f);\n+      }\n+    }\n+\n+    \/\/ Visit all RBNodes in ascending order whose keys are in range [from, to).\n+    template <typename F>\n+    void visit_range_in_order_inner(const K& from, const K& to, F f) {\n+      int cmp_from = COMPARATOR::cmp(from, key());\n+      int cmp_to = COMPARATOR::cmp(to, key());\n+      if (_left != nullptr && cmp_from < 0) { \/\/ from < key\n+        _left->visit_range_in_order_inner(from, to, f);\n+      }\n+      if (cmp_from <= 0 && cmp_to > 0) { \/\/ from <= key && to > key\n+        f(this);\n+      }\n+      if (_right != nullptr && cmp_to > 0) { \/\/ to > key\n+        _right->visit_range_in_order_inner(from, to, f);\n+      }\n+    }\n+\n+#ifdef ASSERT\n+    bool is_correct(unsigned int num_blacks) const {\n+      if (is_black()) {\n+        num_blacks--;\n+      }\n+\n+      bool left_is_correct = num_blacks == 0;\n+      bool right_is_correct = num_blacks == 0;\n+      if (_left != nullptr) {\n+        if (COMPARATOR::cmp(_left->key(), _key) >= 0 || \/\/ left >= root, or\n+            (is_red() && _left->is_red())            || \/\/ 2 red nodes, or\n+            (_left->_parent != this)) {                 \/\/ Pointer mismatch,\n+          return false;                                 \/\/ all incorrect.\n+        }\n+        left_is_correct = _left->is_correct(num_blacks);\n+      }\n+      if (_right != nullptr) {\n+        if (COMPARATOR::cmp(_right->key(), _key) <= 0 || \/\/ right <= root, or\n+            (is_red() && _left->is_red())             || \/\/ 2 red nodes, or\n+            (_right->_parent != this)) {                 \/\/ Pointer mismatch,\n+          return false;                                  \/\/ all incorrect.\n+        }\n+        right_is_correct = _right->is_correct(num_blacks);\n+      }\n+      return left_is_correct && right_is_correct;\n+    }\n+\n+    size_t count_nodes() const {\n+      size_t left_nodes = _left == nullptr ? 0 : _left->count_nodes();\n+      size_t right_nodes = _right == nullptr ? 0 : _right->count_nodes();\n+      return 1 + left_nodes + right_nodes;\n+    }\n+#endif \/\/ ASSERT\n+  };\n+\n+private:\n+  RBNode* _root;\n+\n+  RBNode* allocate_node(const K& k, const V& v) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode));\n+    if (node_place == nullptr) {\n+      return nullptr;\n+    }\n+    _num_nodes++;\n+    return new (node_place) RBNode(k, v);\n+  }\n+\n+  void free_node(RBNode* node) {\n+    _allocator.free(node);\n+    _num_nodes--;\n+  }\n+\n+  static inline bool is_black(RBNode* node) {\n+    return node == nullptr || node->is_black();\n+  }\n+\n+  static inline bool is_red(RBNode* node) {\n+    return node != nullptr && node->is_red();\n+  }\n+\n+  RBNode* find(RBNode* curr, const K& k) {\n+    while (curr != nullptr) {\n+      int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n+\n+      if (key_cmp_k == 0) {       \/\/ k == key\n+        return curr;\n+      } else if (key_cmp_k < 0) { \/\/ k < key\n+        curr = curr->_left;\n+      } else {                    \/\/ k > key\n+        curr = curr->_right;\n+      }\n+    }\n+\n+    return nullptr;\n+  }\n+\n+  RBNode* insert_node(const K& k, const V& v) {\n+    RBNode* curr = _root;\n+    if (curr == nullptr) { \/\/ Tree is empty\n+      _root = allocate_node(k, v);\n+      return _root;\n+    }\n+\n+    RBNode* parent = nullptr;\n+    while (curr != nullptr) {\n+      int key_cmp_k = COMPARATOR::cmp(k, curr->key());\n+\n+      if (key_cmp_k == 0) { \/\/ k == key\n+        curr->_value = v;\n+        return curr;\n+      }\n+\n+      parent = curr;\n+      if (key_cmp_k < 0) { \/\/ k < key\n+        curr = curr->_left;\n+      } else {             \/\/ k > key\n+        curr = curr->_right;\n+      }\n+    }\n+\n+    \/\/ Create and insert new node\n+    RBNode* node = allocate_node(k, v);\n+    node->_parent = parent;\n+\n+    int key_cmp_k = COMPARATOR::cmp(k, parent->key());\n+    if (key_cmp_k < 0) { \/\/ k < key\n+      parent->_left = node;\n+    } else {             \/\/ k > key\n+      parent->_right = node;\n+    }\n+\n+    return node;\n+  }\n+\n+  void fix_insert_violations(RBNode* node) {\n+    if(node->is_black()) { \/\/ node's value was updated\n+      return;              \/\/ Tree is already correct\n+    }\n+\n+    RBNode* parent = node->_parent;\n+    while (parent != nullptr && parent->is_red()) {\n+      \/\/ Node and parent are both red, creating a red-violation\n+\n+      RBNode* grandparent = parent->_parent;\n+      if (grandparent == nullptr) { \/\/ Parent is the tree root\n+        assert(parent == _root, \"parent must be root\");\n+        parent->color_black();      \/\/ Color parent black to eliminate the red-violation\n+        return;\n+      }\n+\n+      RBNode* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n+      if (is_black(uncle)) { \/\/ Parent is red, uncle is black\n+        \/\/ Rotate the parent to the position of the grandparent\n+        if (parent->is_left_child()) {\n+          if (node->is_right_child()) { \/\/ Node is an \"inner\" node\n+            \/\/ Rotate and swap node and parent to make it an \"outer\" node\n+            parent->rotate_left();\n+            parent = node;\n+          }\n+          grandparent->rotate_right();  \/\/ Rotate the parent to the position of the grandparent\n+        } else if (parent->is_right_child()) {\n+          if (node->is_left_child()) {  \/\/ Node is an \"inner\" node\n+            \/\/ Rotate and swap node and parent to make it an \"outer\" node\n+            parent->rotate_right();\n+            parent = node;\n+          }\n+          grandparent->rotate_left();   \/\/ Rotate the parent to the position of the grandparent\n+        }\n+\n+        \/\/ Swap parent and grandparent colors to eliminate the red-violation\n+        parent->color_black();\n+        grandparent->color_red();\n+\n+        if (_root == grandparent) {\n+          _root = parent;\n+        }\n+\n+        return;\n+      }\n+\n+      \/\/ Parent and uncle are both red\n+      \/\/ Paint both black, paint grandparent red to not create a black-violation\n+      parent->color_black();\n+      uncle->color_black();\n+      grandparent->color_red();\n+\n+      \/\/ Move up two levels to check for new potential red-violation\n+      node = grandparent;\n+      parent = grandparent->_parent;\n+    }\n+  }\n+\n+  void remove_black_leaf(RBNode* node) {\n+    \/\/ Black node removed, balancing needed\n+    RBNode* parent = node->_parent;\n+    while (parent != nullptr) {\n+      \/\/ Sibling must exist. If it did not, node would need to be red to not break tree properties,\n+      \/\/ and could be trivially removed before reaching here\n+      RBNode* sibling = node->is_left_child() ? parent->_right : parent->_left;\n+      if (is_red(sibling)) { \/\/ Sibling red, parent and nephews must be black\n+        assert(is_black(parent), \"parent must be black\");\n+        assert(is_black(sibling->_left), \"nephew must be black\");\n+        assert(is_black(sibling->_right), \"nephew must be black\");\n+        \/\/ Swap parent and sibling colors\n+        parent->color_red();\n+        sibling->color_black();\n+\n+        \/\/ Rotate parent down and sibling up\n+        if (node->is_left_child()) {\n+          parent->rotate_left();\n+          sibling = parent->_right;\n+        } else {\n+          parent->rotate_right();\n+          sibling = parent->_left;\n+        }\n+\n+        if (_root == parent) {\n+          _root = parent->_parent;\n+        }\n+        \/\/ Further balancing needed\n+      }\n+\n+      RBNode* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n+      RBNode* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n+      if (is_red(distant_nephew) || is_red(close_nephew)) {\n+        if (is_black(distant_nephew)) { \/\/ close red, distant black\n+          \/\/ Rotate sibling down and inner nephew up\n+          if (node->is_left_child()) {\n+            sibling->rotate_right();\n+          } else {\n+            sibling->rotate_left();\n+          }\n+\n+          distant_nephew = sibling;\n+          sibling = close_nephew;\n+\n+          distant_nephew->color_red();\n+          sibling->color_black();\n+        }\n+\n+        \/\/ Distant nephew red\n+        \/\/ Rotate parent down and sibling up\n+        if (node->is_left_child()) {\n+          parent->rotate_left();\n+        } else {\n+          parent->rotate_right();\n+        }\n+        if (_root == parent) {\n+          _root = sibling;\n+        }\n+\n+        \/\/ Swap parent and sibling colors\n+        if (parent->is_black()) {\n+          sibling->color_black();\n+        } else {\n+          sibling->color_red();\n+        }\n+        parent->color_black();\n+        if (sibling->is_black()) {\n+        }\n+\n+        \/\/ Color distant nephew black to restore black balance\n+        distant_nephew->color_black();\n+        return;\n+      }\n+\n+      if (is_red(parent)) { \/\/ parent red, sibling and nephews black\n+        \/\/ Swap parent and sibling colors to restore black balance\n+        sibling->color_red();\n+        parent->color_black();\n+        return;\n+      }\n+\n+      \/\/ Parent, sibling, and both nephews black\n+      \/\/ Color sibling red and move up one level\n+      sibling->color_red();\n+      node = parent;\n+      parent = node->_parent;\n+    }\n+  }\n+\n+  \/\/ Assumption: node has at most one child. Two children is handled in `remove()`\n+  void remove_from_tree(RBNode* node) {\n+    RBNode* parent = node->_parent;\n+    RBNode* left = node->_left;\n+    RBNode* right = node->_right;\n+    if (left != nullptr) { \/\/ node has a left only-child\n+      \/\/ node must be black, and child red, otherwise a black-violation would exist\n+      \/\/ Remove node and color the child black.\n+      assert(right == nullptr, \"right must be nullptr\");\n+      assert(is_black(node), \"node must be black\");\n+      assert(is_red(left), \"child must be red\");\n+      left->color_black();\n+      left->_parent = parent;\n+      if (parent == nullptr) {\n+        assert(node == _root, \"node must be root\");\n+        _root = left;\n+      } else {\n+        parent->replace_child(node, left);\n+      }\n+    } else if (right != nullptr) { \/\/ node has a right only-child\n+      \/\/ node must be black, and child red, otherwise a black-violation would exist\n+      \/\/ Remove node and color the child black.\n+      assert(left == nullptr, \"left must be nullptr\");\n+      assert(is_black(node), \"node must be black\");\n+      assert(is_red(right), \"child must be red\");\n+      right->color_black();\n+      right->_parent = parent;\n+      if (parent == nullptr) {\n+        assert(node == _root, \"node must be root\");\n+        _root = right;\n+      } else {\n+        parent->replace_child(node, right);\n+      }\n+    } else { \/\/ node has no children\n+      if (node == _root) { \/\/ Tree empty\n+        _root = nullptr;\n+      } else {\n+        if (is_black(node)) {\n+          \/\/ Removed node is black, creating a black imbalance\n+          remove_black_leaf(node);\n+        }\n+        parent->replace_child(node, nullptr);\n+      }\n+    }\n+  }\n+\n+  void remove_all_inner(RBNode* node) {\n+    if (node == nullptr) {\n+      return;\n+    }\n+    remove_all_inner(node->_left);\n+    remove_all_inner(node->_right);\n+    free_node(node);\n+  }\n+\n+public:\n+  NONCOPYABLE(RBTree);\n+\n+  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) {}\n+  ~RBTree() { this->remove_all(); }\n+\n+  size_t size() { return _num_nodes; }\n+\n+  void upsert(const K& k, const V& v) {\n+    RBNode* node = insert_node(k, v);\n+    fix_insert_violations(node);\n+  }\n+\n+  bool remove(const K& k) {\n+    RBNode* node = find(_root, k);\n+    return remove(node);\n+  }\n+\n+  bool remove(RBNode* node) {\n+    if (node == nullptr) {\n+      return false;\n+    }\n+\n+    if (node->_left != nullptr && node->_right != nullptr) { \/\/ node has two children\n+      \/\/ Copy the k\/v from the in-order successor and delete that node instead\n+      RBNode* curr = node->_right;\n+      while (curr->_left != nullptr) {\n+        curr = curr->_left;\n+      }\n+      node->_key = curr->key();\n+      node->_value = curr->val();\n+\n+      node = curr;\n+    }\n+\n+    remove_from_tree(node);\n+    free_node(node);\n+    return true;\n+  }\n+\n+  void remove_all() {\n+    remove_all_inner(_root);\n+    _num_nodes = 0;\n+    _root = nullptr;\n+  }\n+\n+  RBNode* closest_leq(const K& key) {\n+    RBNode* candidate = nullptr;\n+    RBNode* pos = _root;\n+    while (pos != nullptr) {\n+      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r == 0) { \/\/ Exact match\n+        candidate = pos;\n+        break; \/\/ Can't become better than that.\n+      }\n+      if (cmp_r < 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_right;\n+      } else if (cmp_r > 0) {\n+        pos = pos->_left;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  RBNode* closest_gt(const K& key) {\n+    RBNode* candidate = nullptr;\n+    RBNode* pos = _root;\n+    while (pos != nullptr) {\n+      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r > 0) { \/\/ node > key\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_left;\n+      } else { \/\/ node <= key\n+        pos = pos->_right;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  struct Range {\n+    RBNode* start;\n+    RBNode* end;\n+    Range(RBNode* start, RBNode* end)\n+    : start(start), end(end) {}\n+  };\n+\n+  \/\/ Return the range [start, end)\n+  \/\/ where start->key() <= addr < end->key().\n+  \/\/ Failure to find the range leads to start and\/or end being null.\n+  Range find_enclosing_range(K addr) {\n+    RBNode* start = closest_leq(addr);\n+    RBNode* end = closest_gt(addr);\n+    return Range(start, end);\n+  }\n+\n+  V* find(K& key) {\n+    RBNode* node = find(_root, key);\n+    if (node == nullptr) {\n+      return nullptr;\n+    }\n+    return &node->val();\n+  }\n+\n+  \/\/ Visit all RBNodes in ascending order.\n+  template <typename F>\n+  void visit_in_order(F f) const {\n+    _root->visit_in_order_inner(f);\n+  }\n+\n+  \/\/ Visit all RBNodes in ascending order whose keys are in range [from, to).\n+  template <typename F>\n+  void visit_range_in_order(const K& from, const K& to, F f) {\n+    if (_root == nullptr)\n+      return;\n+    _root->visit_range_in_order_inner(from, to, f);\n+  }\n+\n+#ifdef ASSERT\n+  void verify_self() {\n+    if (_root == nullptr) {\n+      assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n+      return;\n+    }\n+\n+    assert(_root->_parent == nullptr, \"root of rbtree has a parent\");\n+\n+    unsigned int black_nodes = 0;\n+    RBNode* node = _root;\n+    while (node != nullptr) {\n+      if (node->is_black()) {\n+        black_nodes++;\n+      }\n+      node = node->_left;\n+    }\n+\n+    const size_t actual_num_nodes = _root->count_nodes();\n+    const size_t expected_num_nodes = size();\n+    const unsigned int maximum_depth = log2i(size() + 1) * 2;\n+\n+    assert(expected_num_nodes == actual_num_nodes, \"unexpected number of nodes in rbtree. expected: \" SIZE_FORMAT \", actual: \" SIZE_FORMAT, expected_num_nodes, actual_num_nodes);\n+    assert(2 * black_nodes <= maximum_depth, \"rbtree is too deep for its number of nodes. can be at most: \" INT32_FORMAT \", but is: \" UINT32_FORMAT, maximum_depth, 2 * black_nodes);\n+    assert(_root->is_correct(black_nodes), \"rbtree does not hold rb-properties\");\n+  }\n+#endif \/\/ ASSERT\n+\n+private:\n+  template<bool Forward>\n+  class IteratorImpl : public StackObj {\n+  private:\n+    const RBTree* const _tree;\n+    GrowableArrayCHeap<RBNode*, mtInternal> _to_visit;\n+    RBNode* _next;\n+\n+    void push_left(RBNode* node) {\n+      while (node != nullptr) {\n+        _to_visit.push(node);\n+        node = node->_left;\n+      }\n+    }\n+\n+    void push_right(RBNode* node) {\n+      while (node != nullptr) {\n+        _to_visit.push(node);\n+        node = node->_right;\n+      }\n+    }\n+\n+  public:\n+    IteratorImpl(const RBTree* tree) : _tree(tree) {\n+      Forward ? push_left(tree->_root) : push_right(tree->_root);\n+    }\n+\n+    bool has_next() {\n+      return !_to_visit.is_empty();\n+    }\n+\n+    RBNode* next() {\n+      RBNode* node = _to_visit.pop();\n+      if (node != nullptr) {\n+        Forward ? push_left(node->_right) : push_right(node->_left);\n+      }\n+      return node;\n+    }\n+  };\n+\n+public:\n+  using Iterator = IteratorImpl<true>; \/\/ Forward iterator\n+  using ReverseIterator = IteratorImpl<false>; \/\/ Backward iterator\n+\n+};\n+\n+class RBTreeCHeapAllocator {\n+public:\n+  void* allocate(size_t sz) {\n+    void* allocation = os::malloc(sz, mtNMT);\n+    if (allocation == nullptr) {\n+      vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR,\n+                            \"red-black tree failed allocation\");\n+    }\n+    return allocation;\n+  }\n+\n+  void free(void* ptr) { os::free(ptr); }\n+};\n+\n+template <typename K, typename V, typename COMPARATOR>\n+using RBTreeCHeap = RBTree<K, V, COMPARATOR, RBTreeCHeapAllocator>;\n+\n+\n+#endif \/\/ SHARE_UTILITIES_RBTREE_HPP\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":694,"deletions":0,"binary":false,"changes":694,"status":"added"},{"patch":"@@ -0,0 +1,433 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/rbTree.hpp\"\n+\n+class RBTreeTest : public testing::Test {\n+public:\n+  struct Cmp {\n+    static int cmp(int a, int b) {\n+      return a - b;\n+    }\n+  };\n+\n+  struct CmpInverse {\n+    static int cmp(int a, int b) {\n+      return b - a;\n+    }\n+  };\n+\n+  struct FCmp {\n+    static int cmp(float a, float b) {\n+      if (a < b) return -1;\n+      if (a == b) return 0;\n+      return 1;\n+    }\n+  };\n+\n+#ifdef ASSERT\n+  template<typename K, typename V, typename CMP, typename ALLOC>\n+  void verify_it(RBTree<K, V, CMP, ALLOC>& t) {\n+    t.verify_self();\n+  }\n+#endif \/\/ ASSERT\n+\n+public:\n+  void inserting_duplicates_results_in_one_value() {\n+    constexpr const int up_to = 10;\n+    GrowableArrayCHeap<int, mtTest> nums_seen(up_to, up_to, 0);\n+    RBTreeCHeap<int, int, Cmp> rbtree;\n+\n+    for (int i = 0; i < up_to; i++) {\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+      rbtree.upsert(i, i);\n+    }\n+\n+    rbtree.visit_in_order([&](RBTreeCHeap<int, int, Cmp>::RBNode* node) {\n+      nums_seen.at(node->key())++;\n+    });\n+    for (int i = 0; i < up_to; i++) {\n+      EXPECT_EQ(1, nums_seen.at(i));\n+    }\n+  }\n+\n+  void rbtree_ought_not_leak() {\n+    struct LeakCheckedAllocator {\n+      int allocations;\n+\n+      LeakCheckedAllocator()\n+        : allocations(0) {\n+      }\n+\n+      void* allocate(size_t sz) {\n+        void* allocation = os::malloc(sz, mtTest);\n+        if (allocation == nullptr) {\n+          vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, \"rbtree failed allocation\");\n+        }\n+        ++allocations;\n+        return allocation;\n+      }\n+\n+      void free(void* ptr) {\n+        --allocations;\n+        os::free(ptr);\n+      }\n+    };\n+\n+    constexpr const int up_to = 10;\n+    {\n+      RBTree<int, int, Cmp, LeakCheckedAllocator> rbtree;\n+      for (int i = 0; i < up_to; i++) {\n+        rbtree.upsert(i, i);\n+      }\n+      EXPECT_EQ(up_to, rbtree._allocator.allocations);\n+      for (int i = 0; i < up_to; i++) {\n+        rbtree.remove(i);\n+      }\n+      EXPECT_EQ(0, rbtree._allocator.allocations);\n+      EXPECT_EQ(nullptr, rbtree._root);\n+    }\n+\n+    {\n+      RBTree<int, int, Cmp, LeakCheckedAllocator> rbtree;\n+      for (int i = 0; i < up_to; i++) {\n+        rbtree.upsert(i, i);\n+      }\n+      rbtree.remove_all();\n+      EXPECT_EQ(0, rbtree._allocator.allocations);\n+      EXPECT_EQ(nullptr, rbtree._root);\n+    }\n+  }\n+\n+  void test_find() {\n+    struct Empty {};\n+    RBTreeCHeap<float, Empty, FCmp> rbtree;\n+    using Node = RBTreeCHeap<float, Empty, FCmp>::RBNode;\n+\n+    Node* n = nullptr;\n+    auto test = [&](float f) {\n+      EXPECT_EQ(nullptr, rbtree.find(rbtree._root, f));\n+      rbtree.upsert(f, Empty{});\n+      Node* n = rbtree.find(rbtree._root, f);\n+      EXPECT_NE(nullptr, n);\n+      EXPECT_EQ(f, n->key());\n+    };\n+\n+    test(1.0f);\n+    test(5.0f);\n+    test(0.0f);\n+  }\n+\n+  void test_visitors() {\n+    { \/\/ Tests with 'default' ordering (ascending)\n+      RBTreeCHeap<int, int, Cmp> rbtree;\n+      using Node = RBTreeCHeap<int, int, Cmp>::RBNode;\n+\n+      rbtree.visit_range_in_order(0, 100, [&](Node* x) {\n+        EXPECT_TRUE(false) << \"Empty rbtree has no nodes to visit\";\n+      });\n+\n+      \/\/ Single-element set\n+      rbtree.upsert(1, 0);\n+      int count = 0;\n+      rbtree.visit_range_in_order(0, 100, [&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(1, count);\n+\n+      count = 0;\n+      rbtree.visit_in_order([&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(1, count);\n+\n+      \/\/ Add an element outside of the range that should not be visited on the right side and\n+      \/\/ one on the left side.\n+      rbtree.upsert(101, 0);\n+      rbtree.upsert(-1, 0);\n+      count = 0;\n+      rbtree.visit_range_in_order(0, 100, [&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(1, count);\n+\n+      count = 0;\n+      rbtree.visit_in_order([&](Node* x) {\n+        count++;\n+      });\n+      EXPECT_EQ(3, count);\n+\n+      \/\/ Visiting empty range [0, 0) == {}\n+      rbtree.upsert(0, 0); \/\/ This node should not be visited.\n+      rbtree.visit_range_in_order(0, 0, [&](Node* x) {\n+        EXPECT_TRUE(false) << \"Empty visiting range should not visit any node\";\n+      });\n+\n+      rbtree.remove_all();\n+      for (int i = 0; i < 11; i++) {\n+        rbtree.upsert(i, 0);\n+      }\n+\n+      ResourceMark rm;\n+      GrowableArray<int> seen;\n+      rbtree.visit_range_in_order(0, 10, [&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(10, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(i, seen.at(i));\n+      }\n+\n+      seen.clear();\n+      rbtree.visit_in_order([&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(11, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(i, seen.at(i));\n+      }\n+\n+      seen.clear();\n+      rbtree.visit_range_in_order(10, 12, [&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(1, seen.length());\n+      EXPECT_EQ(10, seen.at(0));\n+    }\n+    { \/\/ Test with descending ordering\n+      RBTreeCHeap<int, int, CmpInverse> rbtree;\n+      using Node = RBTreeCHeap<int, int, CmpInverse>::RBNode;\n+\n+      for (int i = 0; i < 10; i++) {\n+        rbtree.upsert(i, 0);\n+      }\n+      ResourceMark rm;\n+      GrowableArray<int> seen;\n+      rbtree.visit_range_in_order(9, -1, [&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(10, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(10-i-1, seen.at(i));\n+      }\n+      seen.clear();\n+\n+      rbtree.visit_in_order([&](Node* x) {\n+        seen.push(x->key());\n+      });\n+      EXPECT_EQ(10, seen.length());\n+      for (int i = 0; i < 10; i++) {\n+        EXPECT_EQ(10 - i - 1, seen.at(i));\n+      }\n+    }\n+  }\n+\n+  void test_closest_leq() {\n+    using Node = RBTreeCHeap<int, int, Cmp>::RBNode;\n+    {\n+      RBTreeCHeap<int, int, Cmp> rbtree;\n+      Node* n = rbtree.closest_leq(0);\n+      EXPECT_EQ(nullptr, n);\n+\n+      rbtree.upsert(0, 0);\n+      n = rbtree.closest_leq(0);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(-1, -1);\n+      n = rbtree.closest_leq(0);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(6, 0);\n+      n = rbtree.closest_leq(6);\n+      EXPECT_EQ(6, n->key());\n+\n+      n = rbtree.closest_leq(-2);\n+      EXPECT_EQ(nullptr, n);\n+    }\n+  }\n+\n+  void test_iterator() {\n+    constexpr const int num_nodes = 100;\n+    RBTreeCHeap<int, int, Cmp> tree;\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    RBTreeCHeap<int, int, Cmp>::Iterator iterator(&tree);\n+    for (int n = 0; n <= num_nodes; n++) {\n+      EXPECT_TRUE(iterator.has_next());\n+      EXPECT_EQ(iterator.next()->val(), n);\n+    }\n+\n+    RBTreeCHeap<int, int, Cmp>::ReverseIterator reverse_iterator(&tree);\n+    for (int n = num_nodes; n >= 0; n--) {\n+      EXPECT_TRUE(reverse_iterator.has_next());\n+      EXPECT_EQ(reverse_iterator.next()->val(), n);\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  void test_fill_verify() {\n+    RBTreeCHeap<int, int, Cmp> rbtree;\n+    using Node = RBTreeCHeap<int, int, Cmp>::RBNode;\n+\n+    ResourceMark rm;\n+    GrowableArray<int> allocations;\n+\n+    int size = 10000;\n+    \/\/ Create random values\n+    for (int i = 0; i < size; i++) {\n+      int r = os::random() % size;\n+      allocations.append(r % size);\n+    }\n+\n+    \/\/ Insert ~half of the values\n+    for (int i = 0; i < size; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(allocations.at(i), allocations.at(i));\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+\n+    \/\/ Insert and remove randomly\n+    for (int i = 0; i < size; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(allocations.at(i), allocations.at(i));\n+      } else {\n+        rbtree.remove(allocations.at(i));\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+\n+    \/\/ Remove all elements\n+    for (int i = 0; i < size; i++) {\n+      rbtree.remove(allocations.at(i));\n+    }\n+\n+    verify_it(rbtree);\n+    EXPECT_EQ(rbtree.size(), 0UL);\n+  }\n+#endif \/\/ ASSERT\n+\n+};\n+\n+TEST_VM_F(RBTreeTest, InsertingDuplicatesResultsInOneValue) {\n+  this->inserting_duplicates_results_in_one_value();\n+}\n+\n+TEST_VM_F(RBTreeTest, RBTreeOughtNotLeak) {\n+  this->rbtree_ought_not_leak();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestFind) {\n+  this->test_find();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestVisitors) {\n+  this->test_visitors();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestClosestLeq) {\n+  this->test_closest_leq();\n+}\n+\n+TEST_VM_F(RBTreeTest, IteratorTest) {\n+  this->test_iterator();\n+}\n+\n+#ifdef ASSERT\n+TEST_VM_F(RBTreeTest, FillAndVerify) {\n+  this->test_fill_verify();\n+}\n+\n+TEST_VM_F(RBTreeTest, InsertRemoveVerify) {\n+  constexpr const int num_nodes = 100;\n+  for (int n_t1 = 0; n_t1 < num_nodes; n_t1++) {\n+    for (int n_t2 = 0; n_t2 < n_t1; n_t2++) {\n+      RBTreeCHeap<int, int, Cmp> tree;\n+      for (int i = 0; i < n_t1; i++) {\n+        tree.upsert(i, i);\n+      }\n+      for (int i = 0; i < n_t2; i++) {\n+        tree.remove(i);\n+      }\n+      verify_it(tree);\n+    }\n+  }\n+}\n+\n+TEST_VM_F(RBTreeTest, VerifyItThroughStressTest) {\n+  { \/\/ Repeatedly verify a tree of moderate size\n+    RBTreeCHeap<int, int, Cmp> rbtree;\n+    constexpr const int ten_thousand = 10000;\n+    for (int i = 0; i < ten_thousand; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(i, i);\n+      } else {\n+        rbtree.remove(i);\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+    for (int i = 0; i < ten_thousand; i++) {\n+      int r = os::random();\n+      if (r % 2 == 0) {\n+        rbtree.upsert(i, i);\n+      } else {\n+        rbtree.remove(i);\n+      }\n+      if (i % 100 == 0) {\n+        verify_it(rbtree);\n+      }\n+    }\n+  }\n+  { \/\/ Make a very large tree and verify at the end\n+  struct Nothing {};\n+    RBTreeCHeap<int, Nothing, Cmp> rbtree;\n+    constexpr const int one_hundred_thousand = 100000;\n+    for (int i = 0; i < one_hundred_thousand; i++) {\n+      rbtree.upsert(i, Nothing());\n+    }\n+    verify_it(rbtree);\n+  }\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":433,"deletions":0,"binary":false,"changes":433,"status":"added"}]}