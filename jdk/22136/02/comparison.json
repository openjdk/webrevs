{"files":[{"patch":"@@ -351,2 +351,0 @@\n-  assert(assertion_predicate_has_loop_opaque_node(template_success_proj->in(0)->as_If()),\n-         \"must find Assertion Predicate for fast loop\");\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1315,74 +1315,0 @@\n-#ifdef ASSERT\n-bool PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(IfNode* iff) {\n-  uint init;\n-  uint stride;\n-  count_opaque_loop_nodes(iff->in(1)->in(1), init, stride);\n-  ResourceMark rm;\n-  Unique_Node_List wq;\n-  wq.clear();\n-  wq.push(iff->in(1)->in(1));\n-  uint verif_init = 0;\n-  uint verif_stride = 0;\n-  for (uint i = 0; i < wq.size(); i++) {\n-    Node* n = wq.at(i);\n-    int op = n->Opcode();\n-    if (!n->is_CFG()) {\n-      if (n->Opcode() == Op_OpaqueLoopInit) {\n-        verif_init++;\n-      } else if (n->Opcode() == Op_OpaqueLoopStride) {\n-        verif_stride++;\n-      } else {\n-        for (uint j = 1; j < n->req(); j++) {\n-          Node* m = n->in(j);\n-          if (m != nullptr) {\n-            wq.push(m);\n-          }\n-        }\n-      }\n-    }\n-  }\n-  assert(init == verif_init && stride == verif_stride, \"missed opaque node\");\n-  assert(stride == 0 || init != 0, \"init should be there every time stride is\");\n-  return init != 0;\n-}\n-\n-void PhaseIdealLoop::count_opaque_loop_nodes(Node* n, uint& init, uint& stride) {\n-  init = 0;\n-  stride = 0;\n-  ResourceMark rm;\n-  Unique_Node_List wq;\n-  wq.push(n);\n-  for (uint i = 0; i < wq.size(); i++) {\n-    Node* n = wq.at(i);\n-    if (TemplateAssertionExpressionNode::is_maybe_in_expression(n)) {\n-      if (n->is_OpaqueLoopInit()) {\n-        init++;\n-      } else if (n->is_OpaqueLoopStride()) {\n-        stride++;\n-      } else {\n-        for (uint j = 1; j < n->req(); j++) {\n-          Node* m = n->in(j);\n-          if (m != nullptr) {\n-            wq.push(m);\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-#endif \/\/ ASSERT\n-\n-\/\/ Create an Initialized Assertion Predicate from the template_assertion_predicate\n-IfTrueNode* PhaseIdealLoop::create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n-                                                                   Node* new_stride, Node* new_control) {\n-  assert(assertion_predicate_has_loop_opaque_node(template_assertion_predicate),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n-  InitializedAssertionPredicateCreator initialized_assertion_predicate(this);\n-  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(template_assertion_predicate,\n-                                                                                  new_control, new_init, new_stride);\n-\n-  assert(!assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n-  return success_proj;\n-}\n-\n@@ -2764,1 +2690,0 @@\n-            assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -2772,1 +2697,0 @@\n-          assert(assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -2778,1 +2702,0 @@\n-          assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -944,4 +944,0 @@\n- public:\n-  IfTrueNode* create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n-                                                     Node* new_stride, Node* control);\n-  DEBUG_ONLY(static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);)\n@@ -949,1 +945,0 @@\n-  DEBUG_ONLY(static void count_opaque_loop_nodes(Node* n, uint& init, uint& stride);)\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -792,1 +792,0 @@\n-    assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3032,0 +3032,28 @@\n+\n+\/\/ Run the BFS starting from 'start_node' and apply the actions provided to this class.\n+void CustomNodeInputsBFS::run(Node* start_node) {\n+  assert(_bfs_visit_input_strategy.should_visit_input(start_node), \"start node must pass the visiting strategy\");\n+  ResourceMark rm;\n+  Unique_Node_List nodes_to_visit;\n+  nodes_to_visit.push(start_node);\n+  for (uint i = 0; i < nodes_to_visit.size(); i++) {\n+    Node* next = nodes_to_visit[i];\n+    visit_inputs_of(next, nodes_to_visit);\n+  }\n+}\n+\n+void CustomNodeInputsBFS::visit_inputs_of(const Node* node, Unique_Node_List& nodes_to_visit) {\n+  for (uint i = _bfs_visit_input_strategy.start_input_index(node); i < node->req(); i++) {\n+    Node* input = node->in(i);\n+    if (!_bfs_visit_input_strategy.should_visit_input(input)) {\n+      \/\/ Different *NodeInputsBFS classes can define different strategies\n+      continue;\n+    }\n+    if (_bfs_actions.is_target_node(input)) {\n+      assert(_bfs_actions.should_visit(input), \"must also pass node filter\");\n+      _bfs_actions.target_node_action(input);\n+    } else if (_bfs_actions.should_visit(input)) {\n+      nodes_to_visit.push(input);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2114,0 +2114,88 @@\n+\/\/ Interface to define actions that should be taken when running a *NodeInputsBFS. Each use can extend this class to\n+\/\/ specify a customized BFS.\n+class BFSActions : public StackObj {\n+ public:\n+  \/\/ Should a node's inputs further be visited in the BFS traversal? By default, we visit all data inputs. Override this\n+  \/\/ method to provide a custom filter.\n+  virtual bool should_visit(Node* node) const {\n+    \/\/ By default, visit all inputs.\n+    return true;\n+  };\n+\n+  \/\/ Is the visited node a target node that we are looking for in the BFS traversal? We do not visit its inputs further\n+  \/\/ but the BFS will continue to visit all unvisited nodes in the queue.\n+  virtual bool is_target_node(Node* node) const = 0;\n+\n+  \/\/ Defines an action that should be taken when we visit a target node in the BFS traversal.\n+  virtual void target_node_action(Node* target_node) = 0;\n+};\n+\n+\/\/ Interface to define the node input visiting strategy. This interface is only used for CustomNodeInputsBFS and their\n+\/\/ users.\n+class BFSInputVisitStrategy : public StackObj {\n+ public:\n+  \/\/ Should this input be visited? This method can fundamentally restrict a BFS, for example, if only data nodes should\n+  \/\/ be visited.\n+  virtual bool should_visit_input(const Node* input) const = 0;\n+\n+  \/\/ This method returns the starting input index that should be visited when processing 'node'.\n+  \/\/ Example implementations:\n+  \/\/ - Only visiting data nodes? Return the constant index 1.\n+  \/\/ - Visiting CFG nodes? Return index 0 but if 'node' is a Region, we should start at index 1.\n+  virtual uint start_input_index(const Node* node) const = 0;\n+};\n+\n+\/\/ Generic and customizable class to perform a BFS traversal on input nodes, dictated by the given BFSInputVisitStrategy,\n+\/\/ from a given start node. The provided BFSActions guide which of a visited node's inputs should be further visited,\n+\/\/ which nodes are target nodes and what to do with the target nodes.\n+\/\/\n+\/\/ A user to traverse the node inputs of a graph is encouraged to first have a look at the common use cases covered by\n+\/\/ the specialized *NodeInputsBFS classes found below that use this class internally. For example, DataNodeInputsBFS\n+\/\/ only traverses data node inputs.\n+class CustomNodeInputsBFS : public StackObj {\n+  \/\/ Strategy defined by different *NodeInputsBFS classes.\n+  const BFSInputVisitStrategy& _bfs_visit_input_strategy;\n+\n+  \/\/ BFS actions defined by a user of a *NodeInputsBFS class.\n+  BFSActions& _bfs_actions;\n+\n+  void visit_inputs_of(const Node* node, Unique_Node_List& nodes_to_visit);\n+\n+ public:\n+  CustomNodeInputsBFS(const BFSInputVisitStrategy& bfs_input_visit_strategy, BFSActions& bfs_actions)\n+     : _bfs_visit_input_strategy(bfs_input_visit_strategy),\n+       _bfs_actions(bfs_actions) {}\n+\n+  void run(Node* start_node);\n+};\n+\n+\/\/ This class defines a data node visiting strategy for CustomNodeInputsBFS.\n+class BFSDataNodeInputVisitStrategy : public BFSInputVisitStrategy {\n+ public:\n+  \/\/ Only visit data nodes.\n+  bool should_visit_input(const Node* input) const override {\n+    return !input->is_CFG();\n+  }\n+\n+  \/\/ Data node inputs start at index 1 for data nodes.\n+  uint start_input_index(const Node* node) const override {\n+    return 1;\n+  }\n+};\n+\n+\/\/ Class to perform a BFS traversal on the data input nodes from a given start data node. The provided BFSActions guide\n+\/\/ which of a data node's inputs should be further visited, which data nodes are target nodes and what to do with the\n+\/\/ target nodes.\n+class DataNodeInputsBFS : public StackObj {\n+  const BFSDataNodeInputVisitStrategy _bfs_data_node_input_visit_strategy;\n+  CustomNodeInputsBFS _custom_node_inputs_bfs;\n+\n+ public:\n+  explicit DataNodeInputsBFS(BFSActions& bfs_actions)\n+      : _custom_node_inputs_bfs(_bfs_data_node_input_visit_strategy, bfs_actions) {}\n+\n+  void run(Node* start_node) {\n+    _custom_node_inputs_bfs.run(start_node);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -156,2 +156,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(_if_node),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  DEBUG_ONLY(verify();)\n@@ -164,2 +163,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(success_proj);)\n@@ -172,2 +170,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(_if_node),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  DEBUG_ONLY(verify();)\n@@ -181,2 +178,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(success_proj);)\n@@ -188,0 +184,1 @@\n+  DEBUG_ONLY(verify();)\n@@ -195,6 +192,4 @@\n-  assert(phase->assertion_predicate_has_loop_opaque_node(head()),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n-  InitializedAssertionPredicateCreator initialized_assertion_predicate(phase);\n-  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(head(), new_control);\n-  assert(!phase->assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n+  DEBUG_ONLY(verify();)\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate_creator(phase);\n+  IfTrueNode* success_proj = initialized_assertion_predicate_creator.create_from_template(head(), new_control);\n+  DEBUG_ONLY(InitializedAssertionPredicate::verify(success_proj);)\n@@ -204,0 +199,67 @@\n+#ifdef ASSERT\n+\/\/ Class to verify Initialized and Template Assertion Predicates by trying to find OpaqueLoop*Nodes.\n+class OpaqueLoopNodesVerifier : public BFSActions {\n+  bool _found_init;\n+  bool _found_stride;\n+\n+ public:\n+  OpaqueLoopNodesVerifier()\n+      : _found_init(false),\n+        _found_stride(false) {}\n+\n+  \/\/ A Template Assertion Predicate has:\n+  \/\/ - Always an OpaqueLoopInitNode\n+  \/\/ - Only an OpaqueLoopStrideNode for the last value.\n+  void verify(const TemplateAssertionPredicate& template_assertion_predicate) {\n+    DataNodeInputsBFS bfs(*this);\n+    bfs.run(template_assertion_predicate.opaque_node());\n+    if (template_assertion_predicate.is_last_value()) {\n+      assert(_found_init && _found_stride,\n+             \"must find OpaqueLoopInit and OpaqueLoopStride for last value Template Assertion Predicate\");\n+    } else {\n+      assert(_found_init && !_found_stride,\n+             \"must find OpaqueLoopInit but not OpaqueLoopStride for init value Template Assertion Predicate\");\n+    }\n+  }\n+\n+  \/\/ An Initialized Assertion Predicate never has any OpaqueLoop*Nodes.\n+  void verify(const InitializedAssertionPredicate& initialized_assertion_predicate) {\n+    DataNodeInputsBFS bfs(*this);\n+    bfs.run(initialized_assertion_predicate.opaque_node());\n+    assert(!_found_init && !_found_stride,\n+           \"must neither find OpaqueLoopInit nor OpaqueLoopStride for Initialized Assertion Predicate\");\n+  }\n+\n+  bool should_visit(Node* node) const override {\n+    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n+  }\n+\n+  bool is_target_node(Node* node) const override {\n+    return node->is_Opaque1();\n+  }\n+\n+  void target_node_action(Node* target_node) override {\n+    if (target_node->is_OpaqueLoopInit()) {\n+      assert(!_found_init, \"should only find one OpaqueLoopInitNode\");\n+      _found_init = true;\n+    } else {\n+      assert(target_node->is_OpaqueLoopStride(), \"unexpected Opaque1 node\");\n+      assert(!_found_stride, \"should only find one OpaqueLoopStrideNode\");\n+      _found_stride = true;\n+    }\n+  }\n+};\n+\n+\/\/ Verify that the Template Assertion Predicate has the correct OpaqueLoop*Nodes.\n+void TemplateAssertionPredicate::verify() const {\n+  OpaqueLoopNodesVerifier opaque_loop_nodes_verifier;\n+  opaque_loop_nodes_verifier.verify(*this);\n+}\n+\n+\/\/ Verify that the Initialized Assertion Predicate has no OpaqueLoop*Node.\n+void InitializedAssertionPredicate::verify() const {\n+  OpaqueLoopNodesVerifier opaque_loop_nodes_verifier;\n+  opaque_loop_nodes_verifier.verify(*this);\n+}\n+#endif \/\/ ASSERT\n+\n@@ -421,1 +483,2 @@\n-class ReplaceOpaqueStrideInput : public StackObj {\n+class ReplaceOpaqueStrideInput : public BFSActions {\n+  Node* _new_opaque_stride_input;\n@@ -423,1 +486,0 @@\n-  Unique_Node_List _nodes_to_visit;\n@@ -426,3 +488,3 @@\n-  ReplaceOpaqueStrideInput(OpaqueTemplateAssertionPredicateNode* start_node, PhaseIterGVN& igvn) : _igvn(igvn) {\n-    _nodes_to_visit.push(start_node);\n-  }\n+  ReplaceOpaqueStrideInput(Node* new_opaque_stride_input, PhaseIterGVN& igvn)\n+      : _new_opaque_stride_input(new_opaque_stride_input),\n+        _igvn(igvn) {}\n@@ -431,13 +493,15 @@\n-  void replace(Node* new_opaque_stride_input) {\n-    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n-      Node* next = _nodes_to_visit[i];\n-      for (uint j = 1; j < next->req(); j++) {\n-        Node* input = next->in(j);\n-        if (input->is_OpaqueLoopStride()) {\n-          assert(TemplateAssertionExpressionNode::is_maybe_in_expression(input), \"must also pass node filter\");\n-          _igvn.replace_input_of(input, 1, new_opaque_stride_input);\n-        } else if (TemplateAssertionExpressionNode::is_maybe_in_expression(input)) {\n-          _nodes_to_visit.push(input);\n-        }\n-      }\n-    }\n+  void replace_for(OpaqueTemplateAssertionPredicateNode* opaque_node) {\n+    DataNodeInputsBFS bfs(*this);\n+    bfs.run(opaque_node);\n+  }\n+\n+  bool should_visit(Node* node) const override {\n+    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n+  }\n+\n+  bool is_target_node(Node* node) const override {\n+    return node->is_OpaqueLoopStride();\n+  }\n+\n+  void target_node_action(Node* target_node) override {\n+    _igvn.replace_input_of(target_node, 1, _new_opaque_stride_input);\n@@ -449,2 +513,2 @@\n-  ReplaceOpaqueStrideInput replace_opaque_stride_input(_opaque_node, igvn);\n-  replace_opaque_stride_input.replace(new_stride);\n+  ReplaceOpaqueStrideInput replace_opaque_stride_input(new_stride, igvn);\n+  replace_opaque_stride_input.replace_for(_opaque_node);\n@@ -679,0 +743,2 @@\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(template_predicate_success_proj);)\n+\n@@ -681,2 +747,5 @@\n-  return create_if_node(template_predicate_success_proj, template_assertion_predicate_expression,\n-                        does_overflow, AssertionPredicateType::LastValue);\n+  template_predicate_success_proj = create_if_node(template_predicate_success_proj,\n+                                                   template_assertion_predicate_expression, does_overflow,\n+                                                   AssertionPredicateType::LastValue);\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(template_predicate_success_proj);)\n+  return template_predicate_success_proj;\n@@ -738,2 +807,4 @@\n-  return create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck, assertion_expression,\n-                              assertion_predicate_type);\n+  IfTrueNode* success_proj = create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck,\n+                                                  assertion_expression, assertion_predicate_type);\n+  DEBUG_ONLY(InitializedAssertionPredicate::verify(success_proj);)\n+  return success_proj;\n@@ -835,0 +906,1 @@\n+  DEBUG_ONLY(template_assertion_predicate.verify();)\n@@ -836,2 +908,5 @@\n-  IfTrueNode* initialized_predicate = _phase->create_initialized_assertion_predicate(template_head, _init, _stride,\n-                                                                                     _new_control);\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate_creator(_phase);\n+  IfTrueNode* initialized_predicate = initialized_assertion_predicate_creator.create_from_template(template_head,\n+                                                                                                   _new_control,\n+                                                                                                   _init, _stride);\n+  DEBUG_ONLY(InitializedAssertionPredicate::verify(initialized_predicate);)\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":115,"deletions":40,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -403,0 +403,9 @@\n+\n+#ifdef ASSERT\n+  static void verify(IfTrueNode* template_assertion_predicate_success_proj) {\n+    TemplateAssertionPredicate template_assertion_predicate(template_assertion_predicate_success_proj);\n+    template_assertion_predicate.verify();\n+  }\n+\n+  void verify() const;\n+#endif \/\/ ASSERT\n@@ -422,0 +431,4 @@\n+  OpaqueInitializedAssertionPredicateNode* opaque_node() const {\n+    return _if_node->in(1)->as_OpaqueInitializedAssertionPredicate();\n+  }\n+\n@@ -436,0 +449,9 @@\n+\n+#ifdef ASSERT\n+  static void verify(IfTrueNode* initialized_assertion_predicate_success_proj) {\n+    InitializedAssertionPredicate initialized_assertion_predicate(initialized_assertion_predicate_success_proj);\n+    initialized_assertion_predicate.verify();\n+  }\n+\n+  void verify() const;\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}