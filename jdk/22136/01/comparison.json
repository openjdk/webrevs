{"files":[{"patch":"@@ -351,2 +351,0 @@\n-  assert(assertion_predicate_has_loop_opaque_node(template_success_proj->in(0)->as_If()),\n-         \"must find Assertion Predicate for fast loop\");\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1315,74 +1315,0 @@\n-#ifdef ASSERT\n-bool PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(IfNode* iff) {\n-  uint init;\n-  uint stride;\n-  count_opaque_loop_nodes(iff->in(1)->in(1), init, stride);\n-  ResourceMark rm;\n-  Unique_Node_List wq;\n-  wq.clear();\n-  wq.push(iff->in(1)->in(1));\n-  uint verif_init = 0;\n-  uint verif_stride = 0;\n-  for (uint i = 0; i < wq.size(); i++) {\n-    Node* n = wq.at(i);\n-    int op = n->Opcode();\n-    if (!n->is_CFG()) {\n-      if (n->Opcode() == Op_OpaqueLoopInit) {\n-        verif_init++;\n-      } else if (n->Opcode() == Op_OpaqueLoopStride) {\n-        verif_stride++;\n-      } else {\n-        for (uint j = 1; j < n->req(); j++) {\n-          Node* m = n->in(j);\n-          if (m != nullptr) {\n-            wq.push(m);\n-          }\n-        }\n-      }\n-    }\n-  }\n-  assert(init == verif_init && stride == verif_stride, \"missed opaque node\");\n-  assert(stride == 0 || init != 0, \"init should be there every time stride is\");\n-  return init != 0;\n-}\n-\n-void PhaseIdealLoop::count_opaque_loop_nodes(Node* n, uint& init, uint& stride) {\n-  init = 0;\n-  stride = 0;\n-  ResourceMark rm;\n-  Unique_Node_List wq;\n-  wq.push(n);\n-  for (uint i = 0; i < wq.size(); i++) {\n-    Node* n = wq.at(i);\n-    if (TemplateAssertionExpressionNode::is_maybe_in_expression(n)) {\n-      if (n->is_OpaqueLoopInit()) {\n-        init++;\n-      } else if (n->is_OpaqueLoopStride()) {\n-        stride++;\n-      } else {\n-        for (uint j = 1; j < n->req(); j++) {\n-          Node* m = n->in(j);\n-          if (m != nullptr) {\n-            wq.push(m);\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-#endif \/\/ ASSERT\n-\n-\/\/ Create an Initialized Assertion Predicate from the template_assertion_predicate\n-IfTrueNode* PhaseIdealLoop::create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n-                                                                   Node* new_stride, Node* new_control) {\n-  assert(assertion_predicate_has_loop_opaque_node(template_assertion_predicate),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n-  InitializedAssertionPredicateCreator initialized_assertion_predicate(this);\n-  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(template_assertion_predicate,\n-                                                                                  new_control, new_init, new_stride);\n-\n-  assert(!assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n-  return success_proj;\n-}\n-\n@@ -2764,1 +2690,0 @@\n-            assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -2772,1 +2697,0 @@\n-          assert(assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -2778,1 +2702,0 @@\n-          assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -944,4 +944,0 @@\n- public:\n-  IfTrueNode* create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n-                                                     Node* new_stride, Node* control);\n-  DEBUG_ONLY(static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);)\n@@ -949,1 +945,0 @@\n-  DEBUG_ONLY(static void count_opaque_loop_nodes(Node* n, uint& init, uint& stride);)\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -792,1 +792,0 @@\n-    assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2114,0 +2114,47 @@\n+\/\/ Interface to define actions that should be taken when running DataNodeBFS. Each use can extend this class to specify\n+\/\/ a customized BFS.\n+class BFSActions : public StackObj {\n+ public:\n+  \/\/ Should a node's inputs further be visited in the BFS traversal? By default, we visit all data inputs. Override this\n+  \/\/ method to provide a custom filter.\n+  virtual bool should_visit(Node* node) const {\n+    \/\/ By default, visit all inputs.\n+    return true;\n+  };\n+\n+  \/\/ Is the visited node a target node that we are looking for in the BFS traversal? We do not visit its inputs further\n+  \/\/ but the BFS will continue to visit all unvisited nodes in the queue.\n+  virtual bool is_target_node(Node* node) const = 0;\n+\n+  \/\/ Defines an action that should be taken when we visit a target node in the BFS traversal.\n+  virtual void target_node_action(Node* target_node) = 0;\n+};\n+\n+\/\/ Class to perform a BFS traversal on the data nodes from a given start node. The provided BFSActions guide which\n+\/\/ data node's inputs should be further visited, which data nodes are target nodes and what to do with the target nodes.\n+class DataNodeBFS : public StackObj {\n+  BFSActions& _bfs_actions;\n+\n+ public:\n+  explicit DataNodeBFS(BFSActions& bfs_action) : _bfs_actions(bfs_action) {}\n+\n+  \/\/ Run the BFS starting from 'start_node' and apply the actions provided to this class.\n+  void run(Node* start_node) {\n+    ResourceMark rm;\n+    Unique_Node_List _nodes_to_visit;\n+    _nodes_to_visit.push(start_node);\n+    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n+      Node* next = _nodes_to_visit[i];\n+      for (uint j = 1; j < next->req(); j++) {\n+        Node* input = next->in(j);\n+        if (_bfs_actions.is_target_node(input)) {\n+          assert(_bfs_actions.should_visit(input), \"must also pass node filter\");\n+          _bfs_actions.target_node_action(input);\n+        } else if (_bfs_actions.should_visit(input)) {\n+          _nodes_to_visit.push(input);\n+        }\n+      }\n+    }\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -156,2 +156,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(_if_node),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  DEBUG_ONLY(verify();)\n@@ -164,2 +163,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(success_proj);)\n@@ -172,2 +170,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(_if_node),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  DEBUG_ONLY(verify();)\n@@ -181,2 +178,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(success_proj);)\n@@ -188,0 +184,1 @@\n+  DEBUG_ONLY(verify();)\n@@ -195,6 +192,4 @@\n-  assert(phase->assertion_predicate_has_loop_opaque_node(head()),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n-  InitializedAssertionPredicateCreator initialized_assertion_predicate(phase);\n-  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(head(), new_control);\n-  assert(!phase->assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n+  DEBUG_ONLY(verify();)\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate_creator(phase);\n+  IfTrueNode* success_proj = initialized_assertion_predicate_creator.create_from_template(head(), new_control);\n+  DEBUG_ONLY(InitializedAssertionPredicate::verify(success_proj);)\n@@ -204,0 +199,67 @@\n+#ifdef ASSERT\n+\/\/ Class to verify Initialized and Template Assertion Predicates by trying to find OpaqueLoop*Nodes.\n+class OpaqueLoopNodesVerifier : public BFSActions {\n+  bool _found_init;\n+  bool _found_stride;\n+\n+ public:\n+  OpaqueLoopNodesVerifier()\n+      : _found_init(false),\n+        _found_stride(false) {}\n+\n+  \/\/ A Template Assertion Predicate has:\n+  \/\/ - Always an OpaqueLoopInitNode\n+  \/\/ - Only an OpaqueLoopStrideNode for the last value.\n+  void verify(const TemplateAssertionPredicate& template_assertion_predicate) {\n+    DataNodeBFS bfs(*this);\n+    bfs.run(template_assertion_predicate.opaque_node());\n+    if (template_assertion_predicate.is_last_value()) {\n+      assert(_found_init && _found_stride,\n+             \"must find OpaqueLoopInit and OpaqueLoopStride for last value Template Assertion Predicate\");\n+    } else {\n+      assert(_found_init && !_found_stride,\n+             \"must find OpaqueLoopInit but not OpaqueLoopStride for init value Template Assertion Predicate\");\n+    }\n+  }\n+\n+  \/\/ An Initialized Assertion Predicate never has any OpaqueLoop*Nodes.\n+  void verify(const InitializedAssertionPredicate& initialized_assertion_predicate) {\n+    DataNodeBFS bfs(*this);\n+    bfs.run(initialized_assertion_predicate.opaque_node());\n+    assert(!_found_init && !_found_stride,\n+           \"must neither find OpaqueLoopInit nor OpaqueLoopStride for Initialized Assertion Predicate\");\n+  }\n+\n+  bool should_visit(Node* node) const override {\n+    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n+  }\n+\n+  bool is_target_node(Node* node) const override {\n+    return node->is_Opaque1();\n+  }\n+\n+  void target_node_action(Node* target_node) override {\n+    if (target_node->is_OpaqueLoopInit()) {\n+      assert(!_found_init, \"should only find one OpaqueLoopInitNode\");\n+      _found_init = true;\n+    } else {\n+      assert(target_node->is_OpaqueLoopStride(), \"unexpected Opaque1 node\");\n+      assert(!_found_stride, \"should only find one OpaqueLoopStrideNode\");\n+      _found_stride = true;\n+    }\n+  }\n+};\n+\n+\/\/ Verify that the Template Assertion Predicate has the correct OpaqueLoop*Nodes.\n+void TemplateAssertionPredicate::verify() const {\n+  OpaqueLoopNodesVerifier opaque_loop_nodes_verifier;\n+  opaque_loop_nodes_verifier.verify(*this);\n+}\n+\n+\/\/ Verify that the Initialized Assertion Predicate has no OpaqueLoop*Node.\n+void InitializedAssertionPredicate::verify() const {\n+  OpaqueLoopNodesVerifier opaque_loop_nodes_verifier;\n+  opaque_loop_nodes_verifier.verify(*this);\n+}\n+#endif \/\/ ASSERT\n+\n@@ -421,1 +483,2 @@\n-class ReplaceOpaqueStrideInput : public StackObj {\n+class ReplaceOpaqueStrideInput : public BFSActions {\n+  Node* _new_opaque_stride_input;\n@@ -423,1 +486,0 @@\n-  Unique_Node_List _nodes_to_visit;\n@@ -426,3 +488,3 @@\n-  ReplaceOpaqueStrideInput(OpaqueTemplateAssertionPredicateNode* start_node, PhaseIterGVN& igvn) : _igvn(igvn) {\n-    _nodes_to_visit.push(start_node);\n-  }\n+  ReplaceOpaqueStrideInput(Node* new_opaque_stride_input, PhaseIterGVN& igvn)\n+      : _new_opaque_stride_input(new_opaque_stride_input),\n+        _igvn(igvn) {}\n@@ -431,13 +493,15 @@\n-  void replace(Node* new_opaque_stride_input) {\n-    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n-      Node* next = _nodes_to_visit[i];\n-      for (uint j = 1; j < next->req(); j++) {\n-        Node* input = next->in(j);\n-        if (input->is_OpaqueLoopStride()) {\n-          assert(TemplateAssertionExpressionNode::is_maybe_in_expression(input), \"must also pass node filter\");\n-          _igvn.replace_input_of(input, 1, new_opaque_stride_input);\n-        } else if (TemplateAssertionExpressionNode::is_maybe_in_expression(input)) {\n-          _nodes_to_visit.push(input);\n-        }\n-      }\n-    }\n+  void replace_for(OpaqueTemplateAssertionPredicateNode* opaque_node) {\n+    DataNodeBFS bfs(*this);\n+    bfs.run(opaque_node);\n+  }\n+\n+  bool should_visit(Node* node) const override {\n+    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n+  }\n+\n+  bool is_target_node(Node* node) const override {\n+    return node->is_OpaqueLoopStride();\n+  }\n+\n+  void target_node_action(Node* target_node) override {\n+    _igvn.replace_input_of(target_node, 1, _new_opaque_stride_input);\n@@ -449,2 +513,2 @@\n-  ReplaceOpaqueStrideInput replace_opaque_stride_input(_opaque_node, igvn);\n-  replace_opaque_stride_input.replace(new_stride);\n+  ReplaceOpaqueStrideInput replace_opaque_stride_input(new_stride, igvn);\n+  replace_opaque_stride_input.replace_for(_opaque_node);\n@@ -679,0 +743,2 @@\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(template_predicate_success_proj);)\n+\n@@ -681,2 +747,5 @@\n-  return create_if_node(template_predicate_success_proj, template_assertion_predicate_expression,\n-                        does_overflow, AssertionPredicateType::LastValue);\n+  template_predicate_success_proj = create_if_node(template_predicate_success_proj,\n+                                                   template_assertion_predicate_expression, does_overflow,\n+                                                   AssertionPredicateType::LastValue);\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(template_predicate_success_proj);)\n+  return template_predicate_success_proj;\n@@ -738,2 +807,4 @@\n-  return create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck, assertion_expression,\n-                              assertion_predicate_type);\n+  IfTrueNode* success_proj = create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck,\n+                                                  assertion_expression, assertion_predicate_type);\n+  DEBUG_ONLY(InitializedAssertionPredicate::verify(success_proj);)\n+  return success_proj;\n@@ -835,0 +906,1 @@\n+  DEBUG_ONLY(template_assertion_predicate.verify();)\n@@ -836,2 +908,4 @@\n-  IfTrueNode* initialized_predicate = _phase->create_initialized_assertion_predicate(template_head, _init, _stride,\n-                                                                                     _new_control);\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate(_phase);\n+  IfTrueNode* initialized_predicate = initialized_assertion_predicate.create_from_template(template_head,_new_control,\n+                                                                                           _init, _stride);\n+  DEBUG_ONLY(InitializedAssertionPredicate::verify(initialized_predicate);)\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":114,"deletions":40,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -403,0 +403,9 @@\n+\n+#ifdef ASSERT\n+  static void verify(IfTrueNode* template_assertion_predicate_success_proj) {\n+    TemplateAssertionPredicate template_assertion_predicate(template_assertion_predicate_success_proj);\n+    template_assertion_predicate.verify();\n+  }\n+\n+  void verify() const;\n+#endif \/\/ ASSERT\n@@ -422,0 +431,4 @@\n+  OpaqueInitializedAssertionPredicateNode* opaque_node() const {\n+    return _if_node->in(1)->as_OpaqueInitializedAssertionPredicate();\n+  }\n+\n@@ -436,0 +449,9 @@\n+\n+#ifdef ASSERT\n+  static void verify(IfTrueNode* initialized_assertion_predicate_success_proj) {\n+    InitializedAssertionPredicate initialized_assertion_predicate(initialized_assertion_predicate_success_proj);\n+    initialized_assertion_predicate.verify();\n+  }\n+\n+  void verify() const;\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}