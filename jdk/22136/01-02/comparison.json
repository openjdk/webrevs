{"files":[{"patch":"@@ -3032,0 +3032,28 @@\n+\n+\/\/ Run the BFS starting from 'start_node' and apply the actions provided to this class.\n+void CustomNodeInputsBFS::run(Node* start_node) {\n+  assert(_bfs_visit_input_strategy.should_visit_input(start_node), \"start node must pass the visiting strategy\");\n+  ResourceMark rm;\n+  Unique_Node_List nodes_to_visit;\n+  nodes_to_visit.push(start_node);\n+  for (uint i = 0; i < nodes_to_visit.size(); i++) {\n+    Node* next = nodes_to_visit[i];\n+    visit_inputs_of(next, nodes_to_visit);\n+  }\n+}\n+\n+void CustomNodeInputsBFS::visit_inputs_of(const Node* node, Unique_Node_List& nodes_to_visit) {\n+  for (uint i = _bfs_visit_input_strategy.start_input_index(node); i < node->req(); i++) {\n+    Node* input = node->in(i);\n+    if (!_bfs_visit_input_strategy.should_visit_input(input)) {\n+      \/\/ Different *NodeInputsBFS classes can define different strategies\n+      continue;\n+    }\n+    if (_bfs_actions.is_target_node(input)) {\n+      assert(_bfs_actions.should_visit(input), \"must also pass node filter\");\n+      _bfs_actions.target_node_action(input);\n+    } else if (_bfs_actions.should_visit(input)) {\n+      nodes_to_visit.push(input);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2114,2 +2114,2 @@\n-\/\/ Interface to define actions that should be taken when running DataNodeBFS. Each use can extend this class to specify\n-\/\/ a customized BFS.\n+\/\/ Interface to define actions that should be taken when running a *NodeInputsBFS. Each use can extend this class to\n+\/\/ specify a customized BFS.\n@@ -2133,3 +2133,27 @@\n-\/\/ Class to perform a BFS traversal on the data nodes from a given start node. The provided BFSActions guide which\n-\/\/ data node's inputs should be further visited, which data nodes are target nodes and what to do with the target nodes.\n-class DataNodeBFS : public StackObj {\n+\/\/ Interface to define the node input visiting strategy. This interface is only used for CustomNodeInputsBFS and their\n+\/\/ users.\n+class BFSInputVisitStrategy : public StackObj {\n+ public:\n+  \/\/ Should this input be visited? This method can fundamentally restrict a BFS, for example, if only data nodes should\n+  \/\/ be visited.\n+  virtual bool should_visit_input(const Node* input) const = 0;\n+\n+  \/\/ This method returns the starting input index that should be visited when processing 'node'.\n+  \/\/ Example implementations:\n+  \/\/ - Only visiting data nodes? Return the constant index 1.\n+  \/\/ - Visiting CFG nodes? Return index 0 but if 'node' is a Region, we should start at index 1.\n+  virtual uint start_input_index(const Node* node) const = 0;\n+};\n+\n+\/\/ Generic and customizable class to perform a BFS traversal on input nodes, dictated by the given BFSInputVisitStrategy,\n+\/\/ from a given start node. The provided BFSActions guide which of a visited node's inputs should be further visited,\n+\/\/ which nodes are target nodes and what to do with the target nodes.\n+\/\/\n+\/\/ A user to traverse the node inputs of a graph is encouraged to first have a look at the common use cases covered by\n+\/\/ the specialized *NodeInputsBFS classes found below that use this class internally. For example, DataNodeInputsBFS\n+\/\/ only traverses data node inputs.\n+class CustomNodeInputsBFS : public StackObj {\n+  \/\/ Strategy defined by different *NodeInputsBFS classes.\n+  const BFSInputVisitStrategy& _bfs_visit_input_strategy;\n+\n+  \/\/ BFS actions defined by a user of a *NodeInputsBFS class.\n@@ -2138,0 +2162,12 @@\n+  void visit_inputs_of(const Node* node, Unique_Node_List& nodes_to_visit);\n+\n+ public:\n+  CustomNodeInputsBFS(const BFSInputVisitStrategy& bfs_input_visit_strategy, BFSActions& bfs_actions)\n+     : _bfs_visit_input_strategy(bfs_input_visit_strategy),\n+       _bfs_actions(bfs_actions) {}\n+\n+  void run(Node* start_node);\n+};\n+\n+\/\/ This class defines a data node visiting strategy for CustomNodeInputsBFS.\n+class BFSDataNodeInputVisitStrategy : public BFSInputVisitStrategy {\n@@ -2139,1 +2175,21 @@\n-  explicit DataNodeBFS(BFSActions& bfs_action) : _bfs_actions(bfs_action) {}\n+  \/\/ Only visit data nodes.\n+  bool should_visit_input(const Node* input) const override {\n+    return !input->is_CFG();\n+  }\n+\n+  \/\/ Data node inputs start at index 1 for data nodes.\n+  uint start_input_index(const Node* node) const override {\n+    return 1;\n+  }\n+};\n+\n+\/\/ Class to perform a BFS traversal on the data input nodes from a given start data node. The provided BFSActions guide\n+\/\/ which of a data node's inputs should be further visited, which data nodes are target nodes and what to do with the\n+\/\/ target nodes.\n+class DataNodeInputsBFS : public StackObj {\n+  const BFSDataNodeInputVisitStrategy _bfs_data_node_input_visit_strategy;\n+  CustomNodeInputsBFS _custom_node_inputs_bfs;\n+\n+ public:\n+  explicit DataNodeInputsBFS(BFSActions& bfs_actions)\n+      : _custom_node_inputs_bfs(_bfs_data_node_input_visit_strategy, bfs_actions) {}\n@@ -2141,1 +2197,0 @@\n-  \/\/ Run the BFS starting from 'start_node' and apply the actions provided to this class.\n@@ -2143,15 +2198,1 @@\n-    ResourceMark rm;\n-    Unique_Node_List _nodes_to_visit;\n-    _nodes_to_visit.push(start_node);\n-    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n-      Node* next = _nodes_to_visit[i];\n-      for (uint j = 1; j < next->req(); j++) {\n-        Node* input = next->in(j);\n-        if (_bfs_actions.is_target_node(input)) {\n-          assert(_bfs_actions.should_visit(input), \"must also pass node filter\");\n-          _bfs_actions.target_node_action(input);\n-        } else if (_bfs_actions.should_visit(input)) {\n-          _nodes_to_visit.push(input);\n-        }\n-      }\n-    }\n+    _custom_node_inputs_bfs.run(start_node);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":63,"deletions":22,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-    DataNodeBFS bfs(*this);\n+    DataNodeInputsBFS bfs(*this);\n@@ -227,1 +227,1 @@\n-    DataNodeBFS bfs(*this);\n+    DataNodeInputsBFS bfs(*this);\n@@ -494,1 +494,1 @@\n-    DataNodeBFS bfs(*this);\n+    DataNodeInputsBFS bfs(*this);\n@@ -908,3 +908,4 @@\n-  InitializedAssertionPredicateCreator initialized_assertion_predicate(_phase);\n-  IfTrueNode* initialized_predicate = initialized_assertion_predicate.create_from_template(template_head,_new_control,\n-                                                                                           _init, _stride);\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate_creator(_phase);\n+  IfTrueNode* initialized_predicate = initialized_assertion_predicate_creator.create_from_template(template_head,\n+                                                                                                   _new_control,\n+                                                                                                   _init, _stride);\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"}]}