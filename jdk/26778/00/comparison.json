{"files":[{"patch":"@@ -340,1 +340,1 @@\n-        var srcPath = pkg.asPackageApplicationLayout().orElseThrow().resolveAt(env.appImageDir()).desktopIntegrationDirectory().resolve(fileName);\n+        var srcPath = env.asApplicationLayout().orElseThrow().desktopIntegrationDirectory().resolve(fileName);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -43,2 +44,20 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, libAppLauncher()));\n+        return (LinuxApplicationLayout)ApplicationLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout unresolve() {\n+        return (LinuxApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), libAppLauncher());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, libAppLauncher()));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayout.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayoutMixin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -354,2 +354,1 @@\n-                AppImageLayout.toPathGroup(pkg.packageLayout().resolveAt(\n-                        env.appImageDir())).sizeInBytes() >> 10));\n+                AppImageLayout.toPathGroup(env.appImageLayout()).sizeInBytes() >> 10));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.jpackage.internal.model.LinuxApplication;\n@@ -37,0 +38,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -55,1 +57,1 @@\n-        final var pkg = pkgBuilder.create();\n+        final var tmpPkg = pkgBuilder.create();\n@@ -57,1 +59,1 @@\n-        final var stdPkgType = pkg.asStandardPackageType();\n+        final var stdPkgType = tmpPkg.asStandardPackageType();\n@@ -59,1 +61,1 @@\n-            validatePackageName(pkg.packageName(), stdPkgType.orElseThrow());\n+            validatePackageName(tmpPkg.packageName(), stdPkgType.orElseThrow());\n@@ -62,3 +64,10 @@\n-        var reply = create(pkg, pkg.packageLayout());\n-        if (reply.isInstallDirInUsrTree()) {\n-            reply = create(pkg, usrTreePackageLayout(pkg.relativeInstallDir(), pkg.packageName()));\n+        final AppImageLayout relativeInstalledLayout;\n+        if (create(tmpPkg).isInstallDirInUsrTree()) {\n+            final var usrTreeLayout = usrTreePackageLayout(tmpPkg.relativeInstallDir(), tmpPkg.packageName());\n+            if (tmpPkg.isRuntimeInstaller()) {\n+                relativeInstalledLayout = RuntimeLayout.create(usrTreeLayout.runtimeDirectory());\n+            } else {\n+                relativeInstalledLayout = usrTreeLayout;\n+            }\n+        } else {\n+            relativeInstalledLayout = tmpPkg.appImageLayout().resolveAt(tmpPkg.relativeInstallDir()).resetRootDirectory();\n@@ -67,1 +76,6 @@\n-        return reply;\n+        final var app = ApplicationBuilder.overrideAppImageLayout(pkgBuilder.app(), relativeInstalledLayout);\n+\n+        return create(pkgBuilder\n+                .app(LinuxApplication.create(app))\n+                .installedPackageLayout(relativeInstalledLayout.resolveAt(Path.of(\"\/\")).resetRootDirectory())\n+                .create());\n@@ -70,1 +84,1 @@\n-    private LinuxPackage create(Package pkg, AppImageLayout pkgLayout) throws ConfigException {\n+    private LinuxPackage create(Package pkg) throws ConfigException {\n@@ -72,1 +86,0 @@\n-                pkgLayout,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBuilder.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-    @Override\n-    AppImageLayout packageLayout();\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackage.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,5 +34,0 @@\n-    \/**\n-     * Overrides {@link Package#packageLayout()}.\n-     *\/\n-    AppImageLayout packageLayout();\n-\n@@ -91,1 +86,1 @@\n-    record Stub(AppImageLayout packageLayout, String menuGroupName,\n+    record Stub(String menuGroupName,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackageMixin.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -47,0 +49,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -53,1 +56,1 @@\n-    static Consumer<Path> createSigner(MacApplication app, CodesignConfig signingCfg) {\n+    static Consumer<MacBundle> createSigner(MacApplication app, CodesignConfig signingCfg) {\n@@ -70,1 +73,1 @@\n-        SignFilter(Application app, Path appImage) {\n+        SignFilter(Application app, MacBundle appImage) {\n@@ -75,1 +78,1 @@\n-                return appLayout.resolveAt(appImage);\n+                return appLayout.resolveAt(appImage.root());\n@@ -101,1 +104,6 @@\n-    private void sign(MacApplication app, Path appImage) throws CodesignException, IOException {\n+    private void sign(MacApplication app, MacBundle appImage) throws CodesignException, IOException {\n+        if (!appImage.isValid()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        app = normalizeAppImageLayout(app);\n@@ -105,1 +113,1 @@\n-        try (var content = Files.walk(appImage)) {\n+        try (var content = Files.walk(appImage.root())) {\n@@ -121,1 +129,1 @@\n-            return appLayout.resolveAt(appImage);\n+            return appLayout.resolveAt(appImage.root());\n@@ -124,1 +132,1 @@\n-        final var frameworkPath = appImage.resolve(\"Contents\/Frameworks\");\n+        final var frameworkPath = appImage.contentsDir().resolve(\"Frameworks\");\n@@ -134,1 +142,1 @@\n-        codesigners.accept(appImage);\n+        codesigners.accept(appImage.root());\n@@ -238,0 +246,14 @@\n+    private static MacApplication normalizeAppImageLayout(MacApplication app) {\n+        switch (app.imageLayout()) {\n+            case MacApplicationLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, APPLICATION_LAYOUT);\n+            }\n+            case RuntimeLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, RUNTIME_BUNDLE_LAYOUT);\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                 env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+                 env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n@@ -49,1 +49,1 @@\n-                 env = BuildEnv.withAppImageDir(BuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n+                 env = BuildEnv.withAppImageDir(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -98,2 +99,7 @@\n-        final var mixin = new MacApplicationMixin.Stub(validatedIcon(), validatedBundleName(),\n-                validatedBundleIdentifier(), validatedCategory(), appStore, createSigningConfig());\n+        final var mixin = new MacApplicationMixin.Stub(\n+                validatedIcon(),\n+                validatedBundleName(),\n+                validatedBundleIdentifier(),\n+                validatedCategory(),\n+                appStore,\n+                createSigningConfig());\n@@ -104,0 +110,11 @@\n+    static MacApplication overrideAppImageLayout(MacApplication app, AppImageLayout appImageLayout) {\n+        final var mixin = new MacApplicationMixin.Stub(\n+                app.icon(),\n+                app.bundleName(),\n+                app.bundleIdentifier(),\n+                app.category(),\n+                app.appStore(),\n+                app.signingConfig());\n+        return MacApplication.create(ApplicationBuilder.overrideAppImageLayout(app, appImageLayout), mixin);\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationBuilder.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -38,1 +39,2 @@\n-                .create(MacApplicationLayout.class, layout, new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n+                .create(MacApplicationLayout.class, layout,\n+                        new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n@@ -43,2 +45,1 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, runtimeRootDirectory()));\n+        return (MacApplicationLayout)ApplicationLayout.super.resolveAt(root);\n@@ -46,0 +47,20 @@\n+\n+    @Override\n+    default MacApplicationLayout unresolve() {\n+        return (MacApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default MacApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), runtimeRootDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default MacApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, runtimeRootDirectory()));\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayout.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n@@ -33,1 +33,2 @@\n-     * Path to the root Java runtime directory in the application image.\n+     * Returns path to the root Java runtime directory in the application image.\n+     * <p>\n@@ -35,0 +36,2 @@\n+     *\n+     * @return the path to the root Java runtime directory in the application image\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayoutMixin.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import jdk.jpackage.internal.model.MacPackage;\n+\n+final class MacBuildEnvFromParams {\n+\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return BuildEnvFromParams.create(params, MacPackage::guessRuntimeLayout);\n+    });\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBuildEnvFromParams.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -76,2 +77,14 @@\n-    static MacBundle fromAppImageLayout(AppImageLayout layout) {\n-        return new MacBundle(layout.rootDirectory());\n+    static Optional<MacBundle> fromAppImageLayout(AppImageLayout layout) {\n+        final var root = layout.rootDirectory();\n+        final var bundleSubdir = root.relativize(layout.runtimeDirectory());\n+        final var contentsDirname = Path.of(\"Contents\");\n+        var bundleRoot = root;\n+        for (int i = 0; i != bundleSubdir.getNameCount(); i++) {\n+            var nameComponent = bundleSubdir.getName(i);\n+            if (contentsDirname.equals(nameComponent)) {\n+                return Optional.of(new MacBundle(bundleRoot));\n+            } else {\n+                bundleRoot = bundleRoot.resolve(nameComponent);\n+            }\n+        }\n+        return Optional.empty();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundle.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-        final var superPkgBuilder = pkgBuilder.pkgBuilder();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackageBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static jdk.jpackage.internal.model.MacPackage.RUNTIME_PACKAGE_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -48,1 +48,0 @@\n-import java.nio.file.Files;\n@@ -67,0 +66,1 @@\n+import jdk.jpackage.internal.model.MacPackage;\n@@ -78,7 +78,3 @@\n-        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params).map(predefinedRuntimeImage -> {\n-            if (Files.isDirectory(RUNTIME_PACKAGE_LAYOUT.resolveAt(predefinedRuntimeImage).runtimeDirectory())) {\n-                return RUNTIME_PACKAGE_LAYOUT;\n-            } else {\n-                return RuntimeLayout.DEFAULT;\n-            }\n-        });\n+        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params)\n+                .map(MacPackage::guessRuntimeLayout)\n+                .map(RuntimeLayout::unresolve);\n@@ -91,1 +87,1 @@\n-        }), APPLICATION_LAYOUT, predefinedRuntimeLayout);\n+        }), APPLICATION_LAYOUT, RUNTIME_BUNDLE_LAYOUT, predefinedRuntimeLayout);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.LayoutUtils.packagerLayout;\n+\n@@ -29,0 +31,1 @@\n+import jdk.jpackage.internal.model.MacApplication;\n@@ -48,1 +51,9 @@\n-        final var pkg = pkgBuilder.create();\n+\n+        final var app = (MacApplication)pkgBuilder.app();\n+\n+        var pkg = pkgBuilder.create();\n+\n+        pkgBuilder.app(MacApplicationBuilder.overrideAppImageLayout(app, packagerLayout(pkg)))\n+                .installedPackageLayout(pkg.installedPackageLayout());\n+\n+        pkg = pkgBuilder.create();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.UncheckedIOException;\n@@ -52,0 +53,1 @@\n+import java.util.function.UnaryOperator;\n@@ -56,0 +58,1 @@\n+import jdk.jpackage.internal.PackagingPipeline.AppImageTaskAction;\n@@ -101,4 +104,0 @@\n-    static AppImageLayout packagingLayout(Package pkg) {\n-        return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName());\n-    }\n-\n@@ -107,9 +106,2 @@\n-                .appContextMapper(appContext -> {\n-                    return new TaskContextProxy(appContext, true, false);\n-                })\n-                .pkgContextMapper(appContext -> {\n-                    final var isRuntimeInstaller = pkg.map(Package::isRuntimeInstaller).orElse(false);\n-                    final var withPredefinedAppImage = pkg.flatMap(Package::predefinedAppImage).isPresent();\n-                    return new TaskContextProxy(appContext, false, isRuntimeInstaller || withPredefinedAppImage);\n-                })\n-                .appImageLayoutForPackaging(MacPackagingPipeline::packagingLayout)\n+                .contextMapper(pkg.map(MacPackagingPipeline::mapPackageTaskContext)\n+                        .orElseGet(MacPackagingPipeline::mapAppTaskContext))\n@@ -159,1 +151,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -165,1 +157,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -185,1 +177,0 @@\n-                builder.appImageLayoutForPackaging(Package::appImageLayout);\n@@ -239,2 +230,49 @@\n-    private static void copyAppImage(MacPackage pkg, AppImageDesc srcAppImage,\n-            AppImageDesc dstAppImage) throws IOException {\n+    static final class LayoutUtils {\n+        \/**\n+         * Returns unresolved app image layout for the specified package for use with\n+         * the signing function defined in {@link MacPackagingPipeline} class and\n+         * {@link MacPkgPackager} and {@link MacDmgPackager} packagers.\n+         * <p>\n+         * Paths of the result app image layout will start with the bundle name. E.g.:\n+         * for a package with relative installation directory set to\n+         * {@code \"Applications\/Acme\/MyApp.app\"} and the \"launchers\" directory of an\n+         * application layout set to {@code \"Contents\/MacOS\"}, the result application\n+         * layout object will be such that the value of its \"launchers\" directory will\n+         * be {@code \"MyApp.app\/Contents\/MacOS\"}. The root directory of the result app\n+         * image layout will be an empty path ({@link Path.of(\"\")}), i.e. the app image\n+         * layout will be unresolved.\n+         *\n+         * @param pkg the package\n+         * @return the unresolved app image layout for the specified package suitable\n+         *         for the use with macosx packaging pipeline and packagers\n+         *\/\n+        static AppImageLayout packagerLayout(Package pkg) {\n+            return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName()).resetRootDirectory();\n+        }\n+\n+        static <T extends AppImageLayout> AppImageBuildEnv<MacApplication, T> fromPackagerLayout(AppImageBuildEnv<MacApplication, T> cfg) {\n+\n+            var bundleDirectoryName = cfg.envLayout().runtimeDirectory().getName(0);\n+            var bundleLayout = cfg.envLayout().map(bundleDirectoryName::relativize).resetRootDirectory();\n+            var bundleRoot = cfg.env().appImageDir().resolve(bundleDirectoryName);\n+            var app = MacApplicationBuilder.overrideAppImageLayout(cfg.app(), bundleLayout);\n+            var env = BuildEnv.withAppImageLayout(cfg.env(), bundleLayout.resolveAt(bundleRoot));\n+\n+            return new AppImageBuildEnv<>(env, app);\n+        }\n+\n+        static <T extends AppImageLayout> AppImageTaskAction<MacApplication, T> withBundleLayout(AppImageTaskAction<MacApplication, T> action) {\n+            return new AppImageTaskAction<>() {\n+                @Override\n+                public void execute(AppImageBuildEnv<MacApplication, T> env) throws IOException, PackagerException {\n+                    if (!env.envLayout().runtimeDirectory().getName(0).equals(Path.of(\"Contents\"))) {\n+                        env = LayoutUtils.fromPackagerLayout(env);\n+                    }\n+                    action.execute(env);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static void copyAppImage(MacPackage pkg, AppImageLayout srcAppImage,\n+            AppImageLayout dstAppImage) throws IOException {\n@@ -244,1 +282,6 @@\n-        var inputRootDirectory = srcAppImage.resolvedAppImagelayout().rootDirectory();\n+        final Optional<MacBundle> srcMacBundle;\n+        if (pkg.isRuntimeInstaller()) {\n+            srcMacBundle = MacBundle.fromAppImageLayout(srcAppImage);\n+        } else {\n+            srcMacBundle = Optional.empty();\n+        }\n@@ -246,1 +289,1 @@\n-        if (pkg.isRuntimeInstaller() && MacBundle.isDirectoryMacBundle(inputRootDirectory)) {\n+        srcMacBundle.ifPresentOrElse(inputBundle -> {\n@@ -249,7 +292,15 @@\n-            FileUtils.copyRecursive(\n-                    inputRootDirectory,\n-                    dstAppImage.resolvedAppImagelayout().rootDirectory(),\n-                    LinkOption.NOFOLLOW_LINKS);\n-        } else {\n-            PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !predefinedAppImageSigned);\n-        }\n+            try {\n+                FileUtils.copyRecursive(\n+                        inputBundle.root(),\n+                        MacBundle.fromAppImageLayout(dstAppImage).orElseThrow().root(),\n+                        LinkOption.NOFOLLOW_LINKS);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }, () -> {\n+            try {\n+                PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !predefinedAppImageSigned);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n@@ -275,4 +326,17 @@\n-    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> env) throws IOException {\n-        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env.env(), env.env().appImageDir().resolve(env.envLayout().rootDirectory())),\n-                env.pkg(), env.pkg().appImageLayout(), env.outputDir()));\n+    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> cfg) throws IOException {\n+        var appCfg = LayoutUtils.fromPackagerLayout(\n+                new AppImageBuildEnv<>(cfg.env(), (MacApplication)cfg.pkg().app()));\n+\n+        var pkg = cfg.pkg(); pkg = new Package.Stub(\n+                appCfg.app(),\n+                pkg.type(),\n+                pkg.packageName(),\n+                pkg.description(),\n+                pkg.version(),\n+                pkg.aboutURL(),\n+                pkg.licenseFile(),\n+                pkg.predefinedAppImage(),\n+                pkg.installedPackageLayout(),\n+                pkg.relativeInstallDir());\n+\n+        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(appCfg.env(), pkg, cfg.outputDir()));\n@@ -334,1 +398,1 @@\n-        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).infoPlistFile();\n+        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow().infoPlistFile();\n@@ -387,2 +451,1 @@\n-            final var appImageDir = env.resolvedLayout().rootDirectory();\n-            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(appImageDir);\n+            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow());\n@@ -470,1 +533,1 @@\n-            return new MacBundle(env.resolvedLayout().rootDirectory());\n+            return MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow();\n@@ -501,0 +564,15 @@\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapAppTaskContext() {\n+        return ctx -> {\n+            return new TaskContextProxy(ctx, true, false);\n+        };\n+    }\n+\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapPackageTaskContext(Package pkg) {\n+        return ctx -> {\n+            final var isRuntimeInstaller = pkg.isRuntimeInstaller();\n+            final var withPredefinedAppImage = pkg.predefinedAppImage().isPresent();\n+            return new TaskContextProxy(ctx, false, isRuntimeInstaller || withPredefinedAppImage);\n+        };\n+    }\n+\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":113,"deletions":35,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.nio.file.Files;\n@@ -32,2 +33,0 @@\n-    MacApplication app();\n-\n@@ -35,7 +34,1 @@\n-    default AppImageLayout appImageLayout() {\n-        if (isRuntimeInstaller()) {\n-            return RUNTIME_PACKAGE_LAYOUT;\n-        } else {\n-            return Package.super.appImageLayout();\n-        }\n-    }\n+    MacApplication app();\n@@ -51,1 +44,15 @@\n-    public static final RuntimeLayout RUNTIME_PACKAGE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n+    \/**\n+     * Guesses layout of a runtime image at the given path.\n+     *\n+     * @param path the path to a runtime image\n+     * @return the runtime image layout resolved at the given path\n+     *\/\n+    public static RuntimeLayout guessRuntimeLayout(Path path) {\n+        if (Files.isDirectory(RUNTIME_BUNDLE_LAYOUT.resolveAt(path).runtimeDirectory())) {\n+            return RUNTIME_BUNDLE_LAYOUT.resolveAt(path);\n+        } else {\n+            return RuntimeLayout.DEFAULT.resolveAt(path);\n+        }\n+    }\n+\n+    public static final RuntimeLayout RUNTIME_BUNDLE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacPackage.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-\n-record AppImageDesc(AppImageLayout appImageLayout, Path path) {\n-\n-    AppImageDesc {\n-        Objects.requireNonNull(appImageLayout);\n-        Objects.requireNonNull(path);\n-    }\n-\n-    AppImageLayout resolvedAppImagelayout() {\n-        return appImageLayout.resolveAt(path);\n-    }\n-\n-    Optional<ApplicationLayout> asResolvedApplicationLayout() {\n-        return asApplicationLayout().map(v -> v.resolveAt(path));\n-    }\n-\n-    Optional<ApplicationLayout> asApplicationLayout() {\n-        if (appImageLayout instanceof ApplicationLayout layout) {\n-            return Optional.of(layout);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageDesc.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -156,3 +156,24 @@\n-        return new Launcher.Stub(launcher.name(), Optional.of(startupInfo),\n-                launcher.fileAssociations(), launcher.isService(), launcher.description(),\n-                launcher.icon(), launcher.defaultIconResourceName(), launcher.extraAppImageFileData());\n+        return new Launcher.Stub(\n+                launcher.name(),\n+                Optional.of(startupInfo),\n+                launcher.fileAssociations(),\n+                launcher.isService(),\n+                launcher.description(),\n+                launcher.icon(),\n+                launcher.defaultIconResourceName(),\n+                launcher.extraAppImageFileData());\n+    }\n+\n+    static Application overrideAppImageLayout(Application app, AppImageLayout appImageLayout) {\n+        return new Application.Stub(\n+                app.name(),\n+                app.description(),\n+                app.version(),\n+                app.vendor(),\n+                app.copyright(),\n+                app.srcDir(),\n+                app.contentDirs(),\n+                Objects.requireNonNull(appImageLayout),\n+                app.runtimeBuilder(),\n+                app.launchers(),\n+                app.extraAppImageFileData());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            env.app().runtimeBuilder().orElseThrow().createRuntime(env.resolvedLayout());\n+            env.app().runtimeBuilder().orElseThrow().create(env.resolvedLayout());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -31,0 +33,3 @@\n+\/**\n+ * Build environment.\n+ *\/\n@@ -33,0 +38,5 @@\n+    \/**\n+     * Returns root directory for intermediate build files.\n+     *\n+     * @return the root directory for intermediate build files\n+     *\/\n@@ -35,0 +45,5 @@\n+    \/**\n+     * Returns <code>true<\/code> if the build should be verbose output.\n+     *\n+     * @return <code>true<\/code> if the build should be verbose output\n+     *\/\n@@ -37,0 +52,7 @@\n+    \/**\n+     * Returns the path of the resource directory or an empty {@link Optional}\n+     * instance if none is configured with the build.\n+     *\n+     * @return the path of the resource directory or an empty {@link Optional}\n+     *         instance if non is configured with the build\n+     *\/\n@@ -40,1 +62,1 @@\n-     * Returns path to application image directory.\n+     * Returns the path of the app image directory of this build.\n@@ -42,2 +64,1 @@\n-     * The return value is supposed to be used as a parameter for\n-     * ApplicationLayout#resolveAt function.\n+     * @return the path of the app image directory of this build\n@@ -46,1 +67,1 @@\n-        return buildRoot().resolve(\"image\");\n+        return appImageLayout().rootDirectory();\n@@ -49,0 +70,20 @@\n+    \/**\n+     * Returns resolved app image layout of the app image directory. The return\n+     * layout is resolved at {@link #appImageDir()} path.\n+     *\n+     * @return the resolved app image layout of the app image directory\n+     *\/\n+    AppImageLayout appImageLayout();\n+\n+    default Optional<ApplicationLayout> asApplicationLayout() {\n+        if (appImageLayout() instanceof ApplicationLayout layout) {\n+            return Optional.of(layout);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Returns a path to a directory for intermediate configuration files.\n+     * @return the path to the directory for intermediate configuration files\n+     *\/\n@@ -53,0 +94,7 @@\n+    \/**\n+     * Creates an {@link OverridableResource} instance for the given resource name.\n+     *\n+     * @param defaultName the resource name\n+     * @return the {@link OverridableResource} instance wrapping a resource with the\n+     *         given name\n+     *\/\n@@ -59,2 +107,8 @@\n-    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose, Class<?> resourceLocator) {\n-        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.empty());\n+    static BuildEnv withAppImageLayout(BuildEnv env, AppImageLayout appImageLayout) {\n+        return ((Internal.DefaultBuildEnv)env).copyWithAppImageLayout(appImageLayout);\n+    }\n+\n+    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose,\n+            Class<?> resourceLocator, AppImageLayout appImageLayout) {\n+        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose,\n+                resourceLocator, appImageLayout);\n@@ -64,2 +118,3 @@\n-        private static record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n-                boolean verbose, Class<?> resourceLocator, Optional<Path> optAppImageDir) implements BuildEnv {\n+        private record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n+                boolean verbose, Class<?> resourceLocator,\n+                AppImageLayout appImageLayout) implements BuildEnv {\n@@ -71,1 +126,1 @@\n-                Objects.requireNonNull(optAppImageDir);\n+                Objects.requireNonNull(appImageLayout);\n@@ -74,2 +129,2 @@\n-            DefaultBuildEnv copyWithAppImageDir(Path appImageDir) {\n-                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.of(appImageDir));\n+            DefaultBuildEnv copyWithAppImageDir(Path v) {\n+                return copyWithAppImageLayout(appImageLayout.unresolve().resolveAt(v));\n@@ -78,3 +133,2 @@\n-            @Override\n-            public Path appImageDir() {\n-                return optAppImageDir.orElseGet(BuildEnv.super::appImageDir);\n+            DefaultBuildEnv copyWithAppImageLayout(AppImageLayout v) {\n+                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, v);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnv.java","additions":68,"deletions":14,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.internal.model.Package;\n@@ -43,2 +45,0 @@\n-        Objects.requireNonNull(appImageDir);\n-\n@@ -60,2 +60,2 @@\n-        return BuildEnv.withAppImageDir(BuildEnv.create(root, Optional.ofNullable(resourceDir),\n-                verbose, ResourceLocator.class), appImageDir);\n+        return BuildEnv.create(root, Optional.ofNullable(resourceDir), verbose,\n+                ResourceLocator.class, resolvedAppImageLayout());\n@@ -79,0 +79,5 @@\n+    BuildEnvBuilder appImageLayout(AppImageLayout v) {\n+        appImageLayout = v;\n+        return this;\n+    }\n+\n@@ -81,0 +86,1 @@\n+        appImageLayout = app.imageLayout();\n@@ -84,1 +90,1 @@\n-    BuildEnvBuilder appImageDirForPackage() {\n+    BuildEnvBuilder appImageDirFor(Package pkg) {\n@@ -86,0 +92,1 @@\n+        appImageLayout = pkg.appImageLayout();\n@@ -89,0 +96,5 @@\n+    private AppImageLayout resolvedAppImageLayout() {\n+        Objects.requireNonNull(appImageLayout);\n+        return Optional.ofNullable(appImageDir).map(appImageLayout.unresolve()::resolveAt).orElse(appImageLayout);\n+    }\n+\n@@ -94,0 +106,1 @@\n+    private AppImageLayout appImageLayout;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvBuilder.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n@@ -33,0 +34,1 @@\n+import java.nio.file.Path;\n@@ -34,0 +36,1 @@\n+import java.util.function.Function;\n@@ -35,0 +38,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -38,1 +42,2 @@\n-    static BuildEnv create(Map<String, ? super Object> params) throws ConfigException {\n+    static BuildEnv create(Map<String, ? super Object> params,\n+            Function<Path, RuntimeLayout> predefinedRuntimeImageLayoutProvider) throws ConfigException {\n@@ -50,1 +55,2 @@\n-            PREDEFINED_RUNTIME_IMAGE.copyInto(params, builder::appImageDir);\n+            var layout = predefinedRuntimeImageLayoutProvider.apply(PREDEFINED_RUNTIME_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -52,1 +58,2 @@\n-            PREDEFINED_APP_IMAGE.copyInto(params, builder::appImageDir);\n+            var layout = PLATFORM_APPLICATION_LAYOUT.resolveAt(PREDEFINED_APP_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -54,1 +61,1 @@\n-            builder.appImageDirForPackage();\n+            builder.appImageDirFor(pkg.orElseThrow());\n@@ -62,2 +69,3 @@\n-    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(\n-            BuildEnv.class, BuildEnvFromParams::create);\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return create(params, RuntimeLayout.DEFAULT::resolveAt);\n+    });\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromParams.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        return createApplicationBuilder(params, launcherMapper, appLayout, Optional.of(RuntimeLayout.DEFAULT));\n+        return createApplicationBuilder(params, launcherMapper, appLayout, RuntimeLayout.DEFAULT, Optional.of(RuntimeLayout.DEFAULT));\n@@ -85,1 +85,2 @@\n-            ApplicationLayout appLayout, Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n+            ApplicationLayout appLayout, RuntimeLayout runtimeLayout,\n+            Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n@@ -105,1 +106,1 @@\n-            appBuilder.appImageLayout(predefinedRuntimeLayout.orElseThrow());\n+            appBuilder.appImageLayout(runtimeLayout);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    public void createRuntime(AppImageLayout appImageLayout) throws PackagerException {\n+    public void create(AppImageLayout appImageLayout) throws PackagerException {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -89,0 +90,1 @@\n+                validatedInstalledPackageLayout(relativeInstallDir),\n@@ -92,0 +94,9 @@\n+    PackageBuilder app(Application v) {\n+        app = v;\n+        return this;\n+    }\n+\n+    Application app() {\n+        return app;\n+    }\n+\n@@ -172,0 +183,9 @@\n+    PackageBuilder installedPackageLayout(AppImageLayout v) {\n+        installedPackageLayout = v;\n+        return this;\n+    }\n+\n+    Optional<AppImageLayout> installedPackageLayout() {\n+        return Optional.ofNullable(installedPackageLayout);\n+    }\n+\n@@ -176,0 +196,15 @@\n+    private AppImageLayout validatedInstalledPackageLayout(Path relativeInstallDir) {\n+        return installedPackageLayout().orElseGet(() -> {\n+            var theInstallDir = relativeInstallDir;\n+            if (type instanceof StandardPackageType stdType) {\n+                switch (stdType) {\n+                    case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n+                        theInstallDir = Path.of(\"\/\").resolve(theInstallDir);\n+                    }\n+                    default -> {}\n+                }\n+            }\n+            return app.imageLayout().resolveAt(theInstallDir).resetRootDirectory();\n+        });\n+    }\n+\n@@ -238,0 +273,1 @@\n+    private Application app;\n@@ -246,0 +282,1 @@\n+    private AppImageLayout installedPackageLayout;\n@@ -248,1 +285,0 @@\n-    private final Application app;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackageBuilder.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -41,1 +42,0 @@\n-import java.util.function.Function;\n@@ -44,0 +44,1 @@\n+import java.util.stream.Stream;\n@@ -65,1 +66,1 @@\n-        execute(appContextMapper.apply(createTaskContext(env, app)));\n+        execute(contextMapper.apply(createTaskContext(env, app)));\n@@ -84,2 +85,1 @@\n-        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir,\n-                taskConfig, appImageLayoutForPackaging.apply(pkg)));\n+        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir, taskConfig));\n@@ -95,1 +95,1 @@\n-        execute(pkgContextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n+        execute(contextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n@@ -138,1 +138,6 @@\n-    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app, U envLayout) {\n+    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app) {\n+        @SuppressWarnings(\"unchecked\")\n+        U envLayout() {\n+            return (U)app.imageLayout();\n+        }\n+\n@@ -141,1 +146,1 @@\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+            return (U)env.appImageLayout();\n@@ -145,1 +150,1 @@\n-    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, U envLayout, Path outputDir) {\n+    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, Path outputDir) {\n@@ -147,2 +152,2 @@\n-        U resolvedLayout() {\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+        U envLayout() {\n+            return (U)pkg.appImageLayout();\n@@ -151,2 +156,3 @@\n-        AppImageBuildEnv<Application, U> appImageBuildEnv() {\n-            return new AppImageBuildEnv<>(env, pkg.app(), envLayout);\n+        @SuppressWarnings(\"unchecked\")\n+        U resolvedLayout() {\n+            return (U)env.appImageLayout();\n@@ -168,1 +174,1 @@\n-        void execute(T pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException, PackagerException;\n+        void execute(T pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException, PackagerException;\n@@ -198,0 +204,5 @@\n+            private TaskBuilder(TaskID id, TaskConfig config) {\n+                this(id);\n+                config.action().ifPresent(this::setAction);\n+            }\n+\n@@ -228,0 +239,4 @@\n+            boolean hasAction() {\n+                return action != null;\n+            }\n+\n@@ -286,0 +301,6 @@\n+        Stream<TaskBuilder> configuredTasks() {\n+            return taskConfig.entrySet().stream().map(e -> {\n+                return new TaskBuilder(e.getKey(), e.getValue());\n+            });\n+        }\n+\n@@ -293,17 +314,1 @@\n-            appContextMapper(v);\n-            pkgContextMapper(v);\n-            return this;\n-        }\n-\n-        Builder appContextMapper(UnaryOperator<TaskContext> v) {\n-            appContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder pkgContextMapper(UnaryOperator<TaskContext> v) {\n-            pkgContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder appImageLayoutForPackaging(Function<Package, AppImageLayout> v) {\n-            appImageLayoutForPackaging = v;\n+            contextMapper = v;\n@@ -321,6 +326,1 @@\n-            return createPackagingTaskContext(env, pkg, outputDir, taskConfig,\n-                    validatedAppImageLayoutForPackaging().apply(pkg));\n-        }\n-\n-        private Function<Package, AppImageLayout> validatedAppImageLayoutForPackaging() {\n-            return Optional.ofNullable(appImageLayoutForPackaging).orElse(Package::packageLayout);\n+            return createPackagingTaskContext(env, pkg, outputDir, taskConfig);\n@@ -331,3 +331,1 @@\n-                    Optional.ofNullable(appContextMapper).orElse(UnaryOperator.identity()),\n-                    Optional.ofNullable(pkgContextMapper).orElse(UnaryOperator.identity()),\n-                    validatedAppImageLayoutForPackaging());\n+                    Optional.ofNullable(contextMapper).orElse(UnaryOperator.identity()));\n@@ -339,3 +337,1 @@\n-        private UnaryOperator<TaskContext> appContextMapper;\n-        private UnaryOperator<TaskContext> pkgContextMapper;\n-        private Function<Package, AppImageLayout> appImageLayoutForPackaging;\n+        private UnaryOperator<TaskContext> contextMapper;\n@@ -407,1 +403,1 @@\n-    static void copyAppImage(Package pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException {\n+    static void copyAppImage(Package pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException {\n@@ -411,1 +407,1 @@\n-    static void copyAppImage(AppImageDesc srcAppImage, AppImageDesc dstAppImage,\n+    static void copyAppImage(AppImageLayout srcAppImage, AppImageLayout dstAppImage,\n@@ -413,2 +409,1 @@\n-        final var srcLayout = srcAppImage.resolvedAppImagelayout();\n-        final var srcLayoutPathGroup = AppImageLayout.toPathGroup(srcLayout);\n+        final var srcLayoutPathGroup = toPathGroup(srcAppImage);\n@@ -416,1 +411,1 @@\n-        if (removeAppImageFile && srcLayout instanceof ApplicationLayout appLayout) {\n+        if (removeAppImageFile && srcAppImage instanceof ApplicationLayout appLayout) {\n@@ -421,1 +416,1 @@\n-        srcLayoutPathGroup.copy(AppImageLayout.toPathGroup(dstAppImage.resolvedAppImagelayout()), LinkOption.NOFOLLOW_LINKS);\n+        srcLayoutPathGroup.copy(toPathGroup(dstAppImage), LinkOption.NOFOLLOW_LINKS);\n@@ -435,2 +430,1 @@\n-            UnaryOperator<TaskContext> appContextMapper, UnaryOperator<TaskContext> pkgContextMapper,\n-            Function<Package, AppImageLayout> appImageLayoutForPackaging) {\n+            UnaryOperator<TaskContext> contextMapper) {\n@@ -439,3 +433,1 @@\n-        this.appContextMapper = Objects.requireNonNull(appContextMapper);\n-        this.pkgContextMapper = Objects.requireNonNull(pkgContextMapper);\n-        this.appImageLayoutForPackaging = Objects.requireNonNull(appImageLayoutForPackaging);\n+        this.contextMapper = Objects.requireNonNull(contextMapper);\n@@ -445,1 +437,1 @@\n-        return new DefaultTaskContext(taskGraph, env, app, app.asApplicationLayout(), Optional.empty());\n+        return new DefaultTaskContext(taskGraph, env, app, Optional.empty());\n@@ -449,3 +441,2 @@\n-        final var pkgEnv = BuildEnv.withAppImageDir(packagingContext.env.env(), packagingContext.srcAppImage.path());\n-        return new DefaultTaskContext(taskGraph, pkgEnv, packagingContext.env.pkg.app(),\n-                packagingContext.srcAppImage.asApplicationLayout(), Optional.of(packagingContext));\n+        return new DefaultTaskContext(taskGraph, packagingContext.env(),\n+                packagingContext.pkg().app(), Optional.of(packagingContext));\n@@ -455,1 +446,1 @@\n-            Path outputDir, Map<TaskID, TaskConfig> taskConfig, AppImageLayout appImageLayoutForPackaging) {\n+            Path outputDir, Map<TaskID, TaskConfig> taskConfig) {\n@@ -460,1 +451,3 @@\n-        Objects.requireNonNull(appImageLayoutForPackaging);\n+        if (pkg.appImageLayout().isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -462,2 +455,2 @@\n-        final AppImageDesc srcAppImageDesc;\n-        final AppImageDesc dstAppImageDesc;\n+        final AppImageLayout srcLayout;\n+        final AppImageLayout dstLayout;\n@@ -466,3 +459,2 @@\n-            \/\/ appImageDir() should point to a directory where the application image will be created.\n-            srcAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.appImageDir());\n-            dstAppImageDesc = srcAppImageDesc;\n+            srcLayout = pkg.appImageLayout().resolveAt(env.appImageDir());\n+            dstLayout = srcLayout;\n@@ -470,2 +462,17 @@\n-            srcAppImageDesc = new AppImageDesc(pkg.app().imageLayout(),\n-                    pkg.predefinedAppImage().orElseThrow(UnsupportedOperationException::new));\n+            srcLayout = pkg.predefinedAppImage().map(predefinedAppImage -> {\n+                \/\/ Will create a package from the predefined app image.\n+                if (predefinedAppImage.equals(env.appImageDir())) {\n+                    return env.appImageLayout();\n+                } else {\n+                    return pkg.appImageLayout().resolveAt(predefinedAppImage);\n+                }\n+            }).orElseGet(() -> {\n+                \/\/ No predefined app image and no runtime builder.\n+                \/\/ This should be runtime packaging.\n+                if (pkg.isRuntimeInstaller()) {\n+                    return env.appImageLayout();\n+                } else {\n+                    \/\/ Can't create app image without runtime builder.\n+                    throw new UnsupportedOperationException();\n+                }\n+            });\n@@ -474,3 +481,3 @@\n-                \/\/ \"copy app image\" task action is undefined indicating\n-                \/\/ the package will use provided app image as-is.\n-                dstAppImageDesc = srcAppImageDesc;\n+                \/\/ \"copy app image\" task action is empty indicating\n+                \/\/ the package will use provided app image in place.\n+                dstLayout = srcLayout;\n@@ -478,1 +485,1 @@\n-                dstAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.buildRoot().resolve(\"image\"));\n+                dstLayout = pkg.appImageLayout().resolveAt(env.buildRoot().resolve(\"image\"));\n@@ -482,4 +489,1 @@\n-        final var pkgEnv = new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env, dstAppImageDesc.path()), pkg, dstAppImageDesc.appImageLayout(), outputDir);\n-\n-        return new PackagingTaskContext(pkgEnv, srcAppImageDesc);\n+        return new PackagingTaskContext(BuildEnv.withAppImageLayout(env, dstLayout), pkg, outputDir, srcLayout);\n@@ -503,0 +507,6 @@\n+        } catch (ExceptionBox ex) {\n+            throw new PackagerException(ex.getCause());\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (PackagerException ex) {\n+            throw ex;\n@@ -504,7 +514,1 @@\n-            if (ex instanceof PackagerException pex) {\n-                throw pex;\n-            } else if (ex instanceof ExceptionBox bex) {\n-                throw new PackagerException(bex.getCause());\n-            } else {\n-                throw new PackagerException(ex);\n-            }\n+            throw new PackagerException(ex);\n@@ -514,2 +518,2 @@\n-    private record PackagingTaskContext(PackageBuildEnv<Package, AppImageLayout> env,\n-            AppImageDesc srcAppImage) implements TaskContext, StartupParameters {\n+    private record PackagingTaskContext(BuildEnv env, Package pkg, Path outputDir,\n+            AppImageLayout srcAppImage) implements TaskContext, StartupParameters {\n@@ -519,0 +523,2 @@\n+            Objects.requireNonNull(pkg);\n+            Objects.requireNonNull(outputDir);\n@@ -524,1 +530,1 @@\n-            return env.env;\n+            return env;\n@@ -541,1 +547,1 @@\n-                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(env);\n+                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(pkgBuildEnv());\n@@ -543,2 +549,2 @@\n-                ((CopyAppImageTaskAction<Package>)taskAction).execute(env.pkg(),\n-                        srcAppImage, new AppImageDesc(env.envLayout(), env.env().appImageDir()));\n+                ((CopyAppImageTaskAction<Package>)taskAction).execute(pkg(),\n+                        srcAppImage, env.appImageLayout());\n@@ -551,1 +557,5 @@\n-            return env.appImageBuildEnv();\n+            return new AppImageBuildEnv<>(env, pkg.app());\n+        }\n+\n+        PackageBuildEnv<Package, AppImageLayout> pkgBuildEnv() {\n+            return new PackageBuildEnv<>(env, pkg, outputDir);\n@@ -556,1 +566,1 @@\n-            Optional<ApplicationLayout> appLayout, Optional<PackagingTaskContext> pkg) implements TaskContext {\n+            Optional<PackagingTaskContext> pkg) implements TaskContext {\n@@ -562,1 +572,0 @@\n-            Objects.requireNonNull(appLayout);\n@@ -574,2 +583,2 @@\n-            } else if (pkg.isEmpty() && isPackageTask) {\n-                \/\/ Building application image, skip packaging tasks.\n+            } else if (pkg.isEmpty() && (isPackageTask || isCopyAppImageTask)) {\n+                \/\/ Building application image, skip packaging and copying app image tasks.\n@@ -577,2 +586,2 @@\n-            } else if (app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n-                \/\/ Runtime builder is not present, skip building application image tasks.\n+            } else if (pkg.isPresent() && app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n+                \/\/ Building a package, runtime builder is not present, skip building application image tasks.\n@@ -599,1 +608,1 @@\n-                pkg.orElseThrow().execute(taskAction);\n+                pkg.orElseThrow(UnsupportedOperationException::new).execute(taskAction);\n@@ -615,1 +624,1 @@\n-            return new AppImageBuildEnv<>(env, app, (T)appLayout.orElseThrow());\n+            return new AppImageBuildEnv<>(env, app);\n@@ -625,5 +634,1 @@\n-                try {\n-                    context.execute(config.action.orElseThrow());\n-                } catch (ExceptionBox ex) {\n-                    throw ExceptionBox.rethrowUnchecked(ex);\n-                }\n+                context.execute(config.action.orElseThrow());\n@@ -637,3 +642,1 @@\n-    private final Function<Package, AppImageLayout> appImageLayoutForPackaging;\n-    private final UnaryOperator<TaskContext> appContextMapper;\n-    private final UnaryOperator<TaskContext> pkgContextMapper;\n+    private final UnaryOperator<TaskContext> contextMapper;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":107,"deletions":104,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -32,0 +35,1 @@\n+import java.util.Objects;\n@@ -33,0 +37,1 @@\n+import java.util.function.UnaryOperator;\n@@ -35,2 +40,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n@@ -44,3 +47,8 @@\n- *\n- * The layout is \"unresolved\" if the root directory is an empty string and\n- * \"resolved\" otherwise.\n+ * <p>\n+ * The layout is \"unresolved\" if the root directory is an empty path\n+ * ({@code Path.of(\"\")}) and \"resolved\" otherwise.\n+ * <p>\n+ * The return value of the {@link #runtimeDirectory()} method call is always a\n+ * path starting with the path returned by the {@link #rootDirectory()} method\n+ * call. Public methods without parameters and with the return type {@link Path}\n+ * in the derived interfaces must comply to this constrain.\n@@ -59,1 +67,1 @@\n-     * Root directory of this app image.\n+     * Root directory of this app image layout.\n@@ -62,1 +70,1 @@\n-     * @return the root directory of this app image\n+     * @return the root directory of this app image layout\n@@ -67,1 +75,21 @@\n-     * Creates a copy of this app image resolved at the given root directory.\n+     * Returns a copy of this app image layout with the root directory set to an empty\n+     * path ({@code Path.of(\"\")}) or this instance if its root directory is already\n+     * an empty path.\n+     *\n+     * @return an app image layout with the root directory set to an empty path\n+     *\/\n+    AppImageLayout resetRootDirectory();\n+\n+    \/**\n+     * Returns <code>true<\/code> if the root directory of this app image layout is\n+     * not an empty path, i.e, if it is not equal to <code>Path.of(\"\")<\/code>.\n+     *\n+     * @return <code>true<\/code> if the root directory of this app image layout is\n+     *         not an empty path\n+     *\/\n+    default boolean isResolved() {\n+        return !rootDirectory().equals(Path.of(\"\"));\n+    }\n+\n+    \/**\n+     * Creates a copy of this app image layout resolved at the given root directory.\n@@ -70,1 +98,29 @@\n-     * @return a copy of this app image resolved at the given root directory\n+     * @return a copy of this app image layout resolved at the given root directory\n+     *\/\n+    default AppImageLayout resolveAt(Path root) {\n+        return map(root::resolve);\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout resolved such that its root directory\n+     * is set to an empty path ({@code Path.of(\"\")}) or this instance if its root\n+     * directory is already an empty path.\n+     *\n+     * @return an app image layout resolved at {@code Path.of(\"\")} path\n+     *\/\n+    default AppImageLayout unresolve() {\n+        if (isResolved()) {\n+            final var root = rootDirectory();\n+            return map(root::relativize);\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout with the specified mapper applied to\n+     * every path.\n+     *\n+     * @param mapper the mapper to use with every path in this app image layout.\n+     * @return the copy of this app image layout with the specified mapper applied\n+     *         to every path\n@@ -72,1 +128,1 @@\n-    AppImageLayout resolveAt(Path root);\n+    AppImageLayout map(UnaryOperator<Path> mapper);\n@@ -76,1 +132,1 @@\n-    *\/\n+     *\/\n@@ -79,0 +135,17 @@\n+        public Stub {\n+            Objects.requireNonNull(rootDirectory);\n+        }\n+\n+        public Stub(Path runtimeDirectory) {\n+            this(Path.of(\"\"), runtimeDirectory);\n+        }\n+\n+        @Override\n+        public AppImageLayout resetRootDirectory() {\n+            if (isResolved()) {\n+                return new Stub(runtimeDirectory);\n+            } else {\n+                return this;\n+            }\n+        }\n+\n@@ -80,2 +153,2 @@\n-        public AppImageLayout resolveAt(Path base) {\n-            return new Stub(resolveNullablePath(base, rootDirectory), resolveNullablePath(base, runtimeDirectory));\n+        public AppImageLayout map(UnaryOperator<Path> mapper) {\n+            return new Stub(mapNullablePath(mapper, rootDirectory), mapNullablePath(mapper, runtimeDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/AppImageLayout.java","additions":86,"deletions":13,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -31,0 +31,1 @@\n+import java.util.function.UnaryOperator;\n@@ -45,1 +46,20 @@\n-        return buildFrom(this).resolveAt(root).create();\n+        return (ApplicationLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default ApplicationLayout unresolve() {\n+        return (ApplicationLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default ApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return buildFrom(this).rootDirectory(\"\").create();\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default ApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return buildFrom(this).mutate(mapper).create();\n@@ -116,8 +136,8 @@\n-        public Builder resolveAt(Path base) {\n-            rootDirectory(resolveNullablePath(base, rootDirectory));\n-            launchersDirectory(resolveNullablePath(base, launchersDirectory));\n-            appDirectory(resolveNullablePath(base, appDirectory));\n-            runtimeDirectory(resolveNullablePath(base, runtimeDirectory));\n-            appModsDirectory(resolveNullablePath(base, appModsDirectory));\n-            desktopIntegrationDirectory(resolveNullablePath(base, desktopIntegrationDirectory));\n-            contentDirectory(resolveNullablePath(base, contentDirectory));\n+        public Builder mutate(UnaryOperator<Path> mapper) {\n+            rootDirectory(mapNullablePath(mapper, rootDirectory));\n+            launchersDirectory(mapNullablePath(mapper, launchersDirectory));\n+            appDirectory(mapNullablePath(mapper, appDirectory));\n+            runtimeDirectory(mapNullablePath(mapper, runtimeDirectory));\n+            appModsDirectory(mapNullablePath(mapper, appModsDirectory));\n+            desktopIntegrationDirectory(mapNullablePath(mapper, desktopIntegrationDirectory));\n+            contentDirectory(mapNullablePath(mapper, contentDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLayout.java","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n- * The interface specifies the source app image layout with two transformations:\n- * package app image layout and installed app image layout.\n+ * The interface specifies the source app image and the installed app image layouts.\n@@ -39,7 +38,0 @@\n- * Package app image layout is the source app image layout resolved at the\n- * relative installation directory of the package. Additionally, to resolve the\n- * source layout, some packages may transform the source layout.\n- * <p>\n- * Use {@link #packageLayout()} or {@link #asPackageApplicationLayout()} to get\n- * the package app image layout.\n- * <p>\n@@ -58,1 +50,0 @@\n- * <th>Package app image layout<\/th>\n@@ -65,1 +56,0 @@\n- * <td>Duke\/bin\/foo.exe Duke\/app\/foo.jar<\/td>\n@@ -70,1 +60,0 @@\n- * <td>opt\/duke\/bin\/foo opt\/duke\/lib\/app\/foo.jar<\/td>\n@@ -76,1 +65,0 @@\n- * <td>Applications\/Duke.app\/Contents\/MacOS\/foo Applications\/Duke.app\/Contents\/app\/foo.jar<\/td>\n@@ -172,1 +160,0 @@\n-     * @see #packageLayout\n@@ -196,38 +183,0 @@\n-    \/**\n-     * Gets the layout of the installed app image of the application resolved at the\n-     * relative installation directory of this package.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package\n-     *\n-     * @see #relativeInstallDir\n-     * @see #appImageLayout\n-     * @see #installedPackageLayout\n-     *\/\n-    default AppImageLayout packageLayout() {\n-        return appImageLayout().resolveAt(relativeInstallDir());\n-    }\n-\n-    \/**\n-     * Returns the layout of the installed app image of the application resolved at\n-     * the relative installation directory of this package as\n-     * {@link ApplicationLayout} type or an empty {@link Optional} instance if the\n-     * layout object is of incompatible type.\n-     * <p>\n-     * Returns an empty {@link Optional} instance if {@link #isRuntimeInstaller()}\n-     * returns <code>true<\/code>.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package as\n-     *         {@link ApplicationLayout} type\n-     *\n-     * @see #packageLayout\n-     *\/\n-    default Optional<ApplicationLayout> asPackageApplicationLayout() {\n-        if (packageLayout() instanceof ApplicationLayout layout) {\n-            return Optional.of(layout);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n@@ -240,1 +189,0 @@\n-     * @see #packageLayout\n@@ -242,16 +190,1 @@\n-    default AppImageLayout installedPackageLayout() {\n-        return asStandardPackageType().map(stdType -> {\n-            switch (stdType) {\n-                case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n-                    return packageLayout().resolveAt(Path.of(\"\/\"));\n-                }\n-                case WIN_EXE, WIN_MSI -> {\n-                    return packageLayout();\n-                }\n-                default -> {\n-                    \/\/ Should never get here\n-                    throw new IllegalStateException();\n-                }\n-            }\n-        }).orElseThrow(UnsupportedOperationException::new);\n-    }\n+    AppImageLayout installedPackageLayout();\n@@ -337,1 +270,1 @@\n-            Path relativeInstallDir) implements Package {\n+            AppImageLayout installedPackageLayout, Path relativeInstallDir) implements Package {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Package.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    void createRuntime(AppImageLayout appImageLayout) throws PackagerException;\n+    void create(AppImageLayout appImageLayout) throws PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -42,2 +43,21 @@\n-        return create(new AppImageLayout.Stub(resolveNullablePath(root, rootDirectory()),\n-                resolveNullablePath(root, runtimeDirectory())));\n+        return (RuntimeLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default RuntimeLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(runtimeDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default RuntimeLayout unresolve() {\n+        return (RuntimeLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default RuntimeLayout map(UnaryOperator<Path> mapper) {\n+        return create(new RuntimeLayout.Stub(mapNullablePath(mapper, rootDirectory()),\n+                mapNullablePath(mapper, runtimeDirectory())));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeLayout.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-public class ResourceLocator {\n-    public ResourceLocator() {\n+public final class ResourceLocator {\n+    private ResourceLocator() {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/ResourceLocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -473,0 +473,17 @@\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(entries);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        PathGroup other = (PathGroup) obj;\n+        return Objects.equals(entries, other.entries);\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathGroup.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -29,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -50,2 +52,7 @@\n-    public static Path resolveNullablePath(Path base, Path path) {\n-        return Optional.ofNullable(path).map(base::resolve).orElse(null);\n+    public static Path mapNullablePath(UnaryOperator<Path> mapper, Path path) {\n+        Objects.requireNonNull(mapper);\n+        if (path != null) {\n+            return mapper.apply(path);\n+        } else {\n+            return null;\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathUtils.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -50,1 +49,0 @@\n-                .appImageLayoutForPackaging(Package::appImageLayout)\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinPackagingPipeline.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                pkg.installedPackageLayout(),\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinExePackage.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/helpers-test\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,5 +45,4 @@\n-    public static void testClassFilePath(String... args) {\n-        var appDesc = args[0];\n-        var expectedClassFilePath = Path.of(args[1]);\n-        TKit.assertEquals(expectedClassFilePath.toString(), JavaAppDesc.parse(\n-                appDesc).classFilePath().toString(), null);\n+    public static void testClassFilePath(String appDesc, String expectedClassFile) {\n+        var expectedClassFilePath = Path.of(expectedClassFile);\n+        TKit.assertEquals(expectedClassFilePath.toString(),\n+                JavaAppDesc.parse(appDesc).classFilePath().toString(), null);\n@@ -58,0 +57,6 @@\n+            createTestCase(\"bye.jar:!\", appDesc -> {\n+                return appDesc\n+                        .setBundleFileName(\"bye.jar\")\n+                        .setClassName(\"Hello\")\n+                        .setWithMainClass(true);\n+            }),\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JavaAppDescTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class LinuxApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static LinuxApplicationLayout createLayout() {\n+        return LinuxApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"libapplauncher.so\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test LinuxApplicationLayout\n+ * @requires (os.family == \"linux\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LinuxApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class MacApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static MacApplicationLayout createLayout() {\n+        return MacApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"Contents\/runtime\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test MacApplicationLayoutTest\n+ * @requires (os.family == \"mac\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/MacApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.MacApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class BuildEnvTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"image\"})\n+    public void testUnresolvedAppImageLayout(Path appImageDir) {\n+        final var rootDir = Path.of(\"\");\n+\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory());\n+\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @Test\n+    public void testResolvedAppImageLayout() {\n+        final var rootDir = Path.of(\"\/oof\");\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final var layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true, BuildEnvTest.class, layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\/foo\/bar\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"\/foo\/bar\"})\n+    public void test_withAppImageDir(Path appImageDir) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var layout = RuntimeLayout.DEFAULT;\n+        final var env = BuildEnv.withAppImageDir(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, layout), appImageDir);\n+\n+        assertNotSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(appImageDir, env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_withAppImageLayout(boolean resolved) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final AppImageLayout layout;\n+        if (resolved) {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        } else {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory();\n+        }\n+\n+        final var env = BuildEnv.withAppImageLayout(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, RuntimeLayout.DEFAULT), layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @Test\n+    public void test_asApplicationLayout() {\n+        final var rootDir = Path.of(\"r\");\n+\n+        assertTrue(BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT).asApplicationLayout().isEmpty());\n+\n+        var layout = ApplicationLayout.build().setAll(\"foo\").create();\n+        assertSame(layout, BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, layout).asApplicationLayout().orElseThrow());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/BuildEnvTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,872 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.CopyAppImageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.NoArgTaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.TaskContext;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class PackagingPipelineTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testBuildApplication(boolean withRuntimeBuilder, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1, withRuntimeBuilder ? Optional.of(TestRuntimeBuilder.INSTANCE) : Optional.empty());\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(app).create();\n+\n+        \/\/ Build application image in `env.appImageDir()` directory.\n+        final var builder = buildPipeline();\n+        if (app.runtimeBuilder().isEmpty()) {\n+            builder.task(BuildApplicationTaskID.RUNTIME).noaction().add();\n+        }\n+\n+        builder.create().execute(env, app);\n+\n+        assertEquals(app.appImageDirName(), env.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, app);\n+        }));\n+\n+        List<TaskID> expectedActions = new ArrayList<>();\n+        if (app.runtimeBuilder().isPresent()) {\n+            expectedActions.add(BuildApplicationTaskID.RUNTIME);\n+        }\n+        expectedActions.addAll(List.of(BuildApplicationTaskID.LAUNCHERS, BuildApplicationTaskID.CONTENT));\n+\n+        assertEquals(expectedActions, executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage;\n+        if (withRuntimeBuilder) {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT)\n+                    .file(\"runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+        } else {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT);\n+        }\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCopyApplication(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var srcApp = createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE);\n+\n+        final var srcEnv = buildEnv(workDir.resolve(\"build\")).appImageDirFor(srcApp).create();\n+\n+        \/\/ Build application image in `srcEnv.appImageDir()` directory.\n+        buildPipeline().create().execute(srcEnv, srcApp);\n+\n+        final var dstApp = createApp(TEST_LAYOUT_2, TestRuntimeBuilder.INSTANCE);\n+\n+        final var dstEnv = buildEnv(workDir.resolve(\"build-2\"))\n+                .appImageLayout(dstApp.imageLayout().resolveAt(workDir.resolve(\"a\/b\/c\")))\n+                .create();\n+\n+        \/\/ Copy application image from `srcEnv.appImageDir()` into `dstEnv.appImageDir()`\n+        \/\/ with layout transformation.\n+        \/\/ This test exercises flexibility of the packaging pipeline.\n+        final var builder = buildPipeline()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).applicationAction(cfg -> {\n+                    assertSame(dstApp, cfg.app());\n+                    assertEquals(dstEnv.appImageDir(), cfg.env().appImageLayout().rootDirectory());\n+                    assertFalse(Files.exists(dstEnv.appImageDir()));\n+                    PackagingPipeline.copyAppImage(srcEnv.appImageLayout(), cfg.env().appImageLayout(), false);\n+                }).add();\n+\n+        \/\/ Disable the default \"build application image\" actions of the tasks which\n+        \/\/ are the dependencies of `PrimaryTaskID.BUILD_APPLICATION_IMAGE` task as\n+        \/\/ their output will be overwritten in the custom action of this task.\n+        builder.taskGraphSnapshot().getAllTailsOf(PrimaryTaskID.BUILD_APPLICATION_IMAGE).forEach(taskId -> {\n+            builder.task(taskId).noaction().add();\n+        });\n+\n+        builder.create().execute(dstEnv, dstApp);\n+\n+        AppImageLayout.toPathGroup(dstEnv.appImageLayout()).paths().forEach(path -> {\n+            assertTrue(Files.exists(path));\n+        });\n+\n+        assertEquals(Path.of(\"c\"), dstEnv.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dstEnv, dstApp);\n+        }));\n+\n+        assertEquals(List.of(PrimaryTaskID.BUILD_APPLICATION_IMAGE), executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(\"q\/launchers\/my-launcher\", TestLauncher.CONTENT)\n+                .file(\"qqq\/runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(dstEnv.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCreatePackage(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(pkg).create();\n+\n+        final var builder = buildPipeline();\n+\n+        \/\/ Will create an app image in `env.appImageDir()` directory with `pkg.appImageLayout()` layout.\n+        \/\/ Will convert the created app image into a package.\n+        builder.create().execute(env, pkg, outputDir);\n+\n+        final var expected = createTestPackageFileContents(env.appImageLayout());\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"testCreatePackage:\\n---\\n%s\\n---\", actual));\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, pkg, outputDir);\n+        }));\n+\n+        assertEquals(List.of(\n+                BuildApplicationTaskID.RUNTIME,\n+                BuildApplicationTaskID.LAUNCHERS,\n+                BuildApplicationTaskID.CONTENT,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE\n+        ), executedTaskActions);\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testCreateRuntimeInstaller(boolean transformLayout, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final AppImageLayout srcLayout;\n+        if (transformLayout) {\n+            \/\/ Create an application layout such that the runtime directory doesn't\n+            \/\/ have a common parent with other directories otherwise the runtime directory\n+            \/\/ will be skipped when copying the app image layout as path groups because\n+            \/\/ the destination app image layout is of type RuntimeLayout and have only\n+            \/\/ the runtime directory.\n+            srcLayout = ApplicationLayout.build()\n+                    .launchersDirectory(\"launchers\")\n+                    .appDirectory(\"lib\")\n+                    .runtimeDirectory(\"runtime\")\n+                    .appModsDirectory(\"lib\")\n+                    .contentDirectory(\"lib\")\n+                    .desktopIntegrationDirectory(\"lib\")\n+                    .create();\n+        } else {\n+            srcLayout = RuntimeLayout.DEFAULT;\n+        }\n+\n+        \/\/ Create a runtime image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(srcLayout)\n+                .appImageDir(workDir.resolve(\"rt\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+\n+        final var pipeline = buildPackage(createApp(\n+                RuntimeLayout.DEFAULT.resolveAt(TEST_INSTALL_DIR).resetRootDirectory())).create();\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        createAndVerifyPackage(buildPipeline(), pipeline, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreateRuntimeInstaller(%s)\", transformLayout), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    private enum ExternalAppImageMode {\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant equals to `Package.appImageLayout()`.\n+        COPY_FROM_BUILD_ENV,\n+\n+        \/\/ Copy predefined app image from some directory.\n+        \/\/ Layout of the predefined app image is `Package.appImageLayout()`.\n+        COPY,\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant is NOT equal to `Package.appImageLayout()`.\n+        TRANSFORM_FROM_BUILD_ENV,\n+        ;\n+\n+        static final Set<ExternalAppImageMode> FROM_BUILD_ENV = Set.of(\n+                COPY_FROM_BUILD_ENV, TRANSFORM_FROM_BUILD_ENV);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ExternalAppImageMode.class)\n+    void testCreatePackageFromExternalAppImage(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout;\n+        final ExpectedAppImage expectedAppImage;\n+        if (ExternalAppImageMode.TRANSFORM_FROM_BUILD_ENV == mode) {\n+            appLayout = TEST_LAYOUT_2_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"q\/launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"qqq\/runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        } else {\n+            appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        }\n+\n+        final BuildEnv env;\n+        final Path predefinedAppImage;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImage = env.appImageDir();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            final var externalAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(externalAppImageLayout);\n+            TestLauncher.INSTANCE.create(externalAppImageLayout);\n+            predefinedAppImage = externalAppImageLayout.rootDirectory();\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImage)\n+                .create();\n+\n+        createAndVerifyPackage(buildPipeline(), pkg, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names={\"COPY\", \"COPY_FROM_BUILD_ENV\"})\n+    void testCreatePackageFromExternalAppImageNoCopyAction(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+\n+        final BuildEnv env;\n+        final ApplicationLayout predefinedAppImageLayout;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImageLayout = env.asApplicationLayout().orElseThrow();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            predefinedAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(predefinedAppImageLayout);\n+            TestLauncher.INSTANCE.create(predefinedAppImageLayout);\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImageLayout.rootDirectory())\n+                .create();\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+\n+        final var builder = buildPipeline().configuredTasks().filter(task -> {\n+            return CopyAppImageTaskID.COPY.equals(task.task());\n+        }).findFirst().orElseThrow().noaction().add();\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        builder.create().execute(startupParameters);\n+\n+        final var expected = createTestPackageFileContents(predefinedAppImageLayout);\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\",\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), actual));\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(predefinedAppImageLayout.unresolve().launchersDirectory().resolve(\"my-launcher\"), TestLauncher.CONTENT)\n+                .file(predefinedAppImageLayout.unresolve().runtimeDirectory().resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(pkg.predefinedAppImage().orElseThrow()));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+        assertEquals(List.of(\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE), actualExecutedTaskActions);\n+    }\n+\n+    @Test\n+    void testCreatePackageFromExternalAppImageWithoutExternalAppImageError(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var env = setupBuildEnvForExternalAppImage(workDir);\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR)).create();\n+        final var pipeline = buildPipeline().create();\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, pkg, workDir));\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_RuntimeException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new RuntimeException(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_PackagerException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new PackagerException(\"param.vendor.default\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_Exception() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new Exception(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, PackagerException.class, () -> {\n+            rethrowUnchecked(expectedException);\n+        });\n+        assertSame(expectedException, ex.getCause());\n+    }\n+\n+    @Test\n+    void testAppImageAction() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).appImageAction(ctx -> {\n+                    assertSame(app, ctx.app());\n+                    assertSame(env, ctx.env());\n+                    executed[0] = true;\n+                }).add().create().execute(env, app);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testAppImageActionWithPackage() throws PackagerException, IOException {\n+\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        final var builder = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.PACKAGE).add();\n+\n+        final var startupParameters = builder.createStartupParameters(env,  pkg,  Path.of(\"\"));\n+\n+        builder.task(PrimaryTaskID.PACKAGE).appImageAction(ctx -> {\n+            assertSame(pkg.app(), ctx.app());\n+            assertSame(startupParameters.packagingEnv(), ctx.env());\n+            executed[0] = true;\n+        }).add().create().execute(startupParameters);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testPackageActionWithApplication() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).packageAction(ctx -> {\n+                    throw new AssertionError();\n+                }).add().create();\n+\n+        \/\/ If the pipeline is building an application, it can not execute actions that take a package as an argument.\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, app));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testContextMapper(boolean allowAll) throws PackagerException, IOException {\n+\n+        var builder = PackagingPipeline.buildStandard().contextMapper(ctx -> {\n+            return new TaskContext() {\n+                @Override\n+                public boolean test(TaskID task) {\n+                    return allowAll;\n+                }\n+\n+                @Override\n+                public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+                    if (!allowAll) {\n+                        throw new AssertionError();\n+                    }\n+                    ctx.execute(taskAction);\n+                }\n+            };\n+        });\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dummyBuildEnv(), createApp(TEST_LAYOUT_1));\n+        }));\n+\n+        List<TaskID> expectedExecutedTaskActions;\n+\n+        if (allowAll) {\n+            expectedExecutedTaskActions = List.of(\n+                    BuildApplicationTaskID.RUNTIME,\n+                    BuildApplicationTaskID.LAUNCHERS,\n+                    BuildApplicationTaskID.CONTENT,\n+                    BuildApplicationTaskID.APP_IMAGE_FILE,\n+                    CopyAppImageTaskID.COPY,\n+                    PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT);\n+        } else {\n+            expectedExecutedTaskActions = List.of();\n+        }\n+\n+        assertEquals(expectedExecutedTaskActions, actualExecutedTaskActions);\n+    }\n+\n+    public static List<PackagingPipeline.TaskID> dryRun(PackagingPipeline.Builder builder,\n+            Consumer<PackagingPipeline.Builder> callback) {\n+\n+        List<PackagingPipeline.TaskID> executedTaskActions = new ArrayList<>();\n+        builder.configuredTasks().filter(PackagingPipeline.Builder.TaskBuilder::hasAction).forEach(taskBuilder -> {\n+            var taskId = taskBuilder.task();\n+            taskBuilder.action(() -> {\n+                executedTaskActions.add(taskId);\n+            }).add();\n+        });\n+\n+        callback.accept(builder);\n+\n+        return executedTaskActions;\n+    }\n+\n+    private static Exception testExceptionRethrow(Exception expectedException,\n+            Class<? extends Exception> expectedCatchExceptionType,\n+            NoArgTaskAction throwAction) throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).action(throwAction).add().create();\n+\n+        return assertThrowsExactly(expectedCatchExceptionType, () -> pipeline.execute(env,  app));\n+    }\n+\n+    private static BuildEnv setupBuildEnvForExternalAppImage(Path workDir) throws ConfigException {\n+        \/\/ Create an app image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(TEST_LAYOUT_1.resolveAt(Path.of(\"a\/b\/c\")).resetRootDirectory())\n+                .appImageDir(workDir.resolve(\"app-image\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+        TestLauncher.INSTANCE.create((ApplicationLayout)env.appImageLayout());\n+\n+        return env;\n+    }\n+\n+    private static void createAndVerifyPackage(PackagingPipeline.Builder builder, Package pkg,\n+            BuildEnv env, Path outputDir, String logMsgHeader, ExpectedAppImage expectedAppImage,\n+            TaskID... expectedExecutedTaskActions) throws PackagerException, IOException {\n+        Objects.requireNonNull(logMsgHeader);\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        assertNotSameAppImageDirs(env, startupParameters.packagingEnv());\n+\n+        \/\/ Will create an app image in `startupParameters.packagingEnv().appImageDir()` directory\n+        \/\/ with `pkg.appImageLayout()` layout using an app image (runtime image) from `env.appImageDir()` as input.\n+        \/\/ Will convert the created app image into a package.\n+        \/\/ Will not overwrite the contents of `env.appImageDir()` directory.\n+        builder.create().execute(startupParameters);\n+\n+        final var packagingAppImageDir = startupParameters.packagingEnv().appImageDir();\n+\n+        final var expected = createTestPackageFileContents(pkg.appImageLayout().resolveAt(packagingAppImageDir));\n+\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\", logMsgHeader, actual));\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(packagingAppImageDir));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+\n+        assertEquals(List.of(expectedExecutedTaskActions), actualExecutedTaskActions);\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout) {\n+        return createApp(appImageLayout, Optional.empty());\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, RuntimeBuilder runtimeBuilder) {\n+        return createApp(appImageLayout, Optional.of(runtimeBuilder));\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, Optional<RuntimeBuilder> runtimeBuilder) {\n+        Objects.requireNonNull(appImageLayout);\n+        Objects.requireNonNull(runtimeBuilder);\n+        if (appImageLayout.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new Application.Stub(\n+                \"foo\",\n+                \"My app\",\n+                \"1.0\",\n+                \"Acme\",\n+                \"copyright\",\n+                Optional.empty(),\n+                List.of(),\n+                appImageLayout,\n+                runtimeBuilder,\n+                List.of(),\n+                Map.of());\n+    }\n+\n+\n+    private static final class PackageBuilder {\n+        PackageBuilder(Application app) {\n+            this.app = Objects.requireNonNull(app);\n+        }\n+\n+        Package create() {\n+            return new Package.Stub(\n+                    app,\n+                    new PackageType() {},\n+                    \"the-package\",\n+                    \"My package\",\n+                    \"1.0\",\n+                    Optional.empty(),\n+                    Optional.empty(),\n+                    Optional.ofNullable(predefinedAppImage),\n+                    null,\n+                    TEST_INSTALL_DIR);\n+        }\n+\n+        PackageBuilder predefinedAppImage(Path v) {\n+            predefinedAppImage = v;\n+            return this;\n+        }\n+\n+        private Path predefinedAppImage;\n+        private final Application app;\n+    }\n+\n+\n+    private static PackageBuilder buildPackage(Application app) {\n+        return new PackageBuilder(app);\n+    }\n+\n+    private static BuildEnvBuilder buildEnv(Path rootDir) {\n+        return new BuildEnvBuilder(rootDir);\n+    }\n+\n+    private static BuildEnv dummyBuildEnv() {\n+        return BuildEnv.create(Path.of(\"foo\"), Optional.empty(), false, PackagingPipeline.class, RuntimeLayout.DEFAULT);\n+    }\n+\n+    private static PackagingPipeline.Builder buildPipeline() {\n+        return PackagingPipeline.buildStandard()\n+                \/\/ Disable building the app image file (.jpackage.xml) as we don't have launchers in the test app.\n+                .task(BuildApplicationTaskID.APP_IMAGE_FILE).noaction().add()\n+                .task(BuildApplicationTaskID.LAUNCHERS).applicationAction(cfg -> {\n+                    TestLauncher.INSTANCE.create(cfg.resolvedLayout());\n+                }).add()\n+                .task(PrimaryTaskID.PACKAGE).packageAction(cfg -> {\n+                    var str = createTestPackageFileContents(cfg.resolvedLayout());\n+                    var packageFile = cfg.outputDir().resolve(cfg.pkg().packageFileNameWithSuffix());\n+                    Files.createDirectories(packageFile.getParent());\n+                    Files.writeString(packageFile, str);\n+                }).add();\n+    }\n+\n+    private static String createTestPackageFileContents(AppImageLayout pkgLayout) throws IOException {\n+        return ExpectedAppImage.load(pkgLayout.rootDirectory()).toString();\n+    }\n+\n+    private static void assertNotSameAppImageDirs(BuildEnv a, BuildEnv b) {\n+        assertNotEquals(a.appImageDir(), b.appImageDir());\n+        assertEquals(a.buildRoot(), b.buildRoot());\n+        assertEquals(a.configDir(), b.configDir());\n+        assertEquals(a.resourceDir(), b.resourceDir());\n+    }\n+\n+\n+    private static final class TestRuntimeBuilder implements RuntimeBuilder {\n+        @Override\n+        public void create(AppImageLayout appImageLayout) {\n+            assertTrue(appImageLayout.isResolved());\n+            try {\n+                Files.createDirectories(appImageLayout.runtimeDirectory());\n+                Files.writeString(runtimeFile(appImageLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path runtimeFile(AppImageLayout appImageLayout) {\n+            return appImageLayout.runtimeDirectory().resolve(\"my-runtime\");\n+        }\n+\n+        static final String CONTENT = \"this is the runtime\";\n+\n+        static final TestRuntimeBuilder INSTANCE = new TestRuntimeBuilder();\n+    }\n+\n+\n+    private static final class TestLauncher {\n+        public void create(ApplicationLayout appLayout) {\n+            assertTrue(appLayout.isResolved());\n+            try {\n+                Files.createDirectories(appLayout.launchersDirectory());\n+                Files.writeString(launcherFile(appLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path launcherFile(ApplicationLayout appLayout) {\n+            return appLayout.launchersDirectory().resolve(\"my-launcher\");\n+        }\n+\n+        static final String CONTENT = \"this is the launcher\";\n+\n+        static final TestLauncher INSTANCE = new TestLauncher();\n+    }\n+\n+\n+    private static final class ExpectedAppImage {\n+\n+        static ExpectedAppImage build() {\n+            return new ExpectedAppImage(new HashSet<>());\n+        }\n+\n+        static ExpectedAppImage load(Path appImageRoot) throws IOException {\n+            try (var walk = Files.walk(appImageRoot)) {\n+                return new ExpectedAppImage(walk.sorted().map(path -> {\n+                    var relativePath = appImageRoot.relativize(path);\n+                    if (Files.isDirectory(path)) {\n+                        return new Directory(relativePath);\n+                    } else {\n+                        return new File(relativePath, toSupplier(() -> Files.readString(path)).get());\n+                    }\n+                }).collect(Collectors.toSet()));\n+            }\n+        }\n+\n+        ExpectedAppImage file(Path path, String content) {\n+            return add(new File(path, content));\n+        }\n+\n+        ExpectedAppImage file(String path, String content) {\n+            return file(Path.of(path), content);\n+        }\n+\n+        ExpectedAppImage dir(Path path) {\n+            return add(new Directory(path));\n+        }\n+\n+        ExpectedAppImage dir(String path) {\n+            return dir(Path.of(path));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return items.stream().map(AppImageItem::toString).sorted().collect(Collectors.joining(\"\\n\"));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(items);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if ((obj == null) || (getClass() != obj.getClass())) {\n+                return false;\n+            }\n+            ExpectedAppImage other = (ExpectedAppImage) obj;\n+            return Objects.equals(items, other.items);\n+        }\n+\n+        private ExpectedAppImage(Set<AppImageItem> items) {\n+            this.items = Objects.requireNonNull(items);\n+        }\n+\n+        private ExpectedAppImage add(AppImageItem v) {\n+            var path = v.path();\n+            if (path.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            items.add(v);\n+            while (path.getNameCount() > 1) {\n+                items.add(new Directory(path = path.getParent()));\n+            }\n+            return this;\n+        }\n+\n+        private interface AppImageItem {\n+            Path path();\n+        }\n+\n+        private record File(Path path, String content) implements AppImageItem {\n+\n+            File {\n+                Objects.requireNonNull(path);\n+                Objects.requireNonNull(content);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return String.format(\"%s[%s]\", path, content);\n+            }\n+        }\n+\n+        private record Directory(Path path) implements AppImageItem {\n+\n+            Directory {\n+                Objects.requireNonNull(path);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return path.toString();\n+            }\n+        }\n+\n+        private final Set<AppImageItem> items;\n+    }\n+\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1 = ApplicationLayout.build()\n+            .launchersDirectory(\"launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2 = ApplicationLayout.build()\n+            .launchersDirectory(\"q\/launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"qqq\/runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final Path TEST_INSTALL_DIR = Path.of(\"Acme\/My app\");\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_1.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_2.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":872,"deletions":0,"binary":false,"changes":872,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -27,1 +28,1 @@\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n@@ -32,0 +33,1 @@\n+import jdk.jpackage.internal.util.PathGroup;\n@@ -51,1 +53,1 @@\n-        final var pathGroup = AppImageLayout.toPathGroup(layout);\n+        final var pathGroup = toPathGroup(layout);\n@@ -59,1 +61,28 @@\n-        final var dir = Path.of(\"foo\/bar\");\n+        testResolveAt(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        testResolveAtRepeat(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        testUnresolve(new AppImageLayout.Stub(Path.of(\"runtime\")));\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        testEmptyRootDirectory(new AppImageLayout.Stub(Path.of(\"rt\")));\n+    }\n+\n+    public static void testResolveAt(AppImageLayout testee) {\n+\n+        var dir = Path.of(\"foo\/bar\");\n+\n+        assertLayout(testee.resolveAt(dir), true, testee, dir);\n+    }\n+\n+    public static void testResolveAtRepeat(AppImageLayout testee) {\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"b\/c\")).resolveAt(Path.of(\"a\"));\n@@ -61,1 +90,20 @@\n-        final var layout = new AppImageLayout.Stub(Path.of(\"\"), Path.of(\"runtime\"));\n+        assertLayout(resolvedLayout, true, testee, Path.of(\"a\/b\/c\"));\n+    }\n+\n+    public static void testUnresolve(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"foo\/bar\"));\n+        var layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        resolvedLayout = testee.resolveAt(Path.of(\"\").toAbsolutePath());\n+        layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        assertSame(testee, testee.unresolve());\n+    }\n@@ -63,1 +111,4 @@\n-        final var resolvedLayout = layout.resolveAt(dir);\n+    public static void testEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -65,1 +116,1 @@\n-        assertNotSame(layout, resolvedLayout);\n+        assertEmptyRootDirectory(testee);\n@@ -67,2 +118,25 @@\n-        assertEquals(dir.resolve(layout.rootDirectory()), resolvedLayout.rootDirectory());\n-        assertEquals(dir.resolve(layout.runtimeDirectory()), resolvedLayout.runtimeDirectory());\n+        final var resolved = testee.resolveAt(Path.of(\"t\"));\n+\n+        assertEmptyRootDirectory(resolved);\n+    }\n+\n+    private static void assertEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            var newLayout = testee.resetRootDirectory();\n+            assertLayout(newLayout, false, Path.of(\"\"), toPathGroup(testee));\n+        } else {\n+            assertSame(testee, testee.resetRootDirectory());\n+        }\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            AppImageLayout base, Path baseResolveAt) {\n+        assertLayout(actual, expectedResolved, baseResolveAt.resolve(base.rootDirectory()),\n+                toPathGroup(base).resolveAt(baseResolveAt));\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            Path expectedRootDir, PathGroup expectedPaths) {\n+        assertEquals(expectedResolved, actual.isResolved());\n+        assertEquals(expectedRootDir, actual.rootDirectory());\n+        assertEquals(expectedPaths, toPathGroup(actual));\n@@ -70,0 +144,1 @@\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java","additions":83,"deletions":8,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n@@ -31,2 +34,0 @@\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -39,1 +40,31 @@\n-    public void test(boolean move, Path tempDir) throws IOException {\n+    @Test\n+    public void testMove(@TempDir Path tempDir) throws IOException {\n+        test(true, tempDir);\n+    }\n+\n+    @Test\n+    public void testCopy(@TempDir Path tempDir) throws IOException {\n+        test(false, tempDir);\n+    }\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    private static void test(boolean move, Path tempDir) throws IOException {\n@@ -58,8 +89,1 @@\n-        final var layout = ApplicationLayout.build()\n-                .launchersDirectory(\"bin\")\n-                .appDirectory(\"lib\/app\")\n-                .runtimeDirectory(\"runtime\")\n-                .appModsDirectory(\"mods\")\n-                .contentDirectory(\"content\")\n-                .desktopIntegrationDirectory(\"lib\/apps\")\n-                .create();\n+        final var layout = createLayout();\n@@ -103,8 +127,9 @@\n-    @Test\n-    public void testMove(@TempDir Path tempDir) throws IOException {\n-        test(true, tempDir);\n-    }\n-\n-    @Test\n-    public void testCopy(@TempDir Path tempDir) throws IOException {\n-        test(false, tempDir);\n+    public static ApplicationLayout createLayout() {\n+        return ApplicationLayout.build()\n+                .launchersDirectory(\"bin\")\n+                .appDirectory(\"lib\/app\")\n+                .runtimeDirectory(\"runtime\")\n+                .appModsDirectory(\"mods\")\n+                .contentDirectory(\"content\")\n+                .desktopIntegrationDirectory(\"lib\/apps\")\n+                .create();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java","additions":44,"deletions":19,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -68,0 +68,8 @@\n+    @Test\n+    public void equals() {\n+        assertEquals(new PathGroup(Map.of()), new PathGroup(Map.of()));\n+        assertEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"rab\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"Foo\", Path.of(\"bar\"))));\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PathGroupTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,4 +43,6 @@\n-    static {\n-        if (System.getProperty(\"test.src\") == null) {\n-            \/\/ Was called by somebody else but not by jtreg\n-            System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+    public static class TestSrcInitializer {\n+        static {\n+            if (System.getProperty(\"test.src\") == null) {\n+                \/\/ Was called by somebody else but not by jtreg\n+                System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+            }\n@@ -87,0 +89,4 @@\n+    static {\n+        new TestSrcInitializer();\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitAdapter.java","additions":10,"deletions":4,"binary":false,"changes":14,"previous_filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JUnitAdapter.java","status":"renamed"},{"patch":"@@ -27,1 +27,2 @@\n- * @compile\/module=jdk.jpackage jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n","filename":"test\/jdk\/tools\/jpackage\/junit\/windows\/junit.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}