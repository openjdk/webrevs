{"files":[{"patch":"@@ -129,20 +129,0 @@\n-bool ParallelCompactData::RegionData::is_clear() {\n-  return (_destination == nullptr) &&\n-         (_source_region == 0) &&\n-         (_partial_obj_addr == nullptr) &&\n-         (_partial_obj_size == 0) &&\n-         (_dc_and_los == 0) &&\n-         (_shadow_state == 0);\n-}\n-\n-#ifdef ASSERT\n-void ParallelCompactData::RegionData::verify_clear() {\n-  assert(_destination == nullptr, \"inv\");\n-  assert(_source_region == 0, \"inv\");\n-  assert(_partial_obj_addr == nullptr, \"inv\");\n-  assert(_partial_obj_size == 0, \"inv\");\n-  assert(_dc_and_los == 0, \"inv\");\n-  assert(_shadow_state == 0, \"inv\");\n-}\n-#endif\n-\n@@ -154,7 +134,6 @@\n-void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words) {\n-  assert(split_region_idx != 0, \"precondition\");\n-\n-  \/\/ Obj denoted by split_point will be deferred to the next space.\n-  assert(split_point != nullptr, \"precondition\");\n-\n-  const ParallelCompactData& sd = PSParallelCompact::summary_data();\n+void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n+                       HeapWord* destination)\n+{\n+  assert(src_region_idx != 0, \"invalid src_region_idx\");\n+  assert(partial_obj_size != 0, \"invalid partial_obj_size argument\");\n+  assert(destination != nullptr, \"invalid destination argument\");\n@@ -162,2 +141,3 @@\n-  PSParallelCompact::RegionData* split_region_ptr = sd.region(split_region_idx);\n-  assert(preceding_live_words < split_region_ptr->data_size(), \"inv\");\n+  _src_region_idx = src_region_idx;\n+  _partial_obj_size = partial_obj_size;\n+  _destination = destination;\n@@ -165,2 +145,3 @@\n-  HeapWord* preceding_destination = split_region_ptr->destination();\n-  assert(preceding_destination != nullptr, \"inv\");\n+  \/\/ These fields may not be updated below, so make sure they're clear.\n+  assert(_dest_region_addr == nullptr, \"should have been cleared\");\n+  assert(_first_src_addr == nullptr, \"should have been cleared\");\n@@ -168,9 +149,14 @@\n-  \/\/ How many regions does the preceding part occupy\n-  uint preceding_destination_count;\n-  if (preceding_live_words == 0) {\n-    preceding_destination_count = 0;\n-  } else {\n-    if (preceding_destination + preceding_live_words > sd.region_align_up(preceding_destination)) {\n-      preceding_destination_count = 2;\n-    } else {\n-      preceding_destination_count = 1;\n+  \/\/ Determine the number of destination regions for the partial object.\n+  HeapWord* const last_word = destination + partial_obj_size - 1;\n+  const ParallelCompactData& sd = PSParallelCompact::summary_data();\n+  HeapWord* const beg_region_addr = sd.region_align_down(destination);\n+  HeapWord* const end_region_addr = sd.region_align_down(last_word);\n+\n+  if (beg_region_addr == end_region_addr) {\n+    \/\/ One destination region.\n+    _destination_count = 1;\n+    if (end_region_addr == destination) {\n+      \/\/ The destination falls on a region boundary, thus the first word of the\n+      \/\/ partial object will be the first word copied to the destination region.\n+      _dest_region_addr = end_region_addr;\n+      _first_src_addr = sd.region_to_addr(src_region_idx);\n@@ -178,0 +164,9 @@\n+  } else {\n+    \/\/ Two destination regions.  When copied, the partial object will cross a\n+    \/\/ destination region boundary, so a word somewhere within the partial\n+    \/\/ object will be the first word copied to the second destination region.\n+    _destination_count = 2;\n+    _dest_region_addr = end_region_addr;\n+    const size_t ofs = pointer_delta(end_region_addr, destination);\n+    assert(ofs < _partial_obj_size, \"sanity\");\n+    _first_src_addr = sd.region_to_addr(src_region_idx) + ofs;\n@@ -179,6 +174,0 @@\n-\n-  _split_region_idx = split_region_idx;\n-  _split_point = split_point;\n-  _preceding_live_words = preceding_live_words;\n-  _preceding_destination = preceding_destination;\n-  _preceding_destination_count = preceding_destination_count;\n@@ -189,5 +178,6 @@\n-  _split_region_idx = 0;\n-  _split_point = nullptr;\n-  _preceding_live_words = 0;\n-  _preceding_destination = nullptr;\n-  _preceding_destination_count = 0;\n+  _src_region_idx = 0;\n+  _partial_obj_size = 0;\n+  _destination = nullptr;\n+  _destination_count = 0;\n+  _dest_region_addr = nullptr;\n+  _first_src_addr = nullptr;\n@@ -200,5 +190,6 @@\n-  assert(_split_region_idx == 0, \"not clear\");\n-  assert(_split_point == nullptr, \"not clear\");\n-  assert(_preceding_live_words == 0, \"not clear\");\n-  assert(_preceding_destination == nullptr, \"not clear\");\n-  assert(_preceding_destination_count == 0, \"not clear\");\n+  assert(_src_region_idx == 0, \"not clear\");\n+  assert(_partial_obj_size == 0, \"not clear\");\n+  assert(_destination == nullptr, \"not clear\");\n+  assert(_destination_count == 0, \"not clear\");\n+  assert(_dest_region_addr == nullptr, \"not clear\");\n+  assert(_first_src_addr == nullptr, \"not clear\");\n@@ -307,8 +298,23 @@\n-\/\/ The total live words on src_region would overflow the target space, so find\n-\/\/ the overflowing object and record the split point. The invariant is that an\n-\/\/ obj should not cross space boundary.\n-HeapWord* ParallelCompactData::summarize_split_space(size_t src_region,\n-                                                     SplitInfo& split_info,\n-                                                     HeapWord* const destination,\n-                                                     HeapWord* const target_end,\n-                                                     HeapWord** target_next) {\n+\/\/ Find the point at which a space can be split and, if necessary, record the\n+\/\/ split point.\n+\/\/\n+\/\/ If the current src region (which overflowed the destination space) doesn't\n+\/\/ have a partial object, the split point is at the beginning of the current src\n+\/\/ region (an \"easy\" split, no extra bookkeeping required).\n+\/\/\n+\/\/ If the current src region has a partial object, the split point is in the\n+\/\/ region where that partial object starts (call it the split_region).  If\n+\/\/ split_region has a partial object, then the split point is just after that\n+\/\/ partial object (a \"hard\" split where we have to record the split data and\n+\/\/ zero the partial_obj_size field).  With a \"hard\" split, we know that the\n+\/\/ partial_obj ends within split_region because the partial object that caused\n+\/\/ the overflow starts in split_region.  If split_region doesn't have a partial\n+\/\/ obj, then the split is at the beginning of split_region (another \"easy\"\n+\/\/ split).\n+HeapWord*\n+ParallelCompactData::summarize_split_space(size_t src_region,\n+                                           SplitInfo& split_info,\n+                                           HeapWord* destination,\n+                                           HeapWord* target_end,\n+                                           HeapWord** target_next)\n+{\n@@ -320,0 +326,2 @@\n+  size_t split_region = src_region;\n+  HeapWord* split_destination = destination;\n@@ -323,4 +331,3 @@\n-    assert(partial_obj_size > 0, \"inv\");\n-    \/\/ The overflowing obj is from a previous region.\n-    \/\/\n-    \/\/ source-regions:\n+    \/\/ The split point is just after the partial object (if any) in the\n+    \/\/ src_region that contains the start of the object that overflowed the\n+    \/\/ destination space.\n@@ -328,5 +335,8 @@\n-    \/\/ ***************\n-    \/\/ |     A|AA    |\n-    \/\/ ***************\n-    \/\/       ^\n-    \/\/       | split-point\n+    \/\/ Find the start of the \"overflow\" object and set split_region to the\n+    \/\/ region containing it.\n+    HeapWord* const overflow_obj = _region_data[src_region].partial_obj_addr();\n+    split_region = addr_to_region_idx(overflow_obj);\n+\n+    \/\/ Clear the source_region field of all destination regions whose first word\n+    \/\/ came from data after the split point (a non-null source_region field\n+    \/\/ implies a region must be filled).\n@@ -334,1 +344,4 @@\n-    \/\/ dest-region:\n+    \/\/ An alternative to the simple loop below:  clear during post_compact(),\n+    \/\/ which uses memcpy instead of individual stores, and is easy to\n+    \/\/ parallelize.  (The downside is that it clears the entire RegionData\n+    \/\/ object as opposed to just one field.)\n@@ -336,7 +349,2 @@\n-    \/\/ ********\n-    \/\/ |~~~~A |\n-    \/\/ ********\n-    \/\/       ^^\n-    \/\/       || target-space-end\n-    \/\/       |\n-    \/\/       | destination\n+    \/\/ post_compact() would have to clear the summary data up to the highest\n+    \/\/ address that was written during the summary phase, which would be\n@@ -344,1 +352,1 @@\n-    \/\/ AAA would overflow target-space.\n+    \/\/         max(top, max(new_top, clear_top))\n@@ -346,2 +354,7 @@\n-    HeapWord* overflowing_obj = _region_data[src_region].partial_obj_addr();\n-    size_t split_region = addr_to_region_idx(overflowing_obj);\n+    \/\/ where clear_top is a new field in SpaceInfo.  Would have to set clear_top\n+    \/\/ to target_end.\n+    const RegionData* const sr = region(split_region);\n+    const size_t beg_idx =\n+      addr_to_region_idx(region_align_up(sr->destination() +\n+                                         sr->partial_obj_size()));\n+    const size_t end_idx = addr_to_region_idx(target_end);\n@@ -349,25 +362,3 @@\n-    \/\/ The number of live words before the overflowing object on this split region\n-    size_t preceding_live_words;\n-    if (is_region_aligned(overflowing_obj)) {\n-      preceding_live_words = 0;\n-    } else {\n-      \/\/ Words accounted by the overflowing object on the split region\n-      size_t overflowing_size = pointer_delta(region_align_up(overflowing_obj), overflowing_obj);\n-      preceding_live_words = region(split_region)->data_size() - overflowing_size;\n-    }\n-\n-    split_info.record(split_region, overflowing_obj, preceding_live_words);\n-\n-    HeapWord* src_region_start = region_to_addr(src_region);\n-    HeapWord* new_top = destination - pointer_delta(src_region_start, overflowing_obj);\n-\n-    \/\/ If the overflowing obj was relocated to its original destination,\n-    \/\/ those destination regions would have their source_region set. Now that\n-    \/\/ this overflowing obj is relocated somewhere else, reset the\n-    \/\/ source_region.\n-    {\n-      size_t range_start = addr_to_region_idx(region_align_up(new_top));\n-      size_t range_end = addr_to_region_idx(region_align_up(destination));\n-      for (size_t i = range_start; i < range_end; ++i) {\n-        region(i)->set_source_region(0);\n-      }\n+    log_develop_trace(gc, compaction)(\"split:  clearing source_region field in [\" SIZE_FORMAT \", \" SIZE_FORMAT \")\", beg_idx, end_idx);\n+    for (size_t idx = beg_idx; idx < end_idx; ++idx) {\n+      _region_data[idx].set_source_region(0);\n@@ -376,2 +367,4 @@\n-    \/\/ Update new top of target space\n-    *target_next = new_top;\n+    \/\/ Set split_destination and partial_obj_size to reflect the split region.\n+    split_destination = sr->destination();\n+    partial_obj_size = sr->partial_obj_size();\n+  }\n@@ -379,1 +372,4 @@\n-    return overflowing_obj;\n+  \/\/ The split is recorded only if a partial object extends onto the region.\n+  if (partial_obj_size != 0) {\n+    _region_data[split_region].set_partial_obj_size(0);\n+    split_info.record(split_region, partial_obj_size, split_destination);\n@@ -382,5 +378,3 @@\n-  \/\/ Obj-iteration to locate the overflowing obj\n-  HeapWord* region_start = region_to_addr(src_region);\n-  HeapWord* region_end = region_start + RegionSize;\n-  HeapWord* cur_addr = region_start + partial_obj_size;\n-  size_t live_words = partial_obj_size;\n+  \/\/ Setup the continuation addresses.\n+  *target_next = split_destination + partial_obj_size;\n+  HeapWord* const source_next = region_to_addr(split_region) + partial_obj_size;\n@@ -388,5 +382,8 @@\n-  while (true) {\n-    assert(cur_addr < region_end, \"inv\");\n-    cur_addr = PSParallelCompact::mark_bitmap()->find_obj_beg(cur_addr, region_end);\n-    \/\/ There must be an overflowing obj in this region\n-    assert(cur_addr < region_end, \"inv\");\n+  if (log_develop_is_enabled(Trace, gc, compaction)) {\n+    const char * split_type = partial_obj_size == 0 ? \"easy\" : \"hard\";\n+    log_develop_trace(gc, compaction)(\"%s split:  src=\" PTR_FORMAT \" src_c=\" SIZE_FORMAT \" pos=\" SIZE_FORMAT,\n+                                      split_type, p2i(source_next), split_region, partial_obj_size);\n+    log_develop_trace(gc, compaction)(\"%s split:  dst=\" PTR_FORMAT \" dst_c=\" SIZE_FORMAT \" tn=\" PTR_FORMAT,\n+                                      split_type, p2i(split_destination),\n+                                      addr_to_region_idx(split_destination),\n+                                      p2i(*target_next));\n@@ -394,7 +391,7 @@\n-    oop obj = cast_to_oop(cur_addr);\n-    size_t obj_size = obj->size();\n-    if (destination + live_words + obj_size > target_end) {\n-      \/\/ Found the overflowing obj\n-      split_info.record(src_region, cur_addr, live_words);\n-      *target_next = destination + live_words;\n-      return cur_addr;\n+    if (partial_obj_size != 0) {\n+      HeapWord* const po_beg = split_info.destination();\n+      HeapWord* const po_end = po_beg + split_info.partial_obj_size();\n+      log_develop_trace(gc, compaction)(\"%s split:  po_beg=\" PTR_FORMAT \" \" SIZE_FORMAT \" po_end=\" PTR_FORMAT \" \" SIZE_FORMAT,\n+                                        split_type,\n+                                        p2i(po_beg), addr_to_region_idx(po_beg),\n+                                        p2i(po_end), addr_to_region_idx(po_end));\n@@ -402,3 +399,0 @@\n-\n-    live_words += obj_size;\n-    cur_addr += obj_size;\n@@ -406,0 +400,2 @@\n+\n+  return source_next;\n@@ -457,13 +453,2 @@\n-  for (\/* empty *\/; cur_region < end_region; cur_region++) {\n-    size_t words = _region_data[cur_region].data_size();\n-\n-    \/\/ Skip empty ones\n-    if (words == 0) {\n-      continue;\n-    }\n-\n-    if (split_info.is_split(cur_region)) {\n-      assert(words > split_info.preceding_live_words(), \"inv\");\n-      words -= split_info.preceding_live_words();\n-    }\n-\n+  while (cur_region < end_region) {\n+    \/\/ The destination must be set even if the region has no data.\n@@ -472,9 +457,11 @@\n-    \/\/ If cur_region does not fit entirely into the target space, find a point\n-    \/\/ at which the source space can be 'split' so that part is copied to the\n-    \/\/ target space and the rest is copied elsewhere.\n-    if (dest_addr + words > target_end) {\n-      assert(source_next != nullptr, \"source_next is null when splitting\");\n-      *source_next = summarize_split_space(cur_region, split_info, dest_addr,\n-                                           target_end, target_next);\n-      return false;\n-    }\n+    size_t words = _region_data[cur_region].data_size();\n+    if (words > 0) {\n+      \/\/ If cur_region does not fit entirely into the target space, find a point\n+      \/\/ at which the source space can be 'split' so that part is copied to the\n+      \/\/ target space and the rest is copied elsewhere.\n+      if (dest_addr + words > target_end) {\n+        assert(source_next != nullptr, \"source_next is null when splitting\");\n+        *source_next = summarize_split_space(cur_region, split_info, dest_addr,\n+                                             target_end, target_next);\n+        return false;\n+      }\n@@ -482,3 +469,22 @@\n-    uint destination_count = split_info.is_split(cur_region)\n-                             ? split_info.preceding_destination_count()\n-                             : 0;\n+      \/\/ Compute the destination_count for cur_region, and if necessary, update\n+      \/\/ source_region for a destination region.  The source_region field is\n+      \/\/ updated if cur_region is the first (left-most) region to be copied to a\n+      \/\/ destination region.\n+      \/\/\n+      \/\/ The destination_count calculation is a bit subtle.  A region that has\n+      \/\/ data that compacts into itself does not count itself as a destination.\n+      \/\/ This maintains the invariant that a zero count means the region is\n+      \/\/ available and can be claimed and then filled.\n+      uint destination_count = 0;\n+      if (split_info.is_split(cur_region)) {\n+        \/\/ The current region has been split:  the partial object will be copied\n+        \/\/ to one destination space and the remaining data will be copied to\n+        \/\/ another destination space.  Adjust the initial destination_count and,\n+        \/\/ if necessary, set the source_region field if the partial object will\n+        \/\/ cross a destination region boundary.\n+        destination_count = split_info.destination_count();\n+        if (destination_count == 2) {\n+          size_t dest_idx = addr_to_region_idx(split_info.dest_region_addr());\n+          _region_data[dest_idx].set_source_region(cur_region);\n+        }\n+      }\n@@ -486,3 +492,19 @@\n-    HeapWord* const last_addr = dest_addr + words - 1;\n-    const size_t dest_region_1 = addr_to_region_idx(dest_addr);\n-    const size_t dest_region_2 = addr_to_region_idx(last_addr);\n+      HeapWord* const last_addr = dest_addr + words - 1;\n+      const size_t dest_region_1 = addr_to_region_idx(dest_addr);\n+      const size_t dest_region_2 = addr_to_region_idx(last_addr);\n+\n+      \/\/ Initially assume that the destination regions will be the same and\n+      \/\/ adjust the value below if necessary.  Under this assumption, if\n+      \/\/ cur_region == dest_region_2, then cur_region will be compacted\n+      \/\/ completely into itself.\n+      destination_count += cur_region == dest_region_2 ? 0 : 1;\n+      if (dest_region_1 != dest_region_2) {\n+        \/\/ Destination regions differ; adjust destination_count.\n+        destination_count += 1;\n+        \/\/ Data from cur_region will be copied to the start of dest_region_2.\n+        _region_data[dest_region_2].set_source_region(cur_region);\n+      } else if (is_region_aligned(dest_addr)) {\n+        \/\/ Data from cur_region will be copied to the start of the destination\n+        \/\/ region.\n+        _region_data[dest_region_1].set_source_region(cur_region);\n+      }\n@@ -490,14 +512,2 @@\n-    \/\/ Initially assume that the destination regions will be the same and\n-    \/\/ adjust the value below if necessary.  Under this assumption, if\n-    \/\/ cur_region == dest_region_2, then cur_region will be compacted\n-    \/\/ completely into itself.\n-    destination_count += cur_region == dest_region_2 ? 0 : 1;\n-    if (dest_region_1 != dest_region_2) {\n-      \/\/ Destination regions differ; adjust destination_count.\n-      destination_count += 1;\n-      \/\/ Data from cur_region will be copied to the start of dest_region_2.\n-      _region_data[dest_region_2].set_source_region(cur_region);\n-    } else if (is_region_aligned(dest_addr)) {\n-      \/\/ Data from cur_region will be copied to the start of the destination\n-      \/\/ region.\n-      _region_data[dest_region_1].set_source_region(cur_region);\n+      _region_data[cur_region].set_destination_count(destination_count);\n+      dest_addr += words;\n@@ -506,2 +516,1 @@\n-    _region_data[cur_region].set_destination_count(destination_count);\n-    dest_addr += words;\n+    ++cur_region;\n@@ -515,6 +524,6 @@\n-void ParallelCompactData::verify_clear() {\n-  for (uint cur_idx = 0; cur_idx < region_count(); ++cur_idx) {\n-    if (!region(cur_idx)->is_clear()) {\n-      log_warning(gc)(\"Uncleared Region: %u\", cur_idx);\n-      region(cur_idx)->verify_clear();\n-    }\n+void ParallelCompactData::verify_clear()\n+{\n+  const size_t* const beg = (const size_t*) _region_vspace->committed_low_addr();\n+  const size_t* const end = (const size_t*) _region_vspace->committed_high_addr();\n+  for (const size_t* p = beg; p < end; ++p) {\n+    assert(*p == 0, \"not zero\");\n@@ -687,7 +696,0 @@\n-#ifdef ASSERT\n-  {\n-    mark_bitmap()->verify_clear();\n-    summary_data().verify_clear();\n-  }\n-#endif\n-\n@@ -880,4 +882,4 @@\n-    HeapWord* dense_prefix_end = maximum_compaction\n-                                 ? full_region_prefix_end\n-                                 : compute_dense_prefix_for_old_space(old_space,\n-                                                                      full_region_prefix_end);\n+    HeapWord* dense_prefix_end =\n+      maximum_compaction ? full_region_prefix_end\n+                         : compute_dense_prefix_for_old_space(old_space,\n+                                                              full_region_prefix_end);\n@@ -891,2 +893,0 @@\n-\n-    \/\/ Compacting objs inn [dense_prefix_end, old_space->top())\n@@ -1552,24 +1552,0 @@\n-    static void forward_objs_in_range(ParCompactionManager* cm,\n-                                      HeapWord* start,\n-                                      HeapWord* end,\n-                                      HeapWord* destination) {\n-      HeapWord* cur_addr = start;\n-      HeapWord* new_addr = destination;\n-\n-      while (cur_addr < end) {\n-        cur_addr = mark_bitmap()->find_obj_beg(cur_addr, end);\n-        if (cur_addr >= end) {\n-          return;\n-        }\n-        assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n-        oop obj = cast_to_oop(cur_addr);\n-        if (new_addr != cur_addr) {\n-          cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n-          obj->forward_to(cast_to_oop(new_addr));\n-        }\n-        size_t obj_size = obj->size();\n-        new_addr += obj_size;\n-        cur_addr += obj_size;\n-      }\n-    }\n-\n@@ -1587,2 +1563,0 @@\n-        const SplitInfo& split_info = _space_info[SpaceId(id)].split_info();\n-\n@@ -1608,13 +1582,18 @@\n-\n-          if (split_info.is_split(cur_region)) {\n-            \/\/ Part 1: will be relocated to space-1\n-            HeapWord* preceding_destination = split_info.preceding_destination();\n-            HeapWord* split_point = split_info.split_point();\n-            forward_objs_in_range(cm, region_start + live_words, split_point, preceding_destination + live_words);\n-\n-            \/\/ Part 2: will be relocated to space-2\n-            HeapWord* destination = region_ptr->destination();\n-            forward_objs_in_range(cm, split_point, region_end, destination);\n-          } else {\n-            HeapWord* destination = region_ptr->destination();\n-            forward_objs_in_range(cm, region_start + live_words, region_end, destination + live_words);\n+          HeapWord* cur_addr = region_start + live_words;\n+\n+          HeapWord* destination = region_ptr->destination();\n+          while (cur_addr < region_end) {\n+            cur_addr = mark_bitmap()->find_obj_beg(cur_addr, region_end);\n+            if (cur_addr >= region_end) {\n+              break;\n+            }\n+            assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n+            HeapWord* new_addr = destination + live_words;\n+            oop obj = cast_to_oop(cur_addr);\n+            if (new_addr != cur_addr) {\n+              cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+              obj->forward_to(cast_to_oop(new_addr));\n+            }\n+            size_t obj_size = obj->size();\n+            live_words += obj_size;\n+            cur_addr += obj_size;\n@@ -1652,1 +1631,0 @@\n-      assert(bump_ptr <= _space_info[bump_ptr_space].new_top(), \"inv\");\n@@ -1659,3 +1637,1 @@\n-      if (cur_addr == bump_ptr) {\n-        assert(!obj->is_forwarded(), \"inv\");\n-      } else {\n+      if (cur_addr != bump_ptr) {\n@@ -1971,3 +1947,6 @@\n-\/\/ next live word. Callers must also ensure that there are enough live words in\n-\/\/ the range [beg, end) to skip.\n-HeapWord* PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)\n+\/\/ next live word.  Unless marked, the word corresponding to beg is assumed to\n+\/\/ be dead.  Callers must either ensure beg does not correspond to the middle of\n+\/\/ an object, or account for those live words in some other way.  Callers must\n+\/\/ also ensure that there are enough live words in the range [beg, end) to skip.\n+HeapWord*\n+PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)\n@@ -1975,0 +1954,2 @@\n+  assert(count > 0, \"sanity\");\n+\n@@ -1990,39 +1971,0 @@\n-\/\/ On filling a destination region (dest-region), we need to know the location\n-\/\/ of the word that will be at the start of the dest-region after compaction.\n-\/\/ A dest-region can have one or more source regions, but only the first\n-\/\/ source-region contains this location. This location is retrieved by calling\n-\/\/ `first_src_addr` on a dest-region.\n-\/\/ Conversely, a source-region has a dest-region which holds the destination of\n-\/\/ the first live word on this source-region, based on which the destination\n-\/\/ for the rest of live words can be derived.\n-\/\/\n-\/\/ Note:\n-\/\/ There is some complication due to space-boundary-fragmentation (an obj can't\n-\/\/ cross space-boundary) -- a source-region may be split and behave like two\n-\/\/ distinct regions with their own dest-region, as depicted below.\n-\/\/\n-\/\/ source-region: region-n\n-\/\/\n-\/\/ **********************\n-\/\/ |     A|A~~~~B|B     |\n-\/\/ **********************\n-\/\/    n-1     n     n+1\n-\/\/\n-\/\/ AA, BB denote two live objs. ~~~~ denotes unknown number of live objs.\n-\/\/\n-\/\/ Assuming the dest-region for region-n is the final region before\n-\/\/ old-space-end and its first-live-word is the middle of AA, the heap content\n-\/\/ will look like the following after compaction:\n-\/\/\n-\/\/ **************                  *************\n-\/\/      A|A~~~~ |                  |BB    |\n-\/\/ **************                  *************\n-\/\/              ^                  ^\n-\/\/              | old-space-end    | eden-space-start\n-\/\/\n-\/\/ Therefore, in this example, region-n will have two dest-regions, one for\n-\/\/ the final region in old-space and the other for the first region in\n-\/\/ eden-space.\n-\/\/ To handle this special case, we introduce the concept of split-region, whose\n-\/\/ contents are relocated to two spaces. `SplitInfo` captures all necessary\n-\/\/ info about the split, the first part, spliting-point, and the second part.\n@@ -2033,1 +1975,9 @@\n-  const size_t RegionSize = ParallelCompactData::RegionSize;\n+  assert(summary_data().is_region_aligned(dest_addr), \"not aligned\");\n+\n+  const SplitInfo& split_info = _space_info[src_space_id].split_info();\n+  if (split_info.dest_region_addr() == dest_addr) {\n+    \/\/ The partial object ending at the split point contains the first word to\n+    \/\/ be copied to dest_addr.\n+    return split_info.first_src_addr();\n+  }\n+\n@@ -2035,1 +1985,2 @@\n-  assert(sd.is_region_aligned(dest_addr), \"precondition\");\n+  ParMarkBitMap* const bitmap = mark_bitmap();\n+  const size_t RegionSize = ParallelCompactData::RegionSize;\n@@ -2037,0 +1988,1 @@\n+  assert(sd.is_region_aligned(dest_addr), \"not aligned\");\n@@ -2038,2 +1990,0 @@\n-  assert(src_region_ptr->data_size() > 0, \"src region cannot be empty\");\n-\n@@ -2043,2 +1993,2 @@\n-  HeapWord* const region_start = sd.region_to_addr(src_region_idx);\n-  HeapWord* const region_end = sd.region_to_addr(src_region_idx) + RegionSize;\n+  assert(dest_addr >= src_region_destination, \"wrong src region\");\n+  assert(src_region_ptr->data_size() > 0, \"src region cannot be empty\");\n@@ -2046,8 +1996,9 @@\n-  \/\/ Identify the actual destination for the first live words on this region,\n-  \/\/ taking split-region into account.\n-  HeapWord* region_start_destination;\n-  const SplitInfo& split_info = _space_info[src_space_id].split_info();\n-  if (split_info.is_split(src_region_idx)) {\n-    \/\/ The second part of this split region; use the recorded split point.\n-    if (dest_addr == src_region_destination) {\n-      return split_info.split_point();\n+  HeapWord* const src_region_beg = sd.region_to_addr(src_region_idx);\n+  HeapWord* const src_region_end = src_region_beg + RegionSize;\n+\n+  HeapWord* addr = src_region_beg;\n+  if (dest_addr == src_region_destination) {\n+    \/\/ Return the first live word in the source region.\n+    if (partial_obj_size == 0) {\n+      addr = bitmap->find_obj_beg(addr, src_region_end);\n+      assert(addr < src_region_end, \"no objects start in src region\");\n@@ -2055,3 +2006,1 @@\n-    region_start_destination = split_info.preceding_destination();\n-  } else {\n-    region_start_destination = src_region_destination;\n+    return addr;\n@@ -2060,2 +2009,3 @@\n-  \/\/ Calculate the offset to be skipped\n-  size_t words_to_skip = pointer_delta(dest_addr, region_start_destination);\n+  \/\/ Must skip some live data.\n+  size_t words_to_skip = dest_addr - src_region_destination;\n+  assert(src_region_ptr->data_size() > words_to_skip, \"wrong src region\");\n@@ -2063,6 +2013,9 @@\n-  HeapWord* result;\n-  if (partial_obj_size > words_to_skip) {\n-    result = region_start + words_to_skip;\n-  } else {\n-    words_to_skip -= partial_obj_size;\n-    result = skip_live_words(region_start + partial_obj_size, region_end, words_to_skip);\n+  if (partial_obj_size >= words_to_skip) {\n+    \/\/ All the live words to skip are part of the partial object.\n+    addr += words_to_skip;\n+    if (partial_obj_size == words_to_skip) {\n+      \/\/ Find the first live word past the partial object.\n+      addr = bitmap->find_obj_beg(addr, src_region_end);\n+      assert(addr < src_region_end, \"wrong src region\");\n+    }\n+    return addr;\n@@ -2071,4 +2024,4 @@\n-  if (split_info.is_split(src_region_idx)) {\n-    assert(result < split_info.split_point(), \"postcondition\");\n-  } else {\n-    assert(result < region_end, \"postcondition\");\n+  \/\/ Skip over the partial object (if any).\n+  if (partial_obj_size != 0) {\n+    words_to_skip -= partial_obj_size;\n+    addr += partial_obj_size;\n@@ -2077,1 +2030,4 @@\n-  return result;\n+  \/\/ Skip over live words due to objects that start in the region.\n+  addr = skip_live_words(addr, src_region_end, words_to_skip);\n+  assert(addr < src_region_end, \"wrong src region\");\n+  return addr;\n@@ -2128,0 +2084,2 @@\n+  typedef ParallelCompactData::RegionData RegionData;\n+\n@@ -2129,0 +2087,1 @@\n+  const size_t region_size = ParallelCompactData::RegionSize;\n@@ -2136,2 +2095,2 @@\n-  const RegionData* const top_region_ptr = sd.addr_to_region_ptr(top_aligned_up);\n-\n+  const RegionData* const top_region_ptr =\n+    sd.addr_to_region_ptr(top_aligned_up);\n@@ -2154,1 +2113,1 @@\n-  uint space_id = src_space_id + 1;\n+  unsigned int space_id = src_space_id + 1;\n@@ -2157,24 +2116,28 @@\n-  for (\/* empty *\/; space_id < last_space_id; ++space_id) {\n-    HeapWord* bottom = _space_info[space_id].space()->bottom();\n-    HeapWord* top = _space_info[space_id].space()->top();\n-    \/\/ Skip empty space\n-    if (bottom == top) {\n-      continue;\n-    }\n-\n-    \/\/ Identify the first region that contains live words in this space\n-    size_t cur_region = sd.addr_to_region_idx(bottom);\n-    size_t end_region = sd.addr_to_region_idx(sd.region_align_up(top));\n-\n-    for (\/* empty *\/ ; cur_region < end_region; ++cur_region) {\n-      RegionData* cur = sd.region(cur_region);\n-      if (cur->live_obj_size() > 0) {\n-        HeapWord* region_start_addr = sd.region_to_addr(cur_region);\n-        HeapWord* region_end_addr = region_start_addr + ParallelCompactData::RegionSize;\n-        HeapWord* first_live_word = mark_bitmap()->find_obj_beg(region_start_addr, region_end_addr);\n-        assert(first_live_word < region_end_addr, \"inv\");\n-\n-        src_space_id = SpaceId(space_id);\n-        src_space_top = top;\n-        closure.set_source(first_live_word);\n-        return cur_region;\n+  HeapWord* const destination = closure.destination();\n+\n+  do {\n+    MutableSpace* space = _space_info[space_id].space();\n+    HeapWord* const bottom = space->bottom();\n+    const RegionData* const bottom_cp = sd.addr_to_region_ptr(bottom);\n+\n+    \/\/ Iterate over the spaces that do not compact into themselves.\n+    if (bottom_cp->destination() != bottom) {\n+      HeapWord* const top_aligned_up = sd.region_align_up(space->top());\n+      const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);\n+\n+      for (const RegionData* src_cp = bottom_cp; src_cp < top_cp; ++src_cp) {\n+        if (src_cp->live_obj_size() > 0) {\n+          \/\/ Found it.\n+          assert(src_cp->destination() == destination,\n+                 \"first live obj in the space must match the destination\");\n+          assert(src_cp->partial_obj_size() == 0,\n+                 \"a space cannot begin with a partial obj\");\n+\n+          src_space_id = SpaceId(space_id);\n+          src_space_top = space->top();\n+          const size_t src_region_idx = sd.region(src_cp);\n+          closure.set_source(sd.region_to_addr(src_region_idx));\n+          return src_region_idx;\n+        } else {\n+          assert(src_cp->data_size() == 0, \"sanity\");\n+        }\n@@ -2183,1 +2146,1 @@\n-  }\n+  } while (++space_id < last_space_id);\n@@ -2185,1 +2148,2 @@\n-  ShouldNotReachHere();\n+  assert(false, \"no source region was found\");\n+  return 0;\n@@ -2192,2 +2156,2 @@\n-  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends\n-  \/\/ to region_start_addr.\n+  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends to region_start_addr.\n+  SplitInfo& split_info = _space_info[space_id(region_start_addr)].split_info();\n@@ -2198,0 +2162,4 @@\n+    if (split_info.is_split(region_idx)) {\n+      accumulated_size += split_info.partial_obj_size();\n+      break;\n+    }\n@@ -2207,2 +2175,0 @@\n-\/\/ Use region_idx as the destination region, and evacuate all live objs on its\n-\/\/ source regions to this destination region.\n@@ -2229,18 +2195,0 @@\n-  \/\/ source-region:\n-  \/\/\n-  \/\/ **********\n-  \/\/ |   ~~~  |\n-  \/\/ **********\n-  \/\/      ^\n-  \/\/      |-- closure.source() \/ first_src_addr\n-  \/\/\n-  \/\/\n-  \/\/ ~~~ : live words\n-  \/\/\n-  \/\/ destination-region:\n-  \/\/\n-  \/\/ **********\n-  \/\/ |        |\n-  \/\/ **********\n-  \/\/ ^\n-  \/\/ |-- region-start\n@@ -2248,3 +2196,3 @@\n-    \/\/ An object overflows the previous destination region, so this\n-    \/\/ destination region should copy the remainder of the object or as much as\n-    \/\/ will fit.\n+    \/\/ The first source word is in the middle of an object; copy the remainder\n+    \/\/ of the object or as much as will fit.  The fact that pointer updates were\n+    \/\/ deferred will be noted when the object header is processed.\n@@ -2256,4 +2204,1 @@\n-      if (obj_start != closure.source()) {\n-        assert(bitmap->is_marked(obj_start), \"inv\");\n-        \/\/ Found the actual obj-start, try to find the obj-end using either\n-        \/\/ size() if this obj is completely contained in the current region.\n+      if (bitmap->is_marked(obj_start)) {\n@@ -2264,2 +2209,0 @@\n-        \/\/ This obj extends to next region iff partial_obj_addr of the *next*\n-        \/\/ region is the same as obj-start.\n@@ -2282,1 +2225,2 @@\n-      decrement_destination_counts(cm, src_space_id, src_region_idx, closure.source());\n+      decrement_destination_counts(cm, src_space_id, src_region_idx,\n+                                   closure.source());\n@@ -2287,1 +2231,0 @@\n-    \/\/ Finished copying without using up the current destination-region\n@@ -2290,1 +2233,0 @@\n-      assert(sd.region_align_up(old_src_addr) == end_addr, \"only one region\");\n@@ -2296,1 +2238,2 @@\n-      src_region_idx = next_src_region(closure, src_space_id, src_space_top, end_addr);\n+      src_region_idx = next_src_region(closure, src_space_id, src_space_top,\n+                                       end_addr);\n@@ -2300,1 +2243,0 @@\n-  \/\/ Handle the rest obj-by-obj, where we know obj-start.\n@@ -2305,2 +2247,1 @@\n-    \/\/ To handle the case where the final obj in source region extends to next region.\n-    HeapWord* final_obj_start = (end_addr == src_space_top)\n+    HeapWord* partial_obj_start = (end_addr == src_space_top)\n@@ -2309,1 +2250,1 @@\n-    \/\/ Apply closure on objs inside [cur_addr, end_addr)\n+    \/\/ apply closure on objs inside [cur_addr, end_addr)\n@@ -2316,1 +2257,1 @@\n-      if (final_obj_start == cur_addr) {\n+      if (partial_obj_start == cur_addr) {\n@@ -2327,1 +2268,2 @@\n-      decrement_destination_counts(cm, src_space_id, src_region_idx, closure.source());\n+      decrement_destination_counts(cm, src_space_id, src_region_idx,\n+                                   closure.source());\n@@ -2336,1 +2278,2 @@\n-    src_region_idx = next_src_region(closure, src_space_id, src_space_top, end_addr);\n+    src_region_idx = next_src_region(closure, src_space_id, src_space_top,\n+                                     end_addr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":324,"deletions":381,"binary":false,"changes":705,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  bool is_valid() const { return _split_region_idx > 0; }\n+  bool is_valid() const { return _src_region_idx > 0; }\n@@ -122,1 +122,1 @@\n-  inline bool is_split(size_t region_idx) const;\n+  inline bool is_split(size_t source_region) const;\n@@ -124,2 +124,4 @@\n-  \/\/ Obj at the split point doesn't fit the previous space and will be relocated to the next space.\n-  HeapWord* split_point() const { return _split_point; }\n+  \/\/ The index of the split region, the size of the partial object on that\n+  \/\/ region and the destination of the partial object.\n+  size_t    partial_obj_size() const { return _partial_obj_size; }\n+  HeapWord* destination() const      { return _destination; }\n@@ -127,2 +129,4 @@\n-  \/\/ Number of live words before the split point on this region.\n-  size_t preceding_live_words() const { return _preceding_live_words; }\n+  \/\/ The destination count of the partial object referenced by this split\n+  \/\/ (either 1 or 2).  This must be added to the destination count of the\n+  \/\/ remainder of the source region.\n+  unsigned int destination_count() const { return _destination_count; }\n@@ -130,7 +134,4 @@\n-  \/\/ A split region has two \"destinations\", living in two spaces. This method\n-  \/\/ returns the first one -- destination for the first live word on\n-  \/\/ this split region.\n-  HeapWord* preceding_destination() const {\n-    assert(_preceding_destination != nullptr, \"inv\");\n-    return _preceding_destination;\n-  }\n+  \/\/ If a word within the partial object will be written to the first word of a\n+  \/\/ destination region, this is the address of the destination region;\n+  \/\/ otherwise this is null.\n+  HeapWord* dest_region_addr() const     { return _dest_region_addr; }\n@@ -138,2 +139,4 @@\n-  \/\/ Number of regions the preceding live words are relocated into.\n-  uint preceding_destination_count() const { return _preceding_destination_count; }\n+  \/\/ If a word within the partial object will be written to the first word of a\n+  \/\/ destination region, this is the address of that word within the partial\n+  \/\/ object; otherwise this is null.\n+  HeapWord* first_src_addr() const       { return _first_src_addr; }\n@@ -141,1 +144,3 @@\n-  void record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words);\n+  \/\/ Record the data necessary to split the region src_region_idx.\n+  void record(size_t src_region_idx, size_t partial_obj_size,\n+              HeapWord* destination);\n@@ -148,5 +153,6 @@\n-  size_t       _split_region_idx;\n-  HeapWord*    _split_point;\n-  size_t       _preceding_live_words;\n-  HeapWord*    _preceding_destination;\n-  uint         _preceding_destination_count;\n+  size_t       _src_region_idx;\n+  size_t       _partial_obj_size;\n+  HeapWord*    _destination;\n+  unsigned int _destination_count;\n+  HeapWord*    _dest_region_addr;\n+  HeapWord*    _first_src_addr;\n@@ -157,1 +163,1 @@\n-  return _split_region_idx == region_idx && is_valid();\n+  return _src_region_idx == region_idx && is_valid();\n@@ -212,7 +218,1 @@\n-    \/\/ Destination for the first live word in this region.\n-    \/\/ Therefore, the new addr for every live obj on this region can be calculated as:\n-    \/\/\n-    \/\/ new_addr := _destination + live_words_offset(old_addr);\n-    \/\/\n-    \/\/ where, live_words_offset is the number of live words accumulated from\n-    \/\/ region-start to old_addr.\n+    \/\/ Destination address of the region.\n@@ -221,3 +221,1 @@\n-    \/\/ A destination region can have multiple source regions; only the first\n-    \/\/ one is recorded. Since all live objs are slided down, subsequent source\n-    \/\/ regions can be found via plain heap-region iteration.\n+    \/\/ The first region containing data destined for this region.\n@@ -318,3 +316,0 @@\n-    int shadow_state() { return _shadow_state; }\n-\n-    bool is_clear();\n@@ -322,1 +317,1 @@\n-    void verify_clear() NOT_DEBUG_RETURN;\n+    int shadow_state() { return _shadow_state; }\n@@ -881,4 +876,1 @@\n-  void      set_source(HeapWord* addr) {\n-    assert(addr != nullptr, \"precondition\");\n-    _source = addr;\n-  }\n+  void      set_source(HeapWord* addr) { _source = addr; }\n@@ -913,2 +905,3 @@\n-  return MIN2(pointer_delta(new_top, dest_addr),\n-              ParallelCompactData::RegionSize);\n+  assert(dest_addr < new_top, \"sanity\");\n+\n+  return MIN2(pointer_delta(new_top, dest_addr), ParallelCompactData::RegionSize);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":35,"deletions":42,"binary":false,"changes":77,"status":"modified"}]}