{"files":[{"patch":"@@ -111,13 +111,0 @@\n-\/\/ Tunables ...\n-\/\/ The knob* variables are effectively final.  Once set they should\n-\/\/ never be modified hence.  Consider using __read_mostly with GCC.\n-\n-int ObjectMonitor::Knob_SpinLimit    = 5000;    \/\/ derived by an external tool -\n-\n-static int Knob_Bonus               = 100;     \/\/ spin success bonus\n-static int Knob_BonusB              = 100;     \/\/ spin success bonus\n-static int Knob_Penalty             = 200;     \/\/ spin failure penalty\n-static int Knob_Poverty             = 1000;\n-static int Knob_FixedSpin           = 0;\n-static int Knob_PreSpin             = 10;      \/\/ 20-100 likely better\n-\n@@ -409,1 +396,1 @@\n-  if (TrySpin(current) > 0) {\n+  if (TrySpin(current)) {\n@@ -538,1 +525,1 @@\n-int ObjectMonitor::TryLock(JavaThread* current) {\n+ObjectMonitor::TryLockResult ObjectMonitor::TryLock(JavaThread* current) {\n@@ -540,1 +527,1 @@\n-  if (own != nullptr) return 0;\n+  if (own != nullptr) return TryLockResult::HasOwner;\n@@ -543,1 +530,1 @@\n-    return 1;\n+    return TryLockResult::Success;\n@@ -549,1 +536,1 @@\n-  return -1;\n+  return TryLockResult::Interference;\n@@ -726,1 +713,1 @@\n-  if (TryLock (current) > 0) {\n+  if (TryLock(current) == TryLockResult::Success) {\n@@ -760,1 +747,1 @@\n-  if (TrySpin(current) > 0) {\n+  if (TrySpin(current)) {\n@@ -797,1 +784,1 @@\n-    if (TryLock (current) > 0) {\n+    if (TryLock(current) == TryLockResult::Success) {\n@@ -850,1 +837,1 @@\n-    if (TryLock(current) > 0) break;\n+    if (TryLock(current) == TryLockResult::Success) break;\n@@ -865,1 +852,1 @@\n-    if (TryLock(current) > 0) break;\n+    if (TryLock(current) == TryLockResult::Success) break;\n@@ -898,1 +885,1 @@\n-    if (TrySpin(current) > 0) break;\n+    if (TrySpin(current)) break;\n@@ -997,2 +984,1 @@\n-    if (TryLock(current) > 0) break;\n-    if (TrySpin(current) > 0) break;\n+    if (TrySpin(current)) break;\n@@ -1015,1 +1001,1 @@\n-    if (TryLock(current) > 0) break;\n+    if (TryLock(current) == TryLockResult::Success) break;\n@@ -1857,8 +1843,13 @@\n-\/\/ Spinning: Fixed frequency (100%), vary duration\n-int ObjectMonitor::TrySpin(JavaThread* current) {\n-  \/\/ Dumb, brutal spin.  Good for comparative measurements against adaptive spinning.\n-  int ctr = Knob_FixedSpin;\n-  if (ctr != 0) {\n-    while (--ctr >= 0) {\n-      if (TryLock(current) > 0) return 1;\n-      SpinPause();\n+int ObjectMonitor::Knob_SpinLimit    = 5000;   \/\/ derived by an external tool\n+\n+static int Knob_Bonus               = 100;     \/\/ spin success bonus\n+static int Knob_Penalty             = 200;     \/\/ spin failure penalty\n+static int Knob_Poverty             = 1000;\n+static int Knob_FixedSpin           = 0;\n+static int Knob_PreSpin             = 10;      \/\/ 20-100 likely better, but it's not better in my testing.\n+\n+inline static int adjust_up(int spin_duration) {\n+  int x = spin_duration;\n+  if (x < ObjectMonitor::Knob_SpinLimit) {\n+    if (x < Knob_Poverty) {\n+      x = Knob_Poverty;\n@@ -1866,1 +1857,3 @@\n-    return 0;\n+    return x + Knob_Bonus;\n+  } else {\n+    return spin_duration;\n@@ -1868,0 +1861,1 @@\n+}\n@@ -1869,9 +1863,21 @@\n-  for (ctr = Knob_PreSpin + 1; --ctr >= 0;) {\n-    if (TryLock(current) > 0) {\n-      \/\/ Increase _SpinDuration ...\n-      \/\/ Note that we don't clamp SpinDuration precisely at SpinLimit.\n-      \/\/ Raising _SpurDuration to the poverty line is key.\n-      int x = _SpinDuration;\n-      if (x < Knob_SpinLimit) {\n-        if (x < Knob_Poverty) x = Knob_Poverty;\n-        _SpinDuration = x + Knob_BonusB;\n+inline static int adjust_down(int spin_duration) {\n+  \/\/ TODO: Use an AIMD-like policy to adjust _SpinDuration.\n+  \/\/ AIMD is globally stable.\n+  int x = spin_duration;\n+  if (x > 0) {\n+    \/\/ Consider an AIMD scheme like: x -= (x >> 3) + 100\n+    \/\/ This is globally sample and tends to damp the response.\n+    x -= Knob_Penalty;\n+    if (x < 0) { x = 0; }\n+    return x;\n+  } else {\n+    return spin_duration;\n+  }\n+}\n+\n+bool ObjectMonitor::short_fixed_spin(JavaThread* current, int spin_count, bool adapt) {\n+  for (int ctr = 0; ctr < spin_count; ctr++) {\n+    TryLockResult status = TryLock(current);\n+    if (status == TryLockResult::Success) {\n+      if (adapt) {\n+        _SpinDuration = adjust_up(_SpinDuration);\n@@ -1879,1 +1885,3 @@\n-      return 1;\n+      return true;\n+    } else if (status == TryLockResult::Interference) {\n+      break;\n@@ -1883,0 +1891,11 @@\n+  return false;\n+}\n+\n+\/\/ Spinning: Fixed frequency (100%), vary duration\n+bool ObjectMonitor::TrySpin(JavaThread* current) {\n+\n+  \/\/ Dumb, brutal spin.  Good for comparative measurements against adaptive spinning.\n+  int knob_fixed_spin = Knob_FixedSpin;  \/\/ 0 (don't spin: default), 2000 good test\n+  if (knob_fixed_spin > 0) {\n+    return short_fixed_spin(current, knob_fixed_spin, false);\n+  }\n@@ -1890,0 +1909,6 @@\n+\n+  int knob_pre_spin = Knob_PreSpin; \/\/ 10 (default), 100, 1000 or 2000\n+  if (short_fixed_spin(current, knob_pre_spin, true)) {\n+    return true;\n+  }\n+\n@@ -1898,2 +1923,2 @@\n-  ctr = _SpinDuration;\n-  if (ctr <= 0) return 0;\n+  int ctr = _SpinDuration;\n+  if (ctr <= 0) return false;\n@@ -1931,1 +1956,1 @@\n-        goto Abort;           \/\/ abrupt spin egress\n+        break;\n@@ -1963,6 +1988,2 @@\n-        int x = _SpinDuration;\n-        if (x < Knob_SpinLimit) {\n-          if (x < Knob_Poverty) x = Knob_Poverty;\n-          _SpinDuration = x + Knob_Bonus;\n-        }\n-        return 1;\n+        _SpinDuration = adjust_up(_SpinDuration);\n+        return true;\n@@ -1973,1 +1994,1 @@\n-      \/\/ * exit spin with prejudice -- goto Abort;\n+      \/\/ * exit spin with prejudice -- abort without adapting spinner\n@@ -1976,2 +1997,1 @@\n-      prv = ox;\n-      goto Abort;\n+      break;\n@@ -1982,1 +2002,1 @@\n-      goto Abort;\n+      break;\n@@ -1992,11 +2012,2 @@\n-  \/\/ TODO: Use an AIMD-like policy to adjust _SpinDuration.\n-  \/\/ AIMD is globally stable.\n-  {\n-    int x = _SpinDuration;\n-    if (x > 0) {\n-      \/\/ Consider an AIMD scheme like: x -= (x >> 3) + 100\n-      \/\/ This is globally sample and tends to damp the response.\n-      x -= Knob_Penalty;\n-      if (x < 0) x = 0;\n-      _SpinDuration = x;\n-    }\n+  if (ctr < 0) {\n+    _SpinDuration = adjust_down(_SpinDuration);\n@@ -2005,1 +2016,0 @@\n- Abort:\n@@ -2013,1 +2023,1 @@\n-    if (TryLock(current) > 0) return 1;\n+    if (TryLock(current) == TryLockResult::Success) return true;\n@@ -2015,1 +2025,2 @@\n-  return 0;\n+\n+  return false;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":84,"deletions":73,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -356,2 +356,8 @@\n-  int       TryLock(JavaThread* current);\n-  int       TrySpin(JavaThread* current);\n+\n+\n+  enum class TryLockResult { Interference = -1, HasOwner = 0, Success = 1 };\n+\n+  TryLockResult  TryLock(JavaThread* current);\n+\n+  bool      TrySpin(JavaThread* current);\n+  bool      short_fixed_spin(JavaThread* current, int spin_count, bool adapt);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}