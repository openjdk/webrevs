{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/reflection.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/reflection.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/reflection.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/reflection.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -400,0 +400,3 @@\n+  \/\/ calculates number of fields in all interfaces\n+  static int interfaces_field_count(InstanceKlass* ik);\n+\n@@ -427,0 +430,10 @@\n+int ClassFieldMap::interfaces_field_count(InstanceKlass* ik) {\n+  const Array<InstanceKlass*>* interfaces = ik->transitive_interfaces();\n+  int count = 0;\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    FilteredJavaFieldStream fld(interfaces->at(i));\n+    count += fld.field_count();\n+  }\n+  return count;\n+}\n+\n@@ -434,1 +447,0 @@\n-\/\/\n@@ -441,2 +453,7 @@\n-  FilteredFieldStream f(ik, false, false);\n-  int max_field_index = f.field_count()-1;\n+  \/\/ Static fields of interfaces and superclasses are reported as references from the interfaces\/superclasses.\n+  \/\/ Need to calculate start index of this class fields: number of fields in all interfaces and superclasses.\n+  int index = interfaces_field_count(ik);\n+  for (InstanceKlass* super_klass = ik->java_super(); super_klass != nullptr; super_klass = super_klass->java_super()) {\n+    FilteredJavaFieldStream super_fld(super_klass);\n+    index += super_fld.field_count();\n+  }\n@@ -444,2 +461,1 @@\n-  int index = 0;\n-  for (FilteredFieldStream fld(ik, true, true); !fld.eos(); fld.next(), index++) {\n+  for (FilteredJavaFieldStream fld(ik); !fld.done(); fld.next(), index++) {\n@@ -450,1 +466,1 @@\n-    field_map->add(max_field_index - index, fld.signature()->char_at(0), fld.offset());\n+    field_map->add(index, fld.signature()->char_at(0), fld.offset());\n@@ -452,0 +468,1 @@\n+\n@@ -457,2 +474,1 @@\n-\/\/ and private fields declared in superclasses and superinterfaces too).\n-\/\/\n+\/\/ and private fields declared in superclasses too).\n@@ -465,3 +481,6 @@\n-  FilteredFieldStream f(ik, false, false);\n-\n-  int max_field_index = f.field_count()-1;\n+  \/\/ fields of the superclasses are reported first, so need to know total field number to calculate field indices\n+  int total_field_number = interfaces_field_count(ik);\n+  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->java_super()) {\n+    FilteredJavaFieldStream fld(klass);\n+    total_field_number += fld.field_count();\n+  }\n@@ -469,5 +488,9 @@\n-  int index = 0;\n-  for (FilteredFieldStream fld(ik, false, false); !fld.eos(); fld.next(), index++) {\n-    \/\/ ignore static fields\n-    if (fld.access_flags().is_static()) {\n-      continue;\n+  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->java_super()) {\n+    FilteredJavaFieldStream fld(klass);\n+    int start_index = total_field_number - fld.field_count();\n+    for (int index = 0; !fld.done(); fld.next(), index++) {\n+      \/\/ ignore static fields\n+      if (fld.access_flags().is_static()) {\n+        continue;\n+      }\n+      field_map->add(start_index + index, fld.signature()->char_at(0), fld.offset());\n@@ -475,1 +498,2 @@\n-    field_map->add(max_field_index - index, fld.signature()->char_at(0), fld.offset());\n+    \/\/ update total_field_number for superclass\n+    total_field_number = start_index;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":42,"deletions":18,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,0 @@\n-class FieldStream;\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -32,41 +31,0 @@\n-KlassStream::KlassStream(InstanceKlass* klass, bool local_only,\n-                         bool classes_only, bool walk_defaults) {\n-  _klass = _base_klass = klass;\n-  _base_class_search_defaults = false;\n-  _defaults_checked = false;\n-  if (classes_only) {\n-    _interfaces = Universe::the_empty_instance_klass_array();\n-  } else {\n-    _interfaces = klass->transitive_interfaces();\n-  }\n-  _interface_index = _interfaces->length();\n-  _local_only = local_only;\n-  _classes_only = classes_only;\n-  _walk_defaults = walk_defaults;\n-}\n-\n-bool KlassStream::eos() {\n-  if (index() >= 0) return false;\n-  if (_local_only) return true;\n-  if (!_klass->is_interface() && _klass->super() != nullptr) {\n-    \/\/ go up superclass chain (not for interfaces)\n-    _klass = _klass->java_super();\n-  \/\/ Next for method walks, walk default methods\n-  } else if (_walk_defaults && (_defaults_checked == false)  && (_base_klass->default_methods() != nullptr)) {\n-      _base_class_search_defaults = true;\n-      _klass = _base_klass;\n-      _defaults_checked = true;\n-  } else {\n-    \/\/ Next walk transitive interfaces\n-    if (_interface_index > 0) {\n-      _klass = _interfaces->at(--_interface_index);\n-    } else {\n-      return true;\n-    }\n-  }\n-  _index = length();\n-  next();\n-  return eos();\n-}\n-\n-int FieldStream::length() { return _klass->java_fields_count(); }\n@@ -82,8 +40,0 @@\n-\n-int FilteredFieldStream::field_count() {\n-  int numflds = 0;\n-  for (;!eos(); next()) {\n-    numflds++;\n-  }\n-  return numflds;\n-}\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.cpp","additions":1,"deletions":51,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"oops\/objArrayOop.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"runtime\/handles.hpp\"\n@@ -35,1 +33,0 @@\n-#include \"utilities\/accessFlags.hpp\"\n@@ -39,122 +36,0 @@\n-\/\/ A KlassStream is an abstract stream for streaming over self, superclasses\n-\/\/ and (super)interfaces. Streaming is done in reverse order (subclasses first,\n-\/\/ interfaces last).\n-\/\/\n-\/\/    for (KlassStream st(k, false, false, false); !st.eos(); st.next()) {\n-\/\/      Klass* k = st.klass();\n-\/\/      ...\n-\/\/    }\n-\n-class KlassStream {\n- protected:\n-  InstanceKlass*      _klass;           \/\/ current klass\/interface iterated over\n-  InstanceKlass*      _base_klass;      \/\/ initial klass\/interface to iterate over\n-  Array<InstanceKlass*>*_interfaces;    \/\/ transitive interfaces for initial class\n-  int                 _interface_index; \/\/ current interface being processed\n-  bool                _local_only;      \/\/ process initial class\/interface only\n-  bool                _classes_only;    \/\/ process classes only (no interfaces)\n-  bool                _walk_defaults;   \/\/ process default methods\n-  bool                _base_class_search_defaults; \/\/ time to process default methods\n-  bool                _defaults_checked; \/\/ already checked for default methods\n-  int                 _index;\n-\n-  virtual int length() = 0;\n-\n- public:\n-  \/\/ constructor\n-  KlassStream(InstanceKlass* klass, bool local_only, bool classes_only, bool walk_defaults);\n-\n-  \/\/ testing\n-  bool eos();\n-\n-  \/\/ iterating\n-  virtual void next() = 0;\n-\n-  \/\/ accessors\n-  int index() const                 { return _index; }\n-  bool base_class_search_defaults() const { return _base_class_search_defaults; }\n-  void base_class_search_defaults(bool b) { _base_class_search_defaults = b; }\n-};\n-\n-\n-\/\/ A MethodStream streams over all methods in a class, superclasses and (super)interfaces.\n-\/\/ Streaming is done in reverse order (subclasses first, methods in reverse order)\n-\/\/ Usage:\n-\/\/\n-\/\/    for (MethodStream st(k, false, false); !st.eos(); st.next()) {\n-\/\/      Method* m = st.method();\n-\/\/      ...\n-\/\/    }\n-\n-class MethodStream : public KlassStream {\n- private:\n-  int length()                    { return methods()->length(); }\n-  Array<Method*>* methods() {\n-    if (base_class_search_defaults()) {\n-      base_class_search_defaults(false);\n-      return _klass->default_methods();\n-    } else {\n-      return _klass->methods();\n-    }\n-  }\n- public:\n-  MethodStream(InstanceKlass* klass, bool local_only, bool classes_only)\n-    : KlassStream(klass, local_only, classes_only, true) {\n-    _index = length();\n-    next();\n-  }\n-\n-  void next() { _index--; }\n-  Method* method() { return methods()->at(index()); }\n-};\n-\n-\n-\/\/ A FieldStream streams over all fields in a class, superclasses and (super)interfaces.\n-\/\/ Streaming is done in reverse order (subclasses first, fields in reverse order)\n-\/\/ Usage:\n-\/\/\n-\/\/    for (FieldStream st(k, false, false); !st.eos(); st.next()) {\n-\/\/      Symbol* field_name = st.name();\n-\/\/      ...\n-\/\/    }\n-\n-\n-class FieldStream : public KlassStream {\n- private:\n-  int length();\n-\n-  fieldDescriptor _fd_buf;\n-\n- public:\n-  FieldStream(InstanceKlass* klass, bool local_only, bool classes_only)\n-    : KlassStream(klass, local_only, classes_only, false) {\n-    _index = length();\n-    next();\n-  }\n-\n-  void next() { _index -= 1; }\n-\n-  \/\/ Accessors for current field\n-  AccessFlags access_flags() const {\n-    AccessFlags flags;\n-    flags.set_flags(_klass->field_access_flags(_index));\n-    return flags;\n-  }\n-  Symbol* name() const {\n-    return _klass->field_name(_index);\n-  }\n-  Symbol* signature() const {\n-    return _klass->field_signature(_index);\n-  }\n-  \/\/ missing: initval()\n-  int offset() const {\n-    return _klass->field_offset( index() );\n-  }\n-  \/\/ bridge to a heavier API:\n-  fieldDescriptor& field_descriptor() const {\n-    fieldDescriptor& field = const_cast<fieldDescriptor&>(_fd_buf);\n-    field.reinitialize(_klass, _index);\n-    return field;\n-  }\n-};\n-\n@@ -202,39 +77,0 @@\n-\n-\/\/ A FilteredFieldStream streams over all fields in a class, superclasses and\n-\/\/ (super)interfaces. Streaming is done in reverse order (subclasses first,\n-\/\/ fields in reverse order)\n-\/\/\n-\/\/ Usage:\n-\/\/\n-\/\/    for (FilteredFieldStream st(k, false, false); !st.eos(); st.next()) {\n-\/\/      Symbol* field_name = st.name();\n-\/\/      ...\n-\/\/    }\n-\n-class FilteredFieldStream : public FieldStream {\n- private:\n-  int  _filtered_fields_count;\n-  bool has_filtered_field() { return (_filtered_fields_count > 0); }\n-  void skip_filtered_fields() {\n-    if (has_filtered_field()) {\n-      while (_index >= 0 && FilteredFieldsMap::is_filtered_field((Klass*)_klass, offset())) {\n-        _index -= 1;\n-      }\n-    }\n-  }\n-\n- public:\n-  FilteredFieldStream(InstanceKlass* klass, bool local_only, bool classes_only)\n-    : FieldStream(klass, local_only, classes_only) {\n-    _filtered_fields_count = FilteredFieldsMap::filtered_fields_count(klass, local_only);\n-    \/\/ skip filtered fields at the end\n-    skip_filtered_fields();\n-\n-  }\n-  int field_count();\n-  void next() {\n-    _index -= 1;\n-    skip_filtered_fields();\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.hpp","additions":0,"deletions":164,"binary":false,"changes":164,"status":"modified"}]}