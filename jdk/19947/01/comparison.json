{"files":[{"patch":"@@ -1862,1 +1862,1 @@\n-    __ call_c_with_frame_resize(copyfunc_addr, \/*stub does not need resized frame*\/ 0);\n+    __ call_c(copyfunc_addr);\n@@ -2060,1 +2060,1 @@\n-        __ call_c_with_frame_resize(copyfunc_addr, \/*stub does not need resized frame*\/ 0);\n+        __ call_c(copyfunc_addr);\n@@ -2184,1 +2184,1 @@\n-  __ call_c_with_frame_resize(entry, \/*stub does not need resized frame*\/ 0);\n+  __ call_c(entry);\n@@ -2865,1 +2865,1 @@\n-  __ call_c_with_frame_resize(dest, \/*no resizing*\/ 0);\n+  __ call_c(dest);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -410,1 +410,0 @@\n-#if defined(ABI_ELFv2)\n@@ -412,3 +411,0 @@\n-#else\n-  address return_pc = call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, dest), relocInfo::runtime_call_type);\n-#endif\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  address return_pc = call_c_with_frame_resize(entry_point, \/*No resize, we have a C compatible frame.*\/0);\n+  address return_pc = call_c(entry_point);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,9 +138,1 @@\n-#if defined(ABI_ELFv2)\n-    call_c(CAST_FROM_FN_PTR(address,\n-                            Interpreter::remove_activation_preserving_args_entry),\n-           relocInfo::none);\n-#else\n-    call_c(CAST_FROM_FN_PTR(FunctionDescriptor*,\n-                            Interpreter::remove_activation_preserving_args_entry),\n-           relocInfo::none);\n-#endif\n+    call_c(CAST_FROM_FN_PTR(address, Interpreter::remove_activation_preserving_args_entry), relocInfo::none);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1038,1 +1038,1 @@\n-address MacroAssembler::call_c(address function_entry, relocInfo::relocType rt) {\n+address MacroAssembler::call_c(address function_entry,relocInfo::relocType) {\n@@ -1296,1 +1296,0 @@\n-#if defined(ABI_ELFv2)\n@@ -1298,3 +1297,0 @@\n-#else\n-  address return_pc = call_c((FunctionDescriptor*)entry_point, relocInfo::none);\n-#endif\n@@ -1321,5 +1317,1 @@\n-#if defined(ABI_ELFv2)\n-  call_c(entry_point, relocInfo::none);\n-#else\n-  call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, entry_point), relocInfo::none);\n-#endif\n+  call_c(entry_point);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-  address call_c(address function_entry, relocInfo::relocType rt);\n+  address call_c(address function_entry, relocInfo::relocType rt = relocInfo::none);\n@@ -367,0 +367,3 @@\n+  address call_c(address function_entry, relocInfo::relocType rt = relocInfo::relocType::none) {\n+    return call_c((FunctionDescriptor*)function_entry, rt);\n+  }\n@@ -419,1 +422,0 @@\n-\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,6 +102,1 @@\n-#if defined(ABI_ELFv2)\n-  __ call_c((address) OptoRuntime::handle_exception_C, relocInfo::none);\n-#else\n-  __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, OptoRuntime::handle_exception_C),\n-            relocInfo::none);\n-#endif\n+  __ call_c((address) OptoRuntime::handle_exception_C);\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2447,1 +2447,0 @@\n-#if defined(ABI_ELFv2)\n@@ -2449,4 +2448,0 @@\n-#else\n-  FunctionDescriptor* fd_native_method = (FunctionDescriptor*) native_func;\n-  __ call_c(fd_native_method, relocInfo::runtime_call_type);\n-#endif\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -520,0 +520,100 @@\n+\n+#define __ masm->\n+  \/\/ Continuation point for throwing of implicit exceptions that are\n+  \/\/ not handled in the current activation. Fabricates an exception\n+  \/\/ oop and initiates normal exception dispatching in this\n+  \/\/ frame. Only callee-saved registers are preserved (through the\n+  \/\/ normal register window \/ RegisterMap handling).  If the compiler\n+  \/\/ needs all registers to be preserved between the fault point and\n+  \/\/ the exception handler then it must assume responsibility for that\n+  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n+  \/\/ implicit exceptions (e.g., NullPointerException or\n+  \/\/ AbstractMethodError on entry) are either at call sites or\n+  \/\/ otherwise assume that stack unwinding will be initiated, so\n+  \/\/ caller saved registers were assumed volatile in the compiler.\n+  \/\/\n+  \/\/ Note that we generate only this stub into a RuntimeStub, because\n+  \/\/ it needs to be properly traversed and ignored during GC, so we\n+  \/\/ change the meaning of the \"__\" macro within this method.\n+  \/\/\n+  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n+  \/\/ SharedRuntime.cpp requires that this code be generated into a\n+  \/\/ RuntimeStub.\n+  address generate_throw_exception(const char* name, address runtime_entry, bool restore_saved_exception_pc,\n+                                   Register arg1 = noreg, Register arg2 = noreg) {\n+    CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+\n+    OopMapSet* oop_maps  = new OopMapSet();\n+    int frame_size_in_bytes = frame::native_abi_reg_args_size;\n+    OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n+\n+    address start = __ pc();\n+\n+    __ save_LR(R11_scratch1);\n+\n+    \/\/ Push a frame.\n+    __ push_frame_reg_args(0, R11_scratch1);\n+\n+    address frame_complete_pc = __ pc();\n+\n+    if (restore_saved_exception_pc) {\n+      __ unimplemented(\"StubGenerator::throw_exception with restore_saved_exception_pc\");\n+    }\n+\n+    \/\/ Note that we always have a runtime stub frame on the top of\n+    \/\/ stack by this point. Remember the offset of the instruction\n+    \/\/ whose address will be moved to R11_scratch1.\n+    address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n+\n+    __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n+\n+    __ mr(R3_ARG1, R16_thread);\n+    if (arg1 != noreg) {\n+      __ mr(R4_ARG2, arg1);\n+    }\n+    if (arg2 != noreg) {\n+      __ mr(R5_ARG3, arg2);\n+    }\n+    __ call_c(runtime_entry);\n+\n+    \/\/ Set an oopmap for the call site.\n+    oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n+\n+    __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+    \/\/ Make sure that this code is only executed if there is a pending\n+    \/\/ exception.\n+    {\n+      Label L;\n+      __ ld(R0,\n+                in_bytes(Thread::pending_exception_offset()),\n+                R16_thread);\n+      __ cmpdi(CCR0, R0, 0);\n+      __ bne(CCR0, L);\n+      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n+      __ bind(L);\n+    }\n+#endif\n+\n+    \/\/ Pop frame.\n+    __ pop_frame();\n+\n+    __ restore_LR(R11_scratch1);\n+\n+    __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n+    __ mtctr(R11_scratch1);\n+    __ bctr();\n+\n+    \/\/ Create runtime stub with OopMap.\n+    RuntimeStub* stub =\n+      RuntimeStub::new_runtime_stub(name, &code,\n+                                    \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n+                                    frame_size_in_bytes\/wordSize,\n+                                    oop_maps,\n+                                    false);\n+    return stub->entry_point();\n+  }\n+#undef __\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -1467,7 +1467,1 @@\n-#if defined(ABI_ELFv2)\n-  __ call_c(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans),\n-            relocInfo::none);\n-#else\n-  __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, JavaThread::check_special_condition_for_native_trans),\n-            relocInfo::none);\n-#endif\n+  __ call_c(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans), relocInfo::none);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"}]}