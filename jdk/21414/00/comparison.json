{"files":[{"patch":"@@ -2310,4 +2310,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1006,4 +1006,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2157,4 +2157,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1969,4 +1969,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1480,4 +1480,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2234,4 +2234,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4551,1 +4551,0 @@\n-    const Type* bt_t      = Type::get_const_basic_type(bt);\n@@ -4631,1 +4630,1 @@\n-    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt_t);\n+    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -345,1 +345,0 @@\n-  static const TypeVectMask* predicate_reg_type(const Type* elemTy, int length);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -231,2 +231,2 @@\n-      const Type* element_type = _vloop_analyzer.types().velt_type(p0);\n-      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type->isa_long()) {\n+      BasicType element_type = _vloop_analyzer.types().velt_basic_type(p0);\n+      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type == T_LONG) {\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(TypeInt::BOOL, MaxVectorSize))->hashcons();\n+  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(T_BOOLEAN, MaxVectorSize))->hashcons();\n@@ -690,2 +690,2 @@\n-  if (Matcher::vector_size_supported(T_BYTE,4)) {\n-    TypeVect::VECTS = TypeVect::make(T_BYTE,4);\n+  if (Matcher::vector_size_supported(T_BYTE, 4)) {\n+    TypeVect::VECTS = TypeVect::make(T_BYTE, 4);\n@@ -693,2 +693,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,2)) {\n-    TypeVect::VECTD = TypeVect::make(T_FLOAT,2);\n+  if (Matcher::vector_size_supported(T_FLOAT, 2)) {\n+    TypeVect::VECTD = TypeVect::make(T_FLOAT, 2);\n@@ -696,2 +696,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,4)) {\n-    TypeVect::VECTX = TypeVect::make(T_FLOAT,4);\n+  if (Matcher::vector_size_supported(T_FLOAT, 4)) {\n+    TypeVect::VECTX = TypeVect::make(T_FLOAT, 4);\n@@ -699,2 +699,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,8)) {\n-    TypeVect::VECTY = TypeVect::make(T_FLOAT,8);\n+  if (Matcher::vector_size_supported(T_FLOAT, 8)) {\n+    TypeVect::VECTY = TypeVect::make(T_FLOAT, 8);\n@@ -702,2 +702,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,16)) {\n-    TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);\n+  if (Matcher::vector_size_supported(T_FLOAT, 16)) {\n+    TypeVect::VECTZ = TypeVect::make(T_FLOAT, 16);\n@@ -2494,1 +2494,1 @@\n-const TypeVect* TypeVect::make(const Type *elem, uint length, bool is_mask) {\n+const TypeVect* TypeVect::make(BasicType elem_bt, uint length, bool is_mask) {\n@@ -2496,1 +2496,1 @@\n-    return makemask(elem, length);\n+    return makemask(elem_bt, length);\n@@ -2498,1 +2498,0 @@\n-  BasicType elem_bt = elem->array_element_basic_type();\n@@ -2504,1 +2503,1 @@\n-    return (TypeVect*)(new TypeVectA(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectA(elem_bt, length))->hashcons();\n@@ -2506,1 +2505,1 @@\n-    return (TypeVect*)(new TypeVectS(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectS(elem_bt, length))->hashcons();\n@@ -2510,1 +2509,1 @@\n-    return (TypeVect*)(new TypeVectD(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectD(elem_bt, length))->hashcons();\n@@ -2512,1 +2511,1 @@\n-    return (TypeVect*)(new TypeVectX(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectX(elem_bt, length))->hashcons();\n@@ -2514,1 +2513,1 @@\n-    return (TypeVect*)(new TypeVectY(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectY(elem_bt, length))->hashcons();\n@@ -2516,1 +2515,1 @@\n-    return (TypeVect*)(new TypeVectZ(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectZ(elem_bt, length))->hashcons();\n@@ -2522,2 +2521,1 @@\n-const TypeVect *TypeVect::makemask(const Type* elem, uint length) {\n-  BasicType elem_bt = elem->array_element_basic_type();\n+const TypeVect *TypeVect::makemask(BasicType elem_bt, uint length) {\n@@ -2526,1 +2524,1 @@\n-    return TypeVectMask::make(elem, length);\n+    return TypeVectMask::make(elem_bt, length);\n@@ -2528,1 +2526,1 @@\n-    return make(elem, length);\n+    return make(elem_bt, length);\n@@ -2533,2 +2531,2 @@\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeVect::xmeet( const Type *t ) const {\n+\/\/ Compute the MEET of two types. It returns a new Type object.\n+const Type* TypeVect::xmeet(const Type* t) const {\n@@ -2536,1 +2534,3 @@\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+  if (this == t) {\n+    return this;\n+  }\n@@ -2548,1 +2548,1 @@\n-    assert(  base() == v->base(), \"\");\n+    assert(base() == v->base(), \"\");\n@@ -2551,1 +2551,1 @@\n-    return TypeVect::makemask(_elem->xmeet(v->_elem), _length);\n+    return this;\n@@ -2560,1 +2560,1 @@\n-    assert(  base() == v->base(), \"\");\n+    assert(base() == v->base(), \"\");\n@@ -2563,1 +2563,1 @@\n-    return TypeVect::make(_elem->xmeet(v->_elem), _length);\n+    return this;\n@@ -2574,1 +2574,1 @@\n-  return new TypeVect(base(), _elem->dual(), _length);\n+  return this;\n@@ -2580,2 +2580,2 @@\n-  const TypeVect *v = t->is_vect();\n-  return (_elem == v->_elem) && (_length == v->_length);\n+  const TypeVect* v = t->is_vect();\n+  return (element_basic_type() == v->element_basic_type()) && (length() == v->length());\n@@ -2587,1 +2587,1 @@\n-  return (uint)(uintptr_t)_elem + (uint)(uintptr_t)_length;\n+  return (uint)base() + (uint)(uintptr_t)_elem_bt + (uint)(uintptr_t)_length;\n@@ -2591,1 +2591,1 @@\n-\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple\n@@ -2601,1 +2601,1 @@\n-  return _elem->empty();\n+  return false;\n@@ -2609,1 +2609,1 @@\n-    st->print(\"vectora[\"); break;\n+    st->print(\"vectora\"); break;\n@@ -2611,1 +2611,1 @@\n-    st->print(\"vectors[\"); break;\n+    st->print(\"vectors\"); break;\n@@ -2613,1 +2613,1 @@\n-    st->print(\"vectord[\"); break;\n+    st->print(\"vectord\"); break;\n@@ -2615,1 +2615,1 @@\n-    st->print(\"vectorx[\"); break;\n+    st->print(\"vectorx\"); break;\n@@ -2617,1 +2617,1 @@\n-    st->print(\"vectory[\"); break;\n+    st->print(\"vectory\"); break;\n@@ -2619,1 +2619,1 @@\n-    st->print(\"vectorz[\"); break;\n+    st->print(\"vectorz\"); break;\n@@ -2621,1 +2621,1 @@\n-    st->print(\"vectormask[\"); break;\n+    st->print(\"vectormask\"); break;\n@@ -2625,3 +2625,1 @@\n-  st->print(\"%d]:{\", _length);\n-  _elem->dump2(d, depth, st);\n-  st->print(\"}\");\n+  st->print(\"<%c,%u>\", type2char(element_basic_type()), length());\n@@ -2631,16 +2629,2 @@\n-bool TypeVectMask::eq(const Type *t) const {\n-  const TypeVectMask *v = t->is_vectmask();\n-  return (element_type() == v->element_type()) && (length() == v->length());\n-}\n-\n-const Type *TypeVectMask::xdual() const {\n-  return new TypeVectMask(element_type()->dual(), length());\n-}\n-\n-const TypeVectMask *TypeVectMask::make(const BasicType elem_bt, uint length) {\n-  return make(get_const_basic_type(elem_bt), length);\n-}\n-\n-const TypeVectMask *TypeVectMask::make(const Type* elem, uint length) {\n-  const TypeVectMask* mtype = Matcher::predicate_reg_type(elem, length);\n-  return (TypeVectMask*) const_cast<TypeVectMask*>(mtype)->hashcons();\n+const TypeVectMask* TypeVectMask::make(const BasicType elem_bt, uint length) {\n+  return (TypeVectMask*) (new TypeVectMask(elem_bt, length))->hashcons();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":47,"deletions":63,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -787,2 +787,2 @@\n-  const Type*   _elem;  \/\/ Vector's element type\n-  const uint  _length;  \/\/ Elements in vector (power of 2)\n+  const BasicType _elem_bt;  \/\/ Vector's element type\n+  const uint _length;  \/\/ Elements in vector (power of 2)\n@@ -791,2 +791,2 @@\n-  TypeVect(TYPES t, const Type* elem, uint length) : Type(t),\n-    _elem(elem), _length(length) {}\n+  TypeVect(TYPES t, BasicType elem_bt, uint length) : Type(t),\n+    _elem_bt(elem_bt), _length(length) {}\n@@ -795,2 +795,1 @@\n-  const Type* element_type() const { return _elem; }\n-  BasicType element_basic_type() const { return _elem->array_element_basic_type(); }\n+  BasicType element_basic_type() const { return _elem_bt; }\n@@ -799,1 +798,1 @@\n-   return _length * type2aelembytes(element_basic_type());\n+    return _length * type2aelembytes(element_basic_type());\n@@ -807,12 +806,2 @@\n-  static const TypeVect *make(const BasicType elem_bt, uint length, bool is_mask = false) {\n-    \/\/ Use bottom primitive type.\n-    return make(get_const_basic_type(elem_bt), length, is_mask);\n-  }\n-  \/\/ Used directly by Replicate nodes to construct singleton vector.\n-  static const TypeVect *make(const Type* elem, uint length, bool is_mask = false);\n-\n-  static const TypeVect *makemask(const BasicType elem_bt, uint length) {\n-    \/\/ Use bottom primitive type.\n-    return makemask(get_const_basic_type(elem_bt), length);\n-  }\n-  static const TypeVect *makemask(const Type* elem, uint length);\n+  static const TypeVect* make(const BasicType elem_bt, uint length, bool is_mask = false);\n+  static const TypeVect* makemask(const BasicType elem_bt, uint length);\n@@ -820,0 +809,2 @@\n+  virtual const Type* xmeet( const Type *t) const;\n+  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n@@ -821,10 +812,7 @@\n-  virtual const Type *xmeet( const Type *t) const;\n-  virtual const Type *xdual() const;     \/\/ Compute dual right now.\n-\n-  static const TypeVect *VECTA;\n-  static const TypeVect *VECTS;\n-  static const TypeVect *VECTD;\n-  static const TypeVect *VECTX;\n-  static const TypeVect *VECTY;\n-  static const TypeVect *VECTZ;\n-  static const TypeVect *VECTMASK;\n+  static const TypeVect* VECTA;\n+  static const TypeVect* VECTS;\n+  static const TypeVect* VECTD;\n+  static const TypeVect* VECTX;\n+  static const TypeVect* VECTY;\n+  static const TypeVect* VECTZ;\n+  static const TypeVect* VECTMASK;\n@@ -839,1 +827,1 @@\n-  TypeVectA(const Type* elem, uint length) : TypeVect(VectorA, elem, length) {}\n+  TypeVectA(BasicType elem_bt, uint length) : TypeVect(VectorA, elem_bt, length) {}\n@@ -844,1 +832,1 @@\n-  TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}\n+  TypeVectS(BasicType elem_bt, uint length) : TypeVect(VectorS, elem_bt, length) {}\n@@ -849,1 +837,1 @@\n-  TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}\n+  TypeVectD(BasicType elem_bt, uint length) : TypeVect(VectorD, elem_bt, length) {}\n@@ -854,1 +842,1 @@\n-  TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}\n+  TypeVectX(BasicType elem_bt, uint length) : TypeVect(VectorX, elem_bt, length) {}\n@@ -859,1 +847,1 @@\n-  TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}\n+  TypeVectY(BasicType elem_bt, uint length) : TypeVect(VectorY, elem_bt, length) {}\n@@ -864,1 +852,1 @@\n-  TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}\n+  TypeVectZ(BasicType elem_bt, uint length) : TypeVect(VectorZ, elem_bt, length) {}\n@@ -870,3 +858,1 @@\n-  TypeVectMask(const Type* elem, uint length) : TypeVect(VectorMask, elem, length) {}\n-  virtual bool eq(const Type *t) const;\n-  virtual const Type *xdual() const;\n+  TypeVectMask(BasicType elem_bt, uint length) : TypeVect(VectorMask, elem_bt, length) {}\n@@ -874,1 +860,0 @@\n-  static const TypeVectMask* make(const Type* elem, uint length);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":24,"deletions":39,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -527,1 +527,0 @@\n-  const Type* type_bt = Type::get_const_basic_type(elem_bt);\n@@ -530,1 +529,1 @@\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, type_bt));\n+  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, elem_bt));\n@@ -535,2 +534,2 @@\n-  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n-  const TypeVect* vmask_type = TypeVect::makemask(type_bt, num_elem);\n+  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, elem_bt));\n+  const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n@@ -603,2 +602,1 @@\n-  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n-  const TypeVect * vt  = TypeVect::make(type_bt, num_elem);\n+  const TypeVect * vt  = TypeVect::make(elem_bt, num_elem);\n@@ -612,1 +610,1 @@\n-    Node* bcast_step     = gvn().transform(VectorNode::scalar2vector(step, num_elem, type_bt));\n+    Node* bcast_step = gvn().transform(VectorNode::scalar2vector(step, num_elem, elem_bt));\n@@ -621,1 +619,1 @@\n-    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, type_bt));\n+    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, elem_bt));\n@@ -626,1 +624,1 @@\n-  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, type_bt));\n+  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, elem_bt));\n@@ -805,3 +803,2 @@\n-  const Type* shuffle_type_bt = Type::get_const_basic_type(shuffle_bt);\n-  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, shuffle_type_bt));\n+  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem - 1));\n+  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, shuffle_bt));\n@@ -911,1 +908,1 @@\n-    broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt), is_mask);\n+    broadcast = VectorNode::scalar2vector(elem, num_elem, elem_bt, is_mask);\n@@ -1355,1 +1352,1 @@\n-      zero = gvn().transform(VectorNode::scalar2vector(zero, mem_num_elem, Type::get_const_basic_type(mem_elem_bt)));\n+      zero = gvn().transform(VectorNode::scalar2vector(zero, mem_num_elem, mem_elem_bt));\n@@ -1681,1 +1678,1 @@\n-    Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init, num_elem, Type::get_const_basic_type(elem_bt)));\n+    Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init, num_elem, elem_bt));\n@@ -2062,1 +2059,1 @@\n-      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n+      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, elem_bt));\n@@ -2205,2 +2202,1 @@\n-  const Type * byte_bt = Type::get_const_basic_type(T_BYTE);\n-  const TypeVect * byte_vt  = TypeVect::make(byte_bt, num_elem);\n+  const TypeVect * byte_vt  = TypeVect::make(T_BYTE, num_elem);\n@@ -2212,1 +2208,1 @@\n-  Node* bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, byte_bt));\n+  Node* bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, T_BYTE));\n@@ -2233,1 +2229,1 @@\n-      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n+      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, elem_bt));\n@@ -2381,1 +2377,0 @@\n-      const Type * type_bt = Type::get_const_basic_type(elem_bt);\n@@ -2383,1 +2378,1 @@\n-      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, type_bt));\n+      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, elem_bt));\n@@ -3041,1 +3036,1 @@\n-    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, Type::get_const_basic_type(elem_bt)));\n+    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, elem_bt));\n@@ -3154,1 +3149,1 @@\n-    indexLimit = gvn().transform(VectorNode::scalar2vector(indexLimit, num_elem, Type::get_const_basic_type(elem_bt)));\n+    indexLimit = gvn().transform(VectorNode::scalar2vector(indexLimit, num_elem, elem_bt));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -802,2 +802,1 @@\n-VectorNode* VectorNode::scalar2vector(Node* s, uint vlen, const Type* opd_t, bool is_mask) {\n-  BasicType bt = opd_t->array_element_basic_type();\n+VectorNode* VectorNode::scalar2vector(Node* s, uint vlen, BasicType bt, bool is_mask) {\n@@ -805,1 +804,1 @@\n-    const TypeVect* vt = TypeVect::make(opd_t, vlen, true);\n+    const TypeVect* vt = TypeVect::make(bt, vlen, true);\n@@ -809,2 +808,1 @@\n-  const TypeVect* vt = opd_t->singleton() ? TypeVect::make(opd_t, vlen)\n-                                          : TypeVect::make(bt, vlen);\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n@@ -1629,2 +1627,0 @@\n-    const Type* elem_ty = Type::get_const_basic_type(bt);\n-\n@@ -1642,2 +1638,2 @@\n-    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node, vlen, elem_ty));\n-    Node* vector_one = phase->transform(VectorNode::scalar2vector(const_one_node, vlen, elem_ty));\n+    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node, vlen, bt));\n+    Node* vector_one = phase->transform(VectorNode::scalar2vector(const_one_node, vlen, bt));\n@@ -1885,1 +1881,1 @@\n-      const_minus_one = phase->transform(VectorNode::scalar2vector(const_minus_one, vlen, Type::get_const_basic_type(bt)));\n+      const_minus_one = phase->transform(VectorNode::scalar2vector(const_minus_one, vlen, bt));\n@@ -1890,1 +1886,1 @@\n-      const_one = phase->transform(VectorNode::scalar2vector(const_one, vlen, Type::get_const_basic_type(bt)));\n+      const_one = phase->transform(VectorNode::scalar2vector(const_one, vlen, bt));\n@@ -1907,1 +1903,1 @@\n-  const_zero = phase->transform(VectorNode::scalar2vector(const_zero, vlen, Type::get_const_basic_type(bt)));\n+  const_zero = phase->transform(VectorNode::scalar2vector(const_zero, vlen, bt));\n@@ -2072,2 +2068,1 @@\n-    return VectorNode::scalar2vector(zero, length(), Type::get_const_basic_type(bt),\n-                                     bottom_type()->isa_vectmask() != nullptr);\n+    return VectorNode::scalar2vector(zero, length(), bt, bottom_type()->isa_vectmask() != nullptr);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t, bool is_mask = false);\n+  static VectorNode* scalar2vector(Node* s, uint vlen, BasicType bt, bool is_mask = false);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -425,2 +425,1 @@\n-  tty->print(\"vlen=%d element_type=\", _vlen);\n-  _element_type->dump();\n+  tty->print(\"vlen=%d element_type=%s\", _vlen, type2name(_element_type));\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-  const Type* _element_type;\n+  BasicType _element_type;\n@@ -359,1 +359,1 @@\n-  VTransformReplicateNode(VTransform& vtransform, int vlen, const Type* element_type) :\n+  VTransformReplicateNode(VTransform& vtransform, int vlen, BasicType element_type) :\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,7 +122,7 @@\n-    private static final String TYPE_BYTE   = \"byte\";\n-    private static final String TYPE_CHAR   = \"char\";\n-    private static final String TYPE_SHORT  = \"short\";\n-    private static final String TYPE_INT    = \"int\";\n-    private static final String TYPE_LONG   = \"long\";\n-    private static final String TYPE_FLOAT  = \"float\";\n-    private static final String TYPE_DOUBLE = \"double\";\n+    private static final String TYPE_BYTE   = \"B\";\n+    private static final String TYPE_CHAR   = \"C\";\n+    private static final String TYPE_SHORT  = \"S\";\n+    private static final String TYPE_INT    = \"I\";\n+    private static final String TYPE_LONG   = \"J\";\n+    private static final String TYPE_FLOAT  = \"F\";\n+    private static final String TYPE_DOUBLE = \"D\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,1 @@\n-        return nodeRegex.replaceAll(IRNode.IS_REPLACED,\n-                                    \"vector[A-Za-z]\\\\\\\\[\" + sizeRegex + \"\\\\\\\\]:\\\\\\\\{\" + type + \"\\\\\\\\}\");\n+        return nodeRegex.replaceAll(IRNode.IS_REPLACED, \"vector[A-Za-z]<\" + type + \",\" + sizeRegex + \">\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawIRNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}