{"files":[{"patch":"@@ -1872,2 +1872,3 @@\n-         JavaThread::current()->thread_state() == _thread_in_vm,\n-         \"Java Thread is not running in vm\");\n+         JavaThread::current()->thread_state() == _thread_in_vm ||\n+         JavaThread::current() == java_lang_Thread::thread(java_thread),\n+         \"unsafe call to java_lang_Thread::get_thread_status()?\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -847,0 +847,1 @@\n+#ifdef ASSERT\n@@ -871,0 +872,1 @@\n+#endif\n@@ -937,1 +939,0 @@\n-    int callee_max_locals = 0;\n@@ -942,0 +943,2 @@\n+      methodHandle mh(thread, iframe->interpreter_frame_method());\n+      bool reexecute = el->should_reexecute();\n@@ -946,2 +949,0 @@\n-      bool try_next_mask = false;\n-      int next_mask_expression_stack_size = -1;\n@@ -949,3 +950,1 @@\n-      methodHandle mh(thread, iframe->interpreter_frame_method());\n-      OopMapCache::compute_one_oop_map(mh, iframe->interpreter_frame_bci(), &mask);\n-      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n+      int bci = iframe->interpreter_frame_bci();\n@@ -953,1 +952,25 @@\n-      \/\/ Get to the next bytecode if possible\n+      BytecodeStream str(mh, bci);\n+      assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+      Bytecodes::Code cur_code = str.next();\n+\n+      if (!reexecute && !Bytecodes::is_invoke(cur_code)) {\n+        assert(is_top_frame, \"must be\");\n+        assert(falls_through(cur_code), \"must be\");\n+        assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+        assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+        \/\/ Need to subtract off the size of the result type of\n+        \/\/ the bytecode because this is not described in the\n+        \/\/ debug info but returned to the interpreter in the TOS\n+        \/\/ caching register\n+        BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n+        if (bytecode_result_type != T_ILLEGAL) {\n+          top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n+        }\n+        assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n+\n+        cur_code = str.next();\n+        reexecute = true;\n+      }\n+\n+      assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n@@ -955,0 +978,1 @@\n+      OopMapCache::compute_one_oop_map(mh, str.bci(), &mask);\n@@ -958,2 +982,0 @@\n-      Bytecodes::Code cur_code = str.next();\n-      Bytecodes::Code next_code = Bytecodes::_shouldnotreachhere;\n@@ -961,1 +983,1 @@\n-        Bytecode_invoke invoke(mh, iframe->interpreter_frame_bci());\n+        Bytecode_invoke invoke(mh, str.bci());\n@@ -967,30 +989,0 @@\n-      if (str.bci() < max_bci) {\n-        next_code = str.next();\n-        if (next_code >= 0) {\n-          \/\/ The interpreter oop map generator reports results before\n-          \/\/ the current bytecode has executed except in the case of\n-          \/\/ calls. It seems to be hard to tell whether the compiler\n-          \/\/ has emitted debug information matching the \"state before\"\n-          \/\/ a given bytecode or the state after, so we try both\n-          if (!Bytecodes::is_invoke(cur_code) && falls_through(cur_code)) {\n-            \/\/ Get expression stack size for the next bytecode\n-            InterpreterOopMap next_mask;\n-            OopMapCache::compute_one_oop_map(mh, str.bci(), &next_mask);\n-            next_mask_expression_stack_size = next_mask.expression_stack_size();\n-            if (Bytecodes::is_invoke(next_code)) {\n-              Bytecode_invoke invoke(mh, str.bci());\n-              next_mask_expression_stack_size += invoke.size_of_parameters();\n-            }\n-            \/\/ Need to subtract off the size of the result type of\n-            \/\/ the bytecode because this is not described in the\n-            \/\/ debug info but returned to the interpreter in the TOS\n-            \/\/ caching register\n-            BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n-            if (bytecode_result_type != T_ILLEGAL) {\n-              top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n-            }\n-            assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n-            try_next_mask = true;\n-          }\n-        }\n-      }\n@@ -999,38 +991,26 @@\n-      \/\/ This assertion may be dependent on the platform we're running on and may need modification (tested on x86 and sparc)\n-      if (!(\n-            \/* SPARC *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_size_of_parameters) ||\n-            \/* x86 *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_max_locals) ||\n-            (try_next_mask &&\n-             (iframe->interpreter_frame_expression_stack_size() == (next_mask_expression_stack_size -\n-                                                                    top_frame_expression_stack_adjustment))) ||\n-            (is_top_frame && (exec_mode == Unpack_exception) && iframe->interpreter_frame_expression_stack_size() == 0) ||\n-            (is_top_frame && (exec_mode == Unpack_uncommon_trap || exec_mode == Unpack_reexecute || el->should_reexecute()) &&\n-             (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + cur_invoke_parameter_size))\n-            )) {\n-        {\n-          \/\/ Print out some information that will help us debug the problem\n-          tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n-          tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", i, cur_array->frames() - 1);\n-          tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n-          if (try_next_mask) {\n-            tty->print_cr(\"  Next code %s\", Bytecodes::name(next_code));\n-          }\n-          tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n-                        iframe->interpreter_frame_expression_stack_size());\n-          tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n-          tty->print_cr(\"  try_next_mask = %d\", try_next_mask);\n-          tty->print_cr(\"  next_mask_expression_stack_size = %d\", next_mask_expression_stack_size);\n-          tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n-          tty->print_cr(\"  callee_max_locals = %d\", callee_max_locals);\n-          tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n-          tty->print_cr(\"  exec_mode = %d\", exec_mode);\n-          tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n-          tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n-          tty->print_cr(\"  Interpreted frames:\");\n-          for (int k = 0; k < cur_array->frames(); k++) {\n-            vframeArrayElement* el = cur_array->element(k);\n-            tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n-          }\n-          cur_array->print_on_2(tty);\n+      int iframe_expr_size = iframe->interpreter_frame_expression_stack_size();\n+      int expr_stack_size_before = iframe_expr_size + (is_top_frame ? top_frame_expression_stack_adjustment : 0);\n+\n+      if (!(((is_top_frame && exec_mode == Unpack_exception) && iframe_expr_size == 0) ||\n+            (reexecute ?\n+             (expr_stack_size_before == mask.expression_stack_size() + cur_invoke_parameter_size) : (\n+            (iframe_expr_size == mask.expression_stack_size() + callee_size_of_parameters)\n+            ))))\n+      {\n+        \/\/ Print out some information that will help us debug the problem\n+        tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n+        tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", i, cur_array->frames() - 1);\n+        tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n+        tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n+                      iframe->interpreter_frame_expression_stack_size());\n+        tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n+        tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n+        tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n+        tty->print_cr(\"  exec_mode = %d\", exec_mode);\n+        tty->print_cr(\"  reexecute = %s\", reexecute ? \"true\" : \"false\");\n+        tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n+        tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n+        tty->print_cr(\"  Interpreted frames:\");\n+        for (int k = 0; k < cur_array->frames(); k++) {\n+          vframeArrayElement* el = cur_array->element(k);\n+          tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n@@ -1038,0 +1018,1 @@\n+        cur_array->print_on_2(tty);\n@@ -1043,1 +1024,0 @@\n-      callee_max_locals = mh->max_locals();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":59,"deletions":79,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  _reexecute = vf->should_reexecute();\n+  _reexecute = vf->should_reexecute(); \/\/ initial value, updated in unpack_on_stack\n@@ -174,1 +174,24 @@\n-int unpack_counter = 0;\n+static int unpack_counter = 0;\n+\n+bool vframeArrayElement::should_reexecute(bool is_top_frame, int exec_mode) const {\n+  if (is_top_frame) {\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      return true;\n+    default:\n+      break;\n+    }\n+  }\n+  if (raw_bci() == SynchronizationEntryBCI) {\n+    return true;\n+  }\n+  bool reexec = should_reexecute();\n+  assert(is_top_frame || reexec == false, \"unexepected should_reexecute()\");\n+  if (!reexec) {\n+    address bcp = method()->bcp_from(bci());\n+    Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+    assert(!Interpreter::bytecode_should_reexecute(code), \"should_reexecute mismatch\");\n+  }\n+  return reexec;\n+}\n@@ -194,0 +217,1 @@\n+  bool reexecute = should_reexecute(is_top_frame, exec_mode);\n@@ -198,1 +222,2 @@\n-  } else if (should_reexecute()) { \/\/reexecute this bytecode\n+    assert(reexecute, \"must be\");\n+  } else if (reexecute) { \/\/reexecute this bytecode\n@@ -201,1 +226,14 @@\n-    pc  = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+      \/\/ Do not special-case _athrow or _return_register_finalizer\n+      pc = Interpreter::deopt_entry(vtos, 0);\n+      break;\n+    case Deoptimization::Unpack_reexecute:\n+      pc = Interpreter::deopt_entry(vtos, 0);\n+      assert(pc == Interpreter::deopt_reexecute_entry(method(), bcp), \"athrow or return with Unpack_reexecute?\");\n+      break;\n+    default:\n+      \/\/ Yes, special-case _athrow and _return_register_finalizer\n+      pc = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    }\n+    assert(reexecute, \"must be\");\n@@ -204,0 +242,1 @@\n+    assert(!reexecute, \"must be\");\n@@ -242,0 +281,11 @@\n+#ifdef ASSERT\n+        Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+        assert(Bytecodes::is_invoke(code), \"must be\");\n+        assert(!reexecute, \"must be\");\n+        assert(use_next_mdp, \"must be\");\n+#endif\n+        \/\/ It would be nice if the VerifyStack logic in unpack_frames() was refactored so\n+        \/\/ we could check the stack before and after changing the reexecute mode, but\n+        \/\/ it should pass either way because an invoke uses the same stack state for both modes,\n+        \/\/ which is: args popped but result not yet pushed.\n+        reexecute = true;\n@@ -273,2 +323,4 @@\n-        pc  = Interpreter::deopt_entry(vtos, 0);\n-        use_next_mdp = false;\n+        assert(!use_next_mdp, \"must be\");\n+        assert(reexecute, \"must be\");\n+        \/\/ Was Interpreter::deopt_reexecute_entry()\n+        assert(pc == Interpreter::deopt_entry(vtos, 0), \"pc changed\");\n@@ -280,0 +332,2 @@\n+    assert(use_next_mdp == !reexecute, \"!\");\n+    _reexecute = reexecute;\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":60,"deletions":6,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  bool should_reexecute(bool is_top_frame, int exec_mode) const;\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}