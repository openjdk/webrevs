{"files":[{"patch":"@@ -1889,2 +1889,3 @@\n-         JavaThread::current()->thread_state() == _thread_in_vm,\n-         \"Java Thread is not running in vm\");\n+         JavaThread::current()->thread_state() == _thread_in_vm ||\n+         JavaThread::current() == java_lang_Thread::thread(java_thread),\n+         \"unsafe call to java_lang_Thread::get_thread_status()?\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -847,0 +847,1 @@\n+#ifdef ASSERT\n@@ -871,0 +872,1 @@\n+#endif\n@@ -935,1 +937,0 @@\n-    bool is_top_frame = true;\n@@ -937,3 +938,3 @@\n-    int callee_max_locals = 0;\n-    for (int i = 0; i < cur_array->frames(); i++) {\n-      vframeArrayElement* el = cur_array->element(i);\n+    for (int frame_idx = 0; frame_idx < cur_array->frames(); frame_idx++) {\n+      bool is_top_frame = (frame_idx == 0);\n+      vframeArrayElement* el = cur_array->element(frame_idx);\n@@ -942,0 +943,2 @@\n+      methodHandle mh(thread, iframe->interpreter_frame_method());\n+      bool reexecute = el->should_reexecute();\n@@ -943,2 +946,0 @@\n-      \/\/ Get the oop map for this bci\n-      InterpreterOopMap mask;\n@@ -946,2 +947,0 @@\n-      bool try_next_mask = false;\n-      int next_mask_expression_stack_size = -1;\n@@ -949,3 +948,0 @@\n-      methodHandle mh(thread, iframe->interpreter_frame_method());\n-      OopMapCache::compute_one_oop_map(mh, iframe->interpreter_frame_bci(), &mask);\n-      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n@@ -953,1 +949,29 @@\n-      \/\/ Get to the next bytecode if possible\n+      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n+      assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+      Bytecodes::Code cur_code = str.next();\n+\n+      if (!reexecute && !Bytecodes::is_invoke(cur_code)) {\n+        \/\/ We can only compute OopMaps for the before state, so we need to roll forward\n+        \/\/ to the next bytecode.\n+        assert(is_top_frame, \"must be\");\n+        assert(falls_through(cur_code), \"must be\");\n+        assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+        assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+        \/\/ Need to subtract off the size of the result type of\n+        \/\/ the bytecode because this is not described in the\n+        \/\/ debug info but returned to the interpreter in the TOS\n+        \/\/ caching register\n+        BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n+        if (bytecode_result_type != T_ILLEGAL) {\n+          top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n+        }\n+        assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n+\n+        cur_code = str.next();\n+        \/\/ Reflect the fact that we have rolled forward and now need\n+        \/\/ top_frame_expression_stack_adjustment\n+        reexecute = true;\n+      }\n+\n+      assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n@@ -955,0 +979,4 @@\n+\n+      \/\/ Get the oop map for this bci\n+      InterpreterOopMap mask;\n+      OopMapCache::compute_one_oop_map(mh, str.bci(), &mask);\n@@ -958,2 +986,0 @@\n-      Bytecodes::Code cur_code = str.next();\n-      Bytecodes::Code next_code = Bytecodes::_shouldnotreachhere;\n@@ -961,1 +987,1 @@\n-        Bytecode_invoke invoke(mh, iframe->interpreter_frame_bci());\n+        Bytecode_invoke invoke(mh, str.bci());\n@@ -963,1 +989,1 @@\n-        if (i != 0 && invoke.has_member_arg()) {\n+        if (!is_top_frame && invoke.has_member_arg()) {\n@@ -967,30 +993,0 @@\n-      if (str.bci() < max_bci) {\n-        next_code = str.next();\n-        if (next_code >= 0) {\n-          \/\/ The interpreter oop map generator reports results before\n-          \/\/ the current bytecode has executed except in the case of\n-          \/\/ calls. It seems to be hard to tell whether the compiler\n-          \/\/ has emitted debug information matching the \"state before\"\n-          \/\/ a given bytecode or the state after, so we try both\n-          if (!Bytecodes::is_invoke(cur_code) && falls_through(cur_code)) {\n-            \/\/ Get expression stack size for the next bytecode\n-            InterpreterOopMap next_mask;\n-            OopMapCache::compute_one_oop_map(mh, str.bci(), &next_mask);\n-            next_mask_expression_stack_size = next_mask.expression_stack_size();\n-            if (Bytecodes::is_invoke(next_code)) {\n-              Bytecode_invoke invoke(mh, str.bci());\n-              next_mask_expression_stack_size += invoke.size_of_parameters();\n-            }\n-            \/\/ Need to subtract off the size of the result type of\n-            \/\/ the bytecode because this is not described in the\n-            \/\/ debug info but returned to the interpreter in the TOS\n-            \/\/ caching register\n-            BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n-            if (bytecode_result_type != T_ILLEGAL) {\n-              top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n-            }\n-            assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n-            try_next_mask = true;\n-          }\n-        }\n-      }\n@@ -999,38 +995,26 @@\n-      \/\/ This assertion may be dependent on the platform we're running on and may need modification (tested on x86 and sparc)\n-      if (!(\n-            \/* SPARC *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_size_of_parameters) ||\n-            \/* x86 *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_max_locals) ||\n-            (try_next_mask &&\n-             (iframe->interpreter_frame_expression_stack_size() == (next_mask_expression_stack_size -\n-                                                                    top_frame_expression_stack_adjustment))) ||\n-            (is_top_frame && (exec_mode == Unpack_exception) && iframe->interpreter_frame_expression_stack_size() == 0) ||\n-            (is_top_frame && (exec_mode == Unpack_uncommon_trap || exec_mode == Unpack_reexecute || el->should_reexecute()) &&\n-             (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + cur_invoke_parameter_size))\n-            )) {\n-        {\n-          \/\/ Print out some information that will help us debug the problem\n-          tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n-          tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", i, cur_array->frames() - 1);\n-          tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n-          if (try_next_mask) {\n-            tty->print_cr(\"  Next code %s\", Bytecodes::name(next_code));\n-          }\n-          tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n-                        iframe->interpreter_frame_expression_stack_size());\n-          tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n-          tty->print_cr(\"  try_next_mask = %d\", try_next_mask);\n-          tty->print_cr(\"  next_mask_expression_stack_size = %d\", next_mask_expression_stack_size);\n-          tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n-          tty->print_cr(\"  callee_max_locals = %d\", callee_max_locals);\n-          tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n-          tty->print_cr(\"  exec_mode = %d\", exec_mode);\n-          tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n-          tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n-          tty->print_cr(\"  Interpreted frames:\");\n-          for (int k = 0; k < cur_array->frames(); k++) {\n-            vframeArrayElement* el = cur_array->element(k);\n-            tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n-          }\n-          cur_array->print_on_2(tty);\n+      int iframe_expr_ssize = iframe->interpreter_frame_expression_stack_size();\n+      int oopmap_expr_invoke_ssize = mask.expression_stack_size() + cur_invoke_parameter_size;\n+      int expr_ssize_before = iframe_expr_ssize + top_frame_expression_stack_adjustment;\n+      int oopmap_expr_callee_ssize = mask.expression_stack_size() + callee_size_of_parameters;\n+      if (!((is_top_frame && exec_mode == Unpack_exception && iframe_expr_ssize == 0) ||\n+            (reexecute ? expr_ssize_before == oopmap_expr_invoke_ssize :\n+                         iframe_expr_ssize == oopmap_expr_callee_ssize))) {\n+        \/\/ Print out some information that will help us debug the problem\n+        tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n+        tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", frame_idx, cur_array->frames() - 1);\n+        tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n+        tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n+                      iframe->interpreter_frame_expression_stack_size());\n+        tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n+        tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n+        tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n+        tty->print_cr(\"  exec_mode = %d\", exec_mode);\n+        tty->print_cr(\"  original should_reexecute = %s\", el->should_reexecute() ? \"true\" : \"false\");\n+        tty->print_cr(\"  reexecute = %s%s\", reexecute ? \"true\" : \"false\",\n+                      (reexecute != el->should_reexecute()) ? \" (changed)\" : \"\");\n+        tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n+        tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n+        tty->print_cr(\"  Interpreted frames:\");\n+        for (int k = 0; k < cur_array->frames(); k++) {\n+          vframeArrayElement* el = cur_array->element(k);\n+          tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n@@ -1038,0 +1022,1 @@\n+        cur_array->print_on_2(tty);\n@@ -1043,2 +1028,0 @@\n-      callee_max_locals = mh->max_locals();\n-      is_top_frame = false;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":69,"deletions":86,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  _reexecute = vf->should_reexecute();\n+  _reexecute = vf->should_reexecute(); \/\/ initial value, updated in unpack_on_stack\n@@ -174,1 +174,26 @@\n-int unpack_counter = 0;\n+static int unpack_counter = 0;\n+\n+bool vframeArrayElement::should_reexecute(bool is_top_frame, int exec_mode) const {\n+  if (is_top_frame) {\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      return true;\n+    default:\n+      break;\n+    }\n+  }\n+  if (raw_bci() == SynchronizationEntryBCI) {\n+    return true;\n+  }\n+  bool reexec = should_reexecute();\n+  assert(is_top_frame || reexec == false, \"unexepected should_reexecute()\");\n+#ifdef ASSERT\n+  if (!reexec) {\n+    address bcp = method()->bcp_from(bci());\n+    Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+    assert(!Interpreter::bytecode_should_reexecute(code), \"should_reexecute mismatch\");\n+  }\n+#endif\n+  return reexec;\n+}\n@@ -194,0 +219,1 @@\n+  bool reexecute = should_reexecute(is_top_frame, exec_mode);\n@@ -198,1 +224,2 @@\n-  } else if (should_reexecute()) { \/\/reexecute this bytecode\n+    assert(reexecute, \"must be\");\n+  } else if (reexecute) { \/\/reexecute this bytecode\n@@ -201,1 +228,13 @@\n-    pc  = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+      \/\/ Do not special-case _athrow or _return_register_finalizer\n+      pc = Interpreter::deopt_entry(vtos, 0);\n+      break;\n+    case Deoptimization::Unpack_reexecute:\n+      pc = Interpreter::deopt_entry(vtos, 0);\n+      assert(pc == Interpreter::deopt_reexecute_entry(method(), bcp), \"athrow or return with Unpack_reexecute?\");\n+      break;\n+    default:\n+      \/\/ Yes, special-case _athrow and _return_register_finalizer\n+      pc = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    }\n@@ -204,0 +243,1 @@\n+    assert(!reexecute, \"must be\");\n@@ -242,0 +282,11 @@\n+#ifdef ASSERT\n+        Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+        assert(Bytecodes::is_invoke(code), \"must be\");\n+        assert(!reexecute, \"must be\");\n+        assert(use_next_mdp, \"must be\");\n+#endif\n+        \/\/ It would be nice if the VerifyStack logic in unpack_frames() was refactored so\n+        \/\/ we could check the stack before and after changing the reexecute mode, but\n+        \/\/ it should pass either way because an invoke uses the same stack state for both modes,\n+        \/\/ which is: args popped but result not yet pushed.\n+        reexecute = true;\n@@ -273,2 +324,4 @@\n-        pc  = Interpreter::deopt_entry(vtos, 0);\n-        use_next_mdp = false;\n+        assert(!use_next_mdp, \"must be\");\n+        assert(reexecute, \"must be\");\n+        \/\/ Was Interpreter::deopt_reexecute_entry()\n+        assert(pc == Interpreter::deopt_entry(vtos, 0), \"pc changed\");\n@@ -280,0 +333,2 @@\n+    assert(use_next_mdp == !reexecute, \"!\");\n+    _reexecute = reexecute;\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":61,"deletions":6,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+  bool should_reexecute(bool is_top_frame, int exec_mode) const;\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}