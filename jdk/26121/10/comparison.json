{"files":[{"patch":"@@ -1889,2 +1889,3 @@\n-         JavaThread::current()->thread_state() == _thread_in_vm,\n-         \"Java Thread is not running in vm\");\n+         JavaThread::current()->thread_state() == _thread_in_vm ||\n+         JavaThread::current() == java_lang_Thread::thread(java_thread),\n+         \"unsafe call to java_lang_Thread::get_thread_status()?\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -564,1 +564,2 @@\n-    guarantee(expressions != nullptr && expressions->length() > 0, \"must have exception to throw\");\n+    guarantee(expressions != nullptr && expressions->length() == 1, \"should have only exception on stack\");\n+    guarantee(exec_mode != Unpack_exception, \"rethrow_exception set with Unpack_exception\");\n@@ -740,0 +741,1 @@\n+    assert(array->element(0)->rethrow_exception(), \"must be\");\n@@ -847,0 +849,1 @@\n+#ifdef ASSERT\n@@ -871,0 +874,1 @@\n+#endif\n@@ -935,1 +939,0 @@\n-    bool is_top_frame = true;\n@@ -937,3 +940,3 @@\n-    int callee_max_locals = 0;\n-    for (int i = 0; i < cur_array->frames(); i++) {\n-      vframeArrayElement* el = cur_array->element(i);\n+    for (int frame_idx = 0; frame_idx < cur_array->frames(); frame_idx++) {\n+      bool is_top_frame = (frame_idx == 0);\n+      vframeArrayElement* el = cur_array->element(frame_idx);\n@@ -942,0 +945,2 @@\n+      methodHandle mh(thread, iframe->interpreter_frame_method());\n+      bool reexecute = el->should_reexecute();\n@@ -943,2 +948,0 @@\n-      \/\/ Get the oop map for this bci\n-      InterpreterOopMap mask;\n@@ -946,2 +949,0 @@\n-      bool try_next_mask = false;\n-      int next_mask_expression_stack_size = -1;\n@@ -949,3 +950,0 @@\n-      methodHandle mh(thread, iframe->interpreter_frame_method());\n-      OopMapCache::compute_one_oop_map(mh, iframe->interpreter_frame_bci(), &mask);\n-      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n@@ -953,1 +951,1 @@\n-      \/\/ Get to the next bytecode if possible\n+      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n@@ -955,0 +953,32 @@\n+      Bytecodes::Code cur_code = str.next();\n+\n+      if (!reexecute && !Bytecodes::is_invoke(cur_code)) {\n+        \/\/ We can only compute OopMaps for the before state, so we need to roll forward\n+        \/\/ to the next bytecode.\n+        assert(is_top_frame, \"must be\");\n+        assert(falls_through(cur_code), \"must be\");\n+        assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+        assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+        \/\/ Need to subtract off the size of the result type of\n+        \/\/ the bytecode because this is not described in the\n+        \/\/ debug info but returned to the interpreter in the TOS\n+        \/\/ caching register\n+        BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n+        if (bytecode_result_type != T_ILLEGAL) {\n+          top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n+        }\n+        assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n+\n+        cur_code = str.next();\n+        \/\/ Reflect the fact that we have rolled forward and now need\n+        \/\/ top_frame_expression_stack_adjustment\n+        reexecute = true;\n+      }\n+\n+      assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+      assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+      \/\/ Get the oop map for this bci\n+      InterpreterOopMap mask;\n+      OopMapCache::compute_one_oop_map(mh, str.bci(), &mask);\n@@ -958,2 +988,0 @@\n-      Bytecodes::Code cur_code = str.next();\n-      Bytecodes::Code next_code = Bytecodes::_shouldnotreachhere;\n@@ -961,1 +989,1 @@\n-        Bytecode_invoke invoke(mh, iframe->interpreter_frame_bci());\n+        Bytecode_invoke invoke(mh, str.bci());\n@@ -963,1 +991,1 @@\n-        if (i != 0 && invoke.has_member_arg()) {\n+        if (!is_top_frame && invoke.has_member_arg()) {\n@@ -967,30 +995,0 @@\n-      if (str.bci() < max_bci) {\n-        next_code = str.next();\n-        if (next_code >= 0) {\n-          \/\/ The interpreter oop map generator reports results before\n-          \/\/ the current bytecode has executed except in the case of\n-          \/\/ calls. It seems to be hard to tell whether the compiler\n-          \/\/ has emitted debug information matching the \"state before\"\n-          \/\/ a given bytecode or the state after, so we try both\n-          if (!Bytecodes::is_invoke(cur_code) && falls_through(cur_code)) {\n-            \/\/ Get expression stack size for the next bytecode\n-            InterpreterOopMap next_mask;\n-            OopMapCache::compute_one_oop_map(mh, str.bci(), &next_mask);\n-            next_mask_expression_stack_size = next_mask.expression_stack_size();\n-            if (Bytecodes::is_invoke(next_code)) {\n-              Bytecode_invoke invoke(mh, str.bci());\n-              next_mask_expression_stack_size += invoke.size_of_parameters();\n-            }\n-            \/\/ Need to subtract off the size of the result type of\n-            \/\/ the bytecode because this is not described in the\n-            \/\/ debug info but returned to the interpreter in the TOS\n-            \/\/ caching register\n-            BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n-            if (bytecode_result_type != T_ILLEGAL) {\n-              top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n-            }\n-            assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n-            try_next_mask = true;\n-          }\n-        }\n-      }\n@@ -999,38 +997,43 @@\n-      \/\/ This assertion may be dependent on the platform we're running on and may need modification (tested on x86 and sparc)\n-      if (!(\n-            \/* SPARC *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_size_of_parameters) ||\n-            \/* x86 *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_max_locals) ||\n-            (try_next_mask &&\n-             (iframe->interpreter_frame_expression_stack_size() == (next_mask_expression_stack_size -\n-                                                                    top_frame_expression_stack_adjustment))) ||\n-            (is_top_frame && (exec_mode == Unpack_exception) && iframe->interpreter_frame_expression_stack_size() == 0) ||\n-            (is_top_frame && (exec_mode == Unpack_uncommon_trap || exec_mode == Unpack_reexecute || el->should_reexecute()) &&\n-             (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + cur_invoke_parameter_size))\n-            )) {\n-        {\n-          \/\/ Print out some information that will help us debug the problem\n-          tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n-          tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", i, cur_array->frames() - 1);\n-          tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n-          if (try_next_mask) {\n-            tty->print_cr(\"  Next code %s\", Bytecodes::name(next_code));\n-          }\n-          tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n-                        iframe->interpreter_frame_expression_stack_size());\n-          tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n-          tty->print_cr(\"  try_next_mask = %d\", try_next_mask);\n-          tty->print_cr(\"  next_mask_expression_stack_size = %d\", next_mask_expression_stack_size);\n-          tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n-          tty->print_cr(\"  callee_max_locals = %d\", callee_max_locals);\n-          tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n-          tty->print_cr(\"  exec_mode = %d\", exec_mode);\n-          tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n-          tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n-          tty->print_cr(\"  Interpreted frames:\");\n-          for (int k = 0; k < cur_array->frames(); k++) {\n-            vframeArrayElement* el = cur_array->element(k);\n-            tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n-          }\n-          cur_array->print_on_2(tty);\n+      auto match = [&]() {\n+        int iframe_expr_ssize = iframe->interpreter_frame_expression_stack_size();\n+#if INCLUDE_JVMCI\n+        if (is_top_frame && el->rethrow_exception()) {\n+          return iframe_expr_ssize == 1;\n+        }\n+#endif\n+        \/\/ This should only be needed for C1\n+        if (is_top_frame && exec_mode == Unpack_exception && iframe_expr_ssize == 0) {\n+          return true;\n+        }\n+        if (reexecute) {\n+          int expr_ssize_before = iframe_expr_ssize + top_frame_expression_stack_adjustment;\n+          int oopmap_expr_invoke_ssize = mask.expression_stack_size() + cur_invoke_parameter_size;\n+          return expr_ssize_before == oopmap_expr_invoke_ssize;\n+        } else {\n+          int oopmap_expr_callee_ssize = mask.expression_stack_size() + callee_size_of_parameters;\n+          return iframe_expr_ssize == oopmap_expr_callee_ssize;\n+        }\n+      };\n+      if (!match()) {\n+        \/\/ Print out some information that will help us debug the problem\n+        tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n+        tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", frame_idx, cur_array->frames() - 1);\n+        tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n+        tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n+                      iframe->interpreter_frame_expression_stack_size());\n+        tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n+        tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n+        tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n+        tty->print_cr(\"  exec_mode = %d\", exec_mode);\n+        tty->print_cr(\"  original should_reexecute = %s\", el->should_reexecute() ? \"true\" : \"false\");\n+        tty->print_cr(\"  reexecute = %s%s\", reexecute ? \"true\" : \"false\",\n+                      (reexecute != el->should_reexecute()) ? \" (changed)\" : \"\");\n+#if INCLUDE_JVMCI\n+        tty->print_cr(\"  rethrow_exception = %s\", el->rethrow_exception() ? \"true\" : \"false\");\n+#endif\n+        tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n+        tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n+        tty->print_cr(\"  Interpreted frames:\");\n+        for (int k = 0; k < cur_array->frames(); k++) {\n+          vframeArrayElement* el = cur_array->element(k);\n+          tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n@@ -1038,0 +1041,1 @@\n+        cur_array->print_on_2(tty);\n@@ -1043,2 +1047,0 @@\n-      callee_max_locals = mh->max_locals();\n-      is_top_frame = false;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":89,"deletions":87,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/scopeDesc.hpp\"\n@@ -64,1 +65,4 @@\n-  _reexecute = vf->should_reexecute();\n+  _reexecute = vf->should_reexecute(); \/\/ initial value, updated in unpack_on_stack\n+#if INCLUDE_JVMCI\n+  _rethrow = vf->scope()->rethrow_exception();\n+#endif\n@@ -174,1 +178,28 @@\n-int unpack_counter = 0;\n+static int unpack_counter = 0;\n+\n+bool vframeArrayElement::should_reexecute(bool is_top_frame, int exec_mode) const {\n+  if (is_top_frame) {\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      return true;\n+    case Deoptimization::Unpack_exception:\n+      assert(raw_bci() >= 0, \"bad bci %d for Unpack_exception\", raw_bci());\n+    default:\n+      break;\n+    }\n+  }\n+  if (raw_bci() == SynchronizationEntryBCI) {\n+    return true;\n+  }\n+  bool reexec = should_reexecute();\n+  assert(is_top_frame || reexec == false, \"unexepected should_reexecute()\");\n+#ifdef ASSERT\n+  if (!reexec) {\n+    address bcp = method()->bcp_from(bci());\n+    Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+    assert(!Interpreter::bytecode_should_reexecute(code), \"should_reexecute mismatch\");\n+  }\n+#endif\n+  return reexec;\n+}\n@@ -192,3 +223,12 @@\n-  bool use_next_mdp = false; \/\/ true if we should use the mdp associated with the next bci\n-                             \/\/ rather than the one associated with bcp\n-  if (raw_bci() == SynchronizationEntryBCI) {\n+  bool reexecute = should_reexecute(is_top_frame, exec_mode);\n+  if (is_top_frame && exec_mode == Deoptimization::Unpack_exception) {\n+#if 1\n+    assert(raw_bci() >= 0, \"bad bci %d for Unpack_exception\", raw_bci());\n+#endif\n+    bcp = method()->bcp_from(bci());\n+    \/\/ exception is pending\n+    pc = Interpreter::rethrow_exception_entry();\n+    \/\/ [phh] We're going to end up in some handler or other, so it doesn't\n+    \/\/ matter what mdp we point to.  See exception_handler_for_exception()\n+    \/\/ in interpreterRuntime.cpp.\n+  } else if (raw_bci() == SynchronizationEntryBCI) {\n@@ -198,1 +238,2 @@\n-  } else if (should_reexecute()) { \/\/reexecute this bytecode\n+    assert(reexecute, \"must be\");\n+  } else if (reexecute) { \/\/reexecute this bytecode\n@@ -201,1 +242,10 @@\n-    pc  = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      \/\/ Do not special-case _athrow or _return_register_finalizer\n+      pc = Interpreter::deopt_entry(vtos, 0);\n+      break;\n+    default:\n+      \/\/ Yes, special-case _athrow and _return_register_finalizer\n+      pc = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    }\n@@ -204,0 +254,1 @@\n+    assert(!reexecute, \"must be\");\n@@ -205,1 +256,0 @@\n-    use_next_mdp = true;\n@@ -236,0 +286,3 @@\n+#if 1\n+      assert(exec_mode != Deoptimization::Unpack_exception, \"TODO\");\n+#endif\n@@ -242,1 +295,10 @@\n-        use_next_mdp = false;\n+#ifdef ASSERT\n+        Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+        assert(Bytecodes::is_invoke(code), \"must be\");\n+        assert(!reexecute, \"must be\");\n+#endif\n+        \/\/ It would be nice if the VerifyStack logic in unpack_frames() was refactored so\n+        \/\/ we could check the stack before and after changing the reexecute mode, but\n+        \/\/ it should pass either way because an invoke uses the same stack state for both modes,\n+        \/\/ which is: args popped but result not yet pushed.\n+        reexecute = true;\n@@ -248,6 +310,8 @@\n-    } else if (!realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr &&\n-               state->is_earlyret_pending()) {\n-      \/\/ Force early return from top frame after deoptimization\n-      pc = Interpreter::remove_activation_early_entry(state->earlyret_tos());\n-    } else {\n-      if (realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr && state->is_earlyret_pending()) {\n+    } else if (JvmtiExport::can_force_early_return() && state != nullptr && state->is_earlyret_pending()) {\n+#if 1\n+      assert(exec_mode != Deoptimization::Unpack_exception, \"TODO\");\n+#endif\n+      if (!realloc_failure_exception) {\n+        \/\/ Force early return from top frame after deoptimization\n+        pc = Interpreter::remove_activation_early_entry(state->earlyret_tos());\n+      } else {\n@@ -258,21 +322,0 @@\n-      \/\/ Possibly override the previous pc computation of the top (youngest) frame\n-      switch (exec_mode) {\n-      case Deoptimization::Unpack_deopt:\n-        \/\/ use what we've got\n-        break;\n-      case Deoptimization::Unpack_exception:\n-        \/\/ exception is pending\n-        pc = SharedRuntime::raw_exception_handler_for_return_address(thread, pc);\n-        \/\/ [phh] We're going to end up in some handler or other, so it doesn't\n-        \/\/ matter what mdp we point to.  See exception_handler_for_exception()\n-        \/\/ in interpreterRuntime.cpp.\n-        break;\n-      case Deoptimization::Unpack_uncommon_trap:\n-      case Deoptimization::Unpack_reexecute:\n-        \/\/ redo last byte code\n-        pc  = Interpreter::deopt_entry(vtos, 0);\n-        use_next_mdp = false;\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-      }\n@@ -280,0 +323,1 @@\n+    _reexecute = reexecute;\n@@ -320,3 +364,0 @@\n-  if (ProfileInterpreter) {\n-    iframe()->interpreter_frame_set_mdp(nullptr); \/\/ clear out the mdp.\n-  }\n@@ -326,1 +367,1 @@\n-    if (mdo != nullptr) {\n+    if (mdo != nullptr && exec_mode != Deoptimization::Unpack_exception) {\n@@ -328,1 +369,1 @@\n-      if (use_next_mdp) ++bci;\n+      if (!reexecute) ++bci;\n@@ -331,0 +372,2 @@\n+    } else {\n+      iframe()->interpreter_frame_set_mdp(nullptr); \/\/ clear out the mdp.\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":84,"deletions":41,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,3 @@\n+#if INCLUDE_JVMCI\n+    bool _rethrow;                                               \/\/ from ScopeDesc::rethrow_exception()\n+#endif\n@@ -74,0 +77,1 @@\n+  bool should_reexecute(bool is_top_frame, int exec_mode) const;\n@@ -75,0 +79,3 @@\n+#if INCLUDE_JVMCI\n+  bool rethrow_exception(void) const  { return _rethrow; }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}