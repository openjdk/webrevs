[{"commit":{"message":"Merge master and fix conflicts"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/share\/opto\/vectornode.cpp"},{"filename":"src\/hotspot\/share\/opto\/vectornode.hpp"},{"filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"}],"sha":"639cf06899ebda126059c2d723af026342c25c88"},{"commit":{"message":"8301012: [vectorapi]: Intrinsify CompressBitsV\/ExpandBitsV and add the AArch64 SVE backend implementation\n\nThis patch adds mid-end compiler vector IR nodes for the scalar\nCompressBits and ExpandBits nodes - CompressBitsV and ExpandBitsV and\nalso adds aarch64 backend support for these nodes using SVE2\ninstructions (included in the svebitperm feature).\nAs there are direct instructions in SVE2 that map to these operations,\na huge speed up in performance can be observed and it might significantly\nbenefit all those workloads that extensively run these operations on an\nSVE2(with svebitperm feature) supporting machine.\n\nAll the JTREG tests under \"test\/jdk\/jdk\/incubator\/vector\" pass\nsuccessfully with this patch on an SVE2 machine.\nThe JMH tests - COMPRESS_BITS and EXPAND_BITS from [1] and [2]\nwere run on a 128-bit vector length, SVE2 and svebitperm supporting\naarch64 machine. Following are the gains observed with this patch -\n\nBenchmark                       (length)  Mode    Cnt   Gain\nIntMaxVector.COMPRESS_BITS      1024      thrpt   15    81.68x\nIntMaxVector.EXPAND_BITS        1024      thrpt   15    85.65x\nLongMaxVector.COMPRESS_BITS     1024      thrpt   15    70.78x\nLongMaxVector.EXPAND_BITS       1024      thrpt   15    76.31x\n\nThe \"Gain\" column is the ratio between the throughput of benchmark runs\nwith this patch and that of benchmark runs without this patch. This patch\ndoes not change the performance of these operations for all other\nmachines that do not support these instructions or when run on a\ndifferent architecture.\nWith this patch, vectorization of CompressBits and ExpandBits operations\nhappens only through vectorapi for aarch64. Autovectorization does not\ntake place as the current JDK source does not contain aarch64 backend\nimplementation for scalar CompressBits and ExpandBits. However, this PR -\nhttps:\/\/github.com\/openjdk\/jdk\/pull\/10537 adds aarch64 backend\nimplementaton for CompressBits and ExpandBits and may lead to\nautovectorization of these nodes as well eventually but this PR is a\nstandalone one and not dependent on the scalar implementation.\n\n[1] https:\/\/github.com\/openjdk\/panama-vector\/blob\/vectorIntrinsics\/test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java\n[2] https:\/\/github.com\/openjdk\/panama-vector\/blob\/vectorIntrinsics\/test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/share\/adlc\/formssel.cpp"},{"filename":"src\/hotspot\/share\/opto\/classes.hpp"},{"filename":"src\/hotspot\/share\/opto\/vectornode.cpp"},{"filename":"src\/hotspot\/share\/opto\/vectornode.hpp"},{"filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorCompressExpandBits.java"}],"sha":"282746147900d01d19aaf5d48f0c161b74256c94"}]