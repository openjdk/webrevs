{"files":[{"patch":"@@ -4079,20 +4079,0 @@\n-    \/\/ If the loader is not the boot loader then throw an exception if its\n-    \/\/ superclass is in package jdk.internal.reflect and its loader is not a\n-    \/\/ special reflection class loader\n-    if (!this_klass->class_loader_data()->is_the_null_class_loader_data()) {\n-      PackageEntry* super_package = super->package();\n-      if (super_package != nullptr &&\n-          super_package->name()->fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &&\n-          !java_lang_ClassLoader::is_reflection_class_loader(this_klass->class_loader())) {\n-        ResourceMark rm(THREAD);\n-        Exceptions::fthrow(\n-          THREAD_AND_LOCATION,\n-          vmSymbols::java_lang_IllegalAccessError(),\n-          \"class %s loaded by %s cannot access jdk\/internal\/reflect superclass %s\",\n-          this_klass->external_name(),\n-          this_klass->class_loader_data()->loader_name_and_id(),\n-          super->external_name());\n-        return;\n-      }\n-    }\n-\n@@ -5109,1 +5089,1 @@\n-  Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));\n+  Handle clh = Handle(THREAD, cl);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -647,2 +647,0 @@\n-  } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n-    size = 1;  \/\/ there's only one class in relection class loader and no initiated classes\n@@ -818,2 +816,0 @@\n-      } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n-        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4766,3 +4766,0 @@\n-  \/\/ Fix for 4474172; see evaluation for more details\n-  loader = non_reflection_class_loader(loader);\n-\n@@ -4777,23 +4774,0 @@\n-\/\/ Return true if this is one of the class loaders associated with\n-\/\/ the generated bytecodes for serialization constructor returned\n-\/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n-bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {\n-  if (loader != nullptr) {\n-    Klass* delegating_cl_class = vmClasses::reflect_DelegatingClassLoader_klass();\n-    \/\/ This might be null in non-1.4 JDKs\n-    return (delegating_cl_class != nullptr && loader->is_a(delegating_cl_class));\n-  }\n-  return false;\n-}\n-\n-oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {\n-  \/\/ See whether this is one of the class loaders associated with\n-  \/\/ the generated bytecodes for reflection, and if so, \"magically\"\n-  \/\/ delegate to its parent to prevent class loading from occurring\n-  \/\/ in places where applications using reflection didn't expect it.\n-  if (is_reflection_class_loader(loader)) {\n-    return parent(loader);\n-  }\n-  return loader;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1505,8 +1505,0 @@\n-  \/\/ Return true if this is one of the class loaders associated with\n-  \/\/ the generated bytecodes for serialization constructor returned\n-  \/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n-  static bool is_reflection_class_loader(oop loader);\n-\n-  \/\/ Fix for 4474172\n-  static oop  non_reflection_class_loader(oop loader);\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -312,5 +312,0 @@\n-  \/\/ Make sure loader is not the jdk.internal.reflect.DelegatingClassLoader.\n-  if (loader != java_lang_ClassLoader::non_reflection_class_loader(loader)) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Class loader is an invalid delegating class loader\");\n-  }\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -601,2 +601,0 @@\n-  \/\/ Fix for 4474172; see evaluation for more details\n-  class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n@@ -768,6 +766,1 @@\n-  \/\/ The result of this call should be consistent with the result\n-  \/\/ of the call to resolve_instance_class_or_null().\n-  \/\/ See evaluation 6790209 and 4474172 for more details.\n-  oop class_loader_oop = java_lang_ClassLoader::non_reflection_class_loader(class_loader());\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader_oop);\n-\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -406,3 +406,0 @@\n-      \/\/ Fix for 4474172; see evaluation for more details\n-      class_loader = Handle(\n-        THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -278,4 +278,0 @@\n-  Klass* refl_serialization_ctor_klass = vmClasses::reflect_SerializationConstructorAccessorImpl_klass();\n-\n-  bool is_reflect_accessor = refl_serialization_ctor_klass != nullptr &&\n-                                klass->is_subtype_of(refl_serialization_ctor_klass);\n@@ -298,6 +294,1 @@\n-    !(klass->is_shared() && klass->is_rewritten()) &&\n-\n-    \/\/ As of the fix for 4486457 we disable verification for all of the\n-    \/\/ dynamically-generated bytecodes associated with\n-    \/\/ jdk\/internal\/reflect\/SerializationConstructorAccessor.\n-    (!is_reflect_accessor));\n+    !(klass->is_shared() && klass->is_rewritten()));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-  do_klass(reflect_DelegatingClassLoader_klass,         reflect_DelegatingClassLoader                         ) \\\n@@ -114,1 +113,0 @@\n-  do_klass(reflect_SerializationConstructorAccessorImpl_klass,           reflect_SerializationConstructorAccessorImpl ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,0 @@\n-  template(reflect_DelegatingClassLoader,             \"jdk\/internal\/reflect\/DelegatingClassLoader\")   \\\n@@ -270,1 +269,0 @@\n-  template(reflect_SerializationConstructorAccessorImpl,             \"jdk\/internal\/reflect\/SerializationConstructorAccessorImpl\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1203,7 +1203,1 @@\n-    \/\/ Disable verification for the dynamically-generated reflection bytecodes\n-    \/\/ for serialization constructor accessor.\n-    bool is_reflect = klass_to_check->is_subclass_of(\n-                        vmClasses::reflect_SerializationConstructorAccessorImpl_klass());\n-\n-    if (!is_reflect &&\n-        !klass_to_check->is_same_or_direct_interface(resolved_klass)) {\n+    if (!klass_to_check->is_same_or_direct_interface(resolved_klass)) {\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3281,4 +3281,1 @@\n-      \/\/ Skip reflection related frames\n-      if (!ik->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-        return JNIHandles::make_local(THREAD, loader);\n-      }\n+      return JNIHandles::make_local(THREAD, loader);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -451,6 +451,0 @@\n-  \/\/ Allow all accesses from jdk\/internal\/reflect\/SerializationConstructorAccessorImpl subclasses to\n-  \/\/ succeed trivially.\n-  if (vmClasses::reflect_SerializationConstructorAccessorImpl_klass_is_loaded() &&\n-      current_class->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-    return ACCESS_OK;\n-  }\n@@ -661,6 +655,0 @@\n-  \/\/ Allow all accesses from jdk\/internal\/reflect\/SerializationConstructorAccessorImpl subclasses to\n-  \/\/ succeed trivially.\n-  if (current_class->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,722 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.lang.reflect.*;\n-import jdk.internal.misc.Unsafe;\n-\n-\/** Shared functionality for all accessor generators *\/\n-\n-class AccessorGenerator implements ClassFileConstants {\n-    static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    \/\/ Constants because there's no way to say \"short integer constant\",\n-    \/\/ i.e., \"1S\"\n-    protected static final short S0 = (short) 0;\n-    protected static final short S1 = (short) 1;\n-    protected static final short S2 = (short) 2;\n-    protected static final short S3 = (short) 3;\n-    protected static final short S4 = (short) 4;\n-    protected static final short S5 = (short) 5;\n-    protected static final short S6 = (short) 6;\n-\n-    \/\/ Instance variables for shared functionality\n-    protected ClassFileAssembler asm;\n-    protected int   modifiers;\n-    protected short thisClass;\n-    protected short superClass;\n-    protected short targetClass;\n-    \/\/ Common constant pool entries to FieldAccessor and MethodAccessor\n-    protected short throwableClass;\n-    protected short classCastClass;\n-    protected short nullPointerClass;\n-    protected short illegalArgumentClass;\n-    protected short invocationTargetClass;\n-    protected short initIdx;\n-    protected short initNameAndTypeIdx;\n-    protected short initStringNameAndTypeIdx;\n-    protected short nullPointerCtorIdx;\n-    protected short illegalArgumentCtorIdx;\n-    protected short illegalArgumentStringCtorIdx;\n-    protected short invocationTargetCtorIdx;\n-    protected short superCtorIdx;\n-    protected short objectClass;\n-    protected short toStringIdx;\n-    protected short codeIdx;\n-    protected short exceptionsIdx;\n-    \/\/ Boxing\n-    protected short valueOfIdx;\n-    protected short booleanIdx;\n-    protected short booleanBoxIdx;\n-    protected short booleanUnboxIdx;\n-    protected short byteIdx;\n-    protected short byteBoxIdx;\n-    protected short byteUnboxIdx;\n-    protected short characterIdx;\n-    protected short characterBoxIdx;\n-    protected short characterUnboxIdx;\n-    protected short doubleIdx;\n-    protected short doubleBoxIdx;\n-    protected short doubleUnboxIdx;\n-    protected short floatIdx;\n-    protected short floatBoxIdx;\n-    protected short floatUnboxIdx;\n-    protected short integerIdx;\n-    protected short integerBoxIdx;\n-    protected short integerUnboxIdx;\n-    protected short longIdx;\n-    protected short longBoxIdx;\n-    protected short longUnboxIdx;\n-    protected short shortIdx;\n-    protected short shortBoxIdx;\n-    protected short shortUnboxIdx;\n-\n-    protected final short NUM_COMMON_CPOOL_ENTRIES = (short) 30;\n-    protected final short NUM_BOXING_CPOOL_ENTRIES = (short) 73;\n-\n-    \/\/ Requires that superClass has been set up\n-    protected void emitCommonConstantPoolEntries() {\n-        \/\/ +   [UTF-8] \"java\/lang\/Throwable\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/ClassCastException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/NullPointerException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/IllegalArgumentException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/InvocationTargetException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"<init>\"\n-        \/\/ +   [UTF-8] \"()V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for above\n-        \/\/ +   [CONSTANT_Methodref_info] for NullPointerException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for InvocationTargetException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for \"super()\"\n-        \/\/ +   [UTF-8] \"java\/lang\/Object\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"toString\"\n-        \/\/ +   [UTF-8] \"()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"toString()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_Methodref_info] for Object's toString method\n-        \/\/ +   [UTF-8] \"Code\"\n-        \/\/ +   [UTF-8] \"Exceptions\"\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Throwable\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        throwableClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/ClassCastException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        classCastClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/NullPointerException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        nullPointerClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/IllegalArgumentException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        illegalArgumentClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/reflect\/InvocationTargetException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        invocationTargetClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"<init>\");\n-        initIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"()V\");\n-        asm.emitConstantPoolNameAndType(initIdx, asm.cpi());\n-        initNameAndTypeIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(nullPointerClass, initNameAndTypeIdx);\n-        nullPointerCtorIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(illegalArgumentClass, initNameAndTypeIdx);\n-        illegalArgumentCtorIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(Ljava\/lang\/String;)V\");\n-        asm.emitConstantPoolNameAndType(initIdx, asm.cpi());\n-        initStringNameAndTypeIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(illegalArgumentClass, initStringNameAndTypeIdx);\n-        illegalArgumentStringCtorIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(Ljava\/lang\/Throwable;)V\");\n-        asm.emitConstantPoolNameAndType(initIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(invocationTargetClass, asm.cpi());\n-        invocationTargetCtorIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(superClass, initNameAndTypeIdx);\n-        superCtorIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Object\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        objectClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"toString\");\n-        asm.emitConstantPoolUTF8(\"()Ljava\/lang\/String;\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(objectClass, asm.cpi());\n-        toStringIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"Code\");\n-        codeIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"Exceptions\");\n-        exceptionsIdx = asm.cpi();\n-    }\n-\n-    \/** Constant pool entries required to be able to box\/unbox primitive\n-        types. Note that we don't emit these if we don't need them. *\/\n-    protected void emitBoxingContantPoolEntries() {\n-        \/\/  *  [UTF-8] \"valueOf\"\n-        \/\/  *  [UTF-8] \"java\/lang\/Boolean\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(Z)Ljava\/lang\/Boolean;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"booleanValue\"\n-        \/\/  *  [UTF-8] \"()Z\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Byte\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(B)Ljava\/lang\/Byte;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"byteValue\"\n-        \/\/  *  [UTF-8] \"()B\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Character\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(C)Ljava\/lang\/Character;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"charValue\"\n-        \/\/  *  [UTF-8] \"()C\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Double\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(D)Ljava\/lang\/Double;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"doubleValue\"\n-        \/\/  *  [UTF-8] \"()D\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Float\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(F)Ljava\/lang\/Float;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"floatValue\"\n-        \/\/  *  [UTF-8] \"()F\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Integer\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(I)Ljava\/lang\/Integer;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"intValue\"\n-        \/\/  *  [UTF-8] \"()I\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Long\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(J)Ljava\/lang\/Long;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"longValue\"\n-        \/\/  *  [UTF-8] \"()J\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Short\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(S)Ljava\/lang\/Short;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"shortValue\"\n-        \/\/  *  [UTF-8] \"()S\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-\n-        \/\/ valueOf-method name\n-        asm.emitConstantPoolUTF8(\"valueOf\");\n-        valueOfIdx = asm.cpi();\n-\n-        \/\/ Boolean\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Boolean\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        booleanIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(Z)Ljava\/lang\/Boolean;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        booleanBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"booleanValue\");\n-        asm.emitConstantPoolUTF8(\"()Z\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        booleanUnboxIdx = asm.cpi();\n-\n-        \/\/ Byte\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Byte\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        byteIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(B)Ljava\/lang\/Byte;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        byteBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"byteValue\");\n-        asm.emitConstantPoolUTF8(\"()B\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        byteUnboxIdx = asm.cpi();\n-\n-        \/\/ Character\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Character\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        characterIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(C)Ljava\/lang\/Character;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        characterBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"charValue\");\n-        asm.emitConstantPoolUTF8(\"()C\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        characterUnboxIdx = asm.cpi();\n-\n-        \/\/ Double\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Double\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        doubleIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(D)Ljava\/lang\/Double;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        doubleBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"doubleValue\");\n-        asm.emitConstantPoolUTF8(\"()D\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        doubleUnboxIdx = asm.cpi();\n-\n-        \/\/ Float\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Float\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        floatIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(F)Ljava\/lang\/Float;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        floatBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"floatValue\");\n-        asm.emitConstantPoolUTF8(\"()F\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        floatUnboxIdx = asm.cpi();\n-\n-        \/\/ Integer\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Integer\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        integerIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(I)Ljava\/lang\/Integer;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        integerBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"intValue\");\n-        asm.emitConstantPoolUTF8(\"()I\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        integerUnboxIdx = asm.cpi();\n-\n-        \/\/ Long\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Long\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        longIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(J)Ljava\/lang\/Long;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        longBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"longValue\");\n-        asm.emitConstantPoolUTF8(\"()J\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        longUnboxIdx = asm.cpi();\n-\n-        \/\/ Short\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Short\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        shortIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(S)Ljava\/lang\/Short;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        shortBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"shortValue\");\n-        asm.emitConstantPoolUTF8(\"()S\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        shortUnboxIdx = asm.cpi();\n-    }\n-\n-    \/\/ Necessary because of Java's annoying promotion rules\n-    protected static short add(short s1, short s2) {\n-        return (short) (s1 + s2);\n-    }\n-\n-    protected static short sub(short s1, short s2) {\n-        return (short) (s1 - s2);\n-    }\n-\n-    protected boolean isStatic() {\n-        return Modifier.isStatic(modifiers);\n-    }\n-\n-    protected boolean isPrivate() {\n-        return Modifier.isPrivate(modifiers);\n-    }\n-\n-    \/** Returns class name in \"internal\" form (i.e., '\/' separators\n-        instead of '.') *\/\n-    protected static String getClassName\n-        (Class<?> c, boolean addPrefixAndSuffixForNonPrimitiveTypes)\n-    {\n-        if (c.isPrimitive()) {\n-            if (c == Boolean.TYPE) {\n-                return \"Z\";\n-            } else if (c == Byte.TYPE) {\n-                return \"B\";\n-            } else if (c == Character.TYPE) {\n-                return \"C\";\n-            } else if (c == Double.TYPE) {\n-                return \"D\";\n-            } else if (c == Float.TYPE) {\n-                return \"F\";\n-            } else if (c == Integer.TYPE) {\n-                return \"I\";\n-            } else if (c == Long.TYPE) {\n-                return \"J\";\n-            } else if (c == Short.TYPE) {\n-                return \"S\";\n-            } else if (c == Void.TYPE) {\n-                return \"V\";\n-            }\n-            throw new InternalError(\"Should have found primitive type\");\n-        } else if (c.isArray()) {\n-            return \"[\" + getClassName(c.getComponentType(), true);\n-        } else {\n-            if (addPrefixAndSuffixForNonPrimitiveTypes) {\n-                return internalize(\"L\" + c.getName() + \";\");\n-            } else {\n-                return internalize(c.getName());\n-            }\n-        }\n-    }\n-\n-    private static String internalize(String className) {\n-        return className.replace('.', '\/');\n-    }\n-\n-    protected void emitConstructor() {\n-        \/\/ Generate code into fresh code buffer\n-        ClassFileAssembler cb = new ClassFileAssembler();\n-        \/\/ 0 incoming arguments\n-        cb.setMaxLocals(1);\n-        cb.opc_aload_0();\n-        cb.opc_invokespecial(superCtorIdx, 0, 0);\n-        cb.opc_return();\n-\n-        \/\/ Emit method\n-        emitMethod(initIdx, cb.getMaxLocals(), cb, null, null);\n-    }\n-\n-    \/\/ The descriptor's index in the constant pool must be (1 +\n-    \/\/ nameIdx). \"numArgs\" must indicate ALL arguments, including the\n-    \/\/ implicit \"this\" argument; double and long arguments each count\n-    \/\/ as 2 in this count. The code buffer must NOT contain the code\n-    \/\/ length. The exception table may be null, but if non-null must\n-    \/\/ NOT contain the exception table's length. The checked exception\n-    \/\/ indices may be null.\n-    protected void emitMethod(short nameIdx,\n-                              int numArgs,\n-                              ClassFileAssembler code,\n-                              ClassFileAssembler exceptionTable,\n-                              short[] checkedExceptionIndices)\n-    {\n-        int codeLen = code.getLength();\n-        int excLen  = 0;\n-        if (exceptionTable != null) {\n-            excLen = exceptionTable.getLength();\n-            if ((excLen % 8) != 0) {\n-                throw new IllegalArgumentException(\"Illegal exception table\");\n-            }\n-        }\n-        int attrLen = 12 + codeLen + excLen;\n-        excLen = excLen \/ 8; \/\/ No-op if no exception table\n-\n-        asm.emitShort(ACC_PUBLIC);\n-        asm.emitShort(nameIdx);\n-        asm.emitShort(add(nameIdx, S1));\n-        if (checkedExceptionIndices == null) {\n-            \/\/ Code attribute only\n-            asm.emitShort(S1);\n-        } else {\n-            \/\/ Code and Exceptions attributes\n-            asm.emitShort(S2);\n-        }\n-        \/\/ Code attribute\n-        asm.emitShort(codeIdx);\n-        asm.emitInt(attrLen);\n-        asm.emitShort(code.getMaxStack());\n-        asm.emitShort((short) Math.max(numArgs, code.getMaxLocals()));\n-        asm.emitInt(codeLen);\n-        asm.append(code);\n-        asm.emitShort((short) excLen);\n-        if (exceptionTable != null) {\n-            asm.append(exceptionTable);\n-        }\n-        asm.emitShort(S0); \/\/ No additional attributes for Code attribute\n-        if (checkedExceptionIndices != null) {\n-            \/\/ Exceptions attribute\n-            asm.emitShort(exceptionsIdx);\n-            asm.emitInt(2 + 2 * checkedExceptionIndices.length);\n-            asm.emitShort((short) checkedExceptionIndices.length);\n-            for (int i = 0; i < checkedExceptionIndices.length; i++) {\n-                asm.emitShort(checkedExceptionIndices[i]);\n-            }\n-        }\n-    }\n-\n-    protected short indexForPrimitiveType(Class<?> type) {\n-        if (type == Boolean.TYPE) {\n-            return booleanIdx;\n-        } else if (type == Byte.TYPE) {\n-            return byteIdx;\n-        } else if (type == Character.TYPE) {\n-            return characterIdx;\n-        } else if (type == Double.TYPE) {\n-            return doubleIdx;\n-        } else if (type == Float.TYPE) {\n-            return floatIdx;\n-        } else if (type == Integer.TYPE) {\n-            return integerIdx;\n-        } else if (type == Long.TYPE) {\n-            return longIdx;\n-        } else if (type == Short.TYPE) {\n-            return shortIdx;\n-        }\n-        throw new InternalError(\"Should have found primitive type\");\n-    }\n-\n-    protected short boxingMethodForPrimitiveType(Class<?> type) {\n-        if (type == Boolean.TYPE) {\n-            return booleanBoxIdx;\n-        } else if (type == Byte.TYPE) {\n-            return byteBoxIdx;\n-        } else if (type == Character.TYPE) {\n-            return characterBoxIdx;\n-        } else if (type == Double.TYPE) {\n-            return doubleBoxIdx;\n-        } else if (type == Float.TYPE) {\n-            return floatBoxIdx;\n-        } else if (type == Integer.TYPE) {\n-            return integerBoxIdx;\n-        } else if (type == Long.TYPE) {\n-            return longBoxIdx;\n-        } else if (type == Short.TYPE) {\n-            return shortBoxIdx;\n-        }\n-        throw new InternalError(\"Should have found primitive type\");\n-    }\n-\n-    \/** Returns true for widening or identity conversions for primitive\n-        types only *\/\n-    protected static boolean canWidenTo(Class<?> type, Class<?> otherType) {\n-        if (!type.isPrimitive()) {\n-            return false;\n-        }\n-\n-        \/\/ Widening conversions (from JVM spec):\n-        \/\/  byte to short, int, long, float, or double\n-        \/\/  short to int, long, float, or double\n-        \/\/  char to int, long, float, or double\n-        \/\/  int to long, float, or double\n-        \/\/  long to float or double\n-        \/\/  float to double\n-\n-        if (type == Boolean.TYPE) {\n-            if (otherType == Boolean.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Byte.TYPE) {\n-            if (   otherType == Byte.TYPE\n-                   || otherType == Short.TYPE\n-                   || otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Short.TYPE) {\n-            if (   otherType == Short.TYPE\n-                   || otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Character.TYPE) {\n-            if (   otherType == Character.TYPE\n-                   || otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Integer.TYPE) {\n-            if (   otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Long.TYPE) {\n-            if (   otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Float.TYPE) {\n-            if (   otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Double.TYPE) {\n-            if (otherType == Double.TYPE) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    \/** Emits the widening bytecode for the given primitive conversion\n-        (or none if the identity conversion). Requires that a primitive\n-        conversion exists; i.e., canWidenTo must have already been\n-        called and returned true. *\/\n-    protected static void emitWideningBytecodeForPrimitiveConversion\n-        (ClassFileAssembler cb,\n-         Class<?> fromType,\n-         Class<?> toType)\n-    {\n-        \/\/ Note that widening conversions for integral types (i.e., \"b2s\",\n-        \/\/ \"s2i\") are no-ops since values on the Java stack are\n-        \/\/ sign-extended.\n-\n-        \/\/ Widening conversions (from JVM spec):\n-        \/\/  byte to short, int, long, float, or double\n-        \/\/  short to int, long, float, or double\n-        \/\/  char to int, long, float, or double\n-        \/\/  int to long, float, or double\n-        \/\/  long to float or double\n-        \/\/  float to double\n-\n-        if (   fromType == Byte.TYPE\n-               || fromType == Short.TYPE\n-               || fromType == Character.TYPE\n-               || fromType == Integer.TYPE) {\n-            if (toType == Long.TYPE) {\n-                cb.opc_i2l();\n-            } else if (toType == Float.TYPE) {\n-                cb.opc_i2f();\n-            } else if (toType == Double.TYPE) {\n-                cb.opc_i2d();\n-            }\n-        } else if (fromType == Long.TYPE) {\n-            if (toType == Float.TYPE) {\n-                cb.opc_l2f();\n-            } else if (toType == Double.TYPE) {\n-                cb.opc_l2d();\n-            }\n-        } else if (fromType == Float.TYPE) {\n-            if (toType == Double.TYPE) {\n-                cb.opc_f2d();\n-            }\n-        }\n-\n-        \/\/ Otherwise, was identity or no-op conversion. Fall through.\n-    }\n-\n-    protected short unboxingMethodForPrimitiveType(Class<?> primType) {\n-        if (primType == Boolean.TYPE) {\n-            return booleanUnboxIdx;\n-        } else if (primType == Byte.TYPE) {\n-            return byteUnboxIdx;\n-        } else if (primType == Character.TYPE) {\n-            return characterUnboxIdx;\n-        } else if (primType == Short.TYPE) {\n-            return shortUnboxIdx;\n-        } else if (primType == Integer.TYPE) {\n-            return integerUnboxIdx;\n-        } else if (primType == Long.TYPE) {\n-            return longUnboxIdx;\n-        } else if (primType == Float.TYPE) {\n-            return floatUnboxIdx;\n-        } else if (primType == Double.TYPE) {\n-            return doubleUnboxIdx;\n-        }\n-        throw new InternalError(\"Illegal primitive type \" + primType.getName());\n-    }\n-\n-    protected static final Class<?>[] primitiveTypes = new Class<?>[] {\n-        Boolean.TYPE,\n-        Byte.TYPE,\n-        Character.TYPE,\n-        Short.TYPE,\n-        Integer.TYPE,\n-        Long.TYPE,\n-        Float.TYPE,\n-        Double.TYPE\n-    };\n-\n-    \/** We don't consider \"Void\" to be a primitive type *\/\n-    protected static boolean isPrimitive(Class<?> c) {\n-        return (c.isPrimitive() && c != Void.TYPE);\n-    }\n-\n-    protected int typeSizeInStackSlots(Class<?> c) {\n-        if (c == Void.TYPE) {\n-            return 0;\n-        }\n-        if (c == Long.TYPE || c == Double.TYPE) {\n-            return 2;\n-        }\n-        return 1;\n-    }\n-\n-    private ClassFileAssembler illegalArgumentCodeBuffer;\n-    protected ClassFileAssembler illegalArgumentCodeBuffer() {\n-        if (illegalArgumentCodeBuffer == null) {\n-            illegalArgumentCodeBuffer = new ClassFileAssembler();\n-            illegalArgumentCodeBuffer.opc_new(illegalArgumentClass);\n-            illegalArgumentCodeBuffer.opc_dup();\n-            illegalArgumentCodeBuffer.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);\n-            illegalArgumentCodeBuffer.opc_athrow();\n-        }\n-\n-        return illegalArgumentCodeBuffer;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/AccessorGenerator.java","additions":0,"deletions":722,"binary":false,"changes":722,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** A growable array of bytes. *\/\n-\n-interface ByteVector {\n-    public int  getLength();\n-    public byte get(int index);\n-    public void put(int index, byte value);\n-    public void add(byte value);\n-    public void trim();\n-    public byte[] getData();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ByteVector.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-class ByteVectorFactory {\n-    static ByteVector create() {\n-        return new ByteVectorImpl();\n-    }\n-\n-    static ByteVector create(int sz) {\n-        return new ByteVectorImpl(sz);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ByteVectorFactory.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-class ByteVectorImpl implements ByteVector {\n-    private byte[] data;\n-    private int pos;\n-\n-    public ByteVectorImpl() {\n-        this(100);\n-    }\n-\n-    public ByteVectorImpl(int sz) {\n-        data = new byte[sz];\n-        pos = -1;\n-    }\n-\n-    public int getLength() {\n-        return pos + 1;\n-    }\n-\n-    public byte get(int index) {\n-        if (index >= data.length) {\n-            resize(index);\n-            pos = index;\n-        }\n-        return data[index];\n-    }\n-\n-    public void put(int index, byte value) {\n-        if (index >= data.length) {\n-            resize(index);\n-            pos = index;\n-        }\n-        data[index] = value;\n-    }\n-\n-    public void add(byte value) {\n-        if (++pos >= data.length) {\n-            resize(pos);\n-        }\n-        data[pos] = value;\n-    }\n-\n-    public void trim() {\n-        if (pos != data.length - 1) {\n-            byte[] newData = new byte[pos + 1];\n-            System.arraycopy(data, 0, newData, 0, pos + 1);\n-            data = newData;\n-        }\n-    }\n-\n-    public byte[] getData() {\n-        return data;\n-    }\n-\n-    private void resize(int minSize) {\n-        if (minSize <= 2 * data.length) {\n-            minSize = 2 * data.length;\n-        }\n-        byte[] newData = new byte[minSize];\n-        System.arraycopy(data, 0, newData, 0, data.length);\n-        data = newData;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ByteVectorImpl.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/** Utility class which assists in calling defineClass() by\n- *  creating a new class loader which delegates to the one needed in\n- *  order for proper resolution of the given bytecodes to occur.\n- *\n- *  This is only used to define SerializationConstructorAccessor.\n- *\/\n-\n-class ClassDefiner {\n-    static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    \/** <P> We define generated code into a new class loader which\n-      delegates to the defining loader of the target class. It is\n-      necessary for the VM to be able to resolve references to the\n-      target class from the generated bytecodes, which could not occur\n-      if the generated code was loaded into the bootstrap class\n-      loader. <\/P>\n-\n-      <P> There are two primary reasons for creating a new loader\n-      instead of defining these bytecodes directly into the defining\n-      loader of the target class: first, it avoids any possible\n-      security risk of having these bytecodes in the same loader.\n-      Second, it allows the generated bytecodes to be unloaded earlier\n-      than would otherwise be possible, decreasing run-time\n-      footprint. <\/P>\n-    *\/\n-    static Class<?> defineClass(String name, byte[] bytes, int off, int len,\n-                                final ClassLoader parentClassLoader)\n-    {\n-        @SuppressWarnings(\"removal\")\n-        ClassLoader newLoader = AccessController.doPrivileged(\n-            new PrivilegedAction<ClassLoader>() {\n-                public ClassLoader run() {\n-                        return new DelegatingClassLoader(parentClassLoader);\n-                    }\n-                });\n-        return JLA.defineClass(newLoader, name, bytes, null, \"__ClassDefiner__\");\n-    }\n-}\n-\n-\n-\/\/ NOTE: this class's name and presence are known to the virtual\n-\/\/ machine as of the fix for 4474172.\n-class DelegatingClassLoader extends ClassLoader {\n-    DelegatingClassLoader(ClassLoader parent) {\n-        super(parent);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassDefiner.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,671 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import sun.nio.cs.UTF_8;\n-\n-class ClassFileAssembler implements ClassFileConstants {\n-    private ByteVector vec;\n-    private short cpIdx = 0;\n-\n-    public ClassFileAssembler() {\n-        this(ByteVectorFactory.create());\n-    }\n-\n-    public ClassFileAssembler(ByteVector vec) {\n-        this.vec = vec;\n-    }\n-\n-    public ByteVector getData() {\n-        return vec;\n-    }\n-\n-    \/** Length in bytes *\/\n-    public short getLength() {\n-        return (short) vec.getLength();\n-    }\n-\n-    public void emitMagicAndVersion() {\n-        emitInt(0xCAFEBABE);\n-        emitShort((short) 0);\n-        emitShort((short) 49);\n-    }\n-\n-    public void emitInt(int val) {\n-        emitByte((byte) (val >> 24));\n-        emitByte((byte) ((val >> 16) & 0xFF));\n-        emitByte((byte) ((val >> 8) & 0xFF));\n-        emitByte((byte) (val & 0xFF));\n-    }\n-\n-    public void emitShort(short val) {\n-        emitByte((byte) ((val >> 8) & 0xFF));\n-        emitByte((byte) (val & 0xFF));\n-    }\n-\n-    \/\/ Support for labels; package-private\n-    void emitShort(short bci, short val) {\n-        vec.put(bci,     (byte) ((val >> 8) & 0xFF));\n-        vec.put(bci + 1, (byte) (val & 0xFF));\n-    }\n-\n-    public void emitByte(byte val) {\n-        vec.add(val);\n-    }\n-\n-    public void append(ClassFileAssembler asm) {\n-        append(asm.vec);\n-    }\n-\n-    public void append(ByteVector vec) {\n-        for (int i = 0; i < vec.getLength(); i++) {\n-            emitByte(vec.get(i));\n-        }\n-    }\n-\n-    \/** Keeps track of the current (one-based) constant pool index;\n-        incremented after emitting one of the following constant pool\n-        entries. Can fetch the current constant pool index for use in\n-        later entries.  Index points at the last valid constant pool\n-        entry; initially invalid. It is illegal to fetch the constant\n-        pool index before emitting at least one constant pool entry. *\/\n-    public short cpi() {\n-        if (cpIdx == 0) {\n-            throw new RuntimeException(\"Illegal use of ClassFileAssembler\");\n-        }\n-        return cpIdx;\n-    }\n-\n-    public void emitConstantPoolUTF8(String str) {\n-        byte[] bytes = str.getBytes(UTF_8.INSTANCE);\n-        emitByte(CONSTANT_Utf8);\n-        emitShort((short) bytes.length);\n-        for (int i = 0; i < bytes.length; i++) {\n-            emitByte(bytes[i]);\n-        }\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolClass(short index) {\n-        emitByte(CONSTANT_Class);\n-        emitShort(index);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolNameAndType(short nameIndex, short typeIndex) {\n-        emitByte(CONSTANT_NameAndType);\n-        emitShort(nameIndex);\n-        emitShort(typeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolFieldref\n-        (short classIndex, short nameAndTypeIndex)\n-    {\n-        emitByte(CONSTANT_Fieldref);\n-        emitShort(classIndex);\n-        emitShort(nameAndTypeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolMethodref\n-        (short classIndex, short nameAndTypeIndex)\n-    {\n-        emitByte(CONSTANT_Methodref);\n-        emitShort(classIndex);\n-        emitShort(nameAndTypeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolInterfaceMethodref\n-        (short classIndex, short nameAndTypeIndex)\n-    {\n-        emitByte(CONSTANT_InterfaceMethodref);\n-        emitShort(classIndex);\n-        emitShort(nameAndTypeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolString(short utf8Index) {\n-        emitByte(CONSTANT_String);\n-        emitShort(utf8Index);\n-        cpIdx++;\n-    }\n-\n-    \/\/----------------------------------------------------------------------\n-    \/\/ Opcodes. Keeps track of maximum stack and locals. Make a new\n-    \/\/ assembler for each piece of assembled code, then append the\n-    \/\/ result to the previous assembler's class file.\n-    \/\/\n-\n-    private int stack     = 0;\n-    private int maxStack  = 0;\n-    private int maxLocals = 0;\n-\n-    private void incStack() {\n-        setStack(stack + 1);\n-    }\n-\n-    private void decStack() {\n-        --stack;\n-    }\n-\n-    public short getMaxStack() {\n-        return (short) maxStack;\n-    }\n-\n-    public short getMaxLocals() {\n-        return (short) maxLocals;\n-    }\n-\n-    \/** It's necessary to be able to specify the number of arguments at\n-        the beginning of the method (which translates to the initial\n-        value of max locals) *\/\n-    public void setMaxLocals(int maxLocals) {\n-        this.maxLocals = maxLocals;\n-    }\n-\n-    \/** Needed to do flow control. Returns current stack depth. *\/\n-    public int getStack() {\n-        return stack;\n-    }\n-\n-    \/** Needed to do flow control. *\/\n-    public void setStack(int value) {\n-        stack = value;\n-        if (stack > maxStack) {\n-            maxStack = stack;\n-        }\n-    }\n-\n-    \/\/-----------\/\/\n-    \/\/ Constants \/\/\n-    \/\/-----------\/\/\n-\n-    public void opc_aconst_null() {\n-        emitByte(opc_aconst_null);\n-        incStack();\n-    }\n-\n-    public void opc_sipush(short constant) {\n-        emitByte(opc_sipush);\n-        emitShort(constant);\n-        incStack();\n-    }\n-\n-    public void opc_ldc(byte cpIdx) {\n-        emitByte(opc_ldc);\n-        emitByte(cpIdx);\n-        incStack();\n-    }\n-\n-    \/\/---------------------------------\/\/\n-    \/\/ Local variable loads and stores \/\/\n-    \/\/---------------------------------\/\/\n-\n-    public void opc_iload_0() {\n-        emitByte(opc_iload_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        incStack();\n-    }\n-\n-    public void opc_iload_1() {\n-        emitByte(opc_iload_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-    }\n-\n-    public void opc_iload_2() {\n-        emitByte(opc_iload_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-    }\n-\n-    public void opc_iload_3() {\n-        emitByte(opc_iload_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-    }\n-\n-    public void opc_lload_0() {\n-        emitByte(opc_lload_0);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_lload_1() {\n-        emitByte(opc_lload_1);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_lload_2() {\n-        emitByte(opc_lload_2);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_lload_3() {\n-        emitByte(opc_lload_3);\n-        if (maxLocals < 5) maxLocals = 5;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_fload_0() {\n-        emitByte(opc_fload_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        incStack();\n-    }\n-\n-    public void opc_fload_1() {\n-        emitByte(opc_fload_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-    }\n-\n-    public void opc_fload_2() {\n-        emitByte(opc_fload_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-    }\n-\n-    public void opc_fload_3() {\n-        emitByte(opc_fload_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-    }\n-\n-    public void opc_dload_0() {\n-        emitByte(opc_dload_0);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_dload_1() {\n-        emitByte(opc_dload_1);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_dload_2() {\n-        emitByte(opc_dload_2);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_dload_3() {\n-        emitByte(opc_dload_3);\n-        if (maxLocals < 5) maxLocals = 5;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_aload_0() {\n-        emitByte(opc_aload_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        incStack();\n-    }\n-\n-    public void opc_aload_1() {\n-        emitByte(opc_aload_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-    }\n-\n-    public void opc_aload_2() {\n-        emitByte(opc_aload_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-    }\n-\n-    public void opc_aload_3() {\n-        emitByte(opc_aload_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-    }\n-\n-    public void opc_aaload() {\n-        emitByte(opc_aaload);\n-        decStack();\n-    }\n-\n-    public void opc_astore_0() {\n-        emitByte(opc_astore_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        decStack();\n-    }\n-\n-    public void opc_astore_1() {\n-        emitByte(opc_astore_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        decStack();\n-    }\n-\n-    public void opc_astore_2() {\n-        emitByte(opc_astore_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        decStack();\n-    }\n-\n-    public void opc_astore_3() {\n-        emitByte(opc_astore_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        decStack();\n-    }\n-\n-    \/\/--------------------\/\/\n-    \/\/ Stack manipulation \/\/\n-    \/\/--------------------\/\/\n-\n-    public void opc_pop() {\n-        emitByte(opc_pop);\n-        decStack();\n-    }\n-\n-    public void opc_dup() {\n-        emitByte(opc_dup);\n-        incStack();\n-    }\n-\n-    public void opc_dup_x1() {\n-        emitByte(opc_dup_x1);\n-        incStack();\n-    }\n-\n-    public void opc_swap() {\n-        emitByte(opc_swap);\n-    }\n-\n-    \/\/---------------------------\/\/\n-    \/\/ Widening conversions only \/\/\n-    \/\/---------------------------\/\/\n-\n-    public void opc_i2l() {\n-        emitByte(opc_i2l);\n-    }\n-\n-    public void opc_i2f() {\n-        emitByte(opc_i2f);\n-    }\n-\n-    public void opc_i2d() {\n-        emitByte(opc_i2d);\n-    }\n-\n-    public void opc_l2f() {\n-        emitByte(opc_l2f);\n-    }\n-\n-    public void opc_l2d() {\n-        emitByte(opc_l2d);\n-    }\n-\n-    public void opc_f2d() {\n-        emitByte(opc_f2d);\n-    }\n-\n-    \/\/--------------\/\/\n-    \/\/ Control flow \/\/\n-    \/\/--------------\/\/\n-\n-    public void opc_ifeq(short bciOffset) {\n-        emitByte(opc_ifeq);\n-        emitShort(bciOffset);\n-        decStack();\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes\n-        straight-through control flow. *\/\n-    public void opc_ifeq(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_ifeq);\n-        l.add(this, instrBCI, getLength(), getStack() - 1);\n-        emitShort((short) -1); \/\/ Must be patched later\n-    }\n-\n-    public void opc_if_icmpeq(short bciOffset) {\n-        emitByte(opc_if_icmpeq);\n-        emitShort(bciOffset);\n-        setStack(getStack() - 2);\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_if_icmpeq(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_if_icmpeq);\n-        l.add(this, instrBCI, getLength(), getStack() - 2);\n-        emitShort((short) -1); \/\/ Must be patched later\n-    }\n-\n-    public void opc_goto(short bciOffset) {\n-        emitByte(opc_goto);\n-        emitShort(bciOffset);\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_goto(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_goto);\n-        l.add(this, instrBCI, getLength(), getStack());\n-        emitShort((short) -1); \/\/ Must be patched later\n-    }\n-\n-    public void opc_ifnull(short bciOffset) {\n-        emitByte(opc_ifnull);\n-        emitShort(bciOffset);\n-        decStack();\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_ifnull(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_ifnull);\n-        l.add(this, instrBCI, getLength(), getStack() - 1);\n-        emitShort((short) -1); \/\/ Must be patched later\n-        decStack();\n-    }\n-\n-    public void opc_ifnonnull(short bciOffset) {\n-        emitByte(opc_ifnonnull);\n-        emitShort(bciOffset);\n-        decStack();\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_ifnonnull(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_ifnonnull);\n-        l.add(this, instrBCI, getLength(), getStack() - 1);\n-        emitShort((short) -1); \/\/ Must be patched later\n-        decStack();\n-    }\n-\n-    \/\/---------------------\/\/\n-    \/\/ Return instructions \/\/\n-    \/\/---------------------\/\/\n-\n-    public void opc_ireturn() {\n-        emitByte(opc_ireturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_lreturn() {\n-        emitByte(opc_lreturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_freturn() {\n-        emitByte(opc_freturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_dreturn() {\n-        emitByte(opc_dreturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_areturn() {\n-        emitByte(opc_areturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_return() {\n-        emitByte(opc_return);\n-        setStack(0);\n-    }\n-\n-    \/\/------------------\/\/\n-    \/\/ Field operations \/\/\n-    \/\/------------------\/\/\n-\n-    public void opc_getstatic(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_getstatic);\n-        emitShort(fieldIndex);\n-        setStack(getStack() + fieldSizeInStackSlots);\n-    }\n-\n-    public void opc_putstatic(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_putstatic);\n-        emitShort(fieldIndex);\n-        setStack(getStack() - fieldSizeInStackSlots);\n-    }\n-\n-    public void opc_getfield(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_getfield);\n-        emitShort(fieldIndex);\n-        setStack(getStack() + fieldSizeInStackSlots - 1);\n-    }\n-\n-    public void opc_putfield(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_putfield);\n-        emitShort(fieldIndex);\n-        setStack(getStack() - fieldSizeInStackSlots - 1);\n-    }\n-\n-    \/\/--------------------\/\/\n-    \/\/ Method invocations \/\/\n-    \/\/--------------------\/\/\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokevirtual(short methodIndex,\n-                                  int numArgs,\n-                                  int numReturnValues)\n-    {\n-        emitByte(opc_invokevirtual);\n-        emitShort(methodIndex);\n-        setStack(getStack() - numArgs - 1 + numReturnValues);\n-    }\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokespecial(short methodIndex,\n-                                  int numArgs,\n-                                  int numReturnValues)\n-    {\n-        emitByte(opc_invokespecial);\n-        emitShort(methodIndex);\n-        setStack(getStack() - numArgs - 1 + numReturnValues);\n-    }\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokestatic(short methodIndex,\n-                                 int numArgs,\n-                                 int numReturnValues)\n-    {\n-        emitByte(opc_invokestatic);\n-        emitShort(methodIndex);\n-        setStack(getStack() - numArgs + numReturnValues);\n-    }\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokeinterface(short methodIndex,\n-                                    int numArgs,\n-                                    byte count,\n-                                    int numReturnValues)\n-    {\n-        emitByte(opc_invokeinterface);\n-        emitShort(methodIndex);\n-        emitByte(count);\n-        emitByte((byte) 0);\n-        setStack(getStack() - numArgs - 1 + numReturnValues);\n-    }\n-\n-    \/\/--------------\/\/\n-    \/\/ Array length \/\/\n-    \/\/--------------\/\/\n-\n-    public void opc_arraylength() {\n-        emitByte(opc_arraylength);\n-    }\n-\n-    \/\/-----\/\/\n-    \/\/ New \/\/\n-    \/\/-----\/\/\n-\n-    public void opc_new(short classIndex) {\n-        emitByte(opc_new);\n-        emitShort(classIndex);\n-        incStack();\n-    }\n-\n-    \/\/--------\/\/\n-    \/\/ Athrow \/\/\n-    \/\/--------\/\/\n-\n-    public void opc_athrow() {\n-        emitByte(opc_athrow);\n-        setStack(1);\n-    }\n-\n-    \/\/--------------------------\/\/\n-    \/\/ Checkcast and instanceof \/\/\n-    \/\/--------------------------\/\/\n-\n-    \/** Assumes the checkcast succeeds *\/\n-    public void opc_checkcast(short classIndex) {\n-        emitByte(opc_checkcast);\n-        emitShort(classIndex);\n-    }\n-\n-    public void opc_instanceof(short classIndex) {\n-        emitByte(opc_instanceof);\n-        emitShort(classIndex);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassFileAssembler.java","additions":0,"deletions":671,"binary":false,"changes":671,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** Minimal set of class file constants for assembly of field and\n-    method accessors. *\/\n-\n-interface ClassFileConstants {\n-    \/\/ Constants\n-    public static final byte opc_aconst_null   = (byte) 0x1;\n-    public static final byte opc_sipush        = (byte) 0x11;\n-    public static final byte opc_ldc           = (byte) 0x12;\n-\n-    \/\/ Local variable loads and stores\n-    public static final byte opc_iload_0       = (byte) 0x1a;\n-    public static final byte opc_iload_1       = (byte) 0x1b;\n-    public static final byte opc_iload_2       = (byte) 0x1c;\n-    public static final byte opc_iload_3       = (byte) 0x1d;\n-    public static final byte opc_lload_0       = (byte) 0x1e;\n-    public static final byte opc_lload_1       = (byte) 0x1f;\n-    public static final byte opc_lload_2       = (byte) 0x20;\n-    public static final byte opc_lload_3       = (byte) 0x21;\n-    public static final byte opc_fload_0       = (byte) 0x22;\n-    public static final byte opc_fload_1       = (byte) 0x23;\n-    public static final byte opc_fload_2       = (byte) 0x24;\n-    public static final byte opc_fload_3       = (byte) 0x25;\n-    public static final byte opc_dload_0       = (byte) 0x26;\n-    public static final byte opc_dload_1       = (byte) 0x27;\n-    public static final byte opc_dload_2       = (byte) 0x28;\n-    public static final byte opc_dload_3       = (byte) 0x29;\n-    public static final byte opc_aload_0       = (byte) 0x2a;\n-    public static final byte opc_aload_1       = (byte) 0x2b;\n-    public static final byte opc_aload_2       = (byte) 0x2c;\n-    public static final byte opc_aload_3       = (byte) 0x2d;\n-    public static final byte opc_aaload        = (byte) 0x32;\n-    public static final byte opc_astore_0      = (byte) 0x4b;\n-    public static final byte opc_astore_1      = (byte) 0x4c;\n-    public static final byte opc_astore_2      = (byte) 0x4d;\n-    public static final byte opc_astore_3      = (byte) 0x4e;\n-\n-    \/\/ Stack manipulation\n-    public static final byte opc_pop           = (byte) 0x57;\n-    public static final byte opc_dup           = (byte) 0x59;\n-    public static final byte opc_dup_x1        = (byte) 0x5a;\n-    public static final byte opc_swap          = (byte) 0x5f;\n-\n-    \/\/ Conversions\n-    public static final byte opc_i2l           = (byte) 0x85;\n-    public static final byte opc_i2f           = (byte) 0x86;\n-    public static final byte opc_i2d           = (byte) 0x87;\n-    public static final byte opc_l2i           = (byte) 0x88;\n-    public static final byte opc_l2f           = (byte) 0x89;\n-    public static final byte opc_l2d           = (byte) 0x8a;\n-    public static final byte opc_f2i           = (byte) 0x8b;\n-    public static final byte opc_f2l           = (byte) 0x8c;\n-    public static final byte opc_f2d           = (byte) 0x8d;\n-    public static final byte opc_d2i           = (byte) 0x8e;\n-    public static final byte opc_d2l           = (byte) 0x8f;\n-    public static final byte opc_d2f           = (byte) 0x90;\n-    public static final byte opc_i2b           = (byte) 0x91;\n-    public static final byte opc_i2c           = (byte) 0x92;\n-    public static final byte opc_i2s           = (byte) 0x93;\n-\n-    \/\/ Control flow\n-    public static final byte opc_ifeq          = (byte) 0x99;\n-    public static final byte opc_if_icmpeq     = (byte) 0x9f;\n-    public static final byte opc_goto          = (byte) 0xa7;\n-\n-    \/\/ Return instructions\n-    public static final byte opc_ireturn       = (byte) 0xac;\n-    public static final byte opc_lreturn       = (byte) 0xad;\n-    public static final byte opc_freturn       = (byte) 0xae;\n-    public static final byte opc_dreturn       = (byte) 0xaf;\n-    public static final byte opc_areturn       = (byte) 0xb0;\n-    public static final byte opc_return        = (byte) 0xb1;\n-\n-    \/\/ Field operations\n-    public static final byte opc_getstatic     = (byte) 0xb2;\n-    public static final byte opc_putstatic     = (byte) 0xb3;\n-    public static final byte opc_getfield      = (byte) 0xb4;\n-    public static final byte opc_putfield      = (byte) 0xb5;\n-\n-    \/\/ Method invocations\n-    public static final byte opc_invokevirtual   = (byte) 0xb6;\n-    public static final byte opc_invokespecial   = (byte) 0xb7;\n-    public static final byte opc_invokestatic    = (byte) 0xb8;\n-    public static final byte opc_invokeinterface = (byte) 0xb9;\n-\n-    \/\/ Array length\n-    public static final byte opc_arraylength     = (byte) 0xbe;\n-\n-    \/\/ New\n-    public static final byte opc_new           = (byte) 0xbb;\n-\n-    \/\/ Athrow\n-    public static final byte opc_athrow        = (byte) 0xbf;\n-\n-    \/\/ Checkcast and instanceof\n-    public static final byte opc_checkcast     = (byte) 0xc0;\n-    public static final byte opc_instanceof    = (byte) 0xc1;\n-\n-    \/\/ Ifnull and ifnonnull\n-    public static final byte opc_ifnull        = (byte) 0xc6;\n-    public static final byte opc_ifnonnull     = (byte) 0xc7;\n-\n-    \/\/ Constant pool tags\n-    public static final byte CONSTANT_Class              = (byte) 7;\n-    public static final byte CONSTANT_Fieldref           = (byte) 9;\n-    public static final byte CONSTANT_Methodref          = (byte) 10;\n-    public static final byte CONSTANT_InterfaceMethodref = (byte) 11;\n-    public static final byte CONSTANT_NameAndType        = (byte) 12;\n-    public static final byte CONSTANT_String             = (byte) 8;\n-    public static final byte CONSTANT_Utf8               = (byte) 1;\n-\n-    \/\/ Access flags\n-    public static final short ACC_PUBLIC = (short) 0x0001;\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassFileConstants.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -30,6 +30,1 @@\n-\/** Package-private implementation of the ConstructorAccessor\n-    interface which has access to all classes and all fields,\n-    regardless of language restrictions. See MagicAccessorImpl. *\/\n-\n-abstract class ConstructorAccessorImpl extends MagicAccessorImpl\n-    implements ConstructorAccessor {\n+abstract class ConstructorAccessorImpl implements ConstructorAccessor {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ConstructorAccessorImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,6 +31,1 @@\n-\/** Package-private implementation of the FieldAccessor interface\n-    which has access to all classes and all fields, regardless of\n-    language restrictions. See MagicAccessorImpl. *\/\n-\n-abstract class FieldAccessorImpl extends MagicAccessorImpl\n-    implements FieldAccessor {\n+abstract class FieldAccessorImpl implements FieldAccessor {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/FieldAccessorImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.util.List;\n-import java.util.ArrayList;\n-\n-\/** Allows forward references in bytecode streams emitted by\n-    ClassFileAssembler. Assumes that the start of the method body is\n-    the first byte in the assembler's buffer. May be used at more than\n-    one branch site. *\/\n-\n-class Label {\n-    static class PatchInfo {\n-        PatchInfo(ClassFileAssembler asm,\n-                  short instrBCI,\n-                  short patchBCI,\n-                  int stackDepth)\n-        {\n-            this.asm = asm;\n-            this.instrBCI   = instrBCI;\n-            this.patchBCI   = patchBCI;\n-            this.stackDepth = stackDepth;\n-        }\n-        \/\/ This won't work for more than one assembler anyway, so this is\n-        \/\/ unnecessary\n-        final ClassFileAssembler asm;\n-        final short instrBCI;\n-        final short patchBCI;\n-        final int   stackDepth;\n-    }\n-    private final List<PatchInfo> patches = new ArrayList<>();\n-\n-    public Label() {\n-    }\n-\n-    void add(ClassFileAssembler asm,\n-             short instrBCI,\n-             short patchBCI,\n-             int stackDepth)\n-    {\n-        patches.add(new PatchInfo(asm, instrBCI, patchBCI, stackDepth));\n-    }\n-\n-    public void bind() {\n-        for (PatchInfo patch : patches){\n-            short curBCI = patch.asm.getLength();\n-            short offset = (short) (curBCI - patch.instrBCI);\n-            patch.asm.emitShort(patch.patchBCI, offset);\n-            patch.asm.setStack(patch.stackDepth);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Label.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** <P> MagicAccessorImpl (named for parity with FieldAccessorImpl and\n-    others, not because it actually implements an interface) is a\n-    marker class in the hierarchy. All subclasses of this class are\n-    \"magically\" granted access by the VM to otherwise inaccessible\n-    fields and methods of other classes. It is used to hold the code\n-    for dynamically-generated FieldAccessorImpl and MethodAccessorImpl\n-    subclasses. (Use of the word \"unsafe\" was avoided in this class's\n-    name to avoid confusion with {@link jdk.internal.misc.Unsafe}.) <\/P>\n-\n-    <P> The bug fix for 4486457 also necessitated disabling\n-    verification for this class and all subclasses, as opposed to just\n-    SerializationConstructorAccessorImpl and subclasses, to avoid\n-    having to indicate to the VM which of these dynamically-generated\n-    stub classes were known to be able to pass the verifier. <\/P>\n-\n-    <P> Do not change the name of this class without also changing the\n-    VM's code. <\/P> *\/\n-\n-class MagicAccessorImpl {\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MagicAccessorImpl.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -30,5 +30,1 @@\n-\/** <P> Package-private implementation of the MethodAccessor interface\n-    which has access to all classes and all fields, regardless of\n-    language restrictions. See MagicAccessor. <\/P>\n-\n-    <P> This class is known to the VM; do not change its name without\n+\/** <P> This class is known to the VM; do not change its name without\n@@ -43,2 +39,1 @@\n-abstract class MethodAccessorImpl extends MagicAccessorImpl\n-    implements MethodAccessor {\n+abstract class MethodAccessorImpl implements MethodAccessor {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessorImpl.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -337,10 +337,2 @@\n-        ConstructorAccessor acc;\n-        if (useOldSerializableConstructor()) {\n-            acc = new SerializationConstructorAccessorGenerator().\n-                                generateSerializationConstructor(cl,\n-                                                                 constructorToCall.getParameterTypes(),\n-                                                                 constructorToCall.getModifiers(),\n-                                                                 constructorToCall.getDeclaringClass());\n-        } else {\n-            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, constructorToCall);\n-        }\n+        ConstructorAccessor acc = MethodHandleAccessorFactory\n+                .newSerializableConstructorAccessor(cl, constructorToCall);\n@@ -510,4 +502,0 @@\n-    static boolean useOldSerializableConstructor() {\n-        return config().useOldSerializableConstructor;\n-    }\n-\n@@ -530,1 +518,0 @@\n-                                                            false,  \/\/ useOldSerializeableConstructor\n@@ -545,1 +532,0 @@\n-                          boolean useOldSerializableConstructor,\n@@ -569,2 +555,0 @@\n-        boolean useOldSerializableConstructor =\n-            \"true\".equals(props.getProperty(\"jdk.reflect.useOldSerializableConstructor\"));\n@@ -574,1 +558,1 @@\n-        return new Config(useNativeAccessorOnly, useOldSerializableConstructor, disableSerialConstructorChecks);\n+        return new Config(useNativeAccessorOnly, disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,725 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n-\n-\/** Generator for jdk.internal.reflect.SerializationConstructorAccessorImpl\n-    objects using bytecodes to implement a constructor for serialization\n-    returned by ReflectionFactory::newConstructorForSerialization. *\/\n-\n-class SerializationConstructorAccessorGenerator extends AccessorGenerator {\n-\n-    private static final short NUM_BASE_CPOOL_ENTRIES   = (short) 12;\n-    \/\/ One for invoke() plus one for constructor\n-    private static final short NUM_METHODS              = (short) 2;\n-    \/\/ Only used if forSerialization is true\n-    private static final short NUM_SERIALIZATION_CPOOL_ENTRIES = (short) 2;\n-\n-    private static volatile int methodSymnum;\n-    private static volatile int constructorSymnum;\n-    private static volatile int serializationConstructorSymnum;\n-\n-    private Class<?>   declaringClass;\n-    private Class<?>[] parameterTypes;\n-    private Class<?>   returnType;\n-    private boolean    isConstructor;\n-    private boolean    forSerialization;\n-\n-    private short targetMethodRef;\n-    private short invokeIdx;\n-    private short invokeDescriptorIdx;\n-    \/\/ Constant pool index of CONSTANT_Class_info for first\n-    \/\/ non-primitive parameter type. Should be incremented by 2.\n-    private short nonPrimitiveParametersBaseIdx;\n-\n-    SerializationConstructorAccessorGenerator() {\n-    }\n-\n-    \/** This routine is not thread-safe *\/\n-    public SerializationConstructorAccessorImpl\n-    generateSerializationConstructor(Class<?> declaringClass,\n-                                     Class<?>[] parameterTypes,\n-                                     int modifiers,\n-                                     Class<?> targetConstructorClass)\n-    {\n-        return (SerializationConstructorAccessorImpl)\n-            generate(declaringClass,\n-                     \"<init>\",\n-                     parameterTypes,\n-                     Void.TYPE,\n-                     modifiers,\n-                     true,\n-                     true,\n-                     targetConstructorClass);\n-    }\n-\n-    \/** This routine is not thread-safe *\/\n-    @SuppressWarnings(\"removal\")\n-    private MagicAccessorImpl generate(final Class<?> declaringClass,\n-                                       String name,\n-                                       Class<?>[] parameterTypes,\n-                                       Class<?>   returnType,\n-                                       int modifiers,\n-                                       boolean isConstructor,\n-                                       boolean forSerialization,\n-                                       Class<?> serializationTargetClass)\n-    {\n-        ByteVector vec = ByteVectorFactory.create();\n-        asm = new ClassFileAssembler(vec);\n-        this.declaringClass = declaringClass;\n-        this.parameterTypes = parameterTypes;\n-        this.returnType = returnType;\n-        this.modifiers = modifiers;\n-        this.isConstructor = isConstructor;\n-        this.forSerialization = forSerialization;\n-\n-        asm.emitMagicAndVersion();\n-\n-        \/\/ Constant pool entries:\n-        \/\/ ( * = Boxing information: optional)\n-        \/\/ (+  = Shared entries provided by AccessorGenerator)\n-        \/\/ (^  = Only present if generating SerializationConstructorAccessor)\n-        \/\/     [UTF-8] [This class's name]\n-        \/\/     [CONSTANT_Class_info] for above\n-        \/\/     [UTF-8] \"jdk\/internal\/reflect\/{MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl}\"\n-        \/\/     [CONSTANT_Class_info] for above\n-        \/\/     [UTF-8] [Target class's name]\n-        \/\/     [CONSTANT_Class_info] for above\n-        \/\/ ^   [UTF-8] [Serialization: Class's name in which to invoke constructor]\n-        \/\/ ^   [CONSTANT_Class_info] for above\n-        \/\/     [UTF-8] target method or constructor name\n-        \/\/     [UTF-8] target method or constructor signature\n-        \/\/     [CONSTANT_NameAndType_info] for above\n-        \/\/     [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method\n-        \/\/     [UTF-8] \"invoke\" or \"newInstance\"\n-        \/\/     [UTF-8] invoke or newInstance descriptor\n-        \/\/     [UTF-8] descriptor for type of non-primitive parameter 1\n-        \/\/     [CONSTANT_Class_info] for type of non-primitive parameter 1\n-        \/\/     ...\n-        \/\/     [UTF-8] descriptor for type of non-primitive parameter n\n-        \/\/     [CONSTANT_Class_info] for type of non-primitive parameter n\n-        \/\/ +   [UTF-8] \"java\/lang\/Exception\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/ClassCastException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/NullPointerException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/IllegalArgumentException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/InvocationTargetException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"<init>\"\n-        \/\/ +   [UTF-8] \"()V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for above\n-        \/\/ +   [CONSTANT_Methodref_info] for NullPointerException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for InvocationTargetException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for \"super()\"\n-        \/\/ +   [UTF-8] \"java\/lang\/Object\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"toString\"\n-        \/\/ +   [UTF-8] \"()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"toString()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_Methodref_info] for Object's toString method\n-        \/\/ +   [UTF-8] \"Code\"\n-        \/\/ +   [UTF-8] \"Exceptions\"\n-        \/\/  *  [UTF-8] \"java\/lang\/Boolean\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(Z)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"booleanValue\"\n-        \/\/  *  [UTF-8] \"()Z\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Byte\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(B)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"byteValue\"\n-        \/\/  *  [UTF-8] \"()B\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Character\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(C)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"charValue\"\n-        \/\/  *  [UTF-8] \"()C\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Double\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(D)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"doubleValue\"\n-        \/\/  *  [UTF-8] \"()D\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Float\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(F)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"floatValue\"\n-        \/\/  *  [UTF-8] \"()F\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Integer\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(I)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"intValue\"\n-        \/\/  *  [UTF-8] \"()I\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Long\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(J)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"longValue\"\n-        \/\/  *  [UTF-8] \"()J\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Short\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(S)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"shortValue\"\n-        \/\/  *  [UTF-8] \"()S\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-\n-        short numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;\n-        boolean usesPrimitives = usesPrimitiveTypes();\n-        if (usesPrimitives) {\n-            numCPEntries += NUM_BOXING_CPOOL_ENTRIES;\n-        }\n-        if (forSerialization) {\n-            numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES;\n-        }\n-\n-        \/\/ Add in variable-length number of entries to be able to describe\n-        \/\/ non-primitive parameter types and checked exceptions.\n-        numCPEntries += (short) (2 * numNonPrimitiveParameterTypes());\n-\n-        asm.emitShort(add(numCPEntries, S1));\n-\n-        final String generatedName = generateName(isConstructor, forSerialization);\n-        asm.emitConstantPoolUTF8(generatedName);\n-        asm.emitConstantPoolClass(asm.cpi());\n-        thisClass = asm.cpi();\n-        if (isConstructor) {\n-            if (forSerialization) {\n-                asm.emitConstantPoolUTF8\n-                    (\"jdk\/internal\/reflect\/SerializationConstructorAccessorImpl\");\n-            } else {\n-                asm.emitConstantPoolUTF8(\"jdk\/internal\/reflect\/ConstructorAccessorImpl\");\n-            }\n-        } else {\n-            asm.emitConstantPoolUTF8(\"jdk\/internal\/reflect\/MethodAccessorImpl\");\n-        }\n-        asm.emitConstantPoolClass(asm.cpi());\n-        superClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(getClassName(declaringClass, false));\n-        asm.emitConstantPoolClass(asm.cpi());\n-        targetClass = asm.cpi();\n-        short serializationTargetClassIdx = (short) 0;\n-        if (forSerialization) {\n-            asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, false));\n-            asm.emitConstantPoolClass(asm.cpi());\n-            serializationTargetClassIdx = asm.cpi();\n-        }\n-        asm.emitConstantPoolUTF8(name);\n-        asm.emitConstantPoolUTF8(buildInternalSignature());\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        if (isInterface()) {\n-            asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi());\n-        } else {\n-            if (forSerialization) {\n-                asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi());\n-            } else {\n-                asm.emitConstantPoolMethodref(targetClass, asm.cpi());\n-            }\n-        }\n-        targetMethodRef = asm.cpi();\n-        if (isConstructor) {\n-            asm.emitConstantPoolUTF8(\"newInstance\");\n-        } else {\n-            asm.emitConstantPoolUTF8(\"invoke\");\n-        }\n-        invokeIdx = asm.cpi();\n-        if (isConstructor) {\n-            asm.emitConstantPoolUTF8(\"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n-        } else {\n-            asm.emitConstantPoolUTF8\n-                (\"(Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n-        }\n-        invokeDescriptorIdx = asm.cpi();\n-\n-        \/\/ Output class information for non-primitive parameter types\n-        nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2);\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            Class<?> c = parameterTypes[i];\n-            if (!isPrimitive(c)) {\n-                asm.emitConstantPoolUTF8(getClassName(c, false));\n-                asm.emitConstantPoolClass(asm.cpi());\n-            }\n-        }\n-\n-        \/\/ Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor\n-        emitCommonConstantPoolEntries();\n-\n-        \/\/ Boxing entries\n-        if (usesPrimitives) {\n-            emitBoxingContantPoolEntries();\n-        }\n-\n-        if (asm.cpi() != numCPEntries) {\n-            throw new InternalError(\"Adjust this code (cpi = \" + asm.cpi() +\n-                                    \", numCPEntries = \" + numCPEntries + \")\");\n-        }\n-\n-        \/\/ Access flags\n-        asm.emitShort(ACC_PUBLIC);\n-\n-        \/\/ This class\n-        asm.emitShort(thisClass);\n-\n-        \/\/ Superclass\n-        asm.emitShort(superClass);\n-\n-        \/\/ Interfaces count and interfaces\n-        asm.emitShort(S0);\n-\n-        \/\/ Fields count and fields\n-        asm.emitShort(S0);\n-\n-        \/\/ Methods count and methods\n-        asm.emitShort(NUM_METHODS);\n-\n-        emitConstructor();\n-        emitInvoke();\n-\n-        \/\/ Additional attributes (none)\n-        asm.emitShort(S0);\n-\n-        \/\/ Load class\n-        vec.trim();\n-        final byte[] bytes = vec.getData();\n-        \/\/ Note: the class loader is the only thing that really matters\n-        \/\/ here -- it's important to get the generated code into the\n-        \/\/ same namespace as the target class. Since the generated code\n-        \/\/ is privileged anyway, the protection domain probably doesn't\n-        \/\/ matter.\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<MagicAccessorImpl>() {\n-                @SuppressWarnings(\"deprecation\") \/\/ Class.newInstance\n-                public MagicAccessorImpl run() {\n-                        try {\n-                        return (MagicAccessorImpl)\n-                        ClassDefiner.defineClass\n-                                (generatedName,\n-                                 bytes,\n-                                 0,\n-                                 bytes.length,\n-                                 declaringClass.getClassLoader()).newInstance();\n-                        } catch (InstantiationException | IllegalAccessException e) {\n-                            throw new InternalError(e);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    \/** This emits the code for either invoke() or newInstance() *\/\n-    private void emitInvoke() {\n-        \/\/ NOTE that this code will only handle 65535 parameters since we\n-        \/\/ use the sipush instruction to get the array index on the\n-        \/\/ operand stack.\n-        if (parameterTypes.length > 65535) {\n-            throw new InternalError(\"Can't handle more than 65535 parameters\");\n-        }\n-\n-        \/\/ Generate code into fresh code buffer\n-        ClassFileAssembler cb = new ClassFileAssembler();\n-        if (isConstructor) {\n-            \/\/ 1 incoming argument\n-            cb.setMaxLocals(2);\n-        } else {\n-            \/\/ 2 incoming arguments\n-            cb.setMaxLocals(3);\n-        }\n-\n-        short illegalArgStartPC = 0;\n-\n-        if (isConstructor) {\n-            \/\/ Instantiate target class before continuing\n-            \/\/ new <target class type>\n-            \/\/ dup\n-            cb.opc_new(targetClass);\n-            cb.opc_dup();\n-        } else {\n-            \/\/ Get target object on operand stack if necessary.\n-\n-            \/\/ We need to do an explicit null check here; we won't see\n-            \/\/ NullPointerExceptions from the invoke bytecode, since it's\n-            \/\/ covered by an exception handler.\n-            if (!isStatic()) {\n-                \/\/ aload_1\n-                \/\/ ifnonnull <checkcast label>\n-                \/\/ new <NullPointerException>\n-                \/\/ dup\n-                \/\/ invokespecial <NullPointerException ctor>\n-                \/\/ athrow\n-                \/\/ <checkcast label:>\n-                \/\/ aload_1\n-                \/\/ checkcast <target class's type>\n-                cb.opc_aload_1();\n-                Label l = new Label();\n-                cb.opc_ifnonnull(l);\n-                cb.opc_new(nullPointerClass);\n-                cb.opc_dup();\n-                cb.opc_invokespecial(nullPointerCtorIdx, 0, 0);\n-                cb.opc_athrow();\n-                l.bind();\n-                illegalArgStartPC = cb.getLength();\n-                cb.opc_aload_1();\n-                cb.opc_checkcast(targetClass);\n-            }\n-        }\n-\n-        \/\/ Have to check length of incoming array and throw\n-        \/\/ IllegalArgumentException if not correct. A concession to the\n-        \/\/ JCK (isn't clearly specified in the spec): we allow null in the\n-        \/\/ case where the argument list is zero length.\n-        \/\/ if no-arg:\n-        \/\/   aload_2 | aload_1 (Method | Constructor)\n-        \/\/   ifnull <success label>\n-        \/\/ aload_2 | aload_1\n-        \/\/ arraylength\n-        \/\/ sipush <num parameter types>\n-        \/\/ if_icmpeq <success label>\n-        \/\/ new <IllegalArgumentException>\n-        \/\/ dup\n-        \/\/ invokespecial <IllegalArgumentException ctor>\n-        \/\/ athrow\n-        \/\/ <success label:>\n-        Label successLabel = new Label();\n-        if (parameterTypes.length == 0) {\n-            if (isConstructor) {\n-                cb.opc_aload_1();\n-            } else {\n-                cb.opc_aload_2();\n-            }\n-            cb.opc_ifnull(successLabel);\n-        }\n-        if (isConstructor) {\n-            cb.opc_aload_1();\n-        } else {\n-            cb.opc_aload_2();\n-        }\n-        cb.opc_arraylength();\n-        cb.opc_sipush((short) parameterTypes.length);\n-        cb.opc_if_icmpeq(successLabel);\n-        cb.opc_new(illegalArgumentClass);\n-        cb.opc_dup();\n-        cb.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);\n-        cb.opc_athrow();\n-        successLabel.bind();\n-\n-        \/\/ Iterate through incoming actual parameters, ensuring that each\n-        \/\/ is compatible with the formal parameter type, and pushing the\n-        \/\/ actual on the operand stack (unboxing and widening if necessary).\n-\n-        short paramTypeCPIdx = nonPrimitiveParametersBaseIdx;\n-        Label nextParamLabel = null;\n-        byte count = 1; \/\/ both invokeinterface opcode's \"count\" as well as\n-        \/\/ num args of other invoke bytecodes\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            Class<?> paramType = parameterTypes[i];\n-            count += (byte) typeSizeInStackSlots(paramType);\n-            if (nextParamLabel != null) {\n-                nextParamLabel.bind();\n-                nextParamLabel = null;\n-            }\n-            \/\/ aload_2 | aload_1\n-            \/\/ sipush <index>\n-            \/\/ aaload\n-            if (isConstructor) {\n-                cb.opc_aload_1();\n-            } else {\n-                cb.opc_aload_2();\n-            }\n-            cb.opc_sipush((short) i);\n-            cb.opc_aaload();\n-            if (isPrimitive(paramType)) {\n-                \/\/ Unboxing code.\n-                \/\/ Put parameter into temporary local variable\n-                \/\/ astore_3 | astore_2\n-                if (isConstructor) {\n-                    cb.opc_astore_2();\n-                } else {\n-                    cb.opc_astore_3();\n-                }\n-\n-                \/\/ repeat for all possible widening conversions:\n-                \/\/   aload_3 | aload_2\n-                \/\/   instanceof <primitive boxing type>\n-                \/\/   ifeq <next unboxing label>\n-                \/\/   aload_3 | aload_2\n-                \/\/   checkcast <primitive boxing type> \/\/ Note: this is \"redundant\",\n-                \/\/                                     \/\/ but necessary for the verifier\n-                \/\/   invokevirtual <unboxing method>\n-                \/\/   <widening conversion bytecode, if necessary>\n-                \/\/   goto <next parameter label>\n-                \/\/ <next unboxing label:> ...\n-                \/\/ last unboxing label:\n-                \/\/   new <IllegalArgumentException>\n-                \/\/   dup\n-                \/\/   invokespecial <IllegalArgumentException ctor>\n-                \/\/   athrow\n-\n-                Label l = null; \/\/ unboxing label\n-                nextParamLabel = new Label();\n-\n-                for (int j = 0; j < primitiveTypes.length; j++) {\n-                    Class<?> c = primitiveTypes[j];\n-                    if (canWidenTo(c, paramType)) {\n-                        if (l != null) {\n-                            l.bind();\n-                        }\n-                        \/\/ Emit checking and unboxing code for this type\n-                        if (isConstructor) {\n-                            cb.opc_aload_2();\n-                        } else {\n-                            cb.opc_aload_3();\n-                        }\n-                        cb.opc_instanceof(indexForPrimitiveType(c));\n-                        l = new Label();\n-                        cb.opc_ifeq(l);\n-                        if (isConstructor) {\n-                            cb.opc_aload_2();\n-                        } else {\n-                            cb.opc_aload_3();\n-                        }\n-                        cb.opc_checkcast(indexForPrimitiveType(c));\n-                        cb.opc_invokevirtual(unboxingMethodForPrimitiveType(c),\n-                                             0,\n-                                             typeSizeInStackSlots(c));\n-                        emitWideningBytecodeForPrimitiveConversion(cb,\n-                                                                   c,\n-                                                                   paramType);\n-                        cb.opc_goto(nextParamLabel);\n-                    }\n-                }\n-\n-                if (l == null) {\n-                    throw new InternalError\n-                        (\"Must have found at least identity conversion\");\n-                }\n-\n-                \/\/ Fell through; given object is null or invalid. According to\n-                \/\/ the spec, we can throw IllegalArgumentException for both of\n-                \/\/ these cases.\n-\n-                l.bind();\n-                cb.opc_new(illegalArgumentClass);\n-                cb.opc_dup();\n-                cb.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);\n-                cb.opc_athrow();\n-            } else {\n-                \/\/ Emit appropriate checkcast\n-                cb.opc_checkcast(paramTypeCPIdx);\n-                paramTypeCPIdx = add(paramTypeCPIdx, S2);\n-                \/\/ Fall through to next argument\n-            }\n-        }\n-        \/\/ Bind last goto if present\n-        if (nextParamLabel != null) {\n-            nextParamLabel.bind();\n-        }\n-\n-        short invokeStartPC = cb.getLength();\n-\n-        \/\/ OK, ready to perform the invocation.\n-        if (isConstructor) {\n-            cb.opc_invokespecial(targetMethodRef, count, 0);\n-        } else {\n-            if (isStatic()) {\n-                cb.opc_invokestatic(targetMethodRef,\n-                                    count,\n-                                    typeSizeInStackSlots(returnType));\n-            } else {\n-                if (isInterface()) {\n-                    cb.opc_invokeinterface(targetMethodRef,\n-                                           count,\n-                                           count,\n-                                           typeSizeInStackSlots(returnType));\n-                } else {\n-                    cb.opc_invokevirtual(targetMethodRef,\n-                                         count,\n-                                         typeSizeInStackSlots(returnType));\n-                }\n-            }\n-        }\n-\n-        short invokeEndPC = cb.getLength();\n-\n-        if (!isConstructor) {\n-            \/\/ Box return value if necessary\n-            if (isPrimitive(returnType)) {\n-                cb.opc_invokestatic(boxingMethodForPrimitiveType(returnType),\n-                                    typeSizeInStackSlots(returnType),\n-                                    0);\n-            } else if (returnType == Void.TYPE) {\n-                cb.opc_aconst_null();\n-            }\n-        }\n-        cb.opc_areturn();\n-\n-        \/\/ We generate two exception handlers; one which is responsible\n-        \/\/ for catching ClassCastException and NullPointerException and\n-        \/\/ throwing IllegalArgumentException, and the other which catches\n-        \/\/ all java\/lang\/Throwable objects thrown from the target method\n-        \/\/ and wraps them in InvocationTargetExceptions.\n-\n-        short classCastHandler = cb.getLength();\n-\n-        \/\/ ClassCast, etc. exception handler\n-        cb.setStack(1);\n-        cb.opc_invokespecial(toStringIdx, 0, 1);\n-        cb.opc_new(illegalArgumentClass);\n-        cb.opc_dup_x1();\n-        cb.opc_swap();\n-        cb.opc_invokespecial(illegalArgumentStringCtorIdx, 1, 0);\n-        cb.opc_athrow();\n-\n-        short invocationTargetHandler = cb.getLength();\n-\n-        \/\/ InvocationTargetException exception handler\n-        cb.setStack(1);\n-        cb.opc_new(invocationTargetClass);\n-        cb.opc_dup_x1();\n-        cb.opc_swap();\n-        cb.opc_invokespecial(invocationTargetCtorIdx, 1, 0);\n-        cb.opc_athrow();\n-\n-        \/\/ Generate exception table. We cover the entire code sequence\n-        \/\/ with an exception handler which catches ClassCastException and\n-        \/\/ converts it into an IllegalArgumentException.\n-\n-        ClassFileAssembler exc = new ClassFileAssembler();\n-\n-        exc.emitShort(illegalArgStartPC);       \/\/ start PC\n-        exc.emitShort(invokeStartPC);           \/\/ end PC\n-        exc.emitShort(classCastHandler);        \/\/ handler PC\n-        exc.emitShort(classCastClass);          \/\/ catch type\n-\n-        exc.emitShort(illegalArgStartPC);       \/\/ start PC\n-        exc.emitShort(invokeStartPC);           \/\/ end PC\n-        exc.emitShort(classCastHandler);        \/\/ handler PC\n-        exc.emitShort(nullPointerClass);        \/\/ catch type\n-\n-        exc.emitShort(invokeStartPC);           \/\/ start PC\n-        exc.emitShort(invokeEndPC);             \/\/ end PC\n-        exc.emitShort(invocationTargetHandler); \/\/ handler PC\n-        exc.emitShort(throwableClass);          \/\/ catch type\n-\n-        emitMethod(invokeIdx, cb.getMaxLocals(), cb, exc,\n-                   new short[] { invocationTargetClass });\n-    }\n-\n-    private boolean usesPrimitiveTypes() {\n-        \/\/ We need to emit boxing\/unboxing constant pool information if\n-        \/\/ the method takes a primitive type for any of its parameters or\n-        \/\/ returns a primitive value (except void)\n-        if (returnType.isPrimitive()) {\n-            return true;\n-        }\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            if (parameterTypes[i].isPrimitive()) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private int numNonPrimitiveParameterTypes() {\n-        int num = 0;\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            if (!parameterTypes[i].isPrimitive()) {\n-                ++num;\n-            }\n-        }\n-        return num;\n-    }\n-\n-    private boolean isInterface() {\n-        return declaringClass.isInterface();\n-    }\n-\n-    private String buildInternalSignature() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"(\");\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            sb.append(getClassName(parameterTypes[i], true));\n-        }\n-        sb.append(\")\");\n-        sb.append(getClassName(returnType, true));\n-        return sb.toString();\n-    }\n-\n-    private static synchronized String generateName(boolean isConstructor,\n-                                                    boolean forSerialization)\n-    {\n-        if (isConstructor) {\n-            if (forSerialization) {\n-                int num = ++serializationConstructorSymnum;\n-                return \"jdk\/internal\/reflect\/GeneratedSerializationConstructorAccessor\" + num;\n-            } else {\n-                int num = ++constructorSymnum;\n-                return \"jdk\/internal\/reflect\/GeneratedConstructorAccessor\" + num;\n-            }\n-        } else {\n-            int num = ++methodSymnum;\n-            return \"jdk\/internal\/reflect\/GeneratedMethodAccessor\" + num;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationConstructorAccessorGenerator.java","additions":0,"deletions":725,"binary":false,"changes":725,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** <P> Java serialization (in java.io) expects to be able to\n-    instantiate a class and invoke a no-arg constructor of that\n-    class's first non-Serializable superclass. This is not a valid\n-    operation according to the VM specification; one can not (for\n-    classes A and B, where B is a subclass of A) write \"new B;\n-    invokespecial A()\" without getting a verification error. <\/P>\n-\n-    <P> In all other respects, the bytecode-based reflection framework\n-    can be reused for this purpose. This marker class was originally\n-    known to the VM and verification disabled for it and all\n-    subclasses, but the bug fix for 4486457 necessitated disabling\n-    verification for all of the dynamically-generated bytecodes\n-    associated with reflection. This class has been left in place to\n-    make future debugging easier. <\/P> *\/\n-\n-abstract class SerializationConstructorAccessorImpl\n-    extends ConstructorAccessorImpl {\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationConstructorAccessorImpl.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"}]}