{"files":[{"patch":"@@ -1,722 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.lang.reflect.*;\n-import jdk.internal.misc.Unsafe;\n-\n-\/** Shared functionality for all accessor generators *\/\n-\n-class AccessorGenerator implements ClassFileConstants {\n-    static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    \/\/ Constants because there's no way to say \"short integer constant\",\n-    \/\/ i.e., \"1S\"\n-    protected static final short S0 = (short) 0;\n-    protected static final short S1 = (short) 1;\n-    protected static final short S2 = (short) 2;\n-    protected static final short S3 = (short) 3;\n-    protected static final short S4 = (short) 4;\n-    protected static final short S5 = (short) 5;\n-    protected static final short S6 = (short) 6;\n-\n-    \/\/ Instance variables for shared functionality\n-    protected ClassFileAssembler asm;\n-    protected int   modifiers;\n-    protected short thisClass;\n-    protected short superClass;\n-    protected short targetClass;\n-    \/\/ Common constant pool entries to FieldAccessor and MethodAccessor\n-    protected short throwableClass;\n-    protected short classCastClass;\n-    protected short nullPointerClass;\n-    protected short illegalArgumentClass;\n-    protected short invocationTargetClass;\n-    protected short initIdx;\n-    protected short initNameAndTypeIdx;\n-    protected short initStringNameAndTypeIdx;\n-    protected short nullPointerCtorIdx;\n-    protected short illegalArgumentCtorIdx;\n-    protected short illegalArgumentStringCtorIdx;\n-    protected short invocationTargetCtorIdx;\n-    protected short superCtorIdx;\n-    protected short objectClass;\n-    protected short toStringIdx;\n-    protected short codeIdx;\n-    protected short exceptionsIdx;\n-    \/\/ Boxing\n-    protected short valueOfIdx;\n-    protected short booleanIdx;\n-    protected short booleanBoxIdx;\n-    protected short booleanUnboxIdx;\n-    protected short byteIdx;\n-    protected short byteBoxIdx;\n-    protected short byteUnboxIdx;\n-    protected short characterIdx;\n-    protected short characterBoxIdx;\n-    protected short characterUnboxIdx;\n-    protected short doubleIdx;\n-    protected short doubleBoxIdx;\n-    protected short doubleUnboxIdx;\n-    protected short floatIdx;\n-    protected short floatBoxIdx;\n-    protected short floatUnboxIdx;\n-    protected short integerIdx;\n-    protected short integerBoxIdx;\n-    protected short integerUnboxIdx;\n-    protected short longIdx;\n-    protected short longBoxIdx;\n-    protected short longUnboxIdx;\n-    protected short shortIdx;\n-    protected short shortBoxIdx;\n-    protected short shortUnboxIdx;\n-\n-    protected final short NUM_COMMON_CPOOL_ENTRIES = (short) 30;\n-    protected final short NUM_BOXING_CPOOL_ENTRIES = (short) 73;\n-\n-    \/\/ Requires that superClass has been set up\n-    protected void emitCommonConstantPoolEntries() {\n-        \/\/ +   [UTF-8] \"java\/lang\/Throwable\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/ClassCastException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/NullPointerException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/IllegalArgumentException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/InvocationTargetException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"<init>\"\n-        \/\/ +   [UTF-8] \"()V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for above\n-        \/\/ +   [CONSTANT_Methodref_info] for NullPointerException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for InvocationTargetException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for \"super()\"\n-        \/\/ +   [UTF-8] \"java\/lang\/Object\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"toString\"\n-        \/\/ +   [UTF-8] \"()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"toString()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_Methodref_info] for Object's toString method\n-        \/\/ +   [UTF-8] \"Code\"\n-        \/\/ +   [UTF-8] \"Exceptions\"\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Throwable\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        throwableClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/ClassCastException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        classCastClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/NullPointerException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        nullPointerClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/IllegalArgumentException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        illegalArgumentClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/reflect\/InvocationTargetException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        invocationTargetClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"<init>\");\n-        initIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"()V\");\n-        asm.emitConstantPoolNameAndType(initIdx, asm.cpi());\n-        initNameAndTypeIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(nullPointerClass, initNameAndTypeIdx);\n-        nullPointerCtorIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(illegalArgumentClass, initNameAndTypeIdx);\n-        illegalArgumentCtorIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(Ljava\/lang\/String;)V\");\n-        asm.emitConstantPoolNameAndType(initIdx, asm.cpi());\n-        initStringNameAndTypeIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(illegalArgumentClass, initStringNameAndTypeIdx);\n-        illegalArgumentStringCtorIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(Ljava\/lang\/Throwable;)V\");\n-        asm.emitConstantPoolNameAndType(initIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(invocationTargetClass, asm.cpi());\n-        invocationTargetCtorIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(superClass, initNameAndTypeIdx);\n-        superCtorIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Object\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        objectClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"toString\");\n-        asm.emitConstantPoolUTF8(\"()Ljava\/lang\/String;\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(objectClass, asm.cpi());\n-        toStringIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"Code\");\n-        codeIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"Exceptions\");\n-        exceptionsIdx = asm.cpi();\n-    }\n-\n-    \/** Constant pool entries required to be able to box\/unbox primitive\n-        types. Note that we don't emit these if we don't need them. *\/\n-    protected void emitBoxingContantPoolEntries() {\n-        \/\/  *  [UTF-8] \"valueOf\"\n-        \/\/  *  [UTF-8] \"java\/lang\/Boolean\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(Z)Ljava\/lang\/Boolean;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"booleanValue\"\n-        \/\/  *  [UTF-8] \"()Z\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Byte\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(B)Ljava\/lang\/Byte;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"byteValue\"\n-        \/\/  *  [UTF-8] \"()B\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Character\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(C)Ljava\/lang\/Character;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"charValue\"\n-        \/\/  *  [UTF-8] \"()C\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Double\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(D)Ljava\/lang\/Double;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"doubleValue\"\n-        \/\/  *  [UTF-8] \"()D\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Float\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(F)Ljava\/lang\/Float;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"floatValue\"\n-        \/\/  *  [UTF-8] \"()F\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Integer\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(I)Ljava\/lang\/Integer;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"intValue\"\n-        \/\/  *  [UTF-8] \"()I\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Long\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(J)Ljava\/lang\/Long;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"longValue\"\n-        \/\/  *  [UTF-8] \"()J\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Short\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(S)Ljava\/lang\/Short;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"shortValue\"\n-        \/\/  *  [UTF-8] \"()S\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-\n-        \/\/ valueOf-method name\n-        asm.emitConstantPoolUTF8(\"valueOf\");\n-        valueOfIdx = asm.cpi();\n-\n-        \/\/ Boolean\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Boolean\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        booleanIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(Z)Ljava\/lang\/Boolean;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        booleanBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"booleanValue\");\n-        asm.emitConstantPoolUTF8(\"()Z\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        booleanUnboxIdx = asm.cpi();\n-\n-        \/\/ Byte\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Byte\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        byteIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(B)Ljava\/lang\/Byte;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        byteBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"byteValue\");\n-        asm.emitConstantPoolUTF8(\"()B\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        byteUnboxIdx = asm.cpi();\n-\n-        \/\/ Character\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Character\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        characterIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(C)Ljava\/lang\/Character;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        characterBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"charValue\");\n-        asm.emitConstantPoolUTF8(\"()C\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        characterUnboxIdx = asm.cpi();\n-\n-        \/\/ Double\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Double\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        doubleIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(D)Ljava\/lang\/Double;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        doubleBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"doubleValue\");\n-        asm.emitConstantPoolUTF8(\"()D\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        doubleUnboxIdx = asm.cpi();\n-\n-        \/\/ Float\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Float\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        floatIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(F)Ljava\/lang\/Float;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        floatBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"floatValue\");\n-        asm.emitConstantPoolUTF8(\"()F\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        floatUnboxIdx = asm.cpi();\n-\n-        \/\/ Integer\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Integer\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        integerIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(I)Ljava\/lang\/Integer;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        integerBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"intValue\");\n-        asm.emitConstantPoolUTF8(\"()I\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        integerUnboxIdx = asm.cpi();\n-\n-        \/\/ Long\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Long\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        longIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(J)Ljava\/lang\/Long;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        longBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"longValue\");\n-        asm.emitConstantPoolUTF8(\"()J\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        longUnboxIdx = asm.cpi();\n-\n-        \/\/ Short\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Short\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        shortIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(S)Ljava\/lang\/Short;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        shortBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"shortValue\");\n-        asm.emitConstantPoolUTF8(\"()S\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        shortUnboxIdx = asm.cpi();\n-    }\n-\n-    \/\/ Necessary because of Java's annoying promotion rules\n-    protected static short add(short s1, short s2) {\n-        return (short) (s1 + s2);\n-    }\n-\n-    protected static short sub(short s1, short s2) {\n-        return (short) (s1 - s2);\n-    }\n-\n-    protected boolean isStatic() {\n-        return Modifier.isStatic(modifiers);\n-    }\n-\n-    protected boolean isPrivate() {\n-        return Modifier.isPrivate(modifiers);\n-    }\n-\n-    \/** Returns class name in \"internal\" form (i.e., '\/' separators\n-        instead of '.') *\/\n-    protected static String getClassName\n-        (Class<?> c, boolean addPrefixAndSuffixForNonPrimitiveTypes)\n-    {\n-        if (c.isPrimitive()) {\n-            if (c == Boolean.TYPE) {\n-                return \"Z\";\n-            } else if (c == Byte.TYPE) {\n-                return \"B\";\n-            } else if (c == Character.TYPE) {\n-                return \"C\";\n-            } else if (c == Double.TYPE) {\n-                return \"D\";\n-            } else if (c == Float.TYPE) {\n-                return \"F\";\n-            } else if (c == Integer.TYPE) {\n-                return \"I\";\n-            } else if (c == Long.TYPE) {\n-                return \"J\";\n-            } else if (c == Short.TYPE) {\n-                return \"S\";\n-            } else if (c == Void.TYPE) {\n-                return \"V\";\n-            }\n-            throw new InternalError(\"Should have found primitive type\");\n-        } else if (c.isArray()) {\n-            return \"[\" + getClassName(c.getComponentType(), true);\n-        } else {\n-            if (addPrefixAndSuffixForNonPrimitiveTypes) {\n-                return internalize(\"L\" + c.getName() + \";\");\n-            } else {\n-                return internalize(c.getName());\n-            }\n-        }\n-    }\n-\n-    private static String internalize(String className) {\n-        return className.replace('.', '\/');\n-    }\n-\n-    protected void emitConstructor() {\n-        \/\/ Generate code into fresh code buffer\n-        ClassFileAssembler cb = new ClassFileAssembler();\n-        \/\/ 0 incoming arguments\n-        cb.setMaxLocals(1);\n-        cb.opc_aload_0();\n-        cb.opc_invokespecial(superCtorIdx, 0, 0);\n-        cb.opc_return();\n-\n-        \/\/ Emit method\n-        emitMethod(initIdx, cb.getMaxLocals(), cb, null, null);\n-    }\n-\n-    \/\/ The descriptor's index in the constant pool must be (1 +\n-    \/\/ nameIdx). \"numArgs\" must indicate ALL arguments, including the\n-    \/\/ implicit \"this\" argument; double and long arguments each count\n-    \/\/ as 2 in this count. The code buffer must NOT contain the code\n-    \/\/ length. The exception table may be null, but if non-null must\n-    \/\/ NOT contain the exception table's length. The checked exception\n-    \/\/ indices may be null.\n-    protected void emitMethod(short nameIdx,\n-                              int numArgs,\n-                              ClassFileAssembler code,\n-                              ClassFileAssembler exceptionTable,\n-                              short[] checkedExceptionIndices)\n-    {\n-        int codeLen = code.getLength();\n-        int excLen  = 0;\n-        if (exceptionTable != null) {\n-            excLen = exceptionTable.getLength();\n-            if ((excLen % 8) != 0) {\n-                throw new IllegalArgumentException(\"Illegal exception table\");\n-            }\n-        }\n-        int attrLen = 12 + codeLen + excLen;\n-        excLen = excLen \/ 8; \/\/ No-op if no exception table\n-\n-        asm.emitShort(ACC_PUBLIC);\n-        asm.emitShort(nameIdx);\n-        asm.emitShort(add(nameIdx, S1));\n-        if (checkedExceptionIndices == null) {\n-            \/\/ Code attribute only\n-            asm.emitShort(S1);\n-        } else {\n-            \/\/ Code and Exceptions attributes\n-            asm.emitShort(S2);\n-        }\n-        \/\/ Code attribute\n-        asm.emitShort(codeIdx);\n-        asm.emitInt(attrLen);\n-        asm.emitShort(code.getMaxStack());\n-        asm.emitShort((short) Math.max(numArgs, code.getMaxLocals()));\n-        asm.emitInt(codeLen);\n-        asm.append(code);\n-        asm.emitShort((short) excLen);\n-        if (exceptionTable != null) {\n-            asm.append(exceptionTable);\n-        }\n-        asm.emitShort(S0); \/\/ No additional attributes for Code attribute\n-        if (checkedExceptionIndices != null) {\n-            \/\/ Exceptions attribute\n-            asm.emitShort(exceptionsIdx);\n-            asm.emitInt(2 + 2 * checkedExceptionIndices.length);\n-            asm.emitShort((short) checkedExceptionIndices.length);\n-            for (int i = 0; i < checkedExceptionIndices.length; i++) {\n-                asm.emitShort(checkedExceptionIndices[i]);\n-            }\n-        }\n-    }\n-\n-    protected short indexForPrimitiveType(Class<?> type) {\n-        if (type == Boolean.TYPE) {\n-            return booleanIdx;\n-        } else if (type == Byte.TYPE) {\n-            return byteIdx;\n-        } else if (type == Character.TYPE) {\n-            return characterIdx;\n-        } else if (type == Double.TYPE) {\n-            return doubleIdx;\n-        } else if (type == Float.TYPE) {\n-            return floatIdx;\n-        } else if (type == Integer.TYPE) {\n-            return integerIdx;\n-        } else if (type == Long.TYPE) {\n-            return longIdx;\n-        } else if (type == Short.TYPE) {\n-            return shortIdx;\n-        }\n-        throw new InternalError(\"Should have found primitive type\");\n-    }\n-\n-    protected short boxingMethodForPrimitiveType(Class<?> type) {\n-        if (type == Boolean.TYPE) {\n-            return booleanBoxIdx;\n-        } else if (type == Byte.TYPE) {\n-            return byteBoxIdx;\n-        } else if (type == Character.TYPE) {\n-            return characterBoxIdx;\n-        } else if (type == Double.TYPE) {\n-            return doubleBoxIdx;\n-        } else if (type == Float.TYPE) {\n-            return floatBoxIdx;\n-        } else if (type == Integer.TYPE) {\n-            return integerBoxIdx;\n-        } else if (type == Long.TYPE) {\n-            return longBoxIdx;\n-        } else if (type == Short.TYPE) {\n-            return shortBoxIdx;\n-        }\n-        throw new InternalError(\"Should have found primitive type\");\n-    }\n-\n-    \/** Returns true for widening or identity conversions for primitive\n-        types only *\/\n-    protected static boolean canWidenTo(Class<?> type, Class<?> otherType) {\n-        if (!type.isPrimitive()) {\n-            return false;\n-        }\n-\n-        \/\/ Widening conversions (from JVM spec):\n-        \/\/  byte to short, int, long, float, or double\n-        \/\/  short to int, long, float, or double\n-        \/\/  char to int, long, float, or double\n-        \/\/  int to long, float, or double\n-        \/\/  long to float or double\n-        \/\/  float to double\n-\n-        if (type == Boolean.TYPE) {\n-            if (otherType == Boolean.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Byte.TYPE) {\n-            if (   otherType == Byte.TYPE\n-                   || otherType == Short.TYPE\n-                   || otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Short.TYPE) {\n-            if (   otherType == Short.TYPE\n-                   || otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Character.TYPE) {\n-            if (   otherType == Character.TYPE\n-                   || otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Integer.TYPE) {\n-            if (   otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Long.TYPE) {\n-            if (   otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Float.TYPE) {\n-            if (   otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Double.TYPE) {\n-            if (otherType == Double.TYPE) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    \/** Emits the widening bytecode for the given primitive conversion\n-        (or none if the identity conversion). Requires that a primitive\n-        conversion exists; i.e., canWidenTo must have already been\n-        called and returned true. *\/\n-    protected static void emitWideningBytecodeForPrimitiveConversion\n-        (ClassFileAssembler cb,\n-         Class<?> fromType,\n-         Class<?> toType)\n-    {\n-        \/\/ Note that widening conversions for integral types (i.e., \"b2s\",\n-        \/\/ \"s2i\") are no-ops since values on the Java stack are\n-        \/\/ sign-extended.\n-\n-        \/\/ Widening conversions (from JVM spec):\n-        \/\/  byte to short, int, long, float, or double\n-        \/\/  short to int, long, float, or double\n-        \/\/  char to int, long, float, or double\n-        \/\/  int to long, float, or double\n-        \/\/  long to float or double\n-        \/\/  float to double\n-\n-        if (   fromType == Byte.TYPE\n-               || fromType == Short.TYPE\n-               || fromType == Character.TYPE\n-               || fromType == Integer.TYPE) {\n-            if (toType == Long.TYPE) {\n-                cb.opc_i2l();\n-            } else if (toType == Float.TYPE) {\n-                cb.opc_i2f();\n-            } else if (toType == Double.TYPE) {\n-                cb.opc_i2d();\n-            }\n-        } else if (fromType == Long.TYPE) {\n-            if (toType == Float.TYPE) {\n-                cb.opc_l2f();\n-            } else if (toType == Double.TYPE) {\n-                cb.opc_l2d();\n-            }\n-        } else if (fromType == Float.TYPE) {\n-            if (toType == Double.TYPE) {\n-                cb.opc_f2d();\n-            }\n-        }\n-\n-        \/\/ Otherwise, was identity or no-op conversion. Fall through.\n-    }\n-\n-    protected short unboxingMethodForPrimitiveType(Class<?> primType) {\n-        if (primType == Boolean.TYPE) {\n-            return booleanUnboxIdx;\n-        } else if (primType == Byte.TYPE) {\n-            return byteUnboxIdx;\n-        } else if (primType == Character.TYPE) {\n-            return characterUnboxIdx;\n-        } else if (primType == Short.TYPE) {\n-            return shortUnboxIdx;\n-        } else if (primType == Integer.TYPE) {\n-            return integerUnboxIdx;\n-        } else if (primType == Long.TYPE) {\n-            return longUnboxIdx;\n-        } else if (primType == Float.TYPE) {\n-            return floatUnboxIdx;\n-        } else if (primType == Double.TYPE) {\n-            return doubleUnboxIdx;\n-        }\n-        throw new InternalError(\"Illegal primitive type \" + primType.getName());\n-    }\n-\n-    protected static final Class<?>[] primitiveTypes = new Class<?>[] {\n-        Boolean.TYPE,\n-        Byte.TYPE,\n-        Character.TYPE,\n-        Short.TYPE,\n-        Integer.TYPE,\n-        Long.TYPE,\n-        Float.TYPE,\n-        Double.TYPE\n-    };\n-\n-    \/** We don't consider \"Void\" to be a primitive type *\/\n-    protected static boolean isPrimitive(Class<?> c) {\n-        return (c.isPrimitive() && c != Void.TYPE);\n-    }\n-\n-    protected int typeSizeInStackSlots(Class<?> c) {\n-        if (c == Void.TYPE) {\n-            return 0;\n-        }\n-        if (c == Long.TYPE || c == Double.TYPE) {\n-            return 2;\n-        }\n-        return 1;\n-    }\n-\n-    private ClassFileAssembler illegalArgumentCodeBuffer;\n-    protected ClassFileAssembler illegalArgumentCodeBuffer() {\n-        if (illegalArgumentCodeBuffer == null) {\n-            illegalArgumentCodeBuffer = new ClassFileAssembler();\n-            illegalArgumentCodeBuffer.opc_new(illegalArgumentClass);\n-            illegalArgumentCodeBuffer.opc_dup();\n-            illegalArgumentCodeBuffer.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);\n-            illegalArgumentCodeBuffer.opc_athrow();\n-        }\n-\n-        return illegalArgumentCodeBuffer;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/AccessorGenerator.java","additions":0,"deletions":722,"binary":false,"changes":722,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** A growable array of bytes. *\/\n-\n-interface ByteVector {\n-    public int  getLength();\n-    public byte get(int index);\n-    public void put(int index, byte value);\n-    public void add(byte value);\n-    public void trim();\n-    public byte[] getData();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ByteVector.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-class ByteVectorFactory {\n-    static ByteVector create() {\n-        return new ByteVectorImpl();\n-    }\n-\n-    static ByteVector create(int sz) {\n-        return new ByteVectorImpl(sz);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ByteVectorFactory.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-class ByteVectorImpl implements ByteVector {\n-    private byte[] data;\n-    private int pos;\n-\n-    public ByteVectorImpl() {\n-        this(100);\n-    }\n-\n-    public ByteVectorImpl(int sz) {\n-        data = new byte[sz];\n-        pos = -1;\n-    }\n-\n-    public int getLength() {\n-        return pos + 1;\n-    }\n-\n-    public byte get(int index) {\n-        if (index >= data.length) {\n-            resize(index);\n-            pos = index;\n-        }\n-        return data[index];\n-    }\n-\n-    public void put(int index, byte value) {\n-        if (index >= data.length) {\n-            resize(index);\n-            pos = index;\n-        }\n-        data[index] = value;\n-    }\n-\n-    public void add(byte value) {\n-        if (++pos >= data.length) {\n-            resize(pos);\n-        }\n-        data[pos] = value;\n-    }\n-\n-    public void trim() {\n-        if (pos != data.length - 1) {\n-            byte[] newData = new byte[pos + 1];\n-            System.arraycopy(data, 0, newData, 0, pos + 1);\n-            data = newData;\n-        }\n-    }\n-\n-    public byte[] getData() {\n-        return data;\n-    }\n-\n-    private void resize(int minSize) {\n-        if (minSize <= 2 * data.length) {\n-            minSize = 2 * data.length;\n-        }\n-        byte[] newData = new byte[minSize];\n-        System.arraycopy(data, 0, newData, 0, data.length);\n-        data = newData;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ByteVectorImpl.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,671 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import sun.nio.cs.UTF_8;\n-\n-class ClassFileAssembler implements ClassFileConstants {\n-    private ByteVector vec;\n-    private short cpIdx = 0;\n-\n-    public ClassFileAssembler() {\n-        this(ByteVectorFactory.create());\n-    }\n-\n-    public ClassFileAssembler(ByteVector vec) {\n-        this.vec = vec;\n-    }\n-\n-    public ByteVector getData() {\n-        return vec;\n-    }\n-\n-    \/** Length in bytes *\/\n-    public short getLength() {\n-        return (short) vec.getLength();\n-    }\n-\n-    public void emitMagicAndVersion() {\n-        emitInt(0xCAFEBABE);\n-        emitShort((short) 0);\n-        emitShort((short) 49);\n-    }\n-\n-    public void emitInt(int val) {\n-        emitByte((byte) (val >> 24));\n-        emitByte((byte) ((val >> 16) & 0xFF));\n-        emitByte((byte) ((val >> 8) & 0xFF));\n-        emitByte((byte) (val & 0xFF));\n-    }\n-\n-    public void emitShort(short val) {\n-        emitByte((byte) ((val >> 8) & 0xFF));\n-        emitByte((byte) (val & 0xFF));\n-    }\n-\n-    \/\/ Support for labels; package-private\n-    void emitShort(short bci, short val) {\n-        vec.put(bci,     (byte) ((val >> 8) & 0xFF));\n-        vec.put(bci + 1, (byte) (val & 0xFF));\n-    }\n-\n-    public void emitByte(byte val) {\n-        vec.add(val);\n-    }\n-\n-    public void append(ClassFileAssembler asm) {\n-        append(asm.vec);\n-    }\n-\n-    public void append(ByteVector vec) {\n-        for (int i = 0; i < vec.getLength(); i++) {\n-            emitByte(vec.get(i));\n-        }\n-    }\n-\n-    \/** Keeps track of the current (one-based) constant pool index;\n-        incremented after emitting one of the following constant pool\n-        entries. Can fetch the current constant pool index for use in\n-        later entries.  Index points at the last valid constant pool\n-        entry; initially invalid. It is illegal to fetch the constant\n-        pool index before emitting at least one constant pool entry. *\/\n-    public short cpi() {\n-        if (cpIdx == 0) {\n-            throw new RuntimeException(\"Illegal use of ClassFileAssembler\");\n-        }\n-        return cpIdx;\n-    }\n-\n-    public void emitConstantPoolUTF8(String str) {\n-        byte[] bytes = str.getBytes(UTF_8.INSTANCE);\n-        emitByte(CONSTANT_Utf8);\n-        emitShort((short) bytes.length);\n-        for (int i = 0; i < bytes.length; i++) {\n-            emitByte(bytes[i]);\n-        }\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolClass(short index) {\n-        emitByte(CONSTANT_Class);\n-        emitShort(index);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolNameAndType(short nameIndex, short typeIndex) {\n-        emitByte(CONSTANT_NameAndType);\n-        emitShort(nameIndex);\n-        emitShort(typeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolFieldref\n-        (short classIndex, short nameAndTypeIndex)\n-    {\n-        emitByte(CONSTANT_Fieldref);\n-        emitShort(classIndex);\n-        emitShort(nameAndTypeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolMethodref\n-        (short classIndex, short nameAndTypeIndex)\n-    {\n-        emitByte(CONSTANT_Methodref);\n-        emitShort(classIndex);\n-        emitShort(nameAndTypeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolInterfaceMethodref\n-        (short classIndex, short nameAndTypeIndex)\n-    {\n-        emitByte(CONSTANT_InterfaceMethodref);\n-        emitShort(classIndex);\n-        emitShort(nameAndTypeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolString(short utf8Index) {\n-        emitByte(CONSTANT_String);\n-        emitShort(utf8Index);\n-        cpIdx++;\n-    }\n-\n-    \/\/----------------------------------------------------------------------\n-    \/\/ Opcodes. Keeps track of maximum stack and locals. Make a new\n-    \/\/ assembler for each piece of assembled code, then append the\n-    \/\/ result to the previous assembler's class file.\n-    \/\/\n-\n-    private int stack     = 0;\n-    private int maxStack  = 0;\n-    private int maxLocals = 0;\n-\n-    private void incStack() {\n-        setStack(stack + 1);\n-    }\n-\n-    private void decStack() {\n-        --stack;\n-    }\n-\n-    public short getMaxStack() {\n-        return (short) maxStack;\n-    }\n-\n-    public short getMaxLocals() {\n-        return (short) maxLocals;\n-    }\n-\n-    \/** It's necessary to be able to specify the number of arguments at\n-        the beginning of the method (which translates to the initial\n-        value of max locals) *\/\n-    public void setMaxLocals(int maxLocals) {\n-        this.maxLocals = maxLocals;\n-    }\n-\n-    \/** Needed to do flow control. Returns current stack depth. *\/\n-    public int getStack() {\n-        return stack;\n-    }\n-\n-    \/** Needed to do flow control. *\/\n-    public void setStack(int value) {\n-        stack = value;\n-        if (stack > maxStack) {\n-            maxStack = stack;\n-        }\n-    }\n-\n-    \/\/-----------\/\/\n-    \/\/ Constants \/\/\n-    \/\/-----------\/\/\n-\n-    public void opc_aconst_null() {\n-        emitByte(opc_aconst_null);\n-        incStack();\n-    }\n-\n-    public void opc_sipush(short constant) {\n-        emitByte(opc_sipush);\n-        emitShort(constant);\n-        incStack();\n-    }\n-\n-    public void opc_ldc(byte cpIdx) {\n-        emitByte(opc_ldc);\n-        emitByte(cpIdx);\n-        incStack();\n-    }\n-\n-    \/\/---------------------------------\/\/\n-    \/\/ Local variable loads and stores \/\/\n-    \/\/---------------------------------\/\/\n-\n-    public void opc_iload_0() {\n-        emitByte(opc_iload_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        incStack();\n-    }\n-\n-    public void opc_iload_1() {\n-        emitByte(opc_iload_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-    }\n-\n-    public void opc_iload_2() {\n-        emitByte(opc_iload_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-    }\n-\n-    public void opc_iload_3() {\n-        emitByte(opc_iload_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-    }\n-\n-    public void opc_lload_0() {\n-        emitByte(opc_lload_0);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_lload_1() {\n-        emitByte(opc_lload_1);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_lload_2() {\n-        emitByte(opc_lload_2);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_lload_3() {\n-        emitByte(opc_lload_3);\n-        if (maxLocals < 5) maxLocals = 5;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_fload_0() {\n-        emitByte(opc_fload_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        incStack();\n-    }\n-\n-    public void opc_fload_1() {\n-        emitByte(opc_fload_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-    }\n-\n-    public void opc_fload_2() {\n-        emitByte(opc_fload_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-    }\n-\n-    public void opc_fload_3() {\n-        emitByte(opc_fload_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-    }\n-\n-    public void opc_dload_0() {\n-        emitByte(opc_dload_0);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_dload_1() {\n-        emitByte(opc_dload_1);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_dload_2() {\n-        emitByte(opc_dload_2);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_dload_3() {\n-        emitByte(opc_dload_3);\n-        if (maxLocals < 5) maxLocals = 5;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_aload_0() {\n-        emitByte(opc_aload_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        incStack();\n-    }\n-\n-    public void opc_aload_1() {\n-        emitByte(opc_aload_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-    }\n-\n-    public void opc_aload_2() {\n-        emitByte(opc_aload_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-    }\n-\n-    public void opc_aload_3() {\n-        emitByte(opc_aload_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-    }\n-\n-    public void opc_aaload() {\n-        emitByte(opc_aaload);\n-        decStack();\n-    }\n-\n-    public void opc_astore_0() {\n-        emitByte(opc_astore_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        decStack();\n-    }\n-\n-    public void opc_astore_1() {\n-        emitByte(opc_astore_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        decStack();\n-    }\n-\n-    public void opc_astore_2() {\n-        emitByte(opc_astore_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        decStack();\n-    }\n-\n-    public void opc_astore_3() {\n-        emitByte(opc_astore_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        decStack();\n-    }\n-\n-    \/\/--------------------\/\/\n-    \/\/ Stack manipulation \/\/\n-    \/\/--------------------\/\/\n-\n-    public void opc_pop() {\n-        emitByte(opc_pop);\n-        decStack();\n-    }\n-\n-    public void opc_dup() {\n-        emitByte(opc_dup);\n-        incStack();\n-    }\n-\n-    public void opc_dup_x1() {\n-        emitByte(opc_dup_x1);\n-        incStack();\n-    }\n-\n-    public void opc_swap() {\n-        emitByte(opc_swap);\n-    }\n-\n-    \/\/---------------------------\/\/\n-    \/\/ Widening conversions only \/\/\n-    \/\/---------------------------\/\/\n-\n-    public void opc_i2l() {\n-        emitByte(opc_i2l);\n-    }\n-\n-    public void opc_i2f() {\n-        emitByte(opc_i2f);\n-    }\n-\n-    public void opc_i2d() {\n-        emitByte(opc_i2d);\n-    }\n-\n-    public void opc_l2f() {\n-        emitByte(opc_l2f);\n-    }\n-\n-    public void opc_l2d() {\n-        emitByte(opc_l2d);\n-    }\n-\n-    public void opc_f2d() {\n-        emitByte(opc_f2d);\n-    }\n-\n-    \/\/--------------\/\/\n-    \/\/ Control flow \/\/\n-    \/\/--------------\/\/\n-\n-    public void opc_ifeq(short bciOffset) {\n-        emitByte(opc_ifeq);\n-        emitShort(bciOffset);\n-        decStack();\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes\n-        straight-through control flow. *\/\n-    public void opc_ifeq(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_ifeq);\n-        l.add(this, instrBCI, getLength(), getStack() - 1);\n-        emitShort((short) -1); \/\/ Must be patched later\n-    }\n-\n-    public void opc_if_icmpeq(short bciOffset) {\n-        emitByte(opc_if_icmpeq);\n-        emitShort(bciOffset);\n-        setStack(getStack() - 2);\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_if_icmpeq(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_if_icmpeq);\n-        l.add(this, instrBCI, getLength(), getStack() - 2);\n-        emitShort((short) -1); \/\/ Must be patched later\n-    }\n-\n-    public void opc_goto(short bciOffset) {\n-        emitByte(opc_goto);\n-        emitShort(bciOffset);\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_goto(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_goto);\n-        l.add(this, instrBCI, getLength(), getStack());\n-        emitShort((short) -1); \/\/ Must be patched later\n-    }\n-\n-    public void opc_ifnull(short bciOffset) {\n-        emitByte(opc_ifnull);\n-        emitShort(bciOffset);\n-        decStack();\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_ifnull(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_ifnull);\n-        l.add(this, instrBCI, getLength(), getStack() - 1);\n-        emitShort((short) -1); \/\/ Must be patched later\n-        decStack();\n-    }\n-\n-    public void opc_ifnonnull(short bciOffset) {\n-        emitByte(opc_ifnonnull);\n-        emitShort(bciOffset);\n-        decStack();\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_ifnonnull(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_ifnonnull);\n-        l.add(this, instrBCI, getLength(), getStack() - 1);\n-        emitShort((short) -1); \/\/ Must be patched later\n-        decStack();\n-    }\n-\n-    \/\/---------------------\/\/\n-    \/\/ Return instructions \/\/\n-    \/\/---------------------\/\/\n-\n-    public void opc_ireturn() {\n-        emitByte(opc_ireturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_lreturn() {\n-        emitByte(opc_lreturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_freturn() {\n-        emitByte(opc_freturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_dreturn() {\n-        emitByte(opc_dreturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_areturn() {\n-        emitByte(opc_areturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_return() {\n-        emitByte(opc_return);\n-        setStack(0);\n-    }\n-\n-    \/\/------------------\/\/\n-    \/\/ Field operations \/\/\n-    \/\/------------------\/\/\n-\n-    public void opc_getstatic(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_getstatic);\n-        emitShort(fieldIndex);\n-        setStack(getStack() + fieldSizeInStackSlots);\n-    }\n-\n-    public void opc_putstatic(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_putstatic);\n-        emitShort(fieldIndex);\n-        setStack(getStack() - fieldSizeInStackSlots);\n-    }\n-\n-    public void opc_getfield(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_getfield);\n-        emitShort(fieldIndex);\n-        setStack(getStack() + fieldSizeInStackSlots - 1);\n-    }\n-\n-    public void opc_putfield(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_putfield);\n-        emitShort(fieldIndex);\n-        setStack(getStack() - fieldSizeInStackSlots - 1);\n-    }\n-\n-    \/\/--------------------\/\/\n-    \/\/ Method invocations \/\/\n-    \/\/--------------------\/\/\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokevirtual(short methodIndex,\n-                                  int numArgs,\n-                                  int numReturnValues)\n-    {\n-        emitByte(opc_invokevirtual);\n-        emitShort(methodIndex);\n-        setStack(getStack() - numArgs - 1 + numReturnValues);\n-    }\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokespecial(short methodIndex,\n-                                  int numArgs,\n-                                  int numReturnValues)\n-    {\n-        emitByte(opc_invokespecial);\n-        emitShort(methodIndex);\n-        setStack(getStack() - numArgs - 1 + numReturnValues);\n-    }\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokestatic(short methodIndex,\n-                                 int numArgs,\n-                                 int numReturnValues)\n-    {\n-        emitByte(opc_invokestatic);\n-        emitShort(methodIndex);\n-        setStack(getStack() - numArgs + numReturnValues);\n-    }\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokeinterface(short methodIndex,\n-                                    int numArgs,\n-                                    byte count,\n-                                    int numReturnValues)\n-    {\n-        emitByte(opc_invokeinterface);\n-        emitShort(methodIndex);\n-        emitByte(count);\n-        emitByte((byte) 0);\n-        setStack(getStack() - numArgs - 1 + numReturnValues);\n-    }\n-\n-    \/\/--------------\/\/\n-    \/\/ Array length \/\/\n-    \/\/--------------\/\/\n-\n-    public void opc_arraylength() {\n-        emitByte(opc_arraylength);\n-    }\n-\n-    \/\/-----\/\/\n-    \/\/ New \/\/\n-    \/\/-----\/\/\n-\n-    public void opc_new(short classIndex) {\n-        emitByte(opc_new);\n-        emitShort(classIndex);\n-        incStack();\n-    }\n-\n-    \/\/--------\/\/\n-    \/\/ Athrow \/\/\n-    \/\/--------\/\/\n-\n-    public void opc_athrow() {\n-        emitByte(opc_athrow);\n-        setStack(1);\n-    }\n-\n-    \/\/--------------------------\/\/\n-    \/\/ Checkcast and instanceof \/\/\n-    \/\/--------------------------\/\/\n-\n-    \/** Assumes the checkcast succeeds *\/\n-    public void opc_checkcast(short classIndex) {\n-        emitByte(opc_checkcast);\n-        emitShort(classIndex);\n-    }\n-\n-    public void opc_instanceof(short classIndex) {\n-        emitByte(opc_instanceof);\n-        emitShort(classIndex);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassFileAssembler.java","additions":0,"deletions":671,"binary":false,"changes":671,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** Minimal set of class file constants for assembly of field and\n-    method accessors. *\/\n-\n-interface ClassFileConstants {\n-    \/\/ Constants\n-    public static final byte opc_aconst_null   = (byte) 0x1;\n-    public static final byte opc_sipush        = (byte) 0x11;\n-    public static final byte opc_ldc           = (byte) 0x12;\n-\n-    \/\/ Local variable loads and stores\n-    public static final byte opc_iload_0       = (byte) 0x1a;\n-    public static final byte opc_iload_1       = (byte) 0x1b;\n-    public static final byte opc_iload_2       = (byte) 0x1c;\n-    public static final byte opc_iload_3       = (byte) 0x1d;\n-    public static final byte opc_lload_0       = (byte) 0x1e;\n-    public static final byte opc_lload_1       = (byte) 0x1f;\n-    public static final byte opc_lload_2       = (byte) 0x20;\n-    public static final byte opc_lload_3       = (byte) 0x21;\n-    public static final byte opc_fload_0       = (byte) 0x22;\n-    public static final byte opc_fload_1       = (byte) 0x23;\n-    public static final byte opc_fload_2       = (byte) 0x24;\n-    public static final byte opc_fload_3       = (byte) 0x25;\n-    public static final byte opc_dload_0       = (byte) 0x26;\n-    public static final byte opc_dload_1       = (byte) 0x27;\n-    public static final byte opc_dload_2       = (byte) 0x28;\n-    public static final byte opc_dload_3       = (byte) 0x29;\n-    public static final byte opc_aload_0       = (byte) 0x2a;\n-    public static final byte opc_aload_1       = (byte) 0x2b;\n-    public static final byte opc_aload_2       = (byte) 0x2c;\n-    public static final byte opc_aload_3       = (byte) 0x2d;\n-    public static final byte opc_aaload        = (byte) 0x32;\n-    public static final byte opc_astore_0      = (byte) 0x4b;\n-    public static final byte opc_astore_1      = (byte) 0x4c;\n-    public static final byte opc_astore_2      = (byte) 0x4d;\n-    public static final byte opc_astore_3      = (byte) 0x4e;\n-\n-    \/\/ Stack manipulation\n-    public static final byte opc_pop           = (byte) 0x57;\n-    public static final byte opc_dup           = (byte) 0x59;\n-    public static final byte opc_dup_x1        = (byte) 0x5a;\n-    public static final byte opc_swap          = (byte) 0x5f;\n-\n-    \/\/ Conversions\n-    public static final byte opc_i2l           = (byte) 0x85;\n-    public static final byte opc_i2f           = (byte) 0x86;\n-    public static final byte opc_i2d           = (byte) 0x87;\n-    public static final byte opc_l2i           = (byte) 0x88;\n-    public static final byte opc_l2f           = (byte) 0x89;\n-    public static final byte opc_l2d           = (byte) 0x8a;\n-    public static final byte opc_f2i           = (byte) 0x8b;\n-    public static final byte opc_f2l           = (byte) 0x8c;\n-    public static final byte opc_f2d           = (byte) 0x8d;\n-    public static final byte opc_d2i           = (byte) 0x8e;\n-    public static final byte opc_d2l           = (byte) 0x8f;\n-    public static final byte opc_d2f           = (byte) 0x90;\n-    public static final byte opc_i2b           = (byte) 0x91;\n-    public static final byte opc_i2c           = (byte) 0x92;\n-    public static final byte opc_i2s           = (byte) 0x93;\n-\n-    \/\/ Control flow\n-    public static final byte opc_ifeq          = (byte) 0x99;\n-    public static final byte opc_if_icmpeq     = (byte) 0x9f;\n-    public static final byte opc_goto          = (byte) 0xa7;\n-\n-    \/\/ Return instructions\n-    public static final byte opc_ireturn       = (byte) 0xac;\n-    public static final byte opc_lreturn       = (byte) 0xad;\n-    public static final byte opc_freturn       = (byte) 0xae;\n-    public static final byte opc_dreturn       = (byte) 0xaf;\n-    public static final byte opc_areturn       = (byte) 0xb0;\n-    public static final byte opc_return        = (byte) 0xb1;\n-\n-    \/\/ Field operations\n-    public static final byte opc_getstatic     = (byte) 0xb2;\n-    public static final byte opc_putstatic     = (byte) 0xb3;\n-    public static final byte opc_getfield      = (byte) 0xb4;\n-    public static final byte opc_putfield      = (byte) 0xb5;\n-\n-    \/\/ Method invocations\n-    public static final byte opc_invokevirtual   = (byte) 0xb6;\n-    public static final byte opc_invokespecial   = (byte) 0xb7;\n-    public static final byte opc_invokestatic    = (byte) 0xb8;\n-    public static final byte opc_invokeinterface = (byte) 0xb9;\n-\n-    \/\/ Array length\n-    public static final byte opc_arraylength     = (byte) 0xbe;\n-\n-    \/\/ New\n-    public static final byte opc_new           = (byte) 0xbb;\n-\n-    \/\/ Athrow\n-    public static final byte opc_athrow        = (byte) 0xbf;\n-\n-    \/\/ Checkcast and instanceof\n-    public static final byte opc_checkcast     = (byte) 0xc0;\n-    public static final byte opc_instanceof    = (byte) 0xc1;\n-\n-    \/\/ Ifnull and ifnonnull\n-    public static final byte opc_ifnull        = (byte) 0xc6;\n-    public static final byte opc_ifnonnull     = (byte) 0xc7;\n-\n-    \/\/ Constant pool tags\n-    public static final byte CONSTANT_Class              = (byte) 7;\n-    public static final byte CONSTANT_Fieldref           = (byte) 9;\n-    public static final byte CONSTANT_Methodref          = (byte) 10;\n-    public static final byte CONSTANT_InterfaceMethodref = (byte) 11;\n-    public static final byte CONSTANT_NameAndType        = (byte) 12;\n-    public static final byte CONSTANT_String             = (byte) 8;\n-    public static final byte CONSTANT_Utf8               = (byte) 1;\n-\n-    \/\/ Access flags\n-    public static final short ACC_PUBLIC = (short) 0x0001;\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassFileConstants.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -30,6 +30,1 @@\n-\/** Package-private implementation of the ConstructorAccessor\n-    interface which has access to all classes and all fields,\n-    regardless of language restrictions. See MagicAccessorImpl. *\/\n-\n-abstract class ConstructorAccessorImpl extends MagicAccessorImpl\n-    implements ConstructorAccessor {\n+abstract class ConstructorAccessorImpl implements ConstructorAccessor {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ConstructorAccessorImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,6 +31,1 @@\n-\/** Package-private implementation of the FieldAccessor interface\n-    which has access to all classes and all fields, regardless of\n-    language restrictions. See MagicAccessorImpl. *\/\n-\n-abstract class FieldAccessorImpl extends MagicAccessorImpl\n-    implements FieldAccessor {\n+abstract class FieldAccessorImpl implements FieldAccessor {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/FieldAccessorImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.util.List;\n-import java.util.ArrayList;\n-\n-\/** Allows forward references in bytecode streams emitted by\n-    ClassFileAssembler. Assumes that the start of the method body is\n-    the first byte in the assembler's buffer. May be used at more than\n-    one branch site. *\/\n-\n-class Label {\n-    static class PatchInfo {\n-        PatchInfo(ClassFileAssembler asm,\n-                  short instrBCI,\n-                  short patchBCI,\n-                  int stackDepth)\n-        {\n-            this.asm = asm;\n-            this.instrBCI   = instrBCI;\n-            this.patchBCI   = patchBCI;\n-            this.stackDepth = stackDepth;\n-        }\n-        \/\/ This won't work for more than one assembler anyway, so this is\n-        \/\/ unnecessary\n-        final ClassFileAssembler asm;\n-        final short instrBCI;\n-        final short patchBCI;\n-        final int   stackDepth;\n-    }\n-    private final List<PatchInfo> patches = new ArrayList<>();\n-\n-    public Label() {\n-    }\n-\n-    void add(ClassFileAssembler asm,\n-             short instrBCI,\n-             short patchBCI,\n-             int stackDepth)\n-    {\n-        patches.add(new PatchInfo(asm, instrBCI, patchBCI, stackDepth));\n-    }\n-\n-    public void bind() {\n-        for (PatchInfo patch : patches){\n-            short curBCI = patch.asm.getLength();\n-            short offset = (short) (curBCI - patch.instrBCI);\n-            patch.asm.emitShort(patch.patchBCI, offset);\n-            patch.asm.setStack(patch.stackDepth);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Label.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** <P> MagicAccessorImpl (named for parity with FieldAccessorImpl and\n-    others, not because it actually implements an interface) is a\n-    marker class in the hierarchy. All subclasses of this class are\n-    \"magically\" granted access by the VM to otherwise inaccessible\n-    fields and methods of other classes. It is used to hold the code\n-    for dynamically-generated FieldAccessorImpl and MethodAccessorImpl\n-    subclasses. (Use of the word \"unsafe\" was avoided in this class's\n-    name to avoid confusion with {@link jdk.internal.misc.Unsafe}.) <\/P>\n-\n-    <P> The bug fix for 4486457 also necessitated disabling\n-    verification for this class and all subclasses, as opposed to just\n-    SerializationConstructorAccessorImpl and subclasses, to avoid\n-    having to indicate to the VM which of these dynamically-generated\n-    stub classes were known to be able to pass the verifier. <\/P>\n-\n-    <P> Do not change the name of this class without also changing the\n-    VM's code. <\/P> *\/\n-\n-class MagicAccessorImpl {\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MagicAccessorImpl.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -30,5 +30,1 @@\n-\/** <P> Package-private implementation of the MethodAccessor interface\n-    which has access to all classes and all fields, regardless of\n-    language restrictions. See MagicAccessor. <\/P>\n-\n-    <P> This class is known to the VM; do not change its name without\n+\/** <P> This class is known to the VM; do not change its name without\n@@ -43,2 +39,1 @@\n-abstract class MethodAccessorImpl extends MagicAccessorImpl\n-    implements MethodAccessor {\n+abstract class MethodAccessorImpl implements MethodAccessor {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessorImpl.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"}]}