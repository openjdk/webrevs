{"files":[{"patch":"@@ -4079,20 +4079,0 @@\n-    \/\/ If the loader is not the boot loader then throw an exception if its\n-    \/\/ superclass is in package jdk.internal.reflect and its loader is not a\n-    \/\/ special reflection class loader\n-    if (!this_klass->class_loader_data()->is_the_null_class_loader_data()) {\n-      PackageEntry* super_package = super->package();\n-      if (super_package != nullptr &&\n-          super_package->name()->fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &&\n-          !java_lang_ClassLoader::is_reflection_class_loader(this_klass->class_loader())) {\n-        ResourceMark rm(THREAD);\n-        Exceptions::fthrow(\n-          THREAD_AND_LOCATION,\n-          vmSymbols::java_lang_IllegalAccessError(),\n-          \"class %s loaded by %s cannot access jdk\/internal\/reflect superclass %s\",\n-          this_klass->external_name(),\n-          this_klass->class_loader_data()->loader_name_and_id(),\n-          super->external_name());\n-        return;\n-      }\n-    }\n-\n@@ -5109,1 +5089,1 @@\n-  Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));\n+  Handle clh = Handle(THREAD, cl);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -647,2 +647,0 @@\n-  } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n-    size = 1;  \/\/ there's only one class in relection class loader and no initiated classes\n@@ -818,2 +816,0 @@\n-      } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n-        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4766,3 +4766,0 @@\n-  \/\/ Fix for 4474172; see evaluation for more details\n-  loader = non_reflection_class_loader(loader);\n-\n@@ -4777,23 +4774,0 @@\n-\/\/ Return true if this is one of the class loaders associated with\n-\/\/ the generated bytecodes for serialization constructor returned\n-\/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n-bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {\n-  if (loader != nullptr) {\n-    Klass* delegating_cl_class = vmClasses::reflect_DelegatingClassLoader_klass();\n-    \/\/ This might be null in non-1.4 JDKs\n-    return (delegating_cl_class != nullptr && loader->is_a(delegating_cl_class));\n-  }\n-  return false;\n-}\n-\n-oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {\n-  \/\/ See whether this is one of the class loaders associated with\n-  \/\/ the generated bytecodes for reflection, and if so, \"magically\"\n-  \/\/ delegate to its parent to prevent class loading from occurring\n-  \/\/ in places where applications using reflection didn't expect it.\n-  if (is_reflection_class_loader(loader)) {\n-    return parent(loader);\n-  }\n-  return loader;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1505,8 +1505,0 @@\n-  \/\/ Return true if this is one of the class loaders associated with\n-  \/\/ the generated bytecodes for serialization constructor returned\n-  \/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n-  static bool is_reflection_class_loader(oop loader);\n-\n-  \/\/ Fix for 4474172\n-  static oop  non_reflection_class_loader(oop loader);\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -312,5 +312,0 @@\n-  \/\/ Make sure loader is not the jdk.internal.reflect.DelegatingClassLoader.\n-  if (loader != java_lang_ClassLoader::non_reflection_class_loader(loader)) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Class loader is an invalid delegating class loader\");\n-  }\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -601,2 +601,0 @@\n-  \/\/ Fix for 4474172; see evaluation for more details\n-  class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n@@ -768,6 +766,1 @@\n-  \/\/ The result of this call should be consistent with the result\n-  \/\/ of the call to resolve_instance_class_or_null().\n-  \/\/ See evaluation 6790209 and 4474172 for more details.\n-  oop class_loader_oop = java_lang_ClassLoader::non_reflection_class_loader(class_loader());\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader_oop);\n-\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -406,3 +406,0 @@\n-      \/\/ Fix for 4474172; see evaluation for more details\n-      class_loader = Handle(\n-        THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -278,4 +278,0 @@\n-  Klass* refl_serialization_ctor_klass = vmClasses::reflect_SerializationConstructorAccessorImpl_klass();\n-\n-  bool is_reflect_accessor = refl_serialization_ctor_klass != nullptr &&\n-                                klass->is_subtype_of(refl_serialization_ctor_klass);\n@@ -298,6 +294,1 @@\n-    !(klass->is_shared() && klass->is_rewritten()) &&\n-\n-    \/\/ As of the fix for 4486457 we disable verification for all of the\n-    \/\/ dynamically-generated bytecodes associated with\n-    \/\/ jdk\/internal\/reflect\/SerializationConstructorAccessor.\n-    (!is_reflect_accessor));\n+    !(klass->is_shared() && klass->is_rewritten()));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-  do_klass(reflect_DelegatingClassLoader_klass,         reflect_DelegatingClassLoader                         ) \\\n@@ -114,1 +113,0 @@\n-  do_klass(reflect_SerializationConstructorAccessorImpl_klass,           reflect_SerializationConstructorAccessorImpl ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,0 @@\n-  template(reflect_DelegatingClassLoader,             \"jdk\/internal\/reflect\/DelegatingClassLoader\")   \\\n@@ -270,1 +269,0 @@\n-  template(reflect_SerializationConstructorAccessorImpl,             \"jdk\/internal\/reflect\/SerializationConstructorAccessorImpl\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1203,7 +1203,1 @@\n-    \/\/ Disable verification for the dynamically-generated reflection bytecodes\n-    \/\/ for serialization constructor accessor.\n-    bool is_reflect = klass_to_check->is_subclass_of(\n-                        vmClasses::reflect_SerializationConstructorAccessorImpl_klass());\n-\n-    if (!is_reflect &&\n-        !klass_to_check->is_same_or_direct_interface(resolved_klass)) {\n+    if (!klass_to_check->is_same_or_direct_interface(resolved_klass)) {\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3281,4 +3281,1 @@\n-      \/\/ Skip reflection related frames\n-      if (!ik->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-        return JNIHandles::make_local(THREAD, loader);\n-      }\n+      return JNIHandles::make_local(THREAD, loader);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -451,6 +451,0 @@\n-  \/\/ Allow all accesses from jdk\/internal\/reflect\/SerializationConstructorAccessorImpl subclasses to\n-  \/\/ succeed trivially.\n-  if (vmClasses::reflect_SerializationConstructorAccessorImpl_klass_is_loaded() &&\n-      current_class->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-    return ACCESS_OK;\n-  }\n@@ -661,6 +655,0 @@\n-  \/\/ Allow all accesses from jdk\/internal\/reflect\/SerializationConstructorAccessorImpl subclasses to\n-  \/\/ succeed trivially.\n-  if (current_class->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/** Utility class which assists in calling defineClass() by\n- *  creating a new class loader which delegates to the one needed in\n- *  order for proper resolution of the given bytecodes to occur.\n- *\n- *  This is only used to define SerializationConstructorAccessor.\n- *\/\n-\n-class ClassDefiner {\n-    static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    \/** <P> We define generated code into a new class loader which\n-      delegates to the defining loader of the target class. It is\n-      necessary for the VM to be able to resolve references to the\n-      target class from the generated bytecodes, which could not occur\n-      if the generated code was loaded into the bootstrap class\n-      loader. <\/P>\n-\n-      <P> There are two primary reasons for creating a new loader\n-      instead of defining these bytecodes directly into the defining\n-      loader of the target class: first, it avoids any possible\n-      security risk of having these bytecodes in the same loader.\n-      Second, it allows the generated bytecodes to be unloaded earlier\n-      than would otherwise be possible, decreasing run-time\n-      footprint. <\/P>\n-    *\/\n-    static Class<?> defineClass(String name, byte[] bytes, int off, int len,\n-                                final ClassLoader parentClassLoader)\n-    {\n-        @SuppressWarnings(\"removal\")\n-        ClassLoader newLoader = AccessController.doPrivileged(\n-            new PrivilegedAction<ClassLoader>() {\n-                public ClassLoader run() {\n-                        return new DelegatingClassLoader(parentClassLoader);\n-                    }\n-                });\n-        return JLA.defineClass(newLoader, name, bytes, null, \"__ClassDefiner__\");\n-    }\n-}\n-\n-\n-\/\/ NOTE: this class's name and presence are known to the virtual\n-\/\/ machine as of the fix for 4474172.\n-class DelegatingClassLoader extends ClassLoader {\n-    DelegatingClassLoader(ClassLoader parent) {\n-        super(parent);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassDefiner.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -337,10 +337,2 @@\n-        ConstructorAccessor acc;\n-        if (useOldSerializableConstructor()) {\n-            acc = new SerializationConstructorAccessorGenerator().\n-                                generateSerializationConstructor(cl,\n-                                                                 constructorToCall.getParameterTypes(),\n-                                                                 constructorToCall.getModifiers(),\n-                                                                 constructorToCall.getDeclaringClass());\n-        } else {\n-            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, constructorToCall);\n-        }\n+        ConstructorAccessor acc = MethodHandleAccessorFactory\n+                .newSerializableConstructorAccessor(cl, constructorToCall);\n@@ -510,4 +502,0 @@\n-    static boolean useOldSerializableConstructor() {\n-        return config().useOldSerializableConstructor;\n-    }\n-\n@@ -530,1 +518,0 @@\n-                                                            false,  \/\/ useOldSerializeableConstructor\n@@ -545,1 +532,0 @@\n-                          boolean useOldSerializableConstructor,\n@@ -569,2 +555,0 @@\n-        boolean useOldSerializableConstructor =\n-            \"true\".equals(props.getProperty(\"jdk.reflect.useOldSerializableConstructor\"));\n@@ -574,1 +558,1 @@\n-        return new Config(useNativeAccessorOnly, useOldSerializableConstructor, disableSerialConstructorChecks);\n+        return new Config(useNativeAccessorOnly, disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,725 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n-\n-\/** Generator for jdk.internal.reflect.SerializationConstructorAccessorImpl\n-    objects using bytecodes to implement a constructor for serialization\n-    returned by ReflectionFactory::newConstructorForSerialization. *\/\n-\n-class SerializationConstructorAccessorGenerator extends AccessorGenerator {\n-\n-    private static final short NUM_BASE_CPOOL_ENTRIES   = (short) 12;\n-    \/\/ One for invoke() plus one for constructor\n-    private static final short NUM_METHODS              = (short) 2;\n-    \/\/ Only used if forSerialization is true\n-    private static final short NUM_SERIALIZATION_CPOOL_ENTRIES = (short) 2;\n-\n-    private static volatile int methodSymnum;\n-    private static volatile int constructorSymnum;\n-    private static volatile int serializationConstructorSymnum;\n-\n-    private Class<?>   declaringClass;\n-    private Class<?>[] parameterTypes;\n-    private Class<?>   returnType;\n-    private boolean    isConstructor;\n-    private boolean    forSerialization;\n-\n-    private short targetMethodRef;\n-    private short invokeIdx;\n-    private short invokeDescriptorIdx;\n-    \/\/ Constant pool index of CONSTANT_Class_info for first\n-    \/\/ non-primitive parameter type. Should be incremented by 2.\n-    private short nonPrimitiveParametersBaseIdx;\n-\n-    SerializationConstructorAccessorGenerator() {\n-    }\n-\n-    \/** This routine is not thread-safe *\/\n-    public SerializationConstructorAccessorImpl\n-    generateSerializationConstructor(Class<?> declaringClass,\n-                                     Class<?>[] parameterTypes,\n-                                     int modifiers,\n-                                     Class<?> targetConstructorClass)\n-    {\n-        return (SerializationConstructorAccessorImpl)\n-            generate(declaringClass,\n-                     \"<init>\",\n-                     parameterTypes,\n-                     Void.TYPE,\n-                     modifiers,\n-                     true,\n-                     true,\n-                     targetConstructorClass);\n-    }\n-\n-    \/** This routine is not thread-safe *\/\n-    @SuppressWarnings(\"removal\")\n-    private MagicAccessorImpl generate(final Class<?> declaringClass,\n-                                       String name,\n-                                       Class<?>[] parameterTypes,\n-                                       Class<?>   returnType,\n-                                       int modifiers,\n-                                       boolean isConstructor,\n-                                       boolean forSerialization,\n-                                       Class<?> serializationTargetClass)\n-    {\n-        ByteVector vec = ByteVectorFactory.create();\n-        asm = new ClassFileAssembler(vec);\n-        this.declaringClass = declaringClass;\n-        this.parameterTypes = parameterTypes;\n-        this.returnType = returnType;\n-        this.modifiers = modifiers;\n-        this.isConstructor = isConstructor;\n-        this.forSerialization = forSerialization;\n-\n-        asm.emitMagicAndVersion();\n-\n-        \/\/ Constant pool entries:\n-        \/\/ ( * = Boxing information: optional)\n-        \/\/ (+  = Shared entries provided by AccessorGenerator)\n-        \/\/ (^  = Only present if generating SerializationConstructorAccessor)\n-        \/\/     [UTF-8] [This class's name]\n-        \/\/     [CONSTANT_Class_info] for above\n-        \/\/     [UTF-8] \"jdk\/internal\/reflect\/{MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl}\"\n-        \/\/     [CONSTANT_Class_info] for above\n-        \/\/     [UTF-8] [Target class's name]\n-        \/\/     [CONSTANT_Class_info] for above\n-        \/\/ ^   [UTF-8] [Serialization: Class's name in which to invoke constructor]\n-        \/\/ ^   [CONSTANT_Class_info] for above\n-        \/\/     [UTF-8] target method or constructor name\n-        \/\/     [UTF-8] target method or constructor signature\n-        \/\/     [CONSTANT_NameAndType_info] for above\n-        \/\/     [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method\n-        \/\/     [UTF-8] \"invoke\" or \"newInstance\"\n-        \/\/     [UTF-8] invoke or newInstance descriptor\n-        \/\/     [UTF-8] descriptor for type of non-primitive parameter 1\n-        \/\/     [CONSTANT_Class_info] for type of non-primitive parameter 1\n-        \/\/     ...\n-        \/\/     [UTF-8] descriptor for type of non-primitive parameter n\n-        \/\/     [CONSTANT_Class_info] for type of non-primitive parameter n\n-        \/\/ +   [UTF-8] \"java\/lang\/Exception\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/ClassCastException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/NullPointerException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/IllegalArgumentException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/InvocationTargetException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"<init>\"\n-        \/\/ +   [UTF-8] \"()V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for above\n-        \/\/ +   [CONSTANT_Methodref_info] for NullPointerException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for InvocationTargetException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for \"super()\"\n-        \/\/ +   [UTF-8] \"java\/lang\/Object\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"toString\"\n-        \/\/ +   [UTF-8] \"()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"toString()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_Methodref_info] for Object's toString method\n-        \/\/ +   [UTF-8] \"Code\"\n-        \/\/ +   [UTF-8] \"Exceptions\"\n-        \/\/  *  [UTF-8] \"java\/lang\/Boolean\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(Z)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"booleanValue\"\n-        \/\/  *  [UTF-8] \"()Z\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Byte\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(B)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"byteValue\"\n-        \/\/  *  [UTF-8] \"()B\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Character\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(C)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"charValue\"\n-        \/\/  *  [UTF-8] \"()C\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Double\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(D)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"doubleValue\"\n-        \/\/  *  [UTF-8] \"()D\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Float\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(F)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"floatValue\"\n-        \/\/  *  [UTF-8] \"()F\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Integer\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(I)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"intValue\"\n-        \/\/  *  [UTF-8] \"()I\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Long\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(J)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"longValue\"\n-        \/\/  *  [UTF-8] \"()J\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Short\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(S)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"shortValue\"\n-        \/\/  *  [UTF-8] \"()S\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-\n-        short numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;\n-        boolean usesPrimitives = usesPrimitiveTypes();\n-        if (usesPrimitives) {\n-            numCPEntries += NUM_BOXING_CPOOL_ENTRIES;\n-        }\n-        if (forSerialization) {\n-            numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES;\n-        }\n-\n-        \/\/ Add in variable-length number of entries to be able to describe\n-        \/\/ non-primitive parameter types and checked exceptions.\n-        numCPEntries += (short) (2 * numNonPrimitiveParameterTypes());\n-\n-        asm.emitShort(add(numCPEntries, S1));\n-\n-        final String generatedName = generateName(isConstructor, forSerialization);\n-        asm.emitConstantPoolUTF8(generatedName);\n-        asm.emitConstantPoolClass(asm.cpi());\n-        thisClass = asm.cpi();\n-        if (isConstructor) {\n-            if (forSerialization) {\n-                asm.emitConstantPoolUTF8\n-                    (\"jdk\/internal\/reflect\/SerializationConstructorAccessorImpl\");\n-            } else {\n-                asm.emitConstantPoolUTF8(\"jdk\/internal\/reflect\/ConstructorAccessorImpl\");\n-            }\n-        } else {\n-            asm.emitConstantPoolUTF8(\"jdk\/internal\/reflect\/MethodAccessorImpl\");\n-        }\n-        asm.emitConstantPoolClass(asm.cpi());\n-        superClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(getClassName(declaringClass, false));\n-        asm.emitConstantPoolClass(asm.cpi());\n-        targetClass = asm.cpi();\n-        short serializationTargetClassIdx = (short) 0;\n-        if (forSerialization) {\n-            asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, false));\n-            asm.emitConstantPoolClass(asm.cpi());\n-            serializationTargetClassIdx = asm.cpi();\n-        }\n-        asm.emitConstantPoolUTF8(name);\n-        asm.emitConstantPoolUTF8(buildInternalSignature());\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        if (isInterface()) {\n-            asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi());\n-        } else {\n-            if (forSerialization) {\n-                asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi());\n-            } else {\n-                asm.emitConstantPoolMethodref(targetClass, asm.cpi());\n-            }\n-        }\n-        targetMethodRef = asm.cpi();\n-        if (isConstructor) {\n-            asm.emitConstantPoolUTF8(\"newInstance\");\n-        } else {\n-            asm.emitConstantPoolUTF8(\"invoke\");\n-        }\n-        invokeIdx = asm.cpi();\n-        if (isConstructor) {\n-            asm.emitConstantPoolUTF8(\"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n-        } else {\n-            asm.emitConstantPoolUTF8\n-                (\"(Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n-        }\n-        invokeDescriptorIdx = asm.cpi();\n-\n-        \/\/ Output class information for non-primitive parameter types\n-        nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2);\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            Class<?> c = parameterTypes[i];\n-            if (!isPrimitive(c)) {\n-                asm.emitConstantPoolUTF8(getClassName(c, false));\n-                asm.emitConstantPoolClass(asm.cpi());\n-            }\n-        }\n-\n-        \/\/ Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor\n-        emitCommonConstantPoolEntries();\n-\n-        \/\/ Boxing entries\n-        if (usesPrimitives) {\n-            emitBoxingContantPoolEntries();\n-        }\n-\n-        if (asm.cpi() != numCPEntries) {\n-            throw new InternalError(\"Adjust this code (cpi = \" + asm.cpi() +\n-                                    \", numCPEntries = \" + numCPEntries + \")\");\n-        }\n-\n-        \/\/ Access flags\n-        asm.emitShort(ACC_PUBLIC);\n-\n-        \/\/ This class\n-        asm.emitShort(thisClass);\n-\n-        \/\/ Superclass\n-        asm.emitShort(superClass);\n-\n-        \/\/ Interfaces count and interfaces\n-        asm.emitShort(S0);\n-\n-        \/\/ Fields count and fields\n-        asm.emitShort(S0);\n-\n-        \/\/ Methods count and methods\n-        asm.emitShort(NUM_METHODS);\n-\n-        emitConstructor();\n-        emitInvoke();\n-\n-        \/\/ Additional attributes (none)\n-        asm.emitShort(S0);\n-\n-        \/\/ Load class\n-        vec.trim();\n-        final byte[] bytes = vec.getData();\n-        \/\/ Note: the class loader is the only thing that really matters\n-        \/\/ here -- it's important to get the generated code into the\n-        \/\/ same namespace as the target class. Since the generated code\n-        \/\/ is privileged anyway, the protection domain probably doesn't\n-        \/\/ matter.\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<MagicAccessorImpl>() {\n-                @SuppressWarnings(\"deprecation\") \/\/ Class.newInstance\n-                public MagicAccessorImpl run() {\n-                        try {\n-                        return (MagicAccessorImpl)\n-                        ClassDefiner.defineClass\n-                                (generatedName,\n-                                 bytes,\n-                                 0,\n-                                 bytes.length,\n-                                 declaringClass.getClassLoader()).newInstance();\n-                        } catch (InstantiationException | IllegalAccessException e) {\n-                            throw new InternalError(e);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    \/** This emits the code for either invoke() or newInstance() *\/\n-    private void emitInvoke() {\n-        \/\/ NOTE that this code will only handle 65535 parameters since we\n-        \/\/ use the sipush instruction to get the array index on the\n-        \/\/ operand stack.\n-        if (parameterTypes.length > 65535) {\n-            throw new InternalError(\"Can't handle more than 65535 parameters\");\n-        }\n-\n-        \/\/ Generate code into fresh code buffer\n-        ClassFileAssembler cb = new ClassFileAssembler();\n-        if (isConstructor) {\n-            \/\/ 1 incoming argument\n-            cb.setMaxLocals(2);\n-        } else {\n-            \/\/ 2 incoming arguments\n-            cb.setMaxLocals(3);\n-        }\n-\n-        short illegalArgStartPC = 0;\n-\n-        if (isConstructor) {\n-            \/\/ Instantiate target class before continuing\n-            \/\/ new <target class type>\n-            \/\/ dup\n-            cb.opc_new(targetClass);\n-            cb.opc_dup();\n-        } else {\n-            \/\/ Get target object on operand stack if necessary.\n-\n-            \/\/ We need to do an explicit null check here; we won't see\n-            \/\/ NullPointerExceptions from the invoke bytecode, since it's\n-            \/\/ covered by an exception handler.\n-            if (!isStatic()) {\n-                \/\/ aload_1\n-                \/\/ ifnonnull <checkcast label>\n-                \/\/ new <NullPointerException>\n-                \/\/ dup\n-                \/\/ invokespecial <NullPointerException ctor>\n-                \/\/ athrow\n-                \/\/ <checkcast label:>\n-                \/\/ aload_1\n-                \/\/ checkcast <target class's type>\n-                cb.opc_aload_1();\n-                Label l = new Label();\n-                cb.opc_ifnonnull(l);\n-                cb.opc_new(nullPointerClass);\n-                cb.opc_dup();\n-                cb.opc_invokespecial(nullPointerCtorIdx, 0, 0);\n-                cb.opc_athrow();\n-                l.bind();\n-                illegalArgStartPC = cb.getLength();\n-                cb.opc_aload_1();\n-                cb.opc_checkcast(targetClass);\n-            }\n-        }\n-\n-        \/\/ Have to check length of incoming array and throw\n-        \/\/ IllegalArgumentException if not correct. A concession to the\n-        \/\/ JCK (isn't clearly specified in the spec): we allow null in the\n-        \/\/ case where the argument list is zero length.\n-        \/\/ if no-arg:\n-        \/\/   aload_2 | aload_1 (Method | Constructor)\n-        \/\/   ifnull <success label>\n-        \/\/ aload_2 | aload_1\n-        \/\/ arraylength\n-        \/\/ sipush <num parameter types>\n-        \/\/ if_icmpeq <success label>\n-        \/\/ new <IllegalArgumentException>\n-        \/\/ dup\n-        \/\/ invokespecial <IllegalArgumentException ctor>\n-        \/\/ athrow\n-        \/\/ <success label:>\n-        Label successLabel = new Label();\n-        if (parameterTypes.length == 0) {\n-            if (isConstructor) {\n-                cb.opc_aload_1();\n-            } else {\n-                cb.opc_aload_2();\n-            }\n-            cb.opc_ifnull(successLabel);\n-        }\n-        if (isConstructor) {\n-            cb.opc_aload_1();\n-        } else {\n-            cb.opc_aload_2();\n-        }\n-        cb.opc_arraylength();\n-        cb.opc_sipush((short) parameterTypes.length);\n-        cb.opc_if_icmpeq(successLabel);\n-        cb.opc_new(illegalArgumentClass);\n-        cb.opc_dup();\n-        cb.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);\n-        cb.opc_athrow();\n-        successLabel.bind();\n-\n-        \/\/ Iterate through incoming actual parameters, ensuring that each\n-        \/\/ is compatible with the formal parameter type, and pushing the\n-        \/\/ actual on the operand stack (unboxing and widening if necessary).\n-\n-        short paramTypeCPIdx = nonPrimitiveParametersBaseIdx;\n-        Label nextParamLabel = null;\n-        byte count = 1; \/\/ both invokeinterface opcode's \"count\" as well as\n-        \/\/ num args of other invoke bytecodes\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            Class<?> paramType = parameterTypes[i];\n-            count += (byte) typeSizeInStackSlots(paramType);\n-            if (nextParamLabel != null) {\n-                nextParamLabel.bind();\n-                nextParamLabel = null;\n-            }\n-            \/\/ aload_2 | aload_1\n-            \/\/ sipush <index>\n-            \/\/ aaload\n-            if (isConstructor) {\n-                cb.opc_aload_1();\n-            } else {\n-                cb.opc_aload_2();\n-            }\n-            cb.opc_sipush((short) i);\n-            cb.opc_aaload();\n-            if (isPrimitive(paramType)) {\n-                \/\/ Unboxing code.\n-                \/\/ Put parameter into temporary local variable\n-                \/\/ astore_3 | astore_2\n-                if (isConstructor) {\n-                    cb.opc_astore_2();\n-                } else {\n-                    cb.opc_astore_3();\n-                }\n-\n-                \/\/ repeat for all possible widening conversions:\n-                \/\/   aload_3 | aload_2\n-                \/\/   instanceof <primitive boxing type>\n-                \/\/   ifeq <next unboxing label>\n-                \/\/   aload_3 | aload_2\n-                \/\/   checkcast <primitive boxing type> \/\/ Note: this is \"redundant\",\n-                \/\/                                     \/\/ but necessary for the verifier\n-                \/\/   invokevirtual <unboxing method>\n-                \/\/   <widening conversion bytecode, if necessary>\n-                \/\/   goto <next parameter label>\n-                \/\/ <next unboxing label:> ...\n-                \/\/ last unboxing label:\n-                \/\/   new <IllegalArgumentException>\n-                \/\/   dup\n-                \/\/   invokespecial <IllegalArgumentException ctor>\n-                \/\/   athrow\n-\n-                Label l = null; \/\/ unboxing label\n-                nextParamLabel = new Label();\n-\n-                for (int j = 0; j < primitiveTypes.length; j++) {\n-                    Class<?> c = primitiveTypes[j];\n-                    if (canWidenTo(c, paramType)) {\n-                        if (l != null) {\n-                            l.bind();\n-                        }\n-                        \/\/ Emit checking and unboxing code for this type\n-                        if (isConstructor) {\n-                            cb.opc_aload_2();\n-                        } else {\n-                            cb.opc_aload_3();\n-                        }\n-                        cb.opc_instanceof(indexForPrimitiveType(c));\n-                        l = new Label();\n-                        cb.opc_ifeq(l);\n-                        if (isConstructor) {\n-                            cb.opc_aload_2();\n-                        } else {\n-                            cb.opc_aload_3();\n-                        }\n-                        cb.opc_checkcast(indexForPrimitiveType(c));\n-                        cb.opc_invokevirtual(unboxingMethodForPrimitiveType(c),\n-                                             0,\n-                                             typeSizeInStackSlots(c));\n-                        emitWideningBytecodeForPrimitiveConversion(cb,\n-                                                                   c,\n-                                                                   paramType);\n-                        cb.opc_goto(nextParamLabel);\n-                    }\n-                }\n-\n-                if (l == null) {\n-                    throw new InternalError\n-                        (\"Must have found at least identity conversion\");\n-                }\n-\n-                \/\/ Fell through; given object is null or invalid. According to\n-                \/\/ the spec, we can throw IllegalArgumentException for both of\n-                \/\/ these cases.\n-\n-                l.bind();\n-                cb.opc_new(illegalArgumentClass);\n-                cb.opc_dup();\n-                cb.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);\n-                cb.opc_athrow();\n-            } else {\n-                \/\/ Emit appropriate checkcast\n-                cb.opc_checkcast(paramTypeCPIdx);\n-                paramTypeCPIdx = add(paramTypeCPIdx, S2);\n-                \/\/ Fall through to next argument\n-            }\n-        }\n-        \/\/ Bind last goto if present\n-        if (nextParamLabel != null) {\n-            nextParamLabel.bind();\n-        }\n-\n-        short invokeStartPC = cb.getLength();\n-\n-        \/\/ OK, ready to perform the invocation.\n-        if (isConstructor) {\n-            cb.opc_invokespecial(targetMethodRef, count, 0);\n-        } else {\n-            if (isStatic()) {\n-                cb.opc_invokestatic(targetMethodRef,\n-                                    count,\n-                                    typeSizeInStackSlots(returnType));\n-            } else {\n-                if (isInterface()) {\n-                    cb.opc_invokeinterface(targetMethodRef,\n-                                           count,\n-                                           count,\n-                                           typeSizeInStackSlots(returnType));\n-                } else {\n-                    cb.opc_invokevirtual(targetMethodRef,\n-                                         count,\n-                                         typeSizeInStackSlots(returnType));\n-                }\n-            }\n-        }\n-\n-        short invokeEndPC = cb.getLength();\n-\n-        if (!isConstructor) {\n-            \/\/ Box return value if necessary\n-            if (isPrimitive(returnType)) {\n-                cb.opc_invokestatic(boxingMethodForPrimitiveType(returnType),\n-                                    typeSizeInStackSlots(returnType),\n-                                    0);\n-            } else if (returnType == Void.TYPE) {\n-                cb.opc_aconst_null();\n-            }\n-        }\n-        cb.opc_areturn();\n-\n-        \/\/ We generate two exception handlers; one which is responsible\n-        \/\/ for catching ClassCastException and NullPointerException and\n-        \/\/ throwing IllegalArgumentException, and the other which catches\n-        \/\/ all java\/lang\/Throwable objects thrown from the target method\n-        \/\/ and wraps them in InvocationTargetExceptions.\n-\n-        short classCastHandler = cb.getLength();\n-\n-        \/\/ ClassCast, etc. exception handler\n-        cb.setStack(1);\n-        cb.opc_invokespecial(toStringIdx, 0, 1);\n-        cb.opc_new(illegalArgumentClass);\n-        cb.opc_dup_x1();\n-        cb.opc_swap();\n-        cb.opc_invokespecial(illegalArgumentStringCtorIdx, 1, 0);\n-        cb.opc_athrow();\n-\n-        short invocationTargetHandler = cb.getLength();\n-\n-        \/\/ InvocationTargetException exception handler\n-        cb.setStack(1);\n-        cb.opc_new(invocationTargetClass);\n-        cb.opc_dup_x1();\n-        cb.opc_swap();\n-        cb.opc_invokespecial(invocationTargetCtorIdx, 1, 0);\n-        cb.opc_athrow();\n-\n-        \/\/ Generate exception table. We cover the entire code sequence\n-        \/\/ with an exception handler which catches ClassCastException and\n-        \/\/ converts it into an IllegalArgumentException.\n-\n-        ClassFileAssembler exc = new ClassFileAssembler();\n-\n-        exc.emitShort(illegalArgStartPC);       \/\/ start PC\n-        exc.emitShort(invokeStartPC);           \/\/ end PC\n-        exc.emitShort(classCastHandler);        \/\/ handler PC\n-        exc.emitShort(classCastClass);          \/\/ catch type\n-\n-        exc.emitShort(illegalArgStartPC);       \/\/ start PC\n-        exc.emitShort(invokeStartPC);           \/\/ end PC\n-        exc.emitShort(classCastHandler);        \/\/ handler PC\n-        exc.emitShort(nullPointerClass);        \/\/ catch type\n-\n-        exc.emitShort(invokeStartPC);           \/\/ start PC\n-        exc.emitShort(invokeEndPC);             \/\/ end PC\n-        exc.emitShort(invocationTargetHandler); \/\/ handler PC\n-        exc.emitShort(throwableClass);          \/\/ catch type\n-\n-        emitMethod(invokeIdx, cb.getMaxLocals(), cb, exc,\n-                   new short[] { invocationTargetClass });\n-    }\n-\n-    private boolean usesPrimitiveTypes() {\n-        \/\/ We need to emit boxing\/unboxing constant pool information if\n-        \/\/ the method takes a primitive type for any of its parameters or\n-        \/\/ returns a primitive value (except void)\n-        if (returnType.isPrimitive()) {\n-            return true;\n-        }\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            if (parameterTypes[i].isPrimitive()) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private int numNonPrimitiveParameterTypes() {\n-        int num = 0;\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            if (!parameterTypes[i].isPrimitive()) {\n-                ++num;\n-            }\n-        }\n-        return num;\n-    }\n-\n-    private boolean isInterface() {\n-        return declaringClass.isInterface();\n-    }\n-\n-    private String buildInternalSignature() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"(\");\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            sb.append(getClassName(parameterTypes[i], true));\n-        }\n-        sb.append(\")\");\n-        sb.append(getClassName(returnType, true));\n-        return sb.toString();\n-    }\n-\n-    private static synchronized String generateName(boolean isConstructor,\n-                                                    boolean forSerialization)\n-    {\n-        if (isConstructor) {\n-            if (forSerialization) {\n-                int num = ++serializationConstructorSymnum;\n-                return \"jdk\/internal\/reflect\/GeneratedSerializationConstructorAccessor\" + num;\n-            } else {\n-                int num = ++constructorSymnum;\n-                return \"jdk\/internal\/reflect\/GeneratedConstructorAccessor\" + num;\n-            }\n-        } else {\n-            int num = ++methodSymnum;\n-            return \"jdk\/internal\/reflect\/GeneratedMethodAccessor\" + num;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationConstructorAccessorGenerator.java","additions":0,"deletions":725,"binary":false,"changes":725,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** <P> Java serialization (in java.io) expects to be able to\n-    instantiate a class and invoke a no-arg constructor of that\n-    class's first non-Serializable superclass. This is not a valid\n-    operation according to the VM specification; one can not (for\n-    classes A and B, where B is a subclass of A) write \"new B;\n-    invokespecial A()\" without getting a verification error. <\/P>\n-\n-    <P> In all other respects, the bytecode-based reflection framework\n-    can be reused for this purpose. This marker class was originally\n-    known to the VM and verification disabled for it and all\n-    subclasses, but the bug fix for 4486457 necessitated disabling\n-    verification for all of the dynamically-generated bytecodes\n-    associated with reflection. This class has been left in place to\n-    make future debugging easier. <\/P> *\/\n-\n-abstract class SerializationConstructorAccessorImpl\n-    extends ConstructorAccessorImpl {\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationConstructorAccessorImpl.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"}]}