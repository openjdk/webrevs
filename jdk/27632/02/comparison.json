{"files":[{"patch":"@@ -144,1 +144,1 @@\n-    size_t live_data_for_evacuation = r->get_live_data_bytes();\n+    const size_t live_data_for_evacuation = r->get_live_data_bytes();\n@@ -172,1 +172,3 @@\n-        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        \/\/ There is no room to evacuate this region or any that come after it in within the candidates array.\n+        log_debug(gc, cset)(\"Not enough unfragmented memory (%zu) to hold evacuees (%zu) from region: (%zu)\",\n+                            unfragmented_available, live_data_for_evacuation, r->index());\n@@ -190,1 +192,3 @@\n-        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        \/\/ There is no room to evacuate this region or any that come after it in within the candidates array.\n+        log_debug(gc, cset)(\"Not enough unfragmented memory (%zu) to hold evacuees (%zu) from region: (%zu)\",\n+                            unfragmented_available, live_data_for_evacuation, r->index());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -184,0 +184,13 @@\n+size_t ShenandoahAgeCensus::get_tenurable_bytes(const uint tenuring_threshold) const {\n+  assert(_epoch < MAX_SNAPSHOTS, \"Out of bounds\");\n+  size_t total = 0;\n+  const AgeTable* pv = _global_age_tables[_epoch];\n+  for (uint i = 0; i < MAX_COHORTS; i++) {\n+    if (i >= tenuring_threshold) {\n+      total += pv->sizes[i];\n+    }\n+  }\n+  return total * HeapWordSize;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -214,0 +214,6 @@\n+  \/\/ Return the total size of the population above the given threshold for the current epoch\n+  size_t get_tenurable_bytes(uint tenuring_threshold) const;\n+\n+  \/\/ As above, but use the current tenuring threshold by default\n+  size_t get_tenurable_bytes() const { return get_tenurable_bytes(tenuring_threshold()); }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -228,3 +228,3 @@\n-      const size_t young_evac_bytes = get_young_bytes_reserved_for_evacuation();\n-      const size_t promote_evac_bytes = get_young_bytes_to_be_promoted();\n-      const size_t old_evac_bytes = get_old_bytes_reserved_for_evacuation();\n+      const size_t young_evac_bytes = get_live_bytes_in_young_regions();\n+      const size_t promote_evac_bytes = get_live_bytes_in_tenurable_regions();\n+      const size_t old_evac_bytes = get_live_bytes_in_old_regions();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  inline size_t get_young_bytes_reserved_for_evacuation() const;\n+  inline size_t get_live_bytes_in_young_regions() const;\n@@ -116,1 +116,1 @@\n-  inline size_t get_old_bytes_reserved_for_evacuation() const;\n+  inline size_t get_live_bytes_in_old_regions() const;\n@@ -119,1 +119,1 @@\n-  inline size_t get_young_bytes_to_be_promoted() const;\n+  inline size_t get_live_bytes_in_tenurable_regions() const;\n@@ -128,1 +128,1 @@\n-    assert(_preselected_regions != nullptr, \"Missing etsablish after abandon\");\n+    assert(_preselected_regions != nullptr, \"Missing establish after abandon\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-size_t ShenandoahCollectionSet::get_old_bytes_reserved_for_evacuation() const {\n+size_t ShenandoahCollectionSet::get_live_bytes_in_old_regions() const {\n@@ -61,1 +61,1 @@\n-size_t ShenandoahCollectionSet::get_young_bytes_reserved_for_evacuation() const {\n+size_t ShenandoahCollectionSet::get_live_bytes_in_young_regions() const {\n@@ -65,1 +65,1 @@\n-size_t ShenandoahCollectionSet::get_young_bytes_to_be_promoted() const {\n+size_t ShenandoahCollectionSet::get_live_bytes_in_tenurable_regions() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -293,0 +294,1 @@\n+  const size_t ratio_of_old_in_collection_set = (maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent);\n@@ -294,4 +296,3 @@\n-  const size_t maximum_old_evacuation_reserve = (ShenandoahOldEvacRatioPercent == 100) ?\n-    old_available : MIN2((maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n-                          old_available);\n-\n+  const size_t maximum_old_evacuation_reserve = (ShenandoahOldEvacRatioPercent == 100) ? old_available : MIN2(ratio_of_old_in_collection_set, old_available);\n+  log_debug(gc, cset)(\"max_young_evac_reserver: %zu, max_old_evac_reserve: %zu, old_available: %zu\",\n+                      maximum_young_evacuation_reserve, maximum_old_evacuation_reserve, old_available);\n@@ -370,2 +371,2 @@\n-  \/\/ We may find that old_evacuation_reserve and\/or loaned_for_young_evacuation are not fully consumed, in which case we may\n-  \/\/  be able to increase regions_available_to_loan\n+  \/\/ We may find that old_evacuation_reserve is not fully consumed, in which case we may be able to transfer old\n+  \/\/ unaffiliated regions back to young.\n@@ -373,1 +374,1 @@\n-  \/\/ The role of adjust_evacuation_budgets() is to compute the correct value of regions_available_to_loan and to make\n+  \/\/ The role of adjust_evacuation_budgets() is to compute the correct value of regions to transfer to young and to make\n@@ -385,1 +386,1 @@\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -389,1 +390,1 @@\n-  size_t old_evacuated = collection_set->get_old_bytes_reserved_for_evacuation();\n+  const size_t old_evacuated = collection_set->get_live_bytes_in_old_regions();\n@@ -402,0 +403,1 @@\n+    log_debug(gc, cset)(\"Shrinking old evac reserve to match old_evac_commited: %zu\", old_evacuated_committed);\n@@ -406,7 +408,3 @@\n-  size_t young_advance_promoted = collection_set->get_young_bytes_to_be_promoted();\n-  size_t young_advance_promoted_reserve_used = (size_t) (ShenandoahPromoEvacWaste * double(young_advance_promoted));\n-\n-  size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation();\n-  size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * double(young_evacuated));\n-\n-  size_t total_young_available = young_generation->available_with_reserve();\n+  const size_t young_evacuated = collection_set->get_live_bytes_in_young_regions();\n+  const size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * double(young_evacuated));\n+  const size_t total_young_available = young_generation->available_with_reserve();\n@@ -416,1 +414,0 @@\n-  size_t old_available = old_generation->available();\n@@ -420,11 +417,3 @@\n-  size_t old_consumed = old_evacuated_committed + young_advance_promoted_reserve_used;\n-\n-  if (old_available < old_consumed) {\n-    \/\/ This can happen due to round-off errors when adding the results of truncated integer arithmetic.\n-    \/\/ We've already truncated old_evacuated_committed.  Truncate young_advance_promoted_reserve_used here.\n-    assert(young_advance_promoted_reserve_used <= (33 * (old_available - old_evacuated_committed)) \/ 32,\n-           \"Round-off errors should be less than 3.125%%, committed: %zu, reserved: %zu\",\n-           young_advance_promoted_reserve_used, old_available - old_evacuated_committed);\n-    young_advance_promoted_reserve_used = old_available - old_evacuated_committed;\n-    old_consumed = old_evacuated_committed + young_advance_promoted_reserve_used;\n-  }\n+  const size_t old_available = old_generation->available();\n+  const size_t promoted_reserve = old_generation->get_promoted_reserve();\n+  const size_t old_consumed = old_evacuated_committed + promoted_reserve;\n@@ -432,2 +421,1 @@\n-  assert(old_available >= old_consumed, \"Cannot consume (%zu) more than is available (%zu)\",\n-         old_consumed, old_available);\n+  assert(old_available >= old_consumed, \"Cannot consume (%zu) more than is available (%zu)\", old_consumed, old_available);\n@@ -435,2 +423,2 @@\n-  size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions();\n-  size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n+  const size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions();\n+  const size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n@@ -438,0 +426,1 @@\n+  log_debug(gc, cset)(\"excess_old is: %zu, unaffiliated_old_regions is: %zu\", excess_old, unaffiliated_old_regions);\n@@ -440,4 +429,4 @@\n-  if (old_evacuated_committed > 0) {\n-    if (unaffiliated_old > old_evacuated_committed) {\n-      size_t giveaway = unaffiliated_old - old_evacuated_committed;\n-      size_t giveaway_regions = giveaway \/ region_size_bytes;  \/\/ round down\n+  if (old_consumed > 0) {\n+    if (unaffiliated_old > old_consumed) {\n+      const size_t giveaway = unaffiliated_old - old_consumed;\n+      const size_t giveaway_regions = giveaway \/ region_size_bytes;  \/\/ round down\n@@ -446,0 +435,1 @@\n+        log_debug(gc, cset)(\"Changed excess_old to: %zu\", excess_old);\n@@ -464,1 +454,1 @@\n-    size_t excess_regions = excess_old \/ region_size_bytes;\n+    const size_t excess_regions = excess_old \/ region_size_bytes;\n@@ -469,1 +459,0 @@\n-    bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n@@ -473,0 +462,3 @@\n+    log_debug(gc, ergo)(\"Giving away %zu old regions (old_available, %zu, old_evac: %zu, unaffiliated_old: %zu)\",\n+                        regions_to_xfer, old_available, old_evacuated_committed, unaffiliated_old);\n+    bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n@@ -478,4 +470,0 @@\n-  \/\/ Add in the excess_old memory to hold unanticipated promotions, if any.  If there are more unanticipated\n-  \/\/ promotions than fit in reserved memory, they will be deferred until a future GC pass.\n-  size_t total_promotion_reserve = young_advance_promoted_reserve_used + excess_old;\n-  old_generation->set_promoted_reserve(total_promotion_reserve);\n@@ -527,1 +515,1 @@\n-size_t ShenandoahGeneration::select_aged_regions(size_t old_available) {\n+size_t ShenandoahGeneration::select_aged_regions(const size_t old_promotion_reserve) {\n@@ -540,1 +528,0 @@\n-  size_t old_consumed = 0;\n@@ -563,1 +550,1 @@\n-        \/\/ We prefer to promote this region in place because is has a small amount of garbage and a large usage.\n+        \/\/ We prefer to promote this region in place because it has a small amount of garbage and a large usage.\n@@ -623,0 +610,3 @@\n+\n+  log_info(gc, ergo)(\"Promotion potential of aged regions with sufficient garbage: %zu\", promo_potential);\n+\n@@ -625,0 +615,1 @@\n+  size_t old_consumed = 0;\n@@ -631,3 +622,3 @@\n-      size_t region_live_data = sorted_regions[i]._live_data;\n-      size_t promotion_need = (size_t) (region_live_data * ShenandoahPromoEvacWaste);\n-      if (old_consumed + promotion_need <= old_available) {\n+      const size_t region_live_data = sorted_regions[i]._live_data;\n+      const size_t promotion_need = (size_t) (region_live_data * ShenandoahPromoEvacWaste);\n+      if (old_consumed + promotion_need <= old_promotion_reserve) {\n@@ -647,1 +638,1 @@\n-    log_debug(gc)(\"Preselected %zu regions containing %zu live bytes,\"\n+    log_info(gc, ergo)(\"Preselected %zu regions containing %zu live bytes,\"\n@@ -649,1 +640,1 @@\n-                 selected_regions, selected_live, old_consumed, old_available);\n+                 selected_regions, selected_live, old_consumed, old_promotion_reserve);\n@@ -652,0 +643,7 @@\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+  const size_t tenurable_next_cycle = heap->age_census()->get_tenurable_bytes(tenuring_threshold - 1);\n+  const size_t tenurable_this_cycle = heap->age_census()->get_tenurable_bytes(tenuring_threshold);\n+\n+  log_info(gc, ergo)(\"Promotion potential: %zu, tenurable next cycle: %zu, tenurable this cycle: %zu, selected for promotion: %zu\",\n+                     promo_potential, tenurable_next_cycle, tenurable_this_cycle, old_consumed);\n+\n@@ -653,2 +651,7 @@\n-  heap->old_generation()->set_promotion_potential(promo_potential);\n-  return old_consumed;\n+  heap->old_generation()->set_promotion_potential(tenurable_next_cycle);\n+\n+  assert(old_consumed <= old_promotion_reserve, \"Consumed more (%zu) than we reserved (%zu)\", old_consumed, old_promotion_reserve);\n+\n+  \/\/ old_consumed may exceed tenurable_this_cycle because it has been scaled by ShenandoahPromoEvacWaste.\n+  old_consumed = MAX2(old_consumed, tenurable_this_cycle);\n+  return MIN2(tenurable_this_cycle, old_promotion_reserve);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":55,"deletions":52,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  size_t select_aged_regions(size_t old_available);\n+  size_t select_aged_regions(size_t old_promotion_reserve);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,0 +270,1 @@\n+              \/\/ Shrinking the desired PLAB size may allow us to eke out a small PLAB while staying beneath evacuation reserve.\n@@ -293,1 +294,1 @@\n-      if (!is_promotion || !has_plab || (size > PLAB::min_size())) {\n+      if (!is_promotion || !has_plab || (size > PLAB::max_size())) {\n@@ -297,0 +298,5 @@\n+        if (is_promotion && copy != nullptr) {\n+          log_debug(gc, plab)(\"Made a shared promotion of size: %zu, actual PLAB size for thread: %zu, min PLAB: %zu, max PLAB: %zu\",\n+                              size * HeapWordSize, ShenandoahThreadLocalData::get_plab_actual_size(thread) * HeapWordSize,\n+                              PLAB::min_size() * HeapWordSize, plab_max_size() * HeapWordSize);\n+        }\n@@ -411,1 +417,0 @@\n-  HeapWord* obj;\n@@ -416,0 +421,1 @@\n+    log_debug(gc, plab)(\"Thread has no PLAB\");\n@@ -417,1 +423,4 @@\n-  } else if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+  }\n+\n+  if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+    log_develop_trace(gc, plab)(\"Thread is not allowed to use PLAB for promotions\");\n@@ -420,0 +429,1 @@\n+\n@@ -421,1 +431,1 @@\n-  obj = plab->allocate(size);\n+  HeapWord* obj = plab->allocate(size);\n@@ -439,2 +449,0 @@\n-  \/\/ New object should fit the PLAB size\n-\n@@ -442,0 +450,1 @@\n+\n@@ -454,1 +463,1 @@\n-  size_t future_size = MIN2(cur_size * 2, plab_max_size());\n+  const size_t future_size = MIN2(cur_size * 2, plab_max_size());\n@@ -458,2 +467,2 @@\n-          \", card_size: %zu, cur_size: %zu, max: %zu\",\n-         future_size, (size_t) CardTable::card_size_in_words(), cur_size, plab_max_size());\n+          \", card_size: %u, cur_size: %zu, max: %zu\",\n+         future_size, CardTable::card_size_in_words(), cur_size, plab_max_size());\n@@ -465,1 +474,1 @@\n-  log_debug(gc, free)(\"Set new PLAB size: %zu\", future_size);\n+  log_debug(gc, plab)(\"Set next PLAB refill size: %zu bytes\", future_size * HeapWordSize);\n@@ -467,0 +476,1 @@\n+\n@@ -470,1 +480,1 @@\n-    log_debug(gc, free)(\"Current PLAB size (%zu) is too small for %zu\", cur_size, size);\n+    log_debug(gc, plab)(\"Current PLAB size (%zu) is too small for %zu\", cur_size * HeapWordSize, size * HeapWordSize);\n@@ -474,1 +484,0 @@\n-  \/\/ Retire current PLAB, and allocate a new one.\n@@ -476,39 +485,1 @@\n-  if (plab->words_remaining() < plab_min_size) {\n-    \/\/ Retire current PLAB. This takes care of any PLAB book-keeping.\n-    \/\/ retire_plab() registers the remnant filler object with the remembered set scanner without a lock.\n-    \/\/ Since PLABs are card-aligned, concurrent registrations in other PLABs don't interfere.\n-    retire_plab(plab, thread);\n-\n-    size_t actual_size = 0;\n-    HeapWord* plab_buf = allocate_new_plab(min_size, cur_size, &actual_size);\n-    if (plab_buf == nullptr) {\n-      if (min_size == plab_min_size) {\n-        \/\/ Disable PLAB promotions for this thread because we cannot even allocate a minimal PLAB. This allows us\n-        \/\/ to fail faster on subsequent promotion attempts.\n-        ShenandoahThreadLocalData::disable_plab_promotions(thread);\n-      }\n-      return nullptr;\n-    } else {\n-      ShenandoahThreadLocalData::enable_plab_retries(thread);\n-    }\n-    \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n-    if (ZeroTLAB) {\n-      \/\/ ... and clear it.\n-      Copy::zero_to_words(plab_buf, actual_size);\n-    } else {\n-      \/\/ ...and zap just allocated object.\n-#ifdef ASSERT\n-      \/\/ Skip mangling the space corresponding to the object header to\n-      \/\/ ensure that the returned space is not considered parsable by\n-      \/\/ any concurrent GC thread.\n-      size_t hdr_size = oopDesc::header_size();\n-      Copy::fill_to_words(plab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);\n-#endif \/\/ ASSERT\n-    }\n-    assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n-    plab->set_buf(plab_buf, actual_size);\n-    if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n-      return nullptr;\n-    }\n-    return plab->allocate(size);\n-  } else {\n+  if (plab->words_remaining() >= plab_min_size) {\n@@ -519,0 +490,18 @@\n+    log_debug(gc, plab)(\"Existing PLAB is still viable (words remaining: %zu, plab_min_size: %zu)\", plab->words_remaining(), plab_min_size);\n+    return nullptr;\n+  }\n+\n+  \/\/ The current plab has fewer words remaining than the minimum PLAB. Retire it. This takes care of any PLAB book-keeping.\n+  \/\/ retire_plab() registers the remnant filler object with the remembered set scanner without a lock.\n+  \/\/ Since PLABs are card-aligned, concurrent registrations in other PLABs don't interfere.\n+  retire_plab(plab, thread);\n+\n+  size_t actual_size = 0;\n+  HeapWord* plab_buf = allocate_new_plab(min_size, cur_size, &actual_size);\n+  if (plab_buf == nullptr) {\n+    if (min_size == plab_min_size) {\n+      \/\/ Disable PLAB promotions for this thread because we cannot even allocate a minimal PLAB. This allows us\n+      \/\/ to fail faster on subsequent promotion attempts.\n+      log_debug(gc, plab)(\"Disable PLAB promotions because we can't allocate minimum sized PLAB: %zu\", min_size * HeapWordSize);\n+      ShenandoahThreadLocalData::disable_plab_promotions(thread);\n+    }\n@@ -521,0 +510,31 @@\n+\n+  log_debug(gc, plab)(\"Allocated new PLAB of size: %zu bytes, enable PLAB retries\", actual_size * HeapWordSize);\n+  ShenandoahThreadLocalData::enable_plab_retries(thread);\n+\n+\n+  if (ZeroTLAB) {\n+    \/\/ ... and clear it.\n+    Copy::zero_to_words(plab_buf, actual_size);\n+  } else {\n+    \/\/ ...and zap just allocated object.\n+#ifdef ASSERT\n+    \/\/ Skip mangling the space corresponding to the object header to\n+    \/\/ ensure that the returned space is not considered parsable by\n+    \/\/ any concurrent GC thread.\n+    const size_t hdr_size = oopDesc::header_size();\n+    Copy::fill_to_words(plab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);\n+#endif \/\/ ASSERT\n+  }\n+\n+  assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n+  plab->set_buf(plab_buf, actual_size);\n+  if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+    \/\/ Thinking here is that the thread has exhausted promotion reserve, but there may yet be old objects\n+    \/\/ to evacuate and this plab could be used for those.\n+    log_debug(gc, plab)(\"Thread has new PLAB of size %zu, but is not allowed to promote %zu. Mixed evac in progress? %s\",\n+      actual_size * HeapWordSize, size * HeapWordSize, BOOL_TO_STR(collection_set()->has_old_regions()));\n+    return nullptr;\n+  }\n+\n+  \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n+  return plab->allocate(size);\n@@ -556,0 +576,1 @@\n+    log_debug(gc, plab)(\"Retire PLAB, unexpend unpromoted: %zu\", not_promoted * HeapWordSize);\n@@ -567,2 +588,2 @@\n-    log_debug(gc)(\"retire_plab() is registering remnant of size %zu at \" PTR_FORMAT,\n-                  plab->waste() - original_waste, p2i(top));\n+    log_debug(gc, plab)(\"retire_plab() is registering remnant of size %zu at \" PTR_FORMAT,\n+                  (plab->waste() - original_waste) * HeapWordSize, p2i(top));\n@@ -1091,0 +1112,4 @@\n+  log_info(gc, cset)(\"Concurrent cycle complete, promotions reserved: %zu, promotions expended: %zu, failed count: %zu, failed bytes: %zu\",\n+                     old_generation()->get_promoted_reserve(), old_generation()->get_promoted_expended(),\n+                     old_generation()->get_promotion_failed_count(), old_generation()->get_promotion_failed_words() * HeapWordSize);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":78,"deletions":53,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -1267,1 +1267,1 @@\n-    \/\/ Java threads take this lock while they are being attached and added to the list of thread.\n+    \/\/ Java threads take this lock while they are being attached and added to the list of threads.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,6 +72,0 @@\n-    \/\/ Believe verification following old-gen concurrent mark needs to be different than verification following\n-    \/\/ young-gen concurrent mark, so am commenting this out for now:\n-    \/\/   if (ShenandoahVerify) {\n-    \/\/     heap->verifier()->verify_after_concmark();\n-    \/\/   }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -207,0 +207,2 @@\n+    _promotion_failure_count(0),\n+    _promotion_failure_words(0),\n@@ -243,1 +245,3 @@\n-  AtomicAccess::store(&_promoted_expended, (size_t) 0);\n+  AtomicAccess::store(&_promoted_expended, static_cast<size_t>(0));\n+  AtomicAccess::store(&_promotion_failure_count, static_cast<size_t>(0));\n+  AtomicAccess::store(&_promotion_failure_words, static_cast<size_t>(0));\n@@ -302,0 +306,2 @@\n+        log_debug(gc, plab)(\"Thread can promote using PLAB of %zu bytes. Expended: %zu, available: %zu\",\n+          actual_size, get_promoted_expended(), get_promoted_reserve());\n@@ -309,0 +315,2 @@\n+        log_debug(gc, plab)(\"Thread cannot promote using PLAB of %zu bytes. Expended: %zu, available: %zu, mixed evacuations? %s\",\n+          actual_size, get_promoted_expended(), get_promoted_reserve(), BOOL_TO_STR(ShenandoahHeap::heap()->collection_set()->has_old_regions()));\n@@ -312,0 +320,1 @@\n+      log_debug(gc, plab)(\"Expend shared promotion of %zu bytes\", actual_size);\n@@ -678,3 +687,0 @@\n-  size_t promotion_reserve;\n-  size_t promotion_expended;\n-\n@@ -683,0 +689,3 @@\n+  AtomicAccess::inc(&_promotion_failure_count);\n+  AtomicAccess::add(&_promotion_failure_words, size);\n+\n@@ -684,0 +693,2 @@\n+    size_t promotion_expended;\n+    size_t promotion_reserve;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-  \/\/ Represents the quantity of live bytes we expect to promote in place during the next\n-  \/\/ evacuation cycle. This value is used by the young heuristic to trigger mixed collections.\n+  \/\/ Represents the quantity of live bytes we expect to promote during the next evacuation\n+  \/\/ cycle. This value is used by the young heuristic to trigger mixed collections.\n@@ -75,1 +75,1 @@\n-  \/\/ objects. This field records the total amount of padding used for such regions.\n+  \/\/ objects). This field records the total amount of padding used for such regions.\n@@ -78,0 +78,5 @@\n+  \/\/ Keep track of the number and size of promotions that failed. Perhaps we should use this to increase\n+  \/\/ the size of the old generation for the next collection cycle.\n+  size_t _promotion_failure_count;\n+  size_t _promotion_failure_words;\n+\n@@ -122,0 +127,4 @@\n+  \/\/ Return the count and size (in words) of failed promotions since the last reset\n+  size_t get_promotion_failed_count() const { return _promotion_failure_count; }\n+  size_t get_promotion_failed_words() const { return _promotion_failure_words; }\n+\n@@ -140,0 +149,1 @@\n+\n@@ -141,2 +151,2 @@\n-  void set_promotion_potential(size_t val) { _promotion_potential = val; };\n-  size_t get_promotion_potential() const { return _promotion_potential; };\n+  void set_promotion_potential(size_t val) { _promotion_potential = val; }\n+  size_t get_promotion_potential() const { return _promotion_potential; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-    e.set_collectedOld(cset->get_old_bytes_reserved_for_evacuation());\n-    e.set_collectedPromoted(cset->get_young_bytes_to_be_promoted());\n-    e.set_collectedYoung(cset->get_young_bytes_reserved_for_evacuation());\n+    e.set_collectedOld(cset->get_live_bytes_in_old_regions());\n+    e.set_collectedPromoted(cset->get_live_bytes_in_tenurable_regions());\n+    e.set_collectedYoung(cset->get_live_bytes_in_young_regions());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTrace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -390,7 +390,7 @@\n-          \"expressed as a percentage. The default value 75 denotes that no\" \\\n-          \"more than 75% of the collection set evacuation workload may be \" \\\n-          \"towards evacuation of old-gen heap regions. This limits both the\"\\\n-          \"promotion of aged regions and the compaction of existing old \"   \\\n-          \"regions.  A value of 75 denotes that the total evacuation work\"  \\\n-          \"may increase to up to four times the young gen evacuation work.\" \\\n-          \"A larger value allows quicker promotion and allows\"              \\\n+          \"expressed as a percentage. The default value 75 denotes that \"   \\\n+          \"no more than 75% of the collection set evacuation workload may \" \\\n+          \"be towards evacuation of old-gen heap regions. This limits both \"\\\n+          \"the promotion of aged regions and the compaction of existing \"   \\\n+          \"old regions. A value of 75 denotes that the total evacuation \"   \\\n+          \"work may increase to up to four times the young gen evacuation \" \\\n+          \"work. A larger value allows quicker promotion and allows \"       \\\n@@ -404,1 +404,1 @@\n-          \"replenished.  A value of 0 allows a mixed evacuation to\"         \\\n+          \"replenished.  A value of 0 allows a mixed evacuation to \"        \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    return total;\n+    return total * HeapWordSize;\n@@ -90,0 +90,7 @@\n+TEST_F(ShenandoahAgeCensusTest, get_tenurable_bytes) {\n+  ShenandoahAgeCensus census(1);\n+  update(census);\n+  EXPECT_EQ(get_total_population_older_than(1), census.get_tenurable_bytes(1));\n+  EXPECT_LT(census.get_tenurable_bytes(2), census.get_tenurable_bytes(1));\n+}\n+\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahAgeCensus.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}