{"files":[{"patch":"@@ -144,1 +144,1 @@\n-    size_t live_data_for_evacuation = r->get_live_data_bytes();\n+    const size_t live_data_for_evacuation = r->get_live_data_bytes();\n@@ -172,1 +172,3 @@\n-        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        \/\/ There is no room to evacuate this region or any that come after it in within the candidates array.\n+        log_debug(gc, cset)(\"Not enough unfragmented memory (%zu) to hold evacuees (%zu) from region: (%zu)\",\n+                            unfragmented_available, live_data_for_evacuation, r->index());\n@@ -190,1 +192,3 @@\n-        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        \/\/ There is no room to evacuate this region or any that come after it in within the candidates array.\n+        log_debug(gc, cset)(\"Not enough unfragmented memory (%zu) to hold evacuees (%zu) from region: (%zu)\",\n+                            unfragmented_available, live_data_for_evacuation, r->index());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -184,0 +184,13 @@\n+size_t ShenandoahAgeCensus::get_tenurable_bytes(const uint tenuring_threshold) const {\n+  assert(_epoch < MAX_SNAPSHOTS, \"Out of bounds\");\n+  size_t total = 0;\n+  const AgeTable* pv = _global_age_tables[_epoch];\n+  for (uint i = 0; i < MAX_COHORTS; i++) {\n+    if (i >= tenuring_threshold) {\n+      total += pv->sizes[i];\n+    }\n+  }\n+  return total * HeapWordSize;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -214,0 +214,6 @@\n+  \/\/ Return the total size of the population above the given threshold for the current epoch\n+  size_t get_tenurable_bytes(uint tenuring_threshold) const;\n+\n+  \/\/ As above, but use the current tenuring threshold by default\n+  size_t get_tenurable_bytes() const { return get_tenurable_bytes(tenuring_threshold()); }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -228,3 +228,3 @@\n-      const size_t young_evac_bytes = get_young_bytes_reserved_for_evacuation();\n-      const size_t promote_evac_bytes = get_young_bytes_to_be_promoted();\n-      const size_t old_evac_bytes = get_old_bytes_reserved_for_evacuation();\n+      const size_t young_evac_bytes = get_live_bytes_in_untenurable_regions();\n+      const size_t promote_evac_bytes = get_live_bytes_in_tenurable_regions();\n+      const size_t old_evac_bytes = get_live_bytes_in_old_regions();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-  \/\/ Returns the amount of live bytes in young regions in the collection set. It is not known how many of these bytes will be promoted.\n-  inline size_t get_young_bytes_reserved_for_evacuation() const;\n+  \/\/ Returns the amount of live bytes in young regions with an age below the tenuring threshold.\n+  inline size_t get_live_bytes_in_untenurable_regions() const;\n@@ -116,1 +116,1 @@\n-  inline size_t get_old_bytes_reserved_for_evacuation() const;\n+  inline size_t get_live_bytes_in_old_regions() const;\n@@ -119,1 +119,1 @@\n-  inline size_t get_young_bytes_to_be_promoted() const;\n+  inline size_t get_live_bytes_in_tenurable_regions() const;\n@@ -128,1 +128,1 @@\n-    assert(_preselected_regions != nullptr, \"Missing etsablish after abandon\");\n+    assert(_preselected_regions != nullptr, \"Missing establish after abandon\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-size_t ShenandoahCollectionSet::get_old_bytes_reserved_for_evacuation() const {\n+size_t ShenandoahCollectionSet::get_live_bytes_in_old_regions() const {\n@@ -61,1 +61,1 @@\n-size_t ShenandoahCollectionSet::get_young_bytes_reserved_for_evacuation() const {\n+size_t ShenandoahCollectionSet::get_live_bytes_in_untenurable_regions() const {\n@@ -65,1 +65,1 @@\n-size_t ShenandoahCollectionSet::get_young_bytes_to_be_promoted() const {\n+size_t ShenandoahCollectionSet::get_live_bytes_in_tenurable_regions() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -254,0 +255,22 @@\n+\/\/ Here's the algebra.\n+\/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n+\/\/     OE = old evac,\n+\/\/     YE = young evac, and\n+\/\/     TE = total evac = OE + YE\n+\/\/ By definition:\n+\/\/            SOEP\/100 = OE\/TE\n+\/\/                     = OE\/(OE+YE)\n+\/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)         \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n+\/\/                     = OE\/YE\n+\/\/  =>              OE = YE*SOEP\/(100-SOEP)\n+size_t get_maximum_old_evacuation_reserve(size_t maximum_young_evacuation_reserve, size_t old_available) {\n+  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n+  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n+  if (ShenandoahOldEvacRatioPercent == 100) {\n+    return old_available;\n+  }\n+\n+  const size_t ratio_of_old_in_collection_set = (maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent);\n+  return MIN2(ratio_of_old_in_collection_set, old_available);\n+}\n+\n@@ -278,15 +301,0 @@\n-  \/\/\n-  \/\/ Here's the algebra.\n-  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n-  \/\/     OE = old evac,\n-  \/\/     YE = young evac, and\n-  \/\/     TE = total evac = OE + YE\n-  \/\/ By definition:\n-  \/\/            SOEP\/100 = OE\/TE\n-  \/\/                     = OE\/(OE+YE)\n-  \/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)         \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n-  \/\/                     = OE\/YE\n-  \/\/  =>              OE = YE*SOEP\/(100-SOEP)\n-\n-  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n-  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n@@ -294,3 +302,2 @@\n-  const size_t maximum_old_evacuation_reserve = (ShenandoahOldEvacRatioPercent == 100) ?\n-    old_available : MIN2((maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n-                          old_available);\n+  const size_t maximum_old_evacuation_reserve = get_maximum_old_evacuation_reserve(maximum_young_evacuation_reserve, old_available);\n+\n@@ -298,0 +305,2 @@\n+  log_debug(gc, cset)(\"max_young_evac_reserver: \" PROPERFMT\", max_old_evac_reserve: \" PROPERFMT \", old_available: \" PROPERFMT,\n+                      PROPERFMTARGS(maximum_young_evacuation_reserve), PROPERFMTARGS(maximum_old_evacuation_reserve), PROPERFMTARGS(old_available));\n@@ -353,0 +362,4 @@\n+  assert(consumed_by_advance_promotion <= old_promo_reserve, \"Cannot promote more than was reserved\");\n+\n+  log_info(gc, ergo)(\"Initial evacuation reserves: young: \" PROPERFMT \", promotion: \" PROPERFMT \", old: \" PROPERFMT,\n+                     PROPERFMTARGS(young_evacuation_reserve), PROPERFMTARGS(consumed_by_advance_promotion), PROPERFMTARGS(old_evacuation_reserve));\n@@ -370,2 +383,2 @@\n-  \/\/ We may find that old_evacuation_reserve and\/or loaned_for_young_evacuation are not fully consumed, in which case we may\n-  \/\/  be able to increase regions_available_to_loan\n+  \/\/ We may find that old_evacuation_reserve is not fully consumed, in which case we may be able to transfer old\n+  \/\/ unaffiliated regions back to young.\n@@ -373,1 +386,1 @@\n-  \/\/ The role of adjust_evacuation_budgets() is to compute the correct value of regions_available_to_loan and to make\n+  \/\/ The role of adjust_evacuation_budgets() is to compute the correct value of regions to transfer to young and to make\n@@ -385,1 +398,1 @@\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -389,1 +402,1 @@\n-  size_t old_evacuated = collection_set->get_old_bytes_reserved_for_evacuation();\n+  const size_t old_evacuated = collection_set->get_live_bytes_in_old_regions();\n@@ -402,0 +415,1 @@\n+    log_debug(gc, cset)(\"Shrinking old evac reserve to match old_evac_commited: \" PROPERFMT, PROPERFMTARGS(old_evacuated_committed));\n@@ -406,9 +420,4 @@\n-  size_t young_advance_promoted = collection_set->get_young_bytes_to_be_promoted();\n-  size_t young_advance_promoted_reserve_used = (size_t) (ShenandoahPromoEvacWaste * double(young_advance_promoted));\n-\n-  size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation();\n-  size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * double(young_evacuated));\n-\n-  size_t total_young_available = young_generation->available_with_reserve();\n-  assert(young_evacuated_reserve_used <= total_young_available, \"Cannot evacuate more than is available in young\");\n-  young_generation->set_evacuation_reserve(young_evacuated_reserve_used);\n+  const size_t young_evacuated = collection_set->get_live_bytes_in_untenurable_regions();\n+  const size_t young_evacuated_commited = (size_t) (ShenandoahEvacWaste * double(young_evacuated));\n+  assert(young_evacuated_commited <= young_generation->available_with_reserve(), \"Cannot evacuate more than is available in young\");\n+  young_generation->set_evacuation_reserve(young_evacuated_commited);\n@@ -416,1 +425,0 @@\n-  size_t old_available = old_generation->available();\n@@ -420,11 +428,3 @@\n-  size_t old_consumed = old_evacuated_committed + young_advance_promoted_reserve_used;\n-\n-  if (old_available < old_consumed) {\n-    \/\/ This can happen due to round-off errors when adding the results of truncated integer arithmetic.\n-    \/\/ We've already truncated old_evacuated_committed.  Truncate young_advance_promoted_reserve_used here.\n-    assert(young_advance_promoted_reserve_used <= (33 * (old_available - old_evacuated_committed)) \/ 32,\n-           \"Round-off errors should be less than 3.125%%, committed: %zu, reserved: %zu\",\n-           young_advance_promoted_reserve_used, old_available - old_evacuated_committed);\n-    young_advance_promoted_reserve_used = old_available - old_evacuated_committed;\n-    old_consumed = old_evacuated_committed + young_advance_promoted_reserve_used;\n-  }\n+  const size_t old_available = old_generation->available();\n+  const size_t promoted_reserve = old_generation->get_promoted_reserve();\n+  const size_t old_consumed = old_evacuated_committed + promoted_reserve;\n@@ -432,2 +432,1 @@\n-  assert(old_available >= old_consumed, \"Cannot consume (%zu) more than is available (%zu)\",\n-         old_consumed, old_available);\n+  assert(old_available >= old_consumed, \"Cannot consume (%zu) more than is available (%zu)\", old_consumed, old_available);\n@@ -435,2 +434,2 @@\n-  size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions();\n-  size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n+  const size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions();\n+  const size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n@@ -438,0 +437,1 @@\n+  log_debug(gc, cset)(\"excess_old is: %zu, unaffiliated_old_regions is: %zu\", excess_old, unaffiliated_old_regions);\n@@ -440,4 +440,4 @@\n-  if (old_evacuated_committed > 0) {\n-    if (unaffiliated_old > old_evacuated_committed) {\n-      size_t giveaway = unaffiliated_old - old_evacuated_committed;\n-      size_t giveaway_regions = giveaway \/ region_size_bytes;  \/\/ round down\n+  if (old_consumed > 0) {\n+    if (unaffiliated_old > old_consumed) {\n+      const size_t giveaway = unaffiliated_old - old_consumed;\n+      const size_t giveaway_regions = giveaway \/ region_size_bytes;  \/\/ round down\n@@ -446,0 +446,1 @@\n+        log_debug(gc, cset)(\"Changed excess_old to: %zu\", excess_old);\n@@ -464,1 +465,1 @@\n-    size_t excess_regions = excess_old \/ region_size_bytes;\n+    const size_t excess_regions = excess_old \/ region_size_bytes;\n@@ -469,1 +470,0 @@\n-    bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n@@ -473,0 +473,3 @@\n+    log_debug(gc, ergo)(\"Giving away %zu old regions (old_available, \" PROPERFMT \", old_evac: \" PROPERFMT \", unaffiliated_old: \" PROPERFMT \")\",\n+                        regions_to_xfer, PROPERFMTARGS(old_available), PROPERFMTARGS(old_evacuated_committed), PROPERFMTARGS(unaffiliated_old));\n+    const bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n@@ -478,4 +481,0 @@\n-  \/\/ Add in the excess_old memory to hold unanticipated promotions, if any.  If there are more unanticipated\n-  \/\/ promotions than fit in reserved memory, they will be deferred until a future GC pass.\n-  size_t total_promotion_reserve = young_advance_promoted_reserve_used + excess_old;\n-  old_generation->set_promoted_reserve(total_promotion_reserve);\n@@ -483,0 +482,4 @@\n+  log_info(gc, ergo)(\"Adjusted evacuation reserves: young: \" PROPERFMT \", promotion: \" PROPERFMT \", old: \" PROPERFMT,\n+                     PROPERFMTARGS(young_generation->get_evacuation_reserve()),\n+                     PROPERFMTARGS(old_generation->get_promoted_reserve()),\n+                     PROPERFMTARGS(old_generation->get_evacuation_reserve()));\n@@ -527,1 +530,1 @@\n-size_t ShenandoahGeneration::select_aged_regions(size_t old_available) {\n+size_t ShenandoahGeneration::select_aged_regions(const size_t old_promotion_reserve) {\n@@ -540,1 +543,0 @@\n-  size_t old_consumed = 0;\n@@ -563,1 +565,1 @@\n-        \/\/ We prefer to promote this region in place because is has a small amount of garbage and a large usage.\n+        \/\/ We prefer to promote this region in place because it has a small amount of garbage and a large usage.\n@@ -623,0 +625,3 @@\n+\n+  log_info(gc, ergo)(\"Promotion potential of aged regions with sufficient garbage: \" PROPERFMT, PROPERFMTARGS(promo_potential));\n+\n@@ -625,0 +630,1 @@\n+  size_t old_consumed = 0;\n@@ -631,3 +637,3 @@\n-      size_t region_live_data = sorted_regions[i]._live_data;\n-      size_t promotion_need = (size_t) (region_live_data * ShenandoahPromoEvacWaste);\n-      if (old_consumed + promotion_need <= old_available) {\n+      const size_t region_live_data = sorted_regions[i]._live_data;\n+      const size_t promotion_need = (size_t) (region_live_data * ShenandoahPromoEvacWaste);\n+      if (old_consumed + promotion_need <= old_promotion_reserve) {\n@@ -647,3 +653,3 @@\n-    log_debug(gc)(\"Preselected %zu regions containing %zu live bytes,\"\n-                 \" consuming: %zu of budgeted: %zu\",\n-                 selected_regions, selected_live, old_consumed, old_available);\n+    log_info(gc, ergo)(\"Preselected %zu regions containing \" PROPERFMT \" live data,\"\n+                 \" consuming: \" PROPERFMT \" of budgeted: \" PROPERFMT,\n+                 selected_regions, PROPERFMTARGS(selected_live), PROPERFMTARGS(old_consumed), PROPERFMTARGS(old_promotion_reserve));\n@@ -652,0 +658,7 @@\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+  const size_t tenurable_next_cycle = heap->age_census()->get_tenurable_bytes(tenuring_threshold - 1);\n+  const size_t tenurable_this_cycle = heap->age_census()->get_tenurable_bytes(tenuring_threshold);\n+\n+  log_info(gc, ergo)(\"Promotion potential: \" PROPERFMT \", tenurable next cycle: \" PROPERFMT \", tenurable this cycle: \" PROPERFMT \", selected for promotion: \" PROPERFMT ,\n+                     PROPERFMTARGS(promo_potential), PROPERFMTARGS(tenurable_next_cycle), PROPERFMTARGS(tenurable_this_cycle), PROPERFMTARGS(old_consumed));\n+\n@@ -653,2 +666,7 @@\n-  heap->old_generation()->set_promotion_potential(promo_potential);\n-  return old_consumed;\n+  heap->old_generation()->set_promotion_potential(tenurable_next_cycle);\n+\n+  assert(old_consumed <= old_promotion_reserve, \"Consumed more (%zu) than we reserved (%zu)\", old_consumed, old_promotion_reserve);\n+\n+  \/\/ old_consumed may exceed tenurable_this_cycle because it has been scaled by ShenandoahPromoEvacWaste.\n+  old_consumed = MAX2(old_consumed, tenurable_this_cycle);\n+  return MIN2(old_consumed, old_promotion_reserve);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":87,"deletions":69,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  size_t select_aged_regions(size_t old_available);\n+  size_t select_aged_regions(size_t old_promotion_reserve);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-  size_t initial_capacity_old = max_capacity() - max_capacity_young;\n@@ -270,0 +269,1 @@\n+              \/\/ Shrinking the desired PLAB size may allow us to eke out a small PLAB while staying beneath evacuation reserve.\n@@ -293,1 +293,1 @@\n-      if (!is_promotion || !has_plab || (size > PLAB::min_size())) {\n+      if (!is_promotion || !has_plab || (size > PLAB::max_size())) {\n@@ -297,0 +297,5 @@\n+        if (is_promotion && copy != nullptr) {\n+          log_debug(gc, plab)(\"Made a shared promotion of size: %zu, actual PLAB size for thread: %zu, min PLAB: %zu, max PLAB: %zu\",\n+                              size * HeapWordSize, ShenandoahThreadLocalData::get_plab_actual_size(thread) * HeapWordSize,\n+                              PLAB::min_size() * HeapWordSize, plab_max_size() * HeapWordSize);\n+        }\n@@ -299,3 +304,4 @@\n-      \/\/ We choose not to promote objects smaller than PLAB::min_size() by way of shared allocations, as this is too\n-      \/\/ costly.  Instead, we'll simply \"evacuate\" to young-gen memory (using a GCLAB) and will promote in a future\n-      \/\/ evacuation pass.  This condition is denoted by: is_promotion && has_plab && (size <= PLAB::min_size())\n+      \/\/ We choose not to promote objects smaller than PLAB::max_size() by way of shared allocations, as this is too\n+      \/\/ costly (such objects should use the PLAB). Instead, we'll simply \"evacuate\" to young-gen memory (using a GCLAB)\n+      \/\/ and will promote in a future evacuation pass.  This condition is denoted by: is_promotion && has_plab && (size\n+      \/\/ <= PLAB::max_size())\n@@ -411,1 +417,0 @@\n-  HeapWord* obj;\n@@ -416,0 +421,1 @@\n+    log_debug(gc, plab)(\"Thread has no PLAB\");\n@@ -417,1 +423,4 @@\n-  } else if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+  }\n+\n+  if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+    log_develop_trace(gc, plab)(\"Thread is not allowed to use PLAB for promotions\");\n@@ -420,0 +429,1 @@\n+\n@@ -421,1 +431,1 @@\n-  obj = plab->allocate(size);\n+  HeapWord* obj = plab->allocate(size);\n@@ -439,2 +449,0 @@\n-  \/\/ New object should fit the PLAB size\n-\n@@ -442,0 +450,1 @@\n+\n@@ -454,1 +463,1 @@\n-  size_t future_size = MIN2(cur_size * 2, plab_max_size());\n+  const size_t future_size = MIN2(cur_size * 2, plab_max_size());\n@@ -458,2 +467,2 @@\n-          \", card_size: %zu, cur_size: %zu, max: %zu\",\n-         future_size, (size_t) CardTable::card_size_in_words(), cur_size, plab_max_size());\n+          \", card_size: %u, cur_size: %zu, max: %zu\",\n+         future_size, CardTable::card_size_in_words(), cur_size, plab_max_size());\n@@ -465,1 +474,1 @@\n-  log_debug(gc, free)(\"Set new PLAB size: %zu\", future_size);\n+  log_debug(gc, plab)(\"Set next PLAB refill size: %zu bytes\", future_size * HeapWordSize);\n@@ -467,0 +476,1 @@\n+\n@@ -470,1 +480,1 @@\n-    log_debug(gc, free)(\"Current PLAB size (%zu) is too small for %zu\", cur_size, size);\n+    log_debug(gc, plab)(\"Current PLAB size (%zu) is too small for %zu\", cur_size * HeapWordSize, size * HeapWordSize);\n@@ -474,1 +484,0 @@\n-  \/\/ Retire current PLAB, and allocate a new one.\n@@ -476,39 +485,1 @@\n-  if (plab->words_remaining() < plab_min_size) {\n-    \/\/ Retire current PLAB. This takes care of any PLAB book-keeping.\n-    \/\/ retire_plab() registers the remnant filler object with the remembered set scanner without a lock.\n-    \/\/ Since PLABs are card-aligned, concurrent registrations in other PLABs don't interfere.\n-    retire_plab(plab, thread);\n-\n-    size_t actual_size = 0;\n-    HeapWord* plab_buf = allocate_new_plab(min_size, cur_size, &actual_size);\n-    if (plab_buf == nullptr) {\n-      if (min_size == plab_min_size) {\n-        \/\/ Disable PLAB promotions for this thread because we cannot even allocate a minimal PLAB. This allows us\n-        \/\/ to fail faster on subsequent promotion attempts.\n-        ShenandoahThreadLocalData::disable_plab_promotions(thread);\n-      }\n-      return nullptr;\n-    } else {\n-      ShenandoahThreadLocalData::enable_plab_retries(thread);\n-    }\n-    \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n-    if (ZeroTLAB) {\n-      \/\/ ... and clear it.\n-      Copy::zero_to_words(plab_buf, actual_size);\n-    } else {\n-      \/\/ ...and zap just allocated object.\n-#ifdef ASSERT\n-      \/\/ Skip mangling the space corresponding to the object header to\n-      \/\/ ensure that the returned space is not considered parsable by\n-      \/\/ any concurrent GC thread.\n-      size_t hdr_size = oopDesc::header_size();\n-      Copy::fill_to_words(plab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);\n-#endif \/\/ ASSERT\n-    }\n-    assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n-    plab->set_buf(plab_buf, actual_size);\n-    if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n-      return nullptr;\n-    }\n-    return plab->allocate(size);\n-  } else {\n+  if (plab->words_remaining() >= plab_min_size) {\n@@ -519,0 +490,18 @@\n+    log_debug(gc, plab)(\"Existing PLAB is still viable (words remaining: %zu, plab_min_size: %zu)\", plab->words_remaining(), plab_min_size);\n+    return nullptr;\n+  }\n+\n+  \/\/ The current plab has fewer words remaining than the minimum PLAB. Retire it. This takes care of any PLAB book-keeping.\n+  \/\/ retire_plab() registers the remnant filler object with the remembered set scanner without a lock.\n+  \/\/ Since PLABs are card-aligned, concurrent registrations in other PLABs don't interfere.\n+  retire_plab(plab, thread);\n+\n+  size_t actual_size = 0;\n+  HeapWord* plab_buf = allocate_new_plab(min_size, cur_size, &actual_size);\n+  if (plab_buf == nullptr) {\n+    if (min_size == plab_min_size) {\n+      \/\/ Disable PLAB promotions for this thread because we cannot even allocate a minimal PLAB. This allows us\n+      \/\/ to fail faster on subsequent promotion attempts.\n+      log_debug(gc, plab)(\"Disable PLAB promotions because we can't allocate minimum sized PLAB: %zu\", min_size * HeapWordSize);\n+      ShenandoahThreadLocalData::disable_plab_promotions(thread);\n+    }\n@@ -521,0 +510,31 @@\n+\n+  log_debug(gc, plab)(\"Allocated new PLAB of size: %zu bytes, enable PLAB retries\", actual_size * HeapWordSize);\n+  ShenandoahThreadLocalData::enable_plab_retries(thread);\n+\n+\n+  if (ZeroTLAB) {\n+    \/\/ ... and clear it.\n+    Copy::zero_to_words(plab_buf, actual_size);\n+  } else {\n+    \/\/ ...and zap just allocated object.\n+#ifdef ASSERT\n+    \/\/ Skip mangling the space corresponding to the object header to\n+    \/\/ ensure that the returned space is not considered parsable by\n+    \/\/ any concurrent GC thread.\n+    const size_t hdr_size = oopDesc::header_size();\n+    Copy::fill_to_words(plab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);\n+#endif \/\/ ASSERT\n+  }\n+\n+  assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n+  plab->set_buf(plab_buf, actual_size);\n+  if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+    \/\/ Thinking here is that the thread has exhausted promotion reserve, but there may yet be old objects\n+    \/\/ to evacuate and this plab could be used for those.\n+    log_debug(gc, plab)(\"Thread has new PLAB of size %zu, but is not allowed to promote %zu. Mixed evac in progress? %s\",\n+      actual_size * HeapWordSize, size * HeapWordSize, BOOL_TO_STR(collection_set()->has_old_regions()));\n+    return nullptr;\n+  }\n+\n+  \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n+  return plab->allocate(size);\n@@ -556,0 +576,1 @@\n+    log_debug(gc, plab)(\"Retire PLAB, unexpend unpromoted: %zu\", not_promoted * HeapWordSize);\n@@ -567,2 +588,2 @@\n-    log_debug(gc)(\"retire_plab() is registering remnant of size %zu at \" PTR_FORMAT,\n-                  plab->waste() - original_waste, p2i(top));\n+    log_debug(gc, plab)(\"retire_plab() is registering remnant of size %zu at \" PTR_FORMAT,\n+                  (plab->waste() - original_waste) * HeapWordSize, p2i(top));\n@@ -1091,0 +1112,4 @@\n+  log_info(gc, cset)(\"Concurrent cycle complete, promotions reserved: %zu, promotions expended: %zu, failed count: %zu, failed bytes: %zu\",\n+                     old_generation()->get_promoted_reserve(), old_generation()->get_promoted_expended(),\n+                     old_generation()->get_promotion_failed_count(), old_generation()->get_promotion_failed_words() * HeapWordSize);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":82,"deletions":57,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -1267,1 +1267,1 @@\n-    \/\/ Java threads take this lock while they are being attached and added to the list of thread.\n+    \/\/ Java threads take this lock while they are being attached and added to the list of threads.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,6 +72,0 @@\n-    \/\/ Believe verification following old-gen concurrent mark needs to be different than verification following\n-    \/\/ young-gen concurrent mark, so am commenting this out for now:\n-    \/\/   if (ShenandoahVerify) {\n-    \/\/     heap->verifier()->verify_after_concmark();\n-    \/\/   }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -207,0 +207,2 @@\n+    _promotion_failure_count(0),\n+    _promotion_failure_words(0),\n@@ -243,1 +245,3 @@\n-  AtomicAccess::store(&_promoted_expended, (size_t) 0);\n+  AtomicAccess::store(&_promoted_expended, static_cast<size_t>(0));\n+  AtomicAccess::store(&_promotion_failure_count, static_cast<size_t>(0));\n+  AtomicAccess::store(&_promotion_failure_words, static_cast<size_t>(0));\n@@ -302,0 +306,2 @@\n+        log_debug(gc, plab)(\"Thread can promote using PLAB of %zu bytes. Expended: %zu, available: %zu\",\n+          actual_size, get_promoted_expended(), get_promoted_reserve());\n@@ -309,0 +315,2 @@\n+        log_debug(gc, plab)(\"Thread cannot promote using PLAB of %zu bytes. Expended: %zu, available: %zu, mixed evacuations? %s\",\n+          actual_size, get_promoted_expended(), get_promoted_reserve(), BOOL_TO_STR(ShenandoahHeap::heap()->collection_set()->has_old_regions()));\n@@ -312,0 +320,1 @@\n+      log_debug(gc, plab)(\"Expend shared promotion of %zu bytes\", actual_size);\n@@ -678,3 +687,0 @@\n-  size_t promotion_reserve;\n-  size_t promotion_expended;\n-\n@@ -683,0 +689,3 @@\n+  AtomicAccess::inc(&_promotion_failure_count);\n+  AtomicAccess::add(&_promotion_failure_words, size);\n+\n@@ -684,0 +693,2 @@\n+    size_t promotion_expended;\n+    size_t promotion_reserve;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-  \/\/ Represents the quantity of live bytes we expect to promote in place during the next\n-  \/\/ evacuation cycle. This value is used by the young heuristic to trigger mixed collections.\n+  \/\/ Represents the quantity of live bytes we expect to promote during the next evacuation\n+  \/\/ cycle. This value is used by the young heuristic to trigger mixed collections.\n@@ -75,1 +75,1 @@\n-  \/\/ objects. This field records the total amount of padding used for such regions.\n+  \/\/ objects). This field records the total amount of padding used for such regions.\n@@ -78,0 +78,5 @@\n+  \/\/ Keep track of the number and size of promotions that failed. Perhaps we should use this to increase\n+  \/\/ the size of the old generation for the next collection cycle.\n+  size_t _promotion_failure_count;\n+  size_t _promotion_failure_words;\n+\n@@ -122,0 +127,4 @@\n+  \/\/ Return the count and size (in words) of failed promotions since the last reset\n+  size_t get_promotion_failed_count() const { return _promotion_failure_count; }\n+  size_t get_promotion_failed_words() const { return _promotion_failure_words; }\n+\n@@ -140,0 +149,1 @@\n+\n@@ -141,2 +151,2 @@\n-  void set_promotion_potential(size_t val) { _promotion_potential = val; };\n-  size_t get_promotion_potential() const { return _promotion_potential; };\n+  void set_promotion_potential(size_t val) { _promotion_potential = val; }\n+  size_t get_promotion_potential() const { return _promotion_potential; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-    e.set_collectedOld(cset->get_old_bytes_reserved_for_evacuation());\n-    e.set_collectedPromoted(cset->get_young_bytes_to_be_promoted());\n-    e.set_collectedYoung(cset->get_young_bytes_reserved_for_evacuation());\n+    e.set_collectedOld(cset->get_live_bytes_in_old_regions());\n+    e.set_collectedPromoted(cset->get_live_bytes_in_tenurable_regions());\n+    e.set_collectedYoung(cset->get_live_bytes_in_untenurable_regions());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTrace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -390,7 +390,7 @@\n-          \"expressed as a percentage. The default value 75 denotes that no\" \\\n-          \"more than 75% of the collection set evacuation workload may be \" \\\n-          \"towards evacuation of old-gen heap regions. This limits both the\"\\\n-          \"promotion of aged regions and the compaction of existing old \"   \\\n-          \"regions.  A value of 75 denotes that the total evacuation work\"  \\\n-          \"may increase to up to four times the young gen evacuation work.\" \\\n-          \"A larger value allows quicker promotion and allows\"              \\\n+          \"expressed as a percentage. The default value 75 denotes that \"   \\\n+          \"no more than 75% of the collection set evacuation workload may \" \\\n+          \"be towards evacuation of old-gen heap regions. This limits both \"\\\n+          \"the promotion of aged regions and the compaction of existing \"   \\\n+          \"old regions. A value of 75 denotes that the total evacuation \"   \\\n+          \"work may increase to up to four times the young gen evacuation \" \\\n+          \"work. A larger value allows quicker promotion and allows \"       \\\n@@ -404,1 +404,1 @@\n-          \"replenished.  A value of 0 allows a mixed evacuation to\"         \\\n+          \"replenished.  A value of 0 allows a mixed evacuation to \"        \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    return total;\n+    return total * HeapWordSize;\n@@ -90,0 +90,7 @@\n+TEST_F(ShenandoahAgeCensusTest, get_tenurable_bytes) {\n+  ShenandoahAgeCensus census(1);\n+  update(census);\n+  EXPECT_EQ(get_total_population_older_than(1), census.get_tenurable_bytes(1));\n+  EXPECT_LT(census.get_tenurable_bytes(2), census.get_tenurable_bytes(1));\n+}\n+\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahAgeCensus.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}