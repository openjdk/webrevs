{"files":[{"patch":"@@ -184,0 +184,13 @@\n+size_t ShenandoahAgeCensus::get_tenurable_bytes(const uint tenuring_threshold) const {\n+  assert(_epoch < MAX_SNAPSHOTS, \"Out of bounds\");\n+  size_t total = 0;\n+  const AgeTable* pv = _global_age_tables[_epoch];\n+  for (uint i = 0; i < MAX_COHORTS; i++) {\n+    if (i >= tenuring_threshold) {\n+      total += pv->sizes[i];\n+    }\n+  }\n+  return total * HeapWordSize;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -214,0 +214,6 @@\n+  \/\/ Return the total size of the population above the given threshold for the current epoch\n+  size_t get_tenurable_bytes(uint tenuring_threshold) const;\n+\n+  \/\/ As above, but use the current tenuring threshold by default\n+  size_t get_tenurable_bytes() const { return get_tenurable_bytes(tenuring_threshold()); }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -254,0 +255,22 @@\n+\/\/ Here's the algebra.\n+\/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n+\/\/     OE = old evac,\n+\/\/     YE = young evac, and\n+\/\/     TE = total evac = OE + YE\n+\/\/ By definition:\n+\/\/            SOEP\/100 = OE\/TE\n+\/\/                     = OE\/(OE+YE)\n+\/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)         \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n+\/\/                     = OE\/YE\n+\/\/  =>              OE = YE*SOEP\/(100-SOEP)\n+size_t get_maximum_old_evacuation_reserve(size_t maximum_young_evacuation_reserve, size_t old_available) {\n+  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n+  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n+  if (ShenandoahOldEvacRatioPercent == 100) {\n+    return old_available;\n+  }\n+\n+  const size_t ratio_of_old_in_collection_set = (maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent);\n+  return MIN2(ratio_of_old_in_collection_set, old_available);\n+}\n+\n@@ -278,15 +301,0 @@\n-  \/\/\n-  \/\/ Here's the algebra.\n-  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n-  \/\/     OE = old evac,\n-  \/\/     YE = young evac, and\n-  \/\/     TE = total evac = OE + YE\n-  \/\/ By definition:\n-  \/\/            SOEP\/100 = OE\/TE\n-  \/\/                     = OE\/(OE+YE)\n-  \/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)         \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n-  \/\/                     = OE\/YE\n-  \/\/  =>              OE = YE*SOEP\/(100-SOEP)\n-\n-  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n-  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n@@ -294,3 +302,1 @@\n-  const size_t maximum_old_evacuation_reserve = (ShenandoahOldEvacRatioPercent == 100) ?\n-    old_available : MIN2((maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n-                          old_available);\n+  const size_t maximum_old_evacuation_reserve = get_maximum_old_evacuation_reserve(maximum_young_evacuation_reserve, old_available);\n@@ -299,0 +305,3 @@\n+  log_debug(gc, cset)(\"max_young_evac_reserver: \" PROPERFMT\", max_old_evac_reserve: \" PROPERFMT \", old_available: \" PROPERFMT,\n+                      PROPERFMTARGS(maximum_young_evacuation_reserve), PROPERFMTARGS(maximum_old_evacuation_reserve), PROPERFMTARGS(old_available));\n+\n@@ -353,0 +362,4 @@\n+  assert(consumed_by_advance_promotion <= old_promo_reserve, \"Cannot promote more than was reserved\");\n+\n+  log_info(gc, ergo)(\"Initial evacuation reserves: young: \" PROPERFMT \", promotion: \" PROPERFMT \", old: \" PROPERFMT,\n+                     PROPERFMTARGS(young_evacuation_reserve), PROPERFMTARGS(consumed_by_advance_promotion), PROPERFMTARGS(old_evacuation_reserve));\n@@ -370,2 +383,2 @@\n-  \/\/ We may find that old_evacuation_reserve and\/or loaned_for_young_evacuation are not fully consumed, in which case we may\n-  \/\/  be able to increase regions_available_to_loan\n+  \/\/ We may find that old_evacuation_reserve is not fully consumed, in which case we may be able to transfer old\n+  \/\/ unaffiliated regions back to young.\n@@ -373,1 +386,1 @@\n-  \/\/ The role of adjust_evacuation_budgets() is to compute the correct value of regions_available_to_loan and to make\n+  \/\/ The role of adjust_evacuation_budgets() is to compute the correct value of regions to transfer to young and to make\n@@ -407,2 +420,4 @@\n-  size_t young_advance_promoted = collection_set->get_live_bytes_in_tenurable_regions();\n-  size_t young_advance_promoted_reserve_used = (size_t) (ShenandoahPromoEvacWaste * double(young_advance_promoted));\n+  const size_t young_evacuated = collection_set->get_live_bytes_in_untenurable_regions();\n+  const size_t young_evacuated_commited = (size_t) (ShenandoahEvacWaste * double(young_evacuated));\n+  assert(young_evacuated_commited <= young_generation->available_with_reserve(), \"Cannot evacuate more than is available in young\");\n+  young_generation->set_evacuation_reserve(young_evacuated_commited);\n@@ -410,8 +425,0 @@\n-  size_t young_evacuated = collection_set->get_live_bytes_in_untenurable_regions();\n-  size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * double(young_evacuated));\n-\n-  size_t total_young_available = young_generation->available_with_reserve();\n-  assert(young_evacuated_reserve_used <= total_young_available, \"Cannot evacuate more than is available in young\");\n-  young_generation->set_evacuation_reserve(young_evacuated_reserve_used);\n-\n-  size_t old_available = old_generation->available();\n@@ -421,11 +428,3 @@\n-  size_t old_consumed = old_evacuated_committed + young_advance_promoted_reserve_used;\n-\n-  if (old_available < old_consumed) {\n-    \/\/ This can happen due to round-off errors when adding the results of truncated integer arithmetic.\n-    \/\/ We've already truncated old_evacuated_committed.  Truncate young_advance_promoted_reserve_used here.\n-    assert(young_advance_promoted_reserve_used <= (33 * (old_available - old_evacuated_committed)) \/ 32,\n-           \"Round-off errors should be less than 3.125%%, committed: %zu, reserved: %zu\",\n-           young_advance_promoted_reserve_used, old_available - old_evacuated_committed);\n-    young_advance_promoted_reserve_used = old_available - old_evacuated_committed;\n-    old_consumed = old_evacuated_committed + young_advance_promoted_reserve_used;\n-  }\n+  const size_t old_available = old_generation->available();\n+  const size_t promoted_reserve = old_generation->get_promoted_reserve();\n+  const size_t old_consumed = old_evacuated_committed + promoted_reserve;\n@@ -433,2 +432,1 @@\n-  assert(old_available >= old_consumed, \"Cannot consume (%zu) more than is available (%zu)\",\n-         old_consumed, old_available);\n+  assert(old_available >= old_consumed, \"Cannot consume (%zu) more than is available (%zu)\", old_consumed, old_available);\n@@ -436,2 +434,2 @@\n-  size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions();\n-  size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n+  const size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions();\n+  const size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n@@ -439,0 +437,1 @@\n+  log_debug(gc, cset)(\"excess_old is: %zu, unaffiliated_old_regions is: %zu\", excess_old, unaffiliated_old_regions);\n@@ -441,4 +440,4 @@\n-  if (old_evacuated_committed > 0) {\n-    if (unaffiliated_old > old_evacuated_committed) {\n-      size_t giveaway = unaffiliated_old - old_evacuated_committed;\n-      size_t giveaway_regions = giveaway \/ region_size_bytes;  \/\/ round down\n+  if (old_consumed > 0) {\n+    if (unaffiliated_old > old_consumed) {\n+      const size_t giveaway = unaffiliated_old - old_consumed;\n+      const size_t giveaway_regions = giveaway \/ region_size_bytes;  \/\/ round down\n@@ -447,0 +446,1 @@\n+        log_debug(gc, cset)(\"Changed excess_old to: %zu\", excess_old);\n@@ -465,1 +465,1 @@\n-    size_t excess_regions = excess_old \/ region_size_bytes;\n+    const size_t excess_regions = excess_old \/ region_size_bytes;\n@@ -470,1 +470,0 @@\n-    bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n@@ -474,0 +473,3 @@\n+    log_debug(gc, ergo)(\"Giving away %zu old regions (old_available, \" PROPERFMT \", old_evac: \" PROPERFMT \", unaffiliated_old: \" PROPERFMT \")\",\n+                        regions_to_xfer, PROPERFMTARGS(old_available), PROPERFMTARGS(old_evacuated_committed), PROPERFMTARGS(unaffiliated_old));\n+    const bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n@@ -479,4 +481,0 @@\n-  \/\/ Add in the excess_old memory to hold unanticipated promotions, if any.  If there are more unanticipated\n-  \/\/ promotions than fit in reserved memory, they will be deferred until a future GC pass.\n-  size_t total_promotion_reserve = young_advance_promoted_reserve_used + excess_old;\n-  old_generation->set_promoted_reserve(total_promotion_reserve);\n@@ -484,0 +482,4 @@\n+  log_info(gc, ergo)(\"Adjusted evacuation reserves: young: \" PROPERFMT \", promotion: \" PROPERFMT \", old: \" PROPERFMT,\n+                     PROPERFMTARGS(young_generation->get_evacuation_reserve()),\n+                     PROPERFMTARGS(old_generation->get_promoted_reserve()),\n+                     PROPERFMTARGS(old_generation->get_evacuation_reserve()));\n@@ -656,0 +658,7 @@\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+  const size_t tenurable_next_cycle = heap->age_census()->get_tenurable_bytes(tenuring_threshold - 1);\n+  const size_t tenurable_this_cycle = heap->age_census()->get_tenurable_bytes(tenuring_threshold);\n+\n+  log_info(gc, ergo)(\"Promotion potential: \" PROPERFMT \", tenurable next cycle: \" PROPERFMT \", tenurable this cycle: \" PROPERFMT \", selected for promotion: \" PROPERFMT ,\n+                     PROPERFMTARGS(promo_potential), PROPERFMTARGS(tenurable_next_cycle), PROPERFMTARGS(tenurable_this_cycle), PROPERFMTARGS(old_consumed));\n+\n@@ -657,2 +666,7 @@\n-  heap->old_generation()->set_promotion_potential(promo_potential);\n-  return old_consumed;\n+  heap->old_generation()->set_promotion_potential(tenurable_next_cycle);\n+\n+  assert(old_consumed <= old_promotion_reserve, \"Consumed more (%zu) than we reserved (%zu)\", old_consumed, old_promotion_reserve);\n+\n+  \/\/ old_consumed may exceed tenurable_this_cycle because it has been scaled by ShenandoahPromoEvacWaste.\n+  old_consumed = MAX2(old_consumed, tenurable_this_cycle);\n+  return MIN2(old_consumed, old_promotion_reserve);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":72,"deletions":58,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-      if (!is_promotion || !has_plab || (size > PLAB::min_size())) {\n+      if (!is_promotion || !has_plab || (size > PLAB::max_size())) {\n@@ -297,0 +297,5 @@\n+        if (is_promotion && copy != nullptr) {\n+          log_debug(gc, plab)(\"Made a shared promotion of size: %zu, actual PLAB size for thread: %zu, min PLAB: %zu, max PLAB: %zu\",\n+                              size * HeapWordSize, ShenandoahThreadLocalData::get_plab_actual_size(thread) * HeapWordSize,\n+                              PLAB::min_size() * HeapWordSize, plab_max_size() * HeapWordSize);\n+        }\n@@ -299,3 +304,4 @@\n-      \/\/ We choose not to promote objects smaller than PLAB::min_size() by way of shared allocations, as this is too\n-      \/\/ costly.  Instead, we'll simply \"evacuate\" to young-gen memory (using a GCLAB) and will promote in a future\n-      \/\/ evacuation pass.  This condition is denoted by: is_promotion && has_plab && (size <= PLAB::min_size())\n+      \/\/ We choose not to promote objects smaller than PLAB::max_size() by way of shared allocations, as this is too\n+      \/\/ costly (such objects should use the PLAB). Instead, we'll simply \"evacuate\" to young-gen memory (using a GCLAB)\n+      \/\/ and will promote in a future evacuation pass.  This condition is denoted by: is_promotion && has_plab && (size\n+      \/\/ <= PLAB::max_size())\n@@ -411,1 +417,0 @@\n-  HeapWord* obj;\n@@ -416,0 +421,1 @@\n+    log_debug(gc, plab)(\"Thread has no PLAB\");\n@@ -417,1 +423,4 @@\n-  } else if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+  }\n+\n+  if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+    log_develop_trace(gc, plab)(\"Thread is not allowed to use PLAB for promotions\");\n@@ -420,0 +429,1 @@\n+\n@@ -421,1 +431,1 @@\n-  obj = plab->allocate(size);\n+  HeapWord* obj = plab->allocate(size);\n@@ -474,1 +484,0 @@\n-  \/\/ Retire current PLAB, and allocate a new one.\n@@ -476,39 +485,1 @@\n-  if (plab->words_remaining() < plab_min_size) {\n-    \/\/ Retire current PLAB. This takes care of any PLAB book-keeping.\n-    \/\/ retire_plab() registers the remnant filler object with the remembered set scanner without a lock.\n-    \/\/ Since PLABs are card-aligned, concurrent registrations in other PLABs don't interfere.\n-    retire_plab(plab, thread);\n-\n-    size_t actual_size = 0;\n-    HeapWord* plab_buf = allocate_new_plab(min_size, cur_size, &actual_size);\n-    if (plab_buf == nullptr) {\n-      if (min_size == plab_min_size) {\n-        \/\/ Disable PLAB promotions for this thread because we cannot even allocate a minimal PLAB. This allows us\n-        \/\/ to fail faster on subsequent promotion attempts.\n-        ShenandoahThreadLocalData::disable_plab_promotions(thread);\n-      }\n-      return nullptr;\n-    } else {\n-      ShenandoahThreadLocalData::enable_plab_retries(thread);\n-    }\n-    \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n-    if (ZeroTLAB) {\n-      \/\/ ... and clear it.\n-      Copy::zero_to_words(plab_buf, actual_size);\n-    } else {\n-      \/\/ ...and zap just allocated object.\n-#ifdef ASSERT\n-      \/\/ Skip mangling the space corresponding to the object header to\n-      \/\/ ensure that the returned space is not considered parsable by\n-      \/\/ any concurrent GC thread.\n-      size_t hdr_size = oopDesc::header_size();\n-      Copy::fill_to_words(plab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);\n-#endif \/\/ ASSERT\n-    }\n-    assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n-    plab->set_buf(plab_buf, actual_size);\n-    if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n-      return nullptr;\n-    }\n-    return plab->allocate(size);\n-  } else {\n+  if (plab->words_remaining() >= plab_min_size) {\n@@ -519,0 +490,46 @@\n+    log_debug(gc, plab)(\"Existing PLAB is still viable (words remaining: %zu, plab_min_size: %zu)\", plab->words_remaining(), plab_min_size);\n+    return nullptr;\n+  }\n+\n+  \/\/ The current plab has fewer words remaining than the minimum PLAB. Retire it. This takes care of any PLAB book-keeping.\n+  \/\/ retire_plab() registers the remnant filler object with the remembered set scanner without a lock.\n+  \/\/ Since PLABs are card-aligned, concurrent registrations in other PLABs don't interfere.\n+  retire_plab(plab, thread);\n+\n+  size_t actual_size = 0;\n+  HeapWord* plab_buf = allocate_new_plab(min_size, cur_size, &actual_size);\n+  if (plab_buf == nullptr) {\n+    if (min_size == plab_min_size) {\n+      \/\/ Disable PLAB promotions for this thread because we cannot even allocate a minimal PLAB. This allows us\n+      \/\/ to fail faster on subsequent promotion attempts.\n+      log_debug(gc, plab)(\"Disable PLAB promotions because we can't allocate minimum sized PLAB: %zu\", min_size * HeapWordSize);\n+      ShenandoahThreadLocalData::disable_plab_promotions(thread);\n+    }\n+    return nullptr;\n+  }\n+\n+  log_debug(gc, plab)(\"Allocated new PLAB of size: %zu bytes, enable PLAB retries\", actual_size * HeapWordSize);\n+  ShenandoahThreadLocalData::enable_plab_retries(thread);\n+\n+\n+  if (ZeroTLAB) {\n+    \/\/ ... and clear it.\n+    Copy::zero_to_words(plab_buf, actual_size);\n+  } else {\n+    \/\/ ...and zap just allocated object.\n+#ifdef ASSERT\n+    \/\/ Skip mangling the space corresponding to the object header to\n+    \/\/ ensure that the returned space is not considered parsable by\n+    \/\/ any concurrent GC thread.\n+    const size_t hdr_size = oopDesc::header_size();\n+    Copy::fill_to_words(plab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);\n+#endif \/\/ ASSERT\n+  }\n+\n+  assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n+  plab->set_buf(plab_buf, actual_size);\n+  if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+    \/\/ Thinking here is that the thread has exhausted promotion reserve, but there may yet be old objects\n+    \/\/ to evacuate and this plab could be used for those.\n+    log_debug(gc, plab)(\"Thread has new PLAB of size %zu, but is not allowed to promote %zu. Mixed evac in progress? %s\",\n+      actual_size * HeapWordSize, size * HeapWordSize, BOOL_TO_STR(collection_set()->has_old_regions()));\n@@ -521,0 +538,3 @@\n+\n+  \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n+  return plab->allocate(size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":67,"deletions":47,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    return total;\n+    return total * HeapWordSize;\n@@ -90,0 +90,7 @@\n+TEST_F(ShenandoahAgeCensusTest, get_tenurable_bytes) {\n+  ShenandoahAgeCensus census(1);\n+  update(census);\n+  EXPECT_EQ(get_total_population_older_than(1), census.get_tenurable_bytes(1));\n+  EXPECT_LT(census.get_tenurable_bytes(2), census.get_tenurable_bytes(1));\n+}\n+\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahAgeCensus.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}