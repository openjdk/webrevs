{"files":[{"patch":"@@ -609,1 +609,1 @@\n-        if (_cm->live_words(r->hrm_index()) == 0) {\n+        if (!_cm->contains_live_object(r->hrm_index())) {\n@@ -1112,1 +1112,1 @@\n-        bool const is_live = _cm->live_words(hr->humongous_start_region()->hrm_index()) > 0;\n+        bool const is_live = _cm->contains_live_object(hr->humongous_start_region()->hrm_index());\n@@ -1124,3 +1124,3 @@\n-    \/\/ Distribute the given words across the humongous object starting with hr and\n-    \/\/ note end of marking.\n-    void distribute_marked_bytes(HeapRegion* hr, size_t marked_words) {\n+    \/\/ Distribute the given marked bytes across the humongous object starting\n+    \/\/ with hr and note end of marking for these regions.\n+    void distribute_marked_bytes(HeapRegion* hr, size_t marked_bytes) {\n@@ -1128,0 +1128,1 @@\n+\n@@ -1133,3 +1134,3 @@\n-      assert(marked_words == 0 || obj_size_in_words == marked_words,\n-             \"Marked words should either be 0 or the same as humongous object (\" SIZE_FORMAT \") but is \" SIZE_FORMAT,\n-             obj_size_in_words, marked_words);\n+      assert(marked_bytes == 0 || obj_size_in_words * HeapWordSize == marked_bytes,\n+             \"Marked bytes should either be 0 or the same as humongous object (%zu) but is %zu\",\n+             obj_size_in_words * HeapWordSize, marked_bytes);\n@@ -1139,1 +1140,1 @@\n-        size_t const words_to_add = MIN2(HeapRegion::GrainWords, marked_words);\n+        size_t const bytes_to_add = MIN2(HeapRegion::GrainBytes, marked_bytes);\n@@ -1141,4 +1142,4 @@\n-        log_trace(gc, marking)(\"Adding \" SIZE_FORMAT \" words to humongous region %u (%s)\",\n-                               words_to_add, i, r->get_type_str());\n-        add_marked_bytes_and_note_end(r, words_to_add * HeapWordSize);\n-        marked_words -= words_to_add;\n+        log_trace(gc, marking)(\"Adding %zu bytes to humongous region %u (%s)\",\n+                               bytes_to_add, i, r->get_type_str());\n+        add_marked_bytes_and_note_end(r, bytes_to_add);\n+        marked_bytes -= bytes_to_add;\n@@ -1146,3 +1147,3 @@\n-      assert(marked_words == 0,\n-             SIZE_FORMAT \" words left after distributing space across %u regions\",\n-             marked_words, num_regions_in_humongous);\n+      assert(marked_bytes == 0,\n+             \"%zu bytes left after distributing space across %u regions\",\n+             marked_bytes, num_regions_in_humongous);\n@@ -1153,1 +1154,1 @@\n-      size_t const marked_words = _cm->live_words(region_idx);\n+      size_t const marked_bytes = _cm->live_bytes(region_idx);\n@@ -1158,3 +1159,3 @@\n-        assert(hr->is_starts_humongous() || marked_words == 0,\n-               \"Should not have marked words \" SIZE_FORMAT \" in non-starts humongous region %u (%s)\",\n-               marked_words, region_idx, hr->get_type_str());\n+        assert(hr->is_starts_humongous() || !_cm->contains_live_object(region_idx),\n+               \"Should not have live bytes %zu in continues humongous region %u (%s)\",\n+               marked_bytes, region_idx, hr->get_type_str());\n@@ -1162,1 +1163,1 @@\n-          distribute_marked_bytes(hr, marked_words);\n+          distribute_marked_bytes(hr, marked_bytes);\n@@ -1165,2 +1166,2 @@\n-        log_trace(gc, marking)(\"Adding \" SIZE_FORMAT \" words to region %u (%s)\", marked_words, region_idx, hr->get_type_str());\n-        add_marked_bytes_and_note_end(hr, _cm->live_bytes(region_idx));\n+        log_trace(gc, marking)(\"Adding %zu bytes to region %u (%s)\", marked_bytes, region_idx, hr->get_type_str());\n+        add_marked_bytes_and_note_end(hr, marked_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -471,5 +471,5 @@\n-  \/\/ Live words in the given region as determined by concurrent marking, i.e. the amount of\n-  \/\/ live words between bottom and TAMS.\n-  size_t live_words(uint region) const { return _region_mark_stats[region]._live_words; }\n-  \/\/ Returns the liveness value in bytes.\n-  size_t live_bytes(uint region) const { return live_words(region) * HeapWordSize; }\n+  \/\/ Did the last marking find a live object between bottom and TAMS?\n+  bool contains_live_object(uint region) const { return _region_mark_stats[region]._live_words != 0; }\n+  \/\/ Live bytes in the given region as determined by concurrent marking, i.e. the amount of\n+  \/\/ live bytes between bottom and TAMS.\n+  size_t live_bytes(uint region) const { return _region_mark_stats[region]._live_words * HeapWordSize; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}