{"files":[{"patch":"@@ -3632,3 +3632,4 @@\n-  if (tmp != obj) {\n-    assert_different_registers(obj, tmp, rscratch1, mdo_addr.base(), mdo_addr.index());\n-    __ mov(tmp, obj);\n+#ifdef ASSERT\n+  if (obj == tmp) {\n+    LP64_ONLY(assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());)\n+    NOT_LP64(assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());)\n@@ -3636,1 +3637,2 @@\n-    assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+    LP64_ONLY(assert_different_registers(obj, tmp, rscratch1, mdo_addr.base(), mdo_addr.index());)\n+    NOT_LP64(assert_different_registers(obj, tmp, mdo_addr.base(), mdo_addr.index());)\n@@ -3638,0 +3640,1 @@\n+#endif\n@@ -3639,1 +3642,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3642,0 +3645,8 @@\n+      __ testptr(mdo_addr, TypeEntries::null_seen);\n+#ifndef ASSERT\n+      __ jccb(Assembler::notZero, next); \/\/ already set\n+#else\n+      __ jcc(Assembler::notZero, next); \/\/ already set\n+#endif\n+      \/\/ atomic update to prevent overwriting Klass* with 0\n+      __ lock();\n@@ -3652,1 +3663,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3664,1 +3675,1 @@\n-      __ load_klass(tmp, tmp, tmp_load_klass);\n+      __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3679,1 +3690,1 @@\n-          __ load_klass(tmp, tmp, tmp_load_klass);\n+          __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3681,3 +3692,4 @@\n-\n-        __ movptr(rscratch1, mdo_addr);\n-        __ xorptr(tmp, rscratch1);\n+#ifdef _LP64\n+        __ mov(rscratch1, tmp); \/\/ save original value before XOR\n+#endif\n+        __ xorptr(tmp, mdo_addr);\n@@ -3693,1 +3705,1 @@\n-          __ testptr(rscratch1, TypeEntries::type_mask);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n@@ -3695,2 +3707,3 @@\n-          \/\/ There is a chance that the checks above\n-          \/\/ fail if another thread has just set the\n+#ifdef _LP64\n+          \/\/ There is a chance that the checks above (re-reading profiling\n+          \/\/ data from memory) fail if another thread has just set the\n@@ -3698,1 +3711,1 @@\n-          __ xorptr(tmp, rscratch1); \/\/ get back original value before XOR\n+          __ mov(tmp, rscratch1); \/\/ get back original value before XOR\n@@ -3702,0 +3715,1 @@\n+#endif\n@@ -3707,2 +3721,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3721,0 +3734,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3735,4 +3752,2 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jcc(Assembler::equal, ok);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jcc(Assembler::equal, ok);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jcc(Assembler::zero, ok);\n@@ -3754,0 +3769,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3758,2 +3777,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3765,2 +3783,0 @@\n-\n-    __ bind(next);\n@@ -3768,0 +3784,1 @@\n+  __ bind(next);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":42,"deletions":25,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#ifdef _LP64\n@@ -58,0 +59,3 @@\n+#else\n+  assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n@@ -63,0 +67,4 @@\n+  testptr(mdo_addr, TypeEntries::null_seen);\n+  jccb(Assembler::notZero, next); \/\/ null already seen. Nothing to do anymore.\n+  \/\/ atomic update to prevent overwriting Klass* with 0\n+  lock();\n@@ -68,0 +76,3 @@\n+#ifdef _LP64\n+  mov(rscratch1, obj);\n+#endif\n@@ -69,2 +80,1 @@\n-  movptr(rscratch1, mdo_addr);\n-  xorptr(obj, rscratch1);\n+  xorptr(obj, mdo_addr);\n@@ -79,6 +89,7 @@\n-  \/\/ is_type_none?\n-  testptr(rscratch1, TypeEntries::type_mask);\n-  jccb(Assembler::zero, none);\n-\n-  \/\/ There is a chance that the checks above\n-  \/\/ fail if another thread has just set the\n+  cmpptr(mdo_addr, 0);\n+  jccb(Assembler::equal, none);\n+  cmpptr(mdo_addr, TypeEntries::null_seen);\n+  jccb(Assembler::equal, none);\n+#ifdef _LP64\n+  \/\/ There is a chance that the checks above (re-reading profiling\n+  \/\/ data from memory) fail if another thread has just set the\n@@ -86,1 +97,1 @@\n-  xorptr(obj, rscratch1); \/\/ get back original value before XOR\n+  mov(obj, rscratch1);\n@@ -90,0 +101,1 @@\n+#endif\n@@ -98,0 +110,4 @@\n+#ifdef ASSERT\n+  andptr(obj, TypeEntries::type_klass_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -897,0 +897,1 @@\n+  void testptr(Address src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}