{"files":[{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8321396\n+ * @summary Verify that ZipInputStream ignores non-zero, incorrect 'crc',\n+ * 'compressed size' and 'uncompressed size' values when in streaming mode.\n+ * @run junit DataDescriptorIgnoreCrcAndSizeFields\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class DataDescriptorIgnoreCrcAndSizeFields {\n+\n+    \/**\n+     * Verify that ZipInputStream correctly ignores values from a LOC header's\n+     * 'crc', 'compressed size' and 'uncompressed size' fields, when in\n+     * streaming mode and these fields are incorrectly set to non-zero values.\n+     *\/\n+    @Test\n+    public void shouldIgnoreCrcAndSizeValuesInStreamingMode() throws IOException {\n+        \/\/ ZIP with incorrect 'CRC', 'compressed size' and 'uncompressed size' values\n+        byte[] zip = zipWithIncorrectCrcAndSizeValuesInLocalHeader();\n+\n+        \/\/ ZipInputStream should ignore the incorrect field values\n+        try (ZipInputStream in = new ZipInputStream(new ByteArrayInputStream(zip))) {\n+            ZipEntry first = in.getNextEntry();\n+            assertNotNull(first, \"Zip file is unexpectedly missing first entry\");\n+\n+            \/\/ CRC, compressed size and size should be uninitialized at this point\n+            assertCrcAndSize(first, -1, -1, -1);\n+            \/\/ Check that name and contents is as expected\n+            assertNameAndContents(\"first\", first, in);\n+            \/\/ At this point, ZipInputStream should have read correct values from the data descriptor\n+            assertCrcAndSize(first, crc32(\"first\"), compressedSize(\"first\"), uncompressedSize(\"first\"));\n+\n+            \/\/ For extra caution, also read and validate the second entry\n+            ZipEntry second = in.getNextEntry();\n+            assertNotNull(second, \"Zip file is unexpectedly missing second entry\");\n+\n+            \/\/ CRC, compressed size and size should be uninitialized at this point\n+            assertCrcAndSize(second, -1, -1, -1);\n+            \/\/ Check that name and contents is as expected\n+            assertNameAndContents(\"second\", second, in);\n+            \/\/ At this point, ZipInputStream should have read correct values from the data descriptor\n+            assertCrcAndSize(second, crc32(\"second\"), compressedSize(\"second\"), uncompressedSize(\"second\"));\n+        }\n+\n+    }\n+\n+    \/**\n+     * Assert that the given ZipEntry has the expected name and that\n+     * the expected content can be read from the ZipInputStream\n+     * @param expected the expected name and content\n+     * @param entry the entry to check the name of\n+     * @param in the ZipInputStream to check the entry content of\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    private static void assertNameAndContents(String expected, ZipEntry entry, ZipInputStream in) throws IOException {\n+        assertEquals(expected, entry.getName());\n+        assertArrayEquals(expected.getBytes(StandardCharsets.UTF_8), in.readAllBytes());\n+    }\n+\n+    \/**\n+     * Assert that a ZipEntry has the expected CRC-32, compressed size and uncompressed size values\n+     * @param entry the ZipEntry to validate\n+     * @param expectedCrc the expected CRC-32 value\n+     * @param expectedCompressedSize the exprected compressed size value\n+     * @param expectedSize the expected size value\n+     *\/\n+    private static void assertCrcAndSize(ZipEntry entry, long expectedCrc, long expectedCompressedSize, long expectedSize) {\n+        assertEquals(expectedCrc, entry.getCrc());\n+        assertEquals(expectedCompressedSize, entry.getCompressedSize());\n+        assertEquals(expectedSize, entry.getSize());\n+    }\n+\n+    \/**\n+     * Return the CRC-32 value for the given string encoded in UTF-8\n+     * @param content the string to produce a CRC-32 checksum for\n+     * @return the CRC-value of the encoded string\n+     *\/\n+    private long crc32(String content) {\n+        CRC32 crc32 = new CRC32();\n+        crc32.update(content.getBytes(StandardCharsets.UTF_8));\n+        return crc32.getValue();\n+    }\n+\n+    \/**\n+     * Return the length of the given content encoded in UTF-8\n+     * @param content the content to return the encoded length for\n+     * @return the uncompressed size of the encoded content\n+     *\/\n+    private long uncompressedSize(String content) {\n+        return content.getBytes(StandardCharsets.UTF_8).length;\n+    }\n+\n+    \/**\n+     * Returns the size of the given content, as if it was encoded in UTF-8 and then deflated\n+     * @param content the content to get the compressed size of\n+     * @return the compressed size of the content\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    private long compressedSize(String content) throws IOException {\n+        ByteArrayOutputStream bao = new ByteArrayOutputStream();\n+        try (OutputStream o = new DeflaterOutputStream(bao, new Deflater(Deflater.DEFAULT_COMPRESSION, true))) {\n+            o.write(content.getBytes(StandardCharsets.UTF_8));\n+        }\n+        return bao.size();\n+    }\n+\n+    \/**\n+     * When a ZIP entry is created in 'streaming' mode, the 'general purpose bit flag' 3\n+     * is set, and the fields crc-32, compressed size and uncompressed size are set to\n+     * zero in the local header.\n+     *\n+     * Certain legacy ZIP tools incorrectly set non-zero values for one or more of these\n+     * three fields when in streaming mode.\n+     *\n+     * This method creates a ZIP where the first entry has a local header where the\n+     * mentioned fields are set to a non-zero, incorrect values. The second entry\n+     * has the correct zero values for these fields.\n+     *\/\n+    private static byte[] zipWithIncorrectCrcAndSizeValuesInLocalHeader() throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(out)) {\n+            \/\/ Write a first entry\n+            zo.putNextEntry(new ZipEntry(\"first\"));\n+            zo.write(\"first\".getBytes(StandardCharsets.UTF_8));\n+            \/\/ Add a second entry\n+            zo.putNextEntry(new ZipEntry(\"second\"));\n+            zo.write(\"second\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        \/\/ ZipOutputStream correctly produces local headers with zero crc and sizes values\n+        byte[] zip = out.toByteArray();\n+\n+        \/\/ Buffer for updating the local header values\n+        ByteBuffer buffer = ByteBuffer.wrap(zip).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Set the CRC-32 field to an incorrect value\n+        buffer.putShort(ZipEntry.LOCCRC, (short) 42);\n+        \/\/ Set the compressed size to an incorrect value\n+        buffer.putShort(ZipEntry.LOCSIZ, (short) 42);\n+        \/\/ Set the uncompressed size to an incorrect value\n+        buffer.putShort(ZipEntry.LOCLEN, (short) 42);\n+\n+        return zip;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/DataDescriptorIgnoreCrcAndSizeFields.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4635869\n-   @summary Zip files with no extension signature would get rejected\n-   *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-\n-public class NoExtensionSignature {\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"test.zip\");\n-        ZipInputStream zis = new ZipInputStream (new FileInputStream(f));\n-        ZipEntry entry;\n-        while ((entry = zis.getNextEntry()) != null)\n-            while (zis.read() != -1 );\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/NoExtensionSignature.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"filename":"test\/jdk\/java\/util\/zip\/test.zip","binary":true,"status":"deleted"}]}