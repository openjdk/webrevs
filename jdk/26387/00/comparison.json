{"files":[{"patch":"@@ -120,1 +120,2 @@\n-          \"Options: none, nop, isb, yield, sb.\")                        \\\n+          \"Valid values are: none, nop, isb, yield, sb.\")               \\\n+          constraint(OnSpinWaitInstNameConstraintFunc, AtParse)         \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6819,0 +6819,1 @@\n+        assert(VM_Version::supports_sb(), \"current CPU does not support SB instruction\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"spin_wait_aarch64.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+#include <string.h>\n+\n+bool SpinWait::supports(const char *name) {\n+  return name != nullptr &&\n+         (strcmp(name, \"nop\")   == 0 ||\n+          strcmp(name, \"isb\")   == 0 ||\n+          strcmp(name, \"yield\") == 0 ||\n+          strcmp(name, \"sb\")    == 0 ||\n+          strcmp(name, \"none\")  == 0);\n+}\n+\n+SpinWait::Inst SpinWait::from_name(const char* name) {\n+  assert(supports(name), \"checked by OnSpinWaitInstNameConstraintFunc\");\n+\n+  if (strcmp(name, \"nop\") == 0) {\n+    return SpinWait::NOP;\n+  } else if (strcmp(name, \"isb\") == 0) {\n+    return SpinWait::ISB;\n+  } else if (strcmp(name, \"yield\") == 0) {\n+    return SpinWait::YIELD;\n+  } else if (strcmp(name, \"sb\") == 0) {\n+    return SpinWait::SB;\n+  }\n+\n+  return SpinWait::NONE;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/spin_wait_aarch64.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -22,1 +22,0 @@\n- *\n@@ -30,0 +29,4 @@\n+  \/\/ Non-zero values are chosen to have only one bit set.\n+  \/\/ This simplifies testing values in assembly code.\n+  \/\/ This limits us to 64 possible implementation.\n+  \/\/ Value 1 is used for the default implementation.\n@@ -31,5 +34,5 @@\n-    NONE = -1,\n-    NOP,\n-    ISB,\n-    YIELD,\n-    SB\n+    NONE  = 0,\n+    YIELD = (1 << 0),\n+    ISB   = (1 << 1),\n+    SB    = (1 << 2),\n+    NOP   = (1 << 3)\n@@ -42,0 +45,2 @@\n+  Inst from_name(const char *name);\n+\n@@ -43,1 +48,2 @@\n-  SpinWait(Inst inst = NONE, int count = 0) : _inst(inst), _count(count) {}\n+  SpinWait(Inst inst = NONE, int count = 0) : _inst(inst), _count(inst == NONE ? 0 : count) {}\n+  SpinWait(const char *name, int count) : SpinWait(from_name(name), count) {}\n@@ -47,0 +53,2 @@\n+\n+  static bool supports(const char *name);\n","filename":"src\/hotspot\/cpu\/aarch64\/spin_wait_aarch64.hpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -54,13 +54,3 @@\n-  if (strcmp(OnSpinWaitInst, \"nop\") == 0) {\n-    return SpinWait(SpinWait::NOP, OnSpinWaitInstCount);\n-  } else if (strcmp(OnSpinWaitInst, \"isb\") == 0) {\n-    return SpinWait(SpinWait::ISB, OnSpinWaitInstCount);\n-  } else if (strcmp(OnSpinWaitInst, \"yield\") == 0) {\n-    return SpinWait(SpinWait::YIELD, OnSpinWaitInstCount);\n-  } else if (strcmp(OnSpinWaitInst, \"sb\") == 0) {\n-    if (!VM_Version::supports_sb()) {\n-      vm_exit_during_initialization(\"OnSpinWaitInst is SB but current CPU does not support SB instruction\");\n-    }\n-    return SpinWait(SpinWait::SB, OnSpinWaitInstCount);\n-  } else if (strcmp(OnSpinWaitInst, \"none\") != 0) {\n-    vm_exit_during_initialization(\"The options for OnSpinWaitInst are nop, isb, yield, sb, and none\", OnSpinWaitInst);\n+  SpinWait spin_wait(OnSpinWaitInst, OnSpinWaitInstCount);\n+  if (spin_wait.inst() == SpinWait::SB && !VM_Version::supports_sb()) {\n+    vm_exit_during_initialization(\"OnSpinWaitInst is SB but current CPU does not support SB instruction\");\n@@ -69,5 +59,1 @@\n-  if (!FLAG_IS_DEFAULT(OnSpinWaitInstCount) && OnSpinWaitInstCount > 0) {\n-    vm_exit_during_initialization(\"OnSpinWaitInstCount cannot be used for OnSpinWaitInst 'none'\");\n-  }\n-\n-  return SpinWait{};\n+  return spin_wait;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -527,1 +528,1 @@\n-  \/\/ needs local assembler label '1:' to avoid trouble when using linktime optimization\n+  \/\/ needs local assembler label '4:' to avoid trouble when using linktime optimization\n@@ -532,13 +533,24 @@\n-    \/\/ will be a sequence of 11 instructions for NONE and YIELD and 12\n-    \/\/ instructions for NOP and ISB, SpinPause will always return 1.\n-    uint64_t br_dst;\n-    const int instructions_per_case = 2;\n-    int64_t off = VM_Version::spin_wait_desc().inst() * instructions_per_case * Assembler::instruction_size;\n-\n-    assert(VM_Version::spin_wait_desc().inst() >= SpinWait::NONE &&\n-           VM_Version::spin_wait_desc().inst() <= SpinWait::YIELD, \"must be\");\n-    assert(-1 == SpinWait::NONE,  \"must be\");\n-    assert( 0 == SpinWait::NOP,   \"must be\");\n-    assert( 1 == SpinWait::ISB,   \"must be\");\n-    assert( 2 == SpinWait::YIELD, \"must be\");\n-\n+    \/\/ will be always a sequence of instructions, SpinPause will always return 1.\n+\n+    assert(SpinWait::NONE  == 0, \"SpinWait::Inst value 0 reserved to indicate no implementation\");\n+    assert(SpinWait::YIELD == 1, \"SpinWait::Inst value 1 reserved for 'yield' instruction\");\n+    assert(SpinWait::ISB   == 2, \"SpinWait::Inst value 2 reserved for 'isb' instruction\");\n+    assert(SpinWait::SB    == 4, \"SpinWait::Inst value 4 reserved for 'sb' instruction\");\n+    assert(SpinWait::NOP   == 8, \"SpinWait::Inst value 8 reserved for 'nop' instruction\");\n+\n+    const uint64_t inst_id = VM_Version::spin_wait_desc().inst();\n+    assert(inst_id == 0 || is_power_of_2(inst_id), \"Values of SpinWait::Inst must be 0 or power of 2\");\n+    assert(inst_id != SpinWait::SB || VM_Version::supports_sb(), \"current CPU does not support SB instruction\");\n+    assert(inst_id <= SpinWait::NOP, \"Unsupported type of SpinWait::Inst: %llu\", inst_id);\n+\n+    \/\/ The assembly code below is equivalent to the following:\n+    \/\/\n+    \/\/ if (inst_id == 1) {\n+    \/\/   exec_yield_inst();\n+    \/\/ } else if (inst_id == 2) {\n+    \/\/   exec_isb_inst();\n+    \/\/ } else if (inst_id == 4) {\n+    \/\/   exec_sb_inst();\n+    \/\/ } else if (inst_id == 8) {\n+    \/\/   exec_nop_inst();\n+    \/\/ }\n@@ -546,14 +558,20 @@\n-        \"  adr  %[d], 20          \\n\" \/\/ 20 == PC here + 5 instructions => address\n-                                      \/\/ to entry for case SpinWait::NOP\n-        \"  add  %[d], %[d], %[o]  \\n\"\n-        \"  br   %[d]              \\n\"\n-        \"  b    1f                \\n\" \/\/ case SpinWait::NONE  (-1)\n-        \"  nop                    \\n\" \/\/ padding\n-        \"  nop                    \\n\" \/\/ case SpinWait::NOP   ( 0)\n-        \"  b    1f                \\n\"\n-        \"  isb                    \\n\" \/\/ case SpinWait::ISB   ( 1)\n-        \"  b    1f                \\n\"\n-        \"  yield                  \\n\" \/\/ case SpinWait::YIELD ( 2)\n-        \"1:        \\n\"\n-        : [d]\"=&r\"(br_dst)\n-        : [o]\"r\"(off)\n+        \"  tbz %[id], 0, 0f      \\n\" \/\/ The default instruction for SpinWait is YIELD.\n+                                     \/\/ We check it first before going to switch.\n+        \"  yield                 \\n\"\n+        \"  b    4f               \\n\"\n+        \"0:                      \\n\"\n+        \"  tbnz %[id], 1, 1f     \\n\"\n+        \"  tbnz %[id], 2, 2f     \\n\"\n+        \"  tbnz %[id], 3, 3f     \\n\"\n+        \"  b    4f               \\n\"\n+        \"1:                      \\n\"\n+        \"  isb                   \\n\"\n+        \"  b    4f               \\n\"\n+        \"2:                      \\n\"\n+        \"  .inst 0xd50330ff      \\n\" \/\/ SB instruction, explicitly encoded not to rely on a compiler\n+        \"  b    4f               \\n\"\n+        \"3:                      \\n\"\n+        \"  nop                   \\n\"\n+        \"4:                      \\n\"\n+        :\n+        : [id]\"r\"(inst_id)\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":46,"deletions":28,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -130,0 +130,22 @@\n+\n+JVMFlag::Error OnSpinWaitInstNameConstraintFunc(ccstr value, bool verbose) {\n+#ifdef AARCH64\n+  if (value == nullptr) {\n+    JVMFlag::printError(verbose, \"OnSpinWaitInst cannot be empty\\n\");\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+\n+  if (strcmp(value, \"nop\")   != 0 &&\n+      strcmp(value, \"isb\")   != 0 &&\n+      strcmp(value, \"yield\") != 0 &&\n+      strcmp(value, \"sb\")    != 0 &&\n+      strcmp(value, \"none\")  != 0) {\n+    JVMFlag::printError(verbose,\n+                        \"Unrecognized value %s for OnSpinWaitInst. Must be one of the following: \"\n+                        \"nop, isb, yield, sb, none\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+#endif\n+  return JVMFlag::SUCCESS;\n+}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-  f(size_t, NUMAInterleaveGranularityConstraintFunc)\n+  f(size_t, NUMAInterleaveGranularityConstraintFunc)  \\\n+  f(ccstr,  OnSpinWaitInstNameConstraintFunc)\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#if defined(AARCH64) && !defined(ZERO)\n+\n+#include \"utilities\/spinYield.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(SpinPause, sanity) {\n+  ASSERT_EQ(SpinPause(), 1);\n+}\n+\n+#endif  \/\/ AARCH64\n","filename":"test\/hotspot\/gtest\/aarch64\/test_spin_pause.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default_armv8_0\n+ * @bug 8362193\n+ * @summary Run SpinPause gtest using different instructions for SpinPause\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ * @requires os.arch==\"aarch64\"\n+ * @run main\/native GTestWrapper --gtest_filter=SpinPause*\n+ * @run main\/native GTestWrapper --gtest_filter=SpinPause* -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=none\n+ * @run main\/native GTestWrapper --gtest_filter=SpinPause* -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=nop\n+ * @run main\/native GTestWrapper --gtest_filter=SpinPause* -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=isb\n+ * @run main\/native GTestWrapper --gtest_filter=SpinPause* -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=yield\n+ *\/\n+\n+\/*\n+ * @test id=sb_armv8_5\n+ * @bug 8362193\n+ * @summary Run SpinPause gtest using SB instruction for SpinPause\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ * @requires (os.arch==\"aarch64\" & vm.cpu.features ~= \".*sb.*\")\n+ * @run main\/native GTestWrapper --gtest_filter=SpinPause* -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=sb\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/TestSpinPauseAArch64.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"}]}