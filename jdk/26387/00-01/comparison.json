{"files":[{"patch":"@@ -29,4 +29,0 @@\n-  \/\/ Non-zero values are chosen to have only one bit set.\n-  \/\/ This simplifies testing values in assembly code.\n-  \/\/ This limits us to 64 possible implementation.\n-  \/\/ Value 1 is used for the default implementation.\n@@ -34,5 +30,5 @@\n-    NONE  = 0,\n-    YIELD = (1 << 0),\n-    ISB   = (1 << 1),\n-    SB    = (1 << 2),\n-    NOP   = (1 << 3)\n+    NONE = -1,\n+    NOP,\n+    ISB,\n+    YIELD,\n+    SB\n","filename":"src\/hotspot\/cpu\/aarch64\/spin_wait_aarch64.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -528,1 +529,0 @@\n-  \/\/ needs local assembler label '4:' to avoid trouble when using linktime optimization\n@@ -534,45 +534,19 @@\n-\n-    assert(SpinWait::NONE  == 0, \"SpinWait::Inst value 0 reserved to indicate no implementation\");\n-    assert(SpinWait::YIELD == 1, \"SpinWait::Inst value 1 reserved for 'yield' instruction\");\n-    assert(SpinWait::ISB   == 2, \"SpinWait::Inst value 2 reserved for 'isb' instruction\");\n-    assert(SpinWait::SB    == 4, \"SpinWait::Inst value 4 reserved for 'sb' instruction\");\n-    assert(SpinWait::NOP   == 8, \"SpinWait::Inst value 8 reserved for 'nop' instruction\");\n-\n-    const uint64_t inst_id = VM_Version::spin_wait_desc().inst();\n-    assert(inst_id == 0 || is_power_of_2(inst_id), \"Values of SpinWait::Inst must be 0 or power of 2\");\n-    assert(inst_id != SpinWait::SB || VM_Version::supports_sb(), \"current CPU does not support SB instruction\");\n-    assert(inst_id <= SpinWait::NOP, \"Unsupported type of SpinWait::Inst: %llu\", inst_id);\n-\n-    \/\/ The assembly code below is equivalent to the following:\n-    \/\/\n-    \/\/ if (inst_id == 1) {\n-    \/\/   exec_yield_inst();\n-    \/\/ } else if (inst_id == 2) {\n-    \/\/   exec_isb_inst();\n-    \/\/ } else if (inst_id == 4) {\n-    \/\/   exec_sb_inst();\n-    \/\/ } else if (inst_id == 8) {\n-    \/\/   exec_nop_inst();\n-    \/\/ }\n-    asm volatile(\n-        \"  tbz %[id], 0, 0f      \\n\" \/\/ The default instruction for SpinWait is YIELD.\n-                                     \/\/ We check it first before going to switch.\n-        \"  yield                 \\n\"\n-        \"  b    4f               \\n\"\n-        \"0:                      \\n\"\n-        \"  tbnz %[id], 1, 1f     \\n\"\n-        \"  tbnz %[id], 2, 2f     \\n\"\n-        \"  tbnz %[id], 3, 3f     \\n\"\n-        \"  b    4f               \\n\"\n-        \"1:                      \\n\"\n-        \"  isb                   \\n\"\n-        \"  b    4f               \\n\"\n-        \"2:                      \\n\"\n-        \"  .inst 0xd50330ff      \\n\" \/\/ SB instruction, explicitly encoded not to rely on a compiler\n-        \"  b    4f               \\n\"\n-        \"3:                      \\n\"\n-        \"  nop                   \\n\"\n-        \"4:                      \\n\"\n-        :\n-        : [id]\"r\"(inst_id)\n-        : \"memory\");\n+    switch (VM_Version::spin_wait_desc().inst()) {\n+    case SpinWait::YIELD:\n+      asm volatile(\"yield\" : : : \"memory\");\n+      break;\n+    case SpinWait::ISB:\n+      asm volatile(\"isb\" : : : \"memory\");\n+      break;\n+    case SpinWait::SB:\n+      assert(VM_Version::supports_sb(), \"current CPU does not support SB instruction\");\n+      asm volatile(\".inst 0xd50330ff\" : : : \"memory\");\n+      break;\n+    case SpinWait::NOP:\n+      asm volatile(\"nop\" : : : \"memory\");\n+      break;\n+    case SpinWait::NONE:\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":20,"deletions":46,"binary":false,"changes":66,"status":"modified"}]}