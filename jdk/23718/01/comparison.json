{"files":[{"patch":"@@ -176,1 +176,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked this-escape, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked this-escape lossy-conversions, \\\n@@ -183,1 +183,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked static serial cast this-escape, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked static serial cast this-escape lossy-conversions, \\\n@@ -225,1 +225,1 @@\n-    DISABLED_WARNINGS := this-escape, \\\n+    DISABLED_WARNINGS := this-escape lossy-conversions, \\\n","filename":"make\/CompileDemos.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    DISABLED_WARNINGS := dangling-doc-comments options, \\\n+    DISABLED_WARNINGS := dangling-doc-comments options lossy-conversions, \\\n","filename":"make\/CompileToolsJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-#\n-# DISABLED_WARNINGS_java +=\n+\n+DISABLED_WARNINGS_java += lossy-conversions\n","filename":"make\/modules\/java.base\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    dangling-doc-comments fallthrough this-escape\n+    dangling-doc-comments fallthrough this-escape lossy-conversions\n","filename":"make\/modules\/jdk.hotspot.agent\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-DISABLED_WARNINGS_java += dangling-doc-comments this-escape\n+DISABLED_WARNINGS_java += dangling-doc-comments this-escape lossy-conversions\n","filename":"make\/modules\/jdk.internal.vm.ci\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-DISABLED_WARNINGS_java += dangling-doc-comments exports\n+DISABLED_WARNINGS_java += dangling-doc-comments exports lossy-conversions\n","filename":"make\/modules\/jdk.jfr\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        serial preview dangling-doc-comments, \\\n+        serial preview dangling-doc-comments lossy-conversions, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    LONG(LONG_CLASS, LONG_SUPERCLASSES, true),\n+    LONG(LONG_CLASS, LONG_SUPERCLASSES, LONG_LOSSY_SUPERCLASSES, true),\n@@ -64,1 +64,1 @@\n-    INT(INT_CLASS, INT_SUPERCLASSES, true),\n+    INT(INT_CLASS, INT_SUPERCLASSES, INT_LOSSY_SUPERCLASSES, true),\n@@ -136,0 +136,1 @@\n+    final int lossySuperClasses;\n@@ -143,1 +144,4 @@\n-        this.superClasses = superClasses;\n+        this(numericClass, superClasses, 0, isPrimitive);\n+    }\n+\n+    private TypeTag(int numericClass, int superClasses, int lossySuperClasses, boolean isPrimitive) {\n@@ -145,0 +149,2 @@\n+        this.superClasses = superClasses;\n+        this.lossySuperClasses = lossySuperClasses;\n@@ -167,0 +173,1 @@\n+        static final int INT_LOSSY_SUPERCLASSES = FLOAT_CLASS;\n@@ -169,0 +176,1 @@\n+        static final int LONG_LOSSY_SUPERCLASSES = FLOAT_CLASS | DOUBLE_CLASS;\n@@ -181,0 +189,4 @@\n+    public boolean isNumeric() {\n+        return this.numericClass != 0;\n+    }\n+\n@@ -189,0 +201,4 @@\n+    public boolean isInLossySuperclassesOf(TypeTag tag) {\n+        return (this.numericClass & tag.lossySuperClasses) != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeTag.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1324,0 +1324,2 @@\n+                chk.checkLossOfPrecision(tree.init.pos(), tree.init.type, v.type, tree.init.type.constValue(),\n+                  LintWarnings::PossibleLossOfPrecisionAssignment);\n@@ -2545,0 +2547,3 @@\n+        \/\/ The method symbol\n+        Symbol sym = null;\n+\n@@ -2623,1 +2628,1 @@\n-                Symbol sym = rs.resolveConstructor(\n+                sym = rs.resolveConstructor(\n@@ -2662,1 +2667,1 @@\n-            Symbol msym = TreeInfo.symbol(tree.meth);\n+            Symbol msym = sym = TreeInfo.symbol(tree.meth);\n@@ -2673,0 +2678,3 @@\n+        if (sym instanceof MethodSymbol msym) {\n+            chk.checkLossOfPrecision(tree.args, msym.params().map(v -> v.type));\n+        }\n@@ -3972,1 +3980,5 @@\n-        attribExpr(tree.rhs, env, owntype);\n+        Type vartype = attribExpr(tree.rhs, env, owntype);\n+        if (!owntype.isErroneous() && !capturedType.isErroneous()) {\n+            chk.checkLossOfPrecision(tree.rhs.pos(), vartype, capturedType,\n+                vartype.constValue(), LintWarnings::PossibleLossOfPrecisionAssignment);\n+        }\n@@ -3989,1 +4001,1 @@\n-            chk.checkLossOfPrecision(tree.rhs.pos(), operand, owntype);\n+            chk.checkLossOfPrecision(tree.rhs.pos(), operand, owntype, null, LintWarnings::PossibleLossOfPrecision);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.BiFunction;\n@@ -105,0 +106,1 @@\n+    private final ConstFold cfolder;\n@@ -144,0 +146,1 @@\n+        cfolder = ConstFold.instance(context);;\n@@ -4123,4 +4126,22 @@\n-     *  Check for possible loss of precission\n-     *  @param pos           Position for error reporting.\n-     *  @param found    The computed type of the tree\n-     *  @param req  The computed type of the tree\n+     *  Check for possible loss of precision in the parameters to a method.\n+     *  @param actual   Actual parameters\n+     *  @param formal   Formal parameters\n+     *\/\n+    void checkLossOfPrecision(List<JCExpression> actual, List<Type> formal) {\n+        while (!formal.isEmpty() && !actual.isEmpty()) {\n+            Type actualType = actual.head.type;\n+            Type formalType = formal.head;\n+            checkLossOfPrecision(actual.head.pos(), actualType, formalType,\n+                actualType.constValue(), LintWarnings::PossibleLossOfPrecisionParameter);\n+            formal = formal.tail;\n+            actual = actual.tail;\n+        }\n+    }\n+\n+    \/**\n+     *  Check for possible loss of precision.\n+     *  @param pos          Position for error reporting\n+     *  @param srcType      The type being assigned from\n+     *  @param dstType      The type being assigned to\n+     *  @param constValue   The value being assigned if known, else null\n+     *  @param builder      Warning builder\n@@ -4128,4 +4149,7 @@\n-    void checkLossOfPrecision(final DiagnosticPosition pos, Type found, Type req) {\n-        if (found.isNumeric() && req.isNumeric() && !types.isAssignable(found, req)) {\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PossibleLossOfPrecision(found, req)));\n+    void checkLossOfPrecision(DiagnosticPosition pos, Type srcType, Type dstType,\n+            Object constValue, BiFunction<Type, Type, LintWarning> builder) {\n+        if (srcType.isNumeric() && dstType.isNumeric() &&\n+            (!types.isAssignable(srcType, dstType) ||\n+              (dstType.getTag().isInLossySuperclassesOf(srcType.getTag()) &&\n+                (constValue == null || !cfolder.isExact(srcType, dstType, (Number)constValue))))) {\n+            deferredLintHandler.report(_ -> lint.logIfEnabled(pos, builder.apply(srcType, dstType)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.lang.runtime.ExactConversionsSupport;\n+\n@@ -339,0 +341,66 @@\n+\n+    \/** Determine if the given coercion between numeric types loses information.\n+     *  @param srcType  The type being assigned from\n+     *  @param dstType  The type being assigned to\n+     *  @param value    The value being assigned\n+     *\/\n+    boolean isExact(Type srcType, Type dstType, Number value) {\n+        Assert.check(srcType.getTag().isNumeric() && dstType.getTag().isNumeric());\n+        switch (srcType.getTag()) {\n+        case BYTE:\n+            switch (dstType.getTag()) {\n+            case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+            }\n+            break;\n+        case CHAR:\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+            case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+            }\n+            break;\n+        case SHORT:\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+            case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+            }\n+            break;\n+        case INT:\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+            case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+            case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+            case FLOAT:     return ExactConversionsSupport.isIntToFloatExact(value.intValue());\n+            }\n+            break;\n+        case FLOAT:\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isFloatToByteExact(value.floatValue());\n+            case CHAR:      return ExactConversionsSupport.isFloatToCharExact(value.floatValue());\n+            case SHORT:     return ExactConversionsSupport.isFloatToShortExact(value.floatValue());\n+            case INT:       return ExactConversionsSupport.isFloatToIntExact(value.floatValue());\n+            case LONG:      return ExactConversionsSupport.isFloatToLongExact(value.floatValue());\n+            }\n+            break;\n+        case LONG:\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isLongToByteExact(value.longValue());\n+            case CHAR:      return ExactConversionsSupport.isLongToCharExact(value.longValue());\n+            case SHORT:     return ExactConversionsSupport.isLongToShortExact(value.longValue());\n+            case INT:       return ExactConversionsSupport.isLongToIntExact(value.longValue());\n+            case FLOAT:     return ExactConversionsSupport.isLongToFloatExact(value.longValue());\n+            case DOUBLE:    return ExactConversionsSupport.isLongToDoubleExact(value.longValue());\n+            }\n+            break;\n+        case DOUBLE:\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isDoubleToByteExact(value.doubleValue());\n+            case CHAR:      return ExactConversionsSupport.isDoubleToCharExact(value.doubleValue());\n+            case SHORT:     return ExactConversionsSupport.isDoubleToShortExact(value.doubleValue());\n+            case INT:       return ExactConversionsSupport.isDoubleToIntExact(value.doubleValue());\n+            case FLOAT:     return ExactConversionsSupport.isDoubleToFloatExact(value.doubleValue());\n+            case LONG:      return ExactConversionsSupport.isDoubleToLongExact(value.doubleValue());\n+            }\n+            break;\n+        }\n+        return true;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ConstFold.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2799,0 +2799,10 @@\n+# 0: type, 1: type\n+# lint: lossy-conversions\n+compiler.warn.possible.loss.of.precision.assignment=\\\n+    implicit cast from {0} to {1} in assignment is possibly lossy\n+\n+# 0: type, 1: type\n+# lint: lossy-conversions\n+compiler.warn.possible.loss.of.precision.parameter=\\\n+    implicit cast from {0} to {1} in parameter is possibly lossy\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+\/\/ key: compiler.warn.possible.loss.of.precision.assignment\n+\/\/ key: compiler.warn.possible.loss.of.precision.parameter\n@@ -29,1 +31,5 @@\n-        a += 1.0;\n+        a += 1.0;               \/\/ compound\n+        float b = 0x10000001;   \/\/ assignment\n+        m2(0x10000001);         \/\/ parameter\n+    }\n+    void m2(float f) {\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/LossyConversion.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n- * @compile\/fail\/ref=LossyConversions.out -XDrawDiagnostics -Xmaxwarns 200 -Xlint:lossy-conversions -Werror LossyConversions.java\n+ * @compile\/fail\/ref=LossyConversions.out -XDrawDiagnostics -Xmaxwarns 300 -Xlint:lossy-conversions -Werror LossyConversions.java\n@@ -116,2 +116,2 @@\n-        e += c; e -= c; e *= c; e \/= c; \/\/no warnings\n-        e += d; e -= d; e *= d; e \/= d; \/\/no warnings\n+        e += c; e -= c; e *= c; e \/= c;\n+        e += d; e -= d; e *= d; e \/= d;\n@@ -124,1 +124,1 @@\n-        f += d; f -= d; f *= d; f \/= d; \/\/no warnings\n+        f += d; f -= d; f *= d; f \/= d;\n@@ -192,0 +192,51 @@\n+\n+    public static final int INT2FLOAT_SAFE   = 0x10000000;\n+    public static final int INT2FLOAT_UNSAFE = 0x10000001;\n+\n+    public static final long LONG2FLOAT_SAFE   = 0x10000000L;\n+    public static final long LONG2FLOAT_UNSAFE = 0x10000001L;\n+\n+    public static final long LONG2DOUBLE_SAFE   = 0x1000000000000000L;\n+    public static final long LONG2DOUBLE_UNSAFE = 0x1000000000000001L;\n+\n+    public void lossyAssignments() {\n+\n+        float f;\n+        double d;\n+\n+        f = INT2FLOAT_SAFE;             \/\/ no warning\n+        f = INT2FLOAT_UNSAFE;\n+        f = Integer.MIN_VALUE;          \/\/ no warning\n+        f = Integer.MAX_VALUE;\n+\n+        f = LONG2FLOAT_SAFE;            \/\/ no warning\n+        f = LONG2FLOAT_UNSAFE;\n+        f = Long.MIN_VALUE;             \/\/ no warning\n+        f = Long.MAX_VALUE;\n+\n+        d = LONG2DOUBLE_SAFE;           \/\/ no warning\n+        d = LONG2DOUBLE_UNSAFE;\n+        d = Long.MIN_VALUE;             \/\/ no warning\n+        d = Long.MAX_VALUE;\n+\n+        floatMethod(INT2FLOAT_SAFE);    \/\/ no warning\n+        floatMethod(INT2FLOAT_UNSAFE);\n+        floatMethod(Integer.MIN_VALUE); \/\/ no warning\n+        floatMethod(Integer.MAX_VALUE);\n+\n+        floatMethod(LONG2FLOAT_SAFE);   \/\/ no warning\n+        floatMethod(LONG2FLOAT_UNSAFE);\n+        floatMethod(Long.MIN_VALUE);    \/\/ no warning\n+        floatMethod(Long.MAX_VALUE);\n+\n+        doubleMethod(LONG2DOUBLE_SAFE); \/\/ no warning\n+        doubleMethod(LONG2DOUBLE_UNSAFE);\n+        doubleMethod(Long.MIN_VALUE);   \/\/ no warning\n+        doubleMethod(Long.MAX_VALUE);\n+    }\n+\n+    public void floatMethod(float x) {\n+    }\n+\n+    public void doubleMethod(double x) {\n+    }\n","filename":"test\/langtools\/tools\/javac\/lint\/LossyConversions.java","additions":55,"deletions":4,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -173,0 +173,8 @@\n+LossyConversions.java:116:14: compiler.warn.possible.loss.of.precision: int, float\n+LossyConversions.java:116:22: compiler.warn.possible.loss.of.precision: int, float\n+LossyConversions.java:116:30: compiler.warn.possible.loss.of.precision: int, float\n+LossyConversions.java:116:38: compiler.warn.possible.loss.of.precision: int, float\n+LossyConversions.java:117:14: compiler.warn.possible.loss.of.precision: long, float\n+LossyConversions.java:117:22: compiler.warn.possible.loss.of.precision: long, float\n+LossyConversions.java:117:30: compiler.warn.possible.loss.of.precision: long, float\n+LossyConversions.java:117:38: compiler.warn.possible.loss.of.precision: long, float\n@@ -177,0 +185,16 @@\n+LossyConversions.java:124:14: compiler.warn.possible.loss.of.precision: long, double\n+LossyConversions.java:124:22: compiler.warn.possible.loss.of.precision: long, double\n+LossyConversions.java:124:30: compiler.warn.possible.loss.of.precision: long, double\n+LossyConversions.java:124:38: compiler.warn.possible.loss.of.precision: long, double\n+LossyConversions.java:208:13: compiler.warn.possible.loss.of.precision.assignment: int, float\n+LossyConversions.java:210:20: compiler.warn.possible.loss.of.precision.assignment: int, float\n+LossyConversions.java:213:13: compiler.warn.possible.loss.of.precision.assignment: long, float\n+LossyConversions.java:215:17: compiler.warn.possible.loss.of.precision.assignment: long, float\n+LossyConversions.java:218:13: compiler.warn.possible.loss.of.precision.assignment: long, double\n+LossyConversions.java:220:17: compiler.warn.possible.loss.of.precision.assignment: long, double\n+LossyConversions.java:223:21: compiler.warn.possible.loss.of.precision.parameter: int, float\n+LossyConversions.java:225:28: compiler.warn.possible.loss.of.precision.parameter: int, float\n+LossyConversions.java:228:21: compiler.warn.possible.loss.of.precision.parameter: long, float\n+LossyConversions.java:230:25: compiler.warn.possible.loss.of.precision.parameter: long, float\n+LossyConversions.java:233:22: compiler.warn.possible.loss.of.precision.parameter: long, double\n+LossyConversions.java:235:26: compiler.warn.possible.loss.of.precision.parameter: long, double\n@@ -179,1 +203,1 @@\n-176 warnings\n+200 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/LossyConversions.out","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}