{"files":[{"patch":"@@ -189,0 +189,4 @@\n+    public boolean isNumeric() {\n+        return this.numericClass != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeTag.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4154,2 +4154,1 @@\n-                (constValue == null ||\n-                  !constValue.equals(cfolder.fold(cfolder.fold((Number)constValue, dstType), srcType)))))) {\n+                (constValue == null || !cfolder.isExact(srcType, dstType, (Number)constValue))))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.lang.runtime.ExactConversionsSupport;\n+\n@@ -319,1 +321,1 @@\n-             Number folded = fold((Number)etype.constValue(), ttype);\n+             Object n = etype.constValue();\n@@ -322,1 +324,1 @@\n-                 return syms.byteType.constType(folded);\n+                 return syms.byteType.constType(0 + (byte)intValue(n));\n@@ -324,1 +326,1 @@\n-                 return syms.charType.constType(folded);\n+                 return syms.charType.constType(0 + (char)intValue(n));\n@@ -326,1 +328,1 @@\n-                 return syms.shortType.constType(folded);\n+                 return syms.shortType.constType(0 + (short)intValue(n));\n@@ -328,1 +330,1 @@\n-                 return syms.intType.constType(folded);\n+                 return syms.intType.constType(intValue(n));\n@@ -330,1 +332,1 @@\n-                 return syms.longType.constType(folded);\n+                 return syms.longType.constType(longValue(n));\n@@ -332,1 +334,1 @@\n-                 return syms.floatType.constType(folded);\n+                 return syms.floatType.constType(floatValue(n));\n@@ -334,1 +336,1 @@\n-                 return syms.doubleType.constType(folded);\n+                 return syms.doubleType.constType(doubleValue(n));\n@@ -340,5 +342,4 @@\n-    \/** Fold the given numeric constant to fit into the target numeric type.\n-     *  For types smaller than 32 bits, {@link Integer}s are returned.\n-     *  @param value      constant value\n-     *  @param ttype      The target type of the coercion\n-     *  @return folded value, or null if operation is invalid\n+    \/** Determine if the given coercion between numeric types loses information.\n+     *  @param srcType  The type being assigned from\n+     *  @param dstType  The type being assigned to\n+     *  @param value    The value being assigned\n@@ -346,2 +347,3 @@\n-    Number fold(Number value, Type ttype) {\n-        switch (ttype.getTag()) {\n+    boolean isExact(Type srcType, Type dstType, Number value) {\n+        Assert.check(srcType.getTag().isNumeric() && dstType.getTag().isNumeric());\n+        switch (srcType.getTag()) {\n@@ -349,1 +351,4 @@\n-            return (int)value.byteValue();\n+            switch (dstType.getTag()) {\n+            case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+            }\n+            break;\n@@ -351,1 +356,5 @@\n-            return (int)(char)value.intValue();\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+            case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+            }\n+            break;\n@@ -353,1 +362,5 @@\n-            return (int)value.shortValue();\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+            case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+            }\n+            break;\n@@ -355,3 +368,7 @@\n-            return value.intValue();\n-        case LONG:\n-            return value.longValue();\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+            case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+            case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+            case FLOAT:     return ExactConversionsSupport.isIntToFloatExact(value.intValue());\n+            }\n+            break;\n@@ -359,1 +376,18 @@\n-            return value.floatValue();\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isFloatToByteExact(value.floatValue());\n+            case CHAR:      return ExactConversionsSupport.isFloatToCharExact(value.floatValue());\n+            case SHORT:     return ExactConversionsSupport.isFloatToShortExact(value.floatValue());\n+            case INT:       return ExactConversionsSupport.isFloatToIntExact(value.floatValue());\n+            case LONG:      return ExactConversionsSupport.isFloatToLongExact(value.floatValue());\n+            }\n+            break;\n+        case LONG:\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isLongToByteExact(value.longValue());\n+            case CHAR:      return ExactConversionsSupport.isLongToCharExact(value.longValue());\n+            case SHORT:     return ExactConversionsSupport.isLongToShortExact(value.longValue());\n+            case INT:       return ExactConversionsSupport.isLongToIntExact(value.longValue());\n+            case FLOAT:     return ExactConversionsSupport.isLongToFloatExact(value.longValue());\n+            case DOUBLE:    return ExactConversionsSupport.isLongToDoubleExact(value.longValue());\n+            }\n+            break;\n@@ -361,3 +395,9 @@\n-            return value.doubleValue();\n-        default:\n-            return null;\n+            switch (dstType.getTag()) {\n+            case BYTE:      return ExactConversionsSupport.isDoubleToByteExact(value.doubleValue());\n+            case CHAR:      return ExactConversionsSupport.isDoubleToCharExact(value.doubleValue());\n+            case SHORT:     return ExactConversionsSupport.isDoubleToShortExact(value.doubleValue());\n+            case INT:       return ExactConversionsSupport.isDoubleToIntExact(value.doubleValue());\n+            case FLOAT:     return ExactConversionsSupport.isDoubleToFloatExact(value.doubleValue());\n+            case LONG:      return ExactConversionsSupport.isDoubleToLongExact(value.doubleValue());\n+            }\n+            break;\n@@ -365,0 +405,1 @@\n+        return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ConstFold.java","additions":66,"deletions":25,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n- * @compile\/fail\/ref=LossyConversions.out -XDrawDiagnostics -Xmaxwarns 200 -Xlint:lossy-conversions -Werror LossyConversions.java\n+ * @compile\/fail\/ref=LossyConversions.out -XDrawDiagnostics -Xmaxwarns 300 -Xlint:lossy-conversions -Werror LossyConversions.java\n@@ -209,0 +209,2 @@\n+        f = Integer.MIN_VALUE;          \/\/ no warning\n+        f = Integer.MAX_VALUE;\n@@ -212,0 +214,2 @@\n+        f = Long.MIN_VALUE;             \/\/ no warning\n+        f = Long.MAX_VALUE;\n@@ -215,0 +219,2 @@\n+        d = Long.MIN_VALUE;             \/\/ no warning\n+        d = Long.MAX_VALUE;\n@@ -218,0 +224,2 @@\n+        floatMethod(Integer.MIN_VALUE); \/\/ no warning\n+        floatMethod(Integer.MAX_VALUE);\n@@ -221,0 +229,2 @@\n+        floatMethod(Long.MIN_VALUE);    \/\/ no warning\n+        floatMethod(Long.MAX_VALUE);\n@@ -224,0 +234,2 @@\n+        doubleMethod(Long.MIN_VALUE);   \/\/ no warning\n+        doubleMethod(Long.MAX_VALUE);\n","filename":"test\/langtools\/tools\/javac\/lint\/LossyConversions.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -190,5 +190,11 @@\n-LossyConversions.java:211:13: compiler.warn.possible.loss.of.precision.assignment: long, float\n-LossyConversions.java:214:13: compiler.warn.possible.loss.of.precision.assignment: long, double\n-LossyConversions.java:217:21: compiler.warn.possible.loss.of.precision.parameter: int, float\n-LossyConversions.java:220:21: compiler.warn.possible.loss.of.precision.parameter: long, float\n-LossyConversions.java:223:22: compiler.warn.possible.loss.of.precision.parameter: long, double\n+LossyConversions.java:210:20: compiler.warn.possible.loss.of.precision.assignment: int, float\n+LossyConversions.java:213:13: compiler.warn.possible.loss.of.precision.assignment: long, float\n+LossyConversions.java:215:17: compiler.warn.possible.loss.of.precision.assignment: long, float\n+LossyConversions.java:218:13: compiler.warn.possible.loss.of.precision.assignment: long, double\n+LossyConversions.java:220:17: compiler.warn.possible.loss.of.precision.assignment: long, double\n+LossyConversions.java:223:21: compiler.warn.possible.loss.of.precision.parameter: int, float\n+LossyConversions.java:225:28: compiler.warn.possible.loss.of.precision.parameter: int, float\n+LossyConversions.java:228:21: compiler.warn.possible.loss.of.precision.parameter: long, float\n+LossyConversions.java:230:25: compiler.warn.possible.loss.of.precision.parameter: long, float\n+LossyConversions.java:233:22: compiler.warn.possible.loss.of.precision.parameter: long, double\n+LossyConversions.java:235:26: compiler.warn.possible.loss.of.precision.parameter: long, double\n@@ -197,1 +203,1 @@\n-194 warnings\n+200 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/LossyConversions.out","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"}]}