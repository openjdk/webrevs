{"files":[{"patch":"@@ -3255,0 +3255,2 @@\n+      set_numa_bitmask_equal(CAST_TO_FN_PTR(numa_bitmask_equal_func_t,\n+                                            libnuma_dlsym(handle, \"numa_bitmask_equal\")));\n@@ -3265,0 +3267,2 @@\n+      set_numa_get_run_node_mask(CAST_TO_FN_PTR(numa_get_run_node_mask_func_t,\n+                                                libnuma_v2_dlsym(handle, \"numa_get_run_node_mask\")));\n@@ -3272,0 +3276,1 @@\n+        set_numa_cpunodebind_bitmask(_numa_get_run_node_mask());\n@@ -3448,0 +3453,1 @@\n+os::Linux::numa_bitmask_equal_func_t os::Linux::_numa_bitmask_equal;\n@@ -3451,0 +3457,1 @@\n+os::Linux::numa_get_run_node_mask_func_t os::Linux::_numa_get_run_node_mask;\n@@ -3459,0 +3466,1 @@\n+struct bitmask* os::Linux::_numa_cpunodebind_bitmask;\n@@ -4483,2 +4491,1 @@\n-    FLAG_SET_ERGO(UseNUMA, false);\n-    FLAG_SET_ERGO(UseNUMAInterleaving, false); \/\/ Also depends on libnuma.\n+    disable_numa(\"Failed to initialize libnuma\");\n@@ -4486,4 +4493,7 @@\n-    if ((Linux::numa_max_node() < 1) || Linux::is_bound_to_single_node()) {\n-      \/\/ If there's only one node (they start from 0) or if the process\n-      \/\/ is bound explicitly to a single node using membind, disable NUMA\n-      UseNUMA = false;\n+    Linux::set_configured_numa_policy(Linux::identify_numa_policy());\n+    if (Linux::numa_max_node() < 1) {\n+      disable_numa(\"Only a single NUMA node is available\");\n+    } else if (Linux::is_bound_to_single_mem_node()) {\n+      disable_numa(\"The process is bound to a single NUMA node\");\n+    } else if (Linux::mem_and_cpu_node_mismatch()) {\n+      disable_numa(\"The process memory and cpu node configuration does not match\");\n@@ -4494,2 +4504,0 @@\n-      Linux::set_configured_numa_policy(Linux::identify_numa_policy());\n-\n@@ -4533,0 +4541,10 @@\n+void os::Linux::disable_numa(const char* reason) {\n+  if ((UseNUMA && FLAG_IS_CMDLINE(UseNUMA)) ||\n+      (UseNUMAInterleaving && FLAG_IS_CMDLINE(UseNUMAInterleaving))) {\n+    \/\/ Only issue a warning if the user explicitly asked for NUMA support\n+    log_warning(os)(\"NUMA support disabled: %s\", reason);\n+  }\n+  FLAG_SET_ERGO(UseNUMA, false);\n+  FLAG_SET_ERGO(UseNUMAInterleaving, false);\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -196,0 +196,1 @@\n+  static void disable_numa(const char* reason);\n@@ -207,0 +208,1 @@\n+  typedef struct bitmask* (*numa_get_run_node_mask_func_t)(void);\n@@ -211,0 +213,1 @@\n+  typedef int (*numa_bitmask_equal_func_t)(struct bitmask *bmp1, struct bitmask *bmp2);\n@@ -224,0 +227,1 @@\n+  static numa_bitmask_equal_func_t _numa_bitmask_equal;\n@@ -226,0 +230,1 @@\n+  static numa_get_run_node_mask_func_t _numa_get_run_node_mask;\n@@ -234,0 +239,1 @@\n+  static struct bitmask* _numa_cpunodebind_bitmask;\n@@ -246,0 +252,1 @@\n+  static void set_numa_bitmask_equal(numa_bitmask_equal_func_t func) { _numa_bitmask_equal = func; }\n@@ -248,0 +255,1 @@\n+  static void set_numa_get_run_node_mask(numa_get_run_node_mask_func_t func) { _numa_get_run_node_mask = func; }\n@@ -256,0 +264,1 @@\n+  static void set_numa_cpunodebind_bitmask(struct bitmask* ptr)        { _numa_cpunodebind_bitmask = ptr ;      }\n@@ -361,3 +370,3 @@\n-  \/\/ Check if bound to only one numa node.\n-  \/\/ Returns true if bound to a single numa node, otherwise returns false.\n-  static bool is_bound_to_single_node() {\n+  \/\/ Check if memory is bound to only one numa node.\n+  \/\/ Returns true if memory is bound to a single numa node, otherwise returns false.\n+  static bool is_bound_to_single_mem_node() {\n@@ -368,1 +377,6 @@\n-    if (_numa_membind_bitmask != nullptr && _numa_max_node != nullptr && _numa_bitmask_isbitset != nullptr) {\n+    struct bitmask* mem_nodes_bitmask = Linux::_numa_membind_bitmask;\n+    if (Linux::is_running_in_interleave_mode()) {\n+      mem_nodes_bitmask = Linux::_numa_interleave_bitmask;\n+    }\n+\n+    if (mem_nodes_bitmask != nullptr && _numa_max_node != nullptr && _numa_bitmask_isbitset != nullptr) {\n@@ -375,1 +389,1 @@\n-      if (_numa_bitmask_isbitset(_numa_membind_bitmask, node)) {\n+      if (_numa_bitmask_isbitset(mem_nodes_bitmask, node)) {\n@@ -386,0 +400,13 @@\n+  \/\/ Check if cpu and memory nodes are aligned, returns true if nodes misalign\n+  static bool mem_and_cpu_node_mismatch() {\n+    struct bitmask* mem_nodes_bitmask = Linux::_numa_membind_bitmask;\n+    if (Linux::is_running_in_interleave_mode()) {\n+      mem_nodes_bitmask = Linux::_numa_interleave_bitmask;\n+    }\n+\n+    if (mem_nodes_bitmask == nullptr || Linux::_numa_cpunodebind_bitmask == nullptr) {\n+      return false;\n+    }\n+\n+    return !_numa_bitmask_equal(mem_nodes_bitmask, Linux::_numa_cpunodebind_bitmask);\n+  }\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"}]}