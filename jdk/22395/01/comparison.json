{"files":[{"patch":"@@ -3255,0 +3255,2 @@\n+      set_numa_bitmask_equal(CAST_TO_FN_PTR(numa_bitmask_equal_func_t,\n+                                            libnuma_dlsym(handle, \"numa_bitmask_equal\")));\n@@ -3265,0 +3267,2 @@\n+      set_numa_get_run_node_mask(CAST_TO_FN_PTR(numa_get_run_node_mask_func_t,\n+                                                libnuma_v2_dlsym(handle, \"numa_get_run_node_mask\")));\n@@ -3272,0 +3276,1 @@\n+        set_numa_cpunodebind_bitmask(_numa_get_run_node_mask());\n@@ -3448,0 +3453,1 @@\n+os::Linux::numa_bitmask_equal_func_t os::Linux::_numa_bitmask_equal;\n@@ -3451,0 +3457,1 @@\n+os::Linux::numa_get_run_node_mask_func_t os::Linux::_numa_get_run_node_mask;\n@@ -3459,0 +3466,1 @@\n+struct bitmask* os::Linux::_numa_cpunodebind_bitmask;\n@@ -4481,0 +4489,1 @@\n+  \/\/ TBD Add notes about other policies and cpunodebind.\n@@ -4483,0 +4492,5 @@\n+    if ((UseNUMA && FLAG_IS_CMDLINE(UseNUMA)) ||\n+        (UseNUMAInterleaving && FLAG_IS_CMDLINE(UseNUMAInterleaving))) {\n+      \/\/ Only issue a warning if the user explicitly asked for NUMA support\n+      log_warning(os)(\"NUMA support is disabled as libnuma not initialized\");\n+    }\n@@ -4486,4 +4500,17 @@\n-    if ((Linux::numa_max_node() < 1) || Linux::is_bound_to_single_node()) {\n-      \/\/ If there's only one node (they start from 0) or if the process\n-      \/\/ is bound explicitly to a single node using membind, disable NUMA\n-      UseNUMA = false;\n+    Linux::set_configured_numa_policy(Linux::identify_numa_policy());\n+    if (Linux::numa_max_node() < 1 ||\n+        Linux::is_bound_to_single_mem_node() ||\n+        Linux::mem_and_cpu_node_mismatch()) {\n+      \/\/ Disable NUMA support if:\n+      \/\/ 1. Only a single NUMA node is available\n+      \/\/ 2. The process is bound to a single NUMA node\n+      \/\/ 3. The process memory and cpu node configuration is misaligned\n+      if ((UseNUMA && FLAG_IS_CMDLINE(UseNUMA)) ||\n+          (UseNUMAInterleaving && FLAG_IS_CMDLINE(UseNUMAInterleaving))) {\n+        \/\/ Only issue a warning if the user explicitly asked for NUMA support\n+       log_warning(os)(\"NUMA support is disabled as the process bound to a single\"\n+                       \" numa node or cpu and memory nodes are not aligned\");\n+      }\n+      FLAG_SET_ERGO(UseNUMA, false);\n+      FLAG_SET_ERGO(UseNUMAInterleaving, false);\n+\n@@ -4494,2 +4521,0 @@\n-      Linux::set_configured_numa_policy(Linux::identify_numa_policy());\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -207,0 +207,1 @@\n+  typedef struct bitmask* (*numa_get_run_node_mask_func_t)(void);\n@@ -211,0 +212,1 @@\n+  typedef int (*numa_bitmask_equal_func_t)(struct bitmask *bmp1, struct bitmask *bmp2);\n@@ -224,0 +226,1 @@\n+  static numa_bitmask_equal_func_t _numa_bitmask_equal;\n@@ -226,0 +229,1 @@\n+  static numa_get_run_node_mask_func_t _numa_get_run_node_mask;\n@@ -234,0 +238,1 @@\n+  static struct bitmask* _numa_cpunodebind_bitmask;\n@@ -246,0 +251,1 @@\n+  static void set_numa_bitmask_equal(numa_bitmask_equal_func_t func) { _numa_bitmask_equal = func; }\n@@ -248,0 +254,1 @@\n+  static void set_numa_get_run_node_mask(numa_get_run_node_mask_func_t func) { _numa_get_run_node_mask = func; }\n@@ -256,0 +263,1 @@\n+  static void set_numa_cpunodebind_bitmask(struct bitmask* ptr)        { _numa_cpunodebind_bitmask = ptr ;      }\n@@ -363,1 +371,1 @@\n-  static bool is_bound_to_single_node() {\n+  static bool is_bound_to_single_mem_node() {\n@@ -368,1 +376,6 @@\n-    if (_numa_membind_bitmask != nullptr && _numa_max_node != nullptr && _numa_bitmask_isbitset != nullptr) {\n+    struct bitmask* mem_nodes_bitmask = Linux::_numa_membind_bitmask;\n+    if (Linux::is_running_in_interleave_mode()) {\n+      mem_nodes_bitmask = Linux::_numa_interleave_bitmask;\n+    }\n+\n+    if (mem_nodes_bitmask != nullptr && _numa_max_node != nullptr && _numa_bitmask_isbitset != nullptr) {\n@@ -375,1 +388,1 @@\n-      if (_numa_bitmask_isbitset(_numa_membind_bitmask, node)) {\n+      if (_numa_bitmask_isbitset(mem_nodes_bitmask, node)) {\n@@ -386,0 +399,13 @@\n+  \/\/ Check if cpu and memory nodes are aligned, returns true if nodes misalign\n+  static bool mem_and_cpu_node_mismatch() {\n+    struct bitmask* mem_nodes_bitmask = Linux::_numa_membind_bitmask;\n+    if (Linux::is_running_in_interleave_mode()) {\n+      mem_nodes_bitmask = Linux::_numa_interleave_bitmask;\n+    }\n+\n+    if (mem_nodes_bitmask == nullptr || Linux::_numa_cpunodebind_bitmask == nullptr) {\n+      return false;\n+    }\n+\n+    return !_numa_bitmask_equal(mem_nodes_bitmask, Linux::_numa_cpunodebind_bitmask);\n+  }\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"}]}